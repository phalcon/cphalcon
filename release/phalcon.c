
/*
  +------------------------------------------------------------------------+
  | Phalcon Framework                                                      |
  +------------------------------------------------------------------------+
  | Copyright (c) 2011-2012 Phalcon Team (http://www.phalconphp.com)       |
  +------------------------------------------------------------------------+
  | This source file is subject to the New BSD License that is bundled     |
  | with this package in the file docs/LICENSE.txt.                        |
  |                                                                        |
  | If you did not receive a copy of the license and are unable to         |
  | obtain it through the world-wide-web, please send an email             |
  | to license@phalconphp.com so we can send you a copy immediately.       |
  +------------------------------------------------------------------------+
  | Authors: Andres Gutierrez <andres@phalconphp.com>                      |
  |          Eduar Carvajal <eduar@phalconphp.com>                         |
  +------------------------------------------------------------------------+
*/


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_phalcon.h"
#include "phalcon.h"

#include "main/php_main.h"
#include "ext/standard/php_string.h"

#include "Zend/zend_API.h"
#include "Zend/zend_operators.h"
#include "Zend/zend_exceptions.h"
#include "Zend/zend_interfaces.h"
#include "Zend/zend_execute.h"


/** Main macros */
#define PH_DEBUG 0

#define PH_NOISY 0
#define PH_SILENT 1

#define PH_NOISY_CC PH_NOISY TSRMLS_CC
#define PH_SILENT_CC PH_SILENT TSRMLS_CC

#define PH_CHECK 1
#define PH_NO_CHECK 0

#define PH_SEPARATE 256
#define PH_COPY 1024
#define PH_CTOR 4096

#define PH_FETCH_CLASS_SILENT (zend_bool) ZEND_FETCH_CLASS_SILENT TSRMLS_CC

/** Experimental Features **/
#define PH_EXPERIMENTAL_CALL 0

/** Check whether we can use experimental call yet */
#ifdef PHP_WIN32
#define PH_EXPERIMENTAL_CALL 0
#else
#if PHP_VERSION_ID < 50400
#define PH_EXPERIMENTAL_CALL 0
#endif
#endif

#define SL(str) ZEND_STRL(str)

/** SPL dependencies */
#if defined(HAVE_SPL) && ((PHP_MAJOR_VERSION > 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 1))
extern ZEND_API zend_class_entry *zend_ce_iterator;
extern ZEND_API zend_class_entry *zend_ce_arrayaccess;
extern ZEND_API zend_class_entry *zend_ce_serializable;
extern PHPAPI zend_class_entry *spl_ce_RuntimeException;
extern PHPAPI zend_class_entry *spl_ce_Countable;
extern PHPAPI zend_class_entry *spl_ce_SeekableIterator;
#endif

/** Startup functions */
void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC);

/** Globals functions */
int phalcon_init_global(char *global, int global_length TSRMLS_DC);
int phalcon_get_global(zval **arr, char *global, int global_length TSRMLS_DC);
int phalcon_get_global_by_index(char *global, char *index, zval *result TSRMLS_DC);


int phalcon_file_exists(zval *filename TSRMLS_DC);

/** Function replacement **/
void phalcon_fast_count(zval *result, zval *array TSRMLS_DC);
void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC);
void phalcon_fast_explode(zval *result, zval *delimiter, zval *str TSRMLS_DC);
void phalcon_fast_strpos(zval *return_value, zval *haystack, zval *needle TSRMLS_DC);
void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject TSRMLS_DC);

/** Low level filters */
int phalcon_filter_alphanum(zval *result, zval *param);

/* Utils functions */
void phalcon_inherit_not_found(char *class_name, char *inherit_name);
int phalcon_valid_foreach(zval *arr TSRMLS_DC);

/** Export symbols to active symbol table */
int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC);

/** Compatibility with PHP 5.3 */
#ifndef ZVAL_COPY_VALUE
 #define ZVAL_COPY_VALUE(z, v)\
  (z)->value = (v)->value;\
  Z_TYPE_P(z) = Z_TYPE_P(v);
#endif

#ifndef INIT_PZVAL_COPY
 #define INIT_PZVAL_COPY(z, v) ZVAL_COPY_VALUE(z, v);\
  Z_SET_REFCOUNT_P(z, 1);\
  Z_UNSET_ISREF_P(z);
#endif

/** Symbols */
#define PHALCON_READ_SYMBOL(var, auxarr, name) if(EG(active_symbol_table)){\
	if (zend_hash_find(EG(active_symbol_table), name, sizeof(name), (void **)  &auxarr) == SUCCESS) { \
			var = *auxarr; \
		} else { \
			ZVAL_NULL(var); \
		} \
	} else { \
		ZVAL_NULL(var); \
	}

/**
 * Return zval checking if it's needed to ctor
 */
#define RETURN_CCTOR(var) { \
		zend_uchar is_ref = Z_ISREF_P(return_value); \
		zend_uint refcount = Z_REFCOUNT_P(return_value); \
		*(return_value) = *(var); \
		if (Z_TYPE_P(var) > IS_BOOL) { \
			zval_copy_ctor(return_value); \
		} \
		Z_SET_ISREF_TO_P(return_value, is_ref); \
		Z_SET_REFCOUNT_P(return_value, refcount); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

/**
 * Return zval with always ctor
 */
#define RETURN_CTOR(var) { \
		zend_uchar is_ref = Z_ISREF_P(return_value); \
		zend_uint refcount = Z_REFCOUNT_P(return_value); \
		*(return_value) = *(var); \
		zval_copy_ctor(return_value); \
		Z_SET_ISREF_TO_P(return_value, is_ref); \
		Z_SET_REFCOUNT_P(return_value, refcount); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

/**
 * Returns variables without ctor
 */
#define RETURN_NCTOR(var) { \
		zend_uchar is_ref = Z_ISREF_P(return_value); \
		zend_uint refcount = Z_REFCOUNT_P(return_value); \
		*(return_value) = *(var); \
		Z_SET_ISREF_TO_P(return_value, is_ref); \
		Z_SET_REFCOUNT_P(return_value, refcount); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

/** Foreach */
#define PHALCON_GET_FOREACH_KEY(var, hash, hash_pointer) \
	hash_type = zend_hash_get_current_key_ex(hash, &hash_index, &hash_index_len, &hash_num, 0, &hash_pointer); \
	if (hash_type == HASH_KEY_IS_STRING) { \
		ZVAL_STRINGL(var, hash_index, hash_index_len-1, 1); \
	} else { \
		if (hash_type == HASH_KEY_IS_LONG) { \
			ZVAL_LONG(var, hash_num); \
		}\
	}

#define PHALCON_REGISTER_CLASS(ns, classname, name, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #classname, methods); \
		phalcon_ ##name## _ce = zend_register_internal_class(&ce TSRMLS_CC); \
		phalcon_ ##name## _ce->ce_flags |= flags;  \
	}

#define PHALCON_REGISTER_CLASS_EX(ns, class_name, name, parent, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #class_name, methods); \
		phalcon_ ##name## _ce = zend_register_internal_class_ex(&ce, NULL, parent TSRMLS_CC); \
		if(!phalcon_ ##name## _ce){ \
			phalcon_inherit_not_found(parent, ZEND_NS_NAME(#ns, #class_name)); \
			return FAILURE;	\
		}  \
		phalcon_ ##name## _ce->ce_flags |= flags;  \
	}

/* ------ Starting File: \kernel\fcall.h ------ */
#define PHALCON_CALL_FUNC(return_value, func_name) if(phalcon_call_func(return_value, func_name, strlen(func_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_NORETURN(func_name) if(phalcon_call_func(NULL, func_name, strlen(func_name), 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS(return_value, func_name, param_count, params) if(phalcon_call_func_params(return_value, func_name, strlen(func_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_NORETURN(func_name, param_count, params) if(phalcon_call_func_params(NULL, func_name, strlen(func_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_1(return_value, func_name, param1) if(phalcon_call_func_one_param(return_value, func_name, strlen(func_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_1_NORETURN(func_name, param1) if(phalcon_call_func_one_param(NULL, func_name, strlen(func_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_2(return_value, func_name, param1, param2) if(phalcon_call_func_two_params(return_value, func_name, strlen(func_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_2_NORETURN(func_name, param1, param2) if(phalcon_call_func_two_params(NULL, func_name, strlen(func_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_3(return_value, func_name, param1, param2, param3) if(phalcon_call_func_three_params(return_value, func_name, strlen(func_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_3_NORETURN(func_name, param1, param2, param3) if(phalcon_call_func_three_params(NULL, func_name, strlen(func_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_METHOD(return_value, object, method_name, check) if(phalcon_call_method(return_value, object, method_name, strlen(method_name), check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_NORETURN(object, method_name, check) if(phalcon_call_method(NULL, object, method_name, strlen(method_name), check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS(return_value, object, method_name, param_count, params, check) if(phalcon_call_method_params(return_value, object, method_name, strlen(method_name), param_count, params, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_NORETURN(object, method_name, param_count, params, check) if(phalcon_call_method_params(NULL, object, method_name, strlen(method_name), param_count, params, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_1(return_value, object, method_name, param1, check) if(phalcon_call_method_one_param(return_value, object, method_name, strlen(method_name), param1, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, method_name, param1, check) if(phalcon_call_method_one_param(NULL, object, method_name, strlen(method_name), param1, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_2(return_value, object, method_name, param1, param2, check) if(phalcon_call_method_two_params(return_value, object, method_name, strlen(method_name), param1, param2, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_2_NORETURN(object, method_name, param1, param2, check) if(phalcon_call_method_two_params(NULL, object, method_name, strlen(method_name), param1, param2, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_3(return_value, object, method_name, param1, param2, param3, check) if(phalcon_call_method_three_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_3_NORETURN(object, method_name, param1, param2, param3, check) if(phalcon_call_method_three_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_4(return_value, object, method_name, param1, param2, param3, param4, check) if(phalcon_call_method_four_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, param4, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_4_NORETURN(object, method_name, param1, param2, param3, param4, check) if(phalcon_call_method_four_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, param4, check, 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_PARENT_PARAMS(return_value, object, active_class, method_name, param_count, params) if(phalcon_call_parent_func_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_NORETURN(object, active_class, method_name, param_count, params) if(phalcon_call_parent_func_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_1(return_value, object, active_class, method_name, param1) if(phalcon_call_parent_func_one_param(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_1_NORETURN(object, active_class, method_name, param1) if(phalcon_call_parent_func_one_param(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_2(return_value, object, active_class, method_name, param1, param2) if(phalcon_call_parent_func_two_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_2_NORETURN(object, active_class, method_name, param1, param2) if(phalcon_call_parent_func_two_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_3(return_value, object, active_class, method_name, param1, param2, param3) if(phalcon_call_parent_func_three_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, param2, param3 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_3_NORETURN(object, active_class, method_name, param1, param2, param3) if(phalcon_call_parent_func_three_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT(return_value, object, active_class, method_name) if(phalcon_call_parent_func(return_value, object, active_class, strlen(active_class),method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_NORETURN(object, active_class, method_name) if(phalcon_call_parent_func(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;;

#define PHALCON_CALL_SELF_PARAMS(return_value, object, method_name, param_count, params) if(phalcon_call_self_func_params(return_value, object, method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_NORETURN(object, method_name, param_count, params) if(phalcon_call_self_func_params(NULL, object, method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_1(return_value, object, method_name, param1) if(phalcon_call_self_func_one_param(return_value, object, method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_1_NORETURN(object, method_name, param1) if(phalcon_call_self_func_one_param(NULL, object, method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_2(return_value, object, method_name, param1, param2) if(phalcon_call_self_func_two_params(return_value, object, method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_2_NORETURN(object, method_name, param1, param2) if(phalcon_call_self_func_two_params(NULL, object, method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_3(return_value, object, method_name, param1, param2, param3) if(phalcon_call_self_func_three_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_3_NORETURN(object, method_name, param1, param2, param3) if(phalcon_call_self_func_three_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF(return_value, object, method_name) if(phalcon_call_self_func(return_value, object, method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_NORETURN(object, method_name) if(phalcon_call_self_func(NULL, object, method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_STATIC_PARAMS(return_value, class_name, method_name, param_count, params) if(phalcon_call_static_func_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_NORETURN(class_name, method_name, param_count, params) if(phalcon_call_static_func_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_1(return_value, class_name, method_name, param1) if(phalcon_call_static_func_one_param(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_1_NORETURN(class_name, method_name, param1) if(phalcon_call_static_func_one_param(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_2(return_value, class_name, method_name, param1, param2) if(phalcon_call_static_func_two_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_2_NORETURN(class_name, method_name, param1, param2) if(phalcon_call_static_func_two_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_3(return_value, class_name, method_name, param1, param2, param3) if(phalcon_call_static_func_three_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_3_NORETURN(class_name, method_name, param1, param2, param3) if(phalcon_call_static_func_three_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC(return_value, class_name, method_name) if(phalcon_call_static_func(return_value, class_name, strlen(class_name), method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_NORETURN(class_name, method_name) if(phalcon_call_static_func(NULL, class_name, strlen(class_name), method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_ZVAL_STATIC(return_value, class_zval, method_name) if(phalcon_call_static_zval_func(return_value, class_zval, method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_ZVAL_PARAMS(return_value, class_zval, method_name, param_count, params) if(phalcon_call_static_zval_func_params(return_value, class_zval, method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_ZVAL_PARAMS_1(return_value, class_zval, method_name, param1) if(phalcon_call_static_zval_func_one_param(return_value, class_zval, method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;

/** Look for call scope */
int phalcon_find_scope(zend_class_entry *ce, char *method_name, int method_len TSRMLS_DC);
int phalcon_find_parent_scope(zend_class_entry *ce, char *active_class, int active_class_len, char *method_name, int method_len TSRMLS_DC);

/** Lookups and cache fci data **/
int phalcon_cache_lookup_method(char *func_name, int func_name_length TSRMLS_DC);
int phalcon_cache_lookup_function(char *func_name, int func_name_length, int fcache_pointer TSRMLS_DC);

/** Call single functions */
int phalcon_call_func(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC);
int phalcon_call_func_params(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_func_one_param(zval *return_value, char *func_name, int func_length, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_func_two_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_func_three_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on object instances */
int phalcon_call_method(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC);
int phalcon_call_method_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int check, int noreturn TSRMLS_DC);

/** Call methods on parent class */
int phalcon_call_parent_func(zval *return_value, zval *object, char *active_class, int active_class_len,char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_parent_func_one_param(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_two_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_three_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on self class */
int phalcon_call_self_func(zval *return_value, zval *object, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_self_func_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_self_func_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_self_func_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_self_func_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on static classes */
int phalcon_call_static_func(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_static_func_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_static_func_one_param(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_static_func_two_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_static_func_three_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on static classes from a zval class name */
int phalcon_call_static_zval_func(zval *return_value, zval *mixed_name, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_static_zval_func_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_static_zval_func_one_param(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);

/** Call functions */
int phalcon_call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC);
int phalcon_call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC); 
int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC);
int phalcon_lookup_class_ex(const char *name, int name_length, int use_autoload, zend_class_entry ***ce TSRMLS_DC);
int phalcon_lookup_class(const char *name, int name_length, zend_class_entry ***ce TSRMLS_DC);
/* ------ Finished File: \kernel\fcall.h ------ */

/* ------ Starting File: \kernel\exception.h ------ */
/** Exceptions */
#define PHALCON_THROW_EXCEPTION_STR(class_entry, message) phalcon_throw_exception_string(class_entry, message, strlen(message) TSRMLS_CC);

void phalcon_throw_exception(zval *object TSRMLS_DC);
void phalcon_throw_exception_string(zend_class_entry *ce, char *message, zend_uint message_len TSRMLS_DC);
void phalcon_throw_exception_internal(zval *exception TSRMLS_DC);
/* ------ Finished File: \kernel\exception.h ------ */

/* ------ Starting File: \kernel\require.h ------ */
int phalcon_require(zval *require_path TSRMLS_DC);
/* ------ Finished File: \kernel\require.h ------ */

/* ------ Starting File: \kernel\debug.h ------ */
int phalcon_spprintf(char **message, int max_len, char *format, ...);

#ifndef PHALCON_RELEASE

#define PHV(v) phalcon_vdump(v)
#define PHPR(v) phalcon_print_r(v)

typedef struct _phalcon_debug_entry {
	char *class_name;
	char *method_name;
	int lineno;
	struct _phalcon_debug_entry *prev;
	struct _phalcon_debug_entry *next;
} phalcon_debug_entry;

int phalcon_start_debug();
int phalcon_stop_debug();

int phalcon_print_r(zval *userval TSRMLS_DC);
int phalcon_vdump(zval *uservar TSRMLS_DC);
int phalcon_debug_assign(char *name, zval *value TSRMLS_DC);
int phalcon_vpdump(const zval **uservar TSRMLS_DC);
int phalcon_dump_ce(zend_class_entry *ce TSRMLS_DC);
int phalcon_class_debug(zval *val TSRMLS_DC);

int phalcon_debug_backtrace_internal();
int phalcon_debug_str(char *what, char *message);
int phalcon_debug_long(char *what, uint vlong);
int phalcon_debug_screen(char *message);

int phalcon_step_over(char *message);
int phalcon_step_into(char *message);
int phalcon_step_out(char *message);

int phalcon_step_into_entry(char *class_name, char *method_name, int lineno);
int phalcon_step_out_entry();

int phalcon_debug_method_call(zval *obj, char *method_name TSRMLS_DC);
int phalcon_debug_vdump(char *preffix, zval *value TSRMLS_DC);
int phalcon_debug_param(zval *param TSRMLS_DC);

int phalcon_error_space();
int phalcon_debug_space();

FILE *phalcon_log;
int phalcon_debug_trace;
phalcon_debug_entry *start;
phalcon_debug_entry *active;

#endif
/* ------ Finished File: \kernel\debug.h ------ */

/* ------ Starting File: \kernel\assert.h ------ */
#ifndef PHALCON_RELEASE

int phalcon_assert_class(zval *object, char *class_name TSRMLS_DC);

#endif
/* ------ Finished File: \kernel\assert.h ------ */

/* ------ Starting File: \kernel\object.h ------ */
/** New */
#define PHALCON_NEW_STD(object) PHALCON_ALLOC_ZVAL(object); object_init(object)
#define PHALCON_NEW(object, class) PHALCON_ALLOC_ZVAL(object); object_init_ex(object, class)

/** Class Constants */
#define PHALCON_GET_CLASS_CONSTANT(var, class_entry, name) PHALCON_VAR_INIT(var); phalcon_get_class_constant(var, class_entry, name, strlen(name) TSRMLS_CC)

void phalcon_get_class(zval *result, zval *object TSRMLS_DC);

zend_class_entry *phalcon_fetch_class(zval *class_name TSRMLS_DC);

int phalcon_get_class_constant(zval *return_value, zend_class_entry *ce, char *constant_name, int constant_length TSRMLS_DC);

int phalcon_instance_of(zval *result, const zval *object, const zend_class_entry *ce TSRMLS_DC);
int phalcon_clone(zval *destiny, zval *obj TSRMLS_DC);

int phalcon_method_exists(zval *object, zval *method_name TSRMLS_DC);
int phalcon_method_exists_ex(zval *object, char *method_name, int method_len TSRMLS_DC);

int phalcon_isset_property(zval *object, char *property_name, int property_length TSRMLS_DC);
int phalcon_isset_property_zval(zval *object, zval *property TSRMLS_DC);

int phalcon_read_property(zval **result, zval *object, char *property_name, int property_length, int silent TSRMLS_DC);
int phalcon_read_property_zval(zval **result, zval *object, zval *property, int silent TSRMLS_DC);

int phalcon_update_property_long(zval *obj, char *property_name, int property_length, long value TSRMLS_DC);
int phalcon_update_property_string(zval *obj, char *property_name, int property_length, char *value TSRMLS_DC);
int phalcon_update_property_bool(zval *obj, char *property_name, int property_length, int value TSRMLS_DC);
int phalcon_update_property_null(zval *obj, char *property_name, int property_length TSRMLS_DC);
int phalcon_update_property_zval(zval *obj, char *property_name, int property_length, zval *value TSRMLS_DC);

int phalcon_update_property_zval_zval(zval *obj, zval *property, zval *value TSRMLS_DC);

/** Static properties **/
int phalcon_read_static_property(zval **result, char *class_name, int class_length, char *property_name, int property_length TSRMLS_DC);
int phalcon_update_static_property(char *class_name, int class_length, char *name, int name_length, zval *value TSRMLS_DC);
/* ------ Finished File: \kernel\object.h ------ */

/* ------ Starting File: \kernel\array.h ------ */
/** Array cast */
void phalcon_convert_to_array(zval **var);

/** Check for index existence */
int phalcon_array_isset(const zval *arr, zval *index);
int phalcon_array_isset_long(const zval *arr, ulong index);
int phalcon_array_isset_string(const zval *arr, char *index, uint index_length);

/** Unset existing indexes */
int phalcon_array_unset(zval *arr, zval *index);
int phalcon_array_unset_long(zval *arr, ulong index);
int phalcon_array_unset_string(zval *arr, char *index, uint index_length);

/** Append element to arrays */
int phalcon_array_append(zval **arr, zval *value, int separate TSRMLS_DC);

/** Modify arrays */
int phalcon_array_update(zval **arr, zval *index, zval **value, int flags TSRMLS_DC);
int phalcon_array_update_string(zval **arr, char *index, uint index_length, zval **value, int flags TSRMLS_DC);
int phalcon_array_update_long(zval **arr, ulong index, zval **value, int flags TSRMLS_DC);

/** Update/Append multidimensional arrays */
void phalcon_array_update_multi_2(zval **config, zval *index1, zval *index2, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_multi_long_long_2(zval **arr, long index1, long index2, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_multi_long_str_2(zval **arr, long index1, char *index2, int index2_length, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_multi_append_2(zval **arr, zval *index1, zval *value, int flags TSRMLS_DC);

/** Fetch items from arrays */
int phalcon_array_fetch(zval **return_value, zval *arr, zval *index, int silent TSRMLS_DC);
int phalcon_array_fetch_string(zval **return_value, zval *arr, char *index, uint index_length, int silent TSRMLS_DC);
int phalcon_array_fetch_long(zval **return_value, zval *arr, ulong index, int silent TSRMLS_DC);

/* ------ Finished File: \kernel\array.h ------ */

/* ------ Starting File: \kernel\operators.h ------ */
/** Operators */
#define PHALCON_COMPARE_STRING(op1, op2) phalcon_compare_strict_string(op1, op2, strlen(op2))

/** Operator functions */
int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC);
int phalcon_and_function(zval *result, zval *left, zval *right);

void phalcon_concat_self(zval **left, zval *right TSRMLS_DC);

int phalcon_compare_strict_string(zval *op1, char *op2, int op2_length);

int phalcon_is_smaller_strict_long(zval *op1, long op2 TSRMLS_DC);
int phalcon_is_smaller_or_equal_strict_long(zval *op1, long op2 TSRMLS_DC);

void phalcon_increment_function(zval **var, int separate TSRMLS_DC);
void phalcon_decrement_function(zval **var, int separate TSRMLS_DC);

void phalcon_cast(zval *result, zval *var, zend_uint type);
/* ------ Finished File: \kernel\operators.h ------ */

/* ------ Starting File: \kernel\concat.h ------ */
#define PHALCON_CONCAT_SV(result, op1, op2) \
	 phalcon_concat_sv(result, op1, strlen(op1), op2 TSRMLS_CC);
#define PHALCON_CONCAT_SVS(result, op1, op2, op3) \
	 phalcon_concat_svs(result, op1, strlen(op1), op2, op3, strlen(op3) TSRMLS_CC);
#define PHALCON_CONCAT_SVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_svsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4 TSRMLS_CC);
#define PHALCON_CONCAT_SVSVS(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5) TSRMLS_CC);
#define PHALCON_CONCAT_SVSVSV(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_svsvsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6 TSRMLS_CC);
#define PHALCON_CONCAT_SVSVSVS(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_svsvsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6, op7, strlen(op7) TSRMLS_CC);
#define PHALCON_CONCAT_SVSVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5 TSRMLS_CC);
#define PHALCON_CONCAT_SVV(result, op1, op2, op3) \
	 phalcon_concat_svv(result, op1, strlen(op1), op2, op3 TSRMLS_CC);
#define PHALCON_CONCAT_VS(result, op1, op2) \
	 phalcon_concat_vs(result, op1, op2, strlen(op2) TSRMLS_CC);
#define PHALCON_CONCAT_VSV(result, op1, op2, op3) \
	 phalcon_concat_vsv(result, op1, op2, strlen(op2), op3 TSRMLS_CC);
#define PHALCON_CONCAT_VSVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvs(result, op1, op2, strlen(op2), op3, op4, strlen(op4) TSRMLS_CC);
#define PHALCON_CONCAT_VV(result, op1, op2) \
	 phalcon_concat_vv(result, op1, op2 TSRMLS_CC);
#define PHALCON_CONCAT_VVS(result, op1, op2, op3) \
	 phalcon_concat_vvs(result, op1, op2, op3, strlen(op3) TSRMLS_CC);
#define PHALCON_CONCAT_VVV(result, op1, op2, op3) \
	 phalcon_concat_vvv(result, op1, op2, op3 TSRMLS_CC);
#define PHALCON_CONCAT_VVVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vvvs(result, op1, op2, op3, op4, strlen(op4) TSRMLS_CC);

void phalcon_concat_sv(zval *result, char *op1, zend_uint op1_len, zval *op2 TSRMLS_DC);
void phalcon_concat_svs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len TSRMLS_DC);
void phalcon_concat_svsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4 TSRMLS_DC);
void phalcon_concat_svsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len TSRMLS_DC);
void phalcon_concat_svsvsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6 TSRMLS_DC);
void phalcon_concat_svsvsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, char *op7, zend_uint op7_len TSRMLS_DC);
void phalcon_concat_svsvv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, zval *op5 TSRMLS_DC);
void phalcon_concat_svv(zval *result, char *op1, zend_uint op1_len, zval *op2, zval *op3 TSRMLS_DC);
void phalcon_concat_vs(zval *result, zval *op1, char *op2, zend_uint op2_len TSRMLS_DC);
void phalcon_concat_vsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3 TSRMLS_DC);
void phalcon_concat_vsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len TSRMLS_DC);
void phalcon_concat_vv(zval *result, zval *op1, zval *op2 TSRMLS_DC);
void phalcon_concat_vvs(zval *result, zval *op1, zval *op2, char *op3, zend_uint op3_len TSRMLS_DC);
void phalcon_concat_vvv(zval *result, zval *op1, zval *op2, zval *op3 TSRMLS_DC);
void phalcon_concat_vvvs(zval *result, zval *op1, zval *op2, zval *op3, char *op4, zend_uint op4_len TSRMLS_DC);
/* ------ Finished File: \kernel\concat.h ------ */

/* ------ Starting File: \kernel\memory.h ------ */
void phalcon_init_var(zval **var TSRMLS_DC);
void phalcon_cpy_wrt(zval **dest, zval *var TSRMLS_DC);

int phalcon_memory_grow_stack(TSRMLS_D);
int phalcon_memory_restore_stack(TSRMLS_D);

int phalcon_memory_observe(zval **var TSRMLS_DC);
int phalcon_memory_remove(zval **var TSRMLS_DC);
int phalcon_memory_alloc(zval **var TSRMLS_DC);

int phalcon_clean_restore_stack(TSRMLS_D);

#define PHALCON_MM_GROW() phalcon_memory_grow_stack(TSRMLS_C)
#define PHALCON_MM_RESTORE() phalcon_memory_restore_stack(TSRMLS_C)

/** Memory macros */
#define PHALCON_ALLOC_ZVAL(z) \
	ALLOC_ZVAL(z); INIT_PZVAL(z);

#ifndef PHP_WIN32

#define PHALCON_INIT_VAR(z)\
	if (z) {\
		if (Z_REFCOUNT_P(z) > 1) {\
			Z_DELREF_P(z);\
			ALLOC_ZVAL(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		} else {\
			zval_ptr_dtor(&z);\
			PHALCON_ALLOC_ZVAL(z);\
		}\
	} else {\
		phalcon_memory_alloc(&z TSRMLS_CC);\
	}

#define PHALCON_CPY_WRT(d, v) \
	if (d) { \
		if (Z_REFCOUNT_P(d) > 0) { \
			zval_ptr_dtor(&d); \
		} \
	} else { \
		phalcon_memory_observe(&d TSRMLS_CC); \
	} \
	Z_ADDREF_P(v); \
	d = v;

#else

#define PHALCON_INIT_VAR(z) phalcon_init_var(&z TSRMLS_CC)
#define PHALCON_CPY_WRT(d, v) phalcon_cpy_wrt(&d, v TSRMLS_CC)

#endif

#define PHALCON_ALLOC_ZVAL_MM(z) \
	PHALCON_ALLOC_ZVAL(z); \
	phalcon_memory_observe(&z TSRMLS_CC);

#define PHALCON_SEPARATE_ARRAY(a) \
	{\
		if (Z_REFCOUNT_P(a) > 1) {\
			zval *new_zv;\
			Z_DELREF_P(a);\
			ALLOC_ZVAL(new_zv);\
			INIT_PZVAL_COPY(new_zv, a);\
			a = new_zv;\
			zval_copy_ctor(new_zv);\
		}\
	}

#define PHALCON_SEPARATE(z) \
	{\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			Z_DELREF_P(orig_ptr);\
			ALLOC_ZVAL(z);\
			phalcon_memory_observe(&z TSRMLS_CC);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_SEPARATE_NMO(z) \
	{\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			Z_DELREF_P(orig_ptr);\
			ALLOC_ZVAL(z);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_SEPARATE_PARAM(z) \
	{\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			ALLOC_ZVAL(z);\
			phalcon_memory_observe(&z TSRMLS_CC);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_SEPARATE_PARAM_NMO(z) {\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			ALLOC_ZVAL(z);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_OBSERVE_VAR(var) if(!var){\
		phalcon_memory_observe(&var TSRMLS_CC);\
	} else {\
		zval_ptr_dtor(&var);\
	}
/* ------ Finished File: \kernel\memory.h ------ */


/* ------ Starting File: \kernel\main.c ------ */
/**
 * Initialize globals on each request or each thread started
 */
void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC){
    phalcon_globals->phalcon_memory_stack = 0;
    phalcon_globals->start_memory = NULL;
	phalcon_globals->active_memory = NULL;
	#ifndef PHALCON_RELEASE
	phalcon_globals->phalcon_stack_stats = 0;	
	#endif
}

/**
 * Initilializes super global variables if doesn't
 */
int phalcon_init_global(char *global, int global_length TSRMLS_DC){
	#if PHP_VERSION_ID < 50400
	zend_bool jit_initialization = (PG(auto_globals_jit) && !PG(register_globals) && !PG(register_long_arrays));
	if (jit_initialization) {
		return zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}
	#else
	if (PG(auto_globals_jit)) {
		return zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}
	#endif
	return SUCCESS;
}

/**
 * Gets the global zval into PG macro
 */
int phalcon_get_global(zval **arr, char *global, int global_length TSRMLS_DC){

	zval **gv;

	zend_bool jit_initialization = PG(auto_globals_jit);
	if (jit_initialization) {
		zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}

	if (&EG(symbol_table)) {
		if( zend_hash_find(&EG(symbol_table), global, global_length, (void **) &gv) == SUCCESS) {
			if (Z_TYPE_PP(gv) == IS_ARRAY) {
				*arr = *gv;
			} else {
				PHALCON_INIT_VAR(*arr);
				array_init(*arr);
			}
		}
	}
	if (!*arr) {
		PHALCON_INIT_VAR(*arr);
		array_init(*arr);
	}

	return SUCCESS;
}

/**
 * Makes fast count on implicit array types
 */
void phalcon_fast_count(zval *result, zval *array TSRMLS_DC){
	if (Z_TYPE_P(array) == IS_ARRAY) {
		ZVAL_LONG(result, zend_hash_num_elements(Z_ARRVAL_P(array)));
		return;
	} else {
		if (Z_TYPE_P(array) == IS_OBJECT) {

			#ifdef HAVE_SPL
			zval *retval;
			#endif

			if (Z_OBJ_HT_P(array)->count_elements) {
				ZVAL_LONG(result, 1);
				if (SUCCESS == Z_OBJ_HT(*array)->count_elements(array, &Z_LVAL_P(result) TSRMLS_CC)) {
					return;
				}
			}

			#ifdef HAVE_SPL
			if (Z_OBJ_HT_P(array)->get_class_entry && instanceof_function(Z_OBJCE_P(array), spl_ce_Countable TSRMLS_CC)) {
    			zend_call_method_with_0_params(&array, NULL, NULL, "count", &retval);
				if (retval) {
					convert_to_long_ex(&retval);
					ZVAL_LONG(result, Z_LVAL_P(retval));
					zval_ptr_dtor(&retval);
				}
				return;
			}
			#endif

			ZVAL_LONG(result, 0);
			return;

		} else {
			if (Z_TYPE_P(array) == IS_NULL) {
				ZVAL_LONG(result, 0);
				return;
			}
		}
	}
	ZVAL_LONG(result, 1);
}

/**
 * Fast call to join php function
 */
void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC){

	if (Z_TYPE_P(glue) != IS_STRING || Z_TYPE_P(pieces) != IS_ARRAY){
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for join()");
		return;
	}

	php_implode(glue, pieces, result TSRMLS_CC);
}

void phalcon_fast_explode(zval *result, zval *delimiter, zval *str TSRMLS_DC){

	if (Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(delimiter) != IS_STRING){
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for explode()");
		return;
	}

	array_init(result);
	php_explode(delimiter, str, result, LONG_MAX);
}

/**
 * Inmediate function resolution for addslaches function
 */
void phalcon_fast_addslashes(zval *return_value, zval *param TSRMLS_DC){

	if (Z_TYPE_P(param) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for explode()");
		return;
	}

	//php_addslashes_ex(Z_STRVAL_P(param), Z_STRLEN_P(param), return_value, 0 TSRMLS_CC)

	return;
}

/**
 * Inmediate function resolution for strpos function
 */
void phalcon_fast_strpos(zval *return_value, zval *haystack, zval *needle TSRMLS_DC){

	char *found = NULL;

	if (Z_TYPE_P(haystack) != IS_STRING || Z_TYPE_P(needle) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for strpos()");
		return;
	}

	if (!Z_STRLEN_P(needle)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Empty delimiter");
		return;
	}

	found = php_memnstr(Z_STRVAL_P(haystack), Z_STRVAL_P(needle), Z_STRLEN_P(needle), Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));

	if(found){
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_BOOL(return_value, 0);
	}

}

/**
 * Inmediate function resolution for str_replace function
 */
void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject TSRMLS_DC){

	zval replace_copy, search_copy;
	int copy_replace = 0, copy_search = 0;

	if (Z_TYPE_P(subject) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for str_replace()");
		return;
	}

	if (Z_TYPE_P(replace) != IS_STRING) {
		zend_make_printable_zval(replace, &replace_copy, &copy_replace);
		if (copy_replace) {
			replace = &replace_copy;
		}
	}

	if (Z_TYPE_P(search) != IS_STRING) {
		zend_make_printable_zval(search, &search_copy, &copy_search);
		if (copy_search) {
			search = &search_copy;
		}
	}

	Z_TYPE_P(return_value) = IS_STRING;
	if (Z_STRLEN_P(subject) == 0) {
		ZVAL_STRINGL(return_value, "", 0, 1);
		return;
	}

	if (Z_STRLEN_P(search) == 1) {
		php_char_to_str_ex(Z_STRVAL_P(subject),
			Z_STRLEN_P(subject),
			Z_STRVAL_P(search)[0],
			Z_STRVAL_P(replace),
			Z_STRLEN_P(replace),
			return_value,
			1,
			NULL);
	} else {
		if (Z_STRLEN_P(search) > 1) {
			Z_STRVAL_P(return_value) = php_str_to_str_ex(Z_STRVAL_P(subject), Z_STRLEN_P(subject),
				Z_STRVAL_P(search), Z_STRLEN_P(search),
				Z_STRVAL_P(replace), Z_STRLEN_P(replace), &Z_STRLEN_P(return_value), 1, NULL);
		} else {
			MAKE_COPY_ZVAL(&subject, return_value);
		}
	}

	if (copy_replace) {
		zval_dtor(replace);
	}

	if (copy_search) {
		zval_dtor(search);
	}

}

/**
 * Checks if a file exists
 *
 */
int phalcon_file_exists(zval *filename TSRMLS_DC){

	if (Z_TYPE_P(filename) != IS_STRING) {
		return FAILURE;
	}

	if (VCWD_ACCESS(Z_STRVAL_P(filename), F_OK) == 0) {
		return SUCCESS;
	}

	return FAILURE;
}

/**
 * Filter alphanum string
 */
int phalcon_filter_alphanum(zval *result, zval *param){

	int i, ch, alloc = 0;
	char temp[255];

	if (Z_TYPE_P(param) == IS_STRING) {
		for(i=0; i < Z_STRLEN_P(param) && i < 255;i++){
			ch = Z_STRVAL_P(param)[i];
			if((ch>96&&ch<123)||(ch>64&&ch<91)||(ch>47&&ch<58)){
				temp[alloc] = ch;
				alloc++;
			}
		}
	}

	if (alloc > 0) {
		Z_TYPE_P(result) = IS_STRING;
		Z_STRLEN_P(result) = alloc;
		Z_STRVAL_P(result) = (char *) emalloc(alloc+1);
		memcpy(Z_STRVAL_P(result), temp, alloc);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	} else {
		ZVAL_STRING(result, "", 1);
	}

	return SUCCESS;
}

/**
 * Exports symbols to the active symbol table
 */
int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC){

	if (!EG(active_symbol_table)) {
		zend_rebuild_symbol_table(TSRMLS_C);
	}

	if (EG(active_symbol_table)) {
		if (Z_TYPE_P(key_name) == IS_STRING){
			Z_ADDREF_P(value);
			zend_hash_update(EG(active_symbol_table), Z_STRVAL_P(key_name), Z_STRLEN_P(key_name)+1, &value, sizeof(zval *), NULL);
			if (EG(exception)) {
				return FAILURE;
			}
		}
	}

	return SUCCESS;
}

/**
 * Generates error when foreach is invalid
 */
int phalcon_valid_foreach(zval *arr TSRMLS_DC){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Invalid argument supplied for foreach()");
		phalcon_memory_restore_stack(TSRMLS_C);
		return 0;
	}
	return 1;
}

/**
 * Generates error when inherited class isn't found
 */
void phalcon_inherit_not_found(char *class_name, char *inherit_name){
	fprintf(stderr, "Phalcon Error: Class to extend '%s' was not found when registering class '%s'\n", class_name, inherit_name);
}
/* ------ Finished File: \kernel\main.c ------ */

/* ------ Starting File: \kernel\fcall.c ------ */
/**
 * Finds the correct scope to execute the function
 */
int phalcon_find_scope(zend_class_entry *ce, char *method_name, int method_len TSRMLS_DC){
	char *lcname = zend_str_tolower_dup(method_name, method_len);
	while (ce) {
		if (zend_hash_exists(&ce->function_table, lcname, method_len+1)) {
			EG(scope) = ce;
			efree(lcname);
			return SUCCESS;
		}
		ce = ce->parent;
	}
	if (lcname) {
		efree(lcname);
	}
	return FAILURE;
}

/**
 * Find out function scope on parent classes
 */
int phalcon_find_parent_scope(zend_class_entry *ce, char *active_class, int active_class_len, char *method_name, int method_len TSRMLS_DC){
	char *lcname = zend_str_tolower_dup(method_name, method_len);
	while (ce) {
		if (!zend_binary_strcasecmp(ce->name, ce->name_length, active_class, active_class_len)) {
			if (zend_hash_exists(&ce->function_table, lcname, method_len+1)) {
				EG(scope) = ce;
				efree(lcname);
				return SUCCESS;
			}
		}
		ce = ce->parent;
	}
	if (lcname) {
		efree(lcname);
	}
	return FAILURE;
}

/**
 * This is a function to call PHP functions in a old-style secure way
 */
inline int phalcon_call_func_normal(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zval *local_retval_ptr = NULL;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, func_name, func_length, 1);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s()", func_name);
	}

	zval_ptr_dtor(&fn);

	if (local_retval_ptr) {
		COPY_PZVAL_TO_ZVAL(*return_value, local_retval_ptr);
	}

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single function which not requires parameters
 */
int phalcon_call_func(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC){
	return phalcon_call_func_normal(return_value, func_name, func_length, noreturn TSRMLS_CC);
}

/**
 * This is an experimental function to call PHP functions that requires parameters in a faster way
 */
inline int phalcon_call_func_params_normal(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zval *local_retval_ptr = NULL;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, func_name, func_length, 1);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s()", func_name);
	}

	zval_ptr_dtor(&fn);

	if (local_retval_ptr) {
		COPY_PZVAL_TO_ZVAL(*return_value, local_retval_ptr);
	}

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single function which requires arbitrary number of parameters
 */
int phalcon_call_func_params(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){
	return phalcon_call_func_params_normal(return_value, func_name, func_length, param_count, params, noreturn TSRMLS_CC);
}

/**
 * Call single function which requires only 1 parameter
 */
int phalcon_call_func_one_param(zval *return_value, char *func_name, int func_length, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_func_params(return_value, func_name, func_length, 1, params, noreturn TSRMLS_CC);
}

/**
 * Call single function which requires only 2 parameters
 */
int phalcon_call_func_two_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_func_params(return_value, func_name, func_length, 2, params, noreturn TSRMLS_CC);
}

/**
 * Call single function which requires only 3 parameters
 */
int phalcon_call_func_three_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_func_params(return_value, func_name, func_length, 3, params, noreturn TSRMLS_CC);
}

/**
 * This function implements a secure old-style way to call functions
 */
inline int phalcon_call_method_normal(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zend_class_entry *active_scope = NULL;

	if (check) {
		if (!zend_hash_exists(&Z_OBJCE_P(object)->function_table, method_name, strlen(method_name)+1)) {
			return SUCCESS;
		}
	}

	if(!noreturn){
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, method_name, method_len, 1);

	if (Z_TYPE_P(object) == IS_OBJECT) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
		status = phalcon_call_user_function(&Z_OBJCE_P(object)->function_table, &object, fn, return_value, 0, NULL TSRMLS_CC);
		if (status == FAILURE) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined method %s()", Z_STRVAL_P(fn));
		}
		EG(scope) = active_scope;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to method %s() on a non object", Z_STRVAL_P(fn));
		status = FAILURE;
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call method on an object that not requires parameters
 *
 */
int phalcon_call_method(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC){
	return phalcon_call_method_normal(return_value, object, method_name, method_len, check, noreturn TSRMLS_CC);
}

/**
 * Call methods that require parameters in a old-style secure way
 */
inline int phalcon_call_method_params_normal(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zend_class_entry *active_scope = NULL;

	if (check) {
		if (!zend_hash_exists(&Z_OBJCE_P(object)->function_table, method_name, method_len+1)) {
			return SUCCESS;
		}
	}

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, method_name, method_len, 1);

	if (Z_TYPE_P(object) == IS_OBJECT) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
		status = phalcon_call_user_function(&Z_OBJCE_P(object)->function_table, &object, fn, return_value, param_count, params TSRMLS_CC);
		if (status == FAILURE) {
			EG(scope) = active_scope;
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined method %s() on class %s", Z_STRVAL_P(fn), Z_OBJCE_P(object)->name);
			status = FAILURE;
		}
		EG(scope) = active_scope;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to method %s() on a non object", Z_STRVAL_P(fn));
		status = FAILURE;
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call method on an object that requires an arbitrary number of parameters
 *
 */
int phalcon_call_method_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC){
	return phalcon_call_method_params_normal(return_value, object, method_name, method_len, param_count, params, check, noreturn TSRMLS_CC);
}

/**
 * Call method on an object that requires only 1 parameter
 *
 */
int phalcon_call_method_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 1, params, check, noreturn TSRMLS_CC);
}

/**
 * Call method on an object that requires only 2 parameters
 *
 */
int phalcon_call_method_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 2, params, check, noreturn TSRMLS_CC);
}

/**
 * Call method on an object that requires only 3 parameters
 *
 */
int phalcon_call_method_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 3, params, check, noreturn TSRMLS_CC);
}

/**
 * Call method on an object that requires only 3 parameters
 *
 */
int phalcon_call_method_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3, param4 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 4, params, check, noreturn TSRMLS_CC);
}

/**
 * Call parent static function which not requires parameters
 */
int phalcon_call_parent_func(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_parent_scope(Z_OBJCE_P(object), active_class, active_class_len, method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func(return_value, "parent", strlen("parent"), method_name, method_len, noreturn TSRMLS_CC);
	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

/**
 * Call parent static function that requires an arbitrary number of parameters
 */
int phalcon_call_parent_func_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_parent_scope(Z_OBJCE_P(object), active_class, active_class_len, method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func_params(return_value, "parent", strlen("parent"), method_name, method_len, param_count, params, noreturn TSRMLS_CC);

	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

/**
 * Call parent static function that requires one parameter
 */
int phalcon_call_parent_func_one_param(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

/**
 * Call parent static function that requires two parameters
 */
int phalcon_call_parent_func_two_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

/**
 * Call parent static function that requires two parameters
 */
int phalcon_call_parent_func_three_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

/**
 * Call self-class static function which not requires parameters
 */
int phalcon_call_self_func(zval *return_value, zval *object, char *method_name, int method_len, int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func(return_value, "self", strlen("self"), method_name, method_len, noreturn TSRMLS_CC);

	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

/**
 * Call self-class static function which requires parameters
 */
int phalcon_call_self_func_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func_params(return_value, "self", strlen("self"), method_name, method_len, param_count, params, noreturn TSRMLS_CC);
	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

int phalcon_call_self_func_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function which not requires parameters
 */
int phalcon_call_static_func(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, class_name, class_length, 1);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", class_name, method_name);
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single static function that requires an arbitrary number of parameters
 */
int phalcon_call_static_func_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, class_name, class_length, 1);
	add_next_index_stringl(fn, method_name, method_len, 1);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", class_name, method_name);
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single static function that requires one parameter
 */
int phalcon_call_static_func_one_param(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function that requires two parameters
 */
int phalcon_call_static_func_two_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function that requires three parameters
 */
int phalcon_call_static_func_three_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function on a zval which not requires any parameter
 */
int phalcon_call_static_zval_func(zval *return_value, zval *mixed_name, char *method_name, int method_len, int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_zval(fn, mixed_name);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		if(Z_TYPE_P(mixed_name) == IS_STRING) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", Z_STRVAL_P(mixed_name), method_name);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function not-callable::%s()", method_name);
		}
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single static function on a zval which requires parameters
 */
int phalcon_call_static_zval_func_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_zval(fn, mixed_name);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		if(Z_TYPE_P(mixed_name) == IS_STRING) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", Z_STRVAL_P(mixed_name), method_name);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function not-callable::%s()", method_name);
		}
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Call single static function on a zval that requires one parameter
 */
int phalcon_call_static_zval_func_one_param(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function on a zval that requires one parameter
 */
int phalcon_call_static_zval_func_two_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function on a zval that requires one parameter
 */
int phalcon_call_static_zval_func_three_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

/**
 * Call single static function direct on a zend_class_entry which requires parameters
 */
int phalcon_call_static_ce_func_params(zval *return_value, zend_class_entry *ce, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, ce->name, ce->name_length, 0);
	add_next_index_stringl(fn, method_name, method_len, 0);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", ce->name, method_name);
	}

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)){
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;

}

int phalcon_call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC) {
	zval ***params_array;
	zend_uint i;
	int ex_retval;
	zval *local_retval_ptr = NULL;

	if (param_count) {
		params_array = (zval ***) emalloc(sizeof(zval **)*param_count);
		for (i=0; i<param_count; i++) {
			params_array[i] = &params[i];
		}
	} else {
		params_array = NULL;
	}
	ex_retval = phalcon_call_user_function_ex(function_table, object_pp, function_name, &local_retval_ptr, param_count, params_array, 1, NULL TSRMLS_CC);
	if (local_retval_ptr) {
		COPY_PZVAL_TO_ZVAL(*retval_ptr, local_retval_ptr);
	} else {
		INIT_ZVAL(*retval_ptr);
	}
	if (params_array) {
		efree(params_array);
	}
	return ex_retval;
}

int phalcon_call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC) {
	zend_fcall_info fci;

	fci.size = sizeof(fci);
	fci.function_table = function_table;
	fci.object_ptr = object_pp ? *object_pp : NULL;
	fci.function_name = function_name;
	fci.retval_ptr_ptr = retval_ptr_ptr;
	fci.param_count = param_count;
	fci.params = params;
	fci.no_separation = (zend_bool) no_separation;
	fci.symbol_table = symbol_table;

	return phalcon_call_function(&fci, NULL TSRMLS_CC);
}

int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC) {

	zend_uint i;
	zval **original_return_value;
	HashTable *calling_symbol_table;
	zend_op_array *original_op_array;
	zend_op **original_opline_ptr;
	zend_class_entry *current_scope;
	zend_class_entry *current_called_scope;
	zend_class_entry *calling_scope = NULL;
	zend_class_entry *called_scope = NULL;
	zval *current_this;
	zend_execute_data execute_data;

	*fci->retval_ptr_ptr = NULL;

	if (!EG(active)) {
		return FAILURE; /* executor is already inactive */
	}

	if (EG(exception)) {
		return FAILURE; /* we would result in an instable executor otherwise */
	}

	switch (fci->size) {
		case sizeof(zend_fcall_info):
			break; /* nothing to do currently */
		default:
			zend_error(E_ERROR, "Corrupted fcall_info provided to phalcon_call_function()");
			break;
	}

	/* Initialize execute_data */
	if (EG(current_execute_data)) {
		execute_data = *EG(current_execute_data);
		EX(op_array) = NULL;
		EX(opline) = NULL;
		EX(object) = NULL;
	} else {
		/* This only happens when we're called outside any execute()'s
		 * It shouldn't be strictly necessary to NULL execute_data out,
		 * but it may make bugs easier to spot
		 */
		memset(&execute_data, 0, sizeof(zend_execute_data));
	}

	if (!fci_cache || !fci_cache->initialized) {
		zend_fcall_info_cache fci_cache_local;
		char *callable_name;
		char *error = NULL;

		if (!fci_cache) {
			fci_cache = &fci_cache_local;
		}

		if (!zend_is_callable_ex(fci->function_name, fci->object_ptr, IS_CALLABLE_CHECK_SILENT, &callable_name, NULL, fci_cache, &error TSRMLS_CC)) {
			if (error) {
				zend_error(E_WARNING, "Invalid callback %s, %s", callable_name, error);
				efree(error);
			}
			if (callable_name) {
				efree(callable_name);
			}
			return FAILURE;
		} else if (error) {
			/* Capitalize the first latter of the error message */
			if (error[0] >= 'a' && error[0] <= 'z') {
				error[0] += ('A' - 'a');
			}
			zend_error(E_STRICT, "%s", error);
			efree(error);
		}
		efree(callable_name);
	}

	EX(function_state).function = fci_cache->function_handler;
	calling_scope = fci_cache->calling_scope;
	called_scope = fci_cache->called_scope;
	fci->object_ptr = fci_cache->object_ptr;
	EX(object) = fci->object_ptr;
	if (fci->object_ptr && Z_TYPE_P(fci->object_ptr) == IS_OBJECT &&
	    (!EG(objects_store).object_buckets || !EG(objects_store).object_buckets[Z_OBJ_HANDLE_P(fci->object_ptr)].valid)) {
		return FAILURE;
	}

	if (EX(function_state).function->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) {
		if (EX(function_state).function->common.fn_flags & ZEND_ACC_ABSTRACT) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EX(function_state).function->common.scope->name, EX(function_state).function->common.function_name);
		}
		if (EX(function_state).function->common.fn_flags & ZEND_ACC_DEPRECATED) {
 			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				EX(function_state).function->common.scope ? EX(function_state).function->common.scope->name : "",
				EX(function_state).function->common.scope ? "::" : "",
				EX(function_state).function->common.function_name);
		}
	}

	ZEND_VM_STACK_GROW_IF_NEEDED(fci->param_count + 1);

	for (i=0; i<fci->param_count; i++) {
		zval *param;

		if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION 
			&& (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) == 0 
			&& !ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& PZVAL_IS_REF(*fci->params[i])) {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
			zval_copy_ctor(param);
		} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& !PZVAL_IS_REF(*fci->params[i])) {

			if (Z_REFCOUNT_PP(fci->params[i]) > 1) {
				zval *new_zval;

				if (fci->no_separation &&
				    !ARG_MAY_BE_SENT_BY_REF(EX(function_state).function, i + 1)) {
					if (i || UNEXPECTED(ZEND_VM_STACK_ELEMETS(EG(argument_stack)) == EG(argument_stack)->top)) {
						/* hack to clean up the stack */
						zend_vm_stack_push_nocheck((void *) (zend_uintptr_t)i TSRMLS_CC);
						zend_vm_stack_clear_multiple(TSRMLS_C);
					}

					zend_error(E_WARNING, "Parameter %d to %s%s%s() expected to be a reference, value given",
						i+1,
						EX(function_state).function->common.scope ? EX(function_state).function->common.scope->name : "",
						EX(function_state).function->common.scope ? "::" : "",
						EX(function_state).function->common.function_name);
					return FAILURE;
				}

				ALLOC_ZVAL(new_zval);
				*new_zval = **fci->params[i];
				zval_copy_ctor(new_zval);
				Z_SET_REFCOUNT_P(new_zval, 1);
				Z_DELREF_PP(fci->params[i]);
				*fci->params[i] = new_zval;
			}
			Z_ADDREF_PP(fci->params[i]);
			Z_SET_ISREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else if (*fci->params[i] != &EG(uninitialized_zval)) {
			Z_ADDREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
		}
		zend_vm_stack_push_nocheck(param TSRMLS_CC);
	}

	EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
	zend_vm_stack_push_nocheck((void*)(zend_uintptr_t)fci->param_count TSRMLS_CC);

	current_scope = EG(scope);
	EG(scope) = calling_scope;

	current_this = EG(This);

	current_called_scope = EG(called_scope);
	if (called_scope) {
		EG(called_scope) = called_scope;
	} else if (EX(function_state).function->type != ZEND_INTERNAL_FUNCTION) {
		EG(called_scope) = NULL;
	}

	if (fci->object_ptr) {
		if ((EX(function_state).function->common.fn_flags & ZEND_ACC_STATIC)) {
			EG(This) = NULL;
		} else {
			EG(This) = fci->object_ptr;

			if (!PZVAL_IS_REF(EG(This))) {
				Z_ADDREF_P(EG(This)); /* For $this pointer */
			} else {
				zval *this_ptr;

				ALLOC_ZVAL(this_ptr);
				*this_ptr = *EG(This);
				INIT_PZVAL(this_ptr);
				zval_copy_ctor(this_ptr);
				EG(This) = this_ptr;
			}
		}
	} else {
		EG(This) = NULL;
	}

	EX(prev_execute_data) = EG(current_execute_data);
	EG(current_execute_data) = &execute_data;

	if (EX(function_state).function->type == ZEND_USER_FUNCTION) {
		calling_symbol_table = EG(active_symbol_table);
		EG(scope) = EX(function_state).function->common.scope;
		if (fci->symbol_table) {
			EG(active_symbol_table) = fci->symbol_table;
		} else {
			EG(active_symbol_table) = NULL;
		}

		original_return_value = EG(return_value_ptr_ptr);
		original_op_array = EG(active_op_array);
		EG(return_value_ptr_ptr) = fci->retval_ptr_ptr;
		EG(active_op_array) = (zend_op_array *) EX(function_state).function;
		original_opline_ptr = EG(opline_ptr);
		zend_execute(EG(active_op_array) TSRMLS_CC);
		if (!fci->symbol_table && EG(active_symbol_table)) {
			if (EG(symtable_cache_ptr)>=EG(symtable_cache_limit)) {
				zend_hash_destroy(EG(active_symbol_table));
				FREE_HASHTABLE(EG(active_symbol_table));
			} else {
				/* clean before putting into the cache, since clean
				   could call dtors, which could use cached hash */
				zend_hash_clean(EG(active_symbol_table));
				*(++EG(symtable_cache_ptr)) = EG(active_symbol_table);
			}
		}
		EG(active_symbol_table) = calling_symbol_table;
		EG(active_op_array) = original_op_array;
		EG(return_value_ptr_ptr)=original_return_value;
		EG(opline_ptr) = original_opline_ptr;
	} else if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		int call_via_handler = (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) != 0;
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);
		if (EX(function_state).function->common.scope) {
			EG(scope) = EX(function_state).function->common.scope;
		}
		((zend_internal_function *) EX(function_state).function)->handler(fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		/*  We shouldn't fix bad extensions here,
			because it can break proper ones (Bug #34045)
		if (!EX(function_state).function->common.return_reference)
		{
			INIT_PZVAL(*fci->retval_ptr_ptr);
		}*/
		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}

		if (call_via_handler) {
			/* We must re-initialize function again */
			fci_cache->initialized = 0;
		}
	} else { /* ZEND_OVERLOADED_FUNCTION */
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);

		/* Not sure what should be done here if it's a static method */
		if (fci->object_ptr) {
			Z_OBJ_HT_P(fci->object_ptr)->call_method(EX(function_state).function->common.function_name, fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (EX(function_state).function->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree(EX(function_state).function->common.function_name);
		}
		efree(EX(function_state).function);

		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}
	}
	zend_vm_stack_clear_multiple(TSRMLS_C);

	if (EG(This)) {
		zval_ptr_dtor(&EG(This));
	}
	EG(called_scope) = current_called_scope;
	EG(scope) = current_scope;
	EG(This) = current_this;
	EG(current_execute_data) = EX(prev_execute_data);

	if (EG(exception)) {
		phalcon_throw_exception_internal(NULL TSRMLS_CC);
	}
	return SUCCESS;
}

int phalcon_lookup_class_ex(const char *name, int name_length, int use_autoload, zend_class_entry ***ce TSRMLS_DC){

	zval **args[1];
	zval autoload_function;
	zval *class_name_ptr;
	zval *retval_ptr = NULL;
	int retval, lc_length;
	char *lc_name;
	char *lc_free;
	zend_fcall_info fcall_info;
	zend_fcall_info_cache fcall_cache;
	char dummy = 1;
	ulong hash;
	ALLOCA_FLAG(use_heap)

	if (name == NULL || !name_length) {
		return FAILURE;
	}

	lc_free = lc_name = do_alloca(name_length + 1, use_heap);
	zend_str_tolower_copy(lc_name, name, name_length);
	lc_length = name_length + 1;

	if (lc_name[0] == '\\') {
		lc_name += 1;
		lc_length -= 1;
	}

	hash = zend_inline_hash_func(lc_name, lc_length);

	if (zend_hash_quick_find(EG(class_table), lc_name, lc_length, hash, (void **) ce) == SUCCESS) {
		free_alloca(lc_free, use_heap);
		return SUCCESS;
	}

	/* The compiler is not-reentrant. Make sure we __autoload() only during run-time
	 * (doesn't impact fuctionality of __autoload()
	*/
	if (!use_autoload || zend_is_compiling(TSRMLS_C)) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	if (EG(in_autoload) == NULL) {
		ALLOC_HASHTABLE(EG(in_autoload));
		zend_hash_init(EG(in_autoload), 0, NULL, NULL, 0);
	}

	if (zend_hash_quick_add(EG(in_autoload), lc_name, lc_length, hash, (void**)&dummy, sizeof(char), NULL) == FAILURE) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	ZVAL_STRINGL(&autoload_function, ZEND_AUTOLOAD_FUNC_NAME, sizeof(ZEND_AUTOLOAD_FUNC_NAME) - 1, 0);

	ALLOC_ZVAL(class_name_ptr);
	INIT_PZVAL(class_name_ptr);
	if (name[0] == '\\') {
		ZVAL_STRINGL(class_name_ptr, name+1, name_length-1, 1);
	} else {
		ZVAL_STRINGL(class_name_ptr, name, name_length, 1);
	}

	args[0] = &class_name_ptr;

	fcall_info.size = sizeof(fcall_info);
	fcall_info.function_table = EG(function_table);
	fcall_info.function_name = &autoload_function;
	fcall_info.symbol_table = NULL;
	fcall_info.retval_ptr_ptr = &retval_ptr;
	fcall_info.param_count = 1;
	fcall_info.params = args;
	fcall_info.object_ptr = NULL;
	fcall_info.no_separation = 1;

	fcall_cache.initialized = EG(autoload_func) ? 1 : 0;
	fcall_cache.function_handler = EG(autoload_func);
	fcall_cache.calling_scope = NULL;
	fcall_cache.called_scope = NULL;
	fcall_cache.object_ptr = NULL;

	zend_exception_save(TSRMLS_C);
	retval = phalcon_call_function(&fcall_info, &fcall_cache TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	EG(autoload_func) = fcall_cache.function_handler;

	zval_ptr_dtor(&class_name_ptr);

	zend_hash_quick_del(EG(in_autoload), lc_name, lc_length, hash);

	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}

	if (retval == FAILURE) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	retval = zend_hash_quick_find(EG(class_table), lc_name, lc_length, hash, (void **) ce);
	free_alloca(lc_free, use_heap);
	return retval;
}

int phalcon_lookup_class(const char *name, int name_length, zend_class_entry ***ce TSRMLS_DC){
	return phalcon_lookup_class_ex(name, name_length, 1, ce TSRMLS_CC);
}
/* ------ Finished File: \kernel\fcall.c ------ */

/* ------ Starting File: \kernel\require.c ------ */
/**
 * Do an internal require to a plain php file
 *
 */
int phalcon_require(zval *require_path TSRMLS_DC){

	int ret;
	char *file_path;
	int file_path_length;
	zend_file_handle file_handle;
	zval *result = NULL;
	int status = SUCCESS;
	int dummy = 0;

	zval **original_return_value = EG(return_value_ptr_ptr);
	zend_op **original_opline_ptr = EG(opline_ptr);
	zend_op_array *original_active_op_array = EG(active_op_array);

	zend_op_array *new_op_array = NULL;

	if (Z_TYPE_P(require_path) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Invalid require path value");
		status = FAILURE;
	} else {

		file_path = Z_STRVAL_P(require_path);
		file_path_length = Z_STRLEN_P(require_path);

		ret = php_stream_open_for_zend_ex(file_path, &file_handle, ENFORCE_SAFE_MODE|USE_PATH|STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
		if (ret == SUCCESS) {

			if(!file_handle.opened_path){
				file_handle.opened_path = estrndup(file_path, file_path_length);
			}

			EG(exit_status) = 0;
			PG(during_request_startup) = 0;

			if (file_handle.filename){
				if ((file_handle.filename[0] != '-' || file_handle.filename[1] != 0) && file_handle.opened_path == NULL && file_handle.type != ZEND_HANDLE_FILENAME) {
					char realfile[MAXPATHLEN];
					int realfile_len;
					dummy = 1;
					if(expand_filepath(file_handle.filename, realfile TSRMLS_CC)){
						realfile_len =  strlen(realfile);
						zend_hash_add(&EG(included_files), realfile, realfile_len+1, (void *)&dummy, sizeof(int), NULL);
						file_handle.opened_path = estrndup(realfile, realfile_len);
					}
				}
			}

			if (!dummy) {
				if (file_handle.opened_path) {
					zend_hash_add(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path) + 1, (void *)&dummy, sizeof(int), NULL);
				}
			}

			new_op_array = zend_compile_file(&file_handle, ZEND_REQUIRE TSRMLS_CC);
			zend_destroy_file_handle(&file_handle TSRMLS_CC);

			if (new_op_array) {

				EG(return_value_ptr_ptr) = &result;
				EG(active_op_array) = new_op_array;
				if (!EG(active_symbol_table)) {
					zend_rebuild_symbol_table(TSRMLS_C);
				}

				zend_execute(new_op_array TSRMLS_CC);
				zend_exception_restore(TSRMLS_C);

				destroy_op_array(new_op_array TSRMLS_CC);
				efree(new_op_array);
				if (!EG(exception)) {
					if (EG(return_value_ptr_ptr)) {
						zval_ptr_dtor(EG(return_value_ptr_ptr));
					}
				}

			}

			EG(return_value_ptr_ptr) = original_return_value;
			EG(opline_ptr) = original_opline_ptr;
			EG(active_op_array) = original_active_op_array;

			if (EG(exception) || EG(exit_status) == 255) {
				status = FAILURE;
			}

		} else {
			zend_destroy_file_handle(&file_handle TSRMLS_CC);
			status = FAILURE;
		}

	}

	if (status == FAILURE){
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}
/* ------ Finished File: \kernel\require.c ------ */

/* ------ Starting File: \kernel\debug.c ------ */
/**
 * Applies sprintf function to a variable list
 */
int phalcon_spprintf(char **message, int max_len, char *format, ...){
	va_list arg;
	int len;

	va_start(arg, format);
	len = vspprintf(message, max_len, format, arg);
	va_end(arg);
	return len;
}

#ifndef PHALCON_RELEASE

FILE *phalcon_log = NULL;
int phalcon_debug_trace = 0;
phalcon_debug_entry *start = NULL;
phalcon_debug_entry *active = NULL;

/**
 * Stars debug on file pipe
 */
int phalcon_start_debug(){
	if(!phalcon_log){
		/*//phalcon_log = fopen("/home/gutierrezandresfelipe/phalcon-debug.a", "w");
		phalcon_log = fopen("/tmp/phalcon-debug.a", "w");
		if(!phalcon_log){
			fprintf(stderr, "Can't open debug log\n");
		}*/
		phalcon_log = stderr;
	}
	return SUCCESS;
}

/**
 * Stops debug process
 */
int phalcon_stop_debug(){
	phalcon_debug_entry *ptr = active;
	phalcon_debug_entry *this_entry = NULL;
	while(ptr){
		this_entry = ptr;
		ptr = ptr->prev;
		efree(this_entry);
	}
	//fclose(phalcon_log);
	phalcon_log = NULL;
	return SUCCESS;
}

/**
 * Executes a print_r on an interal zval
 */
int phalcon_print_r(zval *userval TSRMLS_DC){
	zend_print_zval_r(userval, 0 TSRMLS_CC);
	return SUCCESS;
}

/**
 * Internal fast zval dump
 */
int phalcon_vdump(zval *uservar TSRMLS_DC){
	phalcon_start_debug();
    if(!uservar){
		fprintf(phalcon_log, "Null pointer\n");
		return SUCCESS;
	}
    switch(Z_TYPE_P(uservar)){
        case IS_NULL:
            fprintf(phalcon_log, "NULL \n");
            break;
        case IS_BOOL:
            fprintf(phalcon_log, "Boolean: %s\n", Z_LVAL_P(uservar) ? "TRUE" : "FALSE");
            break;
        case IS_LONG:
            fprintf(phalcon_log, "Long: %ld at %p, refcount=%d\n", Z_LVAL_P(uservar), uservar, Z_REFCOUNT_P(uservar));
            break;
        case IS_DOUBLE:
            fprintf(phalcon_log, "Double: %f\n", Z_DVAL_P(uservar));
            break;
        case IS_STRING:
			fprintf(phalcon_log, "String: %s(%d) at %p, refcount=%d\n", Z_STRVAL_P(uservar), Z_STRLEN_P(uservar), uservar, Z_REFCOUNT_P(uservar));
            break;
        case IS_RESOURCE:
            fprintf(phalcon_log, "Resource\n");
            break;
        case IS_ARRAY:
            fprintf(phalcon_log, "Array at %p, refcount=%d\n", uservar, Z_REFCOUNT_P(uservar));
            break;
        case IS_OBJECT:
            fprintf(phalcon_log, "Object <%s> at %p\n", Z_OBJCE_P(uservar)->name, uservar);
            break;
        default:
            fprintf(phalcon_log, "Unknown\n");
    }
    return SUCCESS;
}

/**
 * Internal fast zval dump
 */
int phalcon_vpdump(const zval **uservar TSRMLS_DC){
     if(!uservar){
		fprintf(phalcon_log, "Null pointer");
		return SUCCESS;
     }
     switch(Z_TYPE_PP(uservar)){
        case IS_NULL:
            fprintf(phalcon_log, "NULL\n");
            break;
        case IS_BOOL:
            fprintf(phalcon_log, "Boolean: %s\n", Z_LVAL_PP(uservar) ? "TRUE" : "FALSE");
            break;
        case IS_LONG:
            fprintf(phalcon_log, "Long: %ld\n", Z_LVAL_PP(uservar));
            break;
        case IS_DOUBLE:
            fprintf(phalcon_log, "Double: %f\n", Z_DVAL_PP(uservar));
            break;
        case IS_STRING:
            fprintf(phalcon_log, "String: %s\n", Z_STRVAL_PP(uservar));
            break;
        case IS_RESOURCE:
            fprintf(phalcon_log, "Resource\n");
            break;
        case IS_ARRAY:
            fprintf(phalcon_log, "Array\n");
            break;
        case IS_OBJECT:
            fprintf(phalcon_log, "Object\n");
            break;
        default:
            fprintf(phalcon_log, "Unknown\n");
    }
    return SUCCESS;
}

int phalcon_dump_ce(zend_class_entry *ce TSRMLS_DC){
	char *message = emalloc(sizeof(char *)*120);
	if(ce){
		sprintf(message, "- ClassType => %d", ce->type);
		phalcon_step_over(message);
		if(ce->name){
			sprintf(message, "- ClassName => %s", ce->name);
			phalcon_step_over(message);
		} else {
			phalcon_step_over("- ClassName => NULL");
		}
	} else {
		phalcon_step_over("- NULL class entry :(");
	}
	return SUCCESS;
}

int phalcon_class_debug(zval *val TSRMLS_DC){
	char *message = emalloc(sizeof(char *)*120);
	zend_class_entry *ce;
	if(val){
		ce = Z_OBJCE_P(val);
		if(ce){
			sprintf(message, "- MemoryAddress => %p", val);
			phalcon_step_over(message);
			phalcon_dump_ce(ce TSRMLS_CC);
		} else {
			phalcon_step_over("- No class entry :(");
		}
	} else {
		phalcon_step_over("- this_ptr is null :(");
	}
	return SUCCESS;
}

/**
 * Append debug information to file
 */
int phalcon_debug_str(char *what, char *message){
	fprintf(phalcon_log, "%s", what);
	fprintf(phalcon_log, "%s", message);
	fprintf(phalcon_log, "\n");
	return SUCCESS;
}

int phalcon_debug_long(char *what, uint vlong){
	fprintf(phalcon_log, "%s", what);
	fprintf(phalcon_log, "%u", vlong);
	fprintf(phalcon_log, "\n");
	return SUCCESS;
}

int phalcon_debug_screen(char *message){
	phalcon_debug_space();
	fprintf(phalcon_log, "%s\n", message);
	return SUCCESS;
}

int phalcon_debug_method_call(zval *obj, char *method_name TSRMLS_DC){
	if(Z_TYPE_P(obj)==IS_OBJECT){
		phalcon_debug_space();
	} else {
		phalcon_error_space();
	}
	if(Z_TYPE_P(obj)==IS_OBJECT){
		fprintf(phalcon_log, "Calling method %s::%s on Object at %p\n", Z_OBJCE_P(obj)->name, method_name, obj);
	} else {
		fprintf(phalcon_log, "Calling method %s on non object :(\n", method_name);
	}
	return SUCCESS;
}

int phalcon_error_space(){
	int i;
	fprintf(phalcon_log, "[ERROR] ");
	for(i=0;i<phalcon_debug_trace;i++){
		fprintf(phalcon_log, " ");
	}
	return SUCCESS;
}

int phalcon_debug_space(){
	int i;
	fprintf(phalcon_log, "[DEBUG] ");
	for(i=0;i<phalcon_debug_trace;i++){
		fprintf(phalcon_log, " ");
	}
	return SUCCESS;
}

int phalcon_debug_param(zval *param TSRMLS_DC){
	phalcon_debug_space();
	fprintf(phalcon_log, "Push method Param > ");
	phalcon_vdump(param TSRMLS_CC);
	return SUCCESS;
}

int phalcon_debug_vdump(char *preffix, zval *value TSRMLS_DC){
	phalcon_debug_space();
	fprintf(phalcon_log, "%s", preffix);
	phalcon_vdump(value TSRMLS_CC);
	return SUCCESS;
}

int phalcon_debug_assign(char *name, zval *value TSRMLS_DC){
	phalcon_debug_space();
	fprintf(phalcon_log, "Assign on %s with ", name);
	phalcon_vdump(value TSRMLS_CC);
	return SUCCESS;
}

int phalcon_step_over(char *message){
	phalcon_debug_screen(message);
	return SUCCESS;
}

int phalcon_step_into(char *message){
	phalcon_debug_trace++;
	phalcon_debug_screen(message);
	return SUCCESS;
}

int phalcon_step_out(char *message){
	phalcon_debug_screen(message);
	phalcon_debug_trace--;
	return SUCCESS;
}

/**
 * Prints internal debug backtrace
 */
int phalcon_debug_backtrace_internal(){
	int step = 0;
	char *message;
	phalcon_debug_entry *ptr = active;
	while(ptr){
		phalcon_spprintf(&message, 0, "#%d %s::%s", step, ptr->class_name, ptr->method_name);
		phalcon_debug_screen(message);
		efree(message);
		ptr = ptr->prev;
		step++;
	}
	return SUCCESS;
}

/**
 * Appends a debug entry to internal execution scope
 */
int phalcon_step_into_entry(char *class_name, char *method_name, int lineno){

	char *message;
	phalcon_debug_entry *entry;

	if (!start) {
		start = (phalcon_debug_entry *) emalloc(sizeof(phalcon_debug_entry));
		start->class_name = "__main__";
		start->method_name = "__init__";
		start->lineno = 0;
		start->prev = NULL;
		start->next = NULL;
		active = start;
	}

	phalcon_spprintf(&message, 0, "Step Into %s::%s", class_name, method_name);
	phalcon_debug_screen(message);
	efree(message);

	entry = emalloc(sizeof(phalcon_debug_entry));
	entry->class_name = class_name;
	entry->method_name = method_name;
	entry->lineno = lineno;
	entry->prev = active;
	active->next = entry;
	active = entry;
	phalcon_debug_trace++;

	return SUCCESS;
}

/**
 * Steps out current stack
 */
int phalcon_step_out_entry(){

	char *message;
	phalcon_debug_entry *prev;
	if(active){

		phalcon_debug_trace--;

		phalcon_spprintf(&message, 0, "Step out %s::%s", active->class_name, active->method_name);
		phalcon_debug_screen(message);
		efree(message);

		prev = active->prev;
		efree(active);
		active = prev;

	} else {
		fprintf(phalcon_log, "Problem, stack?");
		return FAILURE;
	}
	return SUCCESS;
}

#endif
/* ------ Finished File: \kernel\debug.c ------ */

/* ------ Starting File: \kernel\assert.c ------ */
#ifndef PHALCON_RELEASE

int phalcon_assert_class(zval *object, char *class_name TSRMLS_DC){
	if(object){
		if(Z_TYPE_P(object)!=IS_OBJECT){
			phalcon_error_space();
			fprintf(phalcon_log, "AssertClass: [Failed] Value is not an object\n");
			return FAILURE;
		} else {
			if(strcmp(Z_OBJCE_P(object)->name, class_name)){
				phalcon_error_space();
				fprintf(phalcon_log, "AssertClass: [Failed] Object is not class %s, is %s\n", class_name, Z_OBJCE_P(object)->name);
				return FAILURE;
			}
		}
	}
	return SUCCESS;
}

#endif
/* ------ Finished File: \kernel\assert.c ------ */

/* ------ Starting File: \kernel\object.c ------ */
#ifdef PHP_WIN32
#endif

/**
 * Reads class constant from string name and returns its value
 */
int phalcon_get_class_constant(zval *return_value, zend_class_entry *ce, char *constant_name, int constant_length TSRMLS_DC){

	zval **result_ptr;

	if (zend_hash_find(&ce->constants_table, constant_name, constant_length+1, (void **) &result_ptr) != SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Undefined class constant '%s::%s'", ce->name, constant_name);
		phalcon_memory_restore_stack(TSRMLS_C);
		return FAILURE;
	} else {
		ZVAL_ZVAL(return_value, *result_ptr, 1, 0);
	}

	return SUCCESS;
}

/**
 * Check if class is instance of
 */
int phalcon_instance_of(zval *result, const zval *object, const zend_class_entry *ce TSRMLS_DC){
	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "instanceof expects an object instance, constant given");
		phalcon_memory_restore_stack(TSRMLS_C);
		return FAILURE;
    } else {
		ZVAL_BOOL(result, instanceof_function(Z_OBJCE_P(object), ce TSRMLS_CC));
    }
    return SUCCESS;
}

/**
 * Returns class name into result
 */
void phalcon_get_class(zval *result, zval *object TSRMLS_DC){
	zend_class_entry *ce;
	if (Z_TYPE_P(object) == IS_OBJECT){
		ce = Z_OBJCE_P(object);
		Z_STRLEN_P(result) = ce->name_length;
		Z_STRVAL_P(result) = (char *) emalloc(ce->name_length + 1);
		memcpy(Z_STRVAL_P(result), ce->name, ce->name_length);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
		Z_TYPE_P(result) = IS_STRING;
	} else {
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "get_class expects an object");
	}
}

/**
 * Fetches a zend class entry from a zval value
 */
zend_class_entry *phalcon_fetch_class(zval *class_name TSRMLS_DC){
	if (Z_TYPE_P(class_name) == IS_STRING){
		return zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "class name must be a string");
		return zend_fetch_class("stdclass", strlen("strlen"), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	}
}

/**
 * Clones an object from obj to destiny
 */
int phalcon_clone(zval *destiny, zval *obj TSRMLS_DC){

	int status = SUCCESS;
	zend_class_entry *ce;
	zend_object_clone_obj_t clone_call;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "__clone method called on non-object");
		status = FAILURE;
	} else {
		ce = Z_OBJCE_P(obj);
		clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
		if (!clone_call) {
			if (ce) {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
			} else {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object");
			}
			status = FAILURE;
		} else {
			if(!EG(exception)){
				Z_OBJVAL_P(destiny) = clone_call(obj TSRMLS_CC);
				Z_TYPE_P(destiny) = IS_OBJECT;
				Z_SET_REFCOUNT_P(destiny, 1);
				Z_SET_ISREF_P(destiny);
				if(EG(exception)){
					zval_ptr_dtor(&destiny);
				}
			}
		}
	}

	if (status == FAILURE){
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

/**
 * Checks if property exists on object
 */
int phalcon_isset_property(zval *object, char *property_name, int property_length TSRMLS_DC){
	if (Z_TYPE_P(object) == IS_OBJECT) {
		if(zend_hash_exists(&Z_OBJCE_P(object)->properties_info, property_name, property_length+1)){
			return 1;
		} else {
			return zend_hash_exists(Z_OBJ_HT_P(object)->get_properties(object TSRMLS_CC), property_name, property_length+1);
		}
	} else {
		return 0;
	}
}

/**
 * Checks if string property exists on object
 */
int phalcon_isset_property_zval(zval *object, zval *property TSRMLS_DC){
	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (Z_TYPE_P(property) == IS_STRING) {
			if(zend_hash_exists(&Z_OBJCE_P(object)->properties_info, Z_STRVAL_P(property), Z_STRLEN_P(property)+1)){
				return 1;
			} else {
				return zend_hash_exists(Z_OBJ_HT_P(object)->get_properties(object TSRMLS_CC), Z_STRVAL_P(property), Z_STRLEN_P(property)+1);
			}
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}

/**
 * Lookup exact class where a property is defined
 *
 */
zend_class_entry *phalcon_lookup_class_ce(zval *object, char *property_name, int property_length TSRMLS_DC){

	zend_class_entry *ce, *original_ce;

	ce = Z_OBJCE_P(object);
	original_ce = ce;
	while (ce) {
		if (zend_hash_exists(&ce->properties_info, property_name, property_length+1)) {
			return ce;
		}
		ce = ce->parent;
	}
	return original_ce;
}

/**
 * Reads a property from an object
 */
int phalcon_read_property(zval **result, zval *object, char *property_name, int property_length, int silent TSRMLS_DC){

	zval *tmp = NULL;
	zend_class_entry *ce;

	ZVAL_NULL((*result));

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
		tmp = zend_read_property(ce, object, property_name, property_length, 1 TSRMLS_CC);
		Z_ADDREF_P(tmp);
		zval_ptr_dtor(result);
		*result = tmp;
		return SUCCESS;
	} else {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
		}
	}
	return FAILURE;
}

/**
 * Reads a property from an object
 */
int phalcon_read_property_zval(zval **result, zval *object, zval *property, int silent TSRMLS_DC){

	zval *tmp = NULL;
	zend_class_entry *ce;

	ZVAL_NULL((*result));

	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (Z_TYPE_P(property) == IS_STRING) {
			ce = phalcon_lookup_class_ce(object, Z_STRVAL_P(property), Z_STRLEN_P(property) TSRMLS_CC);
			tmp = zend_read_property(ce, object, Z_STRVAL_P(property), Z_STRLEN_P(property), 0 TSRMLS_CC);
			Z_ADDREF_P(tmp);
			zval_ptr_dtor(result);
			*result = tmp;
		}
	} else {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
			return FAILURE;
		}
	}
	return SUCCESS;
}

/**
 * Checks whether obj is an object and updates property with long value
 */
int phalcon_update_property_long(zval *obj, char *property_name, int property_length, long value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, property_name, property_length TSRMLS_CC);
	zend_update_property_long(ce, obj, property_name, property_length, value TSRMLS_CC);
	return SUCCESS;
}

/**
 * Checks whether obj is an object and updates property with string value
 */
int phalcon_update_property_string(zval *obj, char *property_name, int property_length, char *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, property_name, property_length TSRMLS_CC);
	zend_update_property_string(ce, obj, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

/**
 * Checks whether obj is an object and updates property with bool value
 */
int phalcon_update_property_bool(zval *obj, char *property_name, int property_length, int value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, property_name, property_length TSRMLS_CC);
	zend_update_property_bool(ce, obj, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

/**
 * Checks whether obj is an object and updates property with null value
 */
int phalcon_update_property_null(zval *obj, char *property_name, int property_length TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, property_name, property_length TSRMLS_CC);
	zend_update_property_null(ce, obj, property_name, property_length TSRMLS_CC);

	return SUCCESS;
}

/**
 * Checks wheter obj is an object and updates property with another zval
 */
int phalcon_update_property_zval(zval *obj, char *property_name, int property_length, zval *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, property_name, property_length TSRMLS_CC);
	zend_update_property(ce, obj, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

/**
 * Checks wheter obj is an object and updates zval property with another zval
 */
int phalcon_update_property_zval_zval(zval *obj, zval *property, zval *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	if (Z_TYPE_P(property) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Property should be string");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(obj, Z_STRVAL_P(property), Z_STRLEN_P(property) TSRMLS_CC);
	zend_update_property(ce, obj, Z_STRVAL_P(property), Z_STRLEN_P(property), value TSRMLS_CC);

	return SUCCESS;
}

/**
 * Check if method exists on certain object
 */
int phalcon_method_exists(zval *object, zval *method_name TSRMLS_DC){

	char *lcname;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		return FAILURE;
	}

	if (Z_TYPE_P(method_name) != IS_STRING) {
		return FAILURE;
	}

	lcname = zend_str_tolower_dup(Z_STRVAL_P(method_name), Z_STRLEN_P(method_name));
	if (zend_hash_exists(&Z_OBJCE_P(object)->function_table, lcname, Z_STRLEN_P(method_name)+1)) {
		efree(lcname);
		return SUCCESS;
	}

	efree(lcname);
	return FAILURE;
}

/**
 * Check if method exists on certain object using explicit char param
 */
int phalcon_method_exists_ex(zval *object, char *method_name, int method_len TSRMLS_DC){

	if (Z_TYPE_P(object) != IS_OBJECT) {
		return FAILURE;
	}

	if (zend_hash_exists(&Z_OBJCE_P(object)->function_table, method_name, method_len+1)) {
		return SUCCESS;
	}

	return FAILURE;
}

/**
 * Query a static property value from a zend_class_entry
 */
int phalcon_read_static_property(zval **result, char *class_name, int class_length, char *property_name, int property_length TSRMLS_DC){
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		*result = zend_read_static_property(*ce, property_name, property_length, PH_FETCH_CLASS_SILENT);
		if (*result) {
			Z_ADDREF_PP(result);
			return SUCCESS;
		}
	}
	return FAILURE;
}

/**
 * Update a static property
 */
int phalcon_update_static_property(char *class_name, int class_length, char *name, int name_length, zval *value TSRMLS_DC){
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		return zend_update_static_property(*ce, name, name_length, value TSRMLS_CC);
	}
	return FAILURE;
}
/* ------ Finished File: \kernel\object.c ------ */

/* ------ Starting File: \kernel\array.c ------ */
void phalcon_convert_to_array(zval **var){
	if (Z_REFCOUNT_PP(var) > 1) {
		
	}
	convert_to_array(*var);
}

/**
 * Check if index exists on an array zval
 */
int phalcon_array_isset(const zval *arr, zval *index){

	zval *copy;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		ALLOC_ZVAL(copy);
		ZVAL_ZVAL(copy, index, 1, 0);
		convert_to_string(copy);
		index = copy;
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			ALLOC_ZVAL(copy);
			ZVAL_ZVAL(copy, index, 1, 0);
			convert_to_long(copy);
			index = copy;
		}
	}

	if (Z_TYPE_P(index) == IS_STRING) {
		return zend_hash_exists(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1);
	} else {
		return zend_hash_index_exists(Z_ARRVAL_P(arr), Z_LVAL_P(index));
	}

	return 0;
}

/**
 * Check if char index exists on an array zval
 */
int phalcon_array_isset_string(const zval *arr, char *index, uint index_length){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}
	return zend_hash_exists(Z_ARRVAL_P(arr), index, index_length);
}

/**
 * Check if char index exists on an array zval
 */
int phalcon_array_isset_long(const zval *arr, ulong index){
	if(Z_TYPE_P(arr)!=IS_ARRAY){
		return 0;
	}
	return zend_hash_index_exists(Z_ARRVAL_P(arr), index);
}

/**
 * Unsets zval index from array
 */
int phalcon_array_unset(zval *arr, zval *index){

	zval *copy;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		ALLOC_ZVAL(copy);
		ZVAL_ZVAL(copy, index, 1, 0);
		convert_to_string(copy);
		index = copy;
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			ALLOC_ZVAL(copy);
			ZVAL_ZVAL(copy, index, 1, 0);
			convert_to_long(copy);
			index = copy;
		}
	}

	if (Z_TYPE_P(index) == IS_STRING) {
		return zend_hash_del(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1);
	} else {
		return zend_hash_index_del(Z_ARRVAL_P(arr), Z_LVAL_P(index));
	}

	return 0;
}

/**
 * Unsets string index from array
 */
int phalcon_array_unset_string(zval *arr, char *index, uint index_length){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}
	return zend_hash_del(Z_ARRVAL_P(arr), index, index_length);
}

/**
 * Unsets long index from array
 */
int phalcon_array_unset_long(zval *arr, ulong index){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}
	return zend_hash_index_del(Z_ARRVAL_P(arr), index);
}

/**
 * Push one or more elements onto the end of an array
 */
int phalcon_array_append(zval **arr, zval *value, int flags TSRMLS_DC){
	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		if((flags & PH_SEPARATE) == PH_SEPARATE){
			if (Z_REFCOUNT_PP(arr) > 1) {
				zval *new_zv;
				Z_DELREF_PP(arr);
				ALLOC_ZVAL(new_zv);
				INIT_PZVAL_COPY(new_zv, *arr);
				*arr = new_zv;
				zval_copy_ctor(new_zv);
			}
		}
		Z_ADDREF_P(value);
		return add_next_index_zval(*arr, value);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
	}
	return FAILURE;
}

/**
 * Updates values on arrays by string or long indexes
 */
int phalcon_array_update(zval **arr, zval *index, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		convert_to_string(index);
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			convert_to_long(index);
		}
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

 	if(Z_TYPE_P(index) == IS_STRING){
		return zend_hash_update(Z_ARRVAL_PP(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1, value, sizeof(zval *), NULL);
	} else {
		if (Z_TYPE_P(index) == IS_LONG) {
			return zend_hash_index_update(Z_ARRVAL_PP(arr), Z_LVAL_P(index), value, sizeof(zval *), NULL);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
	}

	return FAILURE;
}

/**
 * Updates values on arrays by string indexes only
 */
int phalcon_array_update_string(zval **arr, char *index, uint index_length, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

	return zend_hash_update(Z_ARRVAL_PP(arr), index, index_length+1, value, sizeof(zval *), NULL);
}

/**
 * Updates values on arrays by long indexes only
 */
int phalcon_array_update_long(zval **arr, ulong index, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

	return zend_hash_index_update(Z_ARRVAL_PP(arr), index, value, sizeof(zval *), NULL);
}

/**
 * Reads an item from an array using a zval as index
 */
int phalcon_array_fetch(zval **return_value, zval *arr, zval *index, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE, type;

 	if (Z_TYPE_P(index) == IS_ARRAY || Z_TYPE_P(index) == IS_OBJECT) {
		ZVAL_NULL(*return_value);
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
		return FAILURE;
	}

 	if (Z_TYPE_P(index) == IS_NULL) {
		convert_to_string(index);
	}

	ZVAL_NULL(*return_value);

	if (Z_TYPE_P(arr) == IS_NULL || Z_TYPE_P(arr) == IS_BOOL) {
		return FAILURE;
	}

	if (Z_TYPE_P(index) != IS_STRING && Z_TYPE_P(index) != IS_LONG && Z_TYPE_P(index) != IS_DOUBLE) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
		return FAILURE;
	}

 	if (Z_TYPE_P(index) == IS_STRING) {
       	if((type = is_numeric_string(Z_STRVAL_P(index), Z_STRLEN_P(index), NULL, NULL, 0))){
			if (type == IS_LONG) {
				convert_to_long(index);
			}
		}
	} else {
		if (Z_TYPE_P(index) == IS_DOUBLE) {
			convert_to_long(index);
		}
	}

 	if (Z_TYPE_P(index) == IS_STRING) {
		if((result = zend_hash_find(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1, (void**) &zv)) == SUCCESS){
			zval_ptr_dtor(return_value);
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}
	}

 	if (Z_TYPE_P(index) == IS_LONG) {
		if ((result = zend_hash_index_find(Z_ARRVAL_P(arr), Z_LVAL_P(index), (void**) &zv)) == SUCCESS) {
			zval_ptr_dtor(return_value);
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}
	}

	if (silent == PH_NOISY) {
		if (Z_TYPE_P(index) == IS_LONG) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %ld", Z_LVAL_P(index));
		} else {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %s", Z_STRVAL_P(index));
		}
	}

	return FAILURE;
}

/**
 * Reads an item from an array using a string as index
 */
int phalcon_array_fetch_string(zval **return_value, zval *arr, char *index, uint index_length, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE;

	ZVAL_NULL(*return_value);

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		ZVAL_NULL(*return_value);
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		}
		return FAILURE;
	}

	if ((result = zend_hash_find(Z_ARRVAL_P(arr), index, index_length+1, (void**)&zv)) == SUCCESS) {
		zval_ptr_dtor(return_value);
		*return_value = *zv;
		Z_ADDREF_PP(return_value);
		return SUCCESS;
	}

	if (silent == PH_NOISY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %s", index);
	}

	return FAILURE;

}

/**
 * Reads an item from an array using a long as index
 */
int phalcon_array_fetch_long(zval **return_value, zval *arr, ulong index, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE;

	ZVAL_NULL(*return_value);

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		}
		return FAILURE;
	}

	if ((result = zend_hash_index_find(Z_ARRVAL_P(arr), index, (void**)&zv)) == SUCCESS) {
		zval_ptr_dtor(return_value);
		*return_value = *zv;
		Z_ADDREF_PP(return_value);
		return SUCCESS;
	}

	if (silent == PH_NOISY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %ld", index);
	}

	return FAILURE;

}

/**
 * Append a zval to a multi-dimensional array with two indexes
 */
void phalcon_array_append_multi_2(zval **arr, zval *index, zval *value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index, PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(temp) > 1) {
		phalcon_array_update(arr, index, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(temp) != IS_ARRAY) {
		convert_to_array(temp);
		phalcon_array_update(arr, index, &temp, PH_COPY TSRMLS_CC);
	}

	phalcon_array_append(&temp, value, flags TSRMLS_CC);

	zval_ptr_dtor(&temp);

}

/**
 * Updates multi-dimensional array with two zval indexes
 */
void phalcon_array_update_multi_2(zval **arr, zval *index1, zval *index2, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT_CC);
	}

	if (Z_REFCOUNT_P(temp) > 1) {
		phalcon_array_update(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
	}

	if (Z_TYPE_P(temp) != IS_ARRAY) {
		convert_to_array(temp);
		phalcon_array_update(arr, index1, &temp, PH_COPY TSRMLS_CC);
	}

	phalcon_array_update(&temp, index2, value, flags | PH_COPY TSRMLS_CC);

	zval_ptr_dtor(&temp);

}

/**
 * Updates multi-dimensional arrays with two long indices
 *
 * $foo[10][4] = $x
 */
void phalcon_array_update_multi_long_long_2(zval **arr, long index1, long index2, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(temp) > 1) {
		phalcon_array_update_long(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(temp) != IS_ARRAY) {
		convert_to_array(temp);
		phalcon_array_update_long(arr, index1, &temp, PH_COPY TSRMLS_CC);
	}

	phalcon_array_update_long(&temp, index2, value, flags | PH_COPY TSRMLS_CC);

	zval_ptr_dtor(&temp);

}

/**
 * Updates multi-dimensional arrays with one long index and other string
 *
 * $foo[10]["lol"] = $x
 */
void phalcon_array_update_multi_long_str_2(zval **arr, long index1, char *index2, int index2_length, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(temp) > 1) {
		phalcon_array_update_long(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(temp) != IS_ARRAY) {
		convert_to_array(temp);
		phalcon_array_update_long(arr, index1, &temp, PH_COPY TSRMLS_CC);
	}

	phalcon_array_update_string(&temp, index2, index2_length, value, flags | PH_COPY TSRMLS_CC);

	zval_ptr_dtor(&temp);

}

/**
 *
 */
void phalcon_array_update_multi_append_2(zval **arr, zval *index1, zval *value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(temp) > 1) {
		phalcon_array_update(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(temp) != IS_ARRAY) {
		convert_to_array(temp);
		phalcon_array_update(arr, index1, &temp, PH_COPY TSRMLS_CC);
	}
	phalcon_array_append(&temp, value, flags TSRMLS_CC);

	zval_ptr_dtor(&temp);

}
/* ------ Finished File: \kernel\array.c ------ */

/* ------ Starting File: \kernel\operators.c ------ */
/**
 * Performs logical AND function operator
 */
int phalcon_and_function(zval *result, zval *left, zval *right){
	int istrue = zend_is_true(left);
	if (istrue) {
		istrue = zend_is_true(right);
	}
	ZVAL_BOOL(result, istrue);
	return SUCCESS;
}

/**
 * Appends the content of the right operator to the left operator
 */
void phalcon_concat_self(zval **left, zval *right TSRMLS_DC){

	zval *tmp;

	ALLOC_INIT_ZVAL(tmp);
	concat_function(tmp, *left, right TSRMLS_CC);

	if (Z_REFCOUNT_PP(left) > 0) {
		zval_ptr_dtor(left);
	}
	*left = tmp;
}

/**
 * Natural compare with string operadus on right
 */
int phalcon_compare_strict_string(zval *op1, char *op2, int op2_length){

	switch(Z_TYPE_P(op1)){
		case IS_STRING:
			if (!Z_STRLEN_P(op1) && !op2_length) {
				return 1;
			}
			if (Z_STRLEN_P(op1) != op2_length) {
				return 0;
			}
			return zend_binary_strcmp(Z_STRVAL_P(op1), Z_STRLEN_P(op1), op2, op2_length)==0;
		case IS_NULL:
			return zend_binary_strcmp("", 0, op2, op2_length)==0;
		case IS_BOOL:
			if (!Z_BVAL_P(op1)) {
				return zend_binary_strcmp("0", strlen("0"), op2, op2_length)==0;
			} else {
				return zend_binary_strcmp("1", strlen("1"), op2, op2_length)==0;
			}
	}

	return 0;
}

/**
 * Natural is smaller compare with long operadus on right
 */
int phalcon_is_smaller_strict_long(zval *op1, long op2 TSRMLS_DC){

	zval *op2_tmp, *result;
	int bool_result;

	switch(Z_TYPE_P(op1)){
		case IS_LONG:
			return Z_LVAL_P(op1) < op2;
		case IS_DOUBLE:
			return Z_LVAL_P(op1) < (double) op2;
		case IS_NULL:
			return 0 < op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 < op2;
			} else {
				return 1 < op2;
			}
		default:
			ALLOC_INIT_ZVAL(result);
			ALLOC_INIT_ZVAL(op2_tmp);
			ZVAL_LONG(op2_tmp, op2);
			is_smaller_function(result, op1, op2_tmp TSRMLS_CC);
			bool_result = Z_BVAL_P(result);
			zval_ptr_dtor(&result);
			zval_ptr_dtor(&op2_tmp);
			return bool_result;
	}

}

/**
 * Natural is smaller or equal compare with long operadus on right
 */
int phalcon_is_smaller_or_equal_strict_long(zval *op1, long op2 TSRMLS_DC){

	zval *op2_tmp, *result;
	int bool_result;

	switch(Z_TYPE_P(op1)){
		case IS_LONG:
			return Z_LVAL_P(op1) <= op2;
		case IS_DOUBLE:
			return Z_DVAL_P(op1) <= (double) op2;
		case IS_NULL:
			return 0 < op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 <= op2;
			} else {
				return 1 <= op2;
			}
		default:
			ALLOC_INIT_ZVAL(result);
			ALLOC_INIT_ZVAL(op2_tmp);
			ZVAL_LONG(op2_tmp, op2);
			is_smaller_or_equal_function(result, op1, op2_tmp TSRMLS_CC);
			bool_result = Z_BVAL_P(result);
			zval_ptr_dtor(&result);
			zval_ptr_dtor(&op2_tmp);
			return bool_result;
	}

}

/**
 * Do add function keeping ref_count and is_ref
 */
int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC){
	int status;
	int ref_count = Z_REFCOUNT_P(result);
	int is_ref = Z_ISREF_P(result);
	status = add_function(result, op1, op2 TSRMLS_CC);
	Z_SET_REFCOUNT_P(result, ref_count);
	Z_SET_ISREF_TO_P(result, is_ref);
	return status;
}

/**
 * Cast variables converting they to other types
 */
void phalcon_cast(zval *result, zval *var, zend_uint type){

	ZVAL_ZVAL(result, var, 1, 0);

	switch(type){
		case IS_STRING:
			convert_to_string(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		/*case IS_BOOL:
			convert_to_bool(result);
			break;*/
		case IS_ARRAY:
			convert_to_array(result);
			break;
	}

}
/* ------ Finished File: \kernel\operators.c ------ */

/* ------ Starting File: \kernel\concat.c ------ */

void phalcon_concat_sv(zval *result, char *op1, zend_uint op1_len, zval *op2 TSRMLS_DC){

	zval op2_copy;
	int use_copy2 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

}

void phalcon_concat_svs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len TSRMLS_DC){

	zval op2_copy;
	int use_copy2 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

}

void phalcon_concat_svsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4 TSRMLS_DC){

	zval op2_copy, op4_copy;
	int use_copy2 = 0, use_copy4 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

}

void phalcon_concat_svsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len TSRMLS_DC){

	zval op2_copy, op4_copy;
	int use_copy2 = 0, use_copy4 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

}

void phalcon_concat_svsvsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6 TSRMLS_DC){

	zval op2_copy, op4_copy, op6_copy;
	int use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

}

void phalcon_concat_svsvsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, char *op7, zend_uint op7_len TSRMLS_DC){

	zval op2_copy, op4_copy, op6_copy;
	int use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len+Z_STRLEN_P(op6), op7, op7_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

}

void phalcon_concat_svsvv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, zval *op5 TSRMLS_DC){

	zval op2_copy, op4_copy, op5_copy;
	int use_copy2 = 0, use_copy4 = 0, use_copy5 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

}

void phalcon_concat_svv(zval *result, char *op1, zend_uint op1_len, zval *op2, zval *op3 TSRMLS_DC){

	zval op2_copy, op3_copy;
	int use_copy2 = 0, use_copy3 = 0;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	Z_STRLEN_P(result) = op1_len + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), op1, op1_len);
	memcpy(Z_STRVAL_P(result)+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+op1_len+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

}

void phalcon_concat_vs(zval *result, zval *op1, char *op2, zend_uint op2_len TSRMLS_DC){

	zval op1_copy;
	int use_copy1 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + op2_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), op2, op2_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

}

void phalcon_concat_vsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3 TSRMLS_DC){

	zval op1_copy, op3_copy;
	int use_copy1 = 0, use_copy3 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

}

void phalcon_concat_vsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len TSRMLS_DC){

	zval op1_copy, op3_copy;
	int use_copy1 = 0, use_copy3 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3), op4, op4_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

}

void phalcon_concat_vv(zval *result, zval *op1, zval *op2 TSRMLS_DC){

	zval op1_copy, op2_copy;
	int use_copy1 = 0, use_copy2 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + Z_STRLEN_P(op2);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

}

void phalcon_concat_vvs(zval *result, zval *op1, zval *op2, char *op3, zend_uint op3_len TSRMLS_DC){

	zval op1_copy, op2_copy;
	int use_copy1 = 0, use_copy2 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + op3_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), op3, op3_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

}

void phalcon_concat_vvv(zval *result, zval *op1, zval *op2, zval *op3 TSRMLS_DC){

	zval op1_copy, op2_copy, op3_copy;
	int use_copy1 = 0, use_copy2 = 0, use_copy3 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

}

void phalcon_concat_vvvs(zval *result, zval *op1, zval *op2, zval *op3, char *op4, zend_uint op4_len TSRMLS_DC){

	zval op1_copy, op2_copy, op3_copy;
	int use_copy1 = 0, use_copy2 = 0, use_copy3 = 0;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	Z_STRLEN_P(result) = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + op4_len;
	Z_STRVAL_P(result) = (char *) emalloc(Z_STRLEN_P(result) + 1);
	memcpy(Z_STRVAL_P(result), Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+Z_STRLEN_P(op1)+Z_STRLEN_P(op2)+Z_STRLEN_P(op3), op4, op4_len);
	Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	Z_TYPE_P(result) = IS_STRING;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

}

/* ------ Finished File: \kernel\concat.c ------ */

/* ------ Starting File: \kernel\exception.c ------ */
/**
 * Throws an zval object as exception
 */
void phalcon_throw_exception(zval *object TSRMLS_DC){
	Z_ADDREF_P(object);
	zend_throw_exception_object(object TSRMLS_CC);
	phalcon_memory_restore_stack(TSRMLS_C);
}

/**
 * Throws a exception with a single string parameter
 */
void phalcon_throw_exception_string(zend_class_entry *ce, char *message, zend_uint message_len TSRMLS_DC){
	zval *object, *msg;

	ALLOC_INIT_ZVAL(object);
	object_init_ex(object, ce);

	PHALCON_ALLOC_ZVAL_MM(msg);
	ZVAL_STRINGL(msg, message, message_len, 1);

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", msg, PH_CHECK);

	zend_throw_exception_object(object TSRMLS_CC);

	phalcon_memory_restore_stack(TSRMLS_C);
}

/**
 * Latest version of zend_throw_exception_internal
 */
void phalcon_throw_exception_internal(zval *exception TSRMLS_DC) {

	if (exception != NULL) {
		zval *previous = EG(exception);
		zend_exception_set_previous(exception, EG(exception) TSRMLS_CC);
		EG(exception) = exception;
		if (previous) {
			return;
		}
	}
	if (!EG(current_execute_data)) {
		if(EG(exception)) {
			zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
		}
		zend_error(E_ERROR, "Exception thrown without a stack frame");
	}

	if (zend_throw_exception_hook) {
    	zend_throw_exception_hook(exception TSRMLS_CC);
	}

	if (EG(current_execute_data)->opline == NULL ||
    	(EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {
		/* no need to rethrow the exception */
		return;
	}
	EG(opline_before_exception) = EG(current_execute_data)->opline;
	EG(current_execute_data)->opline = EG(exception_op);
	
}

/* ------ Finished File: \kernel\exception.c ------ */

/* ------ Starting File: \kernel\memory.c ------ */
/**
 * Initializes/Reinitializes a variable
 */
inline void phalcon_init_var(zval **var TSRMLS_DC){
	if (*var) {
		if (Z_REFCOUNT_PP(var) > 1) {
			Z_DELREF_PP(var);
			ALLOC_ZVAL(*var);
			Z_SET_REFCOUNT_PP(var, 1);
			Z_UNSET_ISREF_PP(var);
		} else {
			zval_ptr_dtor(var);
			PHALCON_ALLOC_ZVAL(*var);
		}
	} else {
		phalcon_memory_alloc(var TSRMLS_CC);
	}
}

/**
 * Copy/Write variables caring of reference counting
 */
inline void phalcon_cpy_wrt(zval **dest, zval *var TSRMLS_DC){
	if (*dest) {
		if (Z_REFCOUNT_PP(dest) > 0) {
			zval_ptr_dtor(dest);
		}
	} else {
		phalcon_memory_observe(dest TSRMLS_CC);
	}
	Z_ADDREF_P(var);
	*dest = var;
}

/**
 * Initializes memory stack for the active function
 */
int phalcon_memory_grow_stack(TSRMLS_D){

	phalcon_memory_entry *entry;

	if(!PHALCON_GLOBAL(start_memory)){
		PHALCON_GLOBAL(start_memory) = (phalcon_memory_entry *) emalloc(sizeof(phalcon_memory_entry));
		PHALCON_GLOBAL(start_memory)->pointer = -1;
		PHALCON_GLOBAL(start_memory)->prev = NULL;
		PHALCON_GLOBAL(start_memory)->next = NULL;
		PHALCON_GLOBAL(active_memory) = PHALCON_GLOBAL(start_memory);		
	}

	entry = (phalcon_memory_entry *) emalloc(sizeof(phalcon_memory_entry));
	entry->addresses[0] = NULL;
	entry->pointer = -1;
	entry->prev = PHALCON_GLOBAL(active_memory);
	PHALCON_GLOBAL(active_memory)->next = entry;
	PHALCON_GLOBAL(active_memory) = entry;

	return SUCCESS;
}

/**
 * Finishes memory stack by releasing allocated memory
 */
int phalcon_memory_restore_stack(TSRMLS_D){

	register int i;
	phalcon_memory_entry *prev;
	phalcon_memory_entry *active_memory = PHALCON_GLOBAL(active_memory);

	if(active_memory != NULL){

		/*#ifndef PHALCON_RELEASE
		if(!PHALCON_GLOBAL(phalcon_stack_stats)){
			PHALCON_GLOBAL(phalcon_stack_stats) = active_memory->pointer;
		} else {
			if (active_memory->pointer > PHALCON_GLOBAL(phalcon_stack_stats)) {
				PHALCON_GLOBAL(phalcon_stack_stats) = active_memory->pointer;
			}
		}
		#endif*/

		if (active_memory->pointer > -1) {
			for (i=active_memory->pointer;i>=0;i--) {
				if(active_memory->addresses[i] != NULL){
					if(*active_memory->addresses[i] != NULL ){
						if (Z_REFCOUNT_PP(active_memory->addresses[i])-1 == 0) {
							zval_ptr_dtor(active_memory->addresses[i]);
							*active_memory->addresses[i] = NULL;
							active_memory->addresses[i] = NULL;
						} else {
							Z_DELREF_PP(active_memory->addresses[i]);
							if (Z_REFCOUNT_PP(active_memory->addresses[i]) == 1) {
								active_memory->addresses[i] = NULL;
							}
						}
					}
				}
			}
		}

		prev = active_memory->prev;
		efree(PHALCON_GLOBAL(active_memory));
		PHALCON_GLOBAL(active_memory) = prev;
		if (prev != NULL) {
			PHALCON_GLOBAL(active_memory)->next = NULL;
			if (PHALCON_GLOBAL(active_memory) == PHALCON_GLOBAL(start_memory)) {
				efree(PHALCON_GLOBAL(active_memory));
				PHALCON_GLOBAL(start_memory) = NULL;
				PHALCON_GLOBAL(active_memory) = NULL;
			}
		} else {			
			PHALCON_GLOBAL(start_memory) = NULL;
			PHALCON_GLOBAL(active_memory) = NULL;
		}		

	} else {
		return FAILURE;
	}

	return SUCCESS;
}

/**
 * Observes a memory pointer to release its memory at the end of the request
 */
int phalcon_memory_observe(zval **var TSRMLS_DC){
	phalcon_memory_entry *active_memory = PHALCON_GLOBAL(active_memory);
	active_memory->pointer++;
	#ifndef PHALCON_RELEASE
	if(active_memory->pointer>=(PHALCON_MAX_MEMORY_STACK-1)){
		fprintf(stderr, "ERROR: Phalcon memory stack is too small %d", PHALCON_MAX_MEMORY_STACK);
		return FAILURE;
	}
	#endif
	active_memory->addresses[active_memory->pointer] = var;
	active_memory->addresses[active_memory->pointer+1] = NULL;
	return SUCCESS;
}

/**
 * Observe a variable and allocates memory for it
 */
int phalcon_memory_alloc(zval **var TSRMLS_DC){
	phalcon_memory_entry *active_memory = PHALCON_GLOBAL(active_memory);
	active_memory->pointer++;
	#ifndef PHALCON_RELEASE
	if(active_memory->pointer>=(PHALCON_MAX_MEMORY_STACK-1)){
		fprintf(stderr, "ERROR: Phalcon memory stack is too small %d", PHALCON_MAX_MEMORY_STACK);
		return FAILURE;
	}
	#endif
	active_memory->addresses[active_memory->pointer] = var;
	active_memory->addresses[active_memory->pointer+1] = NULL;
	ALLOC_ZVAL(*var);
	INIT_PZVAL(*var);
	return SUCCESS;
}

/**
 * Removes a memory pointer from the active memory pool
 */
int phalcon_memory_remove(zval **var TSRMLS_DC){
	zval_ptr_dtor(var);
	*var = NULL;
	return SUCCESS;
}

/**
 * Cleans the phalcon memory stack recursivery
 */
int phalcon_clean_restore_stack(TSRMLS_D){
	while (PHALCON_GLOBAL(active_memory) != NULL) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}
	return SUCCESS;
}
/* ------ Finished File: \kernel\memory.c ------ */

/* ------ Starting File: \session\namespace.c ------ */
/**
 * Phalcon\Session\Namespace
 *
 * This component helps to separate session data into namespaces. Working by this way
 * you can easily create groups of session variables into the application
 */

/**
 * Constructor of class
 *
 * @param string $name
 */
PHP_METHOD(Phalcon_Session_Namespace, __construct){

	zval *name = NULL, *data = NULL;
	zval *a0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_session_namespace_ce, this_ptr, SL("_data"), a0 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_name"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_STATIC_PARAMS_1(data, "phalcon\\session", "get", t0);
	if (Z_TYPE_P(data) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_data"), data TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Setter of values
 *
 * @param string $property
 * @param string $value
 */
PHP_METHOD(Phalcon_Session_Namespace, __set){

	zval *property = NULL, *value = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &property, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_data"), PH_NOISY_CC);
	phalcon_array_update(&t0, property, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_data"), t0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_name"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_data"), PH_NOISY_CC);
	PHALCON_CALL_STATIC_PARAMS_2_NORETURN("phalcon\\session", "set", t1, t2);
	
	PHALCON_MM_RESTORE();
}

/**
 * Getter of values
 *
 * @param string $property
 * @return string
 */
PHP_METHOD(Phalcon_Session_Namespace, __get){

	zval *property = NULL, *data = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(data);
	phalcon_read_property(&data, this_ptr, SL("_data"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(data, property);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, data, property, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \session\namespace.c ------ */

/* ------ Starting File: \loader.c ------ */
/**
 * Phalcon\Loader
 *
 * This component helps to load your project classes automatically based on some conventions
 *
 *
 */

PHP_METHOD(Phalcon_Loader, __construct){

	zval *a0 = NULL, *a1 = NULL;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_loader_ce, this_ptr, SL("_namespaces"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_loader_ce, this_ptr, SL("_directories"), a1 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Register namespaces and their related directories
 *
 * @param array $namespaces
 */
PHP_METHOD(Phalcon_Loader, registerNamespaces){

	zval *namespaces = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &namespaces) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(namespaces) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_loader_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Parameter ", namespaces, " must be an Array");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_namespaces"), namespaces TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Register directories on which "not found" classes could be found
 *
 * @param array $directories
 */
PHP_METHOD(Phalcon_Loader, registerDirs){

	zval *directories = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &directories) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(directories) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter \\$directories must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_directories"), directories TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Register classes and their locations
 *
 * @param array $directories
 */
PHP_METHOD(Phalcon_Loader, registerClasses){

	zval *classes = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(classes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter \\$classes must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_classes"), classes TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Register the autoload method
 */
PHP_METHOD(Phalcon_Loader, register){

	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_array_append(&a0, this_ptr, PH_SEPARATE TSRMLS_CC);
	add_next_index_stringl(a0, SL("autoLoad"), 1);
	PHALCON_CALL_FUNC_PARAMS_1_NORETURN("spl_autoload_register", a0);
	
	PHALCON_MM_RESTORE();
}

/**
 * Makes the work of autoload registered classes
 *
 * @param string $className
 * @return boolean
 */
PHP_METHOD(Phalcon_Loader, autoLoad){

	zval *class_name = NULL, *file_name = NULL, *directory = NULL, *preffix = NULL;
	zval *path = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &class_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_classes"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, class_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_classes"), PH_NOISY_CC);
		PHALCON_INIT_VAR(file_name);
		phalcon_array_fetch(&file_name, t1, class_name, PH_NOISY_CC);
		if (phalcon_require(file_name TSRMLS_CC) == FAILURE) {
			return;
		}
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_namespaces"), PH_NOISY_CC);
	if (phalcon_valid_foreach(t2 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t2);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_0c08_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_0c08_0;
		} else {
			PHALCON_INIT_VAR(preffix);
			PHALCON_GET_FOREACH_KEY(preffix, ah0, hp0);
		}
		PHALCON_INIT_VAR(directory);
		ZVAL_ZVAL(directory, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "strlen", class_name);
		PHALCON_INIT_VAR(r1);
		is_smaller_function(r1, preffix, r0 TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 0);
			PHALCON_INIT_VAR(r2);
			PHALCON_CALL_FUNC_PARAMS_1(r2, "strlen", preffix);
			PHALCON_INIT_VAR(r3);
			PHALCON_CALL_FUNC_PARAMS_3(r3, "substr", class_name, c0, r2);
			PHALCON_INIT_VAR(r4);
			is_equal_function(r4, r3, preffix TSRMLS_CC);
			if (zend_is_true(r4)) {
				PHALCON_INIT_VAR(r5);
				PHALCON_CONCAT_VS(r5, preffix, "\\");
				PHALCON_INIT_VAR(c1);
				ZVAL_STRING(c1, "", 1);
				PHALCON_INIT_VAR(file_name);
				phalcon_fast_str_replace(file_name, r5, c1, class_name TSRMLS_CC);
				if (zend_is_true(file_name)) {
					PHALCON_INIT_VAR(c2);
					ZVAL_STRING(c2, "\\", 1);
					PHALCON_INIT_VAR(t3);
					zend_get_constant(SL("DIRECTORY_SEPARATOR"), t3 TSRMLS_CC);
					PHALCON_INIT_VAR(r6);
					PHALCON_CONCAT_VVS(r6, directory, file_name, ".php");
					PHALCON_INIT_VAR(path);
					phalcon_fast_str_replace(path, c2, t3, r6 TSRMLS_CC);
					if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
						if (phalcon_require(path TSRMLS_CC) == FAILURE) {
							return;
						}
						PHALCON_MM_RESTORE();
						RETURN_TRUE;
					}
				}
			}
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_0c08_0;
		fee_0c08_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_directories"), PH_NOISY_CC);
	if (phalcon_valid_foreach(t4 TSRMLS_CC)) {
		ah1 = Z_ARRVAL_P(t4);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
		fes_0c08_1:
		if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
			goto fee_0c08_1;
		}
		
		PHALCON_INIT_VAR(directory);
		ZVAL_ZVAL(directory, *hd, 1, 0);
		PHALCON_INIT_VAR(path);
		PHALCON_CONCAT_VVS(path, directory, class_name, ".php");
		if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
			if (phalcon_require(path TSRMLS_CC) == FAILURE) {
				return;
			}
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
		zend_hash_move_forward_ex(ah1, &hp1);
		goto fes_0c08_1;
		fee_0c08_1:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \loader.c ------ */

/* ------ Starting File: \text.c ------ */
/**
 * Phalcon_Text
 *
 * Provides utilities when working with strings
 */

/**
 * Converts strings to camelize style
 *
 * @param string $str
 * @return string
 */
PHP_METHOD(Phalcon_Text, camelize){

	zval *str = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, " ", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "", 1);
	PHALCON_INIT_VAR(c2);
	ZVAL_STRING(c2, "_", 1);
	PHALCON_INIT_VAR(c3);
	ZVAL_STRING(c3, " ", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "strtolower", str);
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_str_replace(r1, c2, c3, r0 TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_1(r2, "ucwords", r1);
	PHALCON_ALLOC_ZVAL_MM(r3);
	phalcon_fast_str_replace(r3, c0, c1, r2 TSRMLS_CC);
	RETURN_CTOR(r3);
}

/**
 * Uncamelize strings which are camelized
 *
 * @param string $str
 * @return string
 */
PHP_METHOD(Phalcon_Text, uncamelize){

	zval *str = NULL, *patterns = NULL, *replacement = NULL, *pattern = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(patterns);
	array_init(patterns);
	add_assoc_stringl_ex(patterns, SL("/(?<=(?:[A-Z]))([A-Z]+)([A-Z][A-z])/")+1, SL("\\1_\\2"), 1);
	add_assoc_stringl_ex(patterns, SL("/(?<=(?:[a-z]))([A-Z])/")+1, SL("_\\1"), 1);
	if (phalcon_valid_foreach(patterns TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(patterns);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_f8ee_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_f8ee_0;
		} else {
			PHALCON_INIT_VAR(pattern);
			PHALCON_GET_FOREACH_KEY(pattern, ah0, hp0);
		}
		PHALCON_INIT_VAR(replacement);
		ZVAL_ZVAL(replacement, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_FUNC_PARAMS_2(r0, "preg_match", pattern, str);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(r1);
			PHALCON_CALL_FUNC_PARAMS_3(r1, "preg_replace", pattern, replacement, str);
			PHALCON_INIT_VAR(r2);
			PHALCON_CALL_FUNC_PARAMS_1(r2, "strtolower", r1);
			RETURN_CTOR(r2);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_f8ee_0;
		fee_f8ee_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_FUNC_PARAMS_1(r3, "strtolower", str);
	RETURN_CTOR(r3);
}

/* ------ Finished File: \text.c ------ */

/* ------ Starting File: \router\rewrite.c ------ */
/**
 * Phalcon\Router\Rewrite
 *
 * Phalcon\Router\Rewrite is the standard framework router. Routing is the
 * process of taking a URI endpoint (that part of the URI which comes after the base URL) and
 * decomposing it into parameters to determine which module, controller, and
 * action of that controller should receive the request
 *
 *
 */

PHP_METHOD(Phalcon_Router_Rewrite, __construct){

	zval *a0 = NULL;

	PHALCON_MM_GROW();

	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_router_rewrite_ce, this_ptr, SL("_params"), a0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Get rewrite info
 */
PHP_METHOD(Phalcon_Router_Rewrite, _getRewriteUri){

	zval *uri = NULL, *prefix = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("_url")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(uri);
		phalcon_array_fetch_string(&uri, g0, SL("_url"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
		if (zend_is_true(prefix)) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_CONCAT_SVS(r0, "~^", prefix, "~");
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "", 1);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_FUNC_PARAMS_3(r1, "preg_replace", r0, c0, uri);
			PHALCON_CPY_WRT(uri, r1);
		}
		
		
		RETURN_CCTOR(uri);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Set a uri prefix. This will be replaced from the beginning of the uri
 */
PHP_METHOD(Phalcon_Router_Rewrite, setPrefix){

	zval *prefix = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_prefix"), prefix TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Handles routing information received from the rewrite engine
 *
 * @param string $uri
 */
PHP_METHOD(Phalcon_Router_Rewrite, handle){

	zval *uri = NULL, *parts = NULL, *params = NULL, *number_parts = NULL, *i = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!uri) {
		PHALCON_ALLOC_ZVAL_MM(uri);
		ZVAL_NULL(uri);
	} else {
		PHALCON_SEPARATE_PARAM(uri);
	}
	
	if (!zend_is_true(uri)) {
		PHALCON_INIT_VAR(uri);
		PHALCON_CALL_METHOD(uri, this_ptr, "_getrewriteuri", PH_NO_CHECK);
	}
	if (zend_is_true(uri)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "/", 1);
		PHALCON_INIT_VAR(parts);
		phalcon_fast_explode(parts, c0, uri TSRMLS_CC);
		eval_int = phalcon_array_isset_long(parts, 0);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_long(&r0, parts, 0, PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_filter_alphanum(r1, r0);
			phalcon_update_property_zval(this_ptr, SL("_controller"), r1 TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(t0);
			phalcon_read_property(&t0, this_ptr, SL("_controller"), PH_NOISY_CC);
			if (!zend_is_true(t0)) {
				phalcon_update_property_null(this_ptr, SL("_controller") TSRMLS_CC);
			}
		} else {
			phalcon_update_property_null(this_ptr, SL("_controller") TSRMLS_CC);
		}
		
		eval_int = phalcon_array_isset_long(parts, 1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_long(&r2, parts, 1, PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_filter_alphanum(r3, r2);
			phalcon_update_property_zval(this_ptr, SL("_action"), r3 TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(t1);
			phalcon_read_property(&t1, this_ptr, SL("_action"), PH_NOISY_CC);
			if (!zend_is_true(t1)) {
				phalcon_update_property_null(this_ptr, SL("_action") TSRMLS_CC);
			}
		} else {
			phalcon_update_property_null(this_ptr, SL("_action") TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(params);
		array_init(params);
		
		PHALCON_INIT_VAR(number_parts);
		phalcon_fast_count(number_parts, parts TSRMLS_CC);
		
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 2);
		fs_ef57_0:
			
			PHALCON_INIT_VAR(r4);
			is_smaller_function(r4, i, number_parts TSRMLS_CC);
			if (!zend_is_true(r4)) {
				goto fe_ef57_0;
			}
			PHALCON_INIT_VAR(r5);
			phalcon_array_fetch(&r5, parts, i, PH_NOISY_CC);
			phalcon_array_append(&params, r5, PH_SEPARATE TSRMLS_CC);
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto fs_ef57_0;
		fe_ef57_0:
		phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	} else {
		phalcon_update_property_null(this_ptr, SL("_controller") TSRMLS_CC);
		phalcon_update_property_null(this_ptr, SL("_action") TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns proccesed controller name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Router_Rewrite, getControllerName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controller"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns proccesed action name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Router_Rewrite, getActionName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_action"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns proccesed extra params
 *
 * @return array
 */
PHP_METHOD(Phalcon_Router_Rewrite, getParams){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \router\rewrite.c ------ */

/* ------ Starting File: \router\regex.c ------ */
/**
 * Phalcon\Router\Regex
 *
 * Phalcon\Router\Regex is the standard framework router. Routing is the
 * process of taking a URI endpoint (that part of the URI which comes after the base URL) and
 * decomposing it into parameters to determine which module, controller, and
 * action of that controller should receive the request
 *
 *
 *
 * Settings baseUri first:
 *
 *
 *
 */

PHP_METHOD(Phalcon_Router_Regex, __construct){

	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL, *a4 = NULL, *a5 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_router_regex_ce, this_ptr, SL("_params"), a0 TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	PHALCON_ALLOC_ZVAL_MM(a2);
	array_init(a2);
	add_assoc_stringl_ex(a2, SL("pattern")+1, SL("#^/([a-zA-Z0-9\\_]+)[/]{0,1}$#"), 1);
	PHALCON_ALLOC_ZVAL_MM(a3);
	array_init(a3);
	add_assoc_long_ex(a3, SL("controller")+1, 1);
	phalcon_array_update_string(&a2, SL("paths"), &a3, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a1, a2, PH_SEPARATE TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(a4);
	array_init(a4);
	add_assoc_stringl_ex(a4, SL("pattern")+1, SL("#^/([a-zA-Z0-9\\_]+)/([a-zA-Z0-9\\_]+)(/.*)*$#"), 1);
	PHALCON_ALLOC_ZVAL_MM(a5);
	array_init(a5);
	add_assoc_long_ex(a5, SL("controller")+1, 1);
	add_assoc_long_ex(a5, SL("action")+1, 2);
	add_assoc_long_ex(a5, SL("params")+1, 3);
	phalcon_array_update_string(&a4, SL("paths"), &a5, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a1, a4, PH_SEPARATE TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_routes"), a1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Get rewrite info
 * 
 * @return string
 */
PHP_METHOD(Phalcon_Router_Regex, _getRewriteUri){

	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("_url")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("_url"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Set the base of application
 *
 * @param string $baseUri
 */
PHP_METHOD(Phalcon_Router_Regex, setBaseUri){

	zval *base_uri = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_baseUri"), base_uri TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Replaces placeholders from pattern returning a valid PCRE regular expression
 *
 * @param string $pattern
 * @return string
 */
PHP_METHOD(Phalcon_Router_Regex, compilePattern){

	zval *pattern = NULL, *id_pattern = NULL, *compiled_pattern = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL, *c4 = NULL, *c5 = NULL, *c6 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &pattern) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(id_pattern);
	ZVAL_STRING(id_pattern, "/([a-zA-Z0-9\\_]+)", 1);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ":", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_strpos(r0, pattern, c0 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "/:controller", 1);
		PHALCON_INIT_VAR(compiled_pattern);
		phalcon_fast_str_replace(compiled_pattern, c1, id_pattern, pattern TSRMLS_CC);
		
		PHALCON_INIT_VAR(c2);
		ZVAL_STRING(c2, "/:action", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_fast_str_replace(r1, c2, id_pattern, compiled_pattern TSRMLS_CC);
		PHALCON_CPY_WRT(compiled_pattern, r1);
		
		PHALCON_INIT_VAR(c3);
		ZVAL_STRING(c3, "/:params", 1);
		
		PHALCON_INIT_VAR(c4);
		ZVAL_STRING(c4, "(/.*)*", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_fast_str_replace(r2, c3, c4, compiled_pattern TSRMLS_CC);
		PHALCON_CPY_WRT(compiled_pattern, r2);
		
		PHALCON_INIT_VAR(c5);
		ZVAL_STRING(c5, "/:int", 1);
		
		PHALCON_INIT_VAR(c6);
		ZVAL_STRING(c6, "/([0-9]+)", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_fast_str_replace(r3, c5, c6, compiled_pattern TSRMLS_CC);
		PHALCON_CPY_WRT(compiled_pattern, r3);
	} else {
		PHALCON_CPY_WRT(compiled_pattern, pattern);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CONCAT_SVS(r4, "#^", compiled_pattern, "$#");
	
	RETURN_CTOR(r4);
}

/**
 * Add a route to the router
 *
 * @param string $pattern
 * @param string/array $paths
 */
PHP_METHOD(Phalcon_Router_Regex, add){

	zval *pattern = NULL, *paths = NULL, *parts = NULL, *route_paths = NULL, *pcre_pattern = NULL;
	zval *matches = NULL, *match = NULL, *n = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *a0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(paths) == IS_STRING) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "::", 1);
		PHALCON_INIT_VAR(parts);
		phalcon_fast_explode(parts, c0, paths TSRMLS_CC);
		
		PHALCON_INIT_VAR(route_paths);
		array_init(route_paths);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_long(&r0, parts, 0, PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_FUNC_PARAMS_1(r1, "strtolower", r0);
		phalcon_array_update_string(&route_paths, SL("controller"), &r1, PH_COPY | PH_SEPARATE TSRMLS_CC);
		eval_int = phalcon_array_isset_long(parts, 1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_long(&r2, parts, 1, PH_NOISY_CC);
			phalcon_array_update_string(&route_paths, SL("action"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	} else {
		PHALCON_CPY_WRT(route_paths, paths);
	}
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "#", 1);
	
	PHALCON_INIT_VAR(c2);
	ZVAL_STRING(c2, "\\#", 1);
	
	PHALCON_INIT_VAR(pcre_pattern);
	phalcon_fast_str_replace(pcre_pattern, c1, c2, pattern TSRMLS_CC);
	
	PHALCON_INIT_VAR(c3);
	ZVAL_STRING(c3, "{", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	phalcon_fast_strpos(r3, pcre_pattern, c3 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(matches);
		array_init(matches);
		
		PHALCON_INIT_VAR(p0[0]);
		ZVAL_STRING(p0[0], "#{([a-zA-Z0-9\\_\\-]+):([^}]+)}#", 1);
		p0[1] = pcre_pattern;
		Z_SET_ISREF_P(matches);
		p0[2] = matches;
		
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 2);
		p0[3] = t0;
		
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CALL_FUNC_PARAMS(r4, "preg_match_all", 4, p0);
		Z_UNSET_ISREF_P(p0[2]);
		if (zend_is_true(r4)) {
			if (phalcon_valid_foreach(matches TSRMLS_CC)) {
				ah0 = Z_ARRVAL_P(matches);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
				fes_62c6_0:
				if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
					goto fee_62c6_0;
				} else {
					PHALCON_INIT_VAR(n);
					PHALCON_GET_FOREACH_KEY(n, ah0, hp0);
				}
				PHALCON_INIT_VAR(match);
				ZVAL_ZVAL(match, *hd, 1, 0);
				PHALCON_INIT_VAR(r5);
				phalcon_array_fetch_long(&r5, match, 0, PH_NOISY_CC);
				PHALCON_INIT_VAR(r6);
				phalcon_array_fetch_long(&r6, match, 2, PH_NOISY_CC);
				PHALCON_INIT_VAR(r7);
				PHALCON_CONCAT_SVS(r7, "(", r6, ")");
				PHALCON_INIT_VAR(r8);
				phalcon_fast_str_replace(r8, r5, r7, pcre_pattern TSRMLS_CC);
				PHALCON_CPY_WRT(pcre_pattern, r8);
				
				PHALCON_INIT_VAR(t1);
				ZVAL_LONG(t1, 1);
				
				PHALCON_INIT_VAR(r9);
				phalcon_add_function(r9, n, t1 TSRMLS_CC);
				
				PHALCON_INIT_VAR(r10);
				phalcon_array_fetch_long(&r10, match, 1, PH_NOISY_CC);
				phalcon_array_update(&route_paths, r10, &r9, PH_COPY | PH_SEPARATE TSRMLS_CC);
				zend_hash_move_forward_ex(ah0, &hp0);
				goto fes_62c6_0;
				fee_62c6_0:
				if(0){}
			} else {
				return;
			}
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	PHALCON_ALLOC_ZVAL_MM(r11);
	PHALCON_CALL_METHOD_PARAMS_1(r11, this_ptr, "compilepattern", pcre_pattern, PH_NO_CHECK);
	phalcon_array_update_string(&a0, SL("pattern"), &r11, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&a0, SL("paths"), &route_paths, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_routes"), PH_NOISY_CC);
	phalcon_array_append(&t2, a0, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_routes"), t2 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Handles routing information received from the rewrite engine
 *
 * @param string $uri
 */
PHP_METHOD(Phalcon_Router_Regex, handle){

	zval *uri = NULL, *real_uri = NULL, *route_found = NULL, *parts = NULL, *params = NULL;
	zval *matches = NULL, *route = NULL, *position = NULL, *part = NULL, *str_params = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *a0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!uri) {
		PHALCON_ALLOC_ZVAL_MM(uri);
		ZVAL_NULL(uri);
	}
	
	if (!zend_is_true(uri)) {
		PHALCON_INIT_VAR(real_uri);
		PHALCON_CALL_METHOD(real_uri, this_ptr, "_getrewriteuri", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(real_uri, uri);
	}
	
	PHALCON_INIT_VAR(route_found);
	ZVAL_BOOL(route_found, 0);
	
	PHALCON_INIT_VAR(parts);
	array_init(parts);
	
	PHALCON_INIT_VAR(params);
	array_init(params);
	
	PHALCON_INIT_VAR(matches);
	array_init(matches);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_routes"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "array_reverse", t0);
	if (phalcon_valid_foreach(r0 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(r0);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_62c6_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_62c6_1;
		}
		
		PHALCON_INIT_VAR(route);
		ZVAL_ZVAL(route, *hd, 1, 0);
		PHALCON_INIT_VAR(parts);
		phalcon_array_fetch_string(&parts, route, SL("paths"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch_string(&r1, route, SL("pattern"), PH_NOISY_CC);
		Z_SET_ISREF_P(matches);
		
		PHALCON_INIT_VAR(r2);
		PHALCON_CALL_FUNC_PARAMS_3(r2, "preg_match", r1, real_uri, matches);
		Z_UNSET_ISREF_P(matches);
		if (zend_is_true(r2)) {
			PHALCON_INIT_VAR(r3);
			phalcon_array_fetch_string(&r3, route, SL("paths"), PH_NOISY_CC);
			if (phalcon_valid_foreach(r3 TSRMLS_CC)) {
				ah1 = Z_ARRVAL_P(r3);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
				fes_62c6_2:
				if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
					goto fee_62c6_2;
				} else {
					PHALCON_INIT_VAR(part);
					PHALCON_GET_FOREACH_KEY(part, ah1, hp1);
				}
				PHALCON_INIT_VAR(position);
				ZVAL_ZVAL(position, *hd, 1, 0);
				eval_int = phalcon_array_isset(matches, position);
				if (eval_int) {
					PHALCON_INIT_VAR(r4);
					phalcon_array_fetch(&r4, matches, position, PH_NOISY_CC);
					phalcon_array_update(&parts, part, &r4, PH_COPY | PH_SEPARATE TSRMLS_CC);
				}
				zend_hash_move_forward_ex(ah1, &hp1);
				goto fes_62c6_2;
				fee_62c6_2:
				if(0){}
			} else {
				return;
			}
			phalcon_update_property_zval(this_ptr, SL("_currentRoute"), route TSRMLS_CC);
			
			PHALCON_INIT_VAR(route_found);
			ZVAL_BOOL(route_found, 1);
			goto fee_62c6_1;
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_62c6_1;
		fee_62c6_1:
		if(0){}
	} else {
		return;
	}
	if (zend_is_true(route_found)) {
		eval_int = phalcon_array_isset_string(parts, SL("controller")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r5);
			phalcon_array_fetch_string(&r5, parts, SL("controller"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_controller"), r5 TSRMLS_CC);
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SL("controller")+1);
		} else {
			phalcon_update_property_null(this_ptr, SL("_controller") TSRMLS_CC);
		}
		eval_int = phalcon_array_isset_string(parts, SL("action")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r6);
			phalcon_array_fetch_string(&r6, parts, SL("action"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_action"), r6 TSRMLS_CC);
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SL("action")+1);
		} else {
			phalcon_update_property_null(this_ptr, SL("_action") TSRMLS_CC);
		}
		
		eval_int = phalcon_array_isset_string(parts, SL("params")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r7);
			phalcon_array_fetch_string(&r7, parts, SL("params"), PH_NOISY_CC);
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 1);
			PHALCON_INIT_VAR(str_params);
			PHALCON_CALL_FUNC_PARAMS_2(str_params, "substr", r7, c0);
			if (zend_is_true(str_params)) {
				PHALCON_INIT_VAR(c1);
				ZVAL_STRING(c1, "/", 1);
				PHALCON_INIT_VAR(params);
				phalcon_fast_explode(params, c1, str_params TSRMLS_CC);
			}
			
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SL("params")+1);
		}
		
		PHALCON_ALLOC_ZVAL_MM(r8);
		PHALCON_CALL_FUNC_PARAMS_2(r8, "array_merge", params, parts);
		phalcon_update_property_zval(this_ptr, SL("_params"), r8 TSRMLS_CC);
	} else {
		phalcon_update_property_null(this_ptr, SL("_action") TSRMLS_CC);
		phalcon_update_property_null(this_ptr, SL("_controller") TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		phalcon_update_property_zval(this_ptr, SL("_params"), a0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns proccesed controller name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Router_Regex, getControllerName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controller"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns proccesed action name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Router_Regex, getActionName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_action"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns proccesed extra params
 *
 * @return array
 */
PHP_METHOD(Phalcon_Router_Regex, getParams){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the route that matchs the handled URI
 *
 * @return string
 */
PHP_METHOD(Phalcon_Router_Regex, getCurrentRoute){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_currentRoute"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \router\regex.c ------ */

/* ------ Starting File: \config\exception.c ------ */
/**
 * Phalcon_Config_Exception
 *
 * Exceptions thrown in Phalcon_Config will use this class
 *
 */

/* ------ Finished File: \config\exception.c ------ */

/* ------ Starting File: \config\adapter\ini.c ------ */
/**
 * Phalcon_Config_Adapter_Ini
 *
 * Reads ini files and convert it to Phalcon_Config objects.
 *
 * Given the next configuration file:
 *
 * 
 *
 * You can read it as follows:
 *
 * 
 *
 */

/**
 * Phalcon_Config_Adapter_Ini constructor
 *
 * @param string $filePath
 * @return Phalcon_Config_Adapter_Ini
 *
 */
PHP_METHOD(Phalcon_Config_Adapter_Ini, __construct){

	zval *file_path = NULL, *config = NULL, *ini_config = NULL, *directives = NULL;
	zval *section = NULL, *value = NULL, *key = NULL, *directive_parts = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *i0 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &file_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(config);
	array_init(config);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_BOOL(c0, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "parse_ini_file", file_path, c0);
	PHALCON_CPY_WRT(ini_config, r0);
	if (Z_TYPE_P(ini_config) == IS_BOOL && !Z_BVAL_P(ini_config)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_config_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_FUNC_PARAMS_1(r1, "basename", file_path);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SVS(r2, "Configuration file ", r1, " can't be loaded");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r2, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	if (phalcon_valid_foreach(ini_config TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(ini_config);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_b840_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_b840_0;
		} else {
			PHALCON_INIT_VAR(section);
			PHALCON_GET_FOREACH_KEY(section, ah0, hp0);
		}
		PHALCON_INIT_VAR(directives);
		ZVAL_ZVAL(directives, *hd, 1, 0);
		if (phalcon_valid_foreach(directives TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(directives);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_b840_1:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_b840_1;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah1, hp1);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			PHALCON_INIT_VAR(c1);
			ZVAL_STRING(c1, ".", 1);
			PHALCON_INIT_VAR(r3);
			phalcon_fast_strpos(r3, key, c1 TSRMLS_CC);
			if (Z_TYPE_P(r3) != IS_BOOL || (Z_TYPE_P(r3) == IS_BOOL && Z_BVAL_P(r3))) {
				PHALCON_INIT_VAR(c2);
				ZVAL_STRING(c2, ".", 1);
				PHALCON_INIT_VAR(directive_parts);
				phalcon_fast_explode(directive_parts, c2, key TSRMLS_CC);
				if (Z_TYPE_P(config) == IS_ARRAY) {
					PHALCON_INIT_VAR(t0);
					phalcon_array_fetch(&t0, config, section, PH_SILENT_CC);
				}
				if (Z_REFCOUNT_P(t0) > 1) {
					phalcon_array_update(&config, section, &t0, PH_COPY | PH_CTOR TSRMLS_CC);
				}
				if (Z_TYPE_P(t0) != IS_ARRAY) {
					convert_to_array(t0);
					phalcon_array_update(&config, section, &t0, PH_COPY TSRMLS_CC);
				}
				PHALCON_INIT_VAR(r4);
				phalcon_array_fetch_long(&r4, directive_parts, 0, PH_NOISY_CC);
				if (Z_TYPE_P(t0) == IS_ARRAY) {
					PHALCON_INIT_VAR(t1);
					phalcon_array_fetch(&t1, t0, r4, PH_SILENT_CC);
				}
				if (Z_REFCOUNT_P(t1) > 1) {
					phalcon_array_update(&t0, r4, &t1, PH_COPY | PH_CTOR TSRMLS_CC);
				}
				if (Z_TYPE_P(t1) != IS_ARRAY) {
					convert_to_array(t1);
					phalcon_array_update(&t0, r4, &t1, PH_COPY TSRMLS_CC);
				}
				
				PHALCON_INIT_VAR(r5);
				phalcon_array_fetch_long(&r5, directive_parts, 1, PH_NOISY_CC);
				phalcon_array_update(&t1, r5, &value, PH_COPY TSRMLS_CC);
			} else {
				phalcon_array_update_multi_2(&config, section, key, &value, 0 TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_b840_1;
			fee_b840_1:
			if(0){}
		} else {
			return;
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_b840_0;
		fee_b840_0:
		if(0){}
	} else {
		return;
	}
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Config\\Adapter\\Ini", "__construct", config);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \config\adapter\ini.c ------ */

/* ------ Starting File: \exception.c ------ */
/**
 * Phalcon\Exception
 *
 * All framework exceptions should use or extend this exception
 */

/* ------ Finished File: \exception.c ------ */

/* ------ Starting File: \db.c ------ */
/**
 * Phalcon\Db
 *
 * Phalcon\Db and its related classes provide a simple SQL database interface for Phalcon Framework.
 * The Phalcon_Db is the basic class you use to connect your PHP application to an RDBMS.
 * There is a different adapter class for each brand of RDBMS.
 *
 * This component is intended to lower level database operations. If you want to interact with databases using
 * high level abstraction use Phalcon\Model.
 *
 * Phalcon\Db is an abstract class. You only can use it with a database adapter like Phalcon\Db\Adapter\Mysql
 *
 * 
 */

/**
 * Phalcon\Db constructor, this method should not be called directly. Use Phalcon\Db::factory instead
 *
 * @param stdClass $descriptor
 */
PHP_METHOD(Phalcon_Db, __construct){

	zval *descriptor = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_descriptor"), descriptor TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets a logger class to log all SQL operations sent to database server
 *
 * @param Phalcon\Logger $logger
 */
PHP_METHOD(Phalcon_Db, setLogger){

	zval *logger = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &logger) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(logger) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Parameter \\$logger must be an Object");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_logger"), logger TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the active logger
 *
 * @return Phalcon\Logger
 */
PHP_METHOD(Phalcon_Db, getLogger){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_logger"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sends arbitrary text to a related logger in the instance
 *
 * @param string $sqlStatement
 * @param int $type
 */
PHP_METHOD(Phalcon_Db, log){

	zval *sql_statement = NULL, *type = NULL, *logger = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_statement, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(logger);
	phalcon_read_property(&logger, this_ptr, SL("_logger"), PH_NOISY_CC);
	if (zend_is_true(logger)) {
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(logger, "log", sql_statement, type, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets a database profiler to the connection
 *
 * @param Phalcon\Db\Profiler $profiler
 */
PHP_METHOD(Phalcon_Db, setProfiler){

	zval *profiler = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &profiler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(profiler) == IS_OBJECT) {
		phalcon_update_property_zval(this_ptr, SL("_profiler"), profiler TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Profiler must be an object");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the first row in a SQL query result
 *
 * @param string $sqlQuery
 * @param int $fetchMode
 * @return array
 */
PHP_METHOD(Phalcon_Db, fetchOne){

	zval *sql_query = NULL, *fetch_mode = NULL, *result = NULL;
	zval *r0 = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &sql_query, &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!fetch_mode) {
		PHALCON_ALLOC_ZVAL_MM(fetch_mode);
		ZVAL_LONG(fetch_mode, 2);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, this_ptr, "query", sql_query, PH_NO_CHECK);
	if (Z_TYPE_P(result) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_mode, PH_NO_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, result, "fetcharray", PH_NO_CHECK);
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		
		RETURN_CTOR(a0);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Dumps the complete result of a query into an array
 *
 * @param string $sqlQuery
 * @param int $fetchMode
 * @return array
 */
PHP_METHOD(Phalcon_Db, fetchAll){

	zval *sql_query = NULL, *fetch_mode = NULL, *results = NULL, *result = NULL;
	zval *row = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &sql_query, &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!fetch_mode) {
		PHALCON_ALLOC_ZVAL_MM(fetch_mode);
		ZVAL_LONG(fetch_mode, 2);
	}
	
	PHALCON_INIT_VAR(results);
	array_init(results);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, this_ptr, "query", sql_query, PH_NO_CHECK);
	if (Z_TYPE_P(result) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_mode, PH_NO_CHECK);
		ws_e7f0_0:
			
			PHALCON_INIT_VAR(r0);
			PHALCON_CALL_METHOD(r0, result, "fetcharray", PH_NO_CHECK);
			PHALCON_CPY_WRT(row, r0);
			if (!zend_is_true(row)) {
				goto we_e7f0_0;
			}
			phalcon_array_append(&results, row, PH_SEPARATE TSRMLS_CC);
			goto ws_e7f0_0;
		we_e7f0_0:
		if(0){}
	}
	
	
	RETURN_CTOR(results);
}

/**
 * Inserts data into a table using custom RBDM SQL syntax
 *
 * @param string $table
 * @param array $values
 * @param array $fields
 * @param boolean $automaticQuotes
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, insert){

	zval *table = NULL, *values = NULL, *fields = NULL, *automatic_quotes = NULL;
	zval *value = NULL, *key = NULL, *comma = NULL, *joined_values = NULL, *insert_sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *i0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &table, &values, &fields, &automatic_quotes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(values);
	
	if (!fields) {
		PHALCON_ALLOC_ZVAL_MM(fields);
		ZVAL_NULL(fields);
	}
	
	if (!automatic_quotes) {
		PHALCON_ALLOC_ZVAL_MM(automatic_quotes);
		ZVAL_BOOL(automatic_quotes, 0);
	}
	
	if (Z_TYPE_P(values) == IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_fast_count(r0, values TSRMLS_CC);
		if (!zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_db_exception_ce);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CONCAT_SVS(r1, "Unable to insert into ", table, " without data");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
			phalcon_throw_exception(i0 TSRMLS_CC);
			return;
		} else {
			if (zend_is_true(automatic_quotes)) {
				if (phalcon_valid_foreach(values TSRMLS_CC)) {
					ALLOC_HASHTABLE(ah0);
					zend_hash_init(ah0, 0, NULL, NULL, 0);
					zend_hash_copy(ah0, Z_ARRVAL_P(values), NULL, NULL, sizeof(zval*));
					zend_hash_internal_pointer_reset_ex(ah0, &hp0);
					fes_e7f0_1:
					if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
						goto fee_e7f0_1;
					} else {
						PHALCON_INIT_VAR(key);
						PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
					}
					PHALCON_INIT_VAR(value);
					ZVAL_ZVAL(value, *hd, 1, 0);
					if (Z_TYPE_P(value) == IS_OBJECT) {
						PHALCON_INIT_VAR(r2);
						phalcon_get_class(r2, value TSRMLS_CC);
						if (PHALCON_COMPARE_STRING(r2, "Phalcon\\Db\\RawValue")) {
							PHALCON_INIT_VAR(r3);
							PHALCON_CALL_METHOD_PARAMS_1(r3, this_ptr, "escapestring", value, PH_NO_CHECK);
							phalcon_array_update(&values, key, &r3, PH_COPY | PH_SEPARATE TSRMLS_CC);
							goto fes_e7f0_1;
						}
					}
					
					PHALCON_INIT_VAR(r4);
					PHALCON_CALL_METHOD_PARAMS_1(r4, this_ptr, "escapestring", value, PH_NO_CHECK);
					
					PHALCON_INIT_VAR(r5);
					PHALCON_CONCAT_SVS(r5, "'", r4, "'");
					phalcon_array_update(&values, key, &r5, PH_COPY | PH_SEPARATE TSRMLS_CC);
					zend_hash_move_forward_ex(ah0, &hp0);
					goto fes_e7f0_1;
					fee_e7f0_1:
					zend_hash_destroy(ah0);
					efree(ah0);
				} else {
					return;
				}
			}
		}
		
		PHALCON_INIT_VAR(comma);
		ZVAL_STRING(comma, ", ", 1);
		
		PHALCON_INIT_VAR(joined_values);
		phalcon_fast_join(joined_values, comma, values TSRMLS_CC);
		if (Z_TYPE_P(fields) == IS_ARRAY) { 
			PHALCON_ALLOC_ZVAL_MM(r6);
			phalcon_fast_join(r6, comma, fields TSRMLS_CC);
			PHALCON_INIT_VAR(insert_sql);
			PHALCON_CONCAT_SVSVSVS(insert_sql, "INSERT INTO ", table, " (", r6, ") VALUES (", joined_values, ")");
		} else {
			PHALCON_INIT_VAR(insert_sql);
			PHALCON_CONCAT_SVSVS(insert_sql, "INSERT INTO ", table, " VALUES (", joined_values, ")");
		}
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		PHALCON_CALL_METHOD_PARAMS_1(r7, this_ptr, "query", insert_sql, PH_NO_CHECK);
		RETURN_CTOR(r7);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The second parameter for insert isn't an Array");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Updates data on a table using custom RBDM SQL syntax
 *
 * @param string $table
 * @param array $fields
 * @param array $values
 * @param string $whereCondition
 * @param boolean $automaticQuotes
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, update){

	zval *table = NULL, *fields = NULL, *values = NULL, *where_condition = NULL;
	zval *automatic_quotes = NULL, *i = NULL, *update_values = NULL, *update_sql = NULL;
	zval *field = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL;
	zval *c0 = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|zz", &table, &fields, &values, &where_condition, &automatic_quotes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(values);
	
	if (!where_condition) {
		PHALCON_ALLOC_ZVAL_MM(where_condition);
		ZVAL_NULL(where_condition);
	}
	
	if (!automatic_quotes) {
		PHALCON_ALLOC_ZVAL_MM(automatic_quotes);
		ZVAL_BOOL(automatic_quotes, 0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, fields TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_count(r1, values TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r2);
	is_not_equal_function(r2, r0, r1 TSRMLS_CC);
	if (zend_is_true(r2)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The number of values to update is not the same as fields");
		return;
	}
	
	PHALCON_INIT_VAR(i);
	ZVAL_LONG(i, 0);
	
	PHALCON_INIT_VAR(update_values);
	array_init(update_values);
	
	PHALCON_INIT_VAR(update_sql);
	PHALCON_CONCAT_SVS(update_sql, "UPDATE ", table, " SET ");
	if (phalcon_valid_foreach(fields TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(fields);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_e7f0_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_e7f0_2;
		}
		
		PHALCON_INIT_VAR(field);
		ZVAL_ZVAL(field, *hd, 1, 0);
		if (zend_is_true(automatic_quotes)) {
			PHALCON_INIT_VAR(r3);
			phalcon_array_fetch(&r3, values, i, PH_NOISY_CC);
			if (Z_TYPE_P(r3) == IS_OBJECT) {
				PHALCON_INIT_VAR(r4);
				phalcon_array_fetch(&r4, values, i, PH_NOISY_CC);
				PHALCON_INIT_VAR(r5);
				phalcon_get_class(r5, r4 TSRMLS_CC);
				if (PHALCON_COMPARE_STRING(r5, "Phalcon\\Db\\RawValue")) {
					PHALCON_INIT_VAR(r6);
					phalcon_array_fetch(&r6, values, i, PH_NOISY_CC);
					PHALCON_INIT_VAR(r7);
					PHALCON_CALL_METHOD(r7, r6, "getvalue", PH_NO_CHECK);
					PHALCON_INIT_VAR(r8);
					PHALCON_CALL_METHOD_PARAMS_1(r8, this_ptr, "escapestring", r7, PH_NO_CHECK);
					phalcon_array_update(&values, i, &r8, PH_COPY | PH_SEPARATE TSRMLS_CC);
					goto fes_e7f0_2;
				}
			}
			
			PHALCON_INIT_VAR(r9);
			phalcon_array_fetch(&r9, values, i, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r10);
			PHALCON_CALL_METHOD_PARAMS_1(r10, this_ptr, "escapestring", r9, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r11);
			PHALCON_CONCAT_SVS(r11, "'", r10, "'");
			phalcon_array_update(&values, i, &r11, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(r12);
		phalcon_array_fetch(&r12, values, i, PH_NOISY_CC);
		
		PHALCON_INIT_VAR(r13);
		PHALCON_CONCAT_VSV(r13, field, " = ", r12);
		phalcon_array_append(&update_values, r13, PH_SEPARATE TSRMLS_CC);
		PHALCON_SEPARATE(i);
		increment_function(i);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_e7f0_2;
		fee_e7f0_2:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ", ", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r14);
	phalcon_fast_join(r14, c0, update_values TSRMLS_CC);
	phalcon_concat_self(&update_sql, r14 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	
	PHALCON_ALLOC_ZVAL_MM(r15);
	is_not_equal_function(r15, where_condition, t0 TSRMLS_CC);
	if (zend_is_true(r15)) {
		PHALCON_ALLOC_ZVAL_MM(r16);
		PHALCON_CONCAT_SV(r16, " WHERE ", where_condition);
		phalcon_concat_self(&update_sql, r16 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r17);
	PHALCON_CALL_METHOD_PARAMS_1(r17, this_ptr, "query", update_sql, PH_NO_CHECK);
	RETURN_CTOR(r17);
}

/**
 * Deletes data from a table using custom RBDM SQL syntax
 *
 * @param string $table
 * @param string $whereCondition
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, delete){

	zval *table = NULL, *where_condition = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &where_condition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!where_condition) {
		PHALCON_ALLOC_ZVAL_MM(where_condition);
		ZVAL_STRING(where_condition, "", 1);
	}
	
	if (!PHALCON_COMPARE_STRING(where_condition, "")) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSV(r0, "DELETE FROM ", table, " WHERE ", where_condition);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "query", r0, PH_NO_CHECK);
		RETURN_CTOR(r1);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SV(r2, "DELETE FROM ", table);
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_METHOD_PARAMS_1(r3, this_ptr, "query", r2, PH_NO_CHECK);
		RETURN_CTOR(r3);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Starts a transaction in the connection
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, begin){

	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	phalcon_update_property_bool(this_ptr, SL("_autoCommit"), 0 TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_underTransaction"), 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "BEGIN", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", c0, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Rollbacks the active transaction in the connection
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, rollback){

	zval *t0 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_underTransaction"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		phalcon_update_property_bool(this_ptr, SL("_underTransaction"), 0 TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_autoCommit"), 1 TSRMLS_CC);
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "ROLLBACK", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", c0, PH_NO_CHECK);
		RETURN_CTOR(r0);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "There is not an active transaction on relational manager");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Commits the active transaction in the connection
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, commit){

	zval *t0 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_underTransaction"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		phalcon_update_property_bool(this_ptr, SL("_underTransaction"), 0 TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_autoCommit"), 1 TSRMLS_CC);
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "COMMIT", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", c0, PH_NO_CHECK);
		RETURN_CTOR(r0);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "There is not an active transaction on relational manager");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Manually sets a "under transaction" state for the connection
 *
 * @param boolean $underTransaction
 */
PHP_METHOD(Phalcon_Db, setUnderTransaction){

	zval *under_transaction = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &under_transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_underTransaction"), under_transaction TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks whether connection is under database transaction
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, isUnderTransaction){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_underTransaction"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Checks whether connection have auto commit
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db, getHaveAutoCommit){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_autoCommit"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns database name in the internal connection
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db, getDatabaseName){

	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(t0, SL("name") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_descriptor"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, t1, SL("name"), PH_NOISY_CC);
		
		RETURN_CCTOR(t2);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Returns active schema name in the internal connection
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db, getDefaultSchema){

	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(t0, SL("schema") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_descriptor"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, t1, SL("schema"), PH_NOISY_CC);
		
		RETURN_CCTOR(t2);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_descriptor"), PH_NOISY_CC);
		eval_int = phalcon_isset_property(t3, SL("name") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t4);
			phalcon_read_property(&t4, this_ptr, SL("_descriptor"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, t4, SL("name"), PH_NOISY_CC);
			
			RETURN_CCTOR(t5);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Returns the username which has connected to the database
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db, getUsername){

	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(t0, SL("username") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_descriptor"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, t1, SL("username"), PH_NOISY_CC);
		
		RETURN_CCTOR(t2);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Returns the username which has connected to the database
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db, getHostName){

	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(t0, SL("host") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_descriptor"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, t1, SL("host"), PH_NOISY_CC);
		
		RETURN_CCTOR(t2);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * This method is executed before every SQL statement sent to the database system
 *
 * @param string $sqlStatement
 */
PHP_METHOD(Phalcon_Db, _beforeQuery){

	zval *sql_statement = NULL, *logger = NULL, *profiler = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(logger);
	phalcon_read_property(&logger, this_ptr, SL("_logger"), PH_NOISY_CC);
	if (zend_is_true(logger)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_BOOL(c0, 1);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "getconnectionid", c0, PH_NO_CHECK);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVSV(r1, "[", r0, "] ", sql_statement);
		PHALCON_INIT_VAR(c1);
		ZVAL_LONG(c1, 7);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(logger, "log", r1, c1, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(profiler);
	phalcon_read_property(&profiler, this_ptr, SL("_profiler"), PH_NOISY_CC);
	if (zend_is_true(profiler)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(profiler, "startprofile", sql_statement, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * This method is executed after every SQL statement sent to the database system
 *
 * @param string $sqlStatement
 */
PHP_METHOD(Phalcon_Db, _afterQuery){

	zval *sql_statement = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_profiler"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_profiler"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t1, "stopprofile", sql_statement, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Instantiates Phalcon\Db adapter using given parameters
 *
 * @param string $adapterName
 * @param stdClass $options
 * @return Phalcon\Db\Adapter
 */
PHP_METHOD(Phalcon_Db, factory){

	zval *adapter_name = NULL, *options = NULL, *descriptor = NULL, *value = NULL;
	zval *key = NULL, *class_name = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL, *i1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &adapter_name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(adapter_name)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "A valid adapter name is required");
		return;
	}
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		if (Z_TYPE_P(options) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The parameter 'options' must be an Array or Object");
			return;
		}
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_INIT_VAR(descriptor);
		object_init(descriptor);
		if (phalcon_valid_foreach(options TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(options);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_e7f0_3:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_e7f0_3;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			phalcon_update_property_zval_zval(descriptor, key, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_e7f0_3;
			fee_e7f0_3:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_CPY_WRT(descriptor, options);
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CONCAT_SV(class_name, "Phalcon\\Db\\Adapter\\", adapter_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", class_name);
	if (zend_is_true(r0)) {
		ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, ce0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", descriptor, PH_CHECK);
		
		RETURN_CTOR(i0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, phalcon_db_exception_ce);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CONCAT_SVS(r1, "Database adapter class ", class_name, " was not found");
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", r1, PH_CHECK);
	phalcon_throw_exception(i1 TSRMLS_CC);
	return;
}

/* ------ Finished File: \db.c ------ */

/* ------ Starting File: \logger.c ------ */
/**
 * Phalcon\Logger
 *
 * Phalcon_Logger is a component whose purpose is to create logs using
 * different backends via adapters, generating options, formats and filters
 * also implementing transactions.
 *
 *
 */

/**
 * Phalcon_Logger constructor
 *
 * @param string $adapter
 * @param string $name
 * @param array $options
 */
PHP_METHOD(Phalcon_Logger, __construct){

	zval *adapter = NULL, *name = NULL, *options = NULL, *class_name = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL, *i1 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzz", &adapter, &name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!adapter) {
		PHALCON_ALLOC_ZVAL_MM(adapter);
		ZVAL_STRING(adapter, "File", 1);
	}
	
	if (!name) {
		PHALCON_ALLOC_ZVAL_MM(name);
		ZVAL_NULL(name);
	}
	
	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CONCAT_SV(class_name, "Phalcon\\Logger\\Adapter\\", adapter);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", class_name);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_logger_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Logger adapter '", class_name, "' cannot be found");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, ce0);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i1, "__construct", name, options, PH_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_adapter"), i1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes a message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, log){

	zval *message = NULL, *type = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!type) {
		PHALCON_ALLOC_ZVAL_MM(type);
		ZVAL_LONG(type, 7);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes a debug message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, debug){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("DEBUG") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes an error message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, error){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("ERROR") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes an info message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, info){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("INFO") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes a notice message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, notice){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("NOTICE") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes a warning message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, warning){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("WARNING") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
  * Sends/Writes an alert message to the log
  *
  * @param string $message
  * @param ing $type
  */
PHP_METHOD(Phalcon_Logger, alert){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_get_class_constant(t1, phalcon_logger_ce, SL("ALERT") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(t0, "log", message, t1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Pass any call to the internal adapter object
 *
 * @param  string $method
 * @param  array $arguments
 * @return mixed
 */
PHP_METHOD(Phalcon_Logger, __call){

	zval *method = NULL, *arguments = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(arguments, a0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	phalcon_array_append(&a1, t0, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a1, method, PH_SEPARATE TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "call_user_func_array", a1, arguments);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \logger.c ------ */

/* ------ Starting File: \cache\exception.c ------ */
/**
 * Phalcon_Cache_Exception
 *
 * Exceptions thrown in Phalcon_Cache will use this class
 *
 */

/* ------ Finished File: \cache\exception.c ------ */

/* ------ Starting File: \cache\frontend\output.c ------ */
/**
 * Phalcon_Cache_Frontend_Output
 *
 * Allows to cache output fragments captured with ob_* functions
 *
 */

/**
 * Phalcon_Cache_Frontend_Output constructor
 *
 * @param array $frontendOptions
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, __construct){

	zval *frontend_options = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_cache_frontend_output_ce, this_ptr, SL("_frontendOptions"), a0 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_frontendOptions"), frontend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns cache lifetime
 *
 * @return integer
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, getLifetime){

	zval *options = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_frontendOptions"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(options, SL("lifetime")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, options, SL("lifetime"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_LONG(1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether if frontend is buffering output
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, isBuffering){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_buffering"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Starts output frontend
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, start){


	PHALCON_MM_GROW();
	phalcon_update_property_bool(this_ptr, SL("_buffering"), 1 TSRMLS_CC);
	PHALCON_CALL_FUNC_NORETURN("ob_start");
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns output cached content
 *
 * @return string
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, getContent){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_buffering"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC(r0, "ob_get_contents");
		RETURN_CTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Stops output frontend
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, stop){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_buffering"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_CALL_FUNC_NORETURN("ob_end_clean");
	}
	phalcon_update_property_bool(this_ptr, SL("_buffering"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Prepare data to be stored
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, beforeStore){

	zval *data = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	RETURN_CCTOR(data);
}

/**
 * Prepares data to be retrieved to user
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_Output, afterRetrieve){

	zval *data = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	RETURN_CCTOR(data);
}

/* ------ Finished File: \cache\frontend\output.c ------ */

/* ------ Starting File: \cache\frontend\none.c ------ */
/**
 * Phalcon_Cache_Frontend_None
 *
 * Discards any kind of frontend data input. This frontend does not have expiration time or any other options
 *
 */

/**
 * Phalcon_Cache_Frontend_None constructor
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, __construct){

	zval *frontend_options = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	PHALCON_MM_RESTORE();
}

/**
 * Returns cache lifetime, always one second expiring content
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, getLifetime){


	PHALCON_MM_GROW();
	PHALCON_MM_RESTORE();
	RETURN_LONG(1);
}

/**
 * Check whether if frontend is buffering output, always false
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, isBuffering){


	PHALCON_MM_GROW();
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Starts output frontend
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, start){


	
}

/**
 * Returns output cached content
 *
 * @return string
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, getContent){


	
}

/**
 * Stops output frontend
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, stop){


	
}

/**
 * Prepare data to be stored
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, beforeStore){

	zval *data = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	RETURN_CCTOR(data);
}

/**
 * Prepares data to be retrieved to user
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_None, afterRetrieve){

	zval *data = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	RETURN_CCTOR(data);
}

/* ------ Finished File: \cache\frontend\none.c ------ */

/* ------ Starting File: \cache\frontend\data.c ------ */
/**
 * Phalcon_Cache_Frontend_Data
 *
 * Allows to cache native PHP data in a serialized form
 *
 */

/**
 * Phalcon_Cache_Frontend_Data constructor
 *
 * @param array $frontendOptions
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, __construct){

	zval *frontend_options = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_cache_frontend_data_ce, this_ptr, SL("_frontendOptions"), a0 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_frontendOptions"), frontend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns cache lifetime
 *
 * @return integer
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, getLifetime){

	zval *options = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_frontendOptions"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(options, SL("lifetime")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, options, SL("lifetime"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_LONG(1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether if frontend is buffering output
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, isBuffering){


	PHALCON_MM_GROW();
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Starts output frontend. Actually, does nothing
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, start){


	
}

/**
 * Returns output cached content
 *
 * @return string
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, getContent){


	PHALCON_MM_GROW();
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Stops output frontend
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, stop){


	
}

/**
 * Serializes data before storing it
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, beforeStore){

	zval *data = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "serialize", data);
	RETURN_CTOR(r0);
}

/**
 * Unserializes data after retrieving it
 *
 * @param mixed $data
 */
PHP_METHOD(Phalcon_Cache_Frontend_Data, afterRetrieve){

	zval *data = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "unserialize", data);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \cache\frontend\data.c ------ */

/* ------ Starting File: \cache\backend.c ------ */
/**
 * Phalcon_Cache_Backend
 *
 * This class implements common functionality for backend adapters. All the backend cache adapter must
 * extend this class
 */

/**
 * Phalcon_Cache_Backend constructor
 *
 * @param mixed $frontendObject
 * @param array $backendOptions
 */
PHP_METHOD(Phalcon_Cache_Backend, __construct){

	zval *frontend_object = NULL, *backend_options = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_cache_backend_ce, this_ptr, SL("_backendOptions"), a0 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(backend_options, SL("prefix")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, backend_options, SL("prefix"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_prefix"), r0 TSRMLS_CC);
	}
	phalcon_update_property_zval(this_ptr, SL("_frontendObject"), frontend_object TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_backendOptions"), backend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Starts a cache. The $keyname allow to identify the created fragment
 *
 * @param int|string $keyName
 * @return  mixed
 */
PHP_METHOD(Phalcon_Cache_Backend, start){

	zval *key_name = NULL, *backend = NULL, *front_end = NULL, *prefixed_key = NULL;
	zval *existing_cache = NULL, *fresh = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, t0, key_name);
	
	PHALCON_INIT_VAR(existing_cache);
	PHALCON_CALL_METHOD_PARAMS_1(existing_cache, this_ptr, "get", prefixed_key, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_NULL(t1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, existing_cache, t1 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(fresh);
		ZVAL_BOOL(fresh, 1);
		PHALCON_CALL_METHOD_NORETURN(front_end, "start", PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(fresh);
		ZVAL_BOOL(fresh, 0);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_fresh"), fresh TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_started"), 1 TSRMLS_CC);
	
	RETURN_CCTOR(existing_cache);
}

/**
 * Returns front-end instance adapter related to the back-end
 *
 * @return mixed
 */
PHP_METHOD(Phalcon_Cache_Backend, getFrontend){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Checks whether the last cache is fresh or cached
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Cache_Backend, isFresh){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_fresh"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Checks whether the cache has started buffering or not
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Cache_Backend, isStarted){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_started"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the last key stored by the cache
 *
 * @return string
 */
PHP_METHOD(Phalcon_Cache_Backend, getLastKey){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \cache\backend.c ------ */

/* ------ Starting File: \cache\backend\memcache.c ------ */
/**
 * Phalcon_Cache_Backend_Memcache
 *
 * Allows to cache output fragments, PHP data or raw data to a memcache backend
 *
 * This adapter uses the special memcached key "_PHCM" to store all the keys internally used by the adapter
 *
 *
 */

/**
 * Phalcon_Backend_Adapter_Memcache constructor
 *
 * @param mixed $frontendObject
 * @param array $backendOptions
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, __construct){

	zval *frontend_object = NULL, *backend_options = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(backend_options);
	
	eval_int = phalcon_array_isset_string(backend_options, SL("host")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, "127.0.0.1", 1);
		phalcon_array_update_string(&backend_options, SL("host"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	eval_int = phalcon_array_isset_string(backend_options, SL("port")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t1);
		ZVAL_STRING(t1, "11211", 1);
		phalcon_array_update_string(&backend_options, SL("port"), &t1, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SL("persistent")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t2);
		ZVAL_BOOL(t2, 0);
		phalcon_array_update_string(&backend_options, SL("persistent"), &t2, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SL("statsKey")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t3);
		ZVAL_STRING(t3, "_PHCM", 1);
		phalcon_array_update_string(&backend_options, SL("statsKey"), &t3, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Cache\\Backend\\Memcache", "__construct", frontend_object, backend_options);
	
	PHALCON_MM_RESTORE();
}

/**
 * Create internal connection to memcached
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, _connect){

	zval *backend_options = NULL, *memcache = NULL, *host = NULL, *port = NULL;
	zval *persistent = NULL, *success = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	ce0 = zend_fetch_class(SL("Memcache"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(memcache);
	object_init_ex(memcache, ce0);
	PHALCON_CALL_METHOD_NORETURN(memcache, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(host);
	phalcon_array_fetch_string(&host, backend_options, SL("host"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(port);
	phalcon_array_fetch_string(&port, backend_options, SL("port"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(persistent);
	phalcon_array_fetch_string(&persistent, backend_options, SL("persistent"), PH_NOISY_CC);
	if (zend_is_true(persistent)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_2(success, memcache, "connect", host, port, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_2(success, memcache, "pconnect", host, port, PH_NO_CHECK);
	}
	
	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cannot connect to Memcached server");
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_memcache"), memcache TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a cached content
 *
 * @param int|string $keyName
 * @param   long $lifetime
 * @return  mixed
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, get){

	zval *key_name = NULL, *lifetime = NULL, *backend = NULL, *front_end = NULL;
	zval *prefixed_key = NULL, *cached_content = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, t1, key_name);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_memcache"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cached_content);
	PHALCON_CALL_METHOD_PARAMS_1(cached_content, t2, "get", prefixed_key, PH_NO_CHECK);
	if (Z_TYPE_P(cached_content) == IS_BOOL && !Z_BVAL_P(cached_content)) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Stores cached content into the file backend
 *
 * @param int|string $keyName
 * @param string $content
 * @param long $lifetime
 * @param boolean $stopBuffer
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *front_end = NULL, *backend_options = NULL;
	zval *cached_content = NULL, *prepared_content = NULL, *ttl = NULL;
	zval *memcache = NULL, *success = NULL, *special_key = NULL, *keys = NULL, *is_buffering = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_ALLOC_ZVAL_MM(key_name);
		ZVAL_NULL(key_name);
	}
	
	if (!content) {
		PHALCON_ALLOC_ZVAL_MM(content);
		ZVAL_NULL(content);
	}
	
	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_ALLOC_ZVAL_MM(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, t0, key_name);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (!zend_is_true(t1)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	
	if (!zend_is_true(content)) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_INIT_VAR(ttl);
		PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_BOOL(c0, 0);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_4(success, memcache, "set", last_key, prepared_content, c0, ttl, PH_NO_CHECK);
	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Failed storing data in memcached");
		return;
	}
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) != IS_ARRAY) { 
		PHALCON_INIT_VAR(keys);
		array_init(keys);
	}
	
	eval_int = phalcon_array_isset(keys, last_key);
	if (!eval_int) {
		phalcon_array_update(&keys, last_key, &ttl, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(memcache, "set", special_key, keys, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (zend_is_true(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (zend_is_true(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Deletes a value from the cache by its key
 *
 * @param int|string $keyName
 * @return boolean
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, delete){

	zval *key_name = NULL, *memcache = NULL, *prefixed_key = NULL, *backend_options = NULL;
	zval *special_key = NULL, *keys = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, t1, key_name);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		PHALCON_SEPARATE(keys);
		phalcon_array_unset(keys, prefixed_key);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(memcache, "set", special_key, keys, PH_NO_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, memcache, "delete", prefixed_key, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Query the existing cached keys
 *
 * @param string $prefix
 * @return array
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, queryKeys){

	zval *prefix = NULL, *memcache = NULL, *start = NULL, *prefix_length = NULL;
	zval *backend_options = NULL, *special_key = NULL, *keys = NULL, *prefixed_keys = NULL;
	zval *ttl = NULL, *key = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *a0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_ALLOC_ZVAL_MM(prefix);
		ZVAL_NULL(prefix);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(start);
	ZVAL_LONG(start, 0);
	
	PHALCON_INIT_VAR(prefix_length);
	PHALCON_CALL_FUNC_PARAMS_1(prefix_length, "strlen", prefix);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		PHALCON_INIT_VAR(prefixed_keys);
		array_init(prefixed_keys);
		if (phalcon_valid_foreach(keys TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(keys);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_be7f_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_be7f_0;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(ttl);
			ZVAL_ZVAL(ttl, *hd, 1, 0);
			if (zend_is_true(prefix)) {
				PHALCON_INIT_VAR(r0);
				PHALCON_CALL_FUNC_PARAMS_3(r0, "substr", key, start, prefix_length);
				PHALCON_INIT_VAR(r1);
				is_not_equal_function(r1, r0, prefix TSRMLS_CC);
				if (zend_is_true(r1)) {
					goto fes_be7f_0;
				}
			}
			phalcon_array_append(&prefixed_keys, key, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_be7f_0;
			fee_be7f_0:
			if(0){}
		} else {
			return;
		}
		
		RETURN_CTOR(prefixed_keys);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Destructs the backend closing the memcached connection
 */
PHP_METHOD(Phalcon_Cache_Backend_Memcache, __destruct){

	zval *memcache = NULL, *backend_options = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (zend_is_true(memcache)) {
		PHALCON_INIT_VAR(backend_options);
		phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, backend_options, SL("persistent"), PH_NOISY_CC);
		if (!zend_is_true(r0)) {
			PHALCON_CALL_METHOD_NORETURN(memcache, "close", PH_NO_CHECK);
		}
	}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \cache\backend\memcache.c ------ */

/* ------ Starting File: \cache\backend\apc.c ------ */
/**
 * Phalcon_Cache_Backend_Apc
 *
 * Allows to cache output fragments, PHP data and raw data using a memcache backend
 *
 *
 */

/**
 * Returns a cached content
 *
 * @param int|string $keyName
 * @param   long $lifetime
 * @return  mixed
 */
PHP_METHOD(Phalcon_Cache_Backend_Apc, get){

	zval *key_name = NULL, *lifetime = NULL, *backend = NULL, *front_end = NULL;
	zval *prefixed_key = NULL, *cached_content = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCA", t0, key_name);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_INIT_VAR(cached_content);
	PHALCON_CALL_FUNC_PARAMS_1(cached_content, "apc_fetch", prefixed_key);
	if (Z_TYPE_P(cached_content) == IS_BOOL && !Z_BVAL_P(cached_content)) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Stores cached content into the file backend
 *
 * @param int|string $keyName
 * @param string $content
 * @param long $lifetime
 * @param boolean $stopBuffer
 */
PHP_METHOD(Phalcon_Cache_Backend_Apc, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *front_end = NULL, *backend = NULL, *cached_content = NULL;
	zval *prepared_content = NULL, *ttl = NULL, *is_buffering = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_ALLOC_ZVAL_MM(key_name);
		ZVAL_NULL(key_name);
	}
	
	if (!content) {
		PHALCON_ALLOC_ZVAL_MM(content);
		ZVAL_NULL(content);
	}
	
	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_ALLOC_ZVAL_MM(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCA", t0, key_name);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	if (!zend_is_true(content)) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_INIT_VAR(ttl);
		PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}
	
	PHALCON_CALL_FUNC_PARAMS_3_NORETURN("apc_store", last_key, prepared_content, ttl);
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (zend_is_true(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (zend_is_true(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Deletes a value from the cache by its key
 *
 * @param string|int $keyName
 * @return boolean
 */
PHP_METHOD(Phalcon_Cache_Backend_Apc, delete){

	zval *key_name = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVV(r0, "_PHCA", t0, key_name);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_FUNC_PARAMS_1(r1, "apc_delete", r0);
	RETURN_CTOR(r1);
}

/**
 * Query the existing cached keys
 *
 * @param string $prefix
 * @return array
 */
PHP_METHOD(Phalcon_Cache_Backend_Apc, queryKeys){

	zval *prefix = NULL, *keys = NULL, *iterator = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_ALLOC_ZVAL_MM(prefix);
		ZVAL_STRING(prefix, "", 1);
	}
	
	PHALCON_INIT_VAR(keys);
	array_init(keys);
	ce0 = zend_fetch_class(SL("APCIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, ce0);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "user", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "/^_PHCA", prefix, "/");
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(iterator, "__construct", c0, r0, PH_CHECK);
	PHALCON_CALL_METHOD_NORETURN(iterator, "rewind", PH_NO_CHECK);
	ws_e532_0:
		
		PHALCON_INIT_VAR(r1);
		PHALCON_CALL_METHOD(r1, iterator, "valid", PH_NO_CHECK);
		if (!zend_is_true(r1)) {
			goto we_e532_0;
		}
		PHALCON_INIT_VAR(r2);
		PHALCON_CALL_METHOD(r2, iterator, "key", PH_NO_CHECK);
		phalcon_array_append(&keys, r2, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_NORETURN(iterator, "next", PH_NO_CHECK);
		goto ws_e532_0;
	we_e532_0:
	
	RETURN_CTOR(keys);
}

/* ------ Finished File: \cache\backend\apc.c ------ */

/* ------ Starting File: \cache\backend\file.c ------ */
/**
 * Phalcon_Cache_Backend_File
 *
 * Allows to cache output fragments using a file backend
 *
 *
 */

/**
 * Phalcon_Backend_Adapter_File constructor
 *
 * @param mixed $frontendObject
 * @param array $backendOptions
 */
PHP_METHOD(Phalcon_Cache_Backend_File, __construct){

	zval *frontend_object = NULL, *backend_options = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(backend_options, SL("cacheDir")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, backend_options, SL("cacheDir"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_FUNC_PARAMS_1(r1, "is_writable", r0);
		if (!zend_is_true(r1)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache directory does not exist or is not writable");
			return;
		}
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "You must specify the cache directory with the option cacheDir");
		return;
	}
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Cache\\Backend\\File", "__construct", frontend_object, backend_options);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a cached content
 *
 * @param int|string $keyName
 * @param   long $lifetime
 * @return  mixed
 */
PHP_METHOD(Phalcon_Cache_Backend_File, get){

	zval *key_name = NULL, *lifetime = NULL, *backend = NULL, *front_end = NULL;
	zval *prefixed_key = NULL, *cache_file = NULL, *time = NULL, *ttl = NULL, *cached_content = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("prefix"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_filter_alphanum(r0, key_name);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, t0, r0);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, r1, prefixed_key);
	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(time);
		PHALCON_CALL_FUNC(time, "time");
		if (Z_TYPE_P(lifetime) == IS_NULL) {
			PHALCON_INIT_VAR(ttl);
			PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
		} else {
			PHALCON_CPY_WRT(ttl, lifetime);
		}
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		sub_function(r2, time, ttl TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_FUNC_PARAMS_1(r3, "filemtime", cache_file);
		
		PHALCON_ALLOC_ZVAL_MM(r4);
		is_smaller_function(r4, r2, r3 TSRMLS_CC);
		if (zend_is_true(r4)) {
			PHALCON_INIT_VAR(cached_content);
			PHALCON_CALL_FUNC_PARAMS_1(cached_content, "file_get_contents", cache_file);
			
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CALL_METHOD_PARAMS_1(r5, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
			RETURN_CTOR(r5);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Stores cached content into the file backend
 *
 * @param int|string $keyName
 * @param string $content
 * @param long $lifetime
 * @param boolean $stopBuffer
 */
PHP_METHOD(Phalcon_Cache_Backend_File, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *front_end = NULL, *backend = NULL, *cache_dir = NULL;
	zval *cache_file = NULL, *cached_content = NULL, *prepared_content = NULL;
	zval *is_buffering = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_ALLOC_ZVAL_MM(key_name);
		ZVAL_NULL(key_name);
	}
	
	if (!content) {
		PHALCON_ALLOC_ZVAL_MM(content);
		ZVAL_NULL(content);
	}
	
	if (!lifetime) {
		PHALCON_ALLOC_ZVAL_MM(lifetime);
		ZVAL_NULL(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_ALLOC_ZVAL_MM(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_filter_alphanum(r0, key_name);
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, t0, r0);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_dir);
	phalcon_array_fetch_string(&cache_dir, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_FUNC_PARAMS_1(r1, "is_writable", cache_dir);
	if (!zend_is_true(r1)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache file is not writable");
		return;
	}
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, last_key);
	if (!zend_is_true(content)) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	PHALCON_CALL_FUNC_PARAMS_2_NORETURN("file_put_contents", cache_file, prepared_content);
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (zend_is_true(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (zend_is_true(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Deletes a value from the cache by its key
 *
 * @param int|string $keyName
 * @return boolean
 */
PHP_METHOD(Phalcon_Cache_Backend_File, delete){

	zval *key_name = NULL, *backend = NULL, *prefixed_key = NULL, *cache_file = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_filter_alphanum(r0, key_name);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, t0, r0);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, r1, prefixed_key);
	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_FUNC_PARAMS_1(r2, "unlink", cache_file);
		RETURN_CTOR(r2);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Query the existing cached keys
 *
 * @param string $prefix
 * @return array
 */
PHP_METHOD(Phalcon_Cache_Backend_File, queryKeys){

	zval *prefix = NULL, *start = NULL, *keys = NULL, *backend = NULL, *prefix_length = NULL;
	zval *iterator = NULL, *item = NULL, *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_ALLOC_ZVAL_MM(prefix);
		ZVAL_NULL(prefix);
	}
	
	PHALCON_INIT_VAR(start);
	ZVAL_LONG(start, 0);
	
	PHALCON_INIT_VAR(keys);
	array_init(keys);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefix_length);
	PHALCON_CALL_FUNC_PARAMS_1(prefix_length, "strlen", prefix);
	ce0 = zend_fetch_class(SL("DirectoryIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, ce0);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, backend, SL("cacheDir"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(iterator, "__construct", r0, PH_CHECK);
	PHALCON_CALL_METHOD_NORETURN(iterator, "rewind", PH_NO_CHECK);
	ws_469d_0:
		
		PHALCON_INIT_VAR(r1);
		PHALCON_CALL_METHOD(r1, iterator, "valid", PH_NO_CHECK);
		if (!zend_is_true(r1)) {
			goto we_469d_0;
		}
		PHALCON_INIT_VAR(item);
		PHALCON_CALL_METHOD(item, iterator, "current", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r2);
		PHALCON_CALL_METHOD(r2, item, "isdir", PH_NO_CHECK);
		if (!zend_is_true(r2)) {
			PHALCON_INIT_VAR(key);
			PHALCON_CALL_METHOD(key, item, "getfilename", PH_NO_CHECK);
			if (zend_is_true(prefix)) {
				PHALCON_INIT_VAR(r3);
				PHALCON_CALL_FUNC_PARAMS_3(r3, "substr", key, start, prefix_length);
				PHALCON_INIT_VAR(r4);
				is_not_equal_function(r4, r3, prefix TSRMLS_CC);
				if (zend_is_true(r4)) {
					goto ws_469d_0;
				}
			}
			
			phalcon_array_append(&keys, key, PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_CALL_METHOD_NORETURN(iterator, "next", PH_NO_CHECK);
		goto ws_469d_0;
	we_469d_0:
	
	RETURN_CTOR(keys);
}

/* ------ Finished File: \cache\backend\file.c ------ */

/* ------ Starting File: \acl\exception.c ------ */
/**
 * Phalcon_Acl_Exception
 *
 * Class for exceptions thrown by Phalcon_Acl
 */

/* ------ Finished File: \acl\exception.c ------ */

/* ------ Starting File: \acl\adapter\memory.c ------ */
/**
 * Phalcon_Acl_Adapter_Memory
 *
 * Manages ACL lists in memory
 */

PHP_METHOD(Phalcon_Acl_Adapter_Memory, __construct){

	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL, *a4 = NULL, *a5 = NULL, *a6 = NULL;
	zval *a7 = NULL;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_rolesNames"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_roles"), a1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a2);
	array_init(a2);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_resources"), a2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a3);
	array_init(a3);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_access"), a3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a4);
	array_init(a4);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_roleInherits"), a4 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a5);
	array_init(a5);
	add_assoc_bool_ex(a5, SL("*")+1, 1);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_resourcesNames"), a5 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a6);
	array_init(a6);
	
	PHALCON_ALLOC_ZVAL_MM(a7);
	array_init(a7);
	add_assoc_bool_ex(a7, SL("*")+1, 1);
	phalcon_array_update_string(&a6, SL("*"), &a7, PH_COPY | PH_SEPARATE TSRMLS_CC);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_accessList"), a6 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Sets the default access level (Phalcon_Acl::ALLOW or Phalcon_Acl::DENY)
 *
 * @param int $defaultAccess
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, setDefaultAction){

	zval *default_access = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &default_access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAccess"), default_access TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the default ACL access level
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, getDefaultAction){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Adds a role to the ACL list. Second parameter lets to inherit access data from other existing role
 *
 * Example:
 * 
 * @param  string $roleObject
 * @param  array $accessInherits
 * @return boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, addRole){

	zval *role_object = NULL, *access_inherits = NULL, *role_name = NULL;
	zval *object = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &role_object, &access_inherits) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!access_inherits) {
		PHALCON_ALLOC_ZVAL_MM(access_inherits);
		ZVAL_NULL(access_inherits);
	}
	
	if (Z_TYPE_P(role_object) == IS_OBJECT) {
		PHALCON_INIT_VAR(role_name);
		PHALCON_CALL_METHOD(role_name, role_object, "getname", PH_NO_CHECK);
		PHALCON_CPY_WRT(object, role_object);
	} else {
		PHALCON_CPY_WRT(role_name, role_object);
		
		PHALCON_INIT_VAR(object);
		object_init_ex(object, phalcon_acl_role_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", role_name, PH_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, role_name);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_roles"), PH_NOISY_CC);
	phalcon_array_append(&t1, object, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_roles"), t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t2);
	ZVAL_BOOL(t2, 1);
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	phalcon_array_update(&t3, role_name, &t2, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_rolesNames"), t3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t5);
	phalcon_read_property(&t5, this_ptr, SL("_access"), PH_NOISY_CC);
	if (Z_TYPE_P(t5) == IS_ARRAY) {
		PHALCON_ALLOC_ZVAL_MM(t6);
		phalcon_array_fetch(&t6, t5, role_name, PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(t6) > 1) {
		phalcon_array_update(&t5, role_name, &t6, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(t6) != IS_ARRAY) {
		convert_to_array(t6);
		phalcon_array_update(&t5, role_name, &t6, PH_COPY TSRMLS_CC);
	}
	if (Z_TYPE_P(t6) == IS_ARRAY) {
		PHALCON_ALLOC_ZVAL_MM(t7);
		phalcon_array_fetch_string(&t7, t6, SL("*"), PH_SILENT_CC);
	}
	if (Z_REFCOUNT_P(t7) > 1) {
		phalcon_array_update_string(&t6, SL("*"), &t7, PH_COPY | PH_CTOR TSRMLS_CC);
	}
	if (Z_TYPE_P(t7) != IS_ARRAY) {
		convert_to_array(t7);
		phalcon_array_update_string(&t6, SL("*"), &t7, PH_COPY TSRMLS_CC);
	}
	phalcon_array_update_string(&t7, SL("*"), &t4, PH_COPY TSRMLS_CC);
	if (zend_is_true(access_inherits)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "addinherit", role_name, access_inherits, PH_NO_CHECK);
		RETURN_CTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Do a role inherit from another existing role
 *
 * @param string $roleName
 * @param string $roleToInherit
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, addInherit){

	zval *role_name = NULL, *role_to_inherit = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &role_name, &role_to_inherit) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, role_name);
	if (!eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t1, role_to_inherit);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_acl_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Role '", role_to_inherit, "' does not exist in the role list");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, role_to_inherit, role_name TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t2, role_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
		phalcon_array_update(&t3, role_name, &a0, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_roleInherits"), t3 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
	phalcon_array_update_multi_append_2(&t4, role_name, role_to_inherit, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_roleInherits"), t4 TSRMLS_CC);
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Check whether role exist in the roles list
 *
 * @param  string $roleName
 * @return boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, isRole){

	zval *role_name = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &role_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, role_name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Check whether resource exist in the resources list
 *
 * @param  string $resourceName
 * @return boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, isResource){

	zval *resource_name = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &resource_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, resource_name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Adds a resource to the ACL list
 *
 * Access names can be a particular action, by example
 * search, update, delete, etc or a list of them
 *
 * Example:
 * 
 * @param   Phalcon_Acl_Resource $resource
 * @return  boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResource){

	zval *resource = NULL, *access_list = NULL, *resource_name = NULL;
	zval *object = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &resource, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!access_list) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(access_list, a0);
	}
	
	if (Z_TYPE_P(resource) == IS_OBJECT) {
		PHALCON_INIT_VAR(resource_name);
		PHALCON_CALL_METHOD(resource_name, resource, "getname", PH_NO_CHECK);
		PHALCON_CPY_WRT(object, resource);
	} else {
		PHALCON_CPY_WRT(resource_name, resource);
		
		PHALCON_INIT_VAR(object);
		object_init_ex(object, phalcon_acl_resource_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", resource_name, PH_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, resource_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_resources"), PH_NOISY_CC);
		phalcon_array_append(&t1, object, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_resources"), t1 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_accessList"), PH_NOISY_CC);
		phalcon_array_update(&t2, resource_name, &a1, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_accessList"), t2 TSRMLS_CC);
		
		PHALCON_INIT_VAR(t3);
		ZVAL_BOOL(t3, 1);
		
		PHALCON_ALLOC_ZVAL_MM(t4);
		phalcon_read_property(&t4, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
		phalcon_array_update(&t4, resource_name, &t3, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_resourcesNames"), t4 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "addresourceaccess", resource_name, access_list, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds access to resources
 *
 * @param string $resourceName
 * @param mixed $accessList
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResourceAccess){

	zval *resource_name = NULL, *access_list = NULL, *access_name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &resource_name, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, resource_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_acl_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Resource '", resource_name, "' does not exist in ACL");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
		if (phalcon_valid_foreach(access_list TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(access_list);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_c945_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_c945_0;
			}
			PHALCON_INIT_VAR(access_name);
			ZVAL_ZVAL(access_name, *hd, 1, 0);
			PHALCON_INIT_VAR(t1);
			phalcon_read_property(&t1, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch(&r1, t1, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r1, access_name);
			if (!eval_int) {
				PHALCON_INIT_VAR(t2);
				ZVAL_BOOL(t2, 1);
				PHALCON_INIT_VAR(t3);
				phalcon_read_property(&t3, this_ptr, SL("_accessList"), PH_NOISY_CC);
				phalcon_array_update_multi_2(&t3, resource_name, access_name, &t2, 0 TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_accessList"), t3 TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_c945_0;
			fee_c945_0:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_ALLOC_ZVAL_MM(t4);
		phalcon_read_property(&t4, this_ptr, SL("_accessList"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch(&r2, t4, resource_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r2, access_list);
		if (!eval_int) {
			PHALCON_INIT_VAR(t5);
			ZVAL_BOOL(t5, 1);
			PHALCON_ALLOC_ZVAL_MM(t6);
			phalcon_read_property(&t6, this_ptr, SL("_accessList"), PH_NOISY_CC);
			phalcon_array_update_multi_2(&t6, resource_name, access_list, &t5, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_accessList"), t6 TSRMLS_CC);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Removes an access from a resource
 *
 * @param string $resourceName
 * @param mixed $accessList
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, dropResourceAccess){

	zval *resource_name = NULL, *access_list = NULL, *access_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &resource_name, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
		if (phalcon_valid_foreach(access_list TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(access_list);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_c945_1:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_c945_1;
			}
			PHALCON_INIT_VAR(access_name);
			ZVAL_ZVAL(access_name, *hd, 1, 0);
			PHALCON_INIT_VAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r0);
			phalcon_array_fetch(&r0, t0, resource_name, PH_NOISY_CC);
			PHALCON_SEPARATE_NMO(r0);
			phalcon_array_unset(r0, access_name);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_c945_1;
			fee_c945_1:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_accessList"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch(&r1, t1, resource_name, PH_NOISY_CC);
		PHALCON_SEPARATE_NMO(r1);
		phalcon_array_unset(r1, access_list);
	}
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, _allowOrDeny){

	zval *role_name = NULL, *resource_name = NULL, *access = NULL, *action = NULL;
	zval *access_name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL, *t10 = NULL, *t11 = NULL, *t12 = NULL, *t13 = NULL;
	zval *t14 = NULL, *t15 = NULL, *t16 = NULL, *t17 = NULL, *t18 = NULL, *t19 = NULL;
	zval *i0 = NULL, *i1 = NULL, *i2 = NULL, *i3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &role_name, &resource_name, &access, &action) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, role_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_acl_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Role \"", role_name, "\" does not exist in ACL");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t1, resource_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(i1);
		object_init_ex(i1, phalcon_acl_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Resource \"", resource_name, "\" does not exist in ACL");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i1 TSRMLS_CC);
		return;
	}
	
	if (Z_TYPE_P(access) == IS_ARRAY) { 
		if (phalcon_valid_foreach(access TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(access);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_c945_2:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_c945_2;
			}
			PHALCON_INIT_VAR(access_name);
			ZVAL_ZVAL(access_name, *hd, 1, 0);
			PHALCON_INIT_VAR(t2);
			phalcon_read_property(&t2, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r2);
			phalcon_array_fetch(&r2, t2, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r2, access_name);
			if (!eval_int) {
				PHALCON_INIT_VAR(i2);
				object_init_ex(i2, phalcon_acl_exception_ce);
				PHALCON_INIT_VAR(r3);
				PHALCON_CONCAT_SVSVS(r3, "Acccess '", access_name, "' does not exist in resource '", resource_name, "' in ACL");
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i2, "__construct", r3, PH_CHECK);
				phalcon_throw_exception(i2 TSRMLS_CC);
				return;
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_c945_2;
			fee_c945_2:
			if(0){}
		} else {
			return;
		}
		if (phalcon_valid_foreach(access TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(access);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_c945_3:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_c945_3;
			}
			
			PHALCON_INIT_VAR(access_name);
			ZVAL_ZVAL(access_name, *hd, 1, 0);
			PHALCON_INIT_VAR(t3);
			phalcon_read_property(&t3, this_ptr, SL("_access"), PH_NOISY_CC);
			if (Z_TYPE_P(t3) == IS_ARRAY) {
				PHALCON_INIT_VAR(t4);
				phalcon_array_fetch(&t4, t3, role_name, PH_SILENT_CC);
			}
			if (Z_REFCOUNT_P(t4) > 1) {
				phalcon_array_update(&t3, role_name, &t4, PH_COPY | PH_CTOR TSRMLS_CC);
			}
			if (Z_TYPE_P(t4) != IS_ARRAY) {
				convert_to_array(t4);
				phalcon_array_update(&t3, role_name, &t4, PH_COPY TSRMLS_CC);
			}
			if (Z_TYPE_P(t4) == IS_ARRAY) {
				PHALCON_INIT_VAR(t5);
				phalcon_array_fetch(&t5, t4, resource_name, PH_SILENT_CC);
			}
			if (Z_REFCOUNT_P(t5) > 1) {
				phalcon_array_update(&t4, resource_name, &t5, PH_COPY | PH_CTOR TSRMLS_CC);
			}
			if (Z_TYPE_P(t5) != IS_ARRAY) {
				convert_to_array(t5);
				phalcon_array_update(&t4, resource_name, &t5, PH_COPY TSRMLS_CC);
			}
			phalcon_array_update(&t5, access_name, &action, PH_COPY TSRMLS_CC);
			
			PHALCON_INIT_VAR(t6);
			phalcon_read_property(&t6, this_ptr, SL("_access"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r4);
			phalcon_array_fetch(&r4, t6, role_name, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r5);
			phalcon_array_fetch(&r5, r4, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(r5, SL("*")+1);
			if (!eval_int) {
				PHALCON_INIT_VAR(t7);
				phalcon_read_property(&t7, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
				PHALCON_INIT_VAR(t8);
				phalcon_read_property(&t8, this_ptr, SL("_access"), PH_NOISY_CC);
				if (Z_TYPE_P(t8) == IS_ARRAY) {
					PHALCON_INIT_VAR(t9);
					phalcon_array_fetch(&t9, t8, role_name, PH_SILENT_CC);
				}
				if (Z_REFCOUNT_P(t9) > 1) {
					phalcon_array_update(&t8, role_name, &t9, PH_COPY | PH_CTOR TSRMLS_CC);
				}
				if (Z_TYPE_P(t9) != IS_ARRAY) {
					convert_to_array(t9);
					phalcon_array_update(&t8, role_name, &t9, PH_COPY TSRMLS_CC);
				}
				if (Z_TYPE_P(t9) == IS_ARRAY) {
					PHALCON_INIT_VAR(t10);
					phalcon_array_fetch(&t10, t9, resource_name, PH_SILENT_CC);
				}
				if (Z_REFCOUNT_P(t10) > 1) {
					phalcon_array_update(&t9, resource_name, &t10, PH_COPY | PH_CTOR TSRMLS_CC);
				}
				if (Z_TYPE_P(t10) != IS_ARRAY) {
					convert_to_array(t10);
					phalcon_array_update(&t9, resource_name, &t10, PH_COPY TSRMLS_CC);
				}
				phalcon_array_update_string(&t10, SL("*"), &t7, PH_COPY TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_c945_3;
			fee_c945_3:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_ALLOC_ZVAL_MM(t11);
		phalcon_read_property(&t11, this_ptr, SL("_accessList"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_array_fetch(&r6, t11, resource_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r6, access);
		if (!eval_int) {
			PHALCON_ALLOC_ZVAL_MM(i3);
			object_init_ex(i3, phalcon_acl_exception_ce);
			PHALCON_ALLOC_ZVAL_MM(r7);
			PHALCON_CONCAT_SVSVS(r7, "Acccess '", access, "' does not exist in resource '", resource_name, "' in ACL");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i3, "__construct", r7, PH_CHECK);
			phalcon_throw_exception(i3 TSRMLS_CC);
			return;
		}
		
		PHALCON_ALLOC_ZVAL_MM(t12);
		phalcon_read_property(&t12, this_ptr, SL("_access"), PH_NOISY_CC);
		if (Z_TYPE_P(t12) == IS_ARRAY) {
			PHALCON_ALLOC_ZVAL_MM(t13);
			phalcon_array_fetch(&t13, t12, role_name, PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t13) > 1) {
			phalcon_array_update(&t12, role_name, &t13, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t13) != IS_ARRAY) {
			convert_to_array(t13);
			phalcon_array_update(&t12, role_name, &t13, PH_COPY TSRMLS_CC);
		}
		if (Z_TYPE_P(t13) == IS_ARRAY) {
			PHALCON_ALLOC_ZVAL_MM(t14);
			phalcon_array_fetch(&t14, t13, resource_name, PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t14) > 1) {
			phalcon_array_update(&t13, resource_name, &t14, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t14) != IS_ARRAY) {
			convert_to_array(t14);
			phalcon_array_update(&t13, resource_name, &t14, PH_COPY TSRMLS_CC);
		}
		phalcon_array_update(&t14, access, &action, PH_COPY TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t15);
		phalcon_read_property(&t15, this_ptr, SL("_access"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r8);
		phalcon_array_fetch(&r8, t15, role_name, PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r9);
		phalcon_array_fetch(&r9, r8, resource_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(r9, SL("*")+1);
		if (!eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t16);
			phalcon_read_property(&t16, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(t17);
			phalcon_read_property(&t17, this_ptr, SL("_access"), PH_NOISY_CC);
			if (Z_TYPE_P(t17) == IS_ARRAY) {
				PHALCON_ALLOC_ZVAL_MM(t18);
				phalcon_array_fetch(&t18, t17, role_name, PH_SILENT_CC);
			}
			if (Z_REFCOUNT_P(t18) > 1) {
				phalcon_array_update(&t17, role_name, &t18, PH_COPY | PH_CTOR TSRMLS_CC);
			}
			if (Z_TYPE_P(t18) != IS_ARRAY) {
				convert_to_array(t18);
				phalcon_array_update(&t17, role_name, &t18, PH_COPY TSRMLS_CC);
			}
			if (Z_TYPE_P(t18) == IS_ARRAY) {
				PHALCON_ALLOC_ZVAL_MM(t19);
				phalcon_array_fetch(&t19, t18, resource_name, PH_SILENT_CC);
			}
			if (Z_REFCOUNT_P(t19) > 1) {
				phalcon_array_update(&t18, resource_name, &t19, PH_COPY | PH_CTOR TSRMLS_CC);
			}
			if (Z_TYPE_P(t19) != IS_ARRAY) {
				convert_to_array(t19);
				phalcon_array_update(&t18, resource_name, &t19, PH_COPY TSRMLS_CC);
			}
			phalcon_array_update_string(&t19, SL("*"), &t16, PH_COPY TSRMLS_CC);
		}
	}
	
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Allow access to a role on a resource
 *
 * You can use '*' as wildcard
 *
 * Ej:
 * 
 * @param string $roleName
 * @param string $resourceName
 * @param mixed $access
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, allow){

	zval *role_name = NULL, *resource_name = NULL, *access = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role_name, &resource_name, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_4(r0, this_ptr, "_allowordeny", role_name, resource_name, access, c0, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Deny access to a role on a resource
 *
 * You can use '*' as wildcard
 *
 * Ej:
 * 
 * @param string $roleName
 * @param string $resourceName
 * @param mixed $access
 * @return boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, deny){

	zval *role_name = NULL, *resource_name = NULL, *access = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role_name, &resource_name, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 0);
	PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_allowordeny", role_name, resource_name, access, c0, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether a role is allowed to access an action from a resource
 *
 * @param  string $role
 * @param  string $resource
 * @param  mixed $accessList
 * @return boolean
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, isAllowed){

	zval *role = NULL, *resource = NULL, *access = NULL, *access_roles = NULL, *resource_access = NULL;
	zval *resource_name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role, &resource, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, resource);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
		
		RETURN_CCTOR(t1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t2, role);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
		
		RETURN_CCTOR(t3);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_access"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(access_roles);
	phalcon_array_fetch(&access_roles, t4, role, PH_NOISY_CC);
	if (phalcon_valid_foreach(access_roles TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(access_roles);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_c945_4:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_c945_4;
		} else {
			PHALCON_INIT_VAR(resource_name);
			PHALCON_GET_FOREACH_KEY(resource_name, ah0, hp0);
		}
		PHALCON_INIT_VAR(resource_access);
		ZVAL_ZVAL(resource_access, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		is_equal_function(r0, resource_name, resource TSRMLS_CC);
		if (zend_is_true(r0)) {
			eval_int = phalcon_array_isset(resource_access, access);
			if (eval_int) {
				PHALCON_INIT_VAR(r1);
				phalcon_array_fetch(&r1, resource_access, access, PH_NOISY_CC);
				
				RETURN_CCTOR(r1);
			}
			
			PHALCON_INIT_VAR(r2);
			phalcon_array_fetch_string(&r2, resource_access, SL("*"), PH_NOISY_CC);
			
			RETURN_CCTOR(r2);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_c945_4;
		fee_c945_4:
		if(0){}
	} else {
		return;
	}
	if (phalcon_valid_foreach(access_roles TSRMLS_CC)) {
		ah1 = Z_ARRVAL_P(access_roles);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
		fes_c945_5:
		if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
			goto fee_c945_5;
		} else {
			PHALCON_INIT_VAR(resource_name);
			PHALCON_GET_FOREACH_KEY(resource_name, ah1, hp1);
		}
		PHALCON_INIT_VAR(resource_access);
		ZVAL_ZVAL(resource_access, *hd, 1, 0);
		eval_int = phalcon_array_isset_string(resource_access, SL("*")+1);
		if (eval_int) {
			eval_int = phalcon_array_isset(resource_access, access);
			if (eval_int) {
				PHALCON_INIT_VAR(r3);
				phalcon_array_fetch(&r3, resource_access, access, PH_NOISY_CC);
				
				RETURN_CCTOR(r3);
			}
			
			PHALCON_INIT_VAR(r4);
			phalcon_array_fetch_string(&r4, resource_access, SL("*"), PH_NOISY_CC);
			
			RETURN_CCTOR(r4);
		}
		zend_hash_move_forward_ex(ah1, &hp1);
		goto fes_c945_5;
		fee_c945_5:
		if(0){}
	} else {
		return;
	}
	PHALCON_MM_RESTORE();
	RETURN_LONG(0);
}

/**
 * Rebuild the list of access from the inherit lists
 *
 */
PHP_METHOD(Phalcon_Acl_Adapter_Memory, _rebuildAccessList){

	zval *number_roles = NULL, *middle = NULL, *i = NULL, *one = NULL, *role_name = NULL;
	zval *role_inherit = NULL, *access = NULL, *resource_name = NULL;
	zval *value = NULL, *name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3;
	HashPosition hp0, hp1, hp2, hp3;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_roles"), PH_NOISY_CC);
	PHALCON_INIT_VAR(number_roles);
	phalcon_fast_count(number_roles, t0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	mul_function(r0, number_roles, number_roles TSRMLS_CC);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 2);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	div_function(r1, r0, t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(middle);
	PHALCON_CALL_FUNC_PARAMS_1(middle, "ceil", r1);
	
	PHALCON_INIT_VAR(i);
	ZVAL_LONG(i, 0);
	fs_c945_6:
		
		PHALCON_INIT_VAR(r2);
		is_smaller_or_equal_function(r2, i, middle TSRMLS_CC);
		if (!zend_is_true(r2)) {
			goto fe_c945_6;
		}
		PHALCON_INIT_VAR(t2);
		phalcon_read_property(&t2, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
		if (phalcon_valid_foreach(t2 TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(t2);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_c945_7:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_c945_7;
			} else {
				PHALCON_INIT_VAR(role_name);
				PHALCON_GET_FOREACH_KEY(role_name, ah0, hp0);
			}
			PHALCON_INIT_VAR(one);
			ZVAL_ZVAL(one, *hd, 1, 0);
			PHALCON_INIT_VAR(t3);
			phalcon_read_property(&t3, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
			eval_int = phalcon_array_isset(t3, role_name);
			if (eval_int) {
				PHALCON_INIT_VAR(t4);
				phalcon_read_property(&t4, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
				PHALCON_INIT_VAR(r3);
				phalcon_array_fetch(&r3, t4, role_name, PH_NOISY_CC);
				if (phalcon_valid_foreach(r3 TSRMLS_CC)) {
					ah1 = Z_ARRVAL_P(r3);
					zend_hash_internal_pointer_reset_ex(ah1, &hp1);
					fes_c945_8:
					if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
						goto fee_c945_8;
					}
					PHALCON_INIT_VAR(role_inherit);
					ZVAL_ZVAL(role_inherit, *hd, 1, 0);
					PHALCON_INIT_VAR(t5);
					phalcon_read_property(&t5, this_ptr, SL("_access"), PH_NOISY_CC);
					eval_int = phalcon_array_isset(t5, role_inherit);
					if (eval_int) {
						PHALCON_INIT_VAR(t6);
						phalcon_read_property(&t6, this_ptr, SL("_access"), PH_NOISY_CC);
						PHALCON_INIT_VAR(r4);
						phalcon_array_fetch(&r4, t6, role_inherit, PH_NOISY_CC);
						if (phalcon_valid_foreach(r4 TSRMLS_CC)) {
							ah2 = Z_ARRVAL_P(r4);
							zend_hash_internal_pointer_reset_ex(ah2, &hp2);
							fes_c945_9:
							if(zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS){
								goto fee_c945_9;
							} else {
								PHALCON_INIT_VAR(resource_name);
								PHALCON_GET_FOREACH_KEY(resource_name, ah2, hp2);
							}
							PHALCON_INIT_VAR(access);
							ZVAL_ZVAL(access, *hd, 1, 0);
							if (phalcon_valid_foreach(access TSRMLS_CC)) {
								ah3 = Z_ARRVAL_P(access);
								zend_hash_internal_pointer_reset_ex(ah3, &hp3);
								fes_c945_10:
								if(zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) != SUCCESS){
									goto fee_c945_10;
								} else {
									PHALCON_INIT_VAR(name);
									PHALCON_GET_FOREACH_KEY(name, ah3, hp3);
								}
								PHALCON_INIT_VAR(value);
								ZVAL_ZVAL(value, *hd, 1, 0);
								PHALCON_INIT_VAR(t7);
								phalcon_read_property(&t7, this_ptr, SL("_access"), PH_NOISY_CC);
								if (Z_TYPE_P(t7) == IS_ARRAY) {
									PHALCON_INIT_VAR(t8);
									phalcon_array_fetch(&t8, t7, role_name, PH_SILENT_CC);
								}
								if (Z_REFCOUNT_P(t8) > 1) {
									phalcon_array_update(&t7, role_name, &t8, PH_COPY | PH_CTOR TSRMLS_CC);
								}
								if (Z_TYPE_P(t8) != IS_ARRAY) {
									convert_to_array(t8);
									phalcon_array_update(&t7, role_name, &t8, PH_COPY TSRMLS_CC);
								}
								if (Z_TYPE_P(t8) == IS_ARRAY) {
									PHALCON_INIT_VAR(t9);
									phalcon_array_fetch(&t9, t8, resource_name, PH_SILENT_CC);
								}
								if (Z_REFCOUNT_P(t9) > 1) {
									phalcon_array_update(&t8, resource_name, &t9, PH_COPY | PH_CTOR TSRMLS_CC);
								}
								if (Z_TYPE_P(t9) != IS_ARRAY) {
									convert_to_array(t9);
									phalcon_array_update(&t8, resource_name, &t9, PH_COPY TSRMLS_CC);
								}
								phalcon_array_update(&t9, name, &value, PH_COPY TSRMLS_CC);
								zend_hash_move_forward_ex(ah3, &hp3);
								goto fes_c945_10;
								fee_c945_10:
								if(0){}
							} else {
								return;
							}
							zend_hash_move_forward_ex(ah2, &hp2);
							goto fes_c945_9;
							fee_c945_9:
							if(0){}
						} else {
							return;
						}
					}
					zend_hash_move_forward_ex(ah1, &hp1);
					goto fes_c945_8;
					fee_c945_8:
					if(0){}
				} else {
					return;
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_c945_7;
			fee_c945_7:
			if(0){}
		} else {
			return;
		}
		PHALCON_SEPARATE(i);
		increment_function(i);
		goto fs_c945_6;
	fe_c945_6:
	if(0){}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \acl\adapter\memory.c ------ */

/* ------ Starting File: \acl\role.c ------ */
/**
 *
 * Phalcon_Acl_Role
 *
 * This class defines role entity and its description
 *
 */

/**
 * Phalcon_Acl_Role description
 *
 * @param string $name
 * @param string $description
 */
PHP_METHOD(Phalcon_Acl_Role, __construct){

	zval *name = NULL, *description = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &description) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!description) {
		PHALCON_ALLOC_ZVAL_MM(description);
		ZVAL_STRING(description, "", 1);
	}
	
	if (PHALCON_COMPARE_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_acl_exception_ce, "Role name cannot be \"*\"");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_description"), description TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the role name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Acl_Role, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_name"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns role description
 *
 * @return string
 */
PHP_METHOD(Phalcon_Acl_Role, getDescription){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_description"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \acl\role.c ------ */

/* ------ Starting File: \acl\resource.c ------ */
/**
 *
 * Phalcon_Acl_Resource
 *
 * This class defines resource entity and its description
 *
 */

/**
 * Phalcon_Acl_Resource description
 *
 * @param string $name
 * @param string $description
 */
PHP_METHOD(Phalcon_Acl_Resource, __construct){

	zval *name = NULL, *description = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &description) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!description) {
		PHALCON_ALLOC_ZVAL_MM(description);
		ZVAL_NULL(description);
	}
	
	if (PHALCON_COMPARE_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_acl_exception_ce, "Resource name cannot be \"*\"");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_description"), description TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the resource name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Acl_Resource, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_name"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns resource description
 *
 * @return string
 */
PHP_METHOD(Phalcon_Acl_Resource, getDescription){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_description"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \acl\resource.c ------ */

/* ------ Starting File: \cache.c ------ */
/**
 * Phalcon\Cache
 *
 * Phalcon\Cache can be used to cache output fragments, PHP data and raw data in order to improve performance
 *
 *
 */

/**
 * Factories different caches backends from their adapters
 *
 * @param string $frontendAdapter
 * @param string $backendAdapter
 * @param array $frontendOptions
 * @param array $backendOptions
 * @return  Phalcon_Cache_Backend_File
 */
PHP_METHOD(Phalcon_Cache, factory){

	zval *frontend_adapter = NULL, *backend_adapter = NULL;
	zval *frontend_options = NULL, *backend_options = NULL;
	zval *frontend_class = NULL, *backend_class = NULL, *front_object = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *i0 = NULL, *i1 = NULL, *i2 = NULL;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &frontend_adapter, &backend_adapter, &frontend_options, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!frontend_options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(frontend_options, a0);
	}
	
	if (!backend_options) {
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		PHALCON_CPY_WRT(backend_options, a1);
	}
	
	PHALCON_INIT_VAR(frontend_class);
	PHALCON_CONCAT_SV(frontend_class, "Phalcon\\Cache\\Frontend\\", frontend_adapter);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", frontend_class);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_cache_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Frontend adapter \"", backend_adapter, "\" doesn't exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_INIT_VAR(backend_class);
	PHALCON_CONCAT_SV(backend_class, "Phalcon\\Cache\\Backend\\", backend_adapter);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_1(r2, "class_exists", backend_class);
	if (!zend_is_true(r2)) {
		PHALCON_ALLOC_ZVAL_MM(i1);
		object_init_ex(i1, phalcon_cache_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CONCAT_SVS(r3, "Backend adapter \"", backend_adapter, "\" doesn't exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", r3, PH_CHECK);
		phalcon_throw_exception(i1 TSRMLS_CC);
		return;
	}
	
	ce0 = phalcon_fetch_class(frontend_class TSRMLS_CC);
	
	PHALCON_INIT_VAR(front_object);
	object_init_ex(front_object, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(front_object, "__construct", frontend_options, PH_CHECK);
	ce1 = phalcon_fetch_class(backend_class TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(i2);
	object_init_ex(i2, ce1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i2, "__construct", front_object, backend_options, PH_CHECK);
	
	RETURN_CTOR(i2);
}

/* ------ Finished File: \cache.c ------ */

/* ------ Starting File: \dispatcher\exception.c ------ */
/**
 * Phalcon\Dispatcher\Exception
 *
 * Exceptions thrown in Phalcon_Dispatcher will use this class
 *
 */

/* ------ Finished File: \dispatcher\exception.c ------ */

/* ------ Starting File: \view.c ------ */
/**
 * Phalcon\iew
 *
 * Phalcon_View is a class for working with the "view" portion of the model-view-controller pattern.
 * That is, it exists to help keep the view script separate from the model and controller scripts.
 * It provides a system of helpers, output filters, and variable escaping.
 *
 * 
 */

/**
 * Phalcon_View constructor
 *
 * @param Phalcon_Config|stClass $options
 */
PHP_METHOD(Phalcon_View, __construct){

	zval *options = NULL, *view_options = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL, *a4 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_view_ce, this_ptr, SL("_viewParams"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_view_ce, this_ptr, SL("_templatesBefore"), a1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a2);
	array_init(a2);
	zend_update_property(phalcon_view_ce, this_ptr, SL("_templatesAfter"), a2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a3);
	array_init(a3);
	zend_update_property(phalcon_view_ce, this_ptr, SL("_registeredEngines"), a3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a4);
	array_init(a4);
	zend_update_property(phalcon_view_ce, this_ptr, SL("_params"), a4 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(options);
		ZVAL_NULL(options);
	}
	
	if (zend_is_true(options)) {
		if (Z_TYPE_P(options) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Options parameter must be an object");
			return;
		}
		PHALCON_CPY_WRT(view_options, options);
	} else {
		PHALCON_INIT_VAR(view_options);
		object_init(view_options);
	}
	phalcon_update_property_zval(this_ptr, SL("_options"), view_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets views directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $viewsDir
 */
PHP_METHOD(Phalcon_View, setViewsDir){

	zval *views_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &views_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_viewsDir"), views_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets views directory
 *
 * @return string
 */
PHP_METHOD(Phalcon_View, getViewsDir){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewsDir"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets base path. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $basePath
 */
PHP_METHOD(Phalcon_View, setBasePath){

	zval *base_path = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets the render level for the view
 *
 * @param string $level
 */
PHP_METHOD(Phalcon_View, setRenderLevel){

	zval *level = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &level) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_renderLevel"), level TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets default view name. Must be a file without extension in the views directory
 *
 * @param string $name
 */
PHP_METHOD(Phalcon_View, setMainView){

	zval *view_path = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &view_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_mainView"), view_path TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Appends template before controller layout
 *
 * @param string|array $templateBefore
 */
PHP_METHOD(Phalcon_View, setTemplateBefore){

	zval *template_before = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &template_before) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(template_before) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		phalcon_array_append(&a0, template_before, PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_templatesBefore"), a0 TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_templatesBefore"), template_before TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Resets any template before layouts
 *
 */
PHP_METHOD(Phalcon_View, cleanTemplateBefore){


	PHALCON_MM_GROW();
	phalcon_update_property_null(this_ptr, SL("_templatesBefore") TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Appends template after controller layout
 *
 * @param string|array $templateAfter
 */
PHP_METHOD(Phalcon_View, setTemplateAfter){

	zval *template_after = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &template_after) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(template_after) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		phalcon_array_append(&a0, template_after, PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_templatesAfter"), a0 TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_templatesAfter"), template_after TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Resets any template before layouts
 *
 */
PHP_METHOD(Phalcon_View, cleanTemplateAfter){


	PHALCON_MM_GROW();
	phalcon_update_property_null(this_ptr, SL("_templatesAfter") TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Adds parameters to views (alias of setVar)
 *
 * @param string $key
 * @param mixed $value
 */
PHP_METHOD(Phalcon_View, setParamToView){

	zval *key = NULL, *value = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	phalcon_array_update(&t0, key, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_viewParams"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Adds parameters to views
 *
 * @param string $key
 * @param mixed $value
 */
PHP_METHOD(Phalcon_View, setVar){

	zval *key = NULL, *value = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	phalcon_array_update(&t0, key, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_viewParams"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns parameters to views
 *
 * @return array
 */
PHP_METHOD(Phalcon_View, getParamsToView){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the name of the controller rendered
 *
 * @return string
 */
PHP_METHOD(Phalcon_View, getControllerName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controllerName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the name of the action rendered
 *
 * @return string
 */
PHP_METHOD(Phalcon_View, getActionName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_actionName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets extra parameters of the action rendered
 */
PHP_METHOD(Phalcon_View, getParams){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Starts rendering process enabling the output buffering
 */
PHP_METHOD(Phalcon_View, start){


	PHALCON_MM_GROW();
	phalcon_update_property_null(this_ptr, SL("_content") TSRMLS_CC);
	PHALCON_CALL_FUNC_NORETURN("ob_start");
	
	PHALCON_MM_RESTORE();
}

/**
 * Loads registered template engines, if none is registered use Phalcon_View_Engine_Php
 *
 * @return array
 */
PHP_METHOD(Phalcon_View, _loadTemplateEngines){

	zval *engines = NULL, *registered_engines = NULL, *engine = NULL;
	zval *extension = NULL, *options = NULL, *name = NULL, *class_name = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *i0 = NULL, *i1 = NULL, *i2 = NULL;
	zval *a0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_engines"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_INIT_VAR(engines);
		array_init(engines);
		
		PHALCON_INIT_VAR(registered_engines);
		phalcon_read_property(&registered_engines, this_ptr, SL("_registeredEngines"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_fast_count(r0, registered_engines TSRMLS_CC);
		if (!zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_view_engine_php_ce);
			PHALCON_ALLOC_ZVAL_MM(a0);
			array_init(a0);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", this_ptr, a0, PH_CHECK);
			phalcon_array_update_string(&engines, SL(".phtml"), &i0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			if (phalcon_valid_foreach(registered_engines TSRMLS_CC)) {
				ah0 = Z_ARRVAL_P(registered_engines);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
				fes_b0d8_0:
				if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
					goto fee_b0d8_0;
				} else {
					PHALCON_INIT_VAR(extension);
					PHALCON_GET_FOREACH_KEY(extension, ah0, hp0);
				}
				PHALCON_INIT_VAR(engine);
				ZVAL_ZVAL(engine, *hd, 1, 0);
				PHALCON_INIT_VAR(options);
				array_init(options);
				if (Z_TYPE_P(engine) == IS_ARRAY) { 
					eval_int = phalcon_array_isset_long(engine, 0);
					if (eval_int) {
						PHALCON_INIT_VAR(name);
						phalcon_array_fetch_long(&name, engine, 0, PH_NOISY_CC);
					} else {
						PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "The template engine name is required");
						return;
					}
					eval_int = phalcon_array_isset_long(engine, 1);
					if (eval_int) {
						PHALCON_INIT_VAR(options);
						phalcon_array_fetch_long(&options, engine, 1, PH_NOISY_CC);
					}
				} else {
					if (Z_TYPE_P(engine) == IS_STRING) {
						PHALCON_CPY_WRT(name, engine);
					} else {
						if (Z_TYPE_P(engine) == IS_OBJECT) {
							PHALCON_CALL_METHOD_PARAMS_2_NORETURN(engine, "initialize", this_ptr, options, PH_NO_CHECK);
							phalcon_array_update(&engines, extension, &engine, PH_COPY | PH_SEPARATE TSRMLS_CC);
							goto fes_b0d8_0;
						} else {
							PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "The template engine is invalid");
							return;
						}
					}
				}
				
				PHALCON_INIT_VAR(class_name);
				PHALCON_CONCAT_SV(class_name, "Phalcon\\View\\Engine\\", name);
				
				PHALCON_INIT_VAR(r1);
				PHALCON_CALL_FUNC_PARAMS_1(r1, "class_exists", class_name);
				if (zend_is_true(r1)) {
					ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
					PHALCON_INIT_VAR(i1);
					object_init_ex(i1, ce0);
					PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i1, "__construct", this_ptr, options, PH_CHECK);
					phalcon_array_update(&engines, extension, &i1, PH_COPY | PH_SEPARATE TSRMLS_CC);
				} else {
					PHALCON_INIT_VAR(i2);
					object_init_ex(i2, phalcon_view_exception_ce);
					PHALCON_INIT_VAR(r2);
					PHALCON_CONCAT_SVS(r2, "Template engine '", class_name, "' cannot be loaded");
					PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i2, "__construct", r2, PH_CHECK);
					phalcon_throw_exception(i2 TSRMLS_CC);
					return;
				}
				zend_hash_move_forward_ex(ah0, &hp0);
				goto fes_b0d8_0;
				fee_b0d8_0:
				if(0){}
			} else {
				return;
			}
		}
		
		phalcon_update_property_zval(this_ptr, SL("_engines"), engines TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(engines);
		phalcon_read_property(&engines, this_ptr, SL("_engines"), PH_NOISY_CC);
	}
	
	RETURN_CCTOR(engines);
}

/**
 * Checks whether view exists on registered extensions and render it
 *
 * @param array $engines
 * @param string $viewPath
 * @param boolean $silence
 * @param Phalcon_Cache $cache
 */
PHP_METHOD(Phalcon_View, _engineRender){

	zval *engines = NULL, *view_path = NULL, *silence = NULL, *cache = NULL, *not_exists = NULL;
	zval *view_params = NULL, *views_dir_path = NULL, *render_level = NULL;
	zval *cache_level = NULL, *key = NULL, *view_options = NULL, *cache_options = NULL;
	zval *cached_view = NULL, *engine = NULL, *extension = NULL, *view_engine_path = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *i0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &engines, &view_path, &silence, &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(not_exists);
	ZVAL_BOOL(not_exists, 1);
	
	PHALCON_INIT_VAR(view_params);
	phalcon_read_property(&view_params, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_viewsDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(views_dir_path);
	PHALCON_CONCAT_VVV(views_dir_path, t0, t1, view_path);
	if (zend_is_true(cache)) {
		PHALCON_INIT_VAR(render_level);
		phalcon_read_property(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(cache_level);
		phalcon_read_property(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		is_smaller_or_equal_function(r0, cache_level, render_level TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_METHOD(r1, cache, "isstarted", PH_NO_CHECK);
			if (!zend_is_true(r1)) {
				PHALCON_INIT_VAR(key);
				ZVAL_NULL(key);
				
				PHALCON_INIT_VAR(view_options);
				phalcon_read_property(&view_options, this_ptr, SL("_options"), PH_NOISY_CC);
				eval_int = phalcon_isset_property(view_options, SL("cache") TSRMLS_CC);
				if (eval_int) {
					PHALCON_INIT_VAR(cache_options);
					phalcon_read_property(&cache_options, view_options, SL("cache"), PH_NOISY_CC);
					if (Z_TYPE_P(cache_options) == IS_OBJECT) {
						eval_int = phalcon_isset_property(cache_options, SL("key") TSRMLS_CC);
						if (eval_int) {
							PHALCON_INIT_VAR(key);
							phalcon_read_property(&key, cache_options, SL("key"), PH_NOISY_CC);
						}
					}
				}
				
				if (!zend_is_true(key)) {
					PHALCON_INIT_VAR(key);
					PHALCON_CALL_FUNC_PARAMS_1(key, "md5", view_path);
				}
				
				PHALCON_INIT_VAR(cached_view);
				PHALCON_CALL_METHOD_PARAMS_1(cached_view, cache, "start", key, PH_NO_CHECK);
				if (Z_TYPE_P(cached_view) != IS_NULL) {
					phalcon_update_property_zval(this_ptr, SL("_content"), cached_view TSRMLS_CC);
					PHALCON_MM_RESTORE();
					RETURN_NULL();
				}
			}
			
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD(r2, cache, "isfresh", PH_NO_CHECK);
			if (!zend_is_true(r2)) {
				PHALCON_MM_RESTORE();
				RETURN_NULL();
			}
		}
	}
	
	if (phalcon_valid_foreach(engines TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(engines);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_b0d8_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_b0d8_1;
		} else {
			PHALCON_INIT_VAR(extension);
			PHALCON_GET_FOREACH_KEY(extension, ah0, hp0);
		}
		PHALCON_INIT_VAR(engine);
		ZVAL_ZVAL(engine, *hd, 1, 0);
		PHALCON_INIT_VAR(view_engine_path);
		PHALCON_CONCAT_VV(view_engine_path, views_dir_path, extension);
		if (phalcon_file_exists(view_engine_path TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(engine, "render", view_engine_path, view_params, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(not_exists);
			ZVAL_BOOL(not_exists, 0);
			goto fee_b0d8_1;
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_b0d8_1;
		fee_b0d8_1:
		if(0){}
	} else {
		return;
	}
	if (zend_is_true(not_exists)) {
		if (!zend_is_true(silence)) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_view_exception_ce);
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CONCAT_SVS(r3, "View '", views_dir_path, "' was not found in the views directory");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r3, PH_CHECK);
			phalcon_throw_exception(i0 TSRMLS_CC);
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Register templating engines
 *
 * @param array $engines
 */
PHP_METHOD(Phalcon_View, registerEngines){

	zval *engines = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &engines) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(engines) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "Engines to register must be an array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_registeredEngines"), engines TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Executes render process from request data
 *
 * @param string $controllerName
 * @param string $actionName
 * @param array $params
 */
PHP_METHOD(Phalcon_View, render){

	zval *controller_name = NULL, *action_name = NULL, *params = NULL;
	zval *layouts_dir = NULL, *engines = NULL, *pick_view = NULL, *render_view = NULL;
	zval *render_controller = NULL, *cache = NULL, *cache_level = NULL;
	zval *silence = NULL, *render_level = NULL, *templates_before = NULL;
	zval *template_before = NULL, *templates_after = NULL, *template_after = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &controller_name, &action_name, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!params) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(params, a0);
	}
	
	PHALCON_INIT_VAR(layouts_dir);
	phalcon_read_property(&layouts_dir, this_ptr, SL("_layoutsDir"), PH_NOISY_CC);
	if (!zend_is_true(layouts_dir)) {
		PHALCON_INIT_VAR(layouts_dir);
		ZVAL_STRING(layouts_dir, "layouts/", 1);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_controllerName"), controller_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_initEngines"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(engines);
	PHALCON_CALL_METHOD(engines, this_ptr, "_loadtemplateengines", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(pick_view);
	phalcon_read_property(&pick_view, this_ptr, SL("_pickView"), PH_NOISY_CC);
	if (!zend_is_true(pick_view)) {
		PHALCON_INIT_VAR(render_view);
		PHALCON_CONCAT_VSV(render_view, controller_name, "/", action_name);
		PHALCON_CPY_WRT(render_controller, controller_name);
	} else {
		PHALCON_INIT_VAR(render_view);
		phalcon_array_fetch_long(&render_view, pick_view, 0, PH_NOISY_CC);
		eval_int = phalcon_array_isset_long(pick_view, 1);
		if (eval_int) {
			PHALCON_INIT_VAR(render_controller);
			phalcon_array_fetch_long(&render_controller, pick_view, 1, PH_NOISY_CC);
		} else {
			PHALCON_CPY_WRT(render_controller, controller_name);
		}
	}
	
	PHALCON_INIT_VAR(cache);
	ZVAL_NULL(cache);
	
	PHALCON_INIT_VAR(cache_level);
	phalcon_read_property(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY_CC);
	if (zend_is_true(cache_level)) {
		PHALCON_INIT_VAR(cache);
		PHALCON_CALL_METHOD(cache, this_ptr, "getcache", PH_NO_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC(r0, "ob_get_contents");
	phalcon_update_property_zval(this_ptr, SL("_content"), r0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(silence);
	ZVAL_BOOL(silence, 1);
	
	PHALCON_INIT_VAR(render_level);
	phalcon_read_property(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY_CC);
	if (zend_is_true(render_level)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 1);
		PHALCON_ALLOC_ZVAL_MM(r1);
		is_smaller_or_equal_function(r1, t0, render_level TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, render_view, silence, cache, PH_NO_CHECK);
		}
		
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 2);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		is_smaller_or_equal_function(r2, t1, render_level TSRMLS_CC);
		if (zend_is_true(r2)) {
			PHALCON_INIT_VAR(templates_before);
			phalcon_read_property(&templates_before, this_ptr, SL("_templatesBefore"), PH_NOISY_CC);
			if (zend_is_true(templates_before)) {
				PHALCON_INIT_VAR(silence);
				ZVAL_BOOL(silence, 0);
				if (Z_TYPE_P(templates_before) == IS_ARRAY) { 
					if (phalcon_valid_foreach(templates_before TSRMLS_CC)) {
						ah0 = Z_ARRVAL_P(templates_before);
						zend_hash_internal_pointer_reset_ex(ah0, &hp0);
						fes_b0d8_2:
						if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
							goto fee_b0d8_2;
						}
						PHALCON_INIT_VAR(template_before);
						ZVAL_ZVAL(template_before, *hd, 1, 0);
						PHALCON_INIT_VAR(r3);
						PHALCON_CONCAT_VV(r3, layouts_dir, template_before);
						PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, r3, silence, cache, PH_NO_CHECK);
						zend_hash_move_forward_ex(ah0, &hp0);
						goto fes_b0d8_2;
						fee_b0d8_2:
						if(0){}
					} else {
						return;
					}
				} else {
					PHALCON_ALLOC_ZVAL_MM(r4);
					PHALCON_CONCAT_VV(r4, layouts_dir, template_before);
					PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, r4, silence, cache, PH_NO_CHECK);
				}
				
				PHALCON_INIT_VAR(silence);
				ZVAL_BOOL(silence, 1);
			}
		}
		
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 3);
		
		PHALCON_ALLOC_ZVAL_MM(r5);
		is_smaller_or_equal_function(r5, t2, render_level TSRMLS_CC);
		if (zend_is_true(r5)) {
			PHALCON_ALLOC_ZVAL_MM(r6);
			PHALCON_CONCAT_VV(r6, layouts_dir, render_controller);
			PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, r6, silence, cache, PH_NO_CHECK);
		}
		
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 4);
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		is_smaller_or_equal_function(r7, t3, render_level TSRMLS_CC);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(templates_after);
			phalcon_read_property(&templates_after, this_ptr, SL("_templatesAfter"), PH_NOISY_CC);
			if (zend_is_true(templates_after)) {
				PHALCON_INIT_VAR(silence);
				ZVAL_BOOL(silence, 0);
				if (Z_TYPE_P(templates_after) == IS_ARRAY) { 
					if (phalcon_valid_foreach(templates_after TSRMLS_CC)) {
						ah1 = Z_ARRVAL_P(templates_after);
						zend_hash_internal_pointer_reset_ex(ah1, &hp1);
						fes_b0d8_3:
						if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
							goto fee_b0d8_3;
						}
						PHALCON_INIT_VAR(template_after);
						ZVAL_ZVAL(template_after, *hd, 1, 0);
						PHALCON_INIT_VAR(r8);
						PHALCON_CONCAT_VV(r8, layouts_dir, template_after);
						PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, r8, silence, cache, PH_NO_CHECK);
						zend_hash_move_forward_ex(ah1, &hp1);
						goto fes_b0d8_3;
						fee_b0d8_3:
						if(0){}
					} else {
						return;
					}
				} else {
					PHALCON_ALLOC_ZVAL_MM(r9);
					PHALCON_CONCAT_VV(r9, layouts_dir, templates_after);
					PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, r9, silence, cache, PH_NO_CHECK);
				}
				
				PHALCON_INIT_VAR(silence);
				ZVAL_BOOL(silence, 1);
			}
		}
		
		PHALCON_INIT_VAR(t4);
		ZVAL_LONG(t4, 5);
		
		PHALCON_ALLOC_ZVAL_MM(r10);
		is_smaller_or_equal_function(r10, t4, render_level TSRMLS_CC);
		if (zend_is_true(r10)) {
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, this_ptr, SL("_mainView"), PH_NOISY_CC);
			PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", engines, t5, silence, cache, PH_NO_CHECK);
		}
		
		if (zend_is_true(cache)) {
			PHALCON_ALLOC_ZVAL_MM(r11);
			PHALCON_CALL_METHOD(r11, cache, "isstarted", PH_NO_CHECK);
			if (zend_is_true(r11)) {
				PHALCON_ALLOC_ZVAL_MM(r12);
				PHALCON_CALL_METHOD(r12, cache, "isfresh", PH_NO_CHECK);
				if (zend_is_true(r12)) {
					PHALCON_CALL_METHOD_NORETURN(cache, "save", PH_NO_CHECK);
				}
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Choose a view different to render than last-controller/last-action
 *
 * @param string $renderView
 */
PHP_METHOD(Phalcon_View, pick){

	zval *render_view = NULL, *separator = NULL, *pick_view = NULL, *layout = NULL;
	zval *parts = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &render_view) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(separator);
	ZVAL_STRING(separator, "/", 1);
	if (Z_TYPE_P(render_view) == IS_ARRAY) { 
		PHALCON_CPY_WRT(pick_view, render_view);
	} else {
		PHALCON_INIT_VAR(layout);
		ZVAL_NULL(layout);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_fast_strpos(r0, render_view, separator TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(parts);
			phalcon_fast_explode(parts, separator, render_view TSRMLS_CC);
			
			PHALCON_INIT_VAR(layout);
			phalcon_array_fetch_long(&layout, parts, 0, PH_NOISY_CC);
		}
		
		PHALCON_INIT_VAR(pick_view);
		array_init(pick_view);
		phalcon_array_append(&pick_view, render_view, PH_SEPARATE TSRMLS_CC);
		if (Z_TYPE_P(layout) != IS_NULL) {
			phalcon_array_append(&pick_view, layout, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	phalcon_update_property_zval(this_ptr, SL("_pickView"), pick_view TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Renders a partial view
 *
 * @param string $partialPath
 */
PHP_METHOD(Phalcon_View, partial){

	zval *partial_path = NULL, *vfalse = NULL, *previous_content = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &partial_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(vfalse);
	ZVAL_BOOL(vfalse, 0);
	
	PHALCON_INIT_VAR(previous_content);
	phalcon_read_property(&previous_content, this_ptr, SL("_content"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "_loadtemplateengines", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_enginerender", r0, partial_path, vfalse, vfalse, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CONCAT_VV(r1, previous_content, t0);
	phalcon_update_property_zval(this_ptr, SL("_content"), r1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Finishes the render process by stopping the output buffering
 */
PHP_METHOD(Phalcon_View, finish){


	PHALCON_MM_GROW();
	PHALCON_CALL_FUNC_NORETURN("ob_end_clean");
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the cache object or cache parameters to do the resultset caching
 *
 * @param Phalcon\Cache\Backend|object $cache
 */
PHP_METHOD(Phalcon_View, setCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(cache) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cache must be an object instance");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Create a Phalcon\Cache based on the internal cache options
 *
 * @return Phalcon\Cache
 */
PHP_METHOD(Phalcon_View, _createCache){

	zval *options = NULL, *cache_options = NULL, *array_options = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(options, SL("cache") TSRMLS_CC);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "Cache options aren't defined");
		return;
	}
	
	PHALCON_INIT_VAR(cache_options);
	phalcon_read_property(&cache_options, options, SL("cache"), PH_NOISY_CC);
	eval_int = phalcon_isset_property(cache_options, SL("adapter") TSRMLS_CC);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cache adapter isn't defined");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_cast(r0, cache_options, IS_ARRAY);
	PHALCON_CPY_WRT(array_options, r0);
	
	PHALCON_INIT_VAR(p0[0]);
	ZVAL_STRING(p0[0], "Output", 1);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, cache_options, SL("adapter"), PH_NOISY_CC);
	p0[1] = t0;
	p0[2] = array_options;
	p0[3] = array_options;
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_STATIC_PARAMS(r1, "phalcon\\cache", "factory", 4, p0);
	RETURN_CTOR(r1);
}

/**
 * Returns the cache instance used to cache
 *
 * @return Phalcon\Cache\Backend
 */
PHP_METHOD(Phalcon_View, getCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(cache);
	phalcon_read_property(&cache, this_ptr, SL("_cache"), PH_NOISY_CC);
	if (zend_is_true(cache)) {
		if (Z_TYPE_P(cache) != IS_OBJECT) {
			PHALCON_INIT_VAR(cache);
			PHALCON_CALL_METHOD(cache, this_ptr, "_createcache", PH_NO_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
		}
	} else {
		PHALCON_INIT_VAR(cache);
		PHALCON_CALL_METHOD(cache, this_ptr, "_createcache", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(cache);
}

/**
 * Cache the actual view render to certain level
 *
 * @param boolean|array $options
 */
PHP_METHOD(Phalcon_View, cache){

	zval *options = NULL, *view_options = NULL, *cache_options = NULL;
	zval *value = NULL, *key = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(options);
		ZVAL_BOOL(options, 1);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_INIT_VAR(view_options);
		phalcon_read_property(&view_options, this_ptr, SL("_options"), PH_NOISY_CC);
		eval_int = phalcon_isset_property(view_options, SL("cache") TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_VAR(cache_options);
			phalcon_read_property(&cache_options, view_options, SL("cache"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_VAR(cache_options);
			object_init(cache_options);
		}
		
		if (phalcon_valid_foreach(options TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(options);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_b0d8_4:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_b0d8_4;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			phalcon_update_property_zval_zval(cache_options, key, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_b0d8_4;
			fee_b0d8_4:
			if(0){}
		} else {
			return;
		}
		eval_int = phalcon_isset_property(cache_options, SL("level") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t0);
			phalcon_read_property(&t0, cache_options, SL("level"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_cacheLevel"), t0 TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		}
		
		phalcon_update_property_zval(view_options, SL("cache"), cache_options TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_options"), view_options TSRMLS_CC);
	} else {
		if (zend_is_true(options)) {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 0 TSRMLS_CC);
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Externally sets the view content
 *
 * @param string $content
 */
PHP_METHOD(Phalcon_View, setContent){

	zval *content = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_content"), content TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns cached ouput from another view stage
 *
 * @return string
 */
PHP_METHOD(Phalcon_View, getContent){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Disable view. No show any view or template
 *
 */
PHP_METHOD(Phalcon_View, disable){


	PHALCON_MM_GROW();
	phalcon_update_property_long(this_ptr, SL("_renderLevel"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \view.c ------ */

/* ------ Starting File: \registry.c ------ */
PHP_METHOD(Phalcon_Registry, set){


	
}

/* ------ Finished File: \registry.c ------ */

/* ------ Starting File: \view\engine.c ------ */
/**
 * Phalcon_View_Engine
 *
 * All the template engine adapters must inherit this class. This provides
 * basic interfacing between the engine and the Phalcon_View component.
 */

/**
 * Phalcon_View_Engine constructor
 *
 * @param Phalcon_View $view
 * @param array $options
 * @param array $params
 */
PHP_METHOD(Phalcon_View_Engine, __construct){

	zval *view = NULL, *options = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "initialize", view, options, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Initializes the engine adapter
 *
 * @param Phalcon_View $view
 * @param array $options
 */
PHP_METHOD(Phalcon_View_Engine, initialize){

	zval *view = NULL, *options = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(view) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "Invalid view component provided to Phalcon_View_Engine");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_view"), view TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the name of the controller rendered
 *
 * @return string
 */
PHP_METHOD(Phalcon_View_Engine, getControllerName){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getcontrollername", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Gets the name of the action rendered
 *
 * @return string
 */
PHP_METHOD(Phalcon_View_Engine, getActionName){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getactionname", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Returns cached ouput on another view stage
 *
 * @return array
 */
PHP_METHOD(Phalcon_View_Engine, getContent){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getcontent", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Generates a external absolute path to an application uri
 *
 * @param array|string $params
 * @return string
 */
PHP_METHOD(Phalcon_View_Engine, url){

	zval *params = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!params) {
		PHALCON_ALLOC_ZVAL_MM(params);
		ZVAL_NULL(params);
	}
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
	} else {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\utils", "geturl", params);
		RETURN_CTOR(r0);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a local path
 *
 * @param array|string $params
 * @return string
 */
PHP_METHOD(Phalcon_View_Engine, path){

	zval *params = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!params) {
		PHALCON_ALLOC_ZVAL_MM(params);
		ZVAL_STRING(params, "", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\utils", "getlocalpath", params);
	RETURN_CTOR(r0);
}

/**
 * Renders a partial inside another view
 *
 * @param string $partialPath
 */
PHP_METHOD(Phalcon_View_Engine, partial){

	zval *partial_path = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &partial_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "partial", partial_path, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \view\engine.c ------ */

/* ------ Starting File: \view\exception.c ------ */
/**
 * Phalcon_View_Exception
 *
 * Class for exceptions thrown by Phalcon_View
 */

/* ------ Finished File: \view\exception.c ------ */

/* ------ Starting File: \view\engine\php.c ------ */
/**
 *
 * Phalcon_View_Engine_Php
 *
 * Adapter to use PHP itself as templating engine
 */

/**
 * Phalcon\View\Engine\Php constructor
 *
 * @param Phalcon\View $view
 * @param array $options
 */
PHP_METHOD(Phalcon_View_Engine_Php, __construct){

	zval *view = NULL, *options = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\View\\Engine\\Php", "__construct", view, options);
	
	PHALCON_MM_RESTORE();
}

/**
 * Renders a view using the template engine
 *
 * @param string $path
 * @param array $params
 */
PHP_METHOD(Phalcon_View_Engine_Php, render){

	zval *path = NULL, *params = NULL, *value = NULL, *key = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &path, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_FUNC_NORETURN("ob_clean");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_4b07_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_4b07_0;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (phalcon_set_symbol(key, value TSRMLS_CC) == FAILURE){
			return;
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_4b07_0;
		fee_4b07_0:
		if(0){}
	} else {
		return;
	}
	if (phalcon_require(path TSRMLS_CC) == FAILURE) {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC(r0, "ob_get_contents");
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "setcontent", r0, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \view\engine\php.c ------ */

/* ------ Starting File: \view\engine\twig.c ------ */
/**
 * Phalcon_View_Engine_Twig
 *
 * Adapter to use Twig library as templating engine
 */

/**
 * Phalcon_View_Engine_Twig constructor
 *
 * @param Phalcon_View $view
 * @param array $options
 * @param array $params
 */
PHP_METHOD(Phalcon_View_Engine_Twig, __construct){

	zval *view = NULL, *options = NULL, *twig = NULL, *loader = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "Twig_Environment", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", c0);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "Twig library must be loaded first");
		return;
	}
	eval_int = phalcon_array_isset_string(options, SL("twig")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(twig);
		phalcon_array_fetch_string(&twig, options, SL("twig"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(options, SL("loader")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(loader);
			phalcon_array_fetch_string(&loader, options, SL("loader"), PH_NOISY_CC);
		} else {
			ce0 = zend_fetch_class(SL("Twig_Loader_Filesystem"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_VAR(loader);
			object_init_ex(loader, ce0);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_METHOD(r1, view, "getviewsdir", PH_NO_CHECK);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(loader, "__construct", r1, PH_CHECK);
		}
		ce1 = zend_fetch_class(SL("Twig_Environment"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		
		PHALCON_INIT_VAR(twig);
		object_init_ex(twig, ce1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(twig, "__construct", loader, PH_CHECK);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_twig"), twig TSRMLS_CC);
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\View\\Engine\\Twig", "__construct", view, options);
	
	PHALCON_MM_RESTORE();
}

/**
 * Renders a view using the template engine
 *
 * @param string $path
 * @param array $params
 */
PHP_METHOD(Phalcon_View_Engine_Twig, render){

	zval *path = NULL, *params = NULL, *view = NULL, *twig_params = NULL, *relative_path = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *c0 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &path, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(view);
	phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
	PHALCON_CPY_WRT(twig_params, params);
	eval_int = phalcon_array_isset_string(twig_params, SL("content")+1);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, view, "getcontent", PH_NO_CHECK);
		phalcon_array_update_string(&twig_params, SL("content"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(twig_params, SL("view")+1);
	if (!eval_int) {
		phalcon_array_update_string(&twig_params, SL("view"), &view, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, view, "getviewsdir", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "", 1);
	
	PHALCON_INIT_VAR(relative_path);
	phalcon_fast_str_replace(relative_path, r1, c0, path TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_twig"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD_PARAMS_2(r2, t1, "render", relative_path, twig_params, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "setcontent", r2, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \view\engine\twig.c ------ */

/* ------ Starting File: \view\engine\mustache.c ------ */
/**
 * Phalcon\View\Engine\Mustache
 *
 * Adapter to use Mustache library as templating engine
 */

/**
 * Phalcon\View\Engine\Mustache constructor
 *
 * @param Phalcon_View $view
 * @param array $options
 */
PHP_METHOD(Phalcon_View_Engine_Mustache, __construct){

	zval *view = NULL, *options = NULL, *mustache = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "Mustache", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", c0);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_view_exception_ce, "Mustache class must be loaded first");
		return;
	}
	eval_int = phalcon_array_isset_string(options, SL("mustache")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(mustache);
		phalcon_array_fetch_string(&mustache, options, SL("mustache"), PH_NOISY_CC);
	} else {
		ce0 = zend_fetch_class(SL("Mustache"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		PHALCON_INIT_VAR(mustache);
		object_init_ex(mustache, ce0);
		PHALCON_CALL_METHOD_NORETURN(mustache, "__construct", PH_CHECK);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_mustache"), mustache TSRMLS_CC);
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\View\\Engine\\Mustache", "__construct", view, options);
	
	PHALCON_MM_RESTORE();
}

/**
 * Renders a view using the template engine
 *
 * @param string $path
 * @param array $params
 */
PHP_METHOD(Phalcon_View_Engine_Mustache, render){

	zval *path = NULL, *params = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &path, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_view"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_mustache"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "file_get_contents", path);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_2(r1, t1, "render", r0, this_ptr, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "setcontent", r1, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks if a view variable exists
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_View_Engine_Mustache, __isset){

	zval *property = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, property);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Returns a variable by its name
 *
 * @return string
 */
PHP_METHOD(Phalcon_View_Engine_Mustache, __get){

	zval *property = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, property);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_params"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, property, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Passes unknow calls to the internal mustache object
 *
 * @param string $method
 * @param array $arguments
 */
PHP_METHOD(Phalcon_View_Engine_Mustache, __call){

	zval *method = NULL, *arguments = NULL;
	zval *a0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_mustache"), PH_NOISY_CC);
	phalcon_array_append(&a0, t0, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a0, method, PH_SEPARATE TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "call_user_func_array", a0, arguments);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \view\engine\mustache.c ------ */

/* ------ Starting File: \paginator\exception.c ------ */
/**
 * Phalcon\Paginator\Exception
 *
 * Exceptions thrown in Phalcon_Paginator will use this class
 *
 */

/* ------ Finished File: \paginator\exception.c ------ */

/* ------ Starting File: \paginator\adapter\array.c ------ */
/**
 * Phalcon\Paginator\Adapter\Array
 *
 * Component of pagination by array data
 *
 */

/**
 * Phalcon\Paginator\Adapter\Array constructor
  *
 * @param array $config
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Array, __construct){

	zval *config = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_config"), config TSRMLS_CC);
	eval_int = phalcon_array_isset_string(config, SL("limit")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, config, SL("limit"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_limitRows"), r0 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(config, SL("page")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, config, SL("page"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_page"), r1 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the current page number
 *
 * @param int $page
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Array, setCurrentPage){

	zval *page = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &page) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a slice of the resultset to show in the pagination
 *
 * @return stdClass
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Array, getPaginate){

	zval *show = NULL, *items = NULL, *page_number = NULL, *n = NULL, *page = NULL, *start = NULL, *total_pages = NULL;
	zval *next = NULL, *before = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(show);
	phalcon_read_property(&show, this_ptr, SL("_limitRows"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_config"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(items);
	phalcon_array_fetch_string(&items, t0, SL("data"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(page_number);
	phalcon_read_property(&page_number, this_ptr, SL("_page"), PH_NOISY_CC);
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_VAR(page_number);
		ZVAL_LONG(page_number, 1);
	}
	
	PHALCON_INIT_VAR(n);
	phalcon_fast_count(n, items TSRMLS_CC);
	
	PHALCON_INIT_VAR(page);
	object_init(page);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	sub_function(r0, page_number, t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(start);
	mul_function(start, show, r0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_count(r1, items TSRMLS_CC);
	
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	sub_function(r2, r1, t2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	div_function(r3, r2, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(total_pages);
	PHALCON_CALL_FUNC_PARAMS_1(total_pages, "round", r3);
	if (Z_TYPE_P(items) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CALL_FUNC_PARAMS_3(r4, "array_slice", items, start, show);
	phalcon_update_property_zval(page, SL("items"), r4 TSRMLS_CC);
	phalcon_update_property_long(page, SL("first"), 1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	phalcon_add_function(r5, start, show TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	is_smaller_function(r6, r5, n TSRMLS_CC);
	if (zend_is_true(r6)) {
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 1);
		PHALCON_INIT_VAR(next);
		phalcon_add_function(next, page_number, t3 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r7);
		phalcon_add_function(r7, start, show TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(r8);
		is_equal_function(r8, r7, n TSRMLS_CC);
		if (zend_is_true(r8)) {
			PHALCON_CPY_WRT(next, n);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r9);
			PHALCON_ALLOC_ZVAL_MM(r10);
			div_function(r10, n, show TSRMLS_CC);
			phalcon_cast(r9, r10, IS_LONG);
			PHALCON_INIT_VAR(t4);
			ZVAL_LONG(t4, 1);
			PHALCON_INIT_VAR(next);
			phalcon_add_function(next, r9, t4 TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r11);
	is_smaller_function(r11, total_pages, next TSRMLS_CC);
	if (zend_is_true(r11)) {
		PHALCON_CPY_WRT(next, total_pages);
	}
	
	phalcon_update_property_zval(page, SL("next"), next TSRMLS_CC);
	
	PHALCON_INIT_VAR(t5);
	ZVAL_LONG(t5, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r12);
	is_smaller_function(r12, t5, page_number TSRMLS_CC);
	if (zend_is_true(r12)) {
		PHALCON_INIT_VAR(t6);
		ZVAL_LONG(t6, 1);
		PHALCON_INIT_VAR(before);
		sub_function(before, page_number, t6 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(before);
		ZVAL_LONG(before, 1);
	}
	
	phalcon_update_property_zval(page, SL("before"), before TSRMLS_CC);
	phalcon_update_property_zval(page, SL("current"), page_number TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r14);
	mod_function(r14, n, show TSRMLS_CC);
	if (zend_is_true(r14)) {
		PHALCON_ALLOC_ZVAL_MM(r15);
		
		PHALCON_ALLOC_ZVAL_MM(r16);
		div_function(r16, n, show TSRMLS_CC);
		phalcon_cast(r15, r16, IS_LONG);
		
		PHALCON_INIT_VAR(t7);
		ZVAL_LONG(t7, 1);
		
		PHALCON_ALLOC_ZVAL_MM(r17);
		phalcon_add_function(r17, r15, t7 TSRMLS_CC);
		r13 = r17;
	} else {
		
		PHALCON_ALLOC_ZVAL_MM(r18);
		div_function(r18, n, show TSRMLS_CC);
		r13 = r18;
	}
	PHALCON_CPY_WRT(total_pages, r13);
	phalcon_update_property_zval(page, SL("last"), total_pages TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_pages"), total_pages TSRMLS_CC);
	
	RETURN_CTOR(page);
}

/* ------ Finished File: \paginator\adapter\array.c ------ */

/* ------ Starting File: \paginator\adapter\model.c ------ */
/**
 * Phalcon\Paginator\Adapter\Model
 *
 * This adapter allows to paginate data using Phalcon\Model resultsets.
 *
 */

/**
 * Phalcon\Paginator\Adapter\Model constructor
 *
 * @param array $config
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Model, __construct){

	zval *config = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_config"), config TSRMLS_CC);
	eval_int = phalcon_array_isset_string(config, SL("limit")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, config, SL("limit"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_limitRows"), r0 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(config, SL("page")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, config, SL("page"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_page"), r1 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the current page number
 *
 * @param int $page
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Model, setCurrentPage){

	zval *page = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &page) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a slice of the resultset to show in the pagination
 *
 * @return stdClass
 */
PHP_METHOD(Phalcon_Paginator_Adapter_Model, getPaginate){

	zval *show = NULL, *items = NULL, *page_number = NULL, *n = NULL, *page = NULL, *start = NULL, *total_pages = NULL;
	zval *pitems = NULL, *i = NULL, *next = NULL, *before = NULL, *pages_total = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL, *r19 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(show);
	phalcon_read_property(&show, this_ptr, SL("_limitRows"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_config"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(items);
	phalcon_array_fetch_string(&items, t0, SL("data"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(page_number);
	phalcon_read_property(&page_number, this_ptr, SL("_page"), PH_NOISY_CC);
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_VAR(page_number);
		ZVAL_LONG(page_number, 1);
	}
	
	PHALCON_INIT_VAR(n);
	phalcon_fast_count(n, items TSRMLS_CC);
	
	PHALCON_INIT_VAR(page);
	object_init(page);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	sub_function(r0, page_number, t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(start);
	mul_function(start, show, r0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	sub_function(r1, n, t2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	div_function(r2, r1, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(total_pages);
	PHALCON_CALL_FUNC_PARAMS_1(total_pages, "ceil", r2);
	if (Z_TYPE_P(items) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}
	
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_VAR(page_number);
		ZVAL_LONG(page_number, 0);
	}
	
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_smaller_function(r3, start, t3 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "The start page number is zero or less");
		return;
	}
	
	PHALCON_INIT_VAR(pitems);
	array_init(pitems);
	
	PHALCON_INIT_VAR(t4);
	ZVAL_LONG(t4, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_smaller_function(r4, t4, n TSRMLS_CC);
	if (zend_is_true(r4)) {
		PHALCON_ALLOC_ZVAL_MM(r5);
		is_smaller_or_equal_function(r5, start, n TSRMLS_CC);
		if (zend_is_true(r5)) {
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(items, "seek", start, PH_NO_CHECK);
		} else {
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(items, "seek", c0, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(page_number);
			ZVAL_LONG(page_number, 1);
		}
		
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 1);
		ws_e435_0:
			
			PHALCON_INIT_VAR(r6);
			PHALCON_CALL_METHOD(r6, items, "valid", PH_NO_CHECK);
			if (Z_TYPE_P(r6) != IS_BOOL || (Z_TYPE_P(r6) == IS_BOOL && !Z_BVAL_P(r6))) {
				goto we_e435_0;
			}
			PHALCON_INIT_VAR(r7);
			PHALCON_CALL_METHOD(r7, items, "current", PH_NO_CHECK);
			phalcon_array_append(&pitems, r7, PH_SEPARATE TSRMLS_CC);
			
			PHALCON_INIT_VAR(r8);
			is_smaller_or_equal_function(r8, show, i TSRMLS_CC);
			if (zend_is_true(r8)) {
				goto we_e435_0;
			}
			
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto ws_e435_0;
		we_e435_0:
		if(0){}
	}
	
	phalcon_update_property_zval(page, SL("items"), pitems TSRMLS_CC);
	phalcon_update_property_long(page, SL("first"), 1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r9);
	phalcon_add_function(r9, start, show TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r10);
	is_smaller_function(r10, r9, n TSRMLS_CC);
	if (zend_is_true(r10)) {
		PHALCON_INIT_VAR(t5);
		ZVAL_LONG(t5, 1);
		PHALCON_INIT_VAR(next);
		phalcon_add_function(next, page_number, t5 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r11);
		phalcon_add_function(r11, start, show TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(r12);
		is_equal_function(r12, r11, n TSRMLS_CC);
		if (zend_is_true(r12)) {
			PHALCON_CPY_WRT(next, n);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r13);
			div_function(r13, n, show TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r14);
			PHALCON_CALL_FUNC_PARAMS_1(r14, "intval", r13);
			PHALCON_INIT_VAR(t6);
			ZVAL_LONG(t6, 1);
			PHALCON_INIT_VAR(next);
			phalcon_add_function(next, r14, t6 TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r15);
	is_smaller_function(r15, total_pages, next TSRMLS_CC);
	if (zend_is_true(r15)) {
		PHALCON_CPY_WRT(next, total_pages);
	}
	
	phalcon_update_property_zval(page, SL("next"), next TSRMLS_CC);
	
	PHALCON_INIT_VAR(t7);
	ZVAL_LONG(t7, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r16);
	is_smaller_function(r16, t7, page_number TSRMLS_CC);
	if (zend_is_true(r16)) {
		PHALCON_INIT_VAR(t8);
		ZVAL_LONG(t8, 1);
		PHALCON_INIT_VAR(before);
		sub_function(before, page_number, t8 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(before);
		ZVAL_LONG(before, 1);
	}
	
	phalcon_update_property_zval(page, SL("before"), before TSRMLS_CC);
	phalcon_update_property_zval(page, SL("current"), page_number TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r17);
	mod_function(r17, n, show TSRMLS_CC);
	if (zend_is_true(r17)) {
		PHALCON_ALLOC_ZVAL_MM(r18);
		div_function(r18, n, show TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(r19);
		PHALCON_CALL_FUNC_PARAMS_1(r19, "intval", r18);
		PHALCON_INIT_VAR(t9);
		ZVAL_LONG(t9, 1);
		PHALCON_INIT_VAR(pages_total);
		phalcon_add_function(pages_total, r19, t9 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(pages_total);
		div_function(pages_total, n, show TSRMLS_CC);
	}
	
	phalcon_update_property_zval(page, SL("last"), pages_total TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_pages"), pages_total TSRMLS_CC);
	
	RETURN_CTOR(page);
}

/* ------ Finished File: \paginator\adapter\model.c ------ */

/* ------ Starting File: \tag\exception.c ------ */
/**
 * Phalcon\Tag\Exception
 *
 * Exceptions thrown in Phalcon\Tag will use this class
 *
 */

/* ------ Finished File: \tag\exception.c ------ */

/* ------ Starting File: \tag\select.c ------ */
/**
 * Phalcon\Tag\Select
 *
 * Generates a SELECT html tag using an static array of values or a Phalcon\Model resultset
 */

/**
 * Generates a SELECT tag 
 *
 * @param array $parameters
 * @param array $data
 */
PHP_METHOD(Phalcon_Tag_Select, selectField){

	zval *parameters = NULL, *data = NULL, *params = NULL, *eol = NULL, *id = NULL, *value = NULL, *dummy_value = NULL;
	zval *dummy_text = NULL, *code = NULL, *avalue = NULL, *key = NULL, *close_option = NULL;
	zval *options = NULL, *using = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_ALLOC_ZVAL_MM(data);
		ZVAL_NULL(data);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, data, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	
	PHALCON_INIT_VAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SL("value")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(value);
		PHALCON_CALL_STATIC_PARAMS_1(value, "phalcon\\tag", "getvalue", id);
	} else {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch_string(&value, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("value")+1);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("dummyValue")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(dummy_value);
		ZVAL_STRING(dummy_value, "", 1);
	} else {
		PHALCON_INIT_VAR(dummy_value);
		phalcon_array_fetch_string(&dummy_value, params, SL("dummyValue"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("dummyValue")+1);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("dummyText")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(dummy_text);
		ZVAL_STRING(dummy_text, "Choose...", 1);
	} else {
		PHALCON_INIT_VAR(dummy_text);
		phalcon_array_fetch_string(&dummy_text, params, SL("dummyText"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("dummyText")+1);
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVSVS(code, "<select id=\"", id, "\" name=\"", id, "\"");
	if (Z_TYPE_P(params) == IS_ARRAY) { 
		if (phalcon_valid_foreach(params TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(params);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_9c31_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_9c31_0;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(avalue);
			ZVAL_ZVAL(avalue, *hd, 1, 0);
			if (Z_TYPE_P(key) != IS_LONG) {
				if (Z_TYPE_P(avalue) != IS_ARRAY) { 
					PHALCON_INIT_VAR(r0);
					PHALCON_CONCAT_SVSVS(r0, " ", key, "=\"", avalue, "\"");
					phalcon_concat_self(&code, r0 TSRMLS_CC);
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_9c31_0;
			fee_9c31_0:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CONCAT_SV(r1, ">", eol);
	phalcon_concat_self(&code, r1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(close_option);
	PHALCON_CONCAT_SV(close_option, "</option>", eol);
	eval_int = phalcon_array_isset_string(params, SL("useDummy")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SVSVV(r2, "\t<option value=\"", dummy_value, "\">", dummy_text, close_option);
		phalcon_concat_self(&code, r2 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_VAR(options);
		phalcon_array_fetch_long(&options, params, 1, PH_NOISY_CC);
	} else {
		PHALCON_CPY_WRT(options, data);
	}
	
	if (Z_TYPE_P(options) == IS_OBJECT) {
		eval_int = phalcon_array_isset_string(params, SL("using")+1);
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter is required");
			return;
		} else {
			PHALCON_INIT_VAR(using);
			phalcon_array_fetch_string(&using, params, SL("using"), PH_NOISY_CC);
			if (Z_TYPE_P(using) != IS_ARRAY) { 
				PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter should be an Array");
				return;
			}
		}
		p0[0] = options;
		p0[1] = using;
		p0[2] = value;
		p0[3] = close_option;
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_SELF_PARAMS(r3, this_ptr, "_optionsfromresultset", 4, p0);
		phalcon_concat_self(&code, r3 TSRMLS_CC);
	} else {
		if (Z_TYPE_P(options) == IS_ARRAY) { 
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_SELF_PARAMS_3(r4, this_ptr, "_optionsfromarray", options, value, close_option);
			phalcon_concat_self(&code, r4 TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Invalid data provided to SELECT helper");
			return;
		}
	}
	
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "</select>", 1);
	phalcon_concat_self(&code, t0 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag_Select, _optionsFromResultset){

	zval *resultset = NULL, *using = NULL, *value = NULL, *close_option = NULL;
	zval *code = NULL, *option = NULL, *option_value = NULL, *option_text = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &resultset, &using, &value, &close_option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "", 1);
	PHALCON_CALL_METHOD_NORETURN(resultset, "rewind", PH_NO_CHECK);
	ws_9c31_1:
		
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, resultset, "valid", PH_NO_CHECK);
		if (Z_TYPE_P(r0) != IS_BOOL || (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0))) {
			goto we_9c31_1;
		}
		PHALCON_INIT_VAR(option);
		PHALCON_CALL_METHOD(option, resultset, "current", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch_long(&r1, using, 0, PH_NOISY_CC);
		
		PHALCON_INIT_VAR(option_value);
		PHALCON_CALL_METHOD_PARAMS_1(option_value, option, "readattribute", r1, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r2);
		phalcon_array_fetch_long(&r2, using, 1, PH_NOISY_CC);
		
		PHALCON_INIT_VAR(option_text);
		PHALCON_CALL_METHOD_PARAMS_1(option_text, option, "readattribute", r2, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r3);
		is_equal_function(r3, value, option_value TSRMLS_CC);
		if (zend_is_true(r3)) {
			PHALCON_INIT_VAR(r4);
			PHALCON_CONCAT_SVSVV(r4, "\t<option selected=\"selected\" value=\"", option_value, "\">", option_text, close_option);
			phalcon_concat_self(&code, r4 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(r5);
			PHALCON_CONCAT_SVSVV(r5, "\t<option value=\"", option_value, "\">", option_text, close_option);
			phalcon_concat_self(&code, r5 TSRMLS_CC);
		}
		
		PHALCON_CALL_METHOD_NORETURN(resultset, "next", PH_NO_CHECK);
		goto ws_9c31_1;
	we_9c31_1:
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag_Select, _optionsFromArray){

	zval *data = NULL, *value = NULL, *close_option = NULL, *code = NULL, *option_text = NULL;
	zval *option_value = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &data, &value, &close_option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "", 1);
	if (phalcon_valid_foreach(data TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(data);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9c31_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9c31_2;
		} else {
			PHALCON_INIT_VAR(option_value);
			PHALCON_GET_FOREACH_KEY(option_value, ah0, hp0);
		}
		PHALCON_INIT_VAR(option_text);
		ZVAL_ZVAL(option_text, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		is_equal_function(r0, option_value, value TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(r1);
			PHALCON_CONCAT_SVSVV(r1, "\t<option selected=\"selected\" value=\"", option_value, "\">", option_text, close_option);
			phalcon_concat_self(&code, r1 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(r2);
			PHALCON_CONCAT_SVSVV(r2, "\t<option value=\"", option_value, "\">", option_text, close_option);
			phalcon_concat_self(&code, r2 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9c31_2;
		fee_9c31_2:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(code);
}

/* ------ Finished File: \tag\select.c ------ */

/* ------ Starting File: \controller.c ------ */
/**
 * Phalcon\Controller
 *
 * Every application controller should extend this class that encapsulates all the controller functionality
 *
 * The controllers provide the flow between models and views. Controllers are responsible
 * for processing the incoming requests from the web browser, interrogating the models for data,
 * and passing that data on to the views for presentation.
 *
 *
 */

/**
 * Constructor for Phalcon_Controller
 *
 * @param Phalcon_Dispatcher $dispatcher
 * @param Phalcon_Request $request
 * @param Phalcon_Response $response
 * @param Phalcon_View $view
 * @param Phalcon_Model_Manager $model
 */
PHP_METHOD(Phalcon_Controller, __construct){

	zval *dispatcher = NULL, *request = NULL, *response = NULL, *view = NULL, *model = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|zz", &dispatcher, &request, &response, &view, &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!view) {
		PHALCON_ALLOC_ZVAL_MM(view);
		ZVAL_NULL(view);
	}
	
	if (!model) {
		PHALCON_ALLOC_ZVAL_MM(model);
		ZVAL_NULL(model);
	}
	
	phalcon_update_property_zval(this_ptr, SL("dispatcher"), dispatcher TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("request"), request TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("response"), response TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("view"), view TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("model"), model TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Forwards execution flow to another controller/action.
 *
 * @param string $uri
 */
PHP_METHOD(Phalcon_Controller, _forward){

	zval *uri = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("dispatcher"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, t0, "forward", uri, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Returns a param from the dispatching params
 *
 * @param mixed $index
 */
PHP_METHOD(Phalcon_Controller, _getParam){

	zval *index = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("dispatcher"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, t0, "getparam", index, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Set a dispatching parameter
 *
 * @param mixed $index
 * @param mixed $value
 */
PHP_METHOD(Phalcon_Controller, _setParam){

	zval *index = NULL, *value = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("dispatcher"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, t0, "setparam", index, value, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Magic method __get
 *
 * @param string $propertyName
 */
PHP_METHOD(Phalcon_Controller, __get){

	zval *property_name = NULL, *model = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *i0 = NULL, *i1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (PHALCON_COMPARE_STRING(property_name, "view")) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, this_ptr, "_getviewcomponent", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("view"), r0 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("view"), PH_NOISY_CC);
		
		RETURN_CCTOR(t0);
	}
	if (PHALCON_COMPARE_STRING(property_name, "filter")) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_filter_ce);
		phalcon_update_property_zval(this_ptr, SL("filter"), i0 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("filter"), PH_NOISY_CC);
		
		RETURN_CCTOR(t1);
	}
	
	if (PHALCON_COMPARE_STRING(property_name, "session")) {
		PHALCON_ALLOC_ZVAL_MM(i1);
		object_init_ex(i1, phalcon_session_namespace_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_get_class(r1, this_ptr TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", r1, PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("session"), i1 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("session"), PH_NOISY_CC);
		
		RETURN_CCTOR(t2);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("model"), PH_NOISY_CC);
	if (zend_is_true(t3)) {
		PHALCON_INIT_VAR(model);
		phalcon_read_property(&model, this_ptr, SL("model"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_METHOD_PARAMS_1(r2, model, "ismodel", property_name, PH_NO_CHECK);
		if (zend_is_true(r2)) {
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_METHOD_PARAMS_1(r3, model, "getmodel", property_name, PH_NO_CHECK);
			RETURN_CTOR(r3);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CONCAT_SV(r4, "Access to undefined property ", property_name);
	PHALCON_CALL_FUNC_PARAMS_1_NORETURN("trigger_error", r4);
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/* ------ Finished File: \controller.c ------ */

/* ------ Starting File: \request\exception.c ------ */
/**
 * Phalcon\Request\Exception
 *
 * Exceptions thrown in Phalcon_Request will use this class
 *
 */

/* ------ Finished File: \request\exception.c ------ */

/* ------ Starting File: \request\file.c ------ */
/**
 * Phalcon\Request\File
 *
 * Provides OO wrappers to the $_FILES superglobal
 *
 *
 */

/**
 * Phalcon\Request\File constructor
 *
 * @param array $file
 */
PHP_METHOD(Phalcon_Request_File, __construct){

	zval *file = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &file) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(file) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_request_exception_ce, "Phalcon_Request_File requires a valid uploaded file");
		return;
	}
	eval_int = phalcon_array_isset_string(file, SL("name")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, file, SL("name"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_name"), r0 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(file, SL("tmp_name")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, file, SL("tmp_name"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_tmp"), r1 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(file, SL("size")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, file, SL("size"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_size"), r2 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the file size of the uploaded file
 *
 * @return int
 */
PHP_METHOD(Phalcon_Request_File, getSize){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_size"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the real name of the uploaded file
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request_File, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_name"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the temporal name of the uploaded file
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request_File, getTempName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_tmp"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Move the temporary file to a destination
 *
 * @param string $destination
 */
PHP_METHOD(Phalcon_Request_File, moveTo){

	zval *destination = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &destination) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_tmp"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "move_uploaded_file", t0, destination);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \request\file.c ------ */

/* ------ Starting File: \paginator.c ------ */
/**
 * Phalcon\Paginator
 *
 * Phalcon\Paginator is designed to simplify building of pagination on views
 *
 * 
 *
 */

/**
 * Factories a paginator adapter
 *
 * @param   string $adapterName
 * @param   array $options
 * @return  Object
 */
PHP_METHOD(Phalcon_Paginator, factory){

	zval *adapter_name = NULL, *options = NULL, *class_name = NULL, *adapter = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &adapter_name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CONCAT_SV(class_name, "Phalcon\\Paginator\\Adapter\\", adapter_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", class_name);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_paginator_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "The paginator adapter file \"", adapter_name, "\" does not exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(adapter);
	object_init_ex(adapter, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(adapter, "__construct", options, PH_CHECK);
	
	RETURN_CTOR(adapter);
}

/* ------ Finished File: \paginator.c ------ */

/* ------ Starting File: \utils.c ------ */
/**
 * Phalcon\Utils
 *
 * Implements functionality used widely by the framework
 */

/**
 * Gets public URL to phalcon instance
 *
 * @param string $uri
 * @return string
 */
PHP_METHOD(Phalcon_Utils, getUrl){

	zval *uri = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!uri) {
		PHALCON_ALLOC_ZVAL_MM(uri);
		ZVAL_NULL(uri);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC(r0, "phalcon\\controller\\front", "getinstance");
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, r0, "getbaseuri", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_VV(r2, r1, uri);
	
	RETURN_CTOR(r2);
}

/**
 * Gets path to local file
 *
 * @param string $extraPath
 * @return string
 */
PHP_METHOD(Phalcon_Utils, getLocalPath){

	zval *extra_path = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &extra_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!extra_path) {
		PHALCON_ALLOC_ZVAL_MM(extra_path);
		ZVAL_NULL(extra_path);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC(r0, "phalcon\\controller\\front", "getinstance");
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, r0, "getbasepath", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_VV(r2, r1, extra_path);
	
	RETURN_CTOR(r2);
}

/* ------ Finished File: \utils.c ------ */

/* ------ Starting File: \response\exception.c ------ */
/**
 * Phalcon\Response\Exception
 *
 * Exceptions thrown in Phalcon\Response will use this class
 *
 */

/* ------ Finished File: \response\exception.c ------ */

/* ------ Starting File: \response\headers.c ------ */
/**
 * Phalcon\Response\Headers
 *
 * This class is a bag to manage the response headers
 * 
 */

PHP_METHOD(Phalcon_Response_Headers, __construct){

	zval *a0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_response_headers_ce, this_ptr, SL("_headers"), a0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Sets a header to be sent at the end of the request
 *
 * @param string $name
 * @param string $value
 */
PHP_METHOD(Phalcon_Response_Headers, set){

	zval *name = NULL, *value = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_headers"), PH_NOISY_CC);
	phalcon_array_update(&t0, name, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_headers"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets a header value from the internal bag
 *
 * @param string $name
 * @return string
 */
PHP_METHOD(Phalcon_Response_Headers, get){

	zval *name = NULL, *headers = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(headers, name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, headers, name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Sets a raw header to be sent at the end of the request
 *
 * @param string $header
 */
PHP_METHOD(Phalcon_Response_Headers, setRaw){

	zval *header = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	ZVAL_BOOL(t0, 0);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_headers"), PH_NOISY_CC);
	phalcon_array_update(&t1, header, &t0, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_headers"), t1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sends the headers to the client
 */
PHP_METHOD(Phalcon_Response_Headers, send){

	zval *t = NULL, *value = NULL, *header = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC(r0, "headers_sent");
	if (!zend_is_true(r0)) {
		PHALCON_INIT_VAR(t);
		ZVAL_BOOL(t, 1);
		
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_headers"), PH_NOISY_CC);
		if (phalcon_valid_foreach(t0 TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(t0);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_ae51_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_ae51_0;
			} else {
				PHALCON_INIT_VAR(header);
				PHALCON_GET_FOREACH_KEY(header, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			if (zend_is_true(value)) {
				PHALCON_INIT_VAR(r1);
				PHALCON_CONCAT_VSV(r1, header, ": ", value);
				PHALCON_CALL_FUNC_PARAMS_2_NORETURN("header", r1, t);
			} else {
				PHALCON_CALL_FUNC_PARAMS_2_NORETURN("header", header, t);
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_ae51_0;
			fee_ae51_0:
			if(0){}
		} else {
			return;
		}
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/* ------ Finished File: \response\headers.c ------ */

/* ------ Starting File: \dispatcher.c ------ */
/**
 * Phalcon\Dispatcher
 *
 * Dispatching is the process of taking the request object, extracting the module name,
 * controller name, action name, and optional parameters contained in it, and then
 * instantiating a controller and calling an action of that controller.
 *
 * 
 */

PHP_METHOD(Phalcon_Dispatcher, __construct){

	zval *a0 = NULL, *a1 = NULL;

	PHALCON_MM_GROW();

	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_dispatcher_ce, this_ptr, SL("_controllers"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_dispatcher_ce, this_ptr, SL("_params"), a1 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Sets default controllers directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $controllersDir
 */
PHP_METHOD(Phalcon_Dispatcher, setControllersDir){

	zval *controllers_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controllers_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_controllersDir"), controllers_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets active controllers directory
 *
 * @return string
 */
PHP_METHOD(Phalcon_Dispatcher, getControllersDir){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controllersDir"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets base path for controllers dir. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $basePath
 */
PHP_METHOD(Phalcon_Dispatcher, setBasePath){

	zval *base_path = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets base path for controllers dir
 *
 * @return string
 */
PHP_METHOD(Phalcon_Dispatcher, getBasePath){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets the default controller name
 *
 * @param string $controllerName
 */
PHP_METHOD(Phalcon_Dispatcher, setDefaultController){

	zval *controller_name = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultController"), controller_name TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets the default action name
 *
 * @param string $actionName
 */
PHP_METHOD(Phalcon_Dispatcher, setDefaultAction){

	zval *action_name = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAction"), action_name TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets the controller name to be dispatched
 *
 * @param string $controllerName
 */
PHP_METHOD(Phalcon_Dispatcher, setControllerName){

	zval *controller_name = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_controllerName"), controller_name TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets last dispatched controller name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Dispatcher, getControllerName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controllerName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets the action name to be dispatched
 *
 * @param string $actionName
 */
PHP_METHOD(Phalcon_Dispatcher, setActionName){

	zval *action_name = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets last dispatched action name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Dispatcher, getActionName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_actionName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets action params to be dispatched
 *
 * @param array $params
 */
PHP_METHOD(Phalcon_Dispatcher, setParams){

	zval *params = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets action params
 *
 * @return array
 */
PHP_METHOD(Phalcon_Dispatcher, getParams){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Set a param by its name or numeric index
 *
 * @param  mixed $param
 * @param  mixed $value 
 */
PHP_METHOD(Phalcon_Dispatcher, setParam){

	zval *param = NULL, *value = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &param, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update(&t0, param, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets a param by its name or numeric index
 *
 * @param  mixed $param
 * @return mixed
 */
PHP_METHOD(Phalcon_Dispatcher, getParam){

	zval *param = NULL, *params = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &param) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(params, param);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, params, param, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Dispatches a controller action taking into account the routing parameters
 *
 * @param Phalcon_Request $request
 * @param Phalcon_Response $response
 * @param Phalcon_View $view
 * @param Phalcon_Model_Manager $model
 * @return Phalcon_Controller
 */
PHP_METHOD(Phalcon_Dispatcher, dispatch){

	zval *request = NULL, *response = NULL, *view = NULL, *model = NULL, *controllers_dir = NULL;
	zval *value = NULL, *controller = NULL, *number_dispatches = NULL;
	zval *controller_name = NULL, *controllers = NULL, *controller_class = NULL;
	zval *controller_path = NULL, *params = NULL, *action_name = NULL;
	zval *action_method = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &request, &response, &view, &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!view) {
		PHALCON_ALLOC_ZVAL_MM(view);
		ZVAL_NULL(view);
	}
	
	if (!model) {
		PHALCON_ALLOC_ZVAL_MM(model);
		ZVAL_NULL(model);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_basePath"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_controllersDir"), PH_NOISY_CC);
	PHALCON_INIT_VAR(controllers_dir);
	PHALCON_CONCAT_VV(controllers_dir, t0, t1);
	
	PHALCON_INIT_VAR(value);
	ZVAL_NULL(value);
	
	PHALCON_INIT_VAR(controller);
	ZVAL_NULL(controller);
	
	PHALCON_INIT_VAR(number_dispatches);
	ZVAL_LONG(number_dispatches, 0);
	phalcon_update_property_bool(this_ptr, SL("_finished"), 0 TSRMLS_CC);
	ws_e10f_0:
		
		PHALCON_INIT_VAR(t2);
		phalcon_read_property(&t2, this_ptr, SL("_finished"), PH_NOISY_CC);
		if (zend_is_true(t2)) {
			goto we_e10f_0;
		}
		phalcon_update_property_bool(this_ptr, SL("_finished"), 1 TSRMLS_CC);
		
		PHALCON_INIT_VAR(controller_name);
		phalcon_read_property(&controller_name, this_ptr, SL("_controllerName"), PH_NOISY_CC);
		if (!zend_is_true(controller_name)) {
			PHALCON_INIT_VAR(controller_name);
			phalcon_read_property(&controller_name, this_ptr, SL("_defaultController"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_controllerName"), controller_name TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(controllers);
		phalcon_read_property(&controllers, this_ptr, SL("_controllers"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\text", "camelize", controller_name);
		
		PHALCON_INIT_VAR(controller_class);
		PHALCON_CONCAT_VS(controller_class, r0, "Controller");
		eval_int = phalcon_array_isset(controllers, controller_class);
		if (!eval_int) {
			PHALCON_INIT_VAR(c0);
			ZVAL_BOOL(c0, 0);
			PHALCON_INIT_VAR(r1);
			PHALCON_CALL_FUNC_PARAMS_2(r1, "class_exists", controller_class, c0);
			if (!zend_is_true(r1)) {
				PHALCON_INIT_VAR(controller_path);
				PHALCON_CONCAT_VVS(controller_path, controllers_dir, controller_class, ".php");
				if (phalcon_file_exists(controller_path TSRMLS_CC) == SUCCESS) {
					if (phalcon_require(controller_path TSRMLS_CC) == FAILURE) {
						return;
					}
				} else {
					PHALCON_INIT_VAR(r2);
					PHALCON_CONCAT_SVS(r2, "File for controller class ", controller_class, " doesn't exist");
					PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", response, r2, PH_NO_CHECK);
				}
				
				PHALCON_INIT_VAR(c1);
				ZVAL_BOOL(c1, 0);
				
				PHALCON_INIT_VAR(r3);
				PHALCON_CALL_FUNC_PARAMS_2(r3, "class_exists", controller_class, c1);
				if (!zend_is_true(r3)) {
					PHALCON_INIT_VAR(r4);
					PHALCON_CONCAT_SVS(r4, "Class ", controller_class, " was not found on controller file");
					PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", response, r4, PH_NO_CHECK);
				}
			}
			ce0 = phalcon_fetch_class(controller_class TSRMLS_CC);
			
			PHALCON_INIT_VAR(controller);
			object_init_ex(controller, ce0);
			p0[0] = this_ptr;
			p0[1] = request;
			p0[2] = response;
			p0[3] = view;
			p0[4] = model;
			PHALCON_CALL_METHOD_PARAMS_NORETURN(controller, "__construct", 5, p0, PH_CHECK);
			if (phalcon_method_exists_ex(controller, SL("initialize") TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD_NORETURN(controller, "initialize", PH_NO_CHECK);
			}
			
			PHALCON_INIT_VAR(t3);
			phalcon_read_property(&t3, this_ptr, SL("_controllers"), PH_NOISY_CC);
			phalcon_array_update(&t3, controller_class, &controller, PH_COPY TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_controllers"), t3 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(controller);
			phalcon_array_fetch(&controller, controllers, controller_class, PH_NOISY_CC);
		}
		
		PHALCON_INIT_VAR(params);
		phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(action_name);
		phalcon_read_property(&action_name, this_ptr, SL("_actionName"), PH_NOISY_CC);
		if (!zend_is_true(action_name)) {
			PHALCON_INIT_VAR(action_name);
			phalcon_read_property(&action_name, this_ptr, SL("_defaultAction"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
		}
		
		if (phalcon_method_exists_ex(controller, SL("beforedispatch") TSRMLS_CC) == SUCCESS) {
			PHALCON_INIT_VAR(r5);
			PHALCON_CALL_METHOD_PARAMS_3(r5, controller, "beforedispatch", controller_name, action_name, params, PH_NO_CHECK);
			if (Z_TYPE_P(r5) == IS_BOOL && !Z_BVAL_P(r5)) {
				PHALCON_INIT_VAR(value);
				ZVAL_BOOL(value, 0);
				goto we_e10f_0;
			}
		}
		
		PHALCON_INIT_VAR(action_method);
		PHALCON_CONCAT_VS(action_method, action_name, "Action");
		if (phalcon_method_exists(controller, action_method TSRMLS_CC) == SUCCESS) {
			PHALCON_INIT_VAR(a0);
			array_init(a0);
			phalcon_array_append(&a0, controller, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&a0, action_method, PH_SEPARATE TSRMLS_CC);
			PHALCON_INIT_VAR(value);
			PHALCON_CALL_FUNC_PARAMS_2(value, "call_user_func_array", a0, params);
		} else {
			if (phalcon_method_exists_ex(controller, SL("notfoundaction") TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_VAR(a1);
				array_init(a1);
				phalcon_array_append(&a1, controller, PH_SEPARATE TSRMLS_CC);
				add_next_index_stringl(a1, SL("notFoundAction"), 1);
				PHALCON_INIT_VAR(value);
				PHALCON_CALL_FUNC_PARAMS_2(value, "call_user_func_array", a1, params);
			} else {
				PHALCON_INIT_VAR(r6);
				PHALCON_CONCAT_SVSVS(r6, "Action '", action_name, "' was not found on controller '", controller_name, "'");
				PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", response, r6, PH_NO_CHECK);
			}
		}
		
		if (phalcon_method_exists_ex(controller, SL("afterdispatch") TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(controller, "afterdispatch", controller_name, action_name, params, PH_NO_CHECK);
		}
		
		PHALCON_SEPARATE(number_dispatches);
		increment_function(number_dispatches);
		
		PHALCON_INIT_VAR(t4);
		ZVAL_LONG(t4, 256);
		
		PHALCON_INIT_VAR(r7);
		is_smaller_function(r7, t4, number_dispatches TSRMLS_CC);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "Dispatcher has detected a cyclic routing causing stability problems", 1);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", response, c2, PH_NO_CHECK);
		}
		goto ws_e10f_0;
	we_e10f_0:
	phalcon_update_property_zval(this_ptr, SL("_returnedValue"), value TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_lastController"), controller TSRMLS_CC);
	
	RETURN_CCTOR(controller);
}

/**
 * Throws an internal exception
 *
 * @param Phalcon_Response $response
 * @param string $message
 */
PHP_METHOD(Phalcon_Dispatcher, _throwDispatchException){

	zval *response = NULL, *message = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &response, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 404);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "Not Found", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(response, "setstatuscode", c0, c1, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_dispatcher_exception_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", message, PH_CHECK);
	phalcon_throw_exception(i0 TSRMLS_CC);
	return;
}

/**
 * Routes to a controller/action using a string or array uri
 *
 * @param string $uri
 */
PHP_METHOD(Phalcon_Dispatcher, forward){

	zval *uri = NULL, *parts = NULL, *params = NULL, *value = NULL, *key = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(uri) == IS_ARRAY) { 
		PHALCON_CPY_WRT(parts, uri);
	} else {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "/", 1);
		PHALCON_INIT_VAR(parts);
		phalcon_fast_explode(parts, c0, uri TSRMLS_CC);
	}
	eval_int = phalcon_array_isset_long(parts, 0);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_long(&r0, parts, 0, PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_filter_alphanum(r1, r0);
		phalcon_update_property_zval(this_ptr, SL("_controllerName"), r1 TSRMLS_CC);
		PHALCON_SEPARATE(parts);
		phalcon_array_unset_long(parts, 0);
	} else {
		eval_int = phalcon_array_isset_string(parts, SL("controller")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_string(&r2, parts, SL("controller"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_filter_alphanum(r3, r2);
			phalcon_update_property_zval(this_ptr, SL("_controllerName"), r3 TSRMLS_CC);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_METHOD(r4, this_ptr, "getcontrollername", PH_NO_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_controllerName"), r4 TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_long(parts, 1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r5);
		phalcon_array_fetch_long(&r5, parts, 1, PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_filter_alphanum(r6, r5);
		phalcon_update_property_zval(this_ptr, SL("_actionName"), r6 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		phalcon_array_fetch_long(&r7, parts, 1, PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_actionName"), r7 TSRMLS_CC);
		PHALCON_SEPARATE(parts);
		phalcon_array_unset_long(parts, 1);
	} else {
		eval_int = phalcon_array_isset_string(parts, SL("action")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r8);
			phalcon_array_fetch_string(&r8, parts, SL("action"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r9);
			phalcon_filter_alphanum(r9, r8);
			phalcon_update_property_zval(this_ptr, SL("_actionName"), r9 TSRMLS_CC);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r10);
			PHALCON_CALL_METHOD(r10, this_ptr, "getactionname", PH_NO_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_actionName"), r10 TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(params);
	array_init(params);
	if (phalcon_valid_foreach(parts TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(parts);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_e10f_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_e10f_1;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(key) == IS_LONG) {
			PHALCON_INIT_VAR(r11);
			phalcon_array_fetch(&r11, parts, key, PH_NOISY_CC);
			phalcon_array_append(&params, r11, PH_SEPARATE TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_e10f_1;
		fee_e10f_1:
		if(0){}
	} else {
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_finished"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks if the dispatch loop is finished or have more pendent controller to disptach
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Dispatcher, isFinished){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_finished"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns all instantiated controllers whitin the dispatcher
 *
 * @return array
 */
PHP_METHOD(Phalcon_Dispatcher, getControllers){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_controllers"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the lastest dispatched controller
 *
 * @return Phalcon_Controller
 */
PHP_METHOD(Phalcon_Dispatcher, getLastController){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_lastController"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns value returned by the lastest dispatched action
 *
 * @return mixed
 */
PHP_METHOD(Phalcon_Dispatcher, getReturnedValue){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_returnedValue"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \dispatcher.c ------ */

/* ------ Starting File: \translate.c ------ */
/**
 * Phalcon\Translate
 *
 * Translate component allows the creation of multi-language applications using
 * different adapters for translation lists.
 */

/**
 * Phalcon\Translate constructor
 *
 * @param string $adapter
 * @param array $options
 */
PHP_METHOD(Phalcon_Translate, __construct){

	zval *adapter = NULL, *options = NULL, *adapter_class = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL, *i1 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &adapter, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(adapter_class);
	PHALCON_CONCAT_SV(adapter_class, "Phalcon\\Translate\\Adapter\\", adapter);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", adapter_class);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_translate_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Translate adapter \"", adapter_class, "\" does not exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	ce0 = phalcon_fetch_class(adapter_class TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", options, PH_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_adapter"), i1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the translation string of the given key
 *
 * @param string $translateKey
 * @param array $placeholders
 * @return string
 */
PHP_METHOD(Phalcon_Translate, _){

	zval *translate_key = NULL, *placeholders = NULL;
	zval *a0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &translate_key, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(placeholders, a0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, t0, "query", translate_key, placeholders, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Sets a translation value
 *
 * @param string $offset
 * @param string $value
 */
PHP_METHOD(Phalcon_Translate, offsetSet){

	zval *offset = NULL, *value = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &offset, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translate is an immutable ArrayAccess object");
	return;
}

/**
 * Check whether a translation key exists
 *
 * @param string $translateKey
 * @return boolean
 */
PHP_METHOD(Phalcon_Translate, offsetExists){

	zval *translate_key = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &translate_key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, t0, "exists", translate_key, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Elimina un indice del diccionario
 *
 * @param string $offset
 */
PHP_METHOD(Phalcon_Translate, offsetUnset){

	zval *offset = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translate is an immutable ArrayAccess object");
	return;
}

/**
 * Returns the translation related to the given key
 *
 * @param string $traslateKey
 * @return string
 */
PHP_METHOD(Phalcon_Translate, offsetGet){

	zval *traslate_key = NULL;
	zval *t0 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &traslate_key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	PHALCON_INIT_VAR(c0);
	ZVAL_NULL(c0);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, t0, "query", traslate_key, c0, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \translate.c ------ */

/* ------ Starting File: \db\pool.c ------ */
/**
 * Phalcon\Db\Pool
 *
 * Manages the caching of database connections. With the help of Phalcon\Db\Pool, developers can be
 * sure that no new database connections will make when calling multiple of times Phalcon\Db\Pool::getConnection().
 *
 *
 */

/**
 * Check if a default descriptor has already defined
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Pool, hasDefaultDescriptor){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\db\\pool"), SL("_defaultDescriptor") TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_NULL(t1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_not_identical_function(r0, t1, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r0);
}

/**
 * Sets the default descriptor for database connections.
 *
 * @param array $options
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Pool, setDefaultDescriptor){

	zval *options = NULL, *descriptor = NULL, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(options) != IS_ARRAY) { 
		if (Z_TYPE_P(options) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The parameter 'options' must be an Array or Object");
			return;
		}
	}
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_INIT_VAR(descriptor);
		object_init(descriptor);
		if (phalcon_valid_foreach(options TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(options);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_162f_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_162f_0;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			phalcon_update_property_zval_zval(descriptor, key, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_162f_0;
			fee_162f_0:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_CPY_WRT(descriptor, options);
	}
	
	phalcon_update_static_property(SL("phalcon\\db\\pool"), SL("_defaultDescriptor"), descriptor TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns a connection builded with the default descriptor parameters
 *
 * @param boolean $newConnection
 * @param boolean $renovate
 * @return Phalcon\Db
 */
PHP_METHOD(Phalcon_Db_Pool, getConnection){

	zval *new_connection = NULL, *renovate = NULL, *database = NULL, *connection = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &new_connection, &renovate) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!new_connection) {
		PHALCON_ALLOC_ZVAL_MM(new_connection);
		ZVAL_BOOL(new_connection, 0);
	}
	
	if (!renovate) {
		PHALCON_ALLOC_ZVAL_MM(renovate);
		ZVAL_BOOL(renovate, 0);
	}
	
	PHALCON_OBSERVE_VAR(database);
	phalcon_read_static_property(&database, SL("phalcon\\db\\pool"), SL("_defaultDescriptor") TSRMLS_CC);
	if (!zend_is_true(database)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Default database connection parameters was not defined");
		return;
	}
	
	eval_int = phalcon_isset_property(database, SL("adapter") TSRMLS_CC);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "A valid adapter name is required");
		return;
	}
	
	if (zend_is_true(new_connection)) {
		if (zend_is_true(renovate)) {
			PHALCON_ALLOC_ZVAL_MM(t0);
			phalcon_read_property(&t0, database, SL("adapter"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\db", "factory", t0, database);
			phalcon_update_static_property(SL("phalcon\\db\\pool"), SL("_connection"), r0 TSRMLS_CC);
			PHALCON_OBSERVE_VAR(connection);
			phalcon_read_static_property(&connection, SL("phalcon\\db\\pool"), SL("_connection") TSRMLS_CC);
		} else {
			PHALCON_ALLOC_ZVAL_MM(t1);
			phalcon_read_property(&t1, database, SL("adapter"), PH_NOISY_CC);
			PHALCON_INIT_VAR(connection);
			PHALCON_CALL_STATIC_PARAMS_2(connection, "phalcon\\db", "factory", t1, database);
		}
	} else {
		PHALCON_OBSERVE_VAR(t2);
		phalcon_read_static_property(&t2, SL("phalcon\\db\\pool"), SL("_connection") TSRMLS_CC);
		if (!zend_is_true(t2)) {
			PHALCON_ALLOC_ZVAL_MM(t3);
			phalcon_read_property(&t3, database, SL("adapter"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_STATIC_PARAMS_2(r1, "phalcon\\db", "factory", t3, database);
			phalcon_update_static_property(SL("phalcon\\db\\pool"), SL("_connection"), r1 TSRMLS_CC);
		}
		PHALCON_OBSERVE_VAR(connection);
		phalcon_read_static_property(&connection, SL("phalcon\\db\\pool"), SL("_connection") TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(connection);
}

/**
 * Resets default descriptor and connection
 *
 */
PHP_METHOD(Phalcon_Db_Pool, reset){

	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	phalcon_update_static_property(SL("phalcon\\db\\pool"), SL("_connection"), t0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_NULL(t1);
	phalcon_update_static_property(SL("phalcon\\db\\pool"), SL("_defaultDescriptor"), t1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \db\pool.c ------ */

/* ------ Starting File: \db\profiler.c ------ */
/**
 * Phalcon\Db\Profiler
 *
 * Instances of Phalcon\Db can generate execution profiles
 * on SQL statements sent to the relational database. Profiled
 * information includes execution time in miliseconds.
 * This helps you to identify bottlenecks in your applications.
 *
 *
 *
 */

PHP_METHOD(Phalcon_Db_Profiler, __construct){

	zval *a0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_db_profiler_ce, this_ptr, SL("_allProfiles"), a0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Starts the profile of a SQL sentence
 *
 * @param string $sqlStatement
 */
PHP_METHOD(Phalcon_Db_Profiler, startProfile){

	zval *sql_statement = NULL;
	zval *i0 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_db_profiler_item_ce);
	phalcon_update_property_zval(this_ptr, SL("_activeProfile"), i0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "setsqlstatement", sql_statement, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_BOOL(c0, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "microtime", c0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t1, "setinitialtime", r0, PH_NO_CHECK);
	if (phalcon_method_exists_ex(this_ptr, SL("beforestartprofile") TSRMLS_CC) == SUCCESS) {
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "beforestartprofile", t2, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Stops the active profile
 *
 * @access public
 */
PHP_METHOD(Phalcon_Db_Profiler, stopProfile){

	zval *final_time = NULL;
	zval *c0 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_BOOL(c0, 1);
	PHALCON_INIT_VAR(final_time);
	PHALCON_CALL_FUNC_PARAMS_1(final_time, "microtime", c0);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t0, "setfinaltime", final_time, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_totalSeconds"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t2, "getinitialtime", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	sub_function(r1, final_time, r0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_add_function(r2, t1, r1 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_totalSeconds"), r2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_allProfiles"), PH_NOISY_CC);
	phalcon_array_append(&t4, t3, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_allProfiles"), t4 TSRMLS_CC);
	if (phalcon_method_exists_ex(this_ptr, SL("afterendprofile") TSRMLS_CC) == SUCCESS) {
		PHALCON_ALLOC_ZVAL_MM(t5);
		phalcon_read_property(&t5, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "afterendprofile", t5, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the total number of SQL statements processed
 *
 * @return integer
 */
PHP_METHOD(Phalcon_Db_Profiler, getNumberTotalStatements){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_allProfiles"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	RETURN_CTOR(r0);
}

/**
 * Returns the total time in seconds spent by the profiles
 *
 * @return double
 */
PHP_METHOD(Phalcon_Db_Profiler, getTotalElapsedSeconds){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_totalSeconds"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns all the processed profiles
 *
 * @return Phalcon_Db_Profiler_Item[]
 */
PHP_METHOD(Phalcon_Db_Profiler, getProfiles){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_allProfiles"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Resets the profiler, cleaning up all the profiles
 *
 */
PHP_METHOD(Phalcon_Db_Profiler, reset){

	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_allProfiles"), a0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the last profile executed in the profiler
 *
 * @return Phalcon_Db_Profiler_Item
 */
PHP_METHOD(Phalcon_Db_Profiler, getLastProfile){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \db\profiler.c ------ */

/* ------ Starting File: \db\exception.c ------ */
/**
 * Phalcon_Db_Exception
 *
 * Exceptions thrown in Phalcon_Db will use this class
 *
 */

/* ------ Finished File: \db\exception.c ------ */

/* ------ Starting File: \db\reference.c ------ */
/**
 * Phalcon\Db\Reference
 *
 * Allows to define reference constraints on tables
 *
 *
 */

/**
 * Phalcon_Db_Reference constructor
 *
 * @param string $referenceName
 * @param array $definition
 */
PHP_METHOD(Phalcon_Db_Reference, __construct){

	zval *reference_name = NULL, *definition = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &reference_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_referenceName"), reference_name TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SL("referencedTable")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, definition, SL("referencedTable"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedTable"), r0 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Referenced table is required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("columns")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, definition, SL("columns"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_columns"), r1 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Foreign key columns are required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("referencedColumns")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, definition, SL("referencedColumns"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedColumns"), r2 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Referenced columns of the foreign key are required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("schema")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_array_fetch_string(&r3, definition, SL("schema"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_schema"), r3 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("referencedSchema")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r4);
		phalcon_array_fetch_string(&r4, definition, SL("referencedSchema"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedSchema"), r4 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_columns"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	phalcon_fast_count(r5, t0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_referencedColumns"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	phalcon_fast_count(r6, t1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	is_not_equal_function(r7, r5, r6 TSRMLS_CC);
	if (zend_is_true(r7)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Number of columns is not equals than the number of columns referenced");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the index name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Reference, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_referenceName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the schema where referenced table is
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Reference, getSchemaName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_schemaName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the schema where referenced table is
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Reference, getReferencedSchema){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_referencedSchema"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets local columns which reference is based
 *
 * @return array
 */
PHP_METHOD(Phalcon_Db_Reference, getColumns){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_columns"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the referenced table
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Reference, getReferencedTable){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_referencedTable"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets referenced columns
 *
 * @return array
 */
PHP_METHOD(Phalcon_Db_Reference, getReferencedColumns){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_referencedColumns"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Restore a Phalcon_Db_Reference object from export
 *
 * @param array $data
 * @return Phalcon_Db_Reference
 */
PHP_METHOD(Phalcon_Db_Reference, __set_state){

	zval *data = NULL, *constraint_name = NULL, *referenced_schema = NULL;
	zval *referenced_table = NULL, *columns = NULL, *referenced_columns = NULL;
	zval *i0 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(data, SL("_referenceName")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_referenceName parameter is required");
		return;
	} else {
		PHALCON_INIT_VAR(constraint_name);
		phalcon_array_fetch_string(&constraint_name, data, SL("_referenceName"), PH_NOISY_CC);
	}
	eval_int = phalcon_array_isset_string(data, SL("_referencedSchema")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_schema);
		phalcon_array_fetch_string(&referenced_schema, data, SL("_referencedSchema"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(referenced_schema);
		ZVAL_NULL(referenced_schema);
	}
	
	eval_int = phalcon_array_isset_string(data, SL("_referencedTable")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_table);
		phalcon_array_fetch_string(&referenced_table, data, SL("_referencedTable"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(referenced_table);
		ZVAL_NULL(referenced_table);
	}
	
	eval_int = phalcon_array_isset_string(data, SL("_columns")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(columns);
		phalcon_array_fetch_string(&columns, data, SL("_columns"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(columns);
		ZVAL_NULL(columns);
	}
	
	eval_int = phalcon_array_isset_string(data, SL("_referencedColumns")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_columns);
		phalcon_array_fetch_string(&referenced_columns, data, SL("_referencedColumns"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(referenced_columns);
		ZVAL_NULL(referenced_columns);
	}
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_db_reference_ce);
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_array_update_string(&a0, SL("referencedSchema"), &referenced_schema, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&a0, SL("referencedTable"), &referenced_table, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&a0, SL("columns"), &columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&a0, SL("referencedColumns"), &referenced_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", constraint_name, a0, PH_CHECK);
	
	RETURN_CTOR(i0);
}

/* ------ Finished File: \db\reference.c ------ */

/* ------ Starting File: \db\adapter\mysql.c ------ */
/**
 * Phalcon_Db_Adapter_Mysql
 *
 * Phalcon_Db_Adapter_Mysql is the Phalcon_Db adapter for the MySQL database.
 * 
 */

/**
 * Constructor for Phalcon_Db_Adapter_Mysql. This method does not should to be called directly. Use Phalcon_Db::factory instead
 *
 * @param stdClass $descriptor
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, __construct){

	zval *descriptor = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_ALLOC_ZVAL_MM(descriptor);
		ZVAL_NULL(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_VAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "connect", descriptor, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * This method is automatically called in Phalcon_Db_Mysql constructor.
 * Call it when you need to restore a database connection
 *
 * @param stdClass $descriptor
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, connect){

	zval *descriptor = NULL, *host = NULL, *username = NULL, *password = NULL, *port = NULL;
	zval *socket = NULL, *dbname = NULL, *client_flags = NULL, *persistent = NULL;
	zval *link = NULL, *autocommit = NULL, *success = NULL, *collation = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_ALLOC_ZVAL_MM(descriptor);
		ZVAL_NULL(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_VAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	eval_int = phalcon_isset_property(descriptor, SL("host") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(host);
		phalcon_read_property(&host, descriptor, SL("host"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(host);
		ZVAL_NULL(host);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("username") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(username);
		phalcon_read_property(&username, descriptor, SL("username"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(username);
		ZVAL_NULL(username);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("password") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(password);
		phalcon_read_property(&password, descriptor, SL("password"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(password);
		ZVAL_NULL(password);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("port") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(port);
		phalcon_read_property(&port, descriptor, SL("port"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(port);
		ZVAL_NULL(port);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("socket") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(socket);
		phalcon_read_property(&socket, descriptor, SL("socket"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(socket);
		ZVAL_NULL(socket);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("name") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(dbname);
		phalcon_read_property(&dbname, descriptor, SL("name"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(dbname);
		ZVAL_STRING(dbname, "", 1);
	}
	
	PHALCON_INIT_VAR(client_flags);
	ZVAL_NULL(client_flags);
	eval_int = phalcon_isset_property(descriptor, SL("compression") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 32);
		PHALCON_CPY_WRT(client_flags, t0);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("ssl") TSRMLS_CC);
	if (eval_int) {
		if (!zend_is_true(client_flags)) {
			PHALCON_INIT_VAR(t1);
			ZVAL_LONG(t1, 2048);
			PHALCON_CPY_WRT(client_flags, t1);
		} else {
			PHALCON_INIT_VAR(t2);
			ZVAL_LONG(t2, 2048);
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_ALLOC_ZVAL_MM(r0);
			bitwise_or_function(r0, client_flags, t2 TSRMLS_CC);
			PHALCON_CPY_WRT(client_flags, r0);
		}
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("interactive") TSRMLS_CC);
	if (eval_int) {
		if (!zend_is_true(client_flags)) {
			PHALCON_INIT_VAR(t3);
			ZVAL_LONG(t3, 1024);
			PHALCON_CPY_WRT(client_flags, t3);
		} else {
			PHALCON_INIT_VAR(t4);
			ZVAL_LONG(t4, 1024);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_ALLOC_ZVAL_MM(r1);
			bitwise_or_function(r1, client_flags, t4 TSRMLS_CC);
			PHALCON_CPY_WRT(client_flags, r1);
		}
	}
	
	PHALCON_INIT_VAR(persistent);
	ZVAL_BOOL(persistent, 0);
	eval_int = phalcon_isset_property(descriptor, SL("persistent") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(persistent);
		phalcon_read_property(&persistent, descriptor, SL("persistent"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(link);
	PHALCON_CALL_FUNC(link, "mysqli_init");
	eval_int = phalcon_isset_property(descriptor, SL("autocommit") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t5);
		phalcon_read_property(&t5, descriptor, SL("autocommit"), PH_NOISY_CC);
		PHALCON_INIT_VAR(autocommit);
		PHALCON_CALL_FUNC_PARAMS_1(autocommit, "intval", t5);
		phalcon_update_property_zval(this_ptr, SL("_autoCommit"), autocommit TSRMLS_CC);
		
		PHALCON_INIT_VAR(t6);
		ZVAL_LONG(t6, 3);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SV(r2, "SET AUTOCOMMIT = ", autocommit);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_FUNC_PARAMS_3(r3, "mysqli_options", link, t6, r2);
		if (!zend_is_true(r3)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Setting MYSQLI_INIT_COMMAND failed");
			return;
		}
	}
	
	p0[0] = link;
	p0[1] = host;
	p0[2] = username;
	p0[3] = password;
	p0[4] = dbname;
	p0[5] = port;
	p0[6] = socket;
	p0[7] = client_flags;
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CALL_FUNC_PARAMS(r4, "mysqli_real_connect", 8, p0);
	PHALCON_CPY_WRT(success, r4);
	if (zend_is_true(success)) {
		phalcon_update_property_zval(this_ptr, SL("_idConnection"), link TSRMLS_CC);
		PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Db\\Adapter\\Mysql", "__construct", descriptor);
		eval_int = phalcon_isset_property(descriptor, SL("charset") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t7);
			phalcon_read_property(&t7, descriptor, SL("charset"), PH_NOISY_CC);
			PHALCON_CALL_FUNC_PARAMS_2_NORETURN("mysqli_set_charset", link, t7);
		}
		
		eval_int = phalcon_isset_property(descriptor, SL("collation") TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_VAR(collation);
			phalcon_read_property(&collation, descriptor, SL("collation"), PH_NOISY_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CONCAT_SV(r5, "SET collation_connection=", collation);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "query", r5, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r6);
			PHALCON_CONCAT_SV(r6, "SET collation_database=", collation);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "query", r6, PH_NO_CHECK);
		}
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Connection to MySQL failed");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sends SQL statements to the MySQL database server returning success state.
 * When the SQL sent have returned any row, the result is a PHP resource.
 *
 * $resultset = $connection->query("SELECT * FROM robots WHERE type=?", array("mechanical"));
 *
 * @param  string $sqlStatement
 * @return Phalcon_Db_Result_Mysql|boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, query){

	zval *sql_statement = NULL, *id_connection = NULL, *result = NULL;
	zval *number_error = NULL, *error_message = NULL;
	zval *i0 = NULL, *i1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_beforequery", sql_statement, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_FUNC_PARAMS_2(result, "mysqli_query", id_connection, sql_statement);
	if (zend_is_true(result)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_afterquery", sql_statement, PH_NO_CHECK);
		if (Z_TYPE_P(result) == IS_OBJECT) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_db_result_mysql_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", result, PH_CHECK);
			
			RETURN_CTOR(i0);
		}
		
		
		RETURN_CCTOR(result);
	}
	
	PHALCON_INIT_VAR(number_error);
	PHALCON_CALL_METHOD(number_error, this_ptr, "noerror", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, " when executing \"", sql_statement, "\"");
	
	PHALCON_INIT_VAR(error_message);
	PHALCON_CALL_METHOD_PARAMS_1(error_message, this_ptr, "error", r0, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, phalcon_db_exception_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i1, "__construct", error_message, number_error, PH_CHECK);
	phalcon_throw_exception(i1 TSRMLS_CC);
	return;
}

/**
 * Returns number of affected rows by the last INSERT/UPDATE/DELETE repoted by MySQL
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, affectedRows){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "mysqli_affected_rows", t0);
	RETURN_CTOR(r0);
}

/**
 * Closes active connection returning success. Phalcon automatically closes and destroys active connections within Phalcon_Db_Pool
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, close){

	zval *id_connection = NULL, *success = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(id_connection)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_FUNC_PARAMS_1(success, "mysqli_close", id_connection);
		phalcon_update_property_null(this_ptr, SL("_idConnection") TSRMLS_CC);
		
		RETURN_CCTOR(success);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the active connection unique identifier. A mysqli object
 *
 * @param boolean $asString
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, getConnectionId){

	zval *as_string = NULL, *id_connection = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &as_string) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!as_string) {
		PHALCON_ALLOC_ZVAL_MM(as_string);
		ZVAL_BOOL(as_string, 0);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(as_string)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "mysqli_thread_id", id_connection);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SV(r1, "Connection", r0);
		
		RETURN_CTOR(r1);
	} else {
		
		RETURN_CCTOR(id_connection);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Escapes a value to avoid SQL injections
 *
 * @param string $str
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, escapeString){

	zval *str = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "mysqli_real_escape_string", t0, str);
	RETURN_CTOR(r0);
}

/**
 * Bind params to SQL select
 *
 * @param string $sqlSelect
 * @param array $params
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, bindParams){

	zval *sql_select = NULL, *params = NULL, *select = NULL, *id_connection = NULL;
	zval *bind_value = NULL, *index = NULL, *value = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_select, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, params TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_CPY_WRT(select, sql_select);
		
		PHALCON_INIT_VAR(id_connection);
		phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
		if (phalcon_valid_foreach(params TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(params);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_321f_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_321f_0;
			} else {
				PHALCON_INIT_VAR(index);
				PHALCON_GET_FOREACH_KEY(index, ah0, hp0);
			}
			PHALCON_INIT_VAR(bind_value);
			ZVAL_ZVAL(bind_value, *hd, 1, 0);
			PHALCON_INIT_VAR(r1);
			PHALCON_CALL_FUNC_PARAMS_1(r1, "is_numeric", bind_value);
			if (zend_is_true(r1)) {
				PHALCON_CPY_WRT(value, bind_value);
			} else {
				PHALCON_INIT_VAR(r2);
				PHALCON_CALL_FUNC_PARAMS_2(r2, "mysqli_real_escape_string", id_connection, bind_value);
				PHALCON_INIT_VAR(value);
				PHALCON_CONCAT_SVS(value, "!", r2, "!");
			}
			if (Z_TYPE_P(index) == IS_LONG) {
				PHALCON_INIT_VAR(r3);
				PHALCON_CONCAT_SV(r3, "?", index);
				PHALCON_INIT_VAR(r4);
				phalcon_fast_str_replace(r4, r3, value, select TSRMLS_CC);
				PHALCON_CPY_WRT(select, r4);
			} else {
				if (Z_TYPE_P(index) == IS_STRING) {
					PHALCON_INIT_VAR(r5);
					PHALCON_CONCAT_SVS(r5, ":", index, ":");
					PHALCON_INIT_VAR(r6);
					phalcon_fast_str_replace(r6, r5, value, select TSRMLS_CC);
					PHALCON_CPY_WRT(select, r6);
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind parameter");
					return;
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_321f_0;
			fee_321f_0:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "!", 1);
		
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "'", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		phalcon_fast_str_replace(r7, c0, c1, select TSRMLS_CC);
		RETURN_CTOR(r7);
	}
	
	RETURN_CCTOR(sql_select);
}

/**
 * Returns last error message from MySQL
 *
 * @param string $errorString
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, error){

	zval *error_string = NULL, *id_connection = NULL, *error_message = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &error_string) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!error_string) {
		PHALCON_ALLOC_ZVAL_MM(error_string);
		ZVAL_NULL(error_string);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(id_connection)) {
		PHALCON_INIT_VAR(error_message);
		PHALCON_CALL_FUNC_PARAMS_1(error_message, "mysqli_error", id_connection);
	} else {
		PHALCON_INIT_VAR(error_message);
		ZVAL_STRING(error_message, "", 1);
	}
	
	if (zend_is_true(error_message)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSV(r0, "\"", error_message, "\" ", error_string);
		phalcon_update_property_zval(this_ptr, SL("_lastError"), r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "[Unknown MySQL error: ", error_string, "]");
		phalcon_update_property_zval(this_ptr, SL("_lastError"), r1 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_lastError"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns last error code from MySQL
 *
 * @param string $errorString
 * @param resurce $resultQuery
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, noError){

	zval *result_query = NULL, *id_connection = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &result_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!result_query) {
		PHALCON_ALLOC_ZVAL_MM(result_query);
		ZVAL_NULL(result_query);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (!zend_is_true(id_connection)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "mysqli_errno", id_connection);
	RETURN_CTOR(r0);
}

/**
 * Returns insert id for the auto_increment column inserted in the last SQL statement
 *
 * @param string $table
 * @param string $primaryKey
 * @param string $sequenceName
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, lastInsertId){

	zval *table = NULL, *primary_key = NULL, *sequence_name = NULL, *id_connection = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzz", &table, &primary_key, &sequence_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!table) {
		PHALCON_ALLOC_ZVAL_MM(table);
		ZVAL_NULL(table);
	}
	
	if (!primary_key) {
		PHALCON_ALLOC_ZVAL_MM(primary_key);
		ZVAL_NULL(primary_key);
	}
	
	if (!sequence_name) {
		PHALCON_ALLOC_ZVAL_MM(sequence_name);
		ZVAL_NULL(sequence_name);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (!zend_is_true(id_connection)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "mysqli_insert_id", id_connection);
	RETURN_CTOR(r0);
}

/**
 * Gets a list of columns
 *
 * @param array $columnList
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, getColumnList){

	zval *column_list = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\db\\dialect\\mysql", "getcolumnlist", column_list);
	RETURN_CTOR(r0);
}

/**
 * Appends a LIMIT clause to $sqlQuery argument
 *
 * @param string $sqlQuery
 * @param int $number
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, limit){

	zval *sql_query = NULL, *number = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\db\\dialect\\mysql", "limit", sql_query, number);
	RETURN_CTOR(r0);
}

/**
 * Generates SQL checking for the existence of a schema.table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, tableExists){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL, *num = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "tableexists", table_name, schema_name);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 2);
	
	PHALCON_INIT_VAR(num);
	PHALCON_CALL_METHOD_PARAMS_2(num, this_ptr, "fetchone", sql, t0, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_long(&r0, num, 0, PH_NOISY_CC);
	
	RETURN_CCTOR(r0);
}

/**
 * Generates SQL checking for the existence of a schema.view
 *
 * @param string $viewName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, viewExists){

	zval *view_name = NULL, *schema_name = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &view_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "tableexists", view_name, schema_name, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Devuelve un FOR UPDATE valido para un SELECT del RBDM
 *
 * @param string $sqlQuery
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, forUpdate){

	zval *sql_query = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VS(r0, sql_query, " FOR UPDATE");
	
	RETURN_CTOR(r0);
}

/**
 * Devuelve un SHARED LOCK valido para un SELECT del RBDM
 *
 * @param string $sqlQuery
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, sharedLock){

	zval *sql_query = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VS(r0, sql_query, " LOCK IN SHARE MODE");
	
	RETURN_CTOR(r0);
}

/**
 * Creates a table using MySQL SQL
 *
 * @param string $tableName
 * @param string $schemaName
 * @param array $definition
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, createTable){

	zval *table_name = NULL, *schema_name = NULL, *definition = NULL;
	zval *sql = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_db_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Invalid definition to create the table '", table_name, "'");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SL("columns")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, definition, SL("columns"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_fast_count(r2, r1 TSRMLS_CC);
	if (!zend_is_true(r2)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "createtable", table_name, schema_name, definition);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD_PARAMS_1(r3, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r3);
}

/**
 * Drops a table from a schema/database
 *
 * @param string $tableName
 * @param   string $schemaName
 * @param boolean $ifExists
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, dropTable){

	zval *table_name = NULL, *schema_name = NULL, *if_exists = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_ALLOC_ZVAL_MM(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "droptable", table_name, schema_name, if_exists);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a column to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Column $column
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, addColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "addcolumn", table_name, schema_name, column);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Modifies a table column based on a definition
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Column $column
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, modifyColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "modifycolumn", table_name, schema_name, column);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops a column from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $columnName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, dropColumn){

	zval *table_name = NULL, *schema_name = NULL, *column_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "dropcolumn", table_name, schema_name, column_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param DbIndex $index
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, addIndex){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "addindex", table_name, schema_name, index);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drop an index from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $indexName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, dropIndex){

	zval *table_name = NULL, *schema_name = NULL, *index_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "dropindex", table_name, schema_name, index_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a primary key to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Index $index
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, addPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "addprimarykey", table_name, schema_name, index);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops primary key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, dropPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "dropprimarykey", table_name, schema_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a foreign key to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Reference $reference
 * @return boolean true
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, addForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "addforeignkey", table_name, schema_name, reference);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops a foreign key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $referenceName
 * @return boolean true
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, dropForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\mysql", "dropforeignkey", table_name, schema_name, reference_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Returns the SQL column definition from a column
 *
 * @param Phalcon_Db_Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, getColumnDefinition){

	zval *column = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\db\\dialect\\mysql", "getcolumndefinition", column);
	RETURN_CTOR(r0);
}

/**
 * Generates SQL describing a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, describeTable){

	zval *table = NULL, *schema = NULL, *sql = NULL, *describe = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "describetable", table, schema);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, t0, PH_NO_CHECK);
	
	RETURN_CCTOR(describe);
}

/**
 * List all tables on a database
 *
 * @param string $schemaName
 * @return array
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, listTables){

	zval *schema_name = NULL, *sql = NULL, *tables = NULL, *all_tables = NULL, *table = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_1(sql, "phalcon\\db\\dialect\\mysql", "listtables", schema_name);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 2);
	
	PHALCON_INIT_VAR(tables);
	PHALCON_CALL_METHOD_PARAMS_2(tables, this_ptr, "fetchall", sql, t0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(all_tables);
	array_init(all_tables);
	if (phalcon_valid_foreach(tables TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(tables);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_321f_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_321f_1;
		}
		
		PHALCON_INIT_VAR(table);
		ZVAL_ZVAL(table, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_long(&r0, table, 0, PH_NOISY_CC);
		phalcon_array_append(&all_tables, r0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_321f_1;
		fee_321f_1:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(all_tables);
}

/**
 * Returns a database date formatted
 *
 * @param string $date
 * @param string $format
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, getDateUsingFormat){

	zval *date = NULL, *format = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &date, &format) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!format) {
		PHALCON_ALLOC_ZVAL_MM(format);
		ZVAL_STRING(format, "YYYY-MM-DD", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "'", date, "'");
	
	RETURN_CTOR(r0);
}

/**
 * Lists table indexes
 *
 * @param string $table
 * @param string $schema
 * @return Phalcon_Db_Index[]
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, describeIndexes){

	zval *table = NULL, *schema = NULL, *sql = NULL, *describe = NULL, *indexes = NULL, *index = NULL;
	zval *key_name = NULL, *index_objects = NULL, *index_columns = NULL;
	zval *name = NULL;
	zval *t0 = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL;
	zval *i0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "describeindexes", table, schema);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, t0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(indexes);
	array_init(indexes);
	if (phalcon_valid_foreach(describe TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(describe);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_321f_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_321f_2;
		}
		
		PHALCON_INIT_VAR(index);
		ZVAL_ZVAL(index, *hd, 1, 0);
		PHALCON_INIT_VAR(key_name);
		phalcon_array_fetch_string(&key_name, index, SL("Key_name"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(indexes, key_name);
		if (!eval_int) {
			PHALCON_INIT_VAR(a0);
			array_init(a0);
			phalcon_array_update(&indexes, key_name, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_string(&r0, index, SL("Column_name"), PH_NOISY_CC);
		phalcon_array_update_multi_append_2(&indexes, key_name, r0, 0 TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_321f_2;
		fee_321f_2:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(index_objects);
	array_init(index_objects);
	if (phalcon_valid_foreach(indexes TSRMLS_CC)) {
		ah1 = Z_ARRVAL_P(indexes);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
		fes_321f_3:
		if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
			goto fee_321f_3;
		} else {
			PHALCON_INIT_VAR(name);
			PHALCON_GET_FOREACH_KEY(name, ah1, hp1);
		}
		PHALCON_INIT_VAR(index_columns);
		ZVAL_ZVAL(index_columns, *hd, 1, 0);
		PHALCON_INIT_VAR(i0);
		object_init_ex(i0, phalcon_db_index_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", name, index_columns, PH_CHECK);
		phalcon_array_update(&index_objects, name, &i0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah1, &hp1);
		goto fes_321f_3;
		fee_321f_3:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(index_objects);
}

/**
 * Lists table references
 *
 * @param string $table
 * @param string $schema
 * @return Phalcon_Db_Reference[]
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, describeReferences){

	zval *table = NULL, *schema = NULL, *sql = NULL, *references = NULL, *describe = NULL;
	zval *reference = NULL, *constraint_name = NULL, *reference_objects = NULL;
	zval *array_reference = NULL, *name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *i0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "describereferences", table, schema);
	
	PHALCON_INIT_VAR(references);
	array_init(references);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, t0, PH_NO_CHECK);
	if (phalcon_valid_foreach(describe TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(describe);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_321f_4:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_321f_4;
		}
		
		PHALCON_INIT_VAR(reference);
		ZVAL_ZVAL(reference, *hd, 1, 0);
		PHALCON_INIT_VAR(constraint_name);
		phalcon_array_fetch_string(&constraint_name, reference, SL("CONSTRAINT_NAME"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(references, constraint_name);
		if (!eval_int) {
			PHALCON_INIT_VAR(a0);
			array_init(a0);
			PHALCON_INIT_VAR(r0);
			phalcon_array_fetch_string(&r0, reference, SL("REFERENCED_TABLE_SCHEMA"), PH_NOISY_CC);
			phalcon_array_update_string(&a0, SL("referencedSchema"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch_string(&r1, reference, SL("REFERENCED_TABLE_NAME"), PH_NOISY_CC);
			phalcon_array_update_string(&a0, SL("referencedTable"), &r1, PH_COPY | PH_SEPARATE TSRMLS_CC);
			PHALCON_INIT_VAR(a1);
			array_init(a1);
			phalcon_array_update_string(&a0, SL("columns"), &a1, PH_COPY | PH_SEPARATE TSRMLS_CC);
			PHALCON_INIT_VAR(a2);
			array_init(a2);
			phalcon_array_update_string(&a0, SL("referencedColumns"), &a2, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update(&references, constraint_name, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(r2);
		phalcon_array_fetch_string(&r2, reference, SL("COLUMN_NAME"), PH_NOISY_CC);
		if (Z_TYPE_P(references) == IS_ARRAY) {
			PHALCON_INIT_VAR(t1);
			phalcon_array_fetch(&t1, references, constraint_name, PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t1) > 1) {
			phalcon_array_update(&references, constraint_name, &t1, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t1) != IS_ARRAY) {
			convert_to_array(t1);
			phalcon_array_update(&references, constraint_name, &t1, PH_COPY TSRMLS_CC);
		}
		if (Z_TYPE_P(t1) == IS_ARRAY) {
			PHALCON_INIT_VAR(t2);
			phalcon_array_fetch_string(&t2, t1, SL("columns"), PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t2) > 1) {
			phalcon_array_update_string(&t1, SL("columns"), &t2, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t2) != IS_ARRAY) {
			convert_to_array(t2);
			phalcon_array_update_string(&t1, SL("columns"), &t2, PH_COPY TSRMLS_CC);
		}
		phalcon_array_append(&t2, r2, 0 TSRMLS_CC);
		
		PHALCON_INIT_VAR(r3);
		phalcon_array_fetch_string(&r3, reference, SL("REFERENCED_COLUMN_NAME"), PH_NOISY_CC);
		if (Z_TYPE_P(references) == IS_ARRAY) {
			PHALCON_INIT_VAR(t3);
			phalcon_array_fetch(&t3, references, constraint_name, PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t3) > 1) {
			phalcon_array_update(&references, constraint_name, &t3, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t3) != IS_ARRAY) {
			convert_to_array(t3);
			phalcon_array_update(&references, constraint_name, &t3, PH_COPY TSRMLS_CC);
		}
		if (Z_TYPE_P(t3) == IS_ARRAY) {
			PHALCON_INIT_VAR(t4);
			phalcon_array_fetch_string(&t4, t3, SL("referencedColumns"), PH_SILENT_CC);
		}
		if (Z_REFCOUNT_P(t4) > 1) {
			phalcon_array_update_string(&t3, SL("referencedColumns"), &t4, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(t4) != IS_ARRAY) {
			convert_to_array(t4);
			phalcon_array_update_string(&t3, SL("referencedColumns"), &t4, PH_COPY TSRMLS_CC);
		}
		phalcon_array_append(&t4, r3, 0 TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_321f_4;
		fee_321f_4:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(reference_objects);
	array_init(reference_objects);
	if (phalcon_valid_foreach(references TSRMLS_CC)) {
		ah1 = Z_ARRVAL_P(references);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
		fes_321f_5:
		if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
			goto fee_321f_5;
		} else {
			PHALCON_INIT_VAR(name);
			PHALCON_GET_FOREACH_KEY(name, ah1, hp1);
		}
		PHALCON_INIT_VAR(array_reference);
		ZVAL_ZVAL(array_reference, *hd, 1, 0);
		PHALCON_INIT_VAR(i0);
		object_init_ex(i0, phalcon_db_reference_ce);
		PHALCON_INIT_VAR(a3);
		array_init(a3);
		PHALCON_INIT_VAR(r4);
		phalcon_array_fetch_string(&r4, array_reference, SL("referencedSchema"), PH_NOISY_CC);
		phalcon_array_update_string(&a3, SL("referencedSchema"), &r4, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r5);
		phalcon_array_fetch_string(&r5, array_reference, SL("referencedTable"), PH_NOISY_CC);
		phalcon_array_update_string(&a3, SL("referencedTable"), &r5, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r6);
		phalcon_array_fetch_string(&r6, array_reference, SL("columns"), PH_NOISY_CC);
		phalcon_array_update_string(&a3, SL("columns"), &r6, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r7);
		phalcon_array_fetch_string(&r7, array_reference, SL("referencedColumns"), PH_NOISY_CC);
		phalcon_array_update_string(&a3, SL("referencedColumns"), &r7, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", name, a3, PH_CHECK);
		phalcon_array_update(&reference_objects, name, &i0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah1, &hp1);
		goto fes_321f_5;
		fee_321f_5:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(reference_objects);
}

/**
 * Gets creation options from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return array
 */
PHP_METHOD(Phalcon_Db_Adapter_Mysql, tableOptions){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL, *references = NULL;
	zval *describe = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\mysql", "tableoptions", table_name, schema_name);
	
	PHALCON_INIT_VAR(references);
	array_init(references);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, t0, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_long(&r0, describe, 0, PH_NOISY_CC);
	
	RETURN_CCTOR(r0);
}

/* ------ Finished File: \db\adapter\mysql.c ------ */

/* ------ Starting File: \db\adapter\postgresql.c ------ */
/**
 * Phalcon_Db_Adapter_Postgresql
 *
 * Phalcon_Db_Adapter_Postgresql is the Phalcon_Db adapter for the PostgreSQL database.
 * 
 */

/**
 * Constructor for Phalcon_Db_Adapter_Postgresql. This method does not should to be called directly. Use Phalcon_Db::factory instead
 *
 * @param stdClass $descriptor
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, __construct){

	zval *descriptor = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_ALLOC_ZVAL_MM(descriptor);
		ZVAL_NULL(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_VAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "connect", descriptor, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * This method is automatically called in Phalcon_Db_Postgresql constructor.
 * Call it when you need to restore a database connection
 *
 * @param stdClass $descriptor
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, connect){

	zval *descriptor = NULL, *connection_string = NULL, *id_connection = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_ALLOC_ZVAL_MM(descriptor);
		ZVAL_NULL(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_VAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(connection_string);
	ZVAL_STRING(connection_string, "", 1);
	eval_int = phalcon_isset_property(descriptor, SL("host") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, descriptor, SL("host"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "host=", t0, " ");
		phalcon_concat_self(&connection_string, r0 TSRMLS_CC);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("port") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, descriptor, SL("port"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "port=", t1, " ");
		phalcon_concat_self(&connection_string, r1 TSRMLS_CC);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("name") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, descriptor, SL("name"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SVS(r2, "dbname=", t2, " ");
		phalcon_concat_self(&connection_string, r2 TSRMLS_CC);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("username") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, descriptor, SL("username"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CONCAT_SVS(r3, "user=", t3, " ");
		phalcon_concat_self(&connection_string, r3 TSRMLS_CC);
	}
	
	eval_int = phalcon_isset_property(descriptor, SL("password") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t4);
		phalcon_read_property(&t4, descriptor, SL("password"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CONCAT_SV(r4, "password=", t4);
		phalcon_concat_self(&connection_string, r4 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(t5);
	ZVAL_LONG(t5, 2);
	
	PHALCON_INIT_VAR(id_connection);
	PHALCON_CALL_FUNC_PARAMS_2(id_connection, "pg_connect", connection_string, t5);
	if (zend_is_true(id_connection)) {
		phalcon_update_property_zval(this_ptr, SL("_idConnection"), id_connection TSRMLS_CC);
		PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Db\\Adapter\\Postgresql", "__construct", descriptor);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Connection to PostgreSQL failed");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sends SQL statements to the PostgreSQL database server returning success state.
 * When the SQL sent have returned any row, the result is a PHP resource.
 *
 * $resultset = $connection->query("SELECT * FROM robots WHERE type=?", array("mechanical"));
 *
 * @param  string $sqlStatement
 * @return Phalcon_Db_Result_Postgresql|boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, query){

	zval *sql_statement = NULL, *id_connection = NULL, *result = NULL;
	zval *number_error = NULL, *error_message = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *i0 = NULL, *i1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_beforequery", sql_statement, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_FUNC_PARAMS_2(result, "pg_query", t0, sql_statement);
	if (zend_is_true(result)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_afterquery", sql_statement, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_lastResultset"), result TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "pg_result_status", result);
		
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 2);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		is_equal_function(r1, r0, t1 TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_db_result_postgresql_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", result, PH_CHECK);
			
			RETURN_CTOR(i0);
		}
		
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_INIT_VAR(number_error);
	PHALCON_CALL_METHOD(number_error, this_ptr, "noerror", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVS(r2, " when executing \"", sql_statement, "\"");
	
	PHALCON_INIT_VAR(error_message);
	PHALCON_CALL_METHOD_PARAMS_1(error_message, this_ptr, "error", r2, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, phalcon_db_exception_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i1, "__construct", error_message, number_error, PH_CHECK);
	phalcon_throw_exception(i1 TSRMLS_CC);
	return;
}

/**
 * Returns number of affected rows by the last INSERT/UPDATE/DELETE repoted by PostgreSQL
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, affectedRows){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_lastResultset"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "pg_affected_rows", t0);
	RETURN_CTOR(r0);
}

/**
 * Closes active connection returning success. Phalcon automatically closes and destroys active connections within Phalcon_Db_Pool
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, close){

	zval *id_connection = NULL, *success = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(id_connection)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_FUNC_PARAMS_1(success, "pg_close", id_connection);
		phalcon_update_property_null(this_ptr, SL("_idConnection") TSRMLS_CC);
		
		RETURN_CCTOR(success);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the active connection unique identifier. A pgsql resource
 *
 * @param boolean $asString
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, getConnectionId){

	zval *as_string = NULL, *id_connection = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &as_string) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!as_string) {
		PHALCON_ALLOC_ZVAL_MM(as_string);
		ZVAL_BOOL(as_string, 0);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(as_string)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "strval", id_connection);
		RETURN_CTOR(r0);
	} else {
		
		RETURN_CCTOR(id_connection);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Escapes a value to avoid SQL injections
 *
 * @param string $str
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, escapeString){

	zval *str = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "pg_escape_string", t0, str);
	RETURN_CTOR(r0);
}

/**
 * Bind params to SQL select
 *
 * @param string $sqlSelect
 * @param array $params
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, bindParams){

	zval *sql_select = NULL, *params = NULL, *select = NULL, *id_connection = NULL;
	zval *bind_value = NULL, *index = NULL, *value = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_select, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, params TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_CPY_WRT(select, sql_select);
		
		PHALCON_INIT_VAR(id_connection);
		phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
		if (phalcon_valid_foreach(params TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(params);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_32b0_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_32b0_0;
			} else {
				PHALCON_INIT_VAR(index);
				PHALCON_GET_FOREACH_KEY(index, ah0, hp0);
			}
			PHALCON_INIT_VAR(bind_value);
			ZVAL_ZVAL(bind_value, *hd, 1, 0);
			PHALCON_INIT_VAR(r1);
			PHALCON_CALL_FUNC_PARAMS_1(r1, "is_numeric", bind_value);
			if (zend_is_true(r1)) {
				PHALCON_CPY_WRT(value, bind_value);
			} else {
				PHALCON_INIT_VAR(r2);
				PHALCON_CALL_FUNC_PARAMS_2(r2, "pg_escape_string", id_connection, bind_value);
				PHALCON_INIT_VAR(value);
				PHALCON_CONCAT_SVS(value, "!", r2, "!");
			}
			if (Z_TYPE_P(index) == IS_LONG) {
				PHALCON_INIT_VAR(r3);
				PHALCON_CONCAT_SV(r3, "?", index);
				PHALCON_INIT_VAR(r4);
				phalcon_fast_str_replace(r4, r3, value, select TSRMLS_CC);
				PHALCON_CPY_WRT(select, r4);
			} else {
				if (Z_TYPE_P(index) == IS_STRING) {
					PHALCON_INIT_VAR(r5);
					PHALCON_CONCAT_SVS(r5, ":", index, ":");
					PHALCON_INIT_VAR(r6);
					phalcon_fast_str_replace(r6, r5, value, select TSRMLS_CC);
					PHALCON_CPY_WRT(select, r6);
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind parameter");
					return;
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_32b0_0;
			fee_32b0_0:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "!", 1);
		
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "'", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		phalcon_fast_str_replace(r7, c0, c1, select TSRMLS_CC);
		RETURN_CTOR(r7);
	}
	
	RETURN_CCTOR(sql_select);
}

/**
 * Returns last error message from PostgreSQL
 *
 * @param string $errorString
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, error){

	zval *error_string = NULL, *id_connection = NULL, *error_message = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &error_string) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!error_string) {
		PHALCON_ALLOC_ZVAL_MM(error_string);
		ZVAL_NULL(error_string);
	}
	
	PHALCON_INIT_VAR(id_connection);
	phalcon_read_property(&id_connection, this_ptr, SL("_idConnection"), PH_NOISY_CC);
	if (zend_is_true(id_connection)) {
		PHALCON_INIT_VAR(error_message);
		PHALCON_CALL_FUNC_PARAMS_1(error_message, "pg_last_error", id_connection);
	} else {
		PHALCON_INIT_VAR(error_message);
		PHALCON_CALL_FUNC(error_message, "pg_last_error");
	}
	
	PHALCON_INIT_VAR(error_message);
	PHALCON_CONCAT_SVSV(error_message, "\"", error_message, "\" ", error_string);
	phalcon_update_property_zval(this_ptr, SL("_lastError"), error_message TSRMLS_CC);
	
	RETURN_CCTOR(error_message);
}

/**
 * Returns last error code from PostgreSQL
 *
 * @param string $errorString
 * @param resurce $resultQuery
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, noError){

	zval *result_query = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &result_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!result_query) {
		PHALCON_ALLOC_ZVAL_MM(result_query);
		ZVAL_NULL(result_query);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_LONG(0);
}

/**
 * Returns insert id for the auto_increment column inserted in the last SQL statement
 *
 * @param string $table
 * @param string $primaryKey
 * @param string $sequenceName
 * @return int
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, lastInsertId){


	
}

/**
 * Gets a list of columns
 *
 * @param array $columnList
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, getColumnList){

	zval *column_list = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\db\\dialect\\postgresql", "getcolumnlist", column_list);
	RETURN_CTOR(r0);
}

/**
 * Appends a LIMIT clause to $sqlQuery argument
 *
 * @param string $sqlQuery
 * @param int $number
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, limit){

	zval *sql_query = NULL, *number = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\db\\dialect\\postgresql", "limit", sql_query, number);
	RETURN_CTOR(r0);
}

/**
 * Generates SQL checking for the existence of a schema.table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, tableExists){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL, *num = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\postgresql", "tableexists", table_name, schema_name);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 2);
	
	PHALCON_INIT_VAR(num);
	PHALCON_CALL_METHOD_PARAMS_2(num, this_ptr, "fetchone", sql, c0, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_long(&r0, num, 0, PH_NOISY_CC);
	
	RETURN_CCTOR(r0);
}

/**
 * Generates SQL checking for the existence of a schema.view
 *
 * @param string $viewName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, viewExists){

	zval *view_name = NULL, *schema_name = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &view_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "tableexists", view_name, schema_name, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Devuelve un FOR UPDATE valido para un SELECT del RBDM
 *
 * @param string $sqlQuery
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, forUpdate){

	zval *sql_query = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VS(r0, sql_query, " FOR UPDATE");
	
	RETURN_CTOR(r0);
}

/**
 * Devuelve un SHARED LOCK valido para un SELECT del RBDM
 *
 * @param string $sqlQuery
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, sharedLock){

	zval *sql_query = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VS(r0, sql_query, " LOCK IN SHARE MODE");
	
	RETURN_CTOR(r0);
}

/**
 * Creates a table using PostgreSQL SQL
 *
 * @param string $tableName
 * @param string $schemaName
 * @param array $definition
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, createTable){

	zval *table_name = NULL, *schema_name = NULL, *definition = NULL;
	zval *sql = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_db_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVS(r0, "Invalid definition to create the table '", table_name, "'");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SL("columns")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, definition, SL("columns"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_fast_count(r2, r1 TSRMLS_CC);
	if (!zend_is_true(r2)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "createtable", table_name, schema_name, definition);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD_PARAMS_1(r3, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r3);
}

/**
 * Drops a table from a schema/database
 *
 * @param string $tableName
 * @param   string $schemaName
 * @param boolean $ifExists
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, dropTable){

	zval *table_name = NULL, *schema_name = NULL, *if_exists = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_ALLOC_ZVAL_MM(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "droptable", table_name, schema_name, if_exists);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a column to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Column $column
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, addColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "addcolumn", table_name, schema_name, column);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Modifies a table column based on a definition
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Column $column
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, modifyColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "modifycolumn", table_name, schema_name, column);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops a column from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $columnName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, dropColumn){

	zval *table_name = NULL, *schema_name = NULL, *column_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "dropcolumn", table_name, schema_name, column_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param DbIndex $index
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, addIndex){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "addindex", table_name, schema_name, index);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drop an index from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $indexName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, dropIndex){

	zval *table_name = NULL, *schema_name = NULL, *index_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "dropindex", table_name, schema_name, index_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a primary key to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Index $index
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, addPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "addprimarykey", table_name, schema_name, index);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops primary key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, dropPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\postgresql", "dropprimarykey", table_name, schema_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Adds a foreign key to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Reference $reference
 * @return boolean true
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, addForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference = NULL, *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "addforeignkey", table_name, schema_name, reference);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Drops a foreign key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $referenceName
 * @return boolean true
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, dropForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_3(sql, "phalcon\\db\\dialect\\postgresql", "dropforeignkey", table_name, schema_name, reference_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "query", sql, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Returns the SQL column definition from a column
 *
 * @param Phalcon_Db_Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, getColumnDefinition){

	zval *column = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_1(r0, "phalcon\\db\\dialect\\postgresql", "getcolumndefinition", column);
	RETURN_CTOR(r0);
}

/**
 * Generates SQL describing a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, describeTable){

	zval *table = NULL, *schema = NULL, *sql = NULL, *describe = NULL, *final_describe = NULL;
	zval *field = NULL;
	zval *c0 = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_2(sql, "phalcon\\db\\dialect\\postgresql", "describetable", table, schema);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 2);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, c0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(final_describe);
	array_init(final_describe);
	if (phalcon_valid_foreach(describe TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(describe);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_32b0_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_32b0_1;
		}
		
		PHALCON_INIT_VAR(field);
		ZVAL_ZVAL(field, *hd, 1, 0);
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_string(&r0, field, SL("field"), PH_NOISY_CC);
		phalcon_array_update_string(&a0, SL("Field"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch_string(&r1, field, SL("type"), PH_NOISY_CC);
		phalcon_array_update_string(&a0, SL("Type"), &r1, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r2);
		phalcon_array_fetch_string(&r2, field, SL("null"), PH_NOISY_CC);
		phalcon_array_update_string(&a0, SL("Null"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r3);
		phalcon_array_fetch_string(&r3, field, SL("key"), PH_NOISY_CC);
		phalcon_array_update_string(&a0, SL("Key"), &r3, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(r4);
		phalcon_array_fetch_string(&r4, field, SL("extra"), PH_NOISY_CC);
		phalcon_array_update_string(&a0, SL("Extra"), &r4, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&final_describe, a0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_32b0_1;
		fee_32b0_1:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(final_describe);
}

/**
 * List all tables on a database
 *
 * @param string $schemaName
 * @return array
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, listTables){

	zval *schema_name = NULL, *sql = NULL, *tables = NULL, *all_tables = NULL, *table = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_STATIC_PARAMS_1(sql, "phalcon\\db\\dialect\\postgresql", "listtables", schema_name);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 2);
	
	PHALCON_INIT_VAR(tables);
	PHALCON_CALL_METHOD_PARAMS_2(tables, this_ptr, "fetchall", sql, c0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(all_tables);
	array_init(all_tables);
	if (phalcon_valid_foreach(tables TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(tables);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_32b0_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_32b0_2;
		}
		
		PHALCON_INIT_VAR(table);
		ZVAL_ZVAL(table, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_long(&r0, table, 0, PH_NOISY_CC);
		phalcon_array_append(&all_tables, r0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_32b0_2;
		fee_32b0_2:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(all_tables);
}

/**
 * Returns a database date formatted
 *
 * @param string $date
 * @param string $format
 * @return string
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, getDateUsingFormat){


	
}

/**
 * Lists table indexes
 *
 * @param string $table
 * @param string $schema
 * @return Phalcon_Db_Index[]
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, describeIndexes){


	
}

/**
 * Lists table references
 *
 * @param string $table
 * @param string $schema
 * @return Phalcon_Db_Reference[]
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, describeReferences){


	
}

/**
 * Gets creation options from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return array
 */
PHP_METHOD(Phalcon_Db_Adapter_Postgresql, tableOptions){


	
}

/* ------ Finished File: \db\adapter\postgresql.c ------ */

/* ------ Starting File: \db\profiler\item.c ------ */
/**
 * Phalcon\Db\Profiler\Item
 *
 * This class identifies each profile in a Phalcon\Db\Profiler
 *
 */

/**
 * Sets the SQL statement related to the profile
 *
 * @param string $sqlStatement
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLStatement){

	zval *sql_statement = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_sqlStatement"), sql_statement TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the SQL statement related to the profile
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLStatement){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_sqlStatement"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets the timestamp on when the profile started
 *
 * @param int $initialTime
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, setInitialTime){

	zval *initial_time = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &initial_time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_initialTime"), initial_time TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets the timestamp on when the profile ended
 *
 * @param int $finalTime
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, setFinalTime){

	zval *final_time = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &final_time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_finalTime"), final_time TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the initial time in milseconds on when the profile started
 *
 * @return double
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, getInitialTime){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_initialTime"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the initial time in milseconds on when the profile ended
 *
 * @return double
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, getFinalTime){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_finalTime"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the total time in seconds spent by the profile
 *
 * @return double
 */
PHP_METHOD(Phalcon_Db_Profiler_Item, getTotalElapsedSeconds){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_finalTime"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_initialTime"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	sub_function(r0, t0, t1 TSRMLS_CC);
	
	RETURN_CTOR(r0);
}

/* ------ Finished File: \db\profiler\item.c ------ */

/* ------ Starting File: \db\rawvalue.c ------ */
/**
 * Phalcon\Db\RawValue
 *
 * This class lets to insert/update raw data without quoting or formating.
 *
 *
 */

/**
 * Phalcon_Db_RawValue constructor
 *
 * @param string $value
 */
PHP_METHOD(Phalcon_Db_RawValue, __construct){

	zval *value = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_value"), value TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns internal raw value without quoting or formating
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_RawValue, getValue){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_value"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Magic method __toString returns raw value without quoting or formating
 */
PHP_METHOD(Phalcon_Db_RawValue, __toString){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_value"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \db\rawvalue.c ------ */

/* ------ Starting File: \db\column.c ------ */
/**
 * Phalcon_Db_Column
 *
 * Allows to define columns to be used on create or alter table operations
 *
 *
 *
 */

/**
 * Phalcon_Db_Column constructor
 *
 * @param string $columnName
 * @param array $definition
 */
PHP_METHOD(Phalcon_Db_Column, __construct){

	zval *column_name = NULL, *definition = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &column_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_columnName"), column_name TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SL("type")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, definition, SL("type"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_type"), r0 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type is required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("notNull")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, definition, SL("notNull"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_notNull"), r1 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("size")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, definition, SL("size"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_size"), r2 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("scale")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 3);
		PHALCON_ALLOC_ZVAL_MM(r3);
		is_equal_function(r3, t0, t1 TSRMLS_CC);
		if (zend_is_true(r3)) {
			PHALCON_ALLOC_ZVAL_MM(r4);
			phalcon_array_fetch_string(&r4, definition, SL("scale"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_scale"), r4 TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type does not support scale parameter");
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("unsigned")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r5);
		phalcon_array_fetch_string(&r5, definition, SL("unsigned"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_unsigned"), r5 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("autoIncrement")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_type"), PH_NOISY_CC);
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 0);
		PHALCON_ALLOC_ZVAL_MM(r6);
		is_equal_function(r6, t2, t3 TSRMLS_CC);
		if (zend_is_true(r6)) {
			PHALCON_ALLOC_ZVAL_MM(r7);
			phalcon_array_fetch_string(&r7, definition, SL("autoIncrement"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_autoIncrement"), r7 TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type cannot be auto-increment");
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("first")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r8);
		phalcon_array_fetch_string(&r8, definition, SL("first"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_first"), r8 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("after")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r9);
		phalcon_array_fetch_string(&r9, definition, SL("after"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_after"), r9 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns schema's table related to column
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Column, getSchemaName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_schemaName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns column name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Column, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_columnName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns column type
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Column, getType){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns column size
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Column, getSize){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_size"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns column scale
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Column, getScale){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_scale"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns true if number column is unsigned
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Column, isUnsigned){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_unsigned"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Not null
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Column, isNotNull){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_notNull"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Auto-Increment
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Column, isAutoIncrement){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_autoIncrement"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Check whether column have first position in table
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Column, isFirst){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_first"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Check whether field absolute to position in table
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Column, getAfterPosition){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_after"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \db\column.c ------ */

/* ------ Starting File: \db\index.c ------ */
/**
 * Phalcon\Db\Index
 *
 * Allows to define indexes to be used on tables. Indexes are a common way
 * to enhance database performance. An index allows the database server to find
 * and retrieve specific rows much faster than it could do without an index.
 *
 * 
 *
 */

/**
 * Phalcon\Db\Index constructor
 *
 * @param string $indexName
 * @param array $columns
 */
PHP_METHOD(Phalcon_Db_Index, __construct){

	zval *index_name = NULL, *columns = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index_name, &columns) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_indexName"), index_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_columns"), columns TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the index name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Db_Index, getName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_indexName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Gets the columns that comprends the index
 *
 * @return array
 */
PHP_METHOD(Phalcon_Db_Index, getColumns){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_columns"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Restore a Phalcon\Db\Index object from export
 *
 * @param array $data
 * @return Phalcon\Db\Index
 */
PHP_METHOD(Phalcon_Db_Index, __set_state){

	zval *data = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(data, SL("_indexName")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_indexName parameter is required");
		return;
	}
	eval_int = phalcon_array_isset_string(data, SL("_columns")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_columns parameter is required");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_db_index_ce);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, data, SL("_indexName"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, data, SL("_columns"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", r0, r1, PH_CHECK);
	
	RETURN_CTOR(i0);
}

/* ------ Finished File: \db\index.c ------ */

/* ------ Starting File: \db\result\mysql.c ------ */
/**
 * Phalcon\Db\Result\Mysql
 *
 * Encapsulates the resultset internals
 *
 * 
 */

/**
 * Phalcon_Db_Result_Mysql constructor
 *
 * @param object $result
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, __construct){

	zval *result = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &result) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(result) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid mysql result supplied to Phalcon_Db_Result_Mysql");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_result"), result TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns an array of strings that corresponds to the fetched row, or FALSE if there are no more rows.
 * This method is affected by the active fetch flag set using Phalcon_Db_Result_Mysql::setFetchMode
 *
 * @param resource $resultQuery
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, fetchArray){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_fetchMode"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "mysqli_fetch_array", t0, t1);
	RETURN_CTOR(r0);
}

/**
 * Gets number of rows returned by a resulset
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, numRows){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "mysqli_num_rows", t0);
	RETURN_CTOR(r0);
}

/**
 * Moves internal resulset cursor to another position letting us to fetch a certain row
 *
 * @param int $number
 * @return int
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, dataSeek){

	zval *number = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "mysqli_data_seek", t0, number);
	RETURN_CTOR(r0);
}

/**
 * Changes the fetching mode affecting Phalcon_Db_Mysql::fetchArray
 *
 * @param int $fetchMode
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, setFetchMode){

	zval *fetch_mode = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, fetch_mode, t0 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 1);
		phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t1 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 2);
		PHALCON_ALLOC_ZVAL_MM(r1);
		is_equal_function(r1, fetch_mode, t2 TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(t3);
			ZVAL_LONG(t3, 3);
			phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t3 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(t4);
			ZVAL_LONG(t4, 3);
			PHALCON_ALLOC_ZVAL_MM(r2);
			is_equal_function(r2, fetch_mode, t4 TSRMLS_CC);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(t5);
				ZVAL_LONG(t5, 2);
				phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t5 TSRMLS_CC);
			}
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Gets the internal MySQLi result object
 *
 * @return mysqli_result
 */
PHP_METHOD(Phalcon_Db_Result_Mysql, getInternalResult){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \db\result\mysql.c ------ */

/* ------ Starting File: \db\result\postgresql.c ------ */
/**
 * Phalcon_Db_Result_Postgresql
 *
 * Encapsulates the resultset internals
 *
 * 
 */

/**
 * Phalcon_Db_Result_Postgresql constructor
 *
 * @param resource $result
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, __construct){

	zval *result = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &result) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_resource", result);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid pgsql result supplied to Phalcon_Db_Result_Postgresql");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_result"), result TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns an array of strings that corresponds to the fetched row, or FALSE if there are no more rows.
 * This method is affected by the active fetch flag set using Phalcon_Db_Result_Postgresql::setFetchMode
 *
 * @param resource $resultQuery
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, fetchArray){

	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_INIT_VAR(c0);
	ZVAL_NULL(c0);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_fetchMode"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_3(r0, "pg_fetch_array", t0, c0, t1);
	RETURN_CTOR(r0);
}

/**
 * Gets number of rows returned by a resulset
 *
 * @return int
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, numRows){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "pg_num_rows", t0);
	RETURN_CTOR(r0);
}

/**
 * Moves internal resulset cursor to another position letting us to fetch a certain row
 *
 * @param int $number
 * @return int
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, dataSeek){

	zval *number = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "pg_result_seek", t0, number);
	RETURN_CTOR(r0);
}

/**
 * Changes the fetching mode affecting Phalcon_Db_Postgresql::fetchArray
 *
 * @param int $fetchMode
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, setFetchMode){

	zval *fetch_mode = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, fetch_mode, t0 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 1);
		phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t1 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 2);
		PHALCON_ALLOC_ZVAL_MM(r1);
		is_equal_function(r1, fetch_mode, t2 TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(t3);
			ZVAL_LONG(t3, 3);
			phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t3 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(t4);
			ZVAL_LONG(t4, 3);
			PHALCON_ALLOC_ZVAL_MM(r2);
			is_equal_function(r2, fetch_mode, t4 TSRMLS_CC);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(t5);
				ZVAL_LONG(t5, 2);
				phalcon_update_property_zval(this_ptr, SL("_fetchMode"), t5 TSRMLS_CC);
			}
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Gets the internal MySQLi result object
 *
 * @return mysqli_result
 */
PHP_METHOD(Phalcon_Db_Result_Postgresql, getInternalResult){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_result"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \db\result\postgresql.c ------ */

/* ------ Starting File: \db\dialect\mysql.c ------ */
/**
 * Phalcon\Db\Dialect\Mysql
 *
 * Generates database specific SQL for the MySQL RBDM
 */

/**
 * Generates the SQL for a MySQL LIMIT clause
 *
 * @param string $sqlQuery
 * @param int $number
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, limit){

	zval *sql_query = NULL, *number = NULL, *limit = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_numeric", number);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(limit);
		PHALCON_CALL_FUNC_PARAMS_1(limit, "intval", number);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_VSV(r1, sql_query, " LIMIT ", limit);
		
		RETURN_CTOR(r1);
	} else {
		
		RETURN_CCTOR(sql_query);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets a list of columns
 *
 * @param array $columnList
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnList){

	zval *column_list = NULL, *str_list = NULL, *column = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	if (phalcon_valid_foreach(column_list TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(column_list);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_52be_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_52be_0;
		}
		
		PHALCON_INIT_VAR(column);
		ZVAL_ZVAL(column, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		PHALCON_CONCAT_SVS(r0, "`", column, "`");
		phalcon_array_append(&str_list, r0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_52be_0;
		fee_52be_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ", ", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_join(r1, c0, str_list TSRMLS_CC);
	RETURN_CTOR(r1);
}

/**
 * Gets the column name in MySQL
 *
 * @param Phalcon\Db\Column $column
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnDefinition){

	zval *column = NULL, *size = NULL, *column_sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an instance of Phalcon_Db_Column");
		return;
	}
	
	PHALCON_INIT_VAR(size);
	PHALCON_CALL_METHOD(size, column, "getsize", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "gettype", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "INT(", size, ")");
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_METHOD(r2, column, "isunsigned", PH_NO_CHECK);
		if (zend_is_true(r2)) {
			PHALCON_INIT_VAR(t1);
			ZVAL_STRING(t1, " UNSIGNED", 1);
			phalcon_concat_self(&column_sql, t1 TSRMLS_CC);
		}
		
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_equal_function(r3, r0, t2 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "DATE", 1);
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 2);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_equal_function(r4, r0, t3 TSRMLS_CC);
	if (zend_is_true(r4)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "VARCHAR(", size, ")");
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t4);
	ZVAL_LONG(t4, 3);
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	is_equal_function(r5, r0, t4 TSRMLS_CC);
	if (zend_is_true(r5)) {
		PHALCON_ALLOC_ZVAL_MM(r6);
		PHALCON_CALL_METHOD(r6, column, "getscale", PH_NO_CHECK);
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVSVS(column_sql, "DECIMAL(", size, ",", r6, ")");
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		PHALCON_CALL_METHOD(r7, column, "isunsigned", PH_NO_CHECK);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(t5);
			ZVAL_STRING(t5, " UNSIGNED", 1);
			phalcon_concat_self(&column_sql, t5 TSRMLS_CC);
		}
		
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t6);
	ZVAL_LONG(t6, 4);
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	is_equal_function(r8, r0, t6 TSRMLS_CC);
	if (zend_is_true(r8)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "DATETIME", 1);
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t7);
	ZVAL_LONG(t7, 5);
	
	PHALCON_ALLOC_ZVAL_MM(r9);
	is_equal_function(r9, r0, t7 TSRMLS_CC);
	if (zend_is_true(r9)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHAR(", size, ")");
		goto se_52be_1;
	}
	
	PHALCON_INIT_VAR(t8);
	ZVAL_LONG(t8, 6);
	
	PHALCON_ALLOC_ZVAL_MM(r10);
	is_equal_function(r10, r0, t8 TSRMLS_CC);
	if (zend_is_true(r10)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "TEXT", 1);
		goto se_52be_1;
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized MySQL data type");
	return;
	se_52be_1:
	
	RETURN_CTOR(column_sql);
}

/**
 * Generates SQL to add a column to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, addColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL, *after_position = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon_Db_Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumndefinition", column);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVSV(r2, "`", r0, "` ", r1);
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, " NOT NULL", 1);
		phalcon_concat_self(&sql, t0 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CALL_METHOD(r4, column, "isfirst", PH_NO_CHECK);
	if (zend_is_true(r4)) {
		PHALCON_INIT_VAR(t1);
		ZVAL_STRING(t1, " FIRST", 1);
		phalcon_concat_self(&sql, t1 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(after_position);
		PHALCON_CALL_METHOD(after_position, column, "getafterposition", PH_NO_CHECK);
		if (zend_is_true(after_position)) {
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CONCAT_SV(r5, " AFTER ", after_position);
			phalcon_concat_self(&sql, r5 TSRMLS_CC);
		}
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to modify a column in a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, modifyColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon_Db_Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` MODIFY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` MODIFY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumndefinition", column);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVSV(r2, "`", r0, "` ", r1);
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, " NOT NULL", 1);
		phalcon_concat_self(&sql, t0 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete a column from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $columnName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropColumn){

	zval *table_name = NULL, *schema_name = NULL, *column_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP COLUMN ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP COLUMN ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "`", column_name, "`");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Index $index
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, addIndex){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon\\Db\\Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD INDEX ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD INDEX ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, index, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_SELF_PARAMS_1(r2, this_ptr, "getcolumnlist", r1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CONCAT_SVSVS(r3, "`", r0, "` (", r2, ")");
	phalcon_concat_self(&sql, r3 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
  * Generates SQL to delete an index from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $indexName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropIndex){

	zval *table_name = NULL, *schema_name = NULL, *index_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP INDEX ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP INDEX ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "`", index_name, "`");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add the primary key to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Index $index
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, addPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon\\Db\\Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD PRIMARY KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD PRIMARY KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumnlist", r0);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVS(r2, "(", r1, ")");
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete primary key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP PRIMARY KEY");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP PRIMARY KEY");
	}
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Reference $reference
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, addForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference = NULL, *sql = NULL;
	zval *referenced_schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(reference) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Reference parameter must be an instance of Phalcon\\Db\\Reference");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD FOREIGN KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD FOREIGN KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, reference, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, reference, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_SELF_PARAMS_1(r2, this_ptr, "getcolumnlist", r1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CONCAT_SVSVS(r3, "`", r0, "`(", r2, ") REFERENCES ");
	phalcon_concat_self(&sql, r3 TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_schema);
	PHALCON_CALL_METHOD(referenced_schema, reference, "getreferencedschema", PH_NO_CHECK);
	if (zend_is_true(referenced_schema)) {
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CONCAT_SVS(r4, "`", referenced_schema, "`.");
		phalcon_concat_self(&sql, r4 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	PHALCON_CALL_METHOD(r5, reference, "getreferencedtable", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	PHALCON_CALL_METHOD(r6, reference, "getreferencedcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	PHALCON_CALL_SELF_PARAMS_1(r7, this_ptr, "getcolumnlist", r6);
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	PHALCON_CONCAT_SVSVS(r8, "`", r5, "`(", r7, ")");
	phalcon_concat_self(&sql, r8 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete a foreign key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $referenceName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP FOREIGN KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP FOREIGN KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "`", reference_name, "`");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add the table creation options
 *
 * @param array $definition
 * @return array
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, _getTableOptions){

	zval *definition = NULL, *table_options = NULL, *engine = NULL, *auto_increment = NULL;
	zval *table_collation = NULL, *collation_parts = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table_options);
	array_init(table_options);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r0, SL("ENGINE")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(engine);
		phalcon_array_fetch_string(&engine, r1, SL("ENGINE"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, definition, SL("options"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_array_fetch_string(&r3, r2, SL("ENGINE"), PH_NOISY_CC);
		if (zend_is_true(r3)) {
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CONCAT_SV(r4, "ENGINE=", engine);
			phalcon_array_append(&table_options, r4, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	phalcon_array_fetch_string(&r5, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r5, SL("AUTO_INCREMENT")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_array_fetch_string(&r6, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(auto_increment);
		phalcon_array_fetch_string(&auto_increment, r6, SL("AUTO_INCREMENT"), PH_NOISY_CC);
		if (zend_is_true(auto_increment)) {
			PHALCON_ALLOC_ZVAL_MM(r7);
			PHALCON_CONCAT_SV(r7, "AUTO_INCREMENT=", auto_increment);
			phalcon_array_append(&table_options, r7, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	phalcon_array_fetch_string(&r8, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r8, SL("TABLE_COLLATION")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r9);
		phalcon_array_fetch_string(&r9, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(table_collation);
		phalcon_array_fetch_string(&table_collation, r9, SL("TABLE_COLLATION"), PH_NOISY_CC);
		if (zend_is_true(table_collation)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "_", 1);
			PHALCON_INIT_VAR(collation_parts);
			phalcon_fast_explode(collation_parts, c0, table_collation TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r10);
			phalcon_array_fetch_long(&r10, collation_parts, 0, PH_NOISY_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r11);
			PHALCON_CONCAT_SV(r11, "DEFAULT CHARSET=", r10);
			phalcon_array_append(&table_options, r11, PH_SEPARATE TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r12);
			PHALCON_CONCAT_SV(r12, "COLLATE=", table_collation);
			phalcon_array_append(&table_options, r12, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r13);
	phalcon_fast_count(r13, table_options TSRMLS_CC);
	if (zend_is_true(r13)) {
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, " ", 1);
		PHALCON_ALLOC_ZVAL_MM(r14);
		phalcon_fast_join(r14, c1, table_options TSRMLS_CC);
		RETURN_CTOR(r14);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Generates SQL to create a table in MySQL
 *
 * @param string $tableName
 * @param string $schemaName
 * @param array $definition
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, createTable){

	zval *table_name = NULL, *schema_name = NULL, *definition = NULL;
	zval *table = NULL, *temporary = NULL, *sql = NULL, *create_lines = NULL, *column = NULL;
	zval *column_line = NULL, *index = NULL, *index_name = NULL, *column_list = NULL;
	zval *reference = NULL, *reference_sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL, *r19 = NULL, *r20 = NULL;
	zval *r21 = NULL, *r22 = NULL, *r23 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	
	PHALCON_INIT_VAR(temporary);
	ZVAL_BOOL(temporary, 0);
	eval_int = phalcon_array_isset_string(definition, SL("options")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(r0, SL("temporary")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_string(&r2, r1, SL("temporary"), PH_NOISY_CC);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(temporary);
				ZVAL_BOOL(temporary, 1);
			}
		}
	}
	
	if (zend_is_true(temporary)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TEMPORARY TABLE ", table, " (\n\t");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TABLE ", table, " (\n\t");
	}
	
	PHALCON_INIT_VAR(create_lines);
	array_init(create_lines);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	phalcon_array_fetch_string(&r3, definition, SL("columns"), PH_NOISY_CC);
	if (phalcon_valid_foreach(r3 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(r3);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_52be_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_52be_2;
		}
		
		PHALCON_INIT_VAR(column);
		ZVAL_ZVAL(column, *hd, 1, 0);
		PHALCON_INIT_VAR(r4);
		PHALCON_CALL_METHOD(r4, column, "getname", PH_NO_CHECK);
		PHALCON_INIT_VAR(r5);
		PHALCON_CALL_SELF_PARAMS_1(r5, this_ptr, "getcolumndefinition", column);
		PHALCON_INIT_VAR(column_line);
		PHALCON_CONCAT_SVSV(column_line, "`", r4, "` ", r5);
		
		PHALCON_INIT_VAR(r6);
		PHALCON_CALL_METHOD(r6, column, "isnotnull", PH_NO_CHECK);
		if (zend_is_true(r6)) {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, " NOT NULL", 1);
			phalcon_concat_self(&column_line, t0 TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(r7);
		PHALCON_CALL_METHOD(r7, column, "isautoincrement", PH_NO_CHECK);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(t1);
			ZVAL_STRING(t1, " AUTO_INCREMENT", 1);
			phalcon_concat_self(&column_line, t1 TSRMLS_CC);
		}
		
		phalcon_array_append(&create_lines, column_line, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_52be_2;
		fee_52be_2:
		if(0){}
	} else {
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SL("indexes")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r8);
		phalcon_array_fetch_string(&r8, definition, SL("indexes"), PH_NOISY_CC);
		if (phalcon_valid_foreach(r8 TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(r8);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_52be_3:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_52be_3;
			}
			PHALCON_INIT_VAR(index);
			ZVAL_ZVAL(index, *hd, 1, 0);
			PHALCON_INIT_VAR(index_name);
			PHALCON_CALL_METHOD(index_name, index, "getname", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r9);
			PHALCON_CALL_METHOD(r9, index, "getcolumns", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(column_list);
			PHALCON_CALL_SELF_PARAMS_1(column_list, this_ptr, "getcolumnlist", r9);
			if (PHALCON_COMPARE_STRING(index_name, "PRIMARY")) {
				PHALCON_INIT_VAR(r10);
				PHALCON_CONCAT_SVS(r10, "PRIMARY KEY (", column_list, ")");
				phalcon_array_append(&create_lines, r10, PH_SEPARATE TSRMLS_CC);
			} else {
				PHALCON_INIT_VAR(r11);
				PHALCON_CONCAT_SVSVS(r11, "KEY `", index_name, "` (", column_list, ")");
				phalcon_array_append(&create_lines, r11, PH_SEPARATE TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_52be_3;
			fee_52be_3:
			if(0){}
		} else {
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("references")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r12);
		phalcon_array_fetch_string(&r12, definition, SL("references"), PH_NOISY_CC);
		if (phalcon_valid_foreach(r12 TSRMLS_CC)) {
			ah2 = Z_ARRVAL_P(r12);
			zend_hash_internal_pointer_reset_ex(ah2, &hp2);
			fes_52be_4:
			if(zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS){
				goto fee_52be_4;
			}
			PHALCON_INIT_VAR(reference);
			ZVAL_ZVAL(reference, *hd, 1, 0);
			PHALCON_INIT_VAR(r13);
			PHALCON_CALL_METHOD(r13, reference, "getname", PH_NO_CHECK);
			PHALCON_INIT_VAR(r14);
			PHALCON_CALL_METHOD(r14, reference, "getcolumns", PH_NO_CHECK);
			PHALCON_INIT_VAR(r15);
			PHALCON_CALL_SELF_PARAMS_1(r15, this_ptr, "getcolumnlist", r14);
			PHALCON_INIT_VAR(reference_sql);
			PHALCON_CONCAT_SVSV(reference_sql, "CONSTRAINT `", r13, "` FOREIGN KEY (", r15);
			
			PHALCON_INIT_VAR(r16);
			PHALCON_CALL_METHOD(r16, reference, "getreferencedtable", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r17);
			PHALCON_CALL_METHOD(r17, reference, "getreferencedcolumns", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r18);
			PHALCON_CALL_SELF_PARAMS_1(r18, this_ptr, "getcolumnlist", r17);
			
			PHALCON_INIT_VAR(r19);
			PHALCON_CONCAT_SVSVS(r19, ") REFERENCES `", r16, "`(", r18, ")");
			phalcon_concat_self(&reference_sql, r19 TSRMLS_CC);
			phalcon_array_append(&create_lines, reference_sql, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah2, &hp2);
			goto fes_52be_4;
			fee_52be_4:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ",\n\t", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r20);
	phalcon_fast_join(r20, c0, create_lines TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r21);
	PHALCON_CONCAT_VS(r21, r20, "\n)");
	phalcon_concat_self(&sql, r21 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SL("options")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r22);
		PHALCON_CALL_SELF_PARAMS_1(r22, this_ptr, "_gettableoptions", definition);
		PHALCON_ALLOC_ZVAL_MM(r23);
		PHALCON_CONCAT_SV(r23, " ", r22);
		phalcon_concat_self(&sql, r23 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to drop a table
 *
 * @param  string $tableName
 * @param  string $schemaName
 * @param  boolean $ifExists
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropTable){

	zval *table_name = NULL, *schema_name = NULL, *if_exists = NULL, *table = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_ALLOC_ZVAL_MM(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	if (zend_is_true(if_exists)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SV(r0, "DROP TABLE IF EXISTS ", table);
		
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SV(r1, "DROP TABLE ", table);
		
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Generates SQL checking for the existence of a schema.table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableExists){

	zval *table_name = NULL, *schema_name = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "SELECT COUNT(*) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`= '", table_name, "' AND `TABLE_SCHEMA`='", schema_name, "'");
		
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "SELECT COUNT(*) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`='", table_name, "'");
		
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Generates SQL describing a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeTable){

	zval *table = NULL, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "DESCRIBE `", schema, "`.`", table, "`");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "DESCRIBE `", table, "`");
	}
	
	RETURN_CTOR(sql);
}

/**
 * List all tables on database
 *
 * @param       string $schemaName
 * @return      array
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, listTables){

	zval *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SHOW TABLES FROM `", schema_name, "`");
	} else {
		PHALCON_INIT_VAR(sql);
		ZVAL_STRING(sql, "SHOW TABLES", 1);
	}
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to query indexes on a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeIndexes){

	zval *table = NULL, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SHOW INDEXES FROM `", schema, "`.`", table, "`");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SHOW INDEXES FROM `", table, "`");
	}
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to query foreign keys on a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeReferences){

	zval *table = NULL, *schema = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,REFERENCED_TABLE_SCHEMA,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME\n\t\t\tFROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_NAME IS NOT NULL AND ", 1);
	if (zend_is_true(schema)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "CONSTRAINT_SCHEMA = \"", schema, "\" AND TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r1 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates the SQL to describe the table creation options
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableOptions){

	zval *table = NULL, *schema = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLES.TABLE_TYPE,TABLES.AUTO_INCREMENT,TABLES.ENGINE,TABLES.TABLE_COLLATION FROM INFORMATION_SCHEMA.TABLES WHERE ", 1);
	if (zend_is_true(schema)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "TABLES.TABLE_SCHEMA = \"", schema, "\" AND TABLES.TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "TABLES.TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r1 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/* ------ Finished File: \db\dialect\mysql.c ------ */

/* ------ Starting File: \db\dialect\postgresql.c ------ */
/**
 * Phalcon\Db\Dialect\Postgresql
 *
 * Generates database specific SQL for the PostgreSQL RBDM
 */

/**
 * Generates the SQL for a PostgreSQL LIMIT clause
 *
 * @param string $sqlQuery
 * @param int $number
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, limit){

	zval *sql_query = NULL, *number = NULL, *limit = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_numeric", number);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(limit);
		PHALCON_CALL_FUNC_PARAMS_1(limit, "intval", number);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_VSV(r1, sql_query, " LIMIT ", limit);
		
		RETURN_CTOR(r1);
	} else {
		
		RETURN_CCTOR(sql_query);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets a list of columns
 *
 * @param array $columnList
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnList){

	zval *column_list = NULL, *str_list = NULL, *column = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	if (phalcon_valid_foreach(column_list TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(column_list);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_46b6_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_46b6_0;
		}
		
		PHALCON_INIT_VAR(column);
		ZVAL_ZVAL(column, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		PHALCON_CONCAT_SVS(r0, "\"", column, "\"");
		phalcon_array_append(&str_list, r0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_46b6_0;
		fee_46b6_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ", ", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_join(r1, c0, column_list TSRMLS_CC);
	RETURN_CTOR(r1);
}

/**
 * Gets the column name in PostgreSQL
 *
 * @param Phalcon\Db\Column $column
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnDefinition){

	zval *column = NULL, *size = NULL, *column_sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an instance of Phalcon_Db_Column");
		return;
	}
	
	PHALCON_INIT_VAR(size);
	PHALCON_CALL_METHOD(size, column, "getsize", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "gettype", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "INT", 1);
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	is_equal_function(r2, r0, t1 TSRMLS_CC);
	if (zend_is_true(r2)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "DATE", 1);
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 2);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_equal_function(r3, r0, t2 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHARACTER VARYING(", size, ")");
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 3);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_equal_function(r4, r0, t3 TSRMLS_CC);
	if (zend_is_true(r4)) {
		PHALCON_ALLOC_ZVAL_MM(r5);
		PHALCON_CALL_METHOD(r5, column, "getscale", PH_NO_CHECK);
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVSVS(column_sql, "NUMERIC(", size, ",", r5, ")");
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t4);
	ZVAL_LONG(t4, 4);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	is_equal_function(r6, r0, t4 TSRMLS_CC);
	if (zend_is_true(r6)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "TIMESTAMP", 1);
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t5);
	ZVAL_LONG(t5, 5);
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	is_equal_function(r7, r0, t5 TSRMLS_CC);
	if (zend_is_true(r7)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHARACTER(", size, ")");
		goto se_46b6_1;
	}
	
	PHALCON_INIT_VAR(t6);
	ZVAL_LONG(t6, 6);
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	is_equal_function(r8, r0, t6 TSRMLS_CC);
	if (zend_is_true(r8)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "TEXT", 1);
		goto se_46b6_1;
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized PostgreSQL data type");
	return;
	se_46b6_1:
	
	RETURN_CTOR(column_sql);
}

/**
 * Generates SQL to add a column to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon_Db_Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon_Db_Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumndefinition", column);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVSV(r2, "`", r0, "` ", r1);
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, " NOT NULL", 1);
		phalcon_concat_self(&sql, t0 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to modify a column in a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Column $column
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, modifyColumn){

	zval *table_name = NULL, *schema_name = NULL, *column = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon_Db_Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` MODIFY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` MODIFY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, column, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumndefinition", column);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVSV(r2, "`", r0, "` ", r1);
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, " NOT NULL", 1);
		phalcon_concat_self(&sql, t0 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete a column from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $columnName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropColumn){

	zval *table_name = NULL, *schema_name = NULL, *column_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP COLUMN ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP COLUMN ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "`", column_name, "`");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Index $index
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addIndex){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon_Db_Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " ADD INDEX ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " ADD INDEX ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, index, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_SELF_PARAMS_1(r2, this_ptr, "getcolumnlist", r1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CONCAT_SVSVS(r3, "\"", r0, "\" (", r2, ")");
	phalcon_concat_self(&sql, r3 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
  * Generates SQL to delete an index from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $indexName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropIndex){

	zval *table_name = NULL, *schema_name = NULL, *index_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " DROP INDEX ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " DROP INDEX ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "\"", index_name, "\"");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add the primary key to a table
 *
 * @param string\$tableName
 * @param string\$schemaName
 * @param Phalcon_Db_Index $index
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *index = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon_Db_Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " ADD PRIMARY KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " ADD PRIMARY KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_SELF_PARAMS_1(r1, this_ptr, "getcolumnlist", r0);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CONCAT_SVS(r2, "(", r1, ")");
	phalcon_concat_self(&sql, r2 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete primary key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropPrimaryKey){

	zval *table_name = NULL, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " DROP PRIMARY KEY");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " DROP PRIMARY KEY");
	}
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add an index to a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param Phalcon\Db\Reference $reference
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference = NULL, *sql = NULL;
	zval *referenced_schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(reference) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Reference parameter must be an instance of Phalcon\\Db\\Reference");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " ADD FOREIGN KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " ADD FOREIGN KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, reference, "getname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD(r1, reference, "getcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_SELF_PARAMS_1(r2, this_ptr, "getcolumnlist", r1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CONCAT_SVSVS(r3, "\"", r0, "\"(", r2, ") REFERENCES ");
	phalcon_concat_self(&sql, r3 TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_schema);
	PHALCON_CALL_METHOD(referenced_schema, reference, "getreferencedschema", PH_NO_CHECK);
	if (zend_is_true(referenced_schema)) {
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CONCAT_SVS(r4, "", referenced_schema, ".");
		phalcon_concat_self(&sql, r4 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	PHALCON_CALL_METHOD(r5, reference, "getreferencedtable", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	PHALCON_CALL_METHOD(r6, reference, "getreferencedcolumns", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	PHALCON_CALL_SELF_PARAMS_1(r7, this_ptr, "getcolumnlist", r6);
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	PHALCON_CONCAT_SVSVS(r8, "", r5, "(", r7, ")");
	phalcon_concat_self(&sql, r8 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to delete a foreign key from a table
 *
 * @param string $tableName
 * @param string $schemaName
 * @param string $referenceName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropForeignKey){

	zval *table_name = NULL, *schema_name = NULL, *reference_name = NULL;
	zval *sql = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE ", schema_name, ".", table_name, " DROP FOREIGN KEY ");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE ", table_name, " DROP FOREIGN KEY ");
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVS(r0, "\"", reference_name, "\"");
	phalcon_concat_self(&sql, r0 TSRMLS_CC);
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to add the table creation options
 *
 * @param array $definition
 * @return array
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, _getTableOptions){

	zval *definition = NULL, *table_options = NULL, *engine = NULL, *auto_increment = NULL;
	zval *table_collation = NULL, *collation_parts = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table_options);
	array_init(table_options);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r0, SL("ENGINE")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(engine);
		phalcon_array_fetch_string(&engine, r1, SL("ENGINE"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, definition, SL("options"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_array_fetch_string(&r3, r2, SL("ENGINE"), PH_NOISY_CC);
		if (zend_is_true(r3)) {
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CONCAT_SV(r4, "ENGINE=", engine);
			phalcon_array_append(&table_options, r4, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	phalcon_array_fetch_string(&r5, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r5, SL("AUTO_INCREMENT")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_array_fetch_string(&r6, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(auto_increment);
		phalcon_array_fetch_string(&auto_increment, r6, SL("AUTO_INCREMENT"), PH_NOISY_CC);
		if (zend_is_true(auto_increment)) {
			PHALCON_ALLOC_ZVAL_MM(r7);
			PHALCON_CONCAT_SV(r7, "AUTO_INCREMENT=", auto_increment);
			phalcon_array_append(&table_options, r7, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	phalcon_array_fetch_string(&r8, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r8, SL("TABLE_COLLATION")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r9);
		phalcon_array_fetch_string(&r9, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(table_collation);
		phalcon_array_fetch_string(&table_collation, r9, SL("TABLE_COLLATION"), PH_NOISY_CC);
		if (zend_is_true(table_collation)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "_", 1);
			PHALCON_INIT_VAR(collation_parts);
			phalcon_fast_explode(collation_parts, c0, table_collation TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r10);
			phalcon_array_fetch_long(&r10, collation_parts, 0, PH_NOISY_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r11);
			PHALCON_CONCAT_SV(r11, "DEFAULT CHARSET=", r10);
			phalcon_array_append(&table_options, r11, PH_SEPARATE TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r12);
			PHALCON_CONCAT_SV(r12, "COLLATE=", table_collation);
			phalcon_array_append(&table_options, r12, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r13);
	phalcon_fast_count(r13, table_options TSRMLS_CC);
	if (zend_is_true(r13)) {
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, " ", 1);
		PHALCON_ALLOC_ZVAL_MM(r14);
		phalcon_fast_join(r14, c1, table_options TSRMLS_CC);
		RETURN_CTOR(r14);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Generates SQL to create a table in PostgreSQL
 *
 * @param string $tableName
 * @param string $schemaName
 * @param array $definition
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createTable){

	zval *table_name = NULL, *schema_name = NULL, *definition = NULL;
	zval *table = NULL, *temporary = NULL, *sql = NULL, *create_lines = NULL, *column = NULL;
	zval *column_line = NULL, *index = NULL, *index_name = NULL, *column_list = NULL;
	zval *reference = NULL, *reference_sql = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL, *r19 = NULL, *r20 = NULL;
	zval *r21 = NULL, *r22 = NULL, *r23 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		PHALCON_CPY_WRT(table, table_name);
	}
	
	PHALCON_INIT_VAR(temporary);
	ZVAL_BOOL(temporary, 0);
	eval_int = phalcon_array_isset_string(definition, SL("options")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(r0, SL("temporary")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_string(&r2, r1, SL("temporary"), PH_NOISY_CC);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(temporary);
				ZVAL_BOOL(temporary, 1);
			}
		}
	}
	
	if (zend_is_true(temporary)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TEMPORARY TABLE ", table, " (\n\t");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TABLE ", table, " (\n\t");
	}
	
	PHALCON_INIT_VAR(create_lines);
	array_init(create_lines);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	phalcon_array_fetch_string(&r3, definition, SL("columns"), PH_NOISY_CC);
	if (phalcon_valid_foreach(r3 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(r3);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_46b6_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_46b6_2;
		}
		
		PHALCON_INIT_VAR(column);
		ZVAL_ZVAL(column, *hd, 1, 0);
		PHALCON_INIT_VAR(r4);
		PHALCON_CALL_METHOD(r4, column, "getname", PH_NO_CHECK);
		PHALCON_INIT_VAR(r5);
		PHALCON_CALL_SELF_PARAMS_1(r5, this_ptr, "getcolumndefinition", column);
		PHALCON_INIT_VAR(column_line);
		PHALCON_CONCAT_SVSV(column_line, "`", r4, "` ", r5);
		
		PHALCON_INIT_VAR(r6);
		PHALCON_CALL_METHOD(r6, column, "isnotnull", PH_NO_CHECK);
		if (zend_is_true(r6)) {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, " NOT NULL", 1);
			phalcon_concat_self(&column_line, t0 TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(r7);
		PHALCON_CALL_METHOD(r7, column, "isautoincrement", PH_NO_CHECK);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(t1);
			ZVAL_STRING(t1, " AUTO_INCREMENT", 1);
			phalcon_concat_self(&column_line, t1 TSRMLS_CC);
		}
		
		phalcon_array_append(&create_lines, column_line, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_46b6_2;
		fee_46b6_2:
		if(0){}
	} else {
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SL("indexes")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r8);
		phalcon_array_fetch_string(&r8, definition, SL("indexes"), PH_NOISY_CC);
		if (phalcon_valid_foreach(r8 TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(r8);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_46b6_3:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_46b6_3;
			}
			PHALCON_INIT_VAR(index);
			ZVAL_ZVAL(index, *hd, 1, 0);
			PHALCON_INIT_VAR(index_name);
			PHALCON_CALL_METHOD(index_name, index, "getname", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r9);
			PHALCON_CALL_METHOD(r9, index, "getcolumns", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(column_list);
			PHALCON_CALL_SELF_PARAMS_1(column_list, this_ptr, "getcolumnlist", r9);
			if (PHALCON_COMPARE_STRING(index_name, "PRIMARY")) {
				PHALCON_INIT_VAR(r10);
				PHALCON_CONCAT_SVS(r10, "PRIMARY KEY (", column_list, ")");
				phalcon_array_append(&create_lines, r10, PH_SEPARATE TSRMLS_CC);
			} else {
				PHALCON_INIT_VAR(r11);
				PHALCON_CONCAT_SVSVS(r11, "KEY `", index_name, "` (", column_list, ")");
				phalcon_array_append(&create_lines, r11, PH_SEPARATE TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_46b6_3;
			fee_46b6_3:
			if(0){}
		} else {
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SL("references")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r12);
		phalcon_array_fetch_string(&r12, definition, SL("references"), PH_NOISY_CC);
		if (phalcon_valid_foreach(r12 TSRMLS_CC)) {
			ah2 = Z_ARRVAL_P(r12);
			zend_hash_internal_pointer_reset_ex(ah2, &hp2);
			fes_46b6_4:
			if(zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS){
				goto fee_46b6_4;
			}
			PHALCON_INIT_VAR(reference);
			ZVAL_ZVAL(reference, *hd, 1, 0);
			PHALCON_INIT_VAR(r13);
			PHALCON_CALL_METHOD(r13, reference, "getname", PH_NO_CHECK);
			PHALCON_INIT_VAR(r14);
			PHALCON_CALL_METHOD(r14, reference, "getcolumns", PH_NO_CHECK);
			PHALCON_INIT_VAR(r15);
			PHALCON_CALL_SELF_PARAMS_1(r15, this_ptr, "getcolumnlist", r14);
			PHALCON_INIT_VAR(reference_sql);
			PHALCON_CONCAT_SVSV(reference_sql, "CONSTRAINT `", r13, "` FOREIGN KEY (", r15);
			
			PHALCON_INIT_VAR(r16);
			PHALCON_CALL_METHOD(r16, reference, "getreferencedtable", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r17);
			PHALCON_CALL_METHOD(r17, reference, "getreferencedcolumns", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r18);
			PHALCON_CALL_SELF_PARAMS_1(r18, this_ptr, "getcolumnlist", r17);
			
			PHALCON_INIT_VAR(r19);
			PHALCON_CONCAT_SVSVS(r19, ") REFERENCES `", r16, "`(", r18, ")");
			phalcon_concat_self(&reference_sql, r19 TSRMLS_CC);
			phalcon_array_append(&create_lines, reference_sql, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah2, &hp2);
			goto fes_46b6_4;
			fee_46b6_4:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, ",\n\t", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r20);
	phalcon_fast_join(r20, c0, create_lines TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r21);
	PHALCON_CONCAT_VS(r21, r20, "\n)");
	phalcon_concat_self(&sql, r21 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SL("options")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r22);
		PHALCON_CALL_SELF_PARAMS_1(r22, this_ptr, "_gettableoptions", definition);
		PHALCON_ALLOC_ZVAL_MM(r23);
		PHALCON_CONCAT_SV(r23, " ", r22);
		phalcon_concat_self(&sql, r23 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to drop a table
 *
 * @param  string $tableName
 * @param  string $schemaName
 * @param  boolean $ifExists
 * @return boolean
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropTable){

	zval *table_name = NULL, *schema_name = NULL, *if_exists = NULL, *table = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_ALLOC_ZVAL_MM(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		PHALCON_CPY_WRT(table, table_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SV(r0, "DROP TABLE IF EXISTS ", table);
		
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SV(r1, "DROP TABLE ", table);
		
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Generates SQL checking for the existence of a schema.table
 *
 * @param string $tableName
 * @param string $schemaName
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableExists){

	zval *table_name = NULL, *schema_name = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '", schema_name, "' AND table_name='", table_name, "'");
		
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name='", table_name, "'");
		
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Generates a SQL describing a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeTable){

	zval *table = NULL, *schema = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVSVS(r0, "SELECT a.attname AS Field, format_type(a.atttypid, a.atttypmod) AS Type, CASE WHEN attnotnull=false THEN 'YES' ELSE 'NO' END AS Null, CASE WHEN (select cc.contype FROM pg_catalog.pg_constraint cc WHERE cc.conrelid = c.oid AND cc.conkey[1] = a.attnum)='p' THEN 'PRI' ELSE '' END AS Key, CASE WHEN t.typname LIKE '%int%' AND (SELECT column_default FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = '", table, "' AND column_name = a.attname) LIKE '%nextval%' THEN 'auto_increment' ELSE '' END AS Extra FROM pg_catalog.pg_Class c, pg_catalog.pg_attribute a, pg_catalog.pg_type t WHERE c.relname = '", table, "' AND c.oid = a.attrelid AND a.attnum > 0 AND c.relhaspkey = 't' AND t.oid = a.atttypid ORDER BY a.attnum");
	
	RETURN_CTOR(r0);
}

/**
 * List all tables on database
 *
 * @param       string $schemaName
 * @return      array
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listTables){

	zval *schema_name = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_ALLOC_ZVAL_MM(schema_name);
		ZVAL_NULL(schema_name);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_STRING("SELECT c.relname AS table_name FROM pg_Class c, pg_user u WHERE c.relowner = u.usesysid AND c.relkind = 'r' AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname) AND c.relname !~ '^(pg_|sql_)' UNION SELECT c.relname AS table_name FROM pg_Class c WHERE c.relkind = 'r' AND NOT EXISTS (SELECT 1 FROM pg_views WHERE viewname = c.relname)  AND NOT EXISTS (SELECT 1 FROM pg_user WHERE usesysid = c.relowner)  AND c.relname !~ '^pg_' ORDER BY 1", 1);
}

/**
 * Generates SQL to query indexes on a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeIndexes){

	zval *table = NULL, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SHOW INDEXES FROM `", schema, "`.`", table, "`");
	} else {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SHOW INDEXES FROM `", table, "`");
	}
	
	RETURN_CTOR(sql);
}

/**
 * Generates SQL to query foreign keys on a table
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeReferences){

	zval *table = NULL, *schema = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,REFERENCED_TABLE_SCHEMA,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME\n\t\t\tFROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_NAME IS NOT NULL AND ", 1);
	if (zend_is_true(schema)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "CONSTRAINT_SCHEMA = \"", schema, "\" AND TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r1 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/**
 * Generates the SQL to describe the table creation options
 *
 * @param string $table
 * @param string $schema
 * @return string
 */
PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableOptions){

	zval *table = NULL, *schema = NULL, *sql = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_ALLOC_ZVAL_MM(schema);
		ZVAL_NULL(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLES.TABLE_TYPE,TABLES.AUTO_INCREMENT,TABLES.ENGINE,TABLES.TABLE_COLLATION FROM INFORMATION_SCHEMA.TABLES WHERE ", 1);
	if (zend_is_true(schema)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_SVSVS(r0, "TABLES.TABLE_SCHEMA = \"", schema, "\" AND TABLES.TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "TABLES.TABLE_NAME = \"", table, "\"");
		phalcon_concat_self(&sql, r1 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

/* ------ Finished File: \db\dialect\postgresql.c ------ */

/* ------ Starting File: \model\validator\uniqueness.c ------ */
/**
 * Phalcon\Model\Validator\Uniqueness
 *
 * Validates that a field or a combination of a set of fields are not
 * present more than once in the existing records of the related table
 *
 *
 *
 */

/**
 * Executes the validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Uniqueness, validate){

	zval *record = NULL, *connection = NULL, *field = NULL, *conditions = NULL;
	zval *compose_field = NULL, *value = NULL, *manager = NULL, *meta_data = NULL;
	zval *primary_fields = NULL, *numeric_fields = NULL, *primary_field = NULL;
	zval *options = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL;
	zval *i0 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *t0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "isrequired", PH_NO_CHECK);
	if (zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "getrecord", PH_NO_CHECK);
		PHALCON_ALLOC_ZVAL_MM(i0);
		if (phalcon_clone(i0, r1 TSRMLS_CC) == FAILURE){
			return;
		}
		PHALCON_CPY_WRT(record, i0);
		
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, record, "getconnection", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(field);
		PHALCON_CALL_METHOD(field, this_ptr, "getfieldname", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
		if (Z_TYPE_P(field) == IS_ARRAY) { 
			if (phalcon_valid_foreach(field TSRMLS_CC)) {
				ah0 = Z_ARRVAL_P(field);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
				fes_d73d_0:
				if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
					goto fee_d73d_0;
				}
				PHALCON_INIT_VAR(compose_field);
				ZVAL_ZVAL(compose_field, *hd, 1, 0);
				PHALCON_INIT_VAR(r2);
				PHALCON_CALL_METHOD_PARAMS_1(r2, record, "readattribute", compose_field, PH_NO_CHECK);
				PHALCON_INIT_VAR(value);
				PHALCON_CALL_METHOD_PARAMS_1(value, connection, "escapestring", r2, PH_NO_CHECK);
				
				PHALCON_INIT_VAR(r3);
				PHALCON_CONCAT_VSVS(r3, compose_field, "='", value, "'");
				phalcon_array_append(&conditions, r3, PH_SEPARATE TSRMLS_CC);
				zend_hash_move_forward_ex(ah0, &hp0);
				goto fes_d73d_0;
				fee_d73d_0:
				if(0){}
			} else {
				return;
			}
		} else {
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_METHOD(r4, this_ptr, "getvalue", PH_NO_CHECK);
			PHALCON_INIT_VAR(value);
			PHALCON_CALL_METHOD_PARAMS_1(value, connection, "escapestring", r4, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CONCAT_VSVS(r5, field, "='", value, "'");
			phalcon_array_append(&conditions, r5, PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_INIT_VAR(manager);
		PHALCON_CALL_METHOD(manager, record, "getmanager", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(meta_data);
		PHALCON_CALL_METHOD(meta_data, manager, "getmetadata", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(primary_fields);
		PHALCON_CALL_METHOD_PARAMS_1(primary_fields, meta_data, "getprimarykeyattributes", record, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(numeric_fields);
		PHALCON_CALL_METHOD_PARAMS_1(numeric_fields, meta_data, "getdatatypesnumeric", record, PH_NO_CHECK);
		if (phalcon_valid_foreach(primary_fields TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(primary_fields);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_d73d_1:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_d73d_1;
			}
			
			PHALCON_INIT_VAR(primary_field);
			ZVAL_ZVAL(primary_field, *hd, 1, 0);
			eval_int = phalcon_array_isset(numeric_fields, primary_field);
			if (!eval_int) {
				PHALCON_INIT_VAR(r6);
				PHALCON_CALL_METHOD_PARAMS_1(r6, record, "readattribute", primary_field, PH_NO_CHECK);
				PHALCON_INIT_VAR(r7);
				PHALCON_CALL_METHOD_PARAMS_1(r7, connection, "escapestring", r6, PH_NO_CHECK);
				PHALCON_INIT_VAR(r8);
				PHALCON_CONCAT_VSVS(r8, primary_field, "<>'", r7, "'");
				phalcon_array_append(&conditions, r8, PH_SEPARATE TSRMLS_CC);
			} else {
				PHALCON_INIT_VAR(r9);
				PHALCON_CALL_METHOD_PARAMS_1(r9, record, "readattribute", primary_field, PH_NO_CHECK);
				PHALCON_INIT_VAR(r10);
				PHALCON_CALL_METHOD_PARAMS_1(r10, connection, "escapestring", r9, PH_NO_CHECK);
				PHALCON_INIT_VAR(r11);
				PHALCON_CALL_FUNC_PARAMS_1(r11, "intval", r10);
				PHALCON_INIT_VAR(r12);
				PHALCON_CONCAT_VSV(r12, primary_field, "<>", r11);
				phalcon_array_append(&conditions, r12, PH_SEPARATE TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_d73d_1;
			fee_d73d_1:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, " AND ", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r13);
		phalcon_fast_join(r13, c0, conditions TSRMLS_CC);
		PHALCON_CPY_WRT(conditions, r13);
		
		PHALCON_ALLOC_ZVAL_MM(r14);
		PHALCON_CALL_STATIC_ZVAL_PARAMS_1(r14, record, "count", conditions);
		
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 0);
		
		PHALCON_ALLOC_ZVAL_MM(r15);
		is_smaller_function(r15, t0, r14 TSRMLS_CC);
		if (zend_is_true(r15)) {
			PHALCON_INIT_VAR(options);
			PHALCON_CALL_METHOD(options, this_ptr, "getoptions", PH_NO_CHECK);
			eval_int = phalcon_array_isset_string(options, SL("message")+1);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(r16);
				phalcon_array_fetch_string(&r16, options, SL("message"), PH_NOISY_CC);
				PHALCON_INIT_VAR(c1);
				ZVAL_STRING(c1, "unique", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r16, field, c1, PH_NO_CHECK);
			} else {
				PHALCON_ALLOC_ZVAL_MM(r17);
				PHALCON_CONCAT_SVS(r17, "Value of field '", field, "' is already present in another record");
				PHALCON_INIT_VAR(c2);
				ZVAL_STRING(c2, "unique", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r17, field, c2, PH_NO_CHECK);
			}
			
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/* ------ Finished File: \model\validator\uniqueness.c ------ */

/* ------ Starting File: \model\validator\exclusionin.c ------ */
/**
 * ExclusionInValidator
 *
 * Check if a value is not included into a list of values
 *
 *
 */

/**
 * Check that the options are valid
 *
 */
PHP_METHOD(Phalcon_Model_Validator_Exclusionin, checkOptions){

	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "domain", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "issetoption", c0, PH_NO_CHECK);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "domain", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "getoption", c1, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_1(r2, "is_array", r1);
	if (!zend_is_true(r2)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Executes validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Exclusionin, validate){

	zval *domain = NULL, *field_name = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "isrequired", PH_NO_CHECK);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "domain", 1);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "issetoption", c0, PH_NO_CHECK);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(c1);
			ZVAL_STRING(c1, "domain", 1);
			PHALCON_INIT_VAR(domain);
			PHALCON_CALL_METHOD_PARAMS_1(domain, this_ptr, "getoption", c1, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD(r2, this_ptr, "getvalue", PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_FUNC_PARAMS_2(r3, "in_array", r2, domain);
			if (zend_is_true(r3)) {
				PHALCON_INIT_VAR(field_name);
				PHALCON_CALL_METHOD(field_name, this_ptr, "getfieldname", PH_NO_CHECK);
				
				PHALCON_INIT_VAR(c2);
				ZVAL_STRING(c2, ", ", 1);
				
				PHALCON_ALLOC_ZVAL_MM(r4);
				phalcon_fast_join(r4, c2, domain TSRMLS_CC);
				
				PHALCON_ALLOC_ZVAL_MM(r5);
				PHALCON_CONCAT_SVSV(r5, "Value of field '", field_name, "' must not be part of list: ", r4);
				
				PHALCON_INIT_VAR(c3);
				ZVAL_STRING(c3, "exclusion", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r5, field_name, c3, PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/* ------ Finished File: \model\validator\exclusionin.c ------ */

/* ------ Starting File: \model\validator\regex.c ------ */
/**
 * Phalcon\Model\Validator\Regex
 *
 * Allows to validate if the value of a field matches a regular expression
 *
 *
 *
 */

/**
 * Check that the options are correct
 *
 */
PHP_METHOD(Phalcon_Model_Validator_Regex, checkOptions){

	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "pattern", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "issetoption", c0, PH_NO_CHECK);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Validator requires a perl-compatible regex pattern");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Executes the validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Regex, validate){

	zval *matches = NULL, *failed = NULL, *value = NULL, *field_name = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(matches);
	ZVAL_NULL(matches);
	
	PHALCON_INIT_VAR(failed);
	ZVAL_BOOL(failed, 1);
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD(value, this_ptr, "getvalue", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD(field_name, this_ptr, "getfieldname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "pattern", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "getoption", c0, PH_NO_CHECK);
	Z_SET_ISREF_P(matches);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_FUNC_PARAMS_3(r1, "preg_match", r0, value, matches);
	Z_UNSET_ISREF_P(matches);
	if (zend_is_true(r1)) {
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_long(&r2, matches, 0, PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r3);
		is_not_equal_function(r3, r2, value TSRMLS_CC);
		if (zend_is_true(r3)) {
			PHALCON_INIT_VAR(failed);
			ZVAL_BOOL(failed, 0);
		}
	} else {
		PHALCON_INIT_VAR(failed);
		ZVAL_BOOL(failed, 0);
	}
	
	if (!zend_is_true(failed)) {
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CONCAT_SVS(r4, "Value of field '", field_name, "' doesn't match regular expression");
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "regex", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r4, field_name, c1, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \model\validator\regex.c ------ */

/* ------ Starting File: \model\validator\inclusionin.c ------ */
/**
 * Phalcon\Model\Validator\Inclusionin
 *
 * Check if a value is included into a list of values
 *
 *
 *
 */

/**
 * Check that the options are valid
 *
 */
PHP_METHOD(Phalcon_Model_Validator_Inclusionin, checkOptions){

	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "domain", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "issetoption", c0, PH_NO_CHECK);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "domain", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "getoption", c1, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_1(r2, "is_array", r1);
	if (!zend_is_true(r2)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Executes validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Inclusionin, validate){

	zval *domain = NULL, *field_name = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "isrequired", PH_NO_CHECK);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "domain", 1);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "issetoption", c0, PH_NO_CHECK);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(c1);
			ZVAL_STRING(c1, "domain", 1);
			PHALCON_INIT_VAR(domain);
			PHALCON_CALL_METHOD_PARAMS_1(domain, this_ptr, "getoption", c1, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD(r2, this_ptr, "getvalue", PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_FUNC_PARAMS_2(r3, "in_array", r2, domain);
			if (!zend_is_true(r3)) {
				PHALCON_INIT_VAR(field_name);
				PHALCON_CALL_METHOD(field_name, this_ptr, "getfieldname", PH_NO_CHECK);
				
				PHALCON_INIT_VAR(c2);
				ZVAL_STRING(c2, ", ", 1);
				
				PHALCON_ALLOC_ZVAL_MM(r4);
				phalcon_fast_join(r4, c2, domain TSRMLS_CC);
				
				PHALCON_ALLOC_ZVAL_MM(r5);
				PHALCON_CONCAT_SVSV(r5, "Value of field '", field_name, "' must be part of list: ", r4);
				
				PHALCON_INIT_VAR(c3);
				ZVAL_STRING(c3, "inclusion", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r5, field_name, c3, PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/* ------ Finished File: \model\validator\inclusionin.c ------ */

/* ------ Starting File: \model\validator\numericality.c ------ */
/**
 * Phalcon\Model\Validator\Numericality
 *
 * Allows to validate if a field has a valid numeric format
 *
 *
 */

/**
 * Executes the validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Numericality, validate){

	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "isrequired", PH_NO_CHECK);
	if (zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "getvalue", PH_NO_CHECK);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_FUNC_PARAMS_1(r2, "is_numeric", r1);
		if (!zend_is_true(r2)) {
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_METHOD(r3, this_ptr, "getfieldname", PH_NO_CHECK);
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CONCAT_SVS(r4, "Value of field '", r3, "' must be numeric");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "appendmessage", r4, PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/* ------ Finished File: \model\validator\numericality.c ------ */

/* ------ Starting File: \model\validator\email.c ------ */
/**
 * Phalcon\Model\Validator\Email
 *
 * Allows to validate if email fields has correct values
 *
 *
 *
 */

/**
 * Executes the validator
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator_Email, validate){

	zval *regs = NULL, *field_name = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "isrequired", PH_NO_CHECK);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(regs);
		ZVAL_NULL(regs);
		
		PHALCON_INIT_VAR(field_name);
		PHALCON_CALL_METHOD(field_name, this_ptr, "getfieldname", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "/^[a-zA-Z0-9_\\.\\+]+@[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)*$/", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "getvalue", PH_NO_CHECK);
		Z_SET_ISREF_P(regs);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_FUNC_PARAMS_3(r2, "preg_match", c0, r1, regs);
		Z_UNSET_ISREF_P(regs);
		if (zend_is_true(r2)) {
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_array_fetch_long(&r3, regs, 0, PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_METHOD(r4, this_ptr, "getvalue", PH_NO_CHECK);
			PHALCON_ALLOC_ZVAL_MM(r5);
			is_not_equal_function(r5, r3, r4 TSRMLS_CC);
			if (zend_is_true(r5)) {
				PHALCON_ALLOC_ZVAL_MM(r6);
				PHALCON_CONCAT_SVS(r6, "Value of field '", field_name, "' should be a valid e-mail");
				PHALCON_INIT_VAR(c1);
				ZVAL_STRING(c1, "email", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r6, field_name, c1, PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		} else {
			PHALCON_ALLOC_ZVAL_MM(r7);
			PHALCON_CONCAT_SVS(r7, "Value of field '", field_name, "' should be a valid e-mail");
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "email", 1);
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", r7, field_name, c2, PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/* ------ Finished File: \model\validator\email.c ------ */

/* ------ Starting File: \model\query.c ------ */
/**
 * Phalcon\Model\Query
 *
 * Phalcon\Model\Query is designed to simplify building of search on models.
 * It provides a set of helpers to generate searchs in a dynamic way to support differents databases.
 *
 * 
 *
 */

PHP_METHOD(Phalcon_Model_Query, __construct){

	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_model_query_ce, this_ptr, SL("_data"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_model_query_ce, this_ptr, SL("_models"), a1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a2);
	array_init(a2);
	zend_update_property(phalcon_model_query_ce, this_ptr, SL("_parameters"), a2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a3);
	array_init(a3);
	zend_update_property(phalcon_model_query_ce, this_ptr, SL("_conditions"), a3 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Set the Phalcon_Model_Manager instance to use in a query
 *
 * @param Phalcon_Model_Manager $manager
 */
PHP_METHOD(Phalcon_Model_Query, setManager){

	zval *manager = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Add models to use in query
 *
 * @param string $model
 */
PHP_METHOD(Phalcon_Model_Query, from){

	zval *model = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_models"), PH_NOISY_CC);
	phalcon_array_append(&t0, model, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_models"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Add conditions to use in query
 *
 * @param string $condition
 */
PHP_METHOD(Phalcon_Model_Query, where){

	zval *condition = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &condition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_conditions"), PH_NOISY_CC);
	phalcon_array_append(&t0, condition, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_conditions"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Set parameter in query to different database adapters.
 *
 * @param string $parameter
 */
PHP_METHOD(Phalcon_Model_Query, setParameters){

	zval *parameter = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameter) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_parameters"), parameter TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the data to use to make the conditions in query
 *
 * @param array $data
 */
PHP_METHOD(Phalcon_Model_Query, setInputData){

	zval *data = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Data parameter must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_data"), data TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the limit of rows to show
 *
 * @param int $limit
 */
PHP_METHOD(Phalcon_Model_Query, setLimit){

	zval *limit = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &limit) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_limit"), limit TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Model_Query, getResultset){


	
}

/**
 * Get the conditions of query
 *
 * @return string $query
 */
PHP_METHOD(Phalcon_Model_Query, getConditions){

	zval *controller_front = NULL, *model_manager = NULL, *model_name = NULL;
	zval *entity = NULL, *meta_data = NULL, *attributes = NULL, *numeric_types = NULL;
	zval *connection = NULL, *i = NULL, *parameters = NULL, *conditions = NULL;
	zval *value = NULL, *param = NULL, *condition = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	zval *c0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_INIT_VAR(controller_front);
		PHALCON_CALL_STATIC(controller_front, "phalcon\\controller\\front", "getinstance");
		
		PHALCON_INIT_VAR(model_manager);
		PHALCON_CALL_METHOD(model_manager, controller_front, "getmodelcomponent", PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "setmanager", model_manager, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(model_manager);
		phalcon_read_property(&model_manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_models"), PH_NOISY_CC);
	if (phalcon_valid_foreach(t1 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t1);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_a355_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_a355_0;
		}
		
		PHALCON_INIT_VAR(model_name);
		ZVAL_ZVAL(model_name, *hd, 1, 0);
		PHALCON_INIT_VAR(entity);
		PHALCON_CALL_METHOD_PARAMS_1(entity, model_manager, "getmodel", model_name, PH_NO_CHECK);
		if (!zend_is_true(entity)) {
			PHALCON_INIT_VAR(i0);
			object_init_ex(i0, phalcon_model_exception_ce);
			PHALCON_INIT_VAR(r0);
			PHALCON_CONCAT_SVS(r0, "The model ", model_name, " does not exist");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
			phalcon_throw_exception(i0 TSRMLS_CC);
			return;
		}
		
		PHALCON_INIT_VAR(meta_data);
		PHALCON_CALL_METHOD(meta_data, model_manager, "getmetadata", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(attributes);
		PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", entity, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(numeric_types);
		PHALCON_CALL_METHOD_PARAMS_1(numeric_types, meta_data, "getdatatypesnumeric", entity, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, entity, "getconnection", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(t2);
		phalcon_read_property(&t2, this_ptr, SL("_data"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(r1);
		phalcon_fast_count(r1, t2 TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(i);
			ZVAL_LONG(i, 0);
			
			PHALCON_INIT_VAR(parameters);
			array_init(parameters);
			
			PHALCON_INIT_VAR(conditions);
			array_init(conditions);
			
			PHALCON_INIT_VAR(t3);
			phalcon_read_property(&t3, this_ptr, SL("_data"), PH_NOISY_CC);
			if (phalcon_valid_foreach(t3 TSRMLS_CC)) {
				ah1 = Z_ARRVAL_P(t3);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
				fes_a355_1:
				if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
					goto fee_a355_1;
				} else {
					PHALCON_INIT_VAR(param);
					PHALCON_GET_FOREACH_KEY(param, ah1, hp1);
				}
				PHALCON_INIT_VAR(value);
				ZVAL_ZVAL(value, *hd, 1, 0);
				PHALCON_INIT_VAR(r2);
				PHALCON_CALL_FUNC_PARAMS_2(r2, "in_array", param, attributes);
				if (zend_is_true(r2)) {
					PHALCON_INIT_VAR(t4);
					ZVAL_STRING(t4, "", 1);
					PHALCON_INIT_VAR(r3);
					is_not_identical_function(r3, t4, value TSRMLS_CC);
					PHALCON_INIT_VAR(r5);
					PHALCON_CALL_FUNC_PARAMS_1(r5, "is_null", value);
					PHALCON_INIT_VAR(r4);
					boolean_not_function(r4, r5 TSRMLS_CC);
					PHALCON_INIT_VAR(r6);
					phalcon_and_function(r6, r3, r4);
					if (zend_is_true(r6)) {
						if (!PHALCON_COMPARE_STRING(value, "@")) {
							eval_int = phalcon_array_isset(numeric_types, param);
							if (eval_int) {
								PHALCON_INIT_VAR(condition);
								PHALCON_CONCAT_VSV(condition, param, " = ?", i);
								phalcon_array_update(&parameters, i, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
							} else {
								PHALCON_INIT_VAR(condition);
								PHALCON_CONCAT_VSV(condition, param, " LIKE ?", i);
								
								PHALCON_INIT_VAR(r7);
								PHALCON_CONCAT_SVS(r7, "%", value, "%");
								phalcon_array_update(&parameters, i, &r7, PH_COPY | PH_SEPARATE TSRMLS_CC);
							}
							phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
						}
					}
				}
				PHALCON_SEPARATE(i);
				increment_function(i);
				zend_hash_move_forward_ex(ah1, &hp1);
				goto fes_a355_1;
				fee_a355_1:
				if(0){}
			} else {
				return;
			}
		} else {
			PHALCON_INIT_VAR(parameters);
			phalcon_read_property(&parameters, this_ptr, SL("_parameters"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(conditions);
			phalcon_read_property(&conditions, this_ptr, SL("_conditions"), PH_NOISY_CC);
		}
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, " AND ", 1);
		
		PHALCON_INIT_VAR(r8);
		phalcon_fast_join(r8, c0, conditions TSRMLS_CC);
		
		PHALCON_INIT_VAR(r9);
		PHALCON_CALL_METHOD_PARAMS_2(r9, connection, "bindparams", r8, parameters, PH_NO_CHECK);
		PHALCON_CPY_WRT(conditions, r9);
		if (PHALCON_COMPARE_STRING(conditions, "")) {
			PHALCON_INIT_VAR(conditions);
			ZVAL_STRING(conditions, "1=1", 1);
		}
		
		
		RETURN_CCTOR(conditions);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_a355_0;
		fee_a355_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Get instance of model query
 *
 * @param string $modelName
 * @param array $data
 * @return Phalcon\Model\Query
 */
PHP_METHOD(Phalcon_Model_Query, fromInput){

	zval *model_name = NULL, *data = NULL, *query = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_model_query_ce);
	PHALCON_CALL_METHOD_NORETURN(query, "__construct", PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "from", model_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "setinputdata", data, PH_NO_CHECK);
	
	RETURN_CTOR(query);
}

/* ------ Finished File: \model\query.c ------ */

/* ------ Starting File: \model\exception.c ------ */
/**
 * Phalcon\Model\Exception
 *
 * Exceptions thrown in Phalcon\Model\* classes will use this class
 *
 */

/* ------ Finished File: \model\exception.c ------ */

/* ------ Starting File: \model\base.c ------ */
/**
 * Phalcon\Model\Base
 *
 * Phalcon\Model connects business objects and database tables to create
 * a persistable domain model where logic and data are presented in one wrapping.
 * Its an implementation of the object- relational mapping (ORM).
 *
 * A model represents the information (data) of the application and the rules to manipulate that data.
 * Models are primarily used for managing the rules of interaction with a corresponding database table.
 * In most cases, each table in your database will correspond to one model in your application.
 * The bulk of your applications business logic will be concentrated in the models.
 *
 * Phalcon\Model is the first ORM written in C-language for PHP, giving to developers high performance
 * when interacting with databases while is also easy to use.
 *
 * 
 *
 */

/**
 * Phalcon\Model\Base constructor
 *
 * @param Phalcon\Model\Manager $manager
 */
PHP_METHOD(Phalcon_Model_Base, __construct){

	zval *manager = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!manager) {
		PHALCON_ALLOC_ZVAL_MM(manager);
		ZVAL_NULL(manager);
	} else {
		PHALCON_SEPARATE_PARAM(manager);
	}
	
	if (!zend_is_true(manager)) {
		PHALCON_INIT_VAR(manager);
		phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
		if (!zend_is_true(manager)) {
			PHALCON_INIT_VAR(manager);
			PHALCON_CALL_STATIC(manager, "phalcon\\model\\manager", "getdefault");
			phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
		}
	} else {
		phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
	}
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(manager, "initialize", this_ptr, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Overwrites default model manager
 *
 * @param Phalcon\Model\Manager $manager
 */
PHP_METHOD(Phalcon_Model_Base, setManager){

	zval *manager = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns internal models manager
 *
 * @return Phalcon\Model\Manager
 */
PHP_METHOD(Phalcon_Model_Base, getManager){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Internal method to create a connection. Automatically dumps mapped table meta-data
 *
 */
PHP_METHOD(Phalcon_Model_Base, _connect){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_manager"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, t1, "getconnection", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_connection"), r0 TSRMLS_CC);
	}
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "dump", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

/**
 * Return an array with the attributes names
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getAttributes){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getattributes", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns an array of attributes that are part of the related table primary key
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getPrimaryKeyAttributes){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getprimarykeyattributes", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns an array of attributes that aren't part of the primary key
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getNonPrimaryKeyAttributes){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getnonprimarykeyattributes", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns an array of not-nullable attributes
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getNotNullAttributes){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getnotnullattributes", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns an array of numeric attributes
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getDataTypesNumeric){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getdatatypesnumeric", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns an array of data-types attributes
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, getDataTypes){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getdatatypes", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Returns the name of the identity field
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Base, getIdentityField){

	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "getmetadata", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, r0, "getidentityfield", this_ptr, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Dumps mapped table meta-data
 *
 * @return Phalcon_Model_Base
 */
PHP_METHOD(Phalcon_Model_Base, dump){

	zval *attributes = NULL, *field = NULL;
	zval *t0 = NULL, *t1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dumped"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	phalcon_update_property_bool(this_ptr, SL("_dumped"), 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD(attributes, this_ptr, "getattributes", PH_NO_CHECK);
	if (phalcon_valid_foreach(attributes TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(attributes);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_f9eb_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_f9eb_0;
		}
		
		PHALCON_INIT_VAR(field);
		ZVAL_ZVAL(field, *hd, 1, 0);
		eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
		if (!eval_int) {
			PHALCON_INIT_VAR(t1);
			ZVAL_STRING(t1, "", 1);
			phalcon_update_property_zval_zval(this_ptr, field, t1 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_f9eb_0;
		fee_f9eb_0:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Creates SQL statement which returns many rows
 *
 * @param Phalcon_Manager $manager
 * @param Phalcon_Model_Base $model
 * @param Phalcon_Db $connection
 * @param array $params
 * @return array
 */
PHP_METHOD(Phalcon_Model_Base, _createSQLSelect){

	zval *manager = NULL, *model = NULL, *connection = NULL, *params = NULL, *meta_data = NULL;
	zval *source = NULL, *schema = NULL, *select = NULL, *conditions = NULL, *no_primary = NULL;
	zval *primary_keys = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL, *r19 = NULL, *r20 = NULL;
	zval *r21 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &manager, &model, &connection, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD(meta_data, manager, "getmetadata", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(select);
	ZVAL_STRING(select, "SELECT ", 1);
	eval_int = phalcon_array_isset_string(params, SL("columns")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, params, SL("columns"), PH_NOISY_CC);
		phalcon_concat_self(&select, r0 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS_1(r1, meta_data, "getattributes", model, PH_NO_CHECK);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_METHOD_PARAMS_1(r2, connection, "getcolumnlist", r1, PH_NO_CHECK);
		phalcon_concat_self(&select, r2 TSRMLS_CC);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CONCAT_SVSV(r3, " FROM ", schema, ".", source);
		phalcon_concat_self(&select, r3 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CONCAT_SV(r4, " FROM ", source);
		phalcon_concat_self(&select, r4 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(conditions);
	ZVAL_NULL(conditions);
	eval_int = phalcon_array_isset_string(params, SL("conditions")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(no_primary);
			ZVAL_BOOL(no_primary, 0);
			
			PHALCON_INIT_VAR(conditions);
			phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(primary_keys);
			PHALCON_CALL_METHOD_PARAMS_1(primary_keys, meta_data, "getprimarykeyattributes", model, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CALL_FUNC_PARAMS_1(r5, "is_numeric", conditions);
			if (zend_is_true(r5)) {
				eval_int = phalcon_array_isset_long(primary_keys, 0);
				if (eval_int) {
					PHALCON_ALLOC_ZVAL_MM(r6);
					phalcon_array_fetch_long(&r6, primary_keys, 0, PH_NOISY_CC);
					PHALCON_ALLOC_ZVAL_MM(r7);
					PHALCON_CALL_METHOD_PARAMS_1(r7, connection, "escapestring", conditions, PH_NO_CHECK);
					PHALCON_INIT_VAR(conditions);
					PHALCON_CONCAT_VSVS(conditions, r6, " = '", r7, "'");
				} else {
					PHALCON_INIT_VAR(no_primary);
					ZVAL_BOOL(no_primary, 1);
				}
			} else {
				if (PHALCON_COMPARE_STRING(conditions, "")) {
					eval_int = phalcon_array_isset_long(primary_keys, 0);
					if (eval_int) {
						PHALCON_ALLOC_ZVAL_MM(r8);
						phalcon_array_fetch_long(&r8, primary_keys, 0, PH_NOISY_CC);
						PHALCON_INIT_VAR(conditions);
						PHALCON_CONCAT_VS(conditions, r8, " = ''");
					} else {
						PHALCON_INIT_VAR(no_primary);
						ZVAL_BOOL(no_primary, 1);
					}
				}
			}
			
			if (zend_is_true(no_primary)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Source related to this model does not have a primary key defined");
				return;
			}
		}
	}
	
	if (zend_is_true(conditions)) {
		eval_int = phalcon_array_isset_string(params, SL("bind")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r9);
			phalcon_array_fetch_string(&r9, params, SL("bind"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r10);
			PHALCON_CALL_METHOD_PARAMS_2(r10, connection, "bindparams", conditions, r9, PH_NO_CHECK);
			PHALCON_CPY_WRT(conditions, r10);
		}
		
		PHALCON_ALLOC_ZVAL_MM(r11);
		PHALCON_CONCAT_SV(r11, " WHERE ", conditions);
		phalcon_concat_self(&select, r11 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("group")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r12);
		phalcon_array_fetch_string(&r12, params, SL("group"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r13);
		PHALCON_CONCAT_SV(r13, " GROUP BY ", r12);
		phalcon_concat_self(&select, r13 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("order")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r14);
		phalcon_array_fetch_string(&r14, params, SL("order"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r15);
		PHALCON_CONCAT_SV(r15, " ORDER BY ", r14);
		phalcon_concat_self(&select, r15 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("limit")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r16);
		phalcon_array_fetch_string(&r16, params, SL("limit"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r17);
		PHALCON_CALL_METHOD_PARAMS_2(r17, connection, "limit", select, r16, PH_NO_CHECK);
		PHALCON_CPY_WRT(select, r17);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("for_update")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r18);
		phalcon_array_fetch_string(&r18, params, SL("for_update"), PH_NOISY_CC);
		if (zend_is_true(r18)) {
			PHALCON_ALLOC_ZVAL_MM(r19);
			PHALCON_CALL_METHOD_PARAMS_1(r19, connection, "forupdate", select, PH_NO_CHECK);
			PHALCON_CPY_WRT(select, r19);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SL("shared_lock")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r20);
		phalcon_array_fetch_string(&r20, params, SL("shared_lock"), PH_NOISY_CC);
		if (zend_is_true(r20)) {
			PHALCON_ALLOC_ZVAL_MM(r21);
			PHALCON_CALL_METHOD_PARAMS_1(r21, connection, "sharedlock", select, PH_NO_CHECK);
			PHALCON_CPY_WRT(select, r21);
		}
	}
	
	
	RETURN_CCTOR(select);
}

/**
 * Gets a resulset from the cache or creates one
 *
 * @param Phalcon\Model\Manager $manager
 * @param Phalcon\Model\Base $model
 * @param Phalcon\Db $connection
 * @param array $params
 * @param boolean $unique
 */
PHP_METHOD(Phalcon_Model_Base, _getOrCreateResultset){

	zval *manager = NULL, *model = NULL, *connection = NULL, *params = NULL, *unique = NULL;
	zval *key = NULL, *cache = NULL, *lifetime = NULL, *select = NULL, *cache_options = NULL;
	zval *resultset = NULL, *result = NULL, *count = NULL, *row = NULL, *result_data = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL }, *p1[] = { NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzzz", &manager, &model, &connection, &params, &unique) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(key);
	ZVAL_NULL(key);
	
	PHALCON_INIT_VAR(cache);
	ZVAL_NULL(cache);
	
	PHALCON_INIT_VAR(lifetime);
	ZVAL_NULL(lifetime);
	
	PHALCON_INIT_VAR(select);
	ZVAL_NULL(select);
	eval_int = phalcon_array_isset_string(params, SL("cache")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(cache_options);
		phalcon_array_fetch_string(&cache_options, params, SL("cache"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "is_bool", cache_options);
		if (zend_is_true(r0)) {
			if (zend_is_true(cache_options)) {
				PHALCON_INIT_VAR(lifetime);
				ZVAL_LONG(lifetime, 3600);
				
				PHALCON_INIT_VAR(cache);
				PHALCON_CALL_METHOD(cache, manager, "getcache", PH_NO_CHECK);
			}
		} else {
			if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
				eval_int = phalcon_array_isset_string(cache_options, SL("key")+1);
				if (eval_int) {
					PHALCON_INIT_VAR(key);
					phalcon_array_fetch_string(&key, cache_options, SL("key"), PH_NOISY_CC);
				}
				eval_int = phalcon_array_isset_string(cache_options, SL("lifetime")+1);
				if (eval_int) {
					PHALCON_INIT_VAR(lifetime);
					phalcon_array_fetch_string(&lifetime, cache_options, SL("lifetime"), PH_NOISY_CC);
				}
			} else {
				if (Z_TYPE_P(cache_options) == IS_LONG) {
					PHALCON_CPY_WRT(lifetime, cache_options);
				} else {
					if (Z_TYPE_P(cache_options) == IS_OBJECT) {
						PHALCON_CPY_WRT(cache, cache_options);
					} else {
						PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Invalid caching options");
						return;
					}
				}
			}
		}
		
		if (Z_TYPE_P(cache) == IS_NULL) {
			PHALCON_INIT_VAR(cache);
			PHALCON_CALL_METHOD(cache, manager, "getcache", PH_NO_CHECK);
		}
	}
	
	if (Z_TYPE_P(cache) != IS_NULL) {
		if (Z_TYPE_P(key) == IS_NULL) {
			p0[0] = manager;
			p0[1] = model;
			p0[2] = connection;
			p0[3] = params;
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_SELF_PARAMS(r1, this_ptr, "_createsqlselect", 4, p0);
			PHALCON_CPY_WRT(select, r1);
			
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_FUNC_PARAMS_1(r2, "md5", select);
			
			PHALCON_INIT_VAR(key);
			PHALCON_CONCAT_SV(key, "phc", r2);
		}
		
		PHALCON_INIT_VAR(resultset);
		PHALCON_CALL_METHOD_PARAMS_2(resultset, cache, "get", key, lifetime, PH_NO_CHECK);
		if (Z_TYPE_P(resultset) != IS_NULL) {
			
			RETURN_CCTOR(resultset);
		}
	}
	
	if (Z_TYPE_P(select) == IS_NULL) {
		p1[0] = manager;
		p1[1] = model;
		p1[2] = connection;
		p1[3] = params;
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_SELF_PARAMS(r3, this_ptr, "_createsqlselect", 4, p1);
		PHALCON_CPY_WRT(select, r3);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, connection, "query", select, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD_PARAMS_1(count, result, "numrows", result, PH_NO_CHECK);
	if (Z_TYPE_P(unique) == IS_BOOL && Z_BVAL_P(unique)) {
		if (!zend_is_true(count)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		} else {
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", c0, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(row);
			PHALCON_CALL_METHOD_PARAMS_1(row, result, "fetcharray", result, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(c1);
			ZVAL_LONG(c1, 2);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", c1, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_SELF_PARAMS_2(r4, this_ptr, "dumpresult", model, row);
			RETURN_CTOR(r4);
		}
	}
	
	if (zend_is_true(count)) {
		PHALCON_CPY_WRT(result_data, result);
	} else {
		PHALCON_INIT_VAR(result_data);
		ZVAL_BOOL(result_data, 0);
	}
	
	PHALCON_INIT_VAR(resultset);
	object_init_ex(resultset, phalcon_model_resultset_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(resultset, "__construct", model, result_data, cache, PH_CHECK);
	if (Z_TYPE_P(cache) != IS_NULL) {
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(cache, "save", key, resultset, lifetime, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(resultset);
}

/**
 * Sets a transaction related to the Model instance
 *
 * @param Phalcon_Transaction $transaction
 */
PHP_METHOD(Phalcon_Model_Base, setTransaction){

	zval *transaction = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(transaction) == IS_OBJECT) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, transaction, "getconnection", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_connection"), r0 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Transaction should be an object");
		return;
	}
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Checks wheter model is mapped to a database view
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, isView){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_isView"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets table name which model should be mapped
 *
 * @param string $source
 */
PHP_METHOD(Phalcon_Model_Base, setSource){

	zval *source = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &source) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns table name mapped in the model
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Base, getSource){

	zval *source = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(source);
	phalcon_read_property(&source, this_ptr, SL("_source"), PH_NOISY_CC);
	if (!zend_is_true(source)) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_get_class(r0, this_ptr TSRMLS_CC);
		PHALCON_INIT_VAR(source);
		PHALCON_CALL_METHOD_PARAMS_1(source, t0, "getsource", r0, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(source);
}

/**
 * Sets schema name where table mapped is located
 *
 * @param string $schema
 */
PHP_METHOD(Phalcon_Model_Base, setSchema){

	zval *schema = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_schema"), schema TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns schema name where table mapped is located
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Base, getSchema){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_schema"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Overwrites internal Phalcon\Db connection
 *
 * @param Phalcon_Db $connection
 */
PHP_METHOD(Phalcon_Model_Base, setConnection){

	zval *connection = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets internal Phalcon\Db connection
 *
 * @return Phalcon\Db
 */
PHP_METHOD(Phalcon_Model_Base, getConnection){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Assigns values to a model from an array returning a new model
 *
 * @param array $result
 * @param Phalcon\Model\Base $base
 * @return Phalcon\Model\Base $result
 */
PHP_METHOD(Phalcon_Model_Base, dumpResult){

	zval *base = NULL, *result = NULL, *object = NULL, *value = NULL, *key = NULL;
	zval *i0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &base, &result) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(i0);
	if (phalcon_clone(i0, base TSRMLS_CC) == FAILURE){
		return;
	}
	PHALCON_CPY_WRT(object, i0);
	if (Z_TYPE_P(result) == IS_ARRAY) { 
		if (phalcon_valid_foreach(result TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(result);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_1:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_1;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			phalcon_update_property_zval_zval(object, key, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_1;
			fee_f9eb_1:
			if(0){}
		} else {
			return;
		}
	}
	
	
	RETURN_CCTOR(object);
}

/**
 * Allows to query a set of records that match the specified conditions
 *
 * @param array $parameters
 * @return  Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Base, find){

	zval *parameters = NULL, *manager = NULL, *class_name = NULL, *model = NULL;
	zval *connection = NULL, *params = NULL;
	zval *r0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_STATIC(manager, "phalcon\\model\\manager", "getdefault");
	if (!zend_is_true(manager)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not model manager related to this model");
		return;
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "getmodel", class_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, manager, "getconnection", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setconnection", connection, PH_NO_CHECK);
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	p0[0] = manager;
	p0[1] = model;
	p0[2] = connection;
	p0[3] = params;
	
	PHALCON_INIT_VAR(p0[4]);
	ZVAL_BOOL(p0[4], 0);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS(r0, this_ptr, "_getorcreateresultset", 5, p0);
	RETURN_CTOR(r0);
}

/**
 * Allows to query the first record that match the specified conditions
 *
 * @param array $parameters
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Base, findFirst){

	zval *parameters = NULL, *manager = NULL, *class_name = NULL, *model = NULL;
	zval *connection = NULL, *params = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_STATIC(manager, "phalcon\\model\\manager", "getdefault");
	if (!zend_is_true(manager)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not model manager related to this model");
		return;
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "getmodel", class_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, manager, "getconnection", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setconnection", connection, PH_NO_CHECK);
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("limit")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, "1", 1);
		phalcon_array_update_string(&params, SL("limit"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	p0[0] = manager;
	p0[1] = model;
	p0[2] = connection;
	p0[3] = params;
	
	PHALCON_INIT_VAR(p0[4]);
	ZVAL_BOOL(p0[4], 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS(r0, this_ptr, "_getorcreateresultset", 5, p0);
	RETURN_CTOR(r0);
}

/**
 * Checks if the current record already exists or not
 *
 * @param Phalcon\Db $connection
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _exists){

	zval *connection = NULL, *primary_keys = NULL, *where_pk = NULL, *numeric_typed = NULL;
	zval *field = NULL, *value = NULL, *sanitized_value = NULL, *schema = NULL;
	zval *source = NULL, *table = NULL, *select = NULL, *num = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *c0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(connection);
	
	PHALCON_INIT_VAR(primary_keys);
	PHALCON_CALL_METHOD(primary_keys, this_ptr, "getprimarykeyattributes", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, primary_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, t0, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(where_pk);
		array_init(where_pk);
		
		PHALCON_INIT_VAR(numeric_typed);
		PHALCON_CALL_METHOD(numeric_typed, this_ptr, "getdatatypesnumeric", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
		if (phalcon_valid_foreach(primary_keys TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(primary_keys);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_2:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_2;
			}
			
			PHALCON_INIT_VAR(field);
			ZVAL_ZVAL(field, *hd, 1, 0);
			PHALCON_INIT_VAR(value);
			phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(t1);
			ZVAL_NULL(t1);
			
			PHALCON_INIT_VAR(r2);
			is_not_identical_function(r2, t1, value TSRMLS_CC);
			
			PHALCON_INIT_VAR(t2);
			ZVAL_STRING(t2, "", 1);
			
			PHALCON_INIT_VAR(r3);
			is_not_identical_function(r3, t2, value TSRMLS_CC);
			
			PHALCON_INIT_VAR(r4);
			phalcon_and_function(r4, r2, r3);
			if (zend_is_true(r4)) {
				PHALCON_INIT_VAR(sanitized_value);
				PHALCON_CALL_METHOD_PARAMS_1(sanitized_value, connection, "escapestring", value, PH_NO_CHECK);
				eval_int = phalcon_array_isset(numeric_typed, field);
				if (eval_int) {
					PHALCON_INIT_VAR(r5);
					PHALCON_CONCAT_VSV(r5, field, " = ", sanitized_value);
					phalcon_array_append(&where_pk, r5, PH_SEPARATE TSRMLS_CC);
				} else {
					PHALCON_INIT_VAR(r6);
					PHALCON_CONCAT_VSVS(r6, field, " = '", sanitized_value, "'");
					phalcon_array_append(&where_pk, r6, PH_SEPARATE TSRMLS_CC);
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_2;
			fee_f9eb_2:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_ALLOC_ZVAL_MM(r7);
		phalcon_fast_count(r7, where_pk TSRMLS_CC);
		if (zend_is_true(r7)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, " AND ", 1);
			PHALCON_ALLOC_ZVAL_MM(r8);
			phalcon_fast_join(r8, c0, where_pk TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_uniqueKey"), r8 TSRMLS_CC);
		} else {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
		
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_forceExists"), PH_NOISY_CC);
		if (!zend_is_true(t3)) {
			PHALCON_INIT_VAR(schema);
			PHALCON_CALL_METHOD(schema, this_ptr, "getschema", PH_NO_CHECK);
			
			PHALCON_INIT_VAR(source);
			PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
			if (zend_is_true(schema)) {
				PHALCON_INIT_VAR(table);
				PHALCON_CONCAT_VSV(table, schema, ".", source);
			} else {
				PHALCON_CPY_WRT(table, source);
			}
			
			PHALCON_ALLOC_ZVAL_MM(t4);
			phalcon_read_property(&t4, this_ptr, SL("_uniqueKey"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(select);
			PHALCON_CONCAT_SVSV(select, "SELECT COUNT(*) AS rowcount FROM ", table, " WHERE ", t4);
			
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, this_ptr, SL("_connection"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(num);
			PHALCON_CALL_METHOD_PARAMS_1(num, t5, "fetchone", select, PH_NO_CHECK);
			
			PHALCON_ALLOC_ZVAL_MM(r9);
			phalcon_array_fetch_string(&r9, num, SL("rowcount"), PH_NOISY_CC);
			
			RETURN_CCTOR(r9);
		} else {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Generate a SQL SELECT statement for an aggregate
 *
 * @param string $function
 * @param string $alias
 * @param array $parameters
 * @return Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Base, _prepareGroupResult){

	zval *function = NULL, *alias = NULL, *parameters = NULL, *manager = NULL, *class_name = NULL;
	zval *model = NULL, *connection = NULL, *params = NULL, *schema = NULL, *source = NULL;
	zval *table = NULL, *group_column = NULL, *select = NULL, *conditions = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &function, &alias, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_STATIC(manager, "phalcon\\model\\manager", "getdefault");
	if (!zend_is_true(manager)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not model manager related to this model");
		return;
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "getmodel", class_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, manager, "getconnection", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setconnection", connection, PH_NO_CHECK);
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("column")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(group_column);
		phalcon_array_fetch_string(&group_column, params, SL("column"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(group_column);
		ZVAL_STRING(group_column, "*", 1);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("distinct")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, params, SL("distinct"), PH_NOISY_CC);
		PHALCON_INIT_VAR(select);
		PHALCON_CONCAT_SVSV(select, "SELECT ", function, "(DISTINCT ", r0);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVSVS(r1, ") AS ", alias, " FROM ", table, " ");
		phalcon_concat_self(&select, r1 TSRMLS_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SL("group")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_array_fetch_string(&r2, params, SL("group"), PH_NOISY_CC);
			PHALCON_INIT_VAR(select);
			PHALCON_CONCAT_SVSVSV(select, "SELECT ", r2, ", ", function, "(", group_column);
			
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CONCAT_SVSVS(r3, ") AS ", alias, " FROM ", table, " ");
			phalcon_concat_self(&select, r3 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(select);
			PHALCON_CONCAT_SVSVS(select, "SELECT ", function, "(", group_column, ") AS ");
			
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CONCAT_VSVS(r4, alias, " FROM ", table, " ");
			phalcon_concat_self(&select, r4 TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(conditions);
	ZVAL_NULL(conditions);
	eval_int = phalcon_array_isset_string(params, SL("conditions")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(conditions);
			phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY_CC);
		}
	}
	
	if (zend_is_true(conditions)) {
		PHALCON_ALLOC_ZVAL_MM(r5);
		PHALCON_CONCAT_SV(r5, " WHERE ", conditions);
		phalcon_concat_self(&select, r5 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("group")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_array_fetch_string(&r6, params, SL("group"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r7);
		PHALCON_CONCAT_SVS(r7, " GROUP BY ", r6, " ");
		phalcon_concat_self(&select, r7 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("having")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r8);
		phalcon_array_fetch_string(&r8, params, SL("having"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r9);
		PHALCON_CONCAT_SVS(r9, " HAVING ", r8, " ");
		phalcon_concat_self(&select, r9 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("order")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r10);
		phalcon_array_fetch_string(&r10, params, SL("order"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r11);
		PHALCON_CONCAT_SVS(r11, " ORDER BY ", r10, " ");
		phalcon_concat_self(&select, r11 TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("limit")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r12);
		phalcon_array_fetch_string(&r12, params, SL("limit"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r13);
		PHALCON_CALL_METHOD_PARAMS_2(r13, connection, "_limit", select, r12, PH_NO_CHECK);
		PHALCON_CPY_WRT(select, r13);
	}
	
	p0[0] = connection;
	p0[1] = params;
	p0[2] = select;
	p0[3] = alias;
	
	PHALCON_ALLOC_ZVAL_MM(r14);
	PHALCON_CALL_SELF_PARAMS(r14, this_ptr, "_getgroupresult", 4, p0);
	RETURN_CTOR(r14);
}

/**
 * Generate a resulset from an aggreate SQL select
 *
 * @param Phalcon_Db $connection
 * @param array $params
 * @param string $sqlSelect
 * @param string $alias
 * @return array|Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Base, _getGroupResult){

	zval *connection = NULL, *params = NULL, *sql_select = NULL, *alias = NULL;
	zval *result = NULL, *count = NULL, *row_object = NULL, *num = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &connection, &params, &sql_select, &alias) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(params, SL("group")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(result);
		PHALCON_CALL_METHOD_PARAMS_1(result, connection, "query", sql_select, PH_NO_CHECK);
		
		PHALCON_INIT_VAR(count);
		PHALCON_CALL_METHOD(count, result, "numrows", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 0);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		is_smaller_function(r0, t0, count TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(row_object);
			object_init_ex(row_object, phalcon_model_row_ce);
			PHALCON_CALL_METHOD_NORETURN(row_object, "__construct", PH_CHECK);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(row_object, "setconnection", connection, PH_NO_CHECK);
		} else {
			PHALCON_INIT_VAR(row_object);
			object_init(row_object);
			
			PHALCON_INIT_VAR(result);
			ZVAL_BOOL(result, 0);
		}
		
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_model_resultset_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", row_object, result, PH_CHECK);
		
		RETURN_CTOR(i0);
	} else {
		PHALCON_INIT_VAR(num);
		PHALCON_CALL_METHOD_PARAMS_1(num, connection, "fetchone", sql_select, PH_NO_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch(&r1, num, alias, PH_NOISY_CC);
		
		RETURN_CCTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Allows to count how many records match the specified conditions
 *
 * @param array $parameters
 * @return int
 */
PHP_METHOD(Phalcon_Model_Base, count){

	zval *parameters = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "COUNT", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "rowcount", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_3(r0, this_ptr, "_preparegroupresult", c0, c1, parameters);
	RETURN_CTOR(r0);
}

/**
 * Allows to a calculate a summatory on a column that match the specified conditions
 *
 * @param array $parameters
 * @return double
 */
PHP_METHOD(Phalcon_Model_Base, sum){

	zval *parameters = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "SUM", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "sumatory", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_3(r0, this_ptr, "_preparegroupresult", c0, c1, parameters);
	RETURN_CTOR(r0);
}

/**
 * Allows to get the maximum value of a column that match the specified conditions
 *
 * @param array $parameters
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Base, maximum){

	zval *parameters = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "MAX", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "maximum", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_3(r0, this_ptr, "_preparegroupresult", c0, c1, parameters);
	RETURN_CTOR(r0);
}

/**
 * Allows to get the minimum value of a column that match the specified conditions
 *
 * @param array $parameters
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Base, minimum){

	zval *parameters = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "MIN", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "minimum", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_3(r0, this_ptr, "_preparegroupresult", c0, c1, parameters);
	RETURN_CTOR(r0);
}

/**
 * Allows to calculate the average value on a column matching the specified conditions
 *
 * @param array $parameters
 * @return double
 */
PHP_METHOD(Phalcon_Model_Base, average){

	zval *parameters = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "AVG", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "average", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_3(r0, this_ptr, "_preparegroupresult", c0, c1, parameters);
	RETURN_CTOR(r0);
}

/**
 * Fires an internal event
 *
 * @param string $eventName
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _callEvent){

	zval *event_name = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_method_exists(this_ptr, event_name TSRMLS_CC) == SUCCESS) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, this_ptr, Z_STRVAL_P(event_name), PH_NO_CHECK);
		if (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Cancel the current operation
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _cancelOperation){

	zval *transaction = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL, *c1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\model\\base"), SL("_disableEvents") TSRMLS_CC);
	if (!zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_operationMade"), PH_NOISY_CC);
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 3);
		PHALCON_ALLOC_ZVAL_MM(r0);
		is_equal_function(r0, t1, t2 TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "notDeleted", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c0, PH_NO_CHECK);
		} else {
			PHALCON_INIT_VAR(c1);
			ZVAL_STRING(c1, "notSaved", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c1, PH_NO_CHECK);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_STATIC(r1, "phalcon\\transaction\\manager", "isautomatic");
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(transaction);
		PHALCON_CALL_STATIC(transaction, "phalcon\\transaction\\manager", "getautomatic");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "setrollbackedrecord", this_ptr, PH_NO_CHECK);
		PHALCON_CALL_METHOD_NORETURN(transaction, "rollback", PH_NO_CHECK);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Appends a customized message on the validation process
 *
 * @param Phalcon_Model_Message $message
 */
PHP_METHOD(Phalcon_Model_Base, appendMessage){

	zval *message = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(message) != IS_OBJECT) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_model_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "gettype", message);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Invalid message format '", r0, "'");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	phalcon_array_append(&t0, message, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Executes validators on every validation call
 *
 * @param string $validatorClass
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_Base, validate){

	zval *validator_class = NULL, *options = NULL, *class_name = NULL;
	zval *field = NULL, *validator = NULL, *values = NULL, *single_field = NULL;
	zval *message = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *i0 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &validator_class, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(class_name);
	PHALCON_CONCAT_SV(class_name, "Phalcon\\Model\\Validator\\", validator_class);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", class_name);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_model_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Validator '", validator_class, "' does not exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Parameter options must be an array");
		return;
	}
	
	eval_int = phalcon_array_isset_string(options, SL("field")+1);
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Field name to be validated is required");
		return;
	} else {
		PHALCON_INIT_VAR(field);
		phalcon_array_fetch_string(&field, options, SL("field"), PH_NOISY_CC);
	}
	
	if (Z_TYPE_P(field) != IS_ARRAY) { 
		ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
		PHALCON_INIT_VAR(validator);
		object_init_ex(validator, ce0);
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property_zval(&t0, this_ptr, field, PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_4_NORETURN(validator, "__construct", this_ptr, field, t0, options, PH_CHECK);
	} else {
		PHALCON_INIT_VAR(values);
		array_init(values);
		if (phalcon_valid_foreach(field TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(field);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_3:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_3;
			}
			
			PHALCON_INIT_VAR(single_field);
			ZVAL_ZVAL(single_field, *hd, 1, 0);
			PHALCON_INIT_VAR(t1);
			phalcon_read_property_zval(&t1, this_ptr, single_field, PH_NOISY_CC);
			phalcon_array_append(&values, t1, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_3;
			fee_f9eb_3:
			if(0){}
		} else {
			return;
		}
		ce1 = phalcon_fetch_class(class_name TSRMLS_CC);
		
		PHALCON_INIT_VAR(validator);
		object_init_ex(validator, ce1);
		PHALCON_CALL_METHOD_PARAMS_4_NORETURN(validator, "__construct", this_ptr, field, values, options, PH_CHECK);
	}
	
	PHALCON_CALL_METHOD_NORETURN(validator, "checkoptions", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD(r2, validator, "validate", PH_NO_CHECK);
	if (Z_TYPE_P(r2) == IS_BOOL && !Z_BVAL_P(r2)) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_METHOD(r3, validator, "getmessages", PH_NO_CHECK);
		if (phalcon_valid_foreach(r3 TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(r3);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_f9eb_4:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_f9eb_4;
			}
			PHALCON_INIT_VAR(message);
			ZVAL_ZVAL(message, *hd, 1, 0);
			PHALCON_INIT_VAR(t2);
			phalcon_read_property(&t2, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
			phalcon_array_append(&t2, message, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t2 TSRMLS_CC);
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_f9eb_4;
			fee_f9eb_4:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether validation process has generated any messages
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, validationHasFailed){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, t1, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns all the validation messages
 *
 * @return Phalcon_Model_Message[]
 */
PHP_METHOD(Phalcon_Model_Base, getMessages){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Reads "belongs to" relations and check the virtual foreign keys when inserting or updating records
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _checkForeignKeys){

	zval *manager = NULL, *belongs_to = NULL, *error = NULL, *relation = NULL, *options = NULL;
	zval *foreign_key = NULL, *conditions = NULL, *referenced_model = NULL;
	zval *fields = NULL, *referenced_fields = NULL, *field = NULL, *n = NULL, *value = NULL;
	zval *rowcount = NULL, *user_message = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;
	zval *i0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(belongs_to);
	PHALCON_CALL_METHOD_PARAMS_1(belongs_to, manager, "getbelongsto", this_ptr, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, belongs_to TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
		if (phalcon_valid_foreach(belongs_to TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(belongs_to);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_5:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_5;
			}
			
			PHALCON_INIT_VAR(relation);
			ZVAL_ZVAL(relation, *hd, 1, 0);
			eval_int = phalcon_array_isset_string(relation, SL("op")+1);
			if (eval_int) {
				PHALCON_INIT_VAR(options);
				phalcon_array_fetch_string(&options, relation, SL("op"), PH_NOISY_CC);
				eval_int = phalcon_array_isset_string(options, SL("foreignKey")+1);
				if (eval_int) {
					PHALCON_INIT_VAR(foreign_key);
					phalcon_array_fetch_string(&foreign_key, options, SL("foreignKey"), PH_NOISY_CC);
					if (zend_is_true(foreign_key)) {
						PHALCON_INIT_VAR(conditions);
						array_init(conditions);
						
						PHALCON_INIT_VAR(r1);
						phalcon_array_fetch_string(&r1, relation, SL("rt"), PH_NOISY_CC);
						
						PHALCON_INIT_VAR(referenced_model);
						PHALCON_CALL_METHOD_PARAMS_1(referenced_model, manager, "getmodel", r1, PH_NO_CHECK);
						
						PHALCON_INIT_VAR(fields);
						phalcon_array_fetch_string(&fields, relation, SL("fi"), PH_NOISY_CC);
						if (Z_TYPE_P(fields) == IS_ARRAY) { 
							PHALCON_INIT_VAR(referenced_fields);
							phalcon_array_fetch_string(&referenced_fields, relation, SL("rf"), PH_NOISY_CC);
							if (phalcon_valid_foreach(fields TSRMLS_CC)) {
								ah1 = Z_ARRVAL_P(fields);
								zend_hash_internal_pointer_reset_ex(ah1, &hp1);
								fes_f9eb_6:
								if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
									goto fee_f9eb_6;
								} else {
									PHALCON_INIT_VAR(n);
									PHALCON_GET_FOREACH_KEY(n, ah1, hp1);
								}
								PHALCON_INIT_VAR(field);
								ZVAL_ZVAL(field, *hd, 1, 0);
								PHALCON_INIT_VAR(value);
								phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
								
								PHALCON_INIT_VAR(r2);
								phalcon_array_fetch(&r2, referenced_fields, n, PH_NOISY_CC);
								
								PHALCON_INIT_VAR(r3);
								PHALCON_CONCAT_VSVS(r3, r2, " = '", value, "'");
								phalcon_array_append(&conditions, r3, PH_SEPARATE TSRMLS_CC);
								zend_hash_move_forward_ex(ah1, &hp1);
								goto fes_f9eb_6;
								fee_f9eb_6:
								if(0){}
							} else {
								return;
							}
						} else {
							PHALCON_INIT_VAR(value);
							phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY_CC);
							
							PHALCON_INIT_VAR(t0);
							ZVAL_NULL(t0);
							
							PHALCON_INIT_VAR(r4);
							is_identical_function(r4, t0, value TSRMLS_CC);
							
							PHALCON_INIT_VAR(t1);
							ZVAL_STRING(t1, "", 1);
							
							PHALCON_INIT_VAR(r5);
							is_identical_function(r5, t1, value TSRMLS_CC);
							
							PHALCON_INIT_VAR(r6);
							ZVAL_BOOL(r6, zend_is_true(r4) || zend_is_true(r5));
							if (zend_is_true(r6)) {
								goto fes_f9eb_5;
							}
							
							PHALCON_INIT_VAR(r7);
							phalcon_array_fetch_string(&r7, relation, SL("rf"), PH_NOISY_CC);
							
							PHALCON_INIT_VAR(r8);
							PHALCON_CONCAT_VSVS(r8, r7, " = '", value, "'");
							phalcon_array_append(&conditions, r8, PH_SEPARATE TSRMLS_CC);
						}
						
						eval_int = phalcon_array_isset_string(foreign_key, SL("conditions")+1);
						if (eval_int) {
							PHALCON_INIT_VAR(r9);
							phalcon_array_fetch_string(&r9, foreign_key, SL("conditions"), PH_NOISY_CC);
							phalcon_array_append(&conditions, r9, PH_SEPARATE TSRMLS_CC);
						}
						
						PHALCON_INIT_VAR(r10);
						PHALCON_CALL_METHOD(r10, this_ptr, "getconnection", PH_NO_CHECK);
						PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "setconnection", r10, PH_NO_CHECK);
						
						PHALCON_INIT_VAR(c0);
						ZVAL_STRING(c0, " AND ", 1);
						
						PHALCON_INIT_VAR(r11);
						phalcon_fast_join(r11, c0, conditions TSRMLS_CC);
						
						PHALCON_INIT_VAR(rowcount);
						PHALCON_CALL_METHOD_PARAMS_1(rowcount, referenced_model, "count", r11, PH_NO_CHECK);
						if (!zend_is_true(rowcount)) {
							eval_int = phalcon_array_isset_string(foreign_key, SL("message")+1);
							if (eval_int) {
								PHALCON_INIT_VAR(user_message);
								phalcon_array_fetch_string(&user_message, foreign_key, SL("message"), PH_NOISY_CC);
							} else {
								if (Z_TYPE_P(fields) == IS_ARRAY) { 
									PHALCON_INIT_VAR(c1);
									ZVAL_STRING(c1, ", ", 1);
									PHALCON_INIT_VAR(r12);
									phalcon_fast_join(r12, c1, fields TSRMLS_CC);
									PHALCON_INIT_VAR(user_message);
									PHALCON_CONCAT_SVS(user_message, "Value of fields \"", r12, "\" does not exist on referenced table");
								} else {
									PHALCON_INIT_VAR(user_message);
									PHALCON_CONCAT_SVS(user_message, "Value of field \"", fields, "\" does not exist on referenced table");
								}
							}
							
							PHALCON_INIT_VAR(i0);
							object_init_ex(i0, phalcon_model_message_ce);
							
							PHALCON_INIT_VAR(c2);
							ZVAL_STRING(c2, "ConstraintViolation", 1);
							PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", user_message, fields, c2, PH_CHECK);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "appendmessage", i0, PH_NO_CHECK);
							
							PHALCON_INIT_VAR(error);
							ZVAL_BOOL(error, 1);
							goto fee_f9eb_5;
						}
					}
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_5;
			fee_f9eb_5:
			if(0){}
		} else {
			return;
		}
		if (zend_is_true(error)) {
			PHALCON_INIT_VAR(c3);
			ZVAL_STRING(c3, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c3, PH_NO_CHECK);
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Reads both "hasMany" and "hasOne" relations and check the virtual foreign keys when deleting records
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _checkForeignKeysReverse){

	zval *manager = NULL, *relations = NULL, *error = NULL, *relation = NULL, *options = NULL;
	zval *foreign_key = NULL, *fields = NULL, *referenced_name = NULL;
	zval *referenced_fields = NULL, *referenced_model = NULL;
	zval *conditions = NULL, *field = NULL, *n = NULL, *value = NULL, *rowcount = NULL, *user_message = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *i0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relations);
	PHALCON_CALL_METHOD_PARAMS_1(relations, manager, "gethasoneandhasmany", this_ptr, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, relations TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
		if (phalcon_valid_foreach(relations TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(relations);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_7:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_7;
			}
			
			PHALCON_INIT_VAR(relation);
			ZVAL_ZVAL(relation, *hd, 1, 0);
			eval_int = phalcon_array_isset_string(relation, SL("op")+1);
			if (eval_int) {
				PHALCON_INIT_VAR(options);
				phalcon_array_fetch_string(&options, relation, SL("op"), PH_NOISY_CC);
				eval_int = phalcon_array_isset_string(options, SL("foreignKey")+1);
				if (eval_int) {
					PHALCON_INIT_VAR(foreign_key);
					phalcon_array_fetch_string(&foreign_key, options, SL("foreignKey"), PH_NOISY_CC);
					if (zend_is_true(foreign_key)) {
						PHALCON_INIT_VAR(fields);
						phalcon_array_fetch_string(&fields, relation, SL("fi"), PH_NOISY_CC);
						
						PHALCON_INIT_VAR(referenced_name);
						phalcon_array_fetch_string(&referenced_name, relation, SL("rt"), PH_NOISY_CC);
						
						PHALCON_INIT_VAR(referenced_fields);
						phalcon_array_fetch_string(&referenced_fields, relation, SL("rf"), PH_NOISY_CC);
						
						PHALCON_INIT_VAR(referenced_model);
						PHALCON_CALL_METHOD_PARAMS_1(referenced_model, manager, "getmodel", referenced_name, PH_NO_CHECK);
						
						PHALCON_INIT_VAR(conditions);
						array_init(conditions);
						if (Z_TYPE_P(fields) == IS_ARRAY) { 
							if (phalcon_valid_foreach(fields TSRMLS_CC)) {
								ah1 = Z_ARRVAL_P(fields);
								zend_hash_internal_pointer_reset_ex(ah1, &hp1);
								fes_f9eb_8:
								if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
									goto fee_f9eb_8;
								} else {
									PHALCON_INIT_VAR(n);
									PHALCON_GET_FOREACH_KEY(n, ah1, hp1);
								}
								PHALCON_INIT_VAR(field);
								ZVAL_ZVAL(field, *hd, 1, 0);
								PHALCON_INIT_VAR(value);
								phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
								
								PHALCON_INIT_VAR(r1);
								phalcon_array_fetch(&r1, referenced_fields, n, PH_NOISY_CC);
								
								PHALCON_INIT_VAR(r2);
								PHALCON_CONCAT_VSVS(r2, r1, " = '", value, "'");
								phalcon_array_append(&conditions, r2, PH_SEPARATE TSRMLS_CC);
								zend_hash_move_forward_ex(ah1, &hp1);
								goto fes_f9eb_8;
								fee_f9eb_8:
								if(0){}
							} else {
								return;
							}
						} else {
							PHALCON_INIT_VAR(value);
							phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY_CC);
							
							PHALCON_INIT_VAR(r3);
							PHALCON_CONCAT_VSVS(r3, referenced_fields, " = '", value, "'");
							phalcon_array_append(&conditions, r3, PH_SEPARATE TSRMLS_CC);
						}
						
						eval_int = phalcon_array_isset_string(foreign_key, SL("conditions")+1);
						if (eval_int) {
							PHALCON_INIT_VAR(r4);
							phalcon_array_fetch_string(&r4, foreign_key, SL("conditions"), PH_NOISY_CC);
							phalcon_array_append(&conditions, r4, PH_SEPARATE TSRMLS_CC);
						}
						
						PHALCON_INIT_VAR(r5);
						PHALCON_CALL_METHOD(r5, this_ptr, "getconnection", PH_NO_CHECK);
						PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "setconnection", r5, PH_NO_CHECK);
						
						PHALCON_INIT_VAR(c0);
						ZVAL_STRING(c0, " AND ", 1);
						
						PHALCON_INIT_VAR(r6);
						phalcon_fast_join(r6, c0, conditions TSRMLS_CC);
						
						PHALCON_INIT_VAR(rowcount);
						PHALCON_CALL_METHOD_PARAMS_1(rowcount, referenced_model, "count", r6, PH_NO_CHECK);
						if (zend_is_true(rowcount)) {
							eval_int = phalcon_array_isset_string(foreign_key, SL("message")+1);
							if (eval_int) {
								PHALCON_INIT_VAR(user_message);
								phalcon_array_fetch_string(&user_message, foreign_key, SL("message"), PH_NOISY_CC);
							} else {
								PHALCON_INIT_VAR(user_message);
								PHALCON_CONCAT_SV(user_message, "Record is referenced by model ", referenced_name);
							}
							
							PHALCON_INIT_VAR(i0);
							object_init_ex(i0, phalcon_model_message_ce);
							
							PHALCON_INIT_VAR(c1);
							ZVAL_STRING(c1, "ConstraintViolation", 1);
							PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", user_message, fields, c1, PH_CHECK);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "appendmessage", i0, PH_NO_CHECK);
							
							PHALCON_INIT_VAR(error);
							ZVAL_BOOL(error, 1);
							goto fee_f9eb_7;
						}
					}
				}
			}
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_7;
			fee_f9eb_7:
			if(0){}
		} else {
			return;
		}
		if (zend_is_true(error)) {
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c2, PH_NO_CHECK);
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Executes internal events before save a record
 *
 * @param boolean $disableEvents
 * @param boolean $exists
 * @param string $identityField
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _preSave){

	zval *disable_events = NULL, *exists = NULL, *identity_field = NULL;
	zval *generator = NULL, *not_null = NULL, *data_type_numeric = NULL;
	zval *error = NULL, *num_fields = NULL, *i = NULL, *is_null = NULL, *field = NULL, *value = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL, *c4 = NULL, *c5 = NULL, *c6 = NULL;
	zval *c7 = NULL, *c8 = NULL, *c9 = NULL, *c10 = NULL, *c11 = NULL, *c12 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL, *r18 = NULL, *r19 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *i0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &disable_events, &exists, &identity_field) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "beforeValidation", 1);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "_callevent", c0, PH_NO_CHECK);
		if (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0)) {
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
		if (!zend_is_true(exists)) {
			PHALCON_INIT_VAR(c1);
			ZVAL_STRING(c1, "beforeValidationOnCreate", 1);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "_callevent", c1, PH_NO_CHECK);
			if (Z_TYPE_P(r1) == IS_BOOL && !Z_BVAL_P(r1)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		} else {
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "beforeValidationOnUpdate", 1);
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD_PARAMS_1(r2, this_ptr, "_callevent", c2, PH_NO_CHECK);
			if (Z_TYPE_P(r2) == IS_BOOL && !Z_BVAL_P(r2)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	
	PHALCON_INIT_VAR(generator);
	ZVAL_NULL(generator);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, this_ptr, "_checkforeignkeys", PH_NO_CHECK);
	if (Z_TYPE_P(r3) == IS_BOOL && !Z_BVAL_P(r3)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(not_null);
	PHALCON_CALL_METHOD(not_null, this_ptr, "getnotnullattributes", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(data_type_numeric);
	PHALCON_CALL_METHOD(data_type_numeric, this_ptr, "getdatatypesnumeric", PH_NO_CHECK);
	if (Z_TYPE_P(not_null) == IS_ARRAY) { 
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
		
		PHALCON_INIT_VAR(num_fields);
		phalcon_fast_count(num_fields, not_null TSRMLS_CC);
		
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 0);
		fs_f9eb_9:
			
			PHALCON_INIT_VAR(r4);
			is_smaller_function(r4, i, num_fields TSRMLS_CC);
			if (!zend_is_true(r4)) {
				goto fe_f9eb_9;
			}
			PHALCON_INIT_VAR(is_null);
			ZVAL_BOOL(is_null, 0);
			
			PHALCON_INIT_VAR(field);
			phalcon_array_fetch(&field, not_null, i, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(value);
			phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
			eval_int = phalcon_array_isset(data_type_numeric, field);
			if (!eval_int) {
				PHALCON_INIT_VAR(t0);
				ZVAL_NULL(t0);
				PHALCON_INIT_VAR(r5);
				is_identical_function(r5, t0, value TSRMLS_CC);
				PHALCON_INIT_VAR(t1);
				ZVAL_STRING(t1, "", 1);
				PHALCON_INIT_VAR(r6);
				is_identical_function(r6, t1, value TSRMLS_CC);
				PHALCON_INIT_VAR(r7);
				ZVAL_BOOL(r7, zend_is_true(r5) || zend_is_true(r6));
				if (zend_is_true(r7)) {
					PHALCON_INIT_VAR(is_null);
					ZVAL_BOOL(is_null, 1);
				}
			} else {
				PHALCON_INIT_VAR(r8);
				PHALCON_CALL_FUNC_PARAMS_1(r8, "is_numeric", value);
				if (!zend_is_true(r8)) {
					PHALCON_INIT_VAR(is_null);
					ZVAL_BOOL(is_null, 1);
				}
			}
			
			if (zend_is_true(is_null)) {
				PHALCON_INIT_VAR(r9);
				boolean_not_function(r9, exists TSRMLS_CC);
				PHALCON_INIT_VAR(r10);
				is_equal_function(r10, field, identity_field TSRMLS_CC);
				PHALCON_INIT_VAR(r11);
				phalcon_and_function(r11, r9, r10);
				if (zend_is_true(r11)) {
					goto fi_f9eb_9;
				}
				
				PHALCON_INIT_VAR(i0);
				object_init_ex(i0, phalcon_model_message_ce);
				
				PHALCON_INIT_VAR(r12);
				PHALCON_CONCAT_VS(r12, field, " is required");
				
				PHALCON_INIT_VAR(c3);
				ZVAL_STRING(c3, "PresenceOf", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", r12, field, c3, PH_CHECK);
				
				PHALCON_INIT_VAR(t2);
				phalcon_read_property(&t2, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
				phalcon_array_append(&t2, i0, 0 TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t2 TSRMLS_CC);
				
				PHALCON_INIT_VAR(error);
				ZVAL_BOOL(error, 1);
			}
			fi_f9eb_9:
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto fs_f9eb_9;
		fe_f9eb_9:
		if (zend_is_true(error)) {
			if (!zend_is_true(disable_events)) {
				PHALCON_INIT_VAR(c4);
				ZVAL_STRING(c4, "onValidationFails", 1);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c4, PH_NO_CHECK);
			}
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(c5);
	ZVAL_STRING(c5, "validation", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r13);
	PHALCON_CALL_METHOD_PARAMS_1(r13, this_ptr, "_callevent", c5, PH_NO_CHECK);
	if (Z_TYPE_P(r13) == IS_BOOL && !Z_BVAL_P(r13)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_VAR(c6);
			ZVAL_STRING(c6, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c6, PH_NO_CHECK);
		}
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	if (!zend_is_true(disable_events)) {
		if (!zend_is_true(exists)) {
			PHALCON_INIT_VAR(c7);
			ZVAL_STRING(c7, "afterValidationOnCreate", 1);
			PHALCON_ALLOC_ZVAL_MM(r14);
			PHALCON_CALL_METHOD_PARAMS_1(r14, this_ptr, "_callevent", c7, PH_NO_CHECK);
			if (Z_TYPE_P(r14) == IS_BOOL && !Z_BVAL_P(r14)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		} else {
			PHALCON_INIT_VAR(c8);
			ZVAL_STRING(c8, "afterValidationOnUpdate", 1);
			PHALCON_ALLOC_ZVAL_MM(r15);
			PHALCON_CALL_METHOD_PARAMS_1(r15, this_ptr, "_callevent", c8, PH_NO_CHECK);
			if (Z_TYPE_P(r15) == IS_BOOL && !Z_BVAL_P(r15)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
		
		PHALCON_INIT_VAR(c9);
		ZVAL_STRING(c9, "afterValidation", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r16);
		PHALCON_CALL_METHOD_PARAMS_1(r16, this_ptr, "_callevent", c9, PH_NO_CHECK);
		if (Z_TYPE_P(r16) == IS_BOOL && !Z_BVAL_P(r16)) {
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
		
		PHALCON_INIT_VAR(c10);
		ZVAL_STRING(c10, "beforeSave", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r17);
		PHALCON_CALL_METHOD_PARAMS_1(r17, this_ptr, "_callevent", c10, PH_NO_CHECK);
		if (Z_TYPE_P(r17) == IS_BOOL && !Z_BVAL_P(r17)) {
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
		
		if (zend_is_true(exists)) {
			PHALCON_INIT_VAR(c11);
			ZVAL_STRING(c11, "beforeUpdate", 1);
			PHALCON_ALLOC_ZVAL_MM(r18);
			PHALCON_CALL_METHOD_PARAMS_1(r18, this_ptr, "_callevent", c11, PH_NO_CHECK);
			if (Z_TYPE_P(r18) == IS_BOOL && !Z_BVAL_P(r18)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		} else {
			PHALCON_INIT_VAR(c12);
			ZVAL_STRING(c12, "beforeCreate", 1);
			PHALCON_ALLOC_ZVAL_MM(r19);
			PHALCON_CALL_METHOD_PARAMS_1(r19, this_ptr, "_callevent", c12, PH_NO_CHECK);
			if (Z_TYPE_P(r19) == IS_BOOL && !Z_BVAL_P(r19)) {
				PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Executes internal events after save a record
 *
 * @param boolean $disableEvents
 * @param boolean $success
 * @param boolean $exists
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _postSave){

	zval *disable_events = NULL, *success = NULL, *exists = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &disable_events, &success, &exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(success)) {
		if (zend_is_true(exists)) {
			if (!zend_is_true(disable_events)) {
				PHALCON_INIT_VAR(c0);
				ZVAL_STRING(c0, "afterUpdate", 1);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c0, PH_NO_CHECK);
			}
		} else {
			if (!zend_is_true(disable_events)) {
				PHALCON_INIT_VAR(c1);
				ZVAL_STRING(c1, "afterCreate", 1);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c1, PH_NO_CHECK);
			}
		}
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "afterSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c2, PH_NO_CHECK);
		}
		
		
		RETURN_CCTOR(success);
	} else {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_VAR(c3);
			ZVAL_STRING(c3, "notSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c3, PH_NO_CHECK);
		}
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_canceloperation", PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Sends a pre-build INSET SQL statement to the relational database system
 *
 * @param Phalcon_Db $connection
 * @param string $table
 * @param array $dataType
 * @param array $dataTypeNumeric
 * @param string $identityField
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _doLowInsert){

	zval *connection = NULL, *table = NULL, *data_type = NULL, *data_type_numeric = NULL;
	zval *identity_field = NULL, *fields = NULL, *values = NULL, *attributes = NULL;
	zval *field = NULL, *value = NULL, *id = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzzz", &connection, &table, &data_type, &data_type_numeric, &identity_field) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD(attributes, this_ptr, "getattributes", PH_NO_CHECK);
	if (phalcon_valid_foreach(attributes TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(attributes);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_f9eb_10:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_f9eb_10;
		}
		
		PHALCON_INIT_VAR(field);
		ZVAL_ZVAL(field, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		is_not_equal_function(r0, field, identity_field TSRMLS_CC);
		if (zend_is_true(r0)) {
			phalcon_array_append(&fields, field, PH_SEPARATE TSRMLS_CC);
			
			PHALCON_INIT_VAR(value);
			phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
			if (Z_TYPE_P(value) == IS_OBJECT) {
				PHALCON_INIT_VAR(r1);
				phalcon_instance_of(r1, value, phalcon_db_rawvalue_ce TSRMLS_CC);
				if (zend_is_true(r1)) {
					PHALCON_INIT_VAR(r2);
					PHALCON_CALL_METHOD(r2, value, "getvalue", PH_NO_CHECK);
					phalcon_array_append(&values, r2, PH_SEPARATE TSRMLS_CC);
				} else {
					PHALCON_INIT_VAR(r3);
					PHALCON_CALL_FUNC_PARAMS_1(r3, "strval", value);
					phalcon_array_append(&values, r3, PH_SEPARATE TSRMLS_CC);
				}
			} else {
				PHALCON_INIT_VAR(t0);
				ZVAL_STRING(t0, "", 1);
				PHALCON_INIT_VAR(r4);
				is_identical_function(r4, t0, value TSRMLS_CC);
				PHALCON_INIT_VAR(t1);
				ZVAL_NULL(t1);
				PHALCON_INIT_VAR(r5);
				is_identical_function(r5, t1, value TSRMLS_CC);
				PHALCON_INIT_VAR(r6);
				ZVAL_BOOL(r6, zend_is_true(r4) || zend_is_true(r5));
				if (zend_is_true(r6)) {
					PHALCON_INIT_VAR(t2);
					ZVAL_STRING(t2, "NULL", 1);
					phalcon_array_append(&values, t2, PH_SEPARATE TSRMLS_CC);
				} else {
					eval_int = phalcon_array_isset(data_type_numeric, field);
					if (eval_int) {
						phalcon_array_append(&values, value, PH_SEPARATE TSRMLS_CC);
					} else {
						PHALCON_INIT_VAR(r7);
						phalcon_array_fetch(&r7, data_type, field, PH_NOISY_CC);
						if (PHALCON_COMPARE_STRING(r7, "date")) {
							PHALCON_INIT_VAR(t3);
							phalcon_read_property(&t3, this_ptr, SL("_connection"), PH_NOISY_CC);
							PHALCON_INIT_VAR(r8);
							PHALCON_CALL_METHOD_PARAMS_1(r8, t3, "getdateusingformat", value, PH_NO_CHECK);
							phalcon_array_append(&values, r8, PH_SEPARATE TSRMLS_CC);
						} else {
							PHALCON_INIT_VAR(r9);
							PHALCON_CONCAT_SVS(r9, "'", value, "'");
							phalcon_array_append(&values, r9, PH_SEPARATE TSRMLS_CC);
						}
					}
				}
			}
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_f9eb_10;
		fee_f9eb_10:
		if(0){}
	} else {
		return;
	}
	if (zend_is_true(identity_field)) {
		PHALCON_INIT_VAR(id);
		phalcon_read_property_zval(&id, this_ptr, identity_field, PH_NOISY_CC);
		phalcon_array_append(&fields, identity_field, PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r10);
		PHALCON_CALL_FUNC_PARAMS_1(r10, "is_null", id);
		
		PHALCON_INIT_VAR(t4);
		ZVAL_STRING(t4, "", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r11);
		is_identical_function(r11, t4, id TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r12);
		ZVAL_BOOL(r12, zend_is_true(r10) || zend_is_true(r11));
		if (zend_is_true(r12)) {
			PHALCON_INIT_VAR(t5);
			ZVAL_STRING(t5, "null", 1);
			phalcon_array_append(&values, t5, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_append(&values, id, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r13);
	PHALCON_CALL_METHOD_PARAMS_3(r13, connection, "insert", table, values, fields, PH_NO_CHECK);
	RETURN_CTOR(r13);
}

/**
 * Sends a pre-build UPDATE SQL statement to the relational database system
 *
 * @param Phalcon_Db $connection
 * @param string $table
 * @param array $dataType
 * @param array $dataTypeNumeric
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, _doLowUpdate){

	zval *connection = NULL, *table = NULL, *data_type = NULL, *data_type_numeric = NULL;
	zval *fields = NULL, *values = NULL, *non_primary = NULL, *field = NULL, *value = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &connection, &table, &data_type, &data_type_numeric) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(non_primary);
	PHALCON_CALL_METHOD(non_primary, this_ptr, "getnonprimarykeyattributes", PH_NO_CHECK);
	if (phalcon_valid_foreach(non_primary TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(non_primary);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_f9eb_11:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_f9eb_11;
		}
		
		PHALCON_INIT_VAR(field);
		ZVAL_ZVAL(field, *hd, 1, 0);
		phalcon_array_append(&fields, field, PH_SEPARATE TSRMLS_CC);
		
		PHALCON_INIT_VAR(value);
		phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
		if (Z_TYPE_P(value) == IS_OBJECT) {
			PHALCON_INIT_VAR(r0);
			phalcon_instance_of(r0, value, phalcon_db_rawvalue_ce TSRMLS_CC);
			if (zend_is_true(r0)) {
				PHALCON_INIT_VAR(r1);
				PHALCON_CALL_METHOD(r1, value, "getvalue", PH_NO_CHECK);
				phalcon_array_append(&values, r1, PH_SEPARATE TSRMLS_CC);
			} else {
				PHALCON_INIT_VAR(r2);
				PHALCON_CALL_FUNC_PARAMS_1(r2, "strval", value);
				phalcon_array_append(&values, r2, PH_SEPARATE TSRMLS_CC);
			}
		} else {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, "", 1);
			PHALCON_INIT_VAR(r3);
			is_identical_function(r3, t0, value TSRMLS_CC);
			PHALCON_INIT_VAR(t1);
			ZVAL_NULL(t1);
			PHALCON_INIT_VAR(r4);
			is_identical_function(r4, t1, value TSRMLS_CC);
			PHALCON_INIT_VAR(r5);
			ZVAL_BOOL(r5, zend_is_true(r3) || zend_is_true(r4));
			if (zend_is_true(r5)) {
				PHALCON_INIT_VAR(t2);
				ZVAL_STRING(t2, "NULL", 1);
				phalcon_array_append(&values, t2, PH_SEPARATE TSRMLS_CC);
			} else {
				eval_int = phalcon_array_isset(data_type_numeric, field);
				if (eval_int) {
					phalcon_array_append(&values, value, PH_SEPARATE TSRMLS_CC);
				} else {
					PHALCON_INIT_VAR(r6);
					phalcon_array_fetch(&r6, data_type, field, PH_NOISY_CC);
					if (PHALCON_COMPARE_STRING(r6, "date")) {
						PHALCON_INIT_VAR(r7);
						PHALCON_CALL_METHOD_PARAMS_1(r7, connection, "getdateusingformat", value, PH_NO_CHECK);
						phalcon_array_append(&values, r7, PH_SEPARATE TSRMLS_CC);
					} else {
						PHALCON_INIT_VAR(r8);
						PHALCON_CONCAT_SVS(r8, "'", value, "'");
						phalcon_array_append(&values, r8, PH_SEPARATE TSRMLS_CC);
					}
				}
			}
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_f9eb_11;
		fee_f9eb_11:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("_uniqueKey"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r9);
	PHALCON_CALL_METHOD_PARAMS_4(r9, connection, "update", table, fields, values, t3, PH_NO_CHECK);
	RETURN_CTOR(r9);
}

/**
 * Inserts or updates a model instance. Returning true on success or false otherwise.
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, save){

	zval *connection = NULL, *exists = NULL, *disable_events = NULL, *identity_field = NULL;
	zval *schema = NULL, *source = NULL, *table = NULL, *data_type = NULL, *primary_keys = NULL;
	zval *data_type_numeric = NULL, *success = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *p1[] = { NULL, NULL, NULL, NULL, NULL };

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_1(exists, this_ptr, "_exists", connection, PH_NO_CHECK);
	if (!zend_is_true(exists)) {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 1 TSRMLS_CC);
	} else {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 2 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), a0 TSRMLS_CC);
	PHALCON_OBSERVE_VAR(disable_events);
	phalcon_read_static_property(&disable_events, SL("phalcon\\model\\base"), SL("_disableEvents") TSRMLS_CC);
	
	PHALCON_INIT_VAR(identity_field);
	PHALCON_CALL_METHOD(identity_field, this_ptr, "getidentityfield", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_3(r0, this_ptr, "_presave", disable_events, exists, identity_field, PH_NO_CHECK);
	if (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, this_ptr, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_INIT_VAR(data_type);
	PHALCON_CALL_METHOD(data_type, this_ptr, "getdatatypes", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(primary_keys);
	PHALCON_CALL_METHOD(primary_keys, this_ptr, "getprimarykeyattributes", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(data_type_numeric);
	PHALCON_CALL_METHOD(data_type_numeric, this_ptr, "getdatatypesnumeric", PH_NO_CHECK);
	if (zend_is_true(exists)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_4(success, this_ptr, "_dolowupdate", connection, table, data_type, data_type_numeric, PH_NO_CHECK);
	} else {
		p1[0] = connection;
		p1[1] = table;
		p1[2] = data_type;
		p1[3] = data_type_numeric;
		p1[4] = identity_field;
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS(r1, this_ptr, "_dolowinsert", 5, p1, PH_NO_CHECK);
		PHALCON_CPY_WRT(success, r1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD(r2, connection, "isundertransaction", PH_NO_CHECK);
	if (!zend_is_true(r2)) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_METHOD(r3, connection, "gethaveautocommit", PH_NO_CHECK);
		if (zend_is_true(r3)) {
			PHALCON_CALL_METHOD_NORETURN(connection, "commit", PH_NO_CHECK);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CALL_METHOD_PARAMS_3(r4, this_ptr, "_postsave", disable_events, success, exists, PH_NO_CHECK);
	RETURN_CTOR(r4);
}

/**
 * Deletes a model instance. Returning true on success or false otherwise.
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Base, delete){

	zval *table = NULL, *primary_keys = NULL, *primary_key_value = NULL;
	zval *conditions = NULL, *primary_key = NULL, *disable_events = NULL;
	zval *success = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_schema"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_schema"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_source"), PH_NOISY_CC);
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, t1, ".", t2);
	} else {
		PHALCON_INIT_VAR(table);
		phalcon_read_property(&table, this_ptr, SL("_source"), PH_NOISY_CC);
	}
	
	phalcon_update_property_long(this_ptr, SL("_operationMade"), 3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "_checkforeignkeysreverse", PH_NO_CHECK);
	if (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(primary_keys);
	PHALCON_CALL_METHOD(primary_keys, this_ptr, "getprimarykeyattributes", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_count(r1, primary_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 1);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	is_equal_function(r2, r1, t3 TSRMLS_CC);
	if (zend_is_true(r2)) {
		PHALCON_INIT_VAR(primary_key_value);
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_array_fetch_long(&r3, primary_keys, 0, PH_NOISY_CC);
		phalcon_read_property_zval(&primary_key_value, this_ptr, r3, PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r4);
		phalcon_array_fetch_long(&r4, primary_keys, 0, PH_NOISY_CC);
		
		PHALCON_INIT_VAR(conditions);
		PHALCON_CONCAT_VSVS(conditions, r4, " = '", primary_key_value, "'");
	} else {
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
		if (phalcon_valid_foreach(primary_keys TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(primary_keys);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_f9eb_12:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_f9eb_12;
			}
			
			PHALCON_INIT_VAR(primary_key);
			ZVAL_ZVAL(primary_key, *hd, 1, 0);
			PHALCON_INIT_VAR(primary_key_value);
			phalcon_read_property_zval(&primary_key_value, this_ptr, primary_key, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r5);
			PHALCON_CONCAT_VSVS(r5, primary_key, " = '", primary_key_value, "'");
			phalcon_array_append(&conditions, r5, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_f9eb_12;
			fee_f9eb_12:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, " AND ", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r6);
		phalcon_fast_join(r6, c0, conditions TSRMLS_CC);
		PHALCON_CPY_WRT(conditions, r6);
	}
	
	PHALCON_OBSERVE_VAR(disable_events);
	phalcon_read_static_property(&disable_events, SL("phalcon\\model\\base"), SL("_disableEvents") TSRMLS_CC);
	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "beforeDelete", 1);
		PHALCON_ALLOC_ZVAL_MM(r7);
		PHALCON_CALL_METHOD_PARAMS_1(r7, this_ptr, "_callevent", c1, PH_NO_CHECK);
		if (Z_TYPE_P(r7) == IS_BOOL && !Z_BVAL_P(r7)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_2(success, t4, "delete", table, conditions, PH_NO_CHECK);
	if (zend_is_true(success)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_VAR(c2);
			ZVAL_STRING(c2, "afterDelete", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", c2, PH_NO_CHECK);
		}
	}
	
	
	RETURN_CCTOR(success);
}

/**
 * Reads an attribute value by its name
 *
 * @param string $attribute
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Base, readAttribute){

	zval *attribute = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attribute) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dump"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property_zval(&t1, this_ptr, attribute, PH_NOISY_CC);
	
	RETURN_CCTOR(t1);
}

/**
 * Writes an attribute value by its name
 *
 * @param string $attribute
 * @param mixed $value
 */
PHP_METHOD(Phalcon_Model_Base, writeAttribute){

	zval *attribute = NULL, *value = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &attribute, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dumped"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	}
	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Setup a 1-1 relation between two models
 *
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param   array $options
 */
PHP_METHOD(Phalcon_Model_Base, hasOne){

	zval *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *manager = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (zend_is_true(manager)) {
		p0[0] = this_ptr;
		p0[1] = fields;
		p0[2] = reference_model;
		p0[3] = referenced_fields;
		p0[4] = options;
		PHALCON_CALL_METHOD_PARAMS_NORETURN(manager, "addhasone", 5, p0, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Setup a relation reverse 1-1  between two models
 *
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param   array $options
 */
PHP_METHOD(Phalcon_Model_Base, belongsTo){

	zval *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *manager = NULL;
	zval *a0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (zend_is_true(manager)) {
		p0[0] = this_ptr;
		p0[1] = fields;
		p0[2] = reference_model;
		p0[3] = referenced_fields;
		p0[4] = options;
		PHALCON_CALL_METHOD_PARAMS_NORETURN(manager, "addbelongsto", 5, p0, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Setup a relation 1-n between two models
 *
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param   array $options
 */
PHP_METHOD(Phalcon_Model_Base, hasMany){

	zval *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *manager = NULL;
	zval *a0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL };

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (zend_is_true(manager)) {
		p0[0] = this_ptr;
		p0[1] = fields;
		p0[2] = reference_model;
		p0[3] = referenced_fields;
		p0[4] = options;
		PHALCON_CALL_METHOD_PARAMS_NORETURN(manager, "addhasmany", 5, p0, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Handles methods when a method does not exist
 *
 * @param string $method
 * @param array $arguments
 * @return mixed
 * @throwsPhalcon_Model_Exception
 */
PHP_METHOD(Phalcon_Model_Base, __call){

	zval *method = NULL, *arguments = NULL, *manager_method = NULL, *model_name = NULL;
	zval *manager = NULL, *requested_relation = NULL, *query_method = NULL;
	zval *model_args = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL, *c4 = NULL, *c5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(arguments, a0);
	}
	
	PHALCON_INIT_VAR(manager_method);
	ZVAL_BOOL(manager_method, 0);
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, this_ptr TSRMLS_CC);
	
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 0);
	
	PHALCON_INIT_VAR(c1);
	ZVAL_LONG(c1, 3);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_3(r0, "substr", method, c0, c1);
	if (PHALCON_COMPARE_STRING(r0, "get")) {
		PHALCON_INIT_VAR(c2);
		ZVAL_LONG(c2, 3);
		PHALCON_INIT_VAR(requested_relation);
		PHALCON_CALL_FUNC_PARAMS_2(requested_relation, "substr", method, c2);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD_PARAMS_2(r1, manager, "existsbelongsto", model_name, requested_relation, PH_NO_CHECK);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(manager_method);
			ZVAL_STRING(manager_method, "getBelongsToRecords", 1);
			
			PHALCON_INIT_VAR(query_method);
			ZVAL_STRING(query_method, "findFirst", 1);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD_PARAMS_2(r2, manager, "existshasmany", model_name, requested_relation, PH_NO_CHECK);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(manager_method);
				ZVAL_STRING(manager_method, "getHasManyRecords", 1);
				
				PHALCON_INIT_VAR(query_method);
				ZVAL_STRING(query_method, "find", 1);
			} else {
				PHALCON_ALLOC_ZVAL_MM(r3);
				PHALCON_CALL_METHOD_PARAMS_2(r3, manager, "existshasone", model_name, requested_relation, PH_NO_CHECK);
				if (zend_is_true(r3)) {
					PHALCON_INIT_VAR(manager_method);
					ZVAL_STRING(manager_method, "getHasOneRecords", 1);
					
					PHALCON_INIT_VAR(query_method);
					ZVAL_STRING(query_method, "findFirst", 1);
				}
			}
		}
	}
	
	if (!zend_is_true(manager_method)) {
		PHALCON_INIT_VAR(c3);
		ZVAL_LONG(c3, 0);
		PHALCON_INIT_VAR(c4);
		ZVAL_LONG(c4, 5);
		PHALCON_ALLOC_ZVAL_MM(r4);
		PHALCON_CALL_FUNC_PARAMS_3(r4, "substr", method, c3, c4);
		if (PHALCON_COMPARE_STRING(r4, "count")) {
			PHALCON_INIT_VAR(query_method);
			ZVAL_STRING(query_method, "count", 1);
			
			PHALCON_INIT_VAR(c5);
			ZVAL_LONG(c5, 5);
			
			PHALCON_INIT_VAR(requested_relation);
			PHALCON_CALL_FUNC_PARAMS_2(requested_relation, "substr", method, c5);
			
			PHALCON_ALLOC_ZVAL_MM(r5);
			PHALCON_CALL_METHOD_PARAMS_2(r5, manager, "existsbelongsto", model_name, requested_relation, PH_NO_CHECK);
			if (zend_is_true(r5)) {
				PHALCON_INIT_VAR(manager_method);
				ZVAL_STRING(manager_method, "getBelongsToRecords", 1);
			} else {
				PHALCON_ALLOC_ZVAL_MM(r6);
				PHALCON_CALL_METHOD_PARAMS_2(r6, manager, "existshasmany", model_name, requested_relation, PH_NO_CHECK);
				if (zend_is_true(r6)) {
					PHALCON_INIT_VAR(manager_method);
					ZVAL_STRING(manager_method, "getHasManyRecords", 1);
				} else {
					PHALCON_ALLOC_ZVAL_MM(r7);
					PHALCON_CALL_METHOD_PARAMS_2(r7, manager, "existshasone", model_name, requested_relation, PH_NO_CHECK);
					if (zend_is_true(r7)) {
						PHALCON_INIT_VAR(manager_method);
						ZVAL_STRING(manager_method, "getHasOneRecords", 1);
					}
				}
			}
		}
	}
	
	if (zend_is_true(manager_method)) {
		PHALCON_INIT_VAR(model_args);
		array_init(model_args);
		phalcon_array_append(&model_args, query_method, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&model_args, model_name, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&model_args, requested_relation, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&model_args, this_ptr, PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		phalcon_array_append(&a1, manager, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&a1, manager_method, PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r8);
		PHALCON_CALL_FUNC_PARAMS_2(r8, "array_merge", model_args, arguments);
		
		PHALCON_ALLOC_ZVAL_MM(r9);
		PHALCON_CALL_FUNC_PARAMS_2(r9, "call_user_func_array", a1, r8);
		RETURN_CTOR(r9);
	}
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_model_exception_ce);
	
	PHALCON_ALLOC_ZVAL_MM(r10);
	PHALCON_CONCAT_SVSVS(r10, "The method \"", method, "\" doesn't exist on model \"", model_name, "\"");
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r10, PH_CHECK);
	phalcon_throw_exception(i0 TSRMLS_CC);
	return;
}

/* ------ Finished File: \model\base.c ------ */

/* ------ Starting File: \model\validator.c ------ */
/**
 * Phalcon\Model\Validator
 *
 * This is the base class for all the Phalcon\Model buit-in validators 
 */

/**
 * Phalcon\Model\Validator constructor
 *
 * @param Phalcon\Model\Base $record
 * @param string $fieldName
 * @param string $value
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_Validator, __construct){

	zval *record = NULL, *field_name = NULL, *value = NULL, *options = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_model_validator_ce, this_ptr, SL("_options"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_model_validator_ce, this_ptr, SL("_messages"), a1 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &record, &field_name, &value, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a2);
		array_init(a2);
		PHALCON_CPY_WRT(options, a2);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_record"), record TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_fieldName"), field_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_value"), value TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Appends a message to the validator
 *
 * @param string $message
 * @param string $field
 * @param string $type
 */
PHP_METHOD(Phalcon_Model_Validator, appendMessage){

	zval *message = NULL, *field = NULL, *type = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;
	zval *i0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &message, &field, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!field) {
		PHALCON_ALLOC_ZVAL_MM(field);
		ZVAL_NULL(field);
	} else {
		PHALCON_SEPARATE_PARAM(field);
	}
	
	if (!type) {
		PHALCON_ALLOC_ZVAL_MM(type);
		ZVAL_NULL(type);
	} else {
		PHALCON_SEPARATE_PARAM(type);
	}
	
	if (!zend_is_true(field)) {
		PHALCON_INIT_VAR(field);
		phalcon_read_property(&field, this_ptr, SL("_fieldName"), PH_NOISY_CC);
	}
	if (!zend_is_true(type)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "Validator", 1);
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, "", 1);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_get_class(r0, this_ptr TSRMLS_CC);
		PHALCON_INIT_VAR(type);
		phalcon_fast_str_replace(type, c0, c1, r0 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_model_message_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", message, field, type, PH_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_messages"), PH_NOISY_CC);
	phalcon_array_append(&t0, i0, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_messages"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns messages generated by the validator
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Validator, getMessages){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_messages"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Check whether option "required" has been passed as option
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator, isRequired){

	zval *required = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(required);
	ZVAL_BOOL(required, 1);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_value"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_STRING(t1, "", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_identical_function(r0, t1, t0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_value"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t3);
	ZVAL_NULL(t3);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_identical_function(r1, t3, t2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	ZVAL_BOOL(r2, zend_is_true(r0) || zend_is_true(r1));
	if (zend_is_true(r2)) {
		PHALCON_ALLOC_ZVAL_MM(t4);
		phalcon_read_property(&t4, this_ptr, SL("_options"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(t4, SL("required")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, this_ptr, SL("_options"), PH_NOISY_CC);
			PHALCON_INIT_VAR(required);
			phalcon_array_fetch_string(&required, t5, SL("required"), PH_NOISY_CC);
		}
		
		RETURN_CCTOR(required);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns all the options from the validator
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Validator, getOptions){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_options"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns an option
 *
 * @param string $option
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Validator, getOption){

	zval *option = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, option);
	PHALCON_INIT_VAR(r1);
	ZVAL_BOOL(r1, eval_int);
	if (zend_is_true(r1)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_options"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch(&r2, t1, option, PH_NOISY_CC);
		r0 = r2;
	} else {
		PHALCON_INIT_VAR(t2);
		ZVAL_STRING(t2, "", 1);
		r0 = t2;
	}
	
	RETURN_CCTOR(r0);
}

/**
 * Check whether a option has been defined in the validator options
 *
 * @param string $option
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Validator, isSetOption){

	zval *option = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, option);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Returns the value of the validated field
 *
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Validator, getValue){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_value"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Devuelve el nombre del campo validado
 * 
 * @return string
 */
PHP_METHOD(Phalcon_Model_Validator, getFieldName){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_fieldName"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns Phalcon\Model\Base related record
 *
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Validator, getRecord){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_record"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * This method can be overridden to implement specific option validations for the validator
 *
 */
PHP_METHOD(Phalcon_Model_Validator, checkOptions){


	
}

/* ------ Finished File: \model\validator.c ------ */

/* ------ Starting File: \model\row.c ------ */
/**
 * Phalcon\Model\Row
 *
 * This component allows to Phalcon_Model_Base returns grouped resultsets.
 */

PHP_METHOD(Phalcon_Model_Row, __construct){

	zval *a0 = NULL;

	PHALCON_MM_GROW();

	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_model_row_ce, this_ptr, SL("_columns"), a0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

/**
 * Overwrites default connection
 *
 * @param Phalcon\Db $connection
 */
PHP_METHOD(Phalcon_Model_Row, setConnection){

	zval *connection = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns default connection
 *
 * @return Phalcon\Db
 */
PHP_METHOD(Phalcon_Model_Row, getConnection){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Assigns values to a row from an array returning a new row
 *
 * @param array $result
 * @return Phalcon\Model $result
 */
PHP_METHOD(Phalcon_Model_Row, dumpResult){

	zval *result = NULL, *object_row = NULL, *columns = NULL, *value = NULL, *field = NULL;
	zval *i0 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &result) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(i0);
	if (phalcon_clone(i0, this_ptr TSRMLS_CC) == FAILURE){
		return;
	}
	PHALCON_CPY_WRT(object_row, i0);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_columns"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t1 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(columns);
		array_init(columns);
		if (phalcon_valid_foreach(result TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(result);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_47c8_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_47c8_0;
			} else {
				PHALCON_INIT_VAR(field);
				PHALCON_GET_FOREACH_KEY(field, ah0, hp0);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			PHALCON_INIT_VAR(t2);
			ZVAL_BOOL(t2, 1);
			phalcon_array_update(&columns, field, &t2, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_update_property_zval_zval(object_row, field, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_47c8_0;
			fee_47c8_0:
			if(0){}
		} else {
			return;
		}
		phalcon_update_property_zval(object_row, SL("_columns"), columns TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_columns"), columns TSRMLS_CC);
	} else {
		if (phalcon_valid_foreach(result TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(result);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_47c8_1:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_47c8_1;
			} else {
				PHALCON_INIT_VAR(field);
				PHALCON_GET_FOREACH_KEY(field, ah1, hp1);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			phalcon_update_property_zval_zval(object_row, field, value TSRMLS_CC);
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_47c8_1;
			fee_47c8_1:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_columns"), PH_NOISY_CC);
		phalcon_update_property_zval(object_row, SL("_columns"), t3 TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(object_row);
}

/**
 * Reads an attribute value by its name
 *
 * @param string $property
 * @return mixed
 */
PHP_METHOD(Phalcon_Model_Row, readAttribute){

	zval *property = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property_zval(&t0, this_ptr, property, PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Magic method sleep
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_Row, sleep){

	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	add_next_index_stringl(a0, SL("_columns"), 1);
	
	RETURN_CTOR(a0);
}

/* ------ Finished File: \model\row.c ------ */

/* ------ Starting File: \model\metadata.c ------ */
/**
 * Phalcon\Model\MetaData
 *
 * Because Phalcon\Model requires meta-data like field names, data types, primary keys, etc.
 * this component collect them and store for further querying by Phalcon\Model\Base.
 * Phalcon\Model\MetaData can also use adapters to store temporarily or permanently the meta-data.
 *
 * A standard Phalcon\Model\MetaData can be used to query model attributes:
 *
 * 
 *
 */

/**
 * Phalcon\Model\MetaData constructor
 *
 * @param string $adapter
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_MetaData, __construct){

	zval *adapter = NULL, *options = NULL, *adapter_class = NULL, *adapter_object = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *i0 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &adapter, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(adapter_class);
	PHALCON_CONCAT_SV(adapter_class, "Phalcon\\Model\\MetaData\\", adapter);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", adapter_class);
	if (zend_is_true(r0)) {
		ce0 = phalcon_fetch_class(adapter_class TSRMLS_CC);
		PHALCON_INIT_VAR(adapter_object);
		object_init_ex(adapter_object, ce0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(adapter_object, "__construct", options, PH_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, adapter_object, "read", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_metaData"), r1 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_adapter"), adapter_object TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_model_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SVS(r2, "Meta-data adapter '", adapter, "' could not found");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r2, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Model_MetaData, _initializeMetaData){

	zval *model = NULL, *table = NULL, *schema = NULL, *key = NULL, *connection = NULL, *is_view = NULL;
	zval *exists = NULL, *complete_table = NULL, *meta_datas = NULL, *attributes = NULL;
	zval *primary_keys = NULL, *non_primary_keys = NULL, *numeric_typed = NULL;
	zval *not_null = NULL, *field_types = NULL, *identity_field = NULL;
	zval *meta_data = NULL, *field_name = NULL, *type = NULL, *table_metadata = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL;
	zval *a0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &model, &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, key);
	if (!eval_int) {
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(is_view);
		PHALCON_CALL_METHOD(is_view, model, "isview", PH_NO_CHECK);
		if (!zend_is_true(is_view)) {
			PHALCON_INIT_VAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, connection, "tableexists", table, schema, PH_NO_CHECK);
		} else {
			PHALCON_INIT_VAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, connection, "viewexists", table, schema, PH_NO_CHECK);
		}
		
		if (!zend_is_true(exists)) {
			if (zend_is_true(schema)) {
				PHALCON_INIT_VAR(complete_table);
				PHALCON_CONCAT_VSV(complete_table, schema, "\".\"", table);
			} else {
				PHALCON_CPY_WRT(complete_table, table);
			}
			
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_model_exception_ce);
			
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_get_class(r0, model TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CONCAT_SVSV(r1, "Table \"", complete_table, "\" doesn't exist on database when dumping meta-data for ", r0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
			phalcon_throw_exception(i0 TSRMLS_CC);
			return;
		} else {
			if (zend_is_true(is_view)) {
				PHALCON_INIT_VAR(meta_datas);
				PHALCON_CALL_METHOD_PARAMS_2(meta_datas, connection, "describeview", table, schema, PH_NO_CHECK);
			} else {
				PHALCON_INIT_VAR(meta_datas);
				PHALCON_CALL_METHOD_PARAMS_2(meta_datas, connection, "describetable", table, schema, PH_NO_CHECK);
			}
			
			PHALCON_INIT_VAR(attributes);
			array_init(attributes);
			
			PHALCON_INIT_VAR(primary_keys);
			array_init(primary_keys);
			
			PHALCON_INIT_VAR(non_primary_keys);
			array_init(non_primary_keys);
			
			PHALCON_INIT_VAR(numeric_typed);
			array_init(numeric_typed);
			
			PHALCON_INIT_VAR(not_null);
			array_init(not_null);
			
			PHALCON_INIT_VAR(field_types);
			array_init(field_types);
			
			PHALCON_INIT_VAR(identity_field);
			ZVAL_BOOL(identity_field, 0);
			if (phalcon_valid_foreach(meta_datas TSRMLS_CC)) {
				ah0 = Z_ARRVAL_P(meta_datas);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
				fes_f5c6_0:
				if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
					goto fee_f5c6_0;
				}
				
				PHALCON_INIT_VAR(meta_data);
				ZVAL_ZVAL(meta_data, *hd, 1, 0);
				PHALCON_INIT_VAR(field_name);
				phalcon_array_fetch_string(&field_name, meta_data, SL("Field"), PH_NOISY_CC);
				phalcon_array_append(&attributes, field_name, PH_SEPARATE TSRMLS_CC);
				
				PHALCON_INIT_VAR(r2);
				phalcon_array_fetch_string(&r2, meta_data, SL("Key"), PH_NOISY_CC);
				if (PHALCON_COMPARE_STRING(r2, "PRI")) {
					phalcon_array_append(&primary_keys, field_name, PH_SEPARATE TSRMLS_CC);
				} else {
					phalcon_array_append(&non_primary_keys, field_name, PH_SEPARATE TSRMLS_CC);
				}
				
				PHALCON_INIT_VAR(type);
				phalcon_array_fetch_string(&type, meta_data, SL("Type"), PH_NOISY_CC);
				phalcon_array_update(&field_types, field_name, &type, PH_COPY | PH_SEPARATE TSRMLS_CC);
				
				PHALCON_INIT_VAR(c0);
				ZVAL_STRING(c0, "char", 1);
				
				PHALCON_INIT_VAR(r3);
				phalcon_fast_strpos(r3, type, c0 TSRMLS_CC);
				if (Z_TYPE_P(r3) == IS_BOOL && !Z_BVAL_P(r3)) {
					PHALCON_INIT_VAR(c1);
					ZVAL_STRING(c1, "int", 1);
					PHALCON_INIT_VAR(r4);
					phalcon_fast_strpos(r4, type, c1 TSRMLS_CC);
					if (Z_TYPE_P(r4) != IS_BOOL || (Z_TYPE_P(r4) == IS_BOOL && Z_BVAL_P(r4))) {
						PHALCON_INIT_VAR(t1);
						ZVAL_BOOL(t1, 1);
						phalcon_array_update(&numeric_typed, field_name, &t1, PH_COPY | PH_SEPARATE TSRMLS_CC);
					} else {
						PHALCON_INIT_VAR(c2);
						ZVAL_STRING(c2, "decimal", 1);
						PHALCON_INIT_VAR(r5);
						phalcon_fast_strpos(r5, type, c2 TSRMLS_CC);
						if (Z_TYPE_P(r5) != IS_BOOL || (Z_TYPE_P(r5) == IS_BOOL && Z_BVAL_P(r5))) {
							PHALCON_INIT_VAR(t2);
							ZVAL_BOOL(t2, 1);
							phalcon_array_update(&numeric_typed, field_name, &t2, PH_COPY | PH_SEPARATE TSRMLS_CC);
						} else {
							PHALCON_INIT_VAR(c3);
							ZVAL_STRING(c3, "numeric", 1);
							PHALCON_INIT_VAR(r6);
							phalcon_fast_strpos(r6, type, c3 TSRMLS_CC);
							if (Z_TYPE_P(r6) != IS_BOOL || (Z_TYPE_P(r6) == IS_BOOL && Z_BVAL_P(r6))) {
								PHALCON_INIT_VAR(t3);
								ZVAL_BOOL(t3, 1);
								phalcon_array_update(&numeric_typed, field_name, &t3, PH_COPY | PH_SEPARATE TSRMLS_CC);
							}
						}
					}
				}
				
				PHALCON_INIT_VAR(r7);
				phalcon_array_fetch_string(&r7, meta_data, SL("Null"), PH_NOISY_CC);
				if (PHALCON_COMPARE_STRING(r7, "NO")) {
					phalcon_array_append(&not_null, field_name, PH_SEPARATE TSRMLS_CC);
				}
				
				PHALCON_INIT_VAR(r8);
				phalcon_array_fetch_string(&r8, meta_data, SL("Extra"), PH_NOISY_CC);
				if (PHALCON_COMPARE_STRING(r8, "auto_increment")) {
					PHALCON_CPY_WRT(identity_field, field_name);
				}
				zend_hash_move_forward_ex(ah0, &hp0);
				goto fes_f5c6_0;
				fee_f5c6_0:
				if(0){}
			} else {
				return;
			}
			
			PHALCON_INIT_VAR(table_metadata);
			array_init(table_metadata);
			phalcon_array_update_long(&table_metadata, 0, &attributes, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 1, &primary_keys, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 2, &non_primary_keys, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 3, &not_null, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 4, &field_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 5, &numeric_typed, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 8, &identity_field, PH_COPY | PH_SEPARATE TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(t4);
			phalcon_read_property(&t4, this_ptr, SL("_metaData"), PH_NOISY_CC);
			phalcon_array_update(&t4, key, &table_metadata, PH_COPY TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_metaData"), t4 TSRMLS_CC);
			
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, this_ptr, SL("_changed"), PH_NOISY_CC);
			if (!zend_is_true(t5)) {
				PHALCON_ALLOC_ZVAL_MM(a0);
				array_init(a0);
				phalcon_array_append(&a0, this_ptr, PH_SEPARATE TSRMLS_CC);
				add_next_index_stringl(a0, SL("storeMetaData"), 1);
				PHALCON_CALL_FUNC_PARAMS_1_NORETURN("register_shutdown_function", a0);
				phalcon_update_property_bool(this_ptr, SL("_changed"), 1 TSRMLS_CC);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns table attributes names (fields)
 *
 * @param Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getAttributes){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 0, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns an array of fields which are part of the primary key
 *
 * @param Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getPrimaryKeyAttributes){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 1, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns an arrau of fields which are not part of the primary key
 *
 * @param Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getNonPrimaryKeyAttributes){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 2, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns an array of not null attributes
 *
 * @param Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getNotNullAttributes){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 3, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns attributes and their data types
 *
 * @param Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getDataTypes){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 4, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns attributes which types are numerical
 *
 * @param  Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getDataTypesNumeric){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 5, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Returns the name of identity field (if one is present)
 *
 * @param  Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData, getIdentityField){

	zval *model = NULL, *table = NULL, *schema = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "_initializemetadata", model, table, schema, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, schema, table);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t0, r0, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_long(&r2, r1, 8, PH_NOISY_CC);
	
	RETURN_CCTOR(r2);
}

/**
 * Stores meta-data using to the internal adapter
 */
PHP_METHOD(Phalcon_Model_MetaData, storeMetaData){

	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_changed"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_adapter"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_metaData"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t1, "write", t2, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks if the internal meta-data container is empty
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_MetaData, isEmpty){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t1 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Resets internal meta-data in order to regenerate it
 */
PHP_METHOD(Phalcon_Model_MetaData, reset){

	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), a0 TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_changed"), 1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \model\metadata.c ------ */

/* ------ Starting File: \model\message.c ------ */
/**
 * Phalcon\Model\Message
 *
 * Encapsulates validation info generated before save/delete records fails
 *
 * 
 *
 */

/**
 * Phalcon\Model\Message message
 *
 * @param string $message
 * @param string $field
 * @param string $type
 */
PHP_METHOD(Phalcon_Model_Message, __construct){

	zval *message = NULL, *field = NULL, *type = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &message, &field, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!field) {
		PHALCON_ALLOC_ZVAL_MM(field);
		ZVAL_NULL(field);
	}
	
	if (!type) {
		PHALCON_ALLOC_ZVAL_MM(type);
		ZVAL_NULL(type);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_field"), field TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets message type
 *
 * @param string $type
 */
PHP_METHOD(Phalcon_Model_Message, setType){

	zval *type = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns message type
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Message, getType){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets verbose message
 *
 * @param string $message
 */
PHP_METHOD(Phalcon_Model_Message, setMessage){

	zval *message = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns verbose message
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Message, getMessage){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_message"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sets field name related to message
 *
 * @param string $field
 */
PHP_METHOD(Phalcon_Model_Message, setField){

	zval *field = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &field) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_field"), field TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns field name related to message
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Message, getField){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_field"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Magic __toString method returns verbose message
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Message, __toString){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_message"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Magic __set_state helps to recover messsages from serialization
 *
 * @param array $message
 * @return Phalcon\Model\Message
 */
PHP_METHOD(Phalcon_Model_Message, __set_state){

	zval *message = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(i0);
	object_init_ex(i0, phalcon_model_message_ce);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, message, SL("_message"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, message, SL("_field"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_array_fetch_string(&r2, message, SL("_type"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", r0, r1, r2, PH_CHECK);
	
	RETURN_CTOR(i0);
}

/* ------ Finished File: \model\message.c ------ */

/* ------ Starting File: \model\manager.c ------ */
/**
 * Phalcon\Model\Manager
 *
 * Manages the creation of models into applications and their relationships.
 * Phacon\Model\Manager helps to control the creation of models across a request execution.
 *
 * 
 */

/**
 * Constructor for Phalcon\Model\Manager
 *
 * @param Phalcon\Config|stdClass $options
 */
PHP_METHOD(Phalcon_Model_Manager, __construct){

	zval *options = NULL, *model_options = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL, *a3 = NULL, *a4 = NULL, *a5 = NULL, *a6 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_models"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_hasMany"), a1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a2);
	array_init(a2);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_hasOne"), a2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a3);
	array_init(a3);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_belongsTo"), a3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a4);
	array_init(a4);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_sourceNames"), a4 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a5);
	array_init(a5);
	zend_update_property(phalcon_model_manager_ce, this_ptr, SL("_initialized"), a5 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(options);
		ZVAL_NULL(options);
	}
	
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\model\\manager"), SL("_default") TSRMLS_CC);
	if (!zend_is_true(t0)) {
		phalcon_update_static_property(SL("phalcon\\model\\manager"), SL("_default"), this_ptr TSRMLS_CC);
	}
	if (zend_is_true(options)) {
		if (Z_TYPE_P(options) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Options parameter must be an object");
			return;
		}
		PHALCON_CPY_WRT(model_options, options);
	} else {
		PHALCON_INIT_VAR(model_options);
		object_init(model_options);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_options"), model_options TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a6);
	array_init(a6);
	phalcon_array_append(&a6, this_ptr, PH_SEPARATE TSRMLS_CC);
	add_next_index_stringl(a6, SL("autoload"), 1);
	PHALCON_CALL_FUNC_PARAMS_1_NORETURN("spl_autoload_register", a6);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets base path. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $basePath
 */
PHP_METHOD(Phalcon_Model_Manager, setBasePath){

	zval *base_path = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Overwrites default meta-data manager
 *
 * @param object $metadata
 */
PHP_METHOD(Phalcon_Model_Manager, setMetaData){

	zval *metadata = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &metadata) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(metadata) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Meta-data must be an object instance similar to Phalcon_Model_Metadata");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_metadata"), metadata TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns active meta-data manager. If not exist then one will be created
 *
 * @return Phalcon\Model\Metadata
 */
PHP_METHOD(Phalcon_Model_Manager, getMetaData){

	zval *metadata = NULL, *adapter = NULL, *options = NULL, *options_metadata = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(metadata);
	phalcon_read_property(&metadata, this_ptr, SL("_metadata"), PH_NOISY_CC);
	if (!zend_is_true(metadata)) {
		PHALCON_INIT_VAR(adapter);
		ZVAL_NULL(adapter);
		
		PHALCON_INIT_VAR(options);
		phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
		eval_int = phalcon_isset_property(options, SL("metadata") TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_VAR(options_metadata);
			phalcon_read_property(&options_metadata, options, SL("metadata"), PH_NOISY_CC);
			eval_int = phalcon_isset_property(options_metadata, SL("adapter") TSRMLS_CC);
			if (eval_int) {
				PHALCON_INIT_VAR(adapter);
				phalcon_read_property(&adapter, options_metadata, SL("adapter"), PH_NOISY_CC);
			}
		}
		
		if (!zend_is_true(adapter)) {
			PHALCON_INIT_VAR(adapter);
			ZVAL_STRING(adapter, "Memory", 1);
			
			PHALCON_INIT_VAR(options_metadata);
			array_init(options_metadata);
		}
		
		PHALCON_INIT_VAR(metadata);
		object_init_ex(metadata, phalcon_model_metadata_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(metadata, "__construct", adapter, options_metadata, PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_metadata"), metadata TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(metadata);
}

/**
 * Set the cache object or cache parameters to make the view caching
 *
 * @param Phalcon\Cache\Backend|object $cache
 */
PHP_METHOD(Phalcon_Model_Manager, setCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(cache) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cache must be an object instance");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns default cache backend. This cache will be used to store resultsets and generated SQL
 *
 * @return Phalcon\Cache\Backend
 */
PHP_METHOD(Phalcon_Model_Manager, getCache){

	zval *cache = NULL, *options = NULL, *options_cache = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(cache);
	phalcon_read_property(&cache, this_ptr, SL("_cache"), PH_NOISY_CC);
	if (!zend_is_true(cache)) {
		PHALCON_INIT_VAR(options);
		phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
		eval_int = phalcon_isset_property(options, SL("cache") TSRMLS_CC);
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cache options aren't set");
			return;
		}
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, options, SL("cache"), PH_NOISY_CC);
		phalcon_cast(r0, t0, IS_ARRAY);
		PHALCON_CPY_WRT(options_cache, r0);
		eval_int = phalcon_array_isset_string(options_cache, SL("adapter")+1);
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Backend cache adapter aren't defined in options");
			return;
		}
		
		PHALCON_INIT_VAR(p0[0]);
		ZVAL_STRING(p0[0], "Data", 1);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, options_cache, SL("adapter"), PH_NOISY_CC);
		p0[1] = r1;
		p0[2] = options_cache;
		p0[3] = options_cache;
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_STATIC_PARAMS(r2, "phalcon\\cache", "factory", 4, p0);
		PHALCON_CPY_WRT(cache, r2);
		phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(cache);
}

/**
 * Sets the models directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $modelsDir
 */
PHP_METHOD(Phalcon_Model_Manager, setModelsDir){

	zval *models_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &models_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_modelsDir"), models_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets active models directory
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Manager, getModelsDir){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_modelsDir"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Checks whether the given name is an existing model
 *
 * @param string $modelName
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, isModel){

	zval *model_name = NULL, *model_path = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_models"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(c0);
		ZVAL_BOOL(c0, 0);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_2(r0, "class_exists", model_name, c0);
		if (!zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(t1);
			phalcon_read_property(&t1, this_ptr, SL("_basePath"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(t2);
			phalcon_read_property(&t2, this_ptr, SL("_modelsDir"), PH_NOISY_CC);
			PHALCON_INIT_VAR(model_path);
			PHALCON_CONCAT_VVVS(model_path, t1, t2, model_name, ".php");
			if (phalcon_file_exists(model_path TSRMLS_CC) == SUCCESS) {
				PHALCON_ALLOC_ZVAL_MM(r1);
				PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "load", model_name, PH_NO_CHECK);
				RETURN_CTOR(r1);
			} else {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Loads a model looking for its file and initializing them
 *
 * @param string $modelName
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, load){

	zval *model_name = NULL, *auto_connection = NULL, *model_path = NULL;
	zval *model = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	zval *i0 = NULL, *i1 = NULL;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_models"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(auto_connection);
		phalcon_read_property(&auto_connection, this_ptr, SL("_autoConnection"), PH_NOISY_CC);
		
		PHALCON_INIT_VAR(c0);
		ZVAL_BOOL(c0, 0);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_2(r0, "class_exists", model_name, c0);
		if (!zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(t1);
			phalcon_read_property(&t1, this_ptr, SL("_basePath"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(t2);
			phalcon_read_property(&t2, this_ptr, SL("_modelsDir"), PH_NOISY_CC);
			PHALCON_INIT_VAR(model_path);
			PHALCON_CONCAT_VVVS(model_path, t1, t2, model_name, ".php");
			if (phalcon_file_exists(model_path TSRMLS_CC) == SUCCESS) {
				if (phalcon_require(model_path TSRMLS_CC) == FAILURE) {
					return;
				}
				
				PHALCON_INIT_VAR(c1);
				ZVAL_BOOL(c1, 0);
				
				PHALCON_ALLOC_ZVAL_MM(r1);
				PHALCON_CALL_FUNC_PARAMS_2(r1, "class_exists", model_name, c1);
				if (!zend_is_true(r1)) {
					PHALCON_ALLOC_ZVAL_MM(i0);
					object_init_ex(i0, phalcon_model_exception_ce);
					PHALCON_ALLOC_ZVAL_MM(r2);
					PHALCON_CONCAT_SVS(r2, "Class \"", model_name, "\"  not be found in the model file");
					PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r2, PH_CHECK);
					phalcon_throw_exception(i0 TSRMLS_CC);
					return;
				}
				
				ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
				
				PHALCON_INIT_VAR(model);
				object_init_ex(model, ce0);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "__construct", this_ptr, PH_CHECK);
				if (zend_is_true(auto_connection)) {
					PHALCON_ALLOC_ZVAL_MM(r3);
					PHALCON_CALL_METHOD(r3, this_ptr, "getconnection", PH_NO_CHECK);
					PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setconnection", r3, PH_NO_CHECK);
				}
				
				PHALCON_ALLOC_ZVAL_MM(t3);
				phalcon_read_property(&t3, this_ptr, SL("_models"), PH_NOISY_CC);
				phalcon_array_update(&t3, model_name, &model, PH_COPY TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_models"), t3 TSRMLS_CC);
			} else {
				PHALCON_ALLOC_ZVAL_MM(i1);
				object_init_ex(i1, phalcon_model_exception_ce);
				PHALCON_ALLOC_ZVAL_MM(r4);
				PHALCON_CONCAT_SVS(r4, "Class file path for model \"", model_name, "\" could not be found");
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", r4, PH_CHECK);
				phalcon_throw_exception(i1 TSRMLS_CC);
				return;
			}
		} else {
			ce1 = phalcon_fetch_class(model_name TSRMLS_CC);
			PHALCON_INIT_VAR(model);
			object_init_ex(model, ce1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "__construct", this_ptr, PH_CHECK);
			if (zend_is_true(auto_connection)) {
				PHALCON_ALLOC_ZVAL_MM(r5);
				PHALCON_CALL_METHOD(r5, this_ptr, "getconnection", PH_NO_CHECK);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setconnection", r5, PH_NO_CHECK);
			}
			
			PHALCON_ALLOC_ZVAL_MM(t4);
			phalcon_read_property(&t4, this_ptr, SL("_models"), PH_NOISY_CC);
			phalcon_array_update(&t4, model_name, &model, PH_COPY TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_models"), t4 TSRMLS_CC);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Gets/Instantiates model from directory
 *
 * @param string $modelName
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, getModel){

	zval *model_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_models"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (!eval_int) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "load", model_name, PH_NO_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_models"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
	
	RETURN_CCTOR(r0);
}

/**
 * Initializes a model in the model manager
 *
 * @param Phalcon\Model\Base $model
 */
PHP_METHOD(Phalcon_Model_Manager, initialize){

	zval *model = NULL, *class_name = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, class_name);
	if (!eval_int) {
		if (phalcon_method_exists_ex(model, SL("initialize") TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD_NORETURN(model, "initialize", PH_NO_CHECK);
		}
		
		PHALCON_INIT_VAR(t1);
		ZVAL_BOOL(t1, 1);
		
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_initialized"), PH_NOISY_CC);
		phalcon_array_update(&t2, class_name, &t1, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_initialized"), t2 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the possible source model name from its class name
 *
 * @param string $modelName
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, getSource){

	zval *model_name = NULL, *source_names = NULL, *source_name = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(source_names);
	phalcon_read_property(&source_names, this_ptr, SL("_sourceNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(source_names, model_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(source_name);
		PHALCON_CALL_STATIC_PARAMS_1(source_name, "phalcon\\text", "uncamelize", model_name);
		
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_sourceNames"), PH_NOISY_CC);
		phalcon_array_update(&t0, model_name, &source_name, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_sourceNames"), t0 TSRMLS_CC);
		
		RETURN_CCTOR(source_name);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch(&r0, source_names, model_name, PH_NOISY_CC);
	
	RETURN_CCTOR(r0);
}

/**
 * Sets the main connection that automatically is binded to all created models
 *
 * @param Phalcon\Db $connection
 */
PHP_METHOD(Phalcon_Model_Manager, setConnection){

	zval *connection = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "$connection must be an Object");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets default connection to the database. All models by default will use connection returned by this method
 *
 * @return Phalcon\Db
 */
PHP_METHOD(Phalcon_Model_Manager, getConnection){

	zval *connection = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	if (!zend_is_true(connection)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_STATIC(r0, "phalcon\\transaction\\manager", "isautomatic");
		if (zend_is_true(r0)) {
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_STATIC(r1, "phalcon\\transaction\\manager", "get");
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD(r2, r1, "getconnection", PH_NO_CHECK);
			RETURN_CTOR(r2);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_STATIC(r3, "phalcon\\db\\pool", "hasdefaultdescriptor");
			if (!zend_is_true(r3)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "There is not defined database connection parameters");
				return;
			}
			
			PHALCON_INIT_VAR(connection);
			PHALCON_CALL_STATIC(connection, "phalcon\\db\\pool", "getconnection");
			phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
		}
	}
	
	
	RETURN_CCTOR(connection);
}

/**
 * Sets if the models manager should create a default connection automatically and bind it to the created models
 *
 * @param boolean $autoConnection
 */
PHP_METHOD(Phalcon_Model_Manager, setAutoConnection){

	zval *auto_connection = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &auto_connection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_autoConnection"), auto_connection TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether the manager binds a database connection automatically to the created models
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, haveAutoConnection){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_autoConnection"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Setup a 1-1 relation between two models
 *
 * @param Phalcon_Model_Base $model
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_Manager, addHasOne){

	zval *model = NULL, *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *entity_name = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, entity_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		phalcon_array_update(&t1, entity_name, &a1, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasOne"), t1 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch(&r0, t2, entity_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_fast_count(r1, fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_fast_count(r2, referenced_fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r3);
			is_not_equal_function(r3, r1, r2 TSRMLS_CC);
			if (zend_is_true(r3)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
		
		PHALCON_ALLOC_ZVAL_MM(a2);
		array_init(a2);
		phalcon_array_update_string(&a2, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t3, entity_name, reference_model, &a2, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasOne"), t3 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Setup a relation reverse 1-1  between two models
 *
 * @param Phalcon_Model_Base $model
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_Manager, addBelongsTo){

	zval *model = NULL, *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *model_name = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		phalcon_array_update(&t1, model_name, &a1, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_belongsTo"), t1 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch(&r0, t2, model_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_fast_count(r1, fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_fast_count(r2, referenced_fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r3);
			is_not_equal_function(r3, r1, r2 TSRMLS_CC);
			if (zend_is_true(r3)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
		
		PHALCON_ALLOC_ZVAL_MM(a2);
		array_init(a2);
		phalcon_array_update_string(&a2, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t3, model_name, reference_model, &a2, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_belongsTo"), t3 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Setup a relation 1-n between two models
 *
 * @param Phalcon_Model_Base $model
 * @param mixed $fields
 * @param string $referenceModel
 * @param mixed $referencedFields
 * @param array $options
 */
PHP_METHOD(Phalcon_Model_Manager, addHasMany){

	zval *model = NULL, *fields = NULL, *reference_model = NULL, *referenced_fields = NULL;
	zval *options = NULL, *entity_name = NULL;
	zval *a0 = NULL, *a1 = NULL, *a2 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, entity_name);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		phalcon_array_update(&t1, entity_name, &a1, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasMany"), t1 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch(&r0, t2, entity_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_fast_count(r1, fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_fast_count(r2, referenced_fields TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r3);
			is_not_equal_function(r3, r1, r2 TSRMLS_CC);
			if (zend_is_true(r3)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
		
		PHALCON_ALLOC_ZVAL_MM(a2);
		array_init(a2);
		phalcon_array_update_string(&a2, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a2, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t3, entity_name, reference_model, &a2, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasMany"), t3 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Checks whether a model has a belongsTo relation with another model
 * 
 * @param string $modelName
 * @param string $modelRelation
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, existsBelongsTo){

	zval *model_name = NULL, *model_relation = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Checks whether a model has a hasMany relation with another model
 *
 * @param string $modelName
 * @param string $modelRelation
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, existsHasMany){

	zval *model_name = NULL, *model_relation = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Checks whether a model has a hasOne relation with another model
 *
 * @param string $modelName
 * @param string $modelRelation
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Manager, existsHasOne){

	zval *model_name = NULL, *model_relation = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Helper method to query records based on a relation definition
 *
 * @param array $relation
 * @param string $method
 * @param Phalcon\Model\Base $record
 */
PHP_METHOD(Phalcon_Model_Manager, _getRelationRecords){

	zval *relation = NULL, *method = NULL, *record = NULL, *conditions = NULL, *value = NULL;
	zval *i = NULL, *referenced_field = NULL, *number_args = NULL, *key = NULL;
	zval *find_params = NULL, *reference_table = NULL, *referenced_entity = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL, *r15 = NULL, *r16 = NULL, *r17 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *c0 = NULL;
	zval *a0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &relation, &method, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_array_fetch_string(&r0, relation, SL("fi"), PH_NOISY_CC);
	if (Z_TYPE_P(r0) != IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, relation, SL("fi"), PH_NOISY_CC);
		PHALCON_INIT_VAR(value);
		PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", r1, PH_NO_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		phalcon_array_fetch_string(&r2, relation, SL("rf"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CONCAT_VSVS(r3, r2, " = '", value, "'");
		phalcon_array_update_long(&conditions, 0, &r3, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 0);
		
		PHALCON_ALLOC_ZVAL_MM(r4);
		phalcon_array_fetch_string(&r4, relation, SL("fi"), PH_NOISY_CC);
		if (phalcon_valid_foreach(r4 TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(r4);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_7231_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_7231_0;
			}
			
			PHALCON_INIT_VAR(referenced_field);
			ZVAL_ZVAL(referenced_field, *hd, 1, 0);
			PHALCON_INIT_VAR(r5);
			phalcon_array_fetch_string(&r5, relation, SL("fi"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r6);
			phalcon_array_fetch(&r6, r5, i, PH_NOISY_CC);
			PHALCON_INIT_VAR(value);
			PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", r6, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(r7);
			phalcon_array_fetch_string(&r7, relation, SL("rf"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r8);
			phalcon_array_fetch(&r8, r7, i, PH_NOISY_CC);
			
			PHALCON_INIT_VAR(r9);
			PHALCON_CONCAT_VSVS(r9, r8, " = '", value, "'");
			phalcon_array_append(&conditions, r9, PH_SEPARATE TSRMLS_CC);
			PHALCON_SEPARATE(i);
			increment_function(i);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_7231_0;
			fee_7231_0:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_INIT_VAR(number_args);
	PHALCON_CALL_FUNC(number_args, "func_num_args");
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 4);
	
	PHALCON_ALLOC_ZVAL_MM(r10);
	is_smaller_function(r10, t0, number_args TSRMLS_CC);
	if (zend_is_true(r10)) {
		PHALCON_ALLOC_ZVAL_MM(r11);
		PHALCON_CALL_FUNC(r11, "func_get_args");
		if (phalcon_valid_foreach(r11 TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(r11);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_7231_1:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_7231_1;
			} else {
				PHALCON_INIT_VAR(key);
				PHALCON_GET_FOREACH_KEY(key, ah1, hp1);
			}
			PHALCON_INIT_VAR(value);
			ZVAL_ZVAL(value, *hd, 1, 0);
			PHALCON_INIT_VAR(t1);
			ZVAL_LONG(t1, 0);
			PHALCON_INIT_VAR(r12);
			is_equal_function(r12, key, t1 TSRMLS_CC);
			PHALCON_INIT_VAR(t2);
			ZVAL_STRING(t2, "conditions", 1);
			PHALCON_INIT_VAR(r13);
			is_equal_function(r13, key, t2 TSRMLS_CC);
			PHALCON_INIT_VAR(r14);
			ZVAL_BOOL(r14, zend_is_true(r12) || zend_is_true(r13));
			if (zend_is_true(r14)) {
				phalcon_array_append(&conditions, value, PH_SEPARATE TSRMLS_CC);
			}
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_7231_1;
			fee_7231_1:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_INIT_VAR(find_params);
	array_init(find_params);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, " AND ", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r15);
	phalcon_fast_join(r15, c0, conditions TSRMLS_CC);
	phalcon_array_append(&find_params, r15, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(reference_table);
	phalcon_array_fetch_string(&reference_table, relation, SL("rt"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(referenced_entity);
	PHALCON_CALL_METHOD_PARAMS_1(referenced_entity, this_ptr, "getmodel", reference_table, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r16);
	PHALCON_CALL_METHOD(r16, record, "getconnection", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_entity, "setconnection", r16, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_array_append(&a0, referenced_entity, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a0, method, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r17);
	PHALCON_CALL_FUNC_PARAMS_2(r17, "call_user_func_array", a0, find_params);
	RETURN_CTOR(r17);
}

/**
 * Gets belongsTo related records from a model
 *
 * @param string $method
 * @param string $modelName
 * @param string $modelRelation
 * @param Phalcon\Model\Base $record
 * @return Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Manager, getBelongsToRecords){

	zval *method = NULL, *model_name = NULL, *model_relation = NULL, *record = NULL;
	zval *relation = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &method, &model_name, &model_relation, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t2, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD_PARAMS_3(r2, this_ptr, "_getrelationrecords", relation, method, record, PH_NO_CHECK);
	RETURN_CTOR(r2);
}

/**
 * Gets hasMany related records from a model
 *
 * @param string $method
 * @param string $modelName
 * @param string $modelRelation
 * @param Phalcon\Model\Base $record
 * @return Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Manager, getHasManyRecords){

	zval *method = NULL, *model_name = NULL, *model_relation = NULL, *record = NULL;
	zval *relation = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &method, &model_name, &model_relation, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t2, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD_PARAMS_3(r2, this_ptr, "_getrelationrecords", relation, method, record, PH_NO_CHECK);
	RETURN_CTOR(r2);
}

/**
 * Gets belongsTo related records from a model
 *
 * @param string $method
 * @param string $modelName
 * @param string $modelRelation
 * @param Phalcon\Model\Base $record
 * @return Phalcon\Model\Resultset
 */
PHP_METHOD(Phalcon_Model_Manager, getHasOneRecords){

	zval *method = NULL, *model_name = NULL, *model_relation = NULL, *record = NULL;
	zval *relation = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &method, &model_name, &model_relation, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch(&r1, t2, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD_PARAMS_3(r2, this_ptr, "_getrelationrecords", relation, method, record, PH_NO_CHECK);
	RETURN_CTOR(r2);
}

/**
 * Gets belongsTo relations defined on a model
 *
 * @param  Phalcon\Model\Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_Manager, getBelongsTo){

	zval *model = NULL, *model_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Gets hasMany relations defined on a model
 *
 * @param  Phalcon\Model\Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_Manager, getHasMany){

	zval *model = NULL, *model_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Gets hasOne relations defined on a model
 *
 * @param  Phalcon\Model\Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_Manager, getHasOne){

	zval *model = NULL, *model_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, model_name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, t1, model_name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Gets hasOne relations defined on a model
 *
 * @param  Phalcon_Model_Base $model
 * @return array
 */
PHP_METHOD(Phalcon_Model_Manager, getHasOneAndHasMany){

	zval *model = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "gethasone", model, PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_1(r1, this_ptr, "gethasmany", model, PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_2(r2, "array_merge", r0, r1);
	RETURN_CTOR(r2);
}

/**
 * Returns the complete on which manager is looking for models
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Manager, getCompleteModelsPath){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_basePath"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_modelsDir"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, t0, t1);
	
	RETURN_CTOR(r0);
}

/**
 * Autoload function for model lazy loading
 *
 * @param string $className
 */
PHP_METHOD(Phalcon_Model_Manager, autoload){

	zval *class_name = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &class_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "ismodel", class_name, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Get the default Phalcon\Model\Manager (usually this first instantiated)
 *
 * @return Phalcon\Model\Manager
 */
PHP_METHOD(Phalcon_Model_Manager, getDefault){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\model\\manager"), SL("_default") TSRMLS_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Resets internal default manager
 */
PHP_METHOD(Phalcon_Model_Manager, reset){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	phalcon_update_static_property(SL("phalcon\\model\\manager"), SL("_default"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \model\manager.c ------ */

/* ------ Starting File: \model\metadata\memory.c ------ */
/**
 * Phalcon\Model\MetaData\Memory
 *
 * Stores model meta-data in memory. Data will be erased when the request finishes
 *
 * 
 *
 */

/**
 * Reads the meta-data from temporal memory
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData_Memory, read){

	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Writes the meta-data to temporal memory
 *
 * @param array $data
 */
PHP_METHOD(Phalcon_Model_MetaData_Memory, write){


	
}

/* ------ Finished File: \model\metadata\memory.c ------ */

/* ------ Starting File: \model\metadata\apc.c ------ */
/**
 * Phalcon\Model\MetaData\Apc
 *
 * Stores model meta-data in the APC cache. Data will erased if the web server is restarted
 *
 * By default meta-data is stored 48 hours (172800 seconds)
 *
 * You can query the meta-data by printing apc_fetch('$PMM$') or apc_fetch('$PMM$my-local-app')
 *
 *
 */

/**
 * Phalcon_Model_MetaData_Apc constructor
 *
 * @param Phalcon_Config|stdClass $options
 */
PHP_METHOD(Phalcon_Model_MetaData_Apc, __construct){

	zval *options = NULL, *adapter_options = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(options);
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_cast(r0, options, IS_ARRAY);
		PHALCON_CPY_WRT(adapter_options, r0);
	} else {
		PHALCON_CPY_WRT(adapter_options, options);
	}
	eval_int = phalcon_isset_property(adapter_options, SL("suffix") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, adapter_options, SL("suffix"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_suffix"), t0 TSRMLS_CC);
	}
	
	eval_int = phalcon_isset_property(adapter_options, SL("lifetime") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, adapter_options, SL("lifetime"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_ttl"), t1 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Reads meta-data from APC
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData_Apc, read){

	zval *key = NULL, *data = NULL;
	zval *t0 = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_suffix"), PH_NOISY_CC);
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_SV(key, "$PMM$", t0);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_FUNC_PARAMS_1(data, "apc_fetch", key);
	if (Z_TYPE_P(data) == IS_ARRAY) { 
		
		RETURN_CCTOR(data);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Writes the meta-data to APC
 *
 * @param array $data
 */
PHP_METHOD(Phalcon_Model_MetaData_Apc, write){

	zval *data = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_suffix"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SV(r0, "$PMM$", t0);
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_ttl"), PH_NOISY_CC);
	PHALCON_CALL_FUNC_PARAMS_3_NORETURN("apc_store", r0, data, t1);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \model\metadata\apc.c ------ */

/* ------ Starting File: \model\metadata\session.c ------ */
/**
 * Phalcon\Model\MetaData\Session
 *
 * Stores model meta-data in session. Data will erase when the session finishes.
 * Meta-data are permanent while the session is active.
 *
 * You can query the meta-data by printing $_SESSION['$PMM$']
 *
 *
 */

/**
 * Phalcon_Model_MetaData_Session constructor
 *
 * @param Phalcon_Config|stdClass $options
 */
PHP_METHOD(Phalcon_Model_MetaData_Session, __construct){

	zval *options = NULL, *adapter_options = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(options);
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_cast(r0, options, IS_ARRAY);
		PHALCON_CPY_WRT(adapter_options, r0);
	} else {
		PHALCON_CPY_WRT(adapter_options, options);
	}
	eval_int = phalcon_isset_property(adapter_options, SL("suffix") TSRMLS_CC);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, adapter_options, SL("suffix"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_suffix"), t0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Reads meta-data from $_SESSION
 *
 * @return array
 */
PHP_METHOD(Phalcon_Model_MetaData_Session, read){

	zval *session = NULL, *key = NULL;
	zval *g0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(session, g0);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_suffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_SV(key, "$PMM$", t0);
	eval_int = phalcon_array_isset(session, key);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, session, key, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Writes the meta-data to $_SESSION
 *
 * @param array $data
 */
PHP_METHOD(Phalcon_Model_MetaData_Session, write){

	zval *data = NULL;
	zval *g0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_suffix"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SV(r0, "$PMM$", t0);
	phalcon_array_update(&g0, r0, &data, PH_COPY TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \model\metadata\session.c ------ */

/* ------ Starting File: \model\resultset.c ------ */
/**
 * Phalcon\Model\Resultset
 *
 * This component allows to Phalcon_Model_Base returns large resulsets with the minimum memory consumption
 * Resulsets can be traversed using a standard foreach or a while statement. If a resultset is serialized
 * it will dump all the rows into a big array. Then unserialize will retrieve the rows as they were before
 * serializing.
 *
 * 
 *
 */

/**
 * Phalcon\Model\Resultset constructor
 *
 * @param Phalcon\Model\Base $model
 * @param Phalcon\Model\Result $result
 * @param Phalcon\Model\Cache $cache
 */
PHP_METHOD(Phalcon_Model_Resultset, __construct){

	zval *model = NULL, *result = NULL, *cache = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &model, &result, &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!cache) {
		PHALCON_ALLOC_ZVAL_MM(cache);
		ZVAL_NULL(cache);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_result"), result TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	phalcon_update_property_long(this_ptr, SL("_type"), 1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether internal resource has rows to fetch
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Resultset, valid){

	zval *result = NULL, *row = NULL, *rows = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (Z_TYPE_P(result) != IS_BOOL || (Z_TYPE_P(result) == IS_BOOL && Z_BVAL_P(result))) {
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", c0, PH_NO_CHECK);
			
			PHALCON_INIT_VAR(row);
			PHALCON_CALL_METHOD_PARAMS_1(row, result, "fetcharray", result, PH_NO_CHECK);
			if (zend_is_true(row)) {
				PHALCON_ALLOC_ZVAL_MM(t1);
				phalcon_read_property(&t1, this_ptr, SL("_model"), PH_NOISY_CC);
				PHALCON_ALLOC_ZVAL_MM(r0);
				PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\model\\base", "dumpresult", t1, row);
				phalcon_update_property_zval(this_ptr, SL("_activeRow"), r0 TSRMLS_CC);
				PHALCON_MM_RESTORE();
				RETURN_TRUE;
			} else {
				PHALCON_INIT_VAR(c1);
				ZVAL_LONG(c1, 2);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", c1, PH_NO_CHECK);
			}
		}
	} else {
		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
		Z_SET_ISREF_P(rows);
		
		PHALCON_INIT_VAR(row);
		PHALCON_CALL_FUNC_PARAMS_1(row, "current", rows);
		Z_UNSET_ISREF_P(rows);
		if (zend_is_true(row)) {
			Z_SET_ISREF_P(rows);
			PHALCON_CALL_FUNC_PARAMS_1_NORETURN("next", rows);
			Z_UNSET_ISREF_P(rows);
			phalcon_update_property_zval(this_ptr, SL("_activeRow"), row TSRMLS_CC);
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Returns current row in the resultset
 *
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Resultset, current){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_activeRow"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Moves cursor to next row in the resultset
 *
 */
PHP_METHOD(Phalcon_Model_Resultset, next){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_pointer"), PH_NOISY_CC);
	PHALCON_SEPARATE_NMO(t0);
	increment_function(t0);
	phalcon_update_property_zval(this_ptr, SL("_pointer"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets pointer number of active row in the resultset
 *
 */
PHP_METHOD(Phalcon_Model_Resultset, key){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_pointer"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Rewinds resultset to its beginning
 *
 */
PHP_METHOD(Phalcon_Model_Resultset, rewind){

	zval *result = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (Z_TYPE_P(result) != IS_BOOL || (Z_TYPE_P(result) == IS_BOOL && Z_BVAL_P(result))) {
			phalcon_update_property_long(this_ptr, SL("pointer"), 1 TSRMLS_CC);
			
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "dataseek", c0, PH_NO_CHECK);
		}
	} else {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_rows"), PH_NOISY_CC);
		Z_SET_ISREF_P(t1);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("reset", t1);
		Z_UNSET_ISREF_P(t1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Changes internal pointer to a specific position in the resultset
 *
 * @param int $position
 */
PHP_METHOD(Phalcon_Model_Resultset, seek){

	zval *position = NULL, *rows = NULL, *i = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &position) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "intval", position);
	phalcon_update_property_zval(this_ptr, SL("_pointer"), r0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_result"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(t1, "dataseek", position, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
		Z_SET_ISREF_P(rows);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("reset", rows);
		Z_UNSET_ISREF_P(rows);
		
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 0);
		fs_fd08_0:
			
			PHALCON_INIT_VAR(r1);
			is_smaller_function(r1, i, position TSRMLS_CC);
			if (!zend_is_true(r1)) {
				goto fe_fd08_0;
			}
			Z_SET_ISREF_P(rows);
			PHALCON_CALL_FUNC_PARAMS_1_NORETURN("next", rows);
			Z_UNSET_ISREF_P(rows);
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto fs_fd08_0;
		fe_fd08_0:
		if(0){}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Counts how many rows are in the resultset
 *
 * @return int
 */
PHP_METHOD(Phalcon_Model_Resultset, count){

	zval *count = NULL, *result = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_count"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_null", t0);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(count);
		ZVAL_LONG(count, 0);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_type"), PH_NOISY_CC);
		if (zend_is_true(t1)) {
			PHALCON_INIT_VAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
			if (Z_TYPE_P(result) != IS_BOOL || (Z_TYPE_P(result) == IS_BOOL && Z_BVAL_P(result))) {
				PHALCON_ALLOC_ZVAL_MM(r1);
				PHALCON_CALL_METHOD(r1, result, "numrows", PH_NO_CHECK);
				PHALCON_INIT_VAR(count);
				PHALCON_CALL_FUNC_PARAMS_1(count, "intval", r1);
			}
		} else {
			PHALCON_ALLOC_ZVAL_MM(t2);
			phalcon_read_property(&t2, this_ptr, SL("_rows"), PH_NOISY_CC);
			PHALCON_INIT_VAR(count);
			phalcon_fast_count(count, t2 TSRMLS_CC);
		}
		
		phalcon_update_property_zval(this_ptr, SL("_count"), count TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("_count"), PH_NOISY_CC);
	
	RETURN_CCTOR(t3);
}

/**
 * Checks whether offset exists in the resultset
 *
 * @param int $index
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Resultset, offsetExists){

	zval *index = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "count", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, index, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Gets row in a specific position of the resultset
 *
 * @param int $index
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Resultset, offsetGet){

	zval *index = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "count", PH_NO_CHECK);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, index, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "seek", index, PH_NO_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_METHOD(r2, this_ptr, "valid", PH_NO_CHECK);
		if (Z_TYPE_P(r2) != IS_BOOL || (Z_TYPE_P(r2) == IS_BOOL && Z_BVAL_P(r2))) {
			PHALCON_ALLOC_ZVAL_MM(r3);
			PHALCON_CALL_METHOD(r3, this_ptr, "current", PH_NO_CHECK);
			RETURN_CTOR(r3);
		} else {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "The index does not exist in the cursor");
	return;
}

/**
 * Resulsets cannot be changed. It has only been implemented to meet the definition of the ArrayAccess interface
 *
 * @param int $index
 * @param Phalcon\Model\Base $value
 */
PHP_METHOD(Phalcon_Model_Resultset, offsetSet){

	zval *index = NULL, *value = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

/**
 * Resulsets cannot be changed. It has only been implemented to meet the definition of the ArrayAccess interface
 *
 * @param int $offset
 */
PHP_METHOD(Phalcon_Model_Resultset, offsetUnset){

	zval *offset = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

/**
 * Get first row in the resultset
 *
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Resultset, getFirst){

	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "rewind", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "valid", PH_NO_CHECK);
	if (Z_TYPE_P(r0) != IS_BOOL || (Z_TYPE_P(r0) == IS_BOOL && Z_BVAL_P(r0))) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "current", PH_NO_CHECK);
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Get last row in the resultset
 *
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Resultset, getLast){

	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "count", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	sub_function(r1, r0, t0 TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "seek", r1, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD(r2, this_ptr, "valid", PH_NO_CHECK);
	if (Z_TYPE_P(r2) != IS_BOOL || (Z_TYPE_P(r2) == IS_BOOL && Z_BVAL_P(r2))) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CALL_METHOD(r3, this_ptr, "current", PH_NO_CHECK);
		RETURN_CTOR(r3);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Tell if the resultset if fresh or an old cached
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Model_Resultset, isFresh){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, t0, t1 TSRMLS_CC);
	
	RETURN_NCTOR(r0);
}

/**
 * Serializing a resultset will dump all related rows into a big array
 *
 * @return string
 */
PHP_METHOD(Phalcon_Model_Resultset, serialize){

	zval *records = NULL, *data = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(records);
	array_init(records);
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "rewind", PH_NO_CHECK);
	ws_fd08_1:
		
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, this_ptr, "valid", PH_NO_CHECK);
		if (Z_TYPE_P(r0) != IS_BOOL || (Z_TYPE_P(r0) == IS_BOOL && !Z_BVAL_P(r0))) {
			goto we_fd08_1;
		}
		PHALCON_INIT_VAR(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "current", PH_NO_CHECK);
		phalcon_array_append(&records, r1, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "next", PH_NO_CHECK);
		goto ws_fd08_1;
	we_fd08_1:
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_cache"), PH_NOISY_CC);
	phalcon_array_update_string(&data, SL("cache"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&data, SL("rows"), &records, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_FUNC_PARAMS_1(r2, "serialize", data);
	RETURN_CTOR(r2);
}

/**
 * Unserializing a resultset will allow to only works on the rows present in the saved state
 *
 * @param string $data
 */
PHP_METHOD(Phalcon_Model_Resultset, unserialize){

	zval *data = NULL, *resultset = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_FUNC_PARAMS_1(resultset, "unserialize", data);
	if (Z_TYPE_P(resultset) == IS_ARRAY) { 
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, resultset, SL("rows"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_rows"), r0 TSRMLS_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, resultset, SL("cache"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_cache"), r1 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_model_exception_ce, "Invalid serialization data");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the associated cache for the resultset
 *
 * @return Phalcon\Cache\Backend
 */
PHP_METHOD(Phalcon_Model_Resultset, getCache){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_cache"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns an instance of the model that is used to generate each of the results
 *
 * @return Phalcon\Model\Base
 */
PHP_METHOD(Phalcon_Model_Resultset, getSourceModel){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_model"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \model\resultset.c ------ */

/* ------ Starting File: \tag.c ------ */
/**
 * Phalcon\Tag
 *
 * Phalcon\Tag is designed to simplify building of HTML tags.
 * It provides a set of helpers to generate HTML in a dynamic way.
 * This component is an abstract class that you can extend to add more helpers.
 */

/**
 * Sets the request dispatcher. A valid dispatcher is required to generate absolute paths
 *
 * @param Phalcon\Dispatcher $dispatcher
 */
PHP_METHOD(Phalcon_Tag, setDispatcher){

	zval *dispatcher = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dispatcher) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dispatcher) != IS_OBJECT) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_tag_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CONCAT_VS(r0, dispatcher, " must be an Object");
		PHALCON_INIT_VAR(c0);
		ZVAL_LONG(c0, 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", r0, c0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_dispatcher"), dispatcher TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Internally gets the request dispatcher
 *
 * @return Phalcon\Dispatcher
 */
PHP_METHOD(Phalcon_Tag, _getDispatcher){

	zval *dispatcher = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(dispatcher);
	phalcon_read_static_property(&dispatcher, SL("phalcon\\tag"), SL("_dispatcher") TSRMLS_CC);
	if (!zend_is_true(dispatcher)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_STATIC(r0, "phalcon\\controller\\front", "getinstance");
		PHALCON_INIT_VAR(dispatcher);
		PHALCON_CALL_METHOD(dispatcher, r0, "getdispatcher", PH_NO_CHECK);
		phalcon_update_static_property(SL("phalcon\\tag"), SL("_dispatcher"), dispatcher TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(dispatcher);
}

/**
 * Assigns default values to generated tags by helpers
 *
 * @param string $id
 * @param string $value
 */
PHP_METHOD(Phalcon_Tag, setDefault){

	zval *id = NULL, *value = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &id, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(value)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "is_scalar", value);
		if (!zend_is_true(r0)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Only scalar values can be assigned to UI components");
			return;
		}
	}
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_displayValues") TSRMLS_CC);
	if (Z_TYPE_P(t0) != IS_ARRAY) {
		convert_to_array(t0);
	}
	phalcon_array_update(&t0, id, &value, PH_COPY TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_displayValues"), t0 TSRMLS_CC);
	
	
	PHALCON_MM_RESTORE();
}

/**
 * Alias of Phalcon\Tag::setDefault
 *
 * @param string $id
 * @param string $value
 */
PHP_METHOD(Phalcon_Tag, displayTo){

	zval *id = NULL, *value = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &id, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "setdefault", id, value);
	RETURN_CTOR(r0);
}

/**
 * Every helper calls this function to check whether a component has a predefined
 * value using Phalcon\Tag::setDefault or value from $_POST
 *
 * @param string $name
 * @return mixed
 */
PHP_METHOD(Phalcon_Tag, getValue){

	zval *name = NULL, *display_values = NULL, *post = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(display_values);
	phalcon_read_static_property(&display_values, SL("phalcon\\tag"), SL("_displayValues") TSRMLS_CC);
	eval_int = phalcon_array_isset(display_values, name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, display_values, name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
		PHALCON_CPY_WRT(post, g0);
		eval_int = phalcon_array_isset(post, name);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_FUNC(r1, "get_magic_quotes_gpc");
			if (!zend_is_true(r1)) {
				PHALCON_ALLOC_ZVAL_MM(r2);
				phalcon_array_fetch(&r2, post, name, PH_NOISY_CC);
				
				RETURN_CCTOR(r2);
			} else {
				PHALCON_ALLOC_ZVAL_MM(r3);
				phalcon_array_fetch(&r3, post, name, PH_NOISY_CC);
				PHALCON_ALLOC_ZVAL_MM(r4);
				PHALCON_CALL_FUNC_PARAMS_1(r4, "stripslashes", r3);
				RETURN_CTOR(r4);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Resets the request and internal values to avoid those fields will have any default value
 */
PHP_METHOD(Phalcon_Tag, resetInput){

	zval *value = NULL, *key = NULL;
	zval *a0 = NULL;
	zval *g0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_displayValues"), a0 TSRMLS_CC);
	phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
	if (phalcon_valid_foreach(g0 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(g0);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_0;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		phalcon_array_unset(g0, key);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_0;
		fee_9b93_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Builds a HTML A tag using framework conventions
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, linkTo){

	zval *parameters = NULL, *text = NULL, *params = NULL, *action = NULL, *code = NULL, *value = NULL;
	zval *key = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &text) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!text) {
		PHALCON_ALLOC_ZVAL_MM(text);
		ZVAL_NULL(text);
	} else {
		PHALCON_SEPARATE_PARAM(text);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, text, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(action);
	ZVAL_STRING(action, "", 1);
	eval_int = phalcon_array_isset_long(params, 0);
	if (eval_int) {
		PHALCON_INIT_VAR(action);
		phalcon_array_fetch_long(&action, params, 0, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SL("action")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(action);
			phalcon_array_fetch_string(&action, params, SL("action"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SL("action")+1);
		}
	}
	
	PHALCON_INIT_VAR(text);
	ZVAL_STRING(text, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_VAR(text);
		phalcon_array_fetch_long(&text, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SL("text")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(text);
			phalcon_array_fetch_string(&text, params, SL("text"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SL("text")+1);
		}
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "", 1);
	eval_int = phalcon_array_isset_string(params, SL("confirm")+1);
	if (eval_int) {
		eval_int = phalcon_array_isset_string(params, SL("onclick")+1);
		if (!eval_int) {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, "", 1);
			phalcon_array_update_string(&params, SL("onclick"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, params, SL("confirm"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, params, SL("onclick"), PH_NOISY_CC);
		
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CONCAT_SVSV(r2, "if(!confirm('", r0, "')) { return false; }; ", r1);
		phalcon_array_update_string(&params, SL("onclick"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("confirm")+1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_STATIC_PARAMS_1(r3, "phalcon\\utils", "geturl", action);
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<a href=\"", r3, "\" ");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_1;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r4);
			PHALCON_CONCAT_SVSVS(r4, " ", key, "=\"", value, "\" ");
			phalcon_concat_self(&code, r4 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_1;
		fee_9b93_1:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	PHALCON_CONCAT_SVS(r5, ">", text, "</a>");
	phalcon_concat_self(&code, r5 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds generic INPUT tags
 *
 * @param   string $type
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, _inputField){

	zval *type = NULL, *parameters = NULL, *params = NULL, *id = NULL, *value = NULL, *code = NULL;
	zval *avalue = NULL, *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &type, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, params, SL("id"), PH_NOISY_CC);
		phalcon_array_update_long(&params, 0, &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SL("name")+1);
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, params, SL("name"), PH_NOISY_CC);
		if (!zend_is_true(r1)) {
			phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SL("value")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch_string(&value, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("value")+1);
	} else {
		PHALCON_INIT_VAR(value);
		PHALCON_CALL_SELF_PARAMS_1(value, this_ptr, "getvalue", id);
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVSVSVS(code, "<input type=\"", type, "\" id=\"", id, "\" value=\"", value, "\" ");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_2;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(avalue);
		ZVAL_ZVAL(avalue, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r2);
			PHALCON_CONCAT_VSVS(r2, key, "=\"", avalue, "\" ");
			phalcon_concat_self(&code, r2 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_2;
		fee_9b93_2:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, " />", 1);
	phalcon_concat_self(&code, t0 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds a HTML input[type="text"] tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, textField){

	zval *parameters = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "text", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_inputfield", c0, parameters);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML input[type="password"] tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, passwordField){

	zval *parameters = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "password", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_inputfield", c0, parameters);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML input[type="hidden"] tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, hiddenField){

	zval *parameters = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "hidden", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_inputfield", c0, parameters);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML input[type="file"] tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, fileField){

	zval *parameters = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "file", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_inputfield", c0, parameters);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML input[type="check"] tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, checkField){

	zval *parameters = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "checkbox", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_inputfield", c0, parameters);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML input[type="submit"] tag
 *
 * @param array $params
 * @return string
 */
PHP_METHOD(Phalcon_Tag, submitButton){

	zval *parameters = NULL, *params = NULL, *value = NULL, *code = NULL, *avalue = NULL;
	zval *key = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SL("value")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch_string(&value, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("value")+1);
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(value);
			phalcon_array_fetch_long(&value, params, 0, PH_NOISY_CC);
		} else {
			PHALCON_INIT_VAR(value);
			ZVAL_STRING(value, "", 1);
		}
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<input type=\"submit\" value=\"", value, "\" ");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_3:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_3;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(avalue);
		ZVAL_ZVAL(avalue, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r0);
			PHALCON_CONCAT_VSVS(r0, key, "=\"", avalue, "\" ");
			phalcon_concat_self(&code, r0 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_3;
		fee_9b93_3:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, " />", 1);
	phalcon_concat_self(&code, t0 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds a HTML SELECT tag using a PHP array for options
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, selectStatic){

	zval *parameters = NULL, *data = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_ALLOC_ZVAL_MM(data);
		ZVAL_NULL(data);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\tag\\select", "selectfield", parameters, data);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML SELECT tag using a Phalcon_Model resultset as options
 *
 * @param array $params
 * @return string
 */
PHP_METHOD(Phalcon_Tag, select){

	zval *parameters = NULL, *data = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_ALLOC_ZVAL_MM(data);
		ZVAL_NULL(data);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_STATIC_PARAMS_2(r0, "phalcon\\tag\\select", "selectfield", parameters, data);
	RETURN_CTOR(r0);
}

/**
 * Builds a HTML TEXTAREA tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, textArea){

	zval *parameters = NULL, *params = NULL, *id = NULL, *content = NULL, *code = NULL, *avalue = NULL;
	zval *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, params, SL("id"), PH_NOISY_CC);
		phalcon_array_update_long(&params, 0, &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SL("name")+1);
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, params, SL("name"), PH_NOISY_CC);
		if (!zend_is_true(r1)) {
			phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SL("value")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(content);
		phalcon_array_fetch_string(&content, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("value")+1);
	} else {
		PHALCON_INIT_VAR(content);
		PHALCON_CALL_SELF_PARAMS_1(content, this_ptr, "getvalue", id);
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<textarea id=\"", id, "\" ");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_4:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_4;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(avalue);
		ZVAL_ZVAL(avalue, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r2);
			PHALCON_CONCAT_VSVS(r2, key, "=\"", avalue, "\" ");
			phalcon_concat_self(&code, r2 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_4;
		fee_9b93_4:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CONCAT_SVS(r3, ">", content, "</textarea>");
	phalcon_concat_self(&code, r3 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds a HTML FORM tag
 *
 * @param array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, form){

	zval *parameters = NULL, *params = NULL, *dispatcher = NULL, *action_parameters = NULL;
	zval *action = NULL, *code = NULL, *avalue = NULL, *key = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL, *r12 = NULL, *r13 = NULL;
	zval *r14 = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(dispatcher);
	PHALCON_CALL_SELF(dispatcher, this_ptr, "_getdispatcher");
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "/", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, dispatcher, "getparams", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(action_parameters);
	phalcon_fast_join(action_parameters, c0, r0 TSRMLS_CC);
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		eval_int = phalcon_array_isset_string(params, SL("action")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(action);
			phalcon_array_fetch_string(&action, params, SL("action"), PH_NOISY_CC);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_METHOD(r1, dispatcher, "getcontrollername", PH_NO_CHECK);
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD(r2, dispatcher, "getactionname", PH_NO_CHECK);
			PHALCON_INIT_VAR(action);
			PHALCON_CONCAT_VSV(action, r1, "/", r2);
		}
	} else {
		PHALCON_INIT_VAR(action);
		phalcon_array_fetch_long(&action, params, 0, PH_NOISY_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("method")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t0);
		ZVAL_STRING(t0, "post", 1);
		phalcon_array_update_string(&params, SL("method"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("confirm")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r3);
		phalcon_array_fetch_string(&r3, params, SL("onsubmit"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r4);
		phalcon_array_fetch_string(&r4, params, SL("onsubmit"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r5);
		phalcon_array_fetch_string(&r5, params, SL("confirm"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r6);
		PHALCON_CONCAT_VSVS(r6, r4, ";if(!confirm(\"", r5, "\")) { return false; }");
		PHALCON_ALLOC_ZVAL_MM(r7);
		concat_function(r7, r3, r6 TSRMLS_CC);
		phalcon_array_update_string(&params, SL("onsubmit"), &r7, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SL("confirm")+1);
	}
	
	if (zend_is_true(action_parameters)) {
		PHALCON_ALLOC_ZVAL_MM(r8);
		PHALCON_CALL_STATIC_PARAMS_1(r8, "phalcon\\utils", "geturl", action);
		PHALCON_CPY_WRT(action, r8);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r9);
		PHALCON_CONCAT_VSV(r9, action, "/", action_parameters);
		PHALCON_ALLOC_ZVAL_MM(r10);
		PHALCON_CALL_STATIC_PARAMS_1(r10, "phalcon\\utils", "geturl", r9);
		PHALCON_CPY_WRT(action, r10);
	}
	
	eval_int = phalcon_array_isset_string(params, SL("parameters")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r11);
		phalcon_array_fetch_string(&r11, params, SL("parameters"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r12);
		PHALCON_CONCAT_SV(r12, "?", r11);
		phalcon_concat_self(&action, r12 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<form action=\"", action, "\" ");
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_5:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_5;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(avalue);
		ZVAL_ZVAL(avalue, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r13);
			PHALCON_CONCAT_VSVS(r13, key, "= \"", avalue, "\" ");
			phalcon_concat_self(&code, r13 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_5;
		fee_9b93_5:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r14);
	PHALCON_CONCAT_VS(r14, code, ">");
	
	RETURN_CTOR(r14);
}

/**
 * Builds a HTML close FORM tag
 *
 * @return string
 */
PHP_METHOD(Phalcon_Tag, endForm){


	PHALCON_MM_GROW();
	PHALCON_MM_RESTORE();
	RETURN_STRING("</form>", 1);
}

/**
 * Set the title of view content
 *
 * @param string $title
 */
PHP_METHOD(Phalcon_Tag, setTitle){

	zval *title = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), title TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Add to title of view content
 *
 * @param string $title
 */
PHP_METHOD(Phalcon_Tag, appendTitle){

	zval *title = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	concat_function(r0, t0, title TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), r0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Add before the title of view content
 *
 * @param string $title
 */
PHP_METHOD(Phalcon_Tag, prependTitle){

	zval *title = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, title, t0);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), r0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Get the title of view content
 *
 * @return string
 */
PHP_METHOD(Phalcon_Tag, getTitle){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(t1);
	zend_get_constant(SL("PHP_EOL"), t1 TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVSV(r0, "<title>", t0, "</title>", t1);
	
	RETURN_CTOR(r0);
}

/**
 * Builds a LINK[rel="stylesheet"] tag
 *
 * @param array $parameters
 * @param   boolean $local
 * @return string
 */
PHP_METHOD(Phalcon_Tag, stylesheetLink){

	zval *parameters = NULL, *local = NULL, *params = NULL, *code = NULL, *value = NULL, *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &parameters, &local) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	if (!local) {
		PHALCON_ALLOC_ZVAL_MM(local);
		ZVAL_BOOL(local, 1);
	} else {
		PHALCON_SEPARATE_PARAM(local);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, local, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SL("href")+1);
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_long(&r0, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("href"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, "", 1);
			phalcon_array_update_string(&params, SL("href"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(local);
	ZVAL_STRING(local, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_VAR(local);
		phalcon_array_fetch_long(&local, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SL("local")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(local);
			phalcon_array_fetch_string(&local, params, SL("local"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SL("local")+1);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SL("type")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t1);
		ZVAL_STRING(t1, "text/css", 1);
		phalcon_array_update_string(&params, SL("type"), &t1, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	if (zend_is_true(local)) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, params, SL("href"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_STATIC_PARAMS_1(r2, "phalcon\\utils", "geturl", r1);
		phalcon_array_update_string(&params, SL("href"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<link rel=\"stylesheet\"", 1);
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_6:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_6;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r3);
			PHALCON_CONCAT_SVSVS(r3, " ", key, "=\"", value, "\"");
			phalcon_concat_self(&code, r3 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_6;
		fee_9b93_6:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	zend_get_constant(SL("PHP_EOL"), t2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CONCAT_SV(r4, ">", t2);
	phalcon_concat_self(&code, r4 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds a SCRIPT[type="javascript"] tag
 *
 * @param array $parameters
 * @param   boolean $local
 * @return string
 */
PHP_METHOD(Phalcon_Tag, javascriptInclude){

	zval *parameters = NULL, *local = NULL, *params = NULL, *code = NULL, *value = NULL, *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &parameters, &local) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	if (!local) {
		PHALCON_ALLOC_ZVAL_MM(local);
		ZVAL_BOOL(local, 1);
	} else {
		PHALCON_SEPARATE_PARAM(local);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, local, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SL("src")+1);
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_long(&r0, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("src"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, "", 1);
			phalcon_array_update_string(&params, SL("src"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(local);
	ZVAL_STRING(local, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_VAR(local);
		phalcon_array_fetch_long(&local, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SL("local")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(local);
			phalcon_array_fetch_string(&local, params, SL("local"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SL("local")+1);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SL("type")+1);
	if (!eval_int) {
		PHALCON_INIT_VAR(t1);
		ZVAL_STRING(t1, "text/javascript", 1);
		phalcon_array_update_string(&params, SL("type"), &t1, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	if (zend_is_true(local)) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		phalcon_array_fetch_string(&r1, params, SL("src"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_STATIC_PARAMS_1(r2, "phalcon\\utils", "geturl", r1);
		phalcon_array_update_string(&params, SL("src"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<script", 1);
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_7:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_7;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r3);
			PHALCON_CONCAT_SVSVS(r3, " ", key, "=\"", value, "\" ");
			phalcon_concat_self(&code, r3 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_7;
		fee_9b93_7:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	zend_get_constant(SL("PHP_EOL"), t2 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CONCAT_SV(r4, "></script>", t2);
	phalcon_concat_self(&code, r4 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/**
 * Builds HTML IMG tags
 *
 * @param  array $parameters
 * @return string
 */
PHP_METHOD(Phalcon_Tag, image){

	zval *parameters = NULL, *params = NULL, *code = NULL, *value = NULL, *key = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_ALLOC_ZVAL_MM(parameters);
		ZVAL_NULL(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SL("src")+1);
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_long(&r0, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("src"), &r0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(t0);
			ZVAL_STRING(t0, "", 1);
			phalcon_array_update_string(&params, SL("src"), &t0, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_array_fetch_string(&r1, params, SL("src"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_STATIC_PARAMS_1(r2, "phalcon\\utils", "geturl", r1);
	phalcon_array_update_string(&params, SL("src"), &r2, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<img", 1);
	if (phalcon_valid_foreach(params TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9b93_8:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9b93_8;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_INIT_VAR(r3);
			PHALCON_CONCAT_SVSVS(r3, " ", key, "=\"", value, "\"");
			phalcon_concat_self(&code, r3 TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9b93_8;
		fee_9b93_8:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	zend_get_constant(SL("PHP_EOL"), t1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CONCAT_SV(r4, ">", t1);
	phalcon_concat_self(&code, r4 TSRMLS_CC);
	
	RETURN_CTOR(code);
}

/* ------ Finished File: \tag.c ------ */

/* ------ Starting File: \response.c ------ */
/**
 * Phalcon\Response
 *
 * Encapsulates the HTTP response message.
 *
 *
 */

/**
 * Returns singleton Phalcon\Response instance
 *
 * @return Phalcon\Response
 */
PHP_METHOD(Phalcon_Response, getInstance){

	zval *instance = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(instance);
	phalcon_read_static_property(&instance, SL("phalcon\\response"), SL("_instance") TSRMLS_CC);
	if (!zend_is_true(instance)) {
		PHALCON_INIT_VAR(instance);
		object_init_ex(instance, phalcon_response_ce);
		phalcon_update_static_property(SL("phalcon\\response"), SL("_instance"), instance TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(instance);
}

/**
 * Sets the HTTP response code
 *
 * @param int $code
 * @param strign $message
 * @return Phalcon\Response
 */
PHP_METHOD(Phalcon_Response, setStatusCode){

	zval *code = NULL, *message = NULL, *headers = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &code, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_SVSV(r0, "HTTP/1.1 ", code, " ", message);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(headers, "setraw", r0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "Status", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CONCAT_VSV(r1, code, " ", message);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", c0, r1, PH_NO_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_headers"), headers TSRMLS_CC);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Returns headers set by the user
 *
 * @return Phalcon\Response\Headers
 */
PHP_METHOD(Phalcon_Response, getHeaders){

	zval *headers = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	if (!zend_is_true(headers)) {
		PHALCON_INIT_VAR(headers);
		object_init_ex(headers, phalcon_response_headers_ce);
		PHALCON_CALL_METHOD_NORETURN(headers, "__construct", PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_headers"), headers TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(headers);
}

/**
 * Overwrites a header in the response
 *
 * @param string $name
 * @param string $value
 * @return Phalcon\Response
 */
PHP_METHOD(Phalcon_Response, setHeader){

	zval *name = NULL, *value = NULL, *headers = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", name, value, PH_NO_CHECK);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Send a raw header to the response
 *
 * @param string $header
 * @return Phalcon\Response
 */
PHP_METHOD(Phalcon_Response, setRawHeader){

	zval *header = NULL, *headers = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "setraw", header, PH_NO_CHECK);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Sets output expire time header
 *
 * @param DateTime $datetime
 * @return Phalcon\Response
 */
PHP_METHOD(Phalcon_Response, setExpires){

	zval *datetime = NULL, *headers = NULL, *date = NULL;
	zval *i0 = NULL, *i1 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &datetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(datetime) == IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_response_exception_ce, "datetime parameter must be an instance of DateTime");
		return;
	}
	
	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(i0);
	if (phalcon_clone(i0, datetime TSRMLS_CC) == FAILURE){
		return;
	}
	PHALCON_CPY_WRT(date, i0);
	ce0 = zend_fetch_class(SL("DateTimeZone"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, ce0);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "UTC", 1);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", c0, PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(date, "settimezone", i1, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "Expires", 1);
	
	PHALCON_INIT_VAR(c2);
	ZVAL_STRING(c2, "D, d M Y H:i:s", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, date, "format", c2, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CONCAT_VS(r1, r0, " GMT");
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setheader", c1, r1, PH_NO_CHECK);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Sends a Not-Modified response
 */
PHP_METHOD(Phalcon_Response, setNotModified){

	zval *c0 = NULL, *c1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 304);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "Not modified", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setstatuscode", c0, c1, PH_NO_CHECK);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Sets the response content-type mime, optionally the charset
 *
 */
PHP_METHOD(Phalcon_Response, setContentType){


	
}

/**
 * Redirect by HTTP to another action or URL
 *
 * @param string $location
 * @param boolean $externalRedirect
 * @param int $statusCode
 * @return Phalcon_Response
 */
PHP_METHOD(Phalcon_Response, redirect){

	zval *location = NULL, *external_redirect = NULL, *status_code = NULL;
	zval *header = NULL;
	zval *c0 = NULL, *c1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &location, &external_redirect, &status_code) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!external_redirect) {
		PHALCON_ALLOC_ZVAL_MM(external_redirect);
		ZVAL_BOOL(external_redirect, 0);
	}
	
	if (!status_code) {
		PHALCON_ALLOC_ZVAL_MM(status_code);
		ZVAL_LONG(status_code, 302);
	}
	
	if (zend_is_true(external_redirect)) {
		PHALCON_CPY_WRT(header, location);
	} else {
		PHALCON_INIT_VAR(header);
		PHALCON_CALL_STATIC_PARAMS_1(header, "phalcon\\utils", "geturl", location);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "Redirect", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setstatuscode", status_code, c0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "Location", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setheader", c1, header, PH_NO_CHECK);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Sets HTTP response body
 *
 * @param string $content
 */
PHP_METHOD(Phalcon_Response, setContent){

	zval *content = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_content"), content TSRMLS_CC);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Appends a string to the HTTP response body
 *
 * @param string $content
 * @return Phalcon_Response
 */
PHP_METHOD(Phalcon_Response, appendContent){

	zval *content = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	concat_function(r0, t0, content TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_content"), r0 TSRMLS_CC);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Gets HTTP response body
 *
 * @return string
 */
PHP_METHOD(Phalcon_Response, getContent){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sends headers to the client
 *
 */
PHP_METHOD(Phalcon_Response, sendHeaders){

	zval *headers = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	if (zend_is_true(headers)) {
		PHALCON_CALL_METHOD_NORETURN(headers, "send", PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Prints out HTTP response to the client
 *
 * @return Phalcon_Response
 */
PHP_METHOD(Phalcon_Response, send){

	zval *headers = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	if (zend_is_true(headers)) {
		PHALCON_CALL_METHOD_NORETURN(headers, "send", PH_NO_CHECK);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	zend_print_zval(t0, 1);
	
	RETURN_CCTOR(this_ptr);
}

/**
 * Resets the internal singleton
 */
PHP_METHOD(Phalcon_Response, reset){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	phalcon_update_static_property(SL("phalcon\\response"), SL("_instance"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \response.c ------ */

/* ------ Starting File: \request.c ------ */
/**
 * Phalcon\Request
 *
 * Encapsulates request information for easy and secure access from application controllers.
 *
 * The request object is a simple value object that is passed between the dispatcher and controller classes.
 * It packages the HTTP request environment.
 *
 * 
 *
 * @see http://phalconphp.com/documentation/request
 */

/**
 * Gets the singleton instance of Phalcon\Request
 *
 * @return Phalcon\Request
 */
PHP_METHOD(Phalcon_Request, getInstance){

	zval *instance = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(instance);
	phalcon_read_static_property(&instance, SL("phalcon\\request"), SL("_instance") TSRMLS_CC);
	if (!zend_is_true(instance)) {
		PHALCON_INIT_VAR(instance);
		object_init_ex(instance, phalcon_request_ce);
		phalcon_update_static_property(SL("phalcon\\request"), SL("_instance"), instance TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(instance);
}

/**
 * Overwrites Phalcon_Filter object used to sanitize input data
 *
 * @param Phalcon_Filter $filter
 */
PHP_METHOD(Phalcon_Request, setFilter){

	zval *filter = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &filter) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_filter"), filter TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the active filter object used to sanitize input data
 *
 * @return Phalcon_Filter
 */
PHP_METHOD(Phalcon_Request, getFilter){

	zval *t0 = NULL, *t1 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_filter"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_filter_ce);
		phalcon_update_property_zval(this_ptr, SL("_filter"), i0 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_filter"), PH_NOISY_CC);
	
	RETURN_CCTOR(t1);
}

/**
 * Gets variable from $_POST superglobal applying filters if needed
 *
 * @param string $name
 * @param string|array $filters
 * @return mixed
 */
PHP_METHOD(Phalcon_Request, getPost){

	zval *name = NULL, *filters = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &filters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_ALLOC_ZVAL_MM(filters);
		ZVAL_NULL(filters);
	}
	
	phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		if (zend_is_true(filters)) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_CALL_METHOD(r0, this_ptr, "getfilter", PH_NO_CHECK);
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_array_fetch(&r1, g0, name, PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD_PARAMS_2(r2, r0, "sanitize", r1, filters, PH_NO_CHECK);
			RETURN_CTOR(r2);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_array_fetch(&r3, g0, name, PH_NOISY_CC);
			
			RETURN_CCTOR(r3);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Gets variable from $_GET superglobal applying filters if needed
 *
 * @param string $name
 * @param string|array $filters
 * @return mixed
 */
PHP_METHOD(Phalcon_Request, getQuery){

	zval *name = NULL, *filters = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &filters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_ALLOC_ZVAL_MM(filters);
		ZVAL_NULL(filters);
	}
	
	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		if (zend_is_true(filters)) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_CALL_METHOD(r0, this_ptr, "getfilter", PH_NO_CHECK);
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_array_fetch(&r1, g0, name, PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CALL_METHOD_PARAMS_2(r2, r0, "sanitize", r1, filters, PH_NO_CHECK);
			RETURN_CTOR(r2);
		} else {
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_array_fetch(&r3, g0, name, PH_NOISY_CC);
			
			RETURN_CCTOR(r3);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Gets variable from $_SERVER superglobal
 *
 * @param string $name
 * @return mixed
 */
PHP_METHOD(Phalcon_Request, getServer){

	zval *name = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, g0, name, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

/**
 * Checks whether $_POST superglobal has certain index
 *
 * @param string $name
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, hasPost){

	zval *name = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Checks whether $_SERVER superglobal has certain index
 *
 * @param string $name
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, hasQuery){

	zval *name = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Checks whether $_SERVER superglobal has certain index
 *
 * @param string $name
 * @return mixed
 */
PHP_METHOD(Phalcon_Request, hasServer){

	zval *name = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/**
 * Gets HTTP header from request data
 *
 * @param string $header
 * @return string
 */
PHP_METHOD(Phalcon_Request, getHeader){

	zval *header = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, header);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, g0, header, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SV(r1, "HTTP_", header);
		eval_int = phalcon_array_isset(g0, r1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r2);
			PHALCON_CONCAT_SV(r2, "HTTP_", header);
			PHALCON_ALLOC_ZVAL_MM(r3);
			phalcon_array_fetch(&r3, g0, r2, PH_NOISY_CC);
			
			RETURN_CCTOR(r3);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Gets HTTP schema (http/https)
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getScheme){

	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_HTTPS", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "getserver", c0, PH_NO_CHECK);
	if (PHALCON_COMPARE_STRING(r0, "on")) {
		PHALCON_MM_RESTORE();
		RETURN_STRING("https", 1);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("http", 1);
}

/**
 * Checks whether request has been made using ajax
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isAjax){

	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_X_REQUESTED_WITH", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_1(r0, this_ptr, "getheader", c0, PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "XMLHttpRequest", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether request has been made using SOAP
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isSoapRequested){

	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *c0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("HTTP_SOAPACTION")+1);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		eval_int = phalcon_array_isset_string(g0, SL("CONTENT_TYPE")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_string(&r0, g0, SL("CONTENT_TYPE"), PH_NOISY_CC);
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "application/soap+xml", 1);
			PHALCON_ALLOC_ZVAL_MM(r1);
			phalcon_fast_strpos(r1, r0, c0 TSRMLS_CC);
			PHALCON_INIT_VAR(t0);
			ZVAL_BOOL(t0, 0);
			PHALCON_ALLOC_ZVAL_MM(r2);
			is_not_identical_function(r2, t0, r1 TSRMLS_CC);
			
			RETURN_NCTOR(r2);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Checks whether request has been made using any secure layer
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isSecureRequest){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getscheme", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "https", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_identical_function(r1, t0, r0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Gets HTTP raws request body
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getRawBody){

	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "php://input", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "file_get_contents", c0);
	RETURN_CTOR(r0);
}

/**
 * Gets active server address IP
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getServerAddress){

	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("SERVER_ADDR")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("SERVER_ADDR"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "localhost", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_FUNC_PARAMS_1(r1, "gethostbyname", c0);
	RETURN_CTOR(r1);
}

/**
 * Gets active server name
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getServerName){

	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("SERVER_NAME")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("SERVER_NAME"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("localhost", 1);
}

/**
 * Gets information about schema, host and port used by the request
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getHttpHost){

	zval *scheme = NULL, *name = NULL, *port = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(scheme);
	PHALCON_CALL_METHOD(scheme, this_ptr, "getscheme", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_SERVER_NAME", 1);
	
	PHALCON_INIT_VAR(name);
	PHALCON_CALL_METHOD_PARAMS_1(name, this_ptr, "getserver", c0, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "HTTP_SERVER_PORT", 1);
	
	PHALCON_INIT_VAR(port);
	PHALCON_CALL_METHOD_PARAMS_1(port, this_ptr, "getserver", c1, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "http", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, scheme, t0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 80);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, port, t1 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	phalcon_and_function(r2, r0, r1);
	
	PHALCON_INIT_VAR(t2);
	ZVAL_STRING(t2, "https", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_equal_function(r3, scheme, t2 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 443);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_equal_function(r4, port, t3 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	phalcon_and_function(r5, r3, r4);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	ZVAL_BOOL(r6, zend_is_true(r2) || zend_is_true(r5));
	if (zend_is_true(r6)) {
		
		RETURN_CCTOR(name);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	PHALCON_CONCAT_VSV(r7, name, ":", port);
	
	RETURN_CTOR(r7);
}

/**
 * Gets most possibly client IPv4 Address. This methods search in $_SERVER['HTTP_X_FORWARDED_FOR'] and $_SERVER['REMOTE_ADDR']
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getClientAddress){

	zval *address = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(address);
	ZVAL_STRING(address, "", 1);
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("HTTP_X_FORWARDED_FOR")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(address);
		phalcon_array_fetch_string(&address, g0, SL("HTTP_X_FORWARDED_FOR"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(g0, SL("REMOTE_ADDR")+1);
		if (eval_int) {
			PHALCON_INIT_VAR(address);
			phalcon_array_fetch_string(&address, g0, SL("REMOTE_ADDR"), PH_NOISY_CC);
		}
	}
	
	
	RETURN_CCTOR(address);
}

/**
 * Gets HTTP method which request has been made
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getMethod){

	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("REQUEST_METHOD")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("REQUEST_METHOD"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Gets HTTP user agent used to made the request
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getUserAgent){

	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("HTTP_USER_AGENT")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("HTTP_USER_AGENT"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Checks whether HTTP method is POST. if $_SERVER['REQUEST_METHOD']=='POST'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isPost){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "POST", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 *
 * Checks whether HTTP method is GET. if $_SERVER['REQUEST_METHOD']=='GET'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isGet){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "GET", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether HTTP method is PUT. if $_SERVER['REQUEST_METHOD']=='PUT'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isPut){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "PUT", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether HTTP method is HEAD. if $_SERVER['REQUEST_METHOD']=='HEAD'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isHead){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "HEAD", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether HTTP method is DELETE. if $_SERVER['REQUEST_METHOD']=='DELETE'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isDelete){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "DELETE", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether HTTP method is OPTIONS. if $_SERVER['REQUEST_METHOD']=='OPTIONS'
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, isOptions){

	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getmethod", PH_NO_CHECK);
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "OPTIONS", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r1);
}

/**
 * Checks whether request include attached files
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Request, hasFiles){

	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_FILES")+1 TSRMLS_CC);
	if (zend_is_true(g0)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_fast_count(r0, g0 TSRMLS_CC);
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 0);
		PHALCON_ALLOC_ZVAL_MM(r1);
		is_smaller_function(r1, t0, r0 TSRMLS_CC);
		
		RETURN_NCTOR(r1);
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

/**
 * Gets attached files as Phalcon_Request_File instances
 *
 * @return Phalcon_Request_File[]
 */
PHP_METHOD(Phalcon_Request, getUploadedFiles){

	zval *super_files = NULL, *files = NULL, *file = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	zval *i0 = NULL;
	zval *a0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_FILES")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(super_files, g0);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, super_files TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(files);
		array_init(files);
		if (phalcon_valid_foreach(super_files TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(super_files);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_9aea_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_9aea_0;
			}
			
			PHALCON_INIT_VAR(file);
			ZVAL_ZVAL(file, *hd, 1, 0);
			PHALCON_INIT_VAR(i0);
			object_init_ex(i0, phalcon_request_file_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", file, PH_CHECK);
			phalcon_array_append(&files, i0, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_9aea_0;
			fee_9aea_0:
			if(0){}
		} else {
			return;
		}
		
		RETURN_CTOR(files);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	
	RETURN_CTOR(a0);
}

/**
 * Gets web page that refers active request. ie: http://www.google.com
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getHTTPReferer){

	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SL("HTTP_REFERER")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, g0, SL("HTTP_REFERER"), PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

/**
 * Process a request header and return an array of values with their qualities
 *
 * @param string $serverIndex
 * @param string $name
 * @return array
 */
PHP_METHOD(Phalcon_Request, _getQualityHeader){

	zval *server_index = NULL, *name = NULL, *http_server = NULL, *parts = NULL;
	zval *returned_parts = NULL, *part = NULL, *header_parts = NULL, *quality = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *a0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &server_index, &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(http_server);
	PHALCON_CALL_METHOD_PARAMS_1(http_server, this_ptr, "getserver", server_index, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "/,\\s*/", 1);
	
	PHALCON_INIT_VAR(parts);
	PHALCON_CALL_FUNC_PARAMS_2(parts, "preg_split", c0, http_server);
	
	PHALCON_INIT_VAR(returned_parts);
	array_init(returned_parts);
	if (phalcon_valid_foreach(parts TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(parts);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9aea_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9aea_1;
		}
		
		PHALCON_INIT_VAR(part);
		ZVAL_ZVAL(part, *hd, 1, 0);
		PHALCON_INIT_VAR(c1);
		ZVAL_STRING(c1, ";", 1);
		PHALCON_INIT_VAR(header_parts);
		phalcon_fast_explode(header_parts, c1, part TSRMLS_CC);
		eval_int = phalcon_array_isset_long(header_parts, 1);
		if (eval_int) {
			PHALCON_INIT_VAR(r0);
			phalcon_array_fetch_long(&r0, header_parts, 1, PH_NOISY_CC);
			PHALCON_INIT_VAR(c2);
			ZVAL_LONG(c2, 2);
			PHALCON_INIT_VAR(quality);
			PHALCON_CALL_FUNC_PARAMS_2(quality, "substr", r0, c2);
		} else {
			PHALCON_INIT_VAR(quality);
			ZVAL_DOUBLE(quality, 1);
		}
		
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch_long(&r1, header_parts, 0, PH_NOISY_CC);
		phalcon_array_update(&a0, name, &r1, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&a0, SL("quality"), &quality, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&returned_parts, a0, PH_SEPARATE TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9aea_1;
		fee_9aea_1:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CTOR(returned_parts);
}

/**
 * Process a request header and return the one with best quality
 *
 * @param array $qualityParts
 * @param string $name
 * @return string
 */
PHP_METHOD(Phalcon_Request, _getBestQuality){

	zval *quality_parts = NULL, *name = NULL, *i = NULL, *quality = NULL, *selected_name = NULL;
	zval *accept = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &quality_parts, &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(i);
	ZVAL_LONG(i, 0);
	
	PHALCON_INIT_VAR(quality);
	ZVAL_LONG(quality, 0);
	
	PHALCON_INIT_VAR(selected_name);
	ZVAL_STRING(selected_name, "", 1);
	if (phalcon_valid_foreach(quality_parts TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(quality_parts);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9aea_2:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9aea_2;
		}
		
		PHALCON_INIT_VAR(accept);
		ZVAL_ZVAL(accept, *hd, 1, 0);
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 0);
		PHALCON_INIT_VAR(r0);
		is_equal_function(r0, i, t0 TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(quality);
			phalcon_array_fetch_string(&quality, accept, SL("quality"), PH_NOISY_CC);
			
			PHALCON_INIT_VAR(selected_name);
			phalcon_array_fetch(&selected_name, accept, name, PH_NOISY_CC);
		} else {
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch_string(&r1, accept, SL("quality"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r2);
			is_smaller_function(r2, quality, r1 TSRMLS_CC);
			if (zend_is_true(r2)) {
				PHALCON_INIT_VAR(quality);
				phalcon_array_fetch_string(&quality, accept, SL("quality"), PH_NOISY_CC);
				
				PHALCON_INIT_VAR(selected_name);
				phalcon_array_fetch(&selected_name, accept, name, PH_NOISY_CC);
			}
		}
		PHALCON_SEPARATE(i);
		increment_function(i);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9aea_2;
		fee_9aea_2:
		if(0){}
	} else {
		return;
	}
	
	RETURN_CCTOR(selected_name);
}

/**
 * Gets array with mime/types and their quality accepted by the browser/client from $_SERVER['HTTP_ACCEPT']
 *
 * @return array
 */
PHP_METHOD(Phalcon_Request, getAcceptableContent){

	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_ACCEPT", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "accept", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "_getqualityheader", c0, c1, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Gets best mime/type accepted by the browser/client from $_SERVER['HTTP_ACCEPT']
 *
 * @return array
 */
PHP_METHOD(Phalcon_Request, getBestAccept){

	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getacceptablecontent", PH_NO_CHECK);
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "accept", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_2(r1, this_ptr, "_getbestquality", r0, c0, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Gets charsets array and their quality accepted by the browser/client from $_SERVER['HTTP_ACCEPT_CHARSET']
 *
 * @return array
 */
PHP_METHOD(Phalcon_Request, getClientCharsets){

	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_ACCEPT_CHARSET", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "charset", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "_getqualityheader", c0, c1, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Gets best charset accepted by the browser/client from $_SERVER['HTTP_ACCEPT_CHARSET']
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getBestCharset){

	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getclientcharsets", PH_NO_CHECK);
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "charset", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_2(r1, this_ptr, "_getbestquality", r0, c0, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Gets languages array and their quality accepted by the browser/client from $_SERVER['HTTP_ACCEPT_LANGUAGE']
 *
 * @return array
 */
PHP_METHOD(Phalcon_Request, getLanguages){

	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "HTTP_ACCEPT_LANGUAGE", 1);
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "language", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, this_ptr, "_getqualityheader", c0, c1, PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Gets best language accepted by the browser/client from $_SERVER['HTTP_ACCEPT_LANGUAGE']
 *
 * @return string
 */
PHP_METHOD(Phalcon_Request, getBestLanguage){

	zval *r0 = NULL, *r1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, this_ptr, "getlanguages", PH_NO_CHECK);
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "language", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_2(r1, this_ptr, "_getbestquality", r0, c0, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Resets the internal singleton
 */
PHP_METHOD(Phalcon_Request, reset){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	phalcon_update_static_property(SL("phalcon\\request"), SL("_instance"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \request.c ------ */

/* ------ Starting File: \transaction\exception.c ------ */
/**
 * Phalcon_Transaction_Exception
 *
 * Exceptions thrown in Phalcon_Transaction will use this class
 *
 */

/* ------ Finished File: \transaction\exception.c ------ */

/* ------ Starting File: \transaction\failed.c ------ */
/**
 * Phalcon_Transaction_Failed
 *
 * Phalcon_Transaction_Failed will thrown to exit a try/catch block for transactions
 *
 */

/**
 * Phalcon_Transaction_Failed constructor
 *
 * @param string $message
 * @param Phalcon_Model_Base $record
 */
PHP_METHOD(Phalcon_Transaction_Failed, __construct){

	zval *message = NULL, *record = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &message, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_record"), record TSRMLS_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_LONG(c0, 0);
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Transaction\\Failed", "__construct", message, c0);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns validation record messages which stop the transaction
 *
 * @return string
 */
PHP_METHOD(Phalcon_Transaction_Failed, getRecordMessages){

	zval *record = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(record);
	phalcon_read_property(&record, this_ptr, SL("_record"), PH_NOISY_CC);
	if (zend_is_true(record)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_METHOD(r0, record, "getmessages", PH_NO_CHECK);
		RETURN_CTOR(r0);
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_METHOD(r1, this_ptr, "getmessage", PH_NO_CHECK);
		RETURN_CTOR(r1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns validation record messages which stop the transaction
 *
 * @return Phalcon_Model_Base
 */
PHP_METHOD(Phalcon_Transaction_Failed, getRecord){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_record"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \transaction\failed.c ------ */

/* ------ Starting File: \transaction\manager.c ------ */
/**
 * Phalcon\Transaction\Manager
 *
 * A transaction acts on a single database connection. If you have multiple class-specific
 * databases, the transaction will not protect interaction among them
 *
  *
 *
 */

/**
 * Checks whether manager has an active transaction
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction_Manager, has){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_number") TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_smaller_function(r0, t1, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r0);
}

/**
 * Returns a new Phalcon_Transaction or an already created once
 *
 * @param boolean $autoBegin
 * @return Phalcon_Transaction
 */
PHP_METHOD(Phalcon_Transaction_Manager, get){

	zval *auto_begin = NULL, *number = NULL, *transaction = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL;
	zval *a0 = NULL;
	zval *c0 = NULL, *c1 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &auto_begin) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!auto_begin) {
		PHALCON_ALLOC_ZVAL_MM(auto_begin);
		ZVAL_BOOL(auto_begin, 1);
	}
	
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_initialized") TSRMLS_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		add_next_index_stringl(a0, SL("Phalcon\\Transaction\\Manager"), 1);
		add_next_index_stringl(a0, SL("rollbackPendent"), 1);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("register_shutdown_function", a0);
		
		PHALCON_INIT_VAR(t1);
		ZVAL_BOOL(t1, 1);
		phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_initialized"), t1 TSRMLS_CC);
	}
	PHALCON_OBSERVE_VAR(number);
	phalcon_read_static_property(&number, SL("phalcon\\transaction\\manager"), SL("_number") TSRMLS_CC);
	if (!zend_is_true(number)) {
		PHALCON_INIT_VAR(transaction);
		object_init_ex(transaction, phalcon_transaction_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "__construct", auto_begin, PH_CHECK);
		
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, "Phalcon\\Transaction\\Manager", 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "settransactionmanager", c0, PH_NO_CHECK);
		PHALCON_OBSERVE_VAR(t2);
		phalcon_read_static_property(&t2, SL("phalcon\\transaction\\manager"), SL("_dependencyPointer") TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "setdependencypointer", t2, PH_NO_CHECK);
		PHALCON_OBSERVE_VAR(t3);
		phalcon_read_static_property(&t3, SL("phalcon\\transaction\\manager"), SL("_dependencyPointer") TSRMLS_CC);
		
		PHALCON_INIT_VAR(t4);
		ZVAL_LONG(t4, 2048);
		
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_add_function(r0, t3, t4 TSRMLS_CC);
		phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_dependencyPointer"), r0 TSRMLS_CC);
		PHALCON_OBSERVE_VAR(t5);
		phalcon_read_static_property(&t5, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
		if (Z_TYPE_P(t5) != IS_ARRAY) {
			convert_to_array(t5);
		}
		phalcon_array_append(&t5, transaction, 0 TSRMLS_CC);
		phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_transactions"), t5 TSRMLS_CC);
		
		PHALCON_OBSERVE_VAR(t6);
		phalcon_read_static_property(&t6, SL("phalcon\\transaction\\manager"), SL("_number") TSRMLS_CC);
		PHALCON_SEPARATE_NMO(t6);
		increment_function(t6);
		phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_number"), t6 TSRMLS_CC);
	} else {
		PHALCON_OBSERVE_VAR(transaction);
		phalcon_read_static_property(&transaction, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
		PHALCON_INIT_VAR(t8);
		ZVAL_LONG(t8, 1);
		PHALCON_ALLOC_ZVAL_MM(r1);
		sub_function(r1, number, t8 TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(t7);
		phalcon_array_fetch(&t7, transaction, r1, PH_NOISY_CC);
		PHALCON_CPY_WRT(transaction, t7);
		
		PHALCON_INIT_VAR(c1);
		ZVAL_BOOL(c1, 0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "setisnewtransaction", c1, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(transaction);
}

/**
 * Rollbacks active transactions within the manager
 *
 */
PHP_METHOD(Phalcon_Transaction_Manager, rollbackPendent){


	PHALCON_MM_GROW();
	PHALCON_CALL_SELF_NORETURN(this_ptr, "rollback");
	
	PHALCON_MM_RESTORE();
}

/**
 * Commmits active transactions within the manager
 *
 */
PHP_METHOD(Phalcon_Transaction_Manager, commit){

	zval *transaction = NULL, *connection = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
	if (phalcon_valid_foreach(t0 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t0);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_ad2c_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_ad2c_0;
		}
		PHALCON_INIT_VAR(transaction);
		ZVAL_ZVAL(transaction, *hd, 1, 0);
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, transaction, "getconnection", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, connection, "isundertransaction", PH_NO_CHECK);
		if (zend_is_true(r0)) {
			PHALCON_CALL_METHOD_NORETURN(connection, "commit", PH_NO_CHECK);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_ad2c_0;
		fee_ad2c_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Rollbacks active transactions within the manager
 * Collect will remove transaction from the manager
 *
 * @param boolean $collect
 */
PHP_METHOD(Phalcon_Transaction_Manager, rollback){

	zval *collect = NULL, *transaction = NULL, *connection = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &collect) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!collect) {
		PHALCON_ALLOC_ZVAL_MM(collect);
		ZVAL_BOOL(collect, 0);
	}
	
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
	if (phalcon_valid_foreach(t0 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t0);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_ad2c_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_ad2c_1;
		}
		PHALCON_INIT_VAR(transaction);
		ZVAL_ZVAL(transaction, *hd, 1, 0);
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, transaction, "getconnection", PH_NO_CHECK);
		
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, connection, "isundertransaction", PH_NO_CHECK);
		if (zend_is_true(r0)) {
			PHALCON_CALL_METHOD_NORETURN(connection, "rollback", PH_NO_CHECK);
			PHALCON_CALL_METHOD_NORETURN(connection, "close", PH_NO_CHECK);
		}
		
		if (zend_is_true(collect)) {
			PHALCON_CALL_SELF_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_ad2c_1;
		fee_ad2c_1:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Notifies the manager about a rollbacked transaction
 *
 * @param Phalcon_Transaction $transaction
 */
PHP_METHOD(Phalcon_Transaction_Manager, notifyRollback){

	zval *transaction = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_SELF_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction);
	
	PHALCON_MM_RESTORE();
}

/**
 * Notifies the manager about a commited transaction
 *
 * @param Phalcon_Transaction $transaction
 */
PHP_METHOD(Phalcon_Transaction_Manager, notifyCommit){

	zval *transaction = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_SELF_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Transaction_Manager, _collectTransaction){

	zval *transaction = NULL, *number = NULL, *managed_transaction = NULL;
	zval *transactions = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, t1, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(number);
		ZVAL_LONG(number, 0);
		PHALCON_OBSERVE_VAR(t2);
		phalcon_read_static_property(&t2, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
		if (phalcon_valid_foreach(t2 TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(t2);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_ad2c_2:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_ad2c_2;
			}
			
			PHALCON_INIT_VAR(managed_transaction);
			ZVAL_ZVAL(managed_transaction, *hd, 1, 0);
			PHALCON_INIT_VAR(r2);
			is_equal_function(r2, managed_transaction, transaction TSRMLS_CC);
			if (zend_is_true(r2)) {
				PHALCON_OBSERVE_VAR(t3);
				phalcon_read_static_property(&t3, SL("phalcon\\transaction\\manager"), SL("_number") TSRMLS_CC);
				PHALCON_SEPARATE_NMO(t3);
				decrement_function(t3);
				phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_number"), t3 TSRMLS_CC);
			}
			PHALCON_SEPARATE(number);
			increment_function(number);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_ad2c_2;
			fee_ad2c_2:
			if(0){}
		} else {
			return;
		}
		
		PHALCON_INIT_VAR(transactions);
		array_init(transactions);
		PHALCON_OBSERVE_VAR(t4);
		phalcon_read_static_property(&t4, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
		if (phalcon_valid_foreach(t4 TSRMLS_CC)) {
			ah1 = Z_ARRVAL_P(t4);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
			fes_ad2c_3:
			if(zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS){
				goto fee_ad2c_3;
			}
			
			PHALCON_INIT_VAR(managed_transaction);
			ZVAL_ZVAL(managed_transaction, *hd, 1, 0);
			phalcon_array_append(&transactions, managed_transaction, PH_SEPARATE TSRMLS_CC);
			zend_hash_move_forward_ex(ah1, &hp1);
			goto fes_ad2c_3;
			fee_ad2c_3:
			if(0){}
		} else {
			return;
		}
		phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_transactions"), transactions TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Remove all the transactions from the manager
 *
 */
PHP_METHOD(Phalcon_Transaction_Manager, collectTransactions){

	zval *number = NULL, *managed_transaction = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	phalcon_fast_count(r0, t0 TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 0);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_smaller_function(r1, t1, r0 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(number);
		ZVAL_LONG(number, 0);
		PHALCON_OBSERVE_VAR(t2);
		phalcon_read_static_property(&t2, SL("phalcon\\transaction\\manager"), SL("_transactions") TSRMLS_CC);
		if (phalcon_valid_foreach(t2 TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(t2);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_ad2c_4:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_ad2c_4;
			}
			
			PHALCON_INIT_VAR(managed_transaction);
			ZVAL_ZVAL(managed_transaction, *hd, 1, 0);
			PHALCON_OBSERVE_VAR(t3);
			phalcon_read_static_property(&t3, SL("phalcon\\transaction\\manager"), SL("_number") TSRMLS_CC);
			PHALCON_SEPARATE_NMO(t3);
			decrement_function(t3);
			phalcon_update_static_property(SL("phalcon\\transaction\\manager"), SL("_number"), t3 TSRMLS_CC);
			PHALCON_SEPARATE(number);
			increment_function(number);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_ad2c_4;
			fee_ad2c_4:
			if(0){}
		} else {
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks whether manager will inject an automatic transaction to all newly
 * created instances of Phalcon_Model_base
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction_Manager, isAutomatic){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_automaticTransaction") TSRMLS_CC);
	PHALCON_INIT_VAR(t1);
	ZVAL_NULL(t1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_not_equal_function(r0, t0, t1 TSRMLS_CC);
	
	RETURN_NCTOR(r0);
}

/**
 * Returns automatic transaction for instances of Phalcon_Model_base
 *
 * @return Phalcon_Transaction
 */
PHP_METHOD(Phalcon_Transaction_Manager, getAutomatic){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\transaction\\manager"), SL("_automaticTransaction") TSRMLS_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \transaction\manager.c ------ */

/* ------ Starting File: \controller\front.c ------ */
/**
 * Phalcon_Controller_Front
 *
 * Phalcon_Controller_Front implements a "Front Controller" pattern used in "Model-View-Controller" (MVC) applications.
 * Its purpose is to initialize the request environment, route the incoming request, and then dispatch
 * any discovered actions; it aggregates any responses and returns them when the process is complete
 *
 *
 */

/**
 * Private Phalcon_Controller_Front constructor for singleton
 */
PHP_METHOD(Phalcon_Controller_Front, __construct){


	PHALCON_MM_GROW();
	
	PHALCON_MM_RESTORE();
}

/**
 * Modifies multiple general settings using a Phalcon_Config object or a stdClass filled with parameters
 *
 * @param stdClass $config
 */
PHP_METHOD(Phalcon_Controller_Front, setConfig){

	zval *config = NULL, *phalcon = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(config) == IS_OBJECT) {
		eval_int = phalcon_isset_property(config, SL("database") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t0);
			phalcon_read_property(&t0, config, SL("database"), PH_NOISY_CC);
			PHALCON_CALL_STATIC_PARAMS_1_NORETURN("phalcon\\db\\pool", "setdefaultdescriptor", t0);
		}
		eval_int = phalcon_isset_property(config, SL("phalcon") TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_VAR(phalcon);
			phalcon_read_property(&phalcon, config, SL("phalcon"), PH_NOISY_CC);
			eval_int = phalcon_isset_property(phalcon, SL("controllersDir") TSRMLS_CC);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(t1);
				phalcon_read_property(&t1, phalcon, SL("controllersDir"), PH_NOISY_CC);
				phalcon_update_property_zval(this_ptr, SL("_controllersDir"), t1 TSRMLS_CC);
			}
			
			eval_int = phalcon_isset_property(phalcon, SL("modelsDir") TSRMLS_CC);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(t2);
				phalcon_read_property(&t2, phalcon, SL("modelsDir"), PH_NOISY_CC);
				phalcon_update_property_zval(this_ptr, SL("_modelsDir"), t2 TSRMLS_CC);
			}
			
			eval_int = phalcon_isset_property(phalcon, SL("viewsDir") TSRMLS_CC);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(t3);
				phalcon_read_property(&t3, phalcon, SL("viewsDir"), PH_NOISY_CC);
				phalcon_update_property_zval(this_ptr, SL("_viewsDir"), t3 TSRMLS_CC);
			}
			
			eval_int = phalcon_isset_property(phalcon, SL("baseUri") TSRMLS_CC);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(t4);
				phalcon_read_property(&t4, phalcon, SL("baseUri"), PH_NOISY_CC);
				phalcon_update_property_zval(this_ptr, SL("_baseUri"), t4 TSRMLS_CC);
			}
			
			eval_int = phalcon_isset_property(phalcon, SL("basePath") TSRMLS_CC);
			if (eval_int) {
				PHALCON_ALLOC_ZVAL_MM(t5);
				phalcon_read_property(&t5, phalcon, SL("basePath"), PH_NOISY_CC);
				phalcon_update_property_zval(this_ptr, SL("_basePath"), t5 TSRMLS_CC);
			}
		}
		
		eval_int = phalcon_isset_property(config, SL("models") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t6);
			phalcon_read_property(&t6, config, SL("models"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_modelsConfig"), t6 TSRMLS_CC);
		}
		
		eval_int = phalcon_isset_property(config, SL("views") TSRMLS_CC);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t7);
			phalcon_read_property(&t7, config, SL("views"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_viewsConfig"), t7 TSRMLS_CC);
		}
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_exception_ce, "Config parameter should be an object");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets the database default settings
 *
 * @param stdClass $database
 */
PHP_METHOD(Phalcon_Controller_Front, setDatabaseConfig){

	zval *database = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &database) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_STATIC_PARAMS_1_NORETURN("phalcon\\db\\pool", "setdefaultdescriptor", database);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets controllers directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $controllersDir
 */
PHP_METHOD(Phalcon_Controller_Front, setControllersDir){

	zval *controllers_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controllers_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_controllersDir"), controllers_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets models directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $modelsDir
 */
PHP_METHOD(Phalcon_Controller_Front, setModelsDir){

	zval *models_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &models_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_modelsDir"), models_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets views directory. Depending of your platform, always add a trailing slash or backslash
 *
 * @param string $viewsDir
 */
PHP_METHOD(Phalcon_Controller_Front, setViewsDir){

	zval *views_dir = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &views_dir) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_viewsDir"), views_dir TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Replaces the default router with a predefined object
 *
 * @param Phalcon_Router $router
 */
PHP_METHOD(Phalcon_Controller_Front, setRouter){

	zval *router = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &router) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_router"), router TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Return active router
 *
 * @return Phalcon_Router
 */
PHP_METHOD(Phalcon_Controller_Front, getRouter){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_router"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Replaces the default dispatcher with a predefined object
 *
 * @param Phalcon_Dispatcher $dispatcher
 */
PHP_METHOD(Phalcon_Controller_Front, setDispatcher){

	zval *dispatcher = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dispatcher) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dispatcher"), dispatcher TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Return active Dispatcher
 *
 * @return Phalcon_Dispatcher
 */
PHP_METHOD(Phalcon_Controller_Front, getDispatcher){

	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dispatcher"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_dispatcher"), PH_NOISY_CC);
		
		RETURN_CCTOR(t1);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_exception_ce, "Dispatch process has not started yet");
	return;
}

/**
 * Sets external uri which app is executed
 *
 * @param string $baseUri
 */
PHP_METHOD(Phalcon_Controller_Front, setBaseUri){

	zval *base_uri = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_baseUri"), base_uri TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets external uri where app is executed
 *
 * @return string
 */
PHP_METHOD(Phalcon_Controller_Front, getBaseUri){

	zval *base_uri = NULL, *slash = NULL, *uri = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *c0 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(base_uri);
	phalcon_read_property(&base_uri, this_ptr, SL("_baseUri"), PH_NOISY_CC);
	if (!zend_is_true(base_uri)) {
		PHALCON_INIT_VAR(slash);
		ZVAL_STRING(slash, "/", 1);
		phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
		eval_int = phalcon_array_isset_string(g0, SL("PHP_SELF")+1);
		if (eval_int) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_array_fetch_string(&r0, g0, SL("PHP_SELF"), PH_NOISY_CC);
			PHALCON_ALLOC_ZVAL_MM(r1);
			PHALCON_CALL_FUNC_PARAMS_1(r1, "dirname", r0);
			PHALCON_ALLOC_ZVAL_MM(r2);
			phalcon_fast_explode(r2, slash, r1 TSRMLS_CC);
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, 1);
			PHALCON_INIT_VAR(t1);
			ZVAL_LONG(t1, 1);
			PHALCON_INIT_VAR(t0);
			ZVAL_LONG(t0, -1);
			PHALCON_ALLOC_ZVAL_MM(r3);
			mul_function(r3, t0, t1 TSRMLS_CC);
			PHALCON_ALLOC_ZVAL_MM(r4);
			PHALCON_CALL_FUNC_PARAMS_3(r4, "array_slice", r2, c0, r3);
			PHALCON_INIT_VAR(uri);
			phalcon_fast_join(uri, slash, r4 TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(uri);
			ZVAL_STRING(uri, "", 1);
		}
		
		if (!zend_is_true(uri)) {
			PHALCON_CPY_WRT(base_uri, slash);
		} else {
			PHALCON_INIT_VAR(base_uri);
			PHALCON_CONCAT_VVV(base_uri, slash, uri, slash);
		}
		
		phalcon_update_property_zval(this_ptr, SL("_baseUri"), base_uri TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(base_uri);
}

/**
 * Sets local path where app/ directory is located. Depending of your platform, always add a trailing slash or backslash
 *
  * @param string $basePath
 */
PHP_METHOD(Phalcon_Controller_Front, setBasePath){

	zval *base_path = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets local path where app/ directory is located
 *
 * @return string
 */
PHP_METHOD(Phalcon_Controller_Front, getBasePath){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Overwrites request object default object
 *
 * @param Phalcon_Request $request
 */
PHP_METHOD(Phalcon_Controller_Front, setRequest){

	zval *request = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &request) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_request"), request TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Overwrites response object default object
  *
 * @param Phalcon_Response $response
 */
PHP_METHOD(Phalcon_Controller_Front, setResponse){

	zval *response = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &response) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_response"), response TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Overwrites models manager default object
 *
 * @param Phalcon_Model_Manager $model
 */
PHP_METHOD(Phalcon_Controller_Front, setModelComponent){

	zval *model = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the models manager
 *
 * @return Phalcon_Model_Manager
 */
PHP_METHOD(Phalcon_Controller_Front, getModelComponent){

	zval *model = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(model);
	phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	if (!zend_is_true(model)) {
		PHALCON_INIT_VAR(model);
		object_init_ex(model, phalcon_model_manager_ce);
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_modelsConfig"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "__construct", t0, PH_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_modelsDir"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setmodelsdir", t1, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(model);
}

/**
 * Sets view component
 *
 * @param Phalcon_View $view
 */
PHP_METHOD(Phalcon_Controller_Front, setViewComponent){

	zval *view = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &view) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_view"), view TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets the views part manager
 *
 * @return Phalcon_View
 */
PHP_METHOD(Phalcon_Controller_Front, getViewComponent){

	zval *view = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(view);
	phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
	if (!zend_is_true(view)) {
		PHALCON_INIT_VAR(view);
		object_init_ex(view, phalcon_view_ce);
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_viewsConfig"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(view, "__construct", t0, PH_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_viewsDir"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(view, "setviewsdir", t1, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_view"), view TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(view);
}

/**
 * Executes the dispatch loop
 *
 * @return Phalcon_View
 */
PHP_METHOD(Phalcon_Controller_Front, dispatchLoop){

	zval *dispatcher = NULL, *router = NULL, *base_path = NULL, *view = NULL, *model = NULL;
	zval *response = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dispatcher"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_INIT_VAR(dispatcher);
		object_init_ex(dispatcher, phalcon_dispatcher_ce);
		PHALCON_CALL_METHOD_NORETURN(dispatcher, "__construct", PH_CHECK);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_controllersDir"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setcontrollersdir", t1, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(dispatcher);
		phalcon_read_property(&dispatcher, this_ptr, SL("_dispatcher"), PH_NOISY_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t2);
	phalcon_read_property(&t2, this_ptr, SL("_request"), PH_NOISY_CC);
	if (!zend_is_true(t2)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_STATIC(r0, "phalcon\\request", "getinstance");
		phalcon_update_property_zval(this_ptr, SL("_request"), r0 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t3);
	phalcon_read_property(&t3, this_ptr, SL("_response"), PH_NOISY_CC);
	if (!zend_is_true(t3)) {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_STATIC(r1, "phalcon\\response", "getinstance");
		phalcon_update_property_zval(this_ptr, SL("_response"), r1 TSRMLS_CC);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t4);
	phalcon_read_property(&t4, this_ptr, SL("_router"), PH_NOISY_CC);
	if (!zend_is_true(t4)) {
		PHALCON_INIT_VAR(router);
		object_init_ex(router, phalcon_router_rewrite_ce);
		PHALCON_CALL_METHOD_NORETURN(router, "__construct", PH_CHECK);
		PHALCON_CALL_METHOD_NORETURN(router, "handle", PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(router);
		phalcon_read_property(&router, this_ptr, SL("_router"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(base_path);
	phalcon_read_property(&base_path, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(view);
	PHALCON_CALL_METHOD(view, this_ptr, "getviewcomponent", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(view, "setbasepath", base_path, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(view, "start", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD(model, this_ptr, "getmodelcomponent", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setbasepath", base_path, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setbasepath", base_path, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD(r2, router, "getcontrollername", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setcontrollername", r2, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	PHALCON_CALL_METHOD(r3, router, "getactionname", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setactionname", r3, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	PHALCON_CALL_METHOD(r4, router, "getparams", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setparams", r4, PH_NO_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_dispatcher"), dispatcher TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_router"), router TSRMLS_CC);
	
	PHALCON_INIT_VAR(response);
	phalcon_read_property(&response, this_ptr, SL("_response"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t5);
	phalcon_read_property(&t5, this_ptr, SL("_request"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_4_NORETURN(dispatcher, "dispatch", t5, response, view, model, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r5);
	PHALCON_CALL_METHOD(r5, dispatcher, "getcontrollername", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r6);
	PHALCON_CALL_METHOD(r6, dispatcher, "getactionname", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r7);
	PHALCON_CALL_METHOD(r7, dispatcher, "getparams", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(view, "render", r5, r6, r7, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(view, "finish", PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r8);
	PHALCON_CALL_METHOD(r8, view, "getcontent", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(response, "setcontent", r8, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(response, "sendheaders", PH_NO_CHECK);
	
	RETURN_CCTOR(response);
}

/**
 * Gets Phalcon_Controller_Front singleton instance
 *
 * @return Phalcon_Controller_Front
 */
PHP_METHOD(Phalcon_Controller_Front, getInstance){

	zval *instance = NULL;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(instance);
	phalcon_read_static_property(&instance, SL("phalcon\\controller\\front"), SL("_instance") TSRMLS_CC);
	if (!zend_is_true(instance)) {
		PHALCON_INIT_VAR(instance);
		object_init_ex(instance, phalcon_controller_front_ce);
		PHALCON_CALL_METHOD_NORETURN(instance, "__construct", PH_CHECK);
		phalcon_update_static_property(SL("phalcon\\controller\\front"), SL("_instance"), instance TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(instance);
}

/**
 * Resets the internal singleton
 */
PHP_METHOD(Phalcon_Controller_Front, reset){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(t0);
	ZVAL_NULL(t0);
	phalcon_update_static_property(SL("phalcon\\controller\\front"), SL("_instance"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \controller\front.c ------ */

/* ------ Starting File: \session.c ------ */
/**
 * Phalcon\Session
 *
 * Session client-server persistent state data management. This component
 * allows you to separate your session data between application or modules.
 * With this, it's possible to use the same index to refer a variable
 * but they can be in different applications.
 *
 * 
 */

/**
 * Starts session, optionally using an adapter
 *
 * @param array $options
 */
PHP_METHOD(Phalcon_Session, start){

	zval *options = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC(r0, "session_start");
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets session options
 *
 * @param array $options
 */
PHP_METHOD(Phalcon_Session, setOptions){

	zval *options = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(options, SL("uniqueId")+1);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch_string(&r0, options, SL("uniqueId"), PH_NOISY_CC);
		phalcon_update_static_property(SL("phalcon\\session"), SL("_uniqueId"), r0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Gets a session variable from an application context
 *
 * @param string $index
 */
PHP_METHOD(Phalcon_Session, get){

	zval *index = NULL, *key = NULL;
	zval *t0 = NULL;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\session"), SL("_uniqueId") TSRMLS_CC);
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, t0, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, key);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		phalcon_array_fetch(&r0, g0, key, PH_NOISY_CC);
		
		RETURN_CCTOR(r0);
	} else {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets a session variable in an application context
 *
 * @param string $index
 * @param string $value
 */
PHP_METHOD(Phalcon_Session, set){

	zval *index = NULL, *value = NULL;
	zval *g0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\session"), SL("_uniqueId") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CONCAT_VV(r0, t0, index);
	phalcon_array_update(&g0, r0, &value, PH_COPY TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether a session variable is set in an application context
 *
 * @param string $index
 */
PHP_METHOD(Phalcon_Session, has){

	zval *index = NULL, *key = NULL;
	zval *t0 = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\session"), SL("_uniqueId") TSRMLS_CC);
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, t0, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, key);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Removes a session variable from an application context
 *
 * @param string $index
 */
PHP_METHOD(Phalcon_Session, remove){

	zval *index = NULL, *key = NULL;
	zval *t0 = NULL;
	zval *g0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\session"), SL("_uniqueId") TSRMLS_CC);
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, t0, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	phalcon_array_unset(g0, key);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns active session id
 *
 * @return string
 */
PHP_METHOD(Phalcon_Session, getId){

	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC(r0, "session_id");
	RETURN_CTOR(r0);
}

/* ------ Finished File: \session.c ------ */

/* ------ Starting File: \flash.c ------ */
/**
 * Phalcon\Flash
 *
 * Shows HTML notifications related to different circumstances. Classes can be stylized using CSS
 *
 *
 */

PHP_METHOD(Phalcon_Flash, _showMessage){

	zval *message = NULL, *classes = NULL, *css_classes = NULL, *eol = NULL, *msg = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &message, &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(classes) == IS_ARRAY) { 
		PHALCON_INIT_VAR(c0);
		ZVAL_STRING(c0, " ", 1);
		PHALCON_INIT_VAR(css_classes);
		phalcon_fast_join(css_classes, c0, classes TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(css_classes, classes);
	}
	
	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	if (Z_TYPE_P(message) == IS_ARRAY) { 
		if (phalcon_valid_foreach(message TSRMLS_CC)) {
			ah0 = Z_ARRVAL_P(message);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
			fes_3b3c_0:
			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto fee_3b3c_0;
			}
			PHALCON_INIT_VAR(msg);
			ZVAL_ZVAL(msg, *hd, 1, 0);
			PHALCON_INIT_VAR(r0);
			PHALCON_CONCAT_SVSVSV(r0, "<div class=\"", css_classes, "\">", msg, "</div>", eol);
			zend_print_zval(r0, 1);
			zend_hash_move_forward_ex(ah0, &hp0);
			goto fes_3b3c_0;
			fee_3b3c_0:
			if(0){}
		} else {
			return;
		}
	} else {
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVSVSV(r1, "<div class=\"", css_classes, "\">", message, "</div>", eol);
		zend_print_zval(r1, 1);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Shows a HTML error message
 *
 * @param string $message
 * @param string $classes
 * @return string
 */
PHP_METHOD(Phalcon_Flash, error){

	zval *message = NULL, *classes = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!classes) {
		PHALCON_ALLOC_ZVAL_MM(classes);
		ZVAL_STRING(classes, "errorMessage", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_showmessage", message, classes);
	RETURN_CTOR(r0);
}

/**
 * Shows a HTML notice/information message
 *
 * @param string $message
 * @param string $classes
 * @return string
 */
PHP_METHOD(Phalcon_Flash, notice){

	zval *message = NULL, *classes = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!classes) {
		PHALCON_ALLOC_ZVAL_MM(classes);
		ZVAL_STRING(classes, "noticeMessage", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_showmessage", message, classes);
	RETURN_CTOR(r0);
}

/**
 * Shows a HTML success message
 *
 * @param string $message
 * @param string $classes
 * @return string
 */
PHP_METHOD(Phalcon_Flash, success){

	zval *message = NULL, *classes = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!classes) {
		PHALCON_ALLOC_ZVAL_MM(classes);
		ZVAL_STRING(classes, "successMessage", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_showmessage", message, classes);
	RETURN_CTOR(r0);
}

/**
 * Shows a HTML warning message
 *
 * @param string $message
 * @param string $classes
 * @return string
 */
PHP_METHOD(Phalcon_Flash, warning){

	zval *message = NULL, *classes = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!classes) {
		PHALCON_ALLOC_ZVAL_MM(classes);
		ZVAL_STRING(classes, "warningMessage", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_SELF_PARAMS_2(r0, this_ptr, "_showmessage", message, classes);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \flash.c ------ */

/* ------ Starting File: \config.c ------ */
/**
 * Phalcon\Config
 *
 * Phalcon\Config is designed to simplify the access to, and the use of, configuration data within applications.
 * It provides a nested object property based user interface for accessing this configuration data within
 * application code.
 *
 * 
 *
 */

/**
 * Phalcon\Config constructor
 *
 * @param array $arrayConfig
 * @return Phalcon\Config
 */
PHP_METHOD(Phalcon_Config, __construct){

	zval *array_config = NULL, *value = NULL, *key = NULL;
	zval *a0 = NULL;
	zval *i0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &array_config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!array_config) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(array_config, a0);
	}
	
	if (phalcon_valid_foreach(array_config TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(array_config);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_9656_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_9656_0;
		} else {
			PHALCON_INIT_VAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		}
		PHALCON_INIT_VAR(value);
		ZVAL_ZVAL(value, *hd, 1, 0);
		if (Z_TYPE_P(value) == IS_ARRAY) { 
			PHALCON_INIT_VAR(i0);
			object_init_ex(i0, phalcon_config_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", value, PH_CHECK);
			phalcon_update_property_zval_zval(this_ptr, key, i0 TSRMLS_CC);
		} else {
			phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_9656_0;
		fee_9656_0:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \config.c ------ */

/* ------ Starting File: \filter.c ------ */
/**
 * Phalcon\Filter
 *
 * The Phalcon_Filter component provides a set of commonly needed data filters. It provides
 * object oriented wrappers to the php filter extension
 *
 *
 *
 */

/**
 * Sanizites a value with a specified single or set of filters
 *
 * @param  mixed $value
 * @param  mixed $filters
 * @param  boolean $silent
 * @return mixed
 */
PHP_METHOD(Phalcon_Filter, sanitize){

	zval *value = NULL, *filters = NULL, *silent = NULL, *new_value = NULL, *filter = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &value, &filters, &silent) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!silent) {
		PHALCON_ALLOC_ZVAL_MM(silent);
		ZVAL_BOOL(silent, 0);
	}
	
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		PHALCON_CPY_WRT(new_value, value);
		if (Z_TYPE_P(value) != IS_NULL) {
			if (phalcon_valid_foreach(filters TSRMLS_CC)) {
				ah0 = Z_ARRVAL_P(filters);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
				fes_e618_0:
				if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
					goto fee_e618_0;
				}
				PHALCON_INIT_VAR(filter);
				ZVAL_ZVAL(filter, *hd, 1, 0);
				PHALCON_INIT_VAR(r0);
				PHALCON_CALL_METHOD_PARAMS_3(r0, this_ptr, "_sanitize", new_value, filter, silent, PH_NO_CHECK);
				PHALCON_CPY_WRT(new_value, r0);
				zend_hash_move_forward_ex(ah0, &hp0);
				goto fes_e618_0;
				fee_e618_0:
				if(0){}
			} else {
				return;
			}
		}
		
		
		RETURN_CCTOR(new_value);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	PHALCON_CALL_METHOD_PARAMS_3(r1, this_ptr, "_sanitize", value, filters, silent, PH_NO_CHECK);
	RETURN_CTOR(r1);
}

/**
 * Internal sanizite wrapper to filter_var
 *
 * @param  mixed $value
 * @param  string $filter
 * @param  boolean $silent
 * @return mixed
 */
PHP_METHOD(Phalcon_Filter, _sanitize){

	zval *value = NULL, *filter = NULL, *silent = NULL, *filtered = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL, *t10 = NULL, *t11 = NULL;
	zval *a0 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &value, &filter, &silent) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!silent) {
		PHALCON_ALLOC_ZVAL_MM(silent);
		ZVAL_BOOL(silent, 0);
	}
	
	PHALCON_INIT_VAR(t0);
	ZVAL_STRING(t0, "email", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, filter, t0 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 517);
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", value, t1);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t2);
	ZVAL_STRING(t2, "int", 1);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, filter, t2 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 519);
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", value, t3);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t4);
	ZVAL_STRING(t4, "string", 1);
	PHALCON_ALLOC_ZVAL_MM(r2);
	is_equal_function(r2, filter, t4 TSRMLS_CC);
	if (zend_is_true(r2)) {
		PHALCON_INIT_VAR(t5);
		ZVAL_LONG(t5, 513);
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", value, t5);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t6);
	ZVAL_STRING(t6, "float", 1);
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_equal_function(r3, filter, t6 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(t7);
		ZVAL_LONG(t7, 520);
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_INIT_VAR(t8);
		ZVAL_LONG(t8, 4096);
		phalcon_array_update_string(&a0, SL("flags"), &t8, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_3(filtered, "filter_var", value, t7, a0);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t9);
	ZVAL_STRING(t9, "alphanum", 1);
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_equal_function(r4, filter, t9 TSRMLS_CC);
	if (zend_is_true(r4)) {
		PHALCON_INIT_VAR(filtered);
		phalcon_filter_alphanum(filtered, value);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t10);
	ZVAL_STRING(t10, "extraspaces", 1);
	PHALCON_ALLOC_ZVAL_MM(r5);
	is_equal_function(r5, filter, t10 TSRMLS_CC);
	if (zend_is_true(r5)) {
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_1(filtered, "trim", value);
		goto se_e618_1;
	}
	PHALCON_INIT_VAR(t11);
	ZVAL_STRING(t11, "striptags", 1);
	PHALCON_ALLOC_ZVAL_MM(r6);
	is_equal_function(r6, filter, t11 TSRMLS_CC);
	if (zend_is_true(r6)) {
		PHALCON_INIT_VAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_1(filtered, "strip_tags", value);
		goto se_e618_1;
	}
	if (!zend_is_true(silent)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r7);
		PHALCON_CONCAT_SVS(r7, "Sanitize filter ", filter, " is not supported");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r7, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	} else {
		PHALCON_CPY_WRT(filtered, value);
	}
	se_e618_1:
	
	RETURN_CCTOR(filtered);
}

/* ------ Finished File: \filter.c ------ */

/* ------ Starting File: \acl.c ------ */
/**
 * Phalcon\Acl
 *
 * This component allows to manage ACL lists. An access control list (ACL) is a list
 * of permissions attached to an object. An ACL specifies which users or system processes
 * are granted access to objects, as well as what operations are allowed on given objects.
 *
 *
 */

/**
 * Phalcon_Acl Constructor
 *
 * @param string $adapterName
 * @param array $options
 */
PHP_METHOD(Phalcon_Acl, __construct){

	zval *adapter_name = NULL, *options = NULL, *adapter_class = NULL;
	zval *a0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *i0 = NULL, *i1 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &adapter_name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!adapter_name) {
		PHALCON_ALLOC_ZVAL_MM(adapter_name);
		ZVAL_STRING(adapter_name, "Memory", 1);
	}
	
	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(options, a0);
	}
	
	PHALCON_INIT_VAR(adapter_class);
	PHALCON_CONCAT_SV(adapter_class, "Phalcon\\Acl\\Adapter\\", adapter_name);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "class_exists", adapter_class);
	if (!zend_is_true(r0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_acl_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Adapter '", adapter_name, "' does not exist");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	ce0 = phalcon_fetch_class(adapter_class TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(i1);
	object_init_ex(i1, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i1, "__construct", options, PH_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_adapter"), i1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Pass any call to the internal adapter object
 *
 * @param  string $method
 * @param  array $arguments
 * @return mixed
 */
PHP_METHOD(Phalcon_Acl, __call){

	zval *method = NULL, *arguments = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		PHALCON_CPY_WRT(arguments, a0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_adapter"), PH_NOISY_CC);
	phalcon_array_append(&a1, t0, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&a1, method, PH_SEPARATE TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "call_user_func_array", a1, arguments);
	RETURN_CTOR(r0);
}

/* ------ Finished File: \acl.c ------ */

/* ------ Starting File: \translate\exception.c ------ */
/**
 * Phalcon_Translate_Exception
 *
 * Class for exceptions thrown by Phalcon_Translate
 */

/* ------ Finished File: \translate\exception.c ------ */

/* ------ Starting File: \translate\adapter\array.c ------ */
/**
 * Phalcon\Translate\Adapter\Array
 *
 * Allows to define translation lists using PHP arrays
 *
 */

/**
 * Phalcon\Translate\Adapter\Array constructor
 *
 * @param array $data
 */
PHP_METHOD(Phalcon_Translate_Adapter_Array, __construct){

	zval *options = NULL, *data = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(options, SL("content")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(data);
		phalcon_array_fetch_string(&data, options, SL("content"), PH_NOISY_CC);
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translation data must be an array");
			return;
		}
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translation content was not provided");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_traslate"), data TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the translation related to the given key
 *
 * @param string $index
 * @param array $placeholders
 * @return string
 */
PHP_METHOD(Phalcon_Translate_Adapter_Array, query){

	zval *index = NULL, *placeholders = NULL, *translation = NULL, *value = NULL;
	zval *key = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_traslate"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, index);
	if (eval_int) {
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_traslate"), PH_NOISY_CC);
		PHALCON_INIT_VAR(translation);
		phalcon_array_fetch(&translation, t1, index, PH_NOISY_CC);
		if (zend_is_true(placeholders)) {
			PHALCON_ALLOC_ZVAL_MM(r0);
			phalcon_fast_count(r0, placeholders TSRMLS_CC);
			if (zend_is_true(r0)) {
				if (phalcon_valid_foreach(placeholders TSRMLS_CC)) {
					ah0 = Z_ARRVAL_P(placeholders);
					zend_hash_internal_pointer_reset_ex(ah0, &hp0);
					fes_2f22_0:
					if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
						goto fee_2f22_0;
					} else {
						PHALCON_INIT_VAR(key);
						PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
					}
					PHALCON_INIT_VAR(value);
					ZVAL_ZVAL(value, *hd, 1, 0);
					PHALCON_INIT_VAR(r1);
					PHALCON_CONCAT_SVS(r1, "%", key, "%");
					PHALCON_INIT_VAR(r2);
					phalcon_fast_str_replace(r2, r1, value, translation TSRMLS_CC);
					PHALCON_CPY_WRT(translation, r2);
					zend_hash_move_forward_ex(ah0, &hp0);
					goto fes_2f22_0;
					fee_2f22_0:
					if(0){}
				} else {
					return;
				}
			}
		}
		
		
		RETURN_CCTOR(translation);
	} else {
		
		RETURN_CCTOR(index);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Check whether is defined a translation key in the internal array
 *
 * @param string $index
 * @return string
 */
PHP_METHOD(Phalcon_Translate_Adapter_Array, exists){

	zval *index = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_traslate"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, index);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

/* ------ Finished File: \translate\adapter\array.c ------ */

/* ------ Starting File: \logger\exception.c ------ */
/**
 * Phalcon_Logger_Exception
 *
 * Exceptions thrown in Phalcon_Logger will use this class
 *
 */

/* ------ Finished File: \logger\exception.c ------ */

/* ------ Starting File: \logger\adapter\file.c ------ */
/**
 * Phalcon_Logger_Adapter_File
 *
 * Adapter to store logs in plain text files
 *
 *
 */

/**
 * Phalcon_Logger_Adapter_File constructor
 *
 * @param string $name
 * @param array $options
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, __construct){

	zval *name = NULL, *options = NULL, *mode = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	zval *t0 = NULL;
	zval *i0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_logger_adapter_file_ce, this_ptr, SL("_quenue"), a0 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		PHALCON_CPY_WRT(options, a1);
	}
	
	eval_int = phalcon_array_isset_string(options, SL("mode")+1);
	if (eval_int) {
		PHALCON_INIT_VAR(mode);
		phalcon_array_fetch_string(&mode, options, SL("mode"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "fopen", name, mode);
	phalcon_update_property_zval(this_ptr, SL("_fileHandler"), r0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_logger_exception_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CONCAT_SVS(r1, "Can't open log file at '", name, "'");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Set the log format
 *
 * @param string $format
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, setFormat){

	zval *format = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &format) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_format"), format TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the log format
 *
 * @param string $format
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, getFormat){

	zval *format = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &format) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_format"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the string meaning of a logger constant
 *
 * @param  integer $type
 * @return string
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, getTypeString){

	zval *type = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(type);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 7);
	PHALCON_ALLOC_ZVAL_MM(r0);
	is_equal_function(r0, type, t0 TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "DEBUG", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 3);
	PHALCON_ALLOC_ZVAL_MM(r1);
	is_equal_function(r1, type, t1 TSRMLS_CC);
	if (zend_is_true(r1)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "ERROR", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 4);
	PHALCON_ALLOC_ZVAL_MM(r2);
	is_equal_function(r2, type, t2 TSRMLS_CC);
	if (zend_is_true(r2)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "WARNING", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t3);
	ZVAL_LONG(t3, 1);
	PHALCON_ALLOC_ZVAL_MM(r3);
	is_equal_function(r3, type, t3 TSRMLS_CC);
	if (zend_is_true(r3)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "CRITICAL", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t4);
	ZVAL_LONG(t4, 8);
	PHALCON_ALLOC_ZVAL_MM(r4);
	is_equal_function(r4, type, t4 TSRMLS_CC);
	if (zend_is_true(r4)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "CUSTOM", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t5);
	ZVAL_LONG(t5, 2);
	PHALCON_ALLOC_ZVAL_MM(r5);
	is_equal_function(r5, type, t5 TSRMLS_CC);
	if (zend_is_true(r5)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "ALERT", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t6);
	ZVAL_LONG(t6, 5);
	PHALCON_ALLOC_ZVAL_MM(r6);
	is_equal_function(r6, type, t6 TSRMLS_CC);
	if (zend_is_true(r6)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "NOTICE", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t7);
	ZVAL_LONG(t7, 6);
	PHALCON_ALLOC_ZVAL_MM(r7);
	is_equal_function(r7, type, t7 TSRMLS_CC);
	if (zend_is_true(r7)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "INFO", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t8);
	ZVAL_LONG(t8, 0);
	PHALCON_ALLOC_ZVAL_MM(r8);
	is_equal_function(r8, type, t8 TSRMLS_CC);
	if (zend_is_true(r8)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "EMERGENCE", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(t9);
	ZVAL_LONG(t9, 9);
	PHALCON_ALLOC_ZVAL_MM(r9);
	is_equal_function(r9, type, t9 TSRMLS_CC);
	if (zend_is_true(r9)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "SPECIAL", 1);
		goto se_654f_0;
	}
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "CUSTOM", 1);
	se_654f_0:
	
	RETURN_CCTOR(type);
}

/**
 * Applies the internal format to the message
 *
 * @param  string $message
 * @param  int $type
 * @param  int $time
 * @return string
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, _applyFormat){

	zval *message = NULL, *type = NULL, *time = NULL, *format = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &message, &type, &time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!time) {
		PHALCON_ALLOC_ZVAL_MM(time);
		ZVAL_LONG(time, 0);
	} else {
		PHALCON_SEPARATE_PARAM(time);
	}
	
	if (!zend_is_true(time)) {
		PHALCON_INIT_VAR(time);
		PHALCON_CALL_FUNC(time, "time");
	}
	
	PHALCON_INIT_VAR(format);
	phalcon_read_property(&format, this_ptr, SL("_format"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "%date%", 1);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dateFormat"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "date", t0, time);
	
	PHALCON_ALLOC_ZVAL_MM(r1);
	phalcon_fast_str_replace(r1, c0, r0, format TSRMLS_CC);
	PHALCON_CPY_WRT(format, r1);
	
	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "%type%", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r2);
	PHALCON_CALL_METHOD_PARAMS_1(r2, this_ptr, "gettypestring", type, PH_NO_CHECK);
	
	PHALCON_ALLOC_ZVAL_MM(r3);
	phalcon_fast_str_replace(r3, c1, r2, format TSRMLS_CC);
	PHALCON_CPY_WRT(format, r3);
	
	PHALCON_INIT_VAR(c2);
	ZVAL_STRING(c2, "%message%", 1);
	
	PHALCON_ALLOC_ZVAL_MM(r4);
	phalcon_fast_str_replace(r4, c2, message, format TSRMLS_CC);
	PHALCON_CPY_WRT(format, r4);
	
	RETURN_CCTOR(format);
}

/**
 * Sets the internal date format
 *
 * @param string $date
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, setDateFormat){

	zval *date = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &date) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dateFormat"), date TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the internal date format
 *
 * @return string
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, getDateFormat){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dateFormat"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Sends/Writes messages to the file log
 *
 * @param string $message
 * @param int $type
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, log){

	zval *message = NULL, *type = NULL, *msg = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;
	zval *c0 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &message, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "Cannot send message to the log because it is invalid");
		return;
	}
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_scalar", message);
	if (zend_is_true(r0)) {
		PHALCON_INIT_VAR(c0);
		ZVAL_BOOL(c0, 1);
		PHALCON_INIT_VAR(msg);
		PHALCON_CALL_FUNC_PARAMS_2(msg, "print_r", message, c0);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (zend_is_true(t1)) {
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_logger_item_ce);
		PHALCON_ALLOC_ZVAL_MM(r1);
		PHALCON_CALL_FUNC(r1, "time");
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(i0, "__construct", message, type, r1, PH_CHECK);
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_quenue"), PH_NOISY_CC);
		phalcon_array_append(&t2, i0, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_quenue"), t2 TSRMLS_CC);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t3);
		phalcon_read_property(&t3, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
		PHALCON_ALLOC_ZVAL_MM(r2);
		PHALCON_CALL_METHOD_PARAMS_2(r2, this_ptr, "_applyformat", message, type, PH_NO_CHECK);
		PHALCON_ALLOC_ZVAL_MM(t4);
		zend_get_constant(SL("PHP_EOL"), t4 TSRMLS_CC);
		PHALCON_ALLOC_ZVAL_MM(r3);
		PHALCON_CONCAT_VV(r3, r2, t4);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("fputs", t3, r3);
	}
	
	PHALCON_MM_RESTORE();
}

/**
  * Starts a transaction
  *
  */
PHP_METHOD(Phalcon_Logger_Adapter_File, begin){


	PHALCON_MM_GROW();
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
  * Commits the internal transaction
  *
  */
PHP_METHOD(Phalcon_Logger_Adapter_File, commit){

	zval *message = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_quenue"), PH_NOISY_CC);
	if (phalcon_valid_foreach(t1 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t1);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_654f_1:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_654f_1;
		}
		
		PHALCON_INIT_VAR(message);
		ZVAL_ZVAL(message, *hd, 1, 0);
		PHALCON_INIT_VAR(t2);
		phalcon_read_property(&t2, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, message, "getmessage", PH_NO_CHECK);
		PHALCON_INIT_VAR(r1);
		PHALCON_CALL_METHOD(r1, message, "gettype", PH_NO_CHECK);
		PHALCON_INIT_VAR(r2);
		PHALCON_CALL_METHOD(r2, message, "gettime", PH_NO_CHECK);
		PHALCON_INIT_VAR(r3);
		PHALCON_CALL_METHOD_PARAMS_3(r3, this_ptr, "_applyformat", r0, r1, r2, PH_NO_CHECK);
		PHALCON_INIT_VAR(t3);
		zend_get_constant(SL("PHP_EOL"), t3 TSRMLS_CC);
		PHALCON_INIT_VAR(r4);
		PHALCON_CONCAT_VV(r4, r3, t3);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("fputs", t2, r4);
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_654f_1;
		fee_654f_1:
		if(0){}
	} else {
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
  * Rollbacks the internal transaction
  *
  */
PHP_METHOD(Phalcon_Logger_Adapter_File, rollback){

	zval *t0 = NULL;
	zval *a0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (!zend_is_true(t0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_quenue"), a0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
  * Closes the logger
  *
  * @return boolean
  */
PHP_METHOD(Phalcon_Logger_Adapter_File, close){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "fclose", t0);
	
	RETURN_CCTOR(r0);
}

/**
 * Opens the internal file handler after unserialization
 *
 */
PHP_METHOD(Phalcon_Logger_Adapter_File, __wakeup){

	zval *t0 = NULL;
	zval *c0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_path"), PH_NOISY_CC);
	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "ab", 1);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_FUNC_PARAMS_2(r0, "fopen", t0, c0);
	phalcon_update_property_zval(this_ptr, SL("_fileHandler"), r0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \logger\adapter\file.c ------ */

/* ------ Starting File: \logger\item.c ------ */
/**
 * Phalcon_Logger_Item
 *
 * Represents each item in a logger transaction
 *
 */

/**
 * Phalcon_Logger_Item contructor
 *
 * @param string $message
 * @param integer $type
 * @param integer $time
 */
PHP_METHOD(Phalcon_Logger_Item, __construct){

	zval *message = NULL, *type = NULL, *time = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &message, &type, &time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!time) {
		PHALCON_ALLOC_ZVAL_MM(time);
		ZVAL_LONG(time, 0);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_time"), time TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns the message
 *
 * @return string
 */
PHP_METHOD(Phalcon_Logger_Item, getMessage){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_message"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns the log type
 *
 * @return integer
 */
PHP_METHOD(Phalcon_Logger_Item, getType){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_type"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Returns log timestamp
 *
 * @return integer
 */
PHP_METHOD(Phalcon_Logger_Item, getTime){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_time"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/* ------ Finished File: \logger\item.c ------ */

/* ------ Starting File: \transaction.c ------ */
/**
 * Phalcon\Transaction
 *
 * Transactions are protective blocks where SQL statements are only permanent if they can
 * all succeed as one atomic action. Phalcon\Transaction is intended to be used with Phalcon_Model_Base.
 * Phalcon Transactions should be created using Phalcon\Transaction\Manager.
 *
 *
 */

/**
 * Phalcon\Transaction constructor
 *
 * @param boolean $autoBegin
 */
PHP_METHOD(Phalcon_Transaction, __construct){

	zval *auto_begin = NULL, *connection = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	zend_update_property(phalcon_transaction_ce, this_ptr, SL("_dependencies"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(a1);
	array_init(a1);
	zend_update_property(phalcon_transaction_ce, this_ptr, SL("_messages"), a1 TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &auto_begin) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!auto_begin) {
		PHALCON_ALLOC_ZVAL_MM(auto_begin);
		ZVAL_BOOL(auto_begin, 0);
	}
	
	PHALCON_INIT_VAR(c0);
	ZVAL_BOOL(c0, 1);
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_STATIC_PARAMS_1(connection, "phalcon\\db\\pool", "getconnection", c0);
	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	if (zend_is_true(auto_begin)) {
		PHALCON_CALL_METHOD_NORETURN(connection, "begin", PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets transaction manager related to the transaction
 *
 * @param Phalcon\Transaction\Manager $manager
 */
PHP_METHOD(Phalcon_Transaction, setTransactionManager){

	zval *manager = NULL;
	zval *i0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(manager) != IS_OBJECT) {
		if (Z_TYPE_P(manager) != IS_STRING) {
			PHALCON_ALLOC_ZVAL_MM(i0);
			object_init_ex(i0, phalcon_transaction_exception_ce);
			PHALCON_ALLOC_ZVAL_MM(r0);
			PHALCON_CONCAT_VS(r0, manager, " must be object or string");
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
			phalcon_throw_exception(i0 TSRMLS_CC);
			return;
		}
	}
	phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Starts the transaction
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, begin){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "begin", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Commits the transaction
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, commit){

	zval *manager = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (zend_is_true(manager)) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		phalcon_array_append(&a0, manager, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(a0, SL("notifyCommit"), 1);
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		phalcon_array_append(&a1, this_ptr, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("call_user_func_array", a0, a1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "commit", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Rollbacks the transaction
 *
 * @param  string $rollbackMessage
 * @param  Phalcon\Model\Base $rollbackRecord
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, rollback){

	zval *rollback_message = NULL, *rollback_record = NULL;
	zval *manager = NULL, *success = NULL;
	zval *a0 = NULL, *a1 = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &rollback_message, &rollback_record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!rollback_message) {
		PHALCON_ALLOC_ZVAL_MM(rollback_message);
		ZVAL_NULL(rollback_message);
	} else {
		PHALCON_SEPARATE_PARAM(rollback_message);
	}
	
	if (!rollback_record) {
		PHALCON_ALLOC_ZVAL_MM(rollback_record);
		ZVAL_NULL(rollback_record);
	}
	
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (zend_is_true(manager)) {
		PHALCON_ALLOC_ZVAL_MM(a0);
		array_init(a0);
		phalcon_array_append(&a0, manager, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(a0, SL("notifyRollback"), 1);
		PHALCON_ALLOC_ZVAL_MM(a1);
		array_init(a1);
		phalcon_array_append(&a1, this_ptr, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("call_user_func_array", a0, a1);
	}
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, t0, "rollback", PH_NO_CHECK);
	if (zend_is_true(success)) {
		if (!zend_is_true(rollback_message)) {
			PHALCON_INIT_VAR(rollback_message);
			ZVAL_STRING(rollback_message, "Transaction aborted", 1);
		}
		if (zend_is_true(rollback_record)) {
			phalcon_update_property_zval(this_ptr, SL("_rollbackRecord"), rollback_record TSRMLS_CC);
		}
		
		PHALCON_ALLOC_ZVAL_MM(i0);
		object_init_ex(i0, phalcon_transaction_failed_ce);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_rollbackRecord"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(i0, "__construct", rollback_message, t1, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Returns connection related to transaction
 *
 * @return Phalcon_Db
 */
PHP_METHOD(Phalcon_Transaction, getConnection){

	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_rollbackOnAbort"), PH_NOISY_CC);
	if (zend_is_true(t0)) {
		PHALCON_ALLOC_ZVAL_MM(r0);
		PHALCON_CALL_FUNC(r0, "connection_aborted");
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(c0);
			ZVAL_STRING(c0, "The request was aborted", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "rollback", c0, PH_NO_CHECK);
		}
	}
	
	PHALCON_ALLOC_ZVAL_MM(t1);
	phalcon_read_property(&t1, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	RETURN_CCTOR(t1);
}

/**
 * Sets if is a reused transaction or new once
 *
 * @param boolean $isNew
 */
PHP_METHOD(Phalcon_Transaction, setIsNewTransaction){

	zval *is_new = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &is_new) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_isNewTransaction"), is_new TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Sets flag to rollback on abort the HTTP connection
 *
 * @param boolean $rollbackOnAbort
 */
PHP_METHOD(Phalcon_Transaction, setRollbackOnAbort){

	zval *rollback_on_abort = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &rollback_on_abort) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_rollbackOnAbort"), rollback_on_abort TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Checks whether transaction is managed by a transaction manager
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, isManaged){

	zval *r0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_manager"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	boolean_not_function(r0, t0 TSRMLS_CC);
	
	RETURN_NCTOR(r0);
}

/**
 * Changes dependency internal pointer
 *
 * @param int $pointer
 */
PHP_METHOD(Phalcon_Transaction, setDependencyPointer){

	zval *pointer = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &pointer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_pointer"), pointer TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/**
 * Attaches Phalcon_Model_Base object to the active transaction
 *
 * @param int $pointer
 * @param Phalcon\Model\Base $object
 */
PHP_METHOD(Phalcon_Transaction, attachDependency){

	zval *pointer = NULL, *object = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	int eval_int;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &pointer, &object) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(pointer);
	
	if (!zend_is_true(pointer)) {
		PHALCON_ALLOC_ZVAL_MM(t0);
		phalcon_read_property(&t0, this_ptr, SL("_pointer"), PH_NOISY_CC);
		PHALCON_SEPARATE_NMO(t0);
		increment_function(t0);
		phalcon_update_property_zval(this_ptr, SL("_pointer"), t0 TSRMLS_CC);
		PHALCON_CPY_WRT(pointer, t0);
		
		PHALCON_ALLOC_ZVAL_MM(t1);
		phalcon_read_property(&t1, this_ptr, SL("_dependencies"), PH_NOISY_CC);
		phalcon_array_update(&t1, pointer, &object, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_dependencies"), t1 TSRMLS_CC);
		
		RETURN_CCTOR(pointer);
	} else {
		PHALCON_ALLOC_ZVAL_MM(t2);
		phalcon_read_property(&t2, this_ptr, SL("_dependencies"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(t2, pointer);
		if (!eval_int) {
			PHALCON_ALLOC_ZVAL_MM(t3);
			phalcon_read_property(&t3, this_ptr, SL("_dependencies"), PH_NOISY_CC);
			phalcon_array_update(&t3, pointer, &object, PH_COPY TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_dependencies"), t3 TSRMLS_CC);
			
			RETURN_CCTOR(pointer);
		} else {
			PHALCON_ALLOC_ZVAL_MM(t4);
			phalcon_read_property(&t4, this_ptr, SL("_pointer"), PH_NOISY_CC);
			PHALCON_SEPARATE_NMO(t4);
			increment_function(t4);
			phalcon_update_property_zval(this_ptr, SL("_pointer"), t4 TSRMLS_CC);
			PHALCON_CPY_WRT(pointer, t4);
			
			PHALCON_ALLOC_ZVAL_MM(t5);
			phalcon_read_property(&t5, this_ptr, SL("_dependencies"), PH_NOISY_CC);
			phalcon_array_update(&t5, pointer, &object, PH_COPY TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_dependencies"), t5 TSRMLS_CC);
			
			RETURN_CCTOR(pointer);
		}
	}
	
	PHALCON_MM_RESTORE();
}

/**
 * Make a bulk save on all attached objects
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, save){

	zval *dependency = NULL;
	zval *a0 = NULL;
	zval *t0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_messages"), a0 TSRMLS_CC);
	
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dependencies"), PH_NOISY_CC);
	if (phalcon_valid_foreach(t0 TSRMLS_CC)) {
		ah0 = Z_ARRVAL_P(t0);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
		fes_815a_0:
		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto fee_815a_0;
		}
		
		PHALCON_INIT_VAR(dependency);
		ZVAL_ZVAL(dependency, *hd, 1, 0);
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD(r0, dependency, "save", PH_NO_CHECK);
		if (!zend_is_true(r0)) {
			PHALCON_INIT_VAR(r1);
			PHALCON_CALL_METHOD(r1, dependency, "getmessages", PH_NO_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_messages"), r1 TSRMLS_CC);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
		zend_hash_move_forward_ex(ah0, &hp0);
		goto fes_815a_0;
		fee_815a_0:
		if(0){}
	} else {
		return;
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

/**
 * Returns validations messages from last save try
 *
 * @return array
 */
PHP_METHOD(Phalcon_Transaction, getMessages){

	zval *t0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_messages"), PH_NOISY_CC);
	
	RETURN_CCTOR(t0);
}

/**
 * Checks whether internal connection is under an active transaction
 *
 * @return boolean
 */
PHP_METHOD(Phalcon_Transaction, isValid){

	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();
	PHALCON_ALLOC_ZVAL_MM(t0);
	phalcon_read_property(&t0, this_ptr, SL("_connection"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	PHALCON_CALL_METHOD(r0, t0, "isundertransaction", PH_NO_CHECK);
	RETURN_CTOR(r0);
}

/**
 * Sets object which generates rollback action
 *
 * @param Phalcon\Model\Base $record
 */
PHP_METHOD(Phalcon_Transaction, setRollbackedRecord){

	zval *record = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_rollbackRecord"), record TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

/* ------ Finished File: \transaction.c ------ */

/* ------ Starting File: \loader\exception.c ------ */
/**
 * Phalcon\Loader\Exception
 *
 * Exceptions thrown in Phalcon_Loader will use this class
 *
 */

/* ------ Finished File: \loader\exception.c ------ */

ZEND_DECLARE_MODULE_GLOBALS(phalcon)

PHP_MINIT_FUNCTION(phalcon){


	if(!zend_ce_arrayaccess){
		fprintf(stderr, "Phalcon Error: Interface ArrayAccess was not found");
		return FAILURE;
	}
	if(!zend_ce_iterator){
		fprintf(stderr, "Phalcon Error: Interface Iterator was not found");
		return FAILURE;
	}
	if(!spl_ce_SeekableIterator){
		fprintf(stderr, "Phalcon Error: Interface SeekableIterator was not found");
		return FAILURE;
	}
	if(!spl_ce_Countable){
		fprintf(stderr, "Phalcon Error: Interface Countable was not found");
		return FAILURE;
	}
	if(!zend_ce_serializable){
		fprintf(stderr, "Phalcon Error: Interface Serializable was not found");
		return FAILURE;
	}

	/** Init globals */
	ZEND_INIT_MODULE_GLOBALS(phalcon, php_phalcon_init_globals, NULL);

	PHALCON_REGISTER_CLASS(Phalcon\\Session, Namespace, session_namespace, phalcon_session_namespace_method_entry, 0);
	zend_declare_property_null(phalcon_session_namespace_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_namespace_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Loader, loader, phalcon_loader_method_entry, 0);
	zend_declare_property_null(phalcon_loader_ce, SL("_namespaces"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_directories"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Text, text, phalcon_text_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon\\Router, Rewrite, router_rewrite, phalcon_router_rewrite_method_entry, 0);
	zend_declare_property_null(phalcon_router_rewrite_ce, SL("_controller"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_rewrite_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_rewrite_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_router_rewrite_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Router, Regex, router_regex, phalcon_router_regex_method_entry, 0);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_controller"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_baseUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_routes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_router_regex_ce, SL("_currentRoute"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Db, db, phalcon_db_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_null(phalcon_db_ce, SL("_descriptor"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_ce, SL("_idConnection"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_ce, SL("_autoCommit"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_ce, SL("_underTransaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_ce, SL("_logger"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_ce, SL("_profiler"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("DB_ASSOC"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("DB_BOTH"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("DB_NUM"), 3 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Logger, logger, phalcon_logger_method_entry, 0);
	zend_declare_property_null(phalcon_logger_ce, SL("_adapter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("SPECIAL"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CUSTOM"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("DEBUG"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("INFO"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("NOTICE"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("WARNING"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ERROR"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ALERT"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CRITICAL"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("EMERGENCE"), 0 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Output, cache_frontend_output, phalcon_cache_frontend_output_method_entry, 0);
	zend_declare_property_bool(phalcon_cache_frontend_output_ce, SL("_buffering"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_frontend_output_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, None, cache_frontend_none, phalcon_cache_frontend_none_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Data, cache_frontend_data, phalcon_cache_frontend_data_method_entry, 0);
	zend_declare_property_null(phalcon_cache_frontend_data_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Cache, Backend, cache_backend, phalcon_cache_backend_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_null(phalcon_cache_backend_ce, SL("_frontendObject"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_backend_ce, SL("_backendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_lastKey"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_fresh"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_started"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Acl\\Adapter, Memory, acl_adapter_memory, phalcon_acl_adapter_memory_method_entry, 0);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_rolesNames"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roles"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resources"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_access"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roleInherits"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resourcesNames"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_accessList"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_long(phalcon_acl_adapter_memory_ce, SL("_defaultAccess"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Role, acl_role, phalcon_acl_role_method_entry, 0);
	zend_declare_property_null(phalcon_acl_role_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_role_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Resource, acl_resource, phalcon_acl_resource_method_entry, 0);
	zend_declare_property_null(phalcon_acl_resource_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_resource_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Cache, cache, phalcon_cache_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon, View, view, phalcon_view_method_entry, 0);
	zend_declare_property_null(phalcon_view_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_view_ce, SL("_basePath"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_view_ce, SL("_content"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_view_ce, SL("_renderLevel"), 5, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_viewParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_view_ce, SL("_layoutsDir"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_templatesBefore"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_templatesAfter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_view_ce, SL("_engines"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_registeredEngines"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_view_ce, SL("_mainView"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_controllerName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_actionName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_pickView"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_view_ce, SL("_cacheLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_MAIN_LAYOUT"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_AFTER_TEMPLATE"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_LAYOUT"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_BEFORE_TEMPLATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_ACTION_VIEW"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_view_ce, SL("LEVEL_NO_RENDER"), 0 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Registry, registry, phalcon_registry_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon\\View, Engine, view_engine, phalcon_view_engine_method_entry, 0);
	zend_declare_property_null(phalcon_view_engine_ce, SL("_view"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_engine_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, Array, paginator_adapter_array, phalcon_paginator_adapter_array_method_entry, 0);
	zend_declare_property_null(phalcon_paginator_adapter_array_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_array_ce, SL("_config"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_array_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, Model, paginator_adapter_model, phalcon_paginator_adapter_model_method_entry, 0);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_config"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Tag, Select, tag_select, phalcon_tag_select_method_entry, ZEND_ACC_ABSTRACT);

	PHALCON_REGISTER_CLASS(Phalcon, Controller, controller, phalcon_controller_method_entry, 0);
	zend_declare_property_null(phalcon_controller_ce, SL("dispatcher"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_ce, SL("request"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_ce, SL("response"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_ce, SL("view"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_ce, SL("model"), ZEND_ACC_PUBLIC TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Request, File, request_file, phalcon_request_file_method_entry, 0);
	zend_declare_property_null(phalcon_request_file_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_request_file_ce, SL("_tmp"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_request_file_ce, SL("_size"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Paginator, paginator, phalcon_paginator_method_entry, ZEND_ACC_ABSTRACT);

	PHALCON_REGISTER_CLASS(Phalcon, Utils, utils, phalcon_utils_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon\\Response, Headers, response_headers, phalcon_response_headers_method_entry, 0);
	zend_declare_property_null(phalcon_response_headers_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Dispatcher, dispatcher, phalcon_dispatcher_method_entry, 0);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_finished"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_controllers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_controllersDir"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_basePath"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_controllerName"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_actionName"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_returnedValue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_lastController"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultController"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultAction"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Translate, translate, phalcon_translate_method_entry, 0);
	zend_declare_property_null(phalcon_translate_ce, SL("_adapter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_class_implements(phalcon_translate_ce TSRMLS_CC, 1, zend_ce_arrayaccess);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Pool, db_pool, phalcon_db_pool_method_entry, 0);
	zend_declare_property_null(phalcon_db_pool_ce, SL("_connection"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_pool_ce, SL("_defaultDescriptor"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Profiler, db_profiler, phalcon_db_profiler_method_entry, 0);
	zend_declare_property_null(phalcon_db_profiler_ce, SL("_allProfiles"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_ce, SL("_activeProfile"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_profiler_ce, SL("_totalSeconds"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Reference, db_reference, phalcon_db_reference_method_entry, 0);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referenceName"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedTable"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_columns"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedColumns"), ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Profiler, Item, db_profiler_item, phalcon_db_profiler_item_method_entry, 0);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_initialTime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_finalTime"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, RawValue, db_rawvalue, phalcon_db_rawvalue_method_entry, 0);
	zend_declare_property_null(phalcon_db_rawvalue_ce, SL("_value"), ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Column, db_column, phalcon_db_column_method_entry, 0);
	zend_declare_property_null(phalcon_db_column_ce, SL("_columnName"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_schemaName"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_type"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_size"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_scale"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_unsigned"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_notNull"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_autoIncrement"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_first"), 0, ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_after"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_INTEGER"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_VARCHAR"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DECIMAL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATETIME"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_CHAR"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_TEXT"), 6 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Index, db_index, phalcon_db_index_method_entry, 0);
	zend_declare_property_null(phalcon_db_index_ce, SL("_indexName"), ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Result, Mysql, db_result_mysql, phalcon_db_result_mysql_method_entry, 0);
	zend_declare_property_long(phalcon_db_result_mysql_ce, SL("_fetchMode"), 3, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_mysql_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Result, Postgresql, db_result_postgresql, phalcon_db_result_postgresql_method_entry, 0);
	zend_declare_property_long(phalcon_db_result_postgresql_ce, SL("_fetchMode"), 3, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_postgresql_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Dialect, Mysql, db_dialect_mysql, phalcon_db_dialect_mysql_method_entry, ZEND_ACC_ABSTRACT);

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Dialect, Postgresql, db_dialect_postgresql, phalcon_db_dialect_postgresql_method_entry, ZEND_ACC_ABSTRACT);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Query, model_query, phalcon_model_query_method_entry, 0);
	zend_declare_property_null(phalcon_model_query_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_query_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_query_ce, SL("_models"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_query_ce, SL("_parameters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_query_ce, SL("_conditions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_query_ce, SL("_limit"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Base, model_base, phalcon_model_base_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_string(phalcon_model_base_ce, SL("_uniqueKey"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_connection"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_model_base_ce, SL("_schema"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_model_base_ce, SL("_source"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_isView"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_dumped"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_dumpLock"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_base_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_base_ce, SL("_operationMade"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_forceExists"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_defaultConnection"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_base_ce, SL("_connectionName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_base_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_disableEvents"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_base_ce, SL("_refreshPersistance"), 1, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_base_ce, SL("OP_CREATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_base_ce, SL("OP_UPDATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_base_ce, SL("OP_DELETE"), 3 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Validator, model_validator, phalcon_model_validator_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_null(phalcon_model_validator_ce, SL("_record"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_validator_ce, SL("_fieldName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_validator_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_validator_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_validator_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Row, model_row, phalcon_model_row_method_entry, 0);
	zend_declare_property_null(phalcon_model_row_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_row_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, MetaData, model_metadata, phalcon_model_metadata_method_entry, 0);
	zend_declare_property_bool(phalcon_model_metadata_ce, SL("_changed"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_metadata_ce, SL("_metaData"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_ATTRIBUTES"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_PRIMARY_KEY"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_NON_PRIMARY_KEY"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_NOT_NULL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_DATA_TYPE"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_DATA_TYPE_NUMERIC"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_DATE_AT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_DATE_IN"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_model_metadata_ce, SL("MODELS_IDENTITY_FIELD"), 8 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Message, model_message, phalcon_model_message_method_entry, 0);
	zend_declare_property_null(phalcon_model_message_ce, SL("_type"), ZEND_ACC_PRIVATE TSRMLS_CC);
	zend_declare_property_null(phalcon_model_message_ce, SL("_message"), ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Manager, model_manager, phalcon_model_manager_method_entry, 0);
	zend_declare_property_bool(phalcon_model_manager_ce, SL("_connection"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_model_manager_ce, SL("_autoConnection"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_metadata"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_basePath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_modelsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_models"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_hasMany"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_hasOne"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_belongsTo"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_sourceNames"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_initialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_manager_ce, SL("_default"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model\\MetaData, Memory, model_metadata_memory, phalcon_model_metadata_memory_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon\\Model\\MetaData, Apc, model_metadata_apc, phalcon_model_metadata_apc_method_entry, 0);
	zend_declare_property_string(phalcon_model_metadata_apc_ce, SL("_suffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_model_metadata_apc_ce, SL("_ttl"), 172800, ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model\\MetaData, Session, model_metadata_session, phalcon_model_metadata_session_method_entry, 0);
	zend_declare_property_string(phalcon_model_metadata_session_ce, SL("_suffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Model, Resultset, model_resultset, phalcon_model_resultset_method_entry, 0);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_model_resultset_ce, SL("_pointer"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_count"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_activeRow"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_model_resultset_ce, SL("_rows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_class_implements(phalcon_model_resultset_ce TSRMLS_CC, 5, zend_ce_iterator, spl_ce_SeekableIterator, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_serializable);

	PHALCON_REGISTER_CLASS(Phalcon, Tag, tag, phalcon_tag_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_null(phalcon_tag_ce, SL("_displayValues"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_string(phalcon_tag_ce, SL("_documentTitle"), "", ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_dispatcher"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Response, response, phalcon_response_method_entry, 0);
	zend_declare_property_null(phalcon_response_ce, SL("_instance"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_response_ce, SL("_content"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_response_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Request, request, phalcon_request_method_entry, 0);
	zend_declare_property_null(phalcon_request_ce, SL("_filter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_request_ce, SL("_instance"), ZEND_ACC_STATIC|ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Transaction, Manager, transaction_manager, phalcon_transaction_manager_method_entry, 0);
	zend_declare_property_bool(phalcon_transaction_manager_ce, SL("_initialized"), 0, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_transaction_manager_ce, SL("_number"), 0, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_manager_ce, SL("_transactions"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_transaction_manager_ce, SL("_dependencyPointer"), 0, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_manager_ce, SL("_automaticTransaction"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Controller, Front, controller_front, phalcon_controller_front_method_entry, 0);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_instance"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_controllersDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_modelsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_viewsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_basePath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_baseUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_dispatcher"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_view"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_request"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_response"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_router"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_modelsConfig"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_controller_front_ce, SL("_viewsConfig"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Session, session, phalcon_session_method_entry, ZEND_ACC_ABSTRACT);
	zend_declare_property_null(phalcon_session_ce, SL("_uniqueId"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_ce, SL("_options"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Flash, flash, phalcon_flash_method_entry, ZEND_ACC_ABSTRACT);

	PHALCON_REGISTER_CLASS(Phalcon, Config, config, phalcon_config_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon, Filter, filter, phalcon_filter_method_entry, 0);

	PHALCON_REGISTER_CLASS(Phalcon, Acl, acl, phalcon_acl_method_entry, 0);
	zend_declare_property_null(phalcon_acl_ce, SL("_adapter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_acl_ce, SL("ALLOW"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_acl_ce, SL("DENY"), 0 TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Translate\\Adapter, Array, translate_adapter_array, phalcon_translate_adapter_array_method_entry, 0);
	zend_declare_property_null(phalcon_translate_adapter_array_ce, SL("_traslate"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Logger\\Adapter, File, logger_adapter_file, phalcon_logger_adapter_file_method_entry, 0);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_fileHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_logger_adapter_file_ce, SL("_transaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_quenue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_logger_adapter_file_ce, SL("_dateFormat"), "D, d M y H:i:s O", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_logger_adapter_file_ce, SL("_format"), "[%date%][%type%] %message%", ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Item, logger_item, phalcon_logger_item_method_entry, 0);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_time"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS(Phalcon, Transaction, transaction, phalcon_transaction_method_entry, 0);
	zend_declare_property_null(phalcon_transaction_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_transaction_ce, SL("_activeTransaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_transaction_ce, SL("_isNewTransaction"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_transaction_ce, SL("_rollbackOnAbort"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_transaction_ce, SL("_pointer"), 255, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_ce, SL("_dependencies"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_transaction_ce, SL("_rollbackRecord"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon, Exception, exception, "exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config, Exception, config_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Ini, config_adapter_ini, "phalcon\\config", phalcon_config_adapter_ini_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache, Exception, cache_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Memcache, cache_backend_memcache, "phalcon\\cache\\backend", phalcon_cache_backend_memcache_method_entry, 0);
	zend_declare_property_null(phalcon_cache_backend_memcache_ce, SL("_memcache"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Apc, cache_backend_apc, "phalcon\\cache\\backend", phalcon_cache_backend_apc_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, File, cache_backend_file, "phalcon\\cache\\backend", phalcon_cache_backend_file_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Acl, Exception, acl_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Dispatcher, Exception, dispatcher_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\View, Exception, view_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\View\\Engine, Php, view_engine_php, "phalcon\\view\\engine", phalcon_view_engine_php_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\View\\Engine, Twig, view_engine_twig, "phalcon\\view\\engine", phalcon_view_engine_twig_method_entry, 0);
	zend_declare_property_null(phalcon_view_engine_twig_ce, SL("_twig"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\View\\Engine, Mustache, view_engine_mustache, "phalcon\\view\\engine", phalcon_view_engine_mustache_method_entry, 0);
	zend_declare_property_null(phalcon_view_engine_mustache_ce, SL("_mustache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_view_engine_mustache_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Paginator, Exception, paginator_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Tag, Exception, tag_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Request, Exception, request_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Response, Exception, response_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db, Exception, db_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter, Mysql, db_adapter_mysql, "phalcon\\db", phalcon_db_adapter_mysql_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter, Postgresql, db_adapter_postgresql, "phalcon\\db", phalcon_db_adapter_postgresql_method_entry, 0);
	zend_declare_property_null(phalcon_db_adapter_postgresql_ce, SL("_lastResultset"), ZEND_ACC_PROTECTED TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Uniqueness, model_validator_uniqueness, "phalcon\\model\\validator", phalcon_model_validator_uniqueness_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Exclusionin, model_validator_exclusionin, "phalcon\\model\\validator", phalcon_model_validator_exclusionin_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Regex, model_validator_regex, "phalcon\\model\\validator", phalcon_model_validator_regex_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Inclusionin, model_validator_inclusionin, "phalcon\\model\\validator", phalcon_model_validator_inclusionin_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Numericality, model_validator_numericality, "phalcon\\model\\validator", phalcon_model_validator_numericality_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model\\Validator, Email, model_validator_email, "phalcon\\model\\validator", phalcon_model_validator_email_method_entry, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Model, Exception, model_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Transaction, Exception, transaction_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Transaction, Failed, transaction_failed, "exception", phalcon_transaction_failed_method_entry, 0);
	zend_declare_property_null(phalcon_transaction_failed_ce, SL("_record"), ZEND_ACC_PRIVATE TSRMLS_CC);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate, Exception, translate_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger, Exception, logger_exception, "phalcon\\exception", NULL, 0);

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Loader, Exception, loader_exception, "phalcon\\exception", NULL, 0);
	return SUCCESS;
}

PHP_MSHUTDOWN_FUNCTION(phalcon){
	return SUCCESS;
}

PHP_RINIT_FUNCTION(phalcon){
return SUCCESS;
}

PHP_RSHUTDOWN_FUNCTION(phalcon){
return SUCCESS;
}

zend_module_entry phalcon_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
	STANDARD_MODULE_HEADER,
#endif
	PHP_PHALCON_EXTNAME,
	NULL,
	PHP_MINIT(phalcon),
	PHP_MSHUTDOWN(phalcon),
	PHP_RINIT(phalcon),
	PHP_RSHUTDOWN(phalcon),
	NULL,
#if ZEND_MODULE_API_NO >= 20010901
	PHP_PHALCON_VERSION,
#endif
	STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_PHALCON
ZEND_GET_MODULE(phalcon)
#endif

