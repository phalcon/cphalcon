/**

New BSD License

Copyright (c) 2011-2012, Phalcon Framework Team
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stdio.h>

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_phalcon.h"
#include "phalcon.h"

#include "main/php_main.h"
#include "main/php_streams.h"
#include "ext/standard/php_string.h"
#include "ext/standard/php_smart_str.h"
#include "ext/pdo/php_pdo_driver.h"
#include "ext/standard/php_filestat.h"

#include "Zend/zend_API.h"
#include "Zend/zend_operators.h"
#include "Zend/zend_exceptions.h"
#include "Zend/zend_interfaces.h"
#include "Zend/zend_execute.h"

#define PHQL_EQUALS                          1
#define PHQL_NOTEQUALS                       2
#define PHQL_LESS                            3
#define PHQL_GREATER                         4
#define PHQL_GREATEREQUAL                    5
#define PHQL_LESSEQUAL                       6
#define PHQL_AND                             7
#define PHQL_OR                              8
#define PHQL_LIKE                            9
#define PHQL_DIVIDE                         10
#define PHQL_TIMES                          11
#define PHQL_MOD                            12
#define PHQL_PLUS                           13
#define PHQL_MINUS                          14
#define PHQL_IS                             15
#define PHQL_IN                             16
#define PHQL_NOT                            17
#define PHQL_SELECT                         18
#define PHQL_FROM                           19
#define PHQL_COMMA                          20
#define PHQL_IDENTIFIER                     21
#define PHQL_DOT                            22
#define PHQL_AS                             23
#define PHQL_JOIN                           24
#define PHQL_ON                             25
#define PHQL_INNER                          26
#define PHQL_CROSS                          27
#define PHQL_LEFT                           28
#define PHQL_OUTER                          29
#define PHQL_RIGHT                          30
#define PHQL_FULL                           31
#define PHQL_INSERT                         32
#define PHQL_INTO                           33
#define PHQL_VALUES                         34
#define PHQL_BRACKET_OPEN                   35
#define PHQL_BRACKET_CLOSE                  36
#define PHQL_UPDATE                         37
#define PHQL_SET                            38
#define PHQL_DELETE                         39
#define PHQL_WHERE                          40
#define PHQL_ORDER                          41
#define PHQL_BY                             42
#define PHQL_ASC                            43
#define PHQL_DESC                           44
#define PHQL_INTEGER                        45
#define PHQL_GROUP                          46
#define PHQL_HAVING                         47
#define PHQL_LIMIT                          48
#define PHQL_OFFSET                         49
#define PHQL_NULL                           50
#define PHQL_STRING                         51
#define PHQL_DOUBLE                         52
#define PHQL_NPLACEHOLDER                   53
#define PHQL_SPLACEHOLDER                   54




#define PHQL_SCANNER_RETCODE_EOF -1
#define PHQL_SCANNER_RETCODE_ERR -2
#define PHQL_SCANNER_RETCODE_IMPOSSIBLE -3

#define PHQL_T_IGNORE 257

/* Literals & Identifiers */
#define PHQL_T_INTEGER 258
#define PHQL_T_DOUBLE 259
#define PHQL_T_STRING 260
#define PHQL_T_IDENTIFIER 265

/* Operators */
#define PHQL_T_ADD '+'
#define PHQL_T_SUB '-'
#define PHQL_T_MUL '*'
#define PHQL_T_DIV '/'
#define PHQL_T_MOD '%'
#define PHQL_T_AND 266
#define PHQL_T_OR 267
#define PHQL_T_LIKE 268

#define PHQL_T_DOT '.'
#define PHQL_T_COMMA 269

#define PHQL_T_EQUALS '='
#define PHQL_T_NOTEQUALS 270
#define PHQL_T_NOT '!'
#define PHQL_T_LESS '<'
#define PHQL_T_LESSEQUAL 271
#define PHQL_T_GREATER '>'
#define PHQL_T_GREATEREQUAL 272

#define PHQL_T_BRACKET_OPEN '('
#define PHQL_T_BRACKET_CLOSE ')'

/** Placeholders */
#define PHQL_T_NPLACEHOLDER 273
#define PHQL_T_SPLACEHOLDER 274

/** Reserved words */
#define PHQL_T_UPDATE 300
#define PHQL_T_SET 301
#define PHQL_T_WHERE 302
#define PHQL_T_DELETE 303
#define PHQL_T_FROM 304
#define PHQL_T_AS 305
#define PHQL_T_INSERT 306
#define PHQL_T_INTO 307
#define PHQL_T_VALUES 308
#define PHQL_T_SELECT 309
#define PHQL_T_ORDER 310
#define PHQL_T_BY 311
#define PHQL_T_LIMIT 312
#define PHQL_T_GROUP 313
#define PHQL_T_HAVING 314
#define PHQL_T_IN 315
#define PHQL_T_ON 316
#define PHQL_T_INNER 317
#define PHQL_T_JOIN 318
#define PHQL_T_LEFT 319
#define PHQL_T_RIGHT 320
#define PHQL_T_IS 321
#define PHQL_T_NULL 322
#define PHQL_T_NOTIN 323
#define PHQL_T_CROSS 324
#define PHQL_T_FULL 325
#define PHQL_T_OUTER 326
#define PHQL_T_ASC 327
#define PHQL_T_DESC 328
#define PHQL_T_OFFSET 329

/** Special Tokens */
#define PHQL_T_FCALL 350
#define PHQL_T_NLIKE 351
#define PHQL_T_ALL 352
#define PHQL_T_DOMAINALL 353
#define PHQL_T_EXPR 354
#define PHQL_T_QUALIFIED 355
#define PHQL_T_ENCLOSED 356

#define PHQL_T_INNERJOIN 360
#define PHQL_T_LEFTJOIN 361
#define PHQL_T_RIGHTJOIN 362
#define PHQL_T_CROSSJOIN 363
#define PHQL_T_FULLOUTER 364
#define PHQL_T_ISNULL 365
#define PHQL_T_ISNOTNULL 366
#define PHQL_T_MINUS 367

/* list of tokens and their names */
typedef struct _phql_token_names
{
    unsigned int code;
    char *name;
} phql_token_names;

/* active token state */
typedef struct _phql_scanner_state {
  int active_token;
	char* start;
	char* end;
} phql_scanner_state;

/* extra information tokens */
typedef struct _phql_scanner_token {
	int opcode;
	char *value;
	int len;
} phql_scanner_token;

int phql_get_token(phql_scanner_state *s, phql_scanner_token *token);

const phql_token_names phql_tokens[];




zend_class_entry *phalcon_mvc_model_query_lang_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Lang);

PHP_METHOD(Phalcon_Mvc_Model_Query_Lang, parsePHQL);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_lang_parsephql, 0, 0, 1)
	ZEND_ARG_INFO(0, phql)
ZEND_END_ARG_INFO()

PHALCON_INIT_FUNCS(phalcon_mvc_model_query_lang_method_entry){
	PHP_ME(Phalcon_Mvc_Model_Query_Lang, parsePHQL, arginfo_phalcon_mvc_model_query_lang_parsephql, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC) 
	PHP_FE_END
};



#define PHVOLT_COMMA                           1
#define PHVOLT_SBRACKET_OPEN                   2
#define PHVOLT_RANGE                           3
#define PHVOLT_IS                              4
#define PHVOLT_EQUALS                          5
#define PHVOLT_NOTEQUALS                       6
#define PHVOLT_LESS                            7
#define PHVOLT_GREATER                         8
#define PHVOLT_GREATEREQUAL                    9
#define PHVOLT_LESSEQUAL                      10
#define PHVOLT_IDENTICAL                      11
#define PHVOLT_NOTIDENTICAL                   12
#define PHVOLT_AND                            13
#define PHVOLT_OR                             14
#define PHVOLT_PIPE                           15
#define PHVOLT_DIVIDE                         16
#define PHVOLT_TIMES                          17
#define PHVOLT_MOD                            18
#define PHVOLT_PLUS                           19
#define PHVOLT_MINUS                          20
#define PHVOLT_CONCAT                         21
#define PHVOLT_NOT                            22
#define PHVOLT_DOT                            23
#define PHVOLT_OPEN_DELIMITER                 24
#define PHVOLT_IF                             25
#define PHVOLT_CLOSE_DELIMITER                26
#define PHVOLT_ENDIF                          27
#define PHVOLT_ELSE                           28
#define PHVOLT_FOR                            29
#define PHVOLT_IN                             30
#define PHVOLT_ENDFOR                         31
#define PHVOLT_SET                            32
#define PHVOLT_ASSIGN                         33
#define PHVOLT_OPEN_EDELIMITER                34
#define PHVOLT_CLOSE_EDELIMITER               35
#define PHVOLT_BLOCK                          36
#define PHVOLT_IDENTIFIER                     37
#define PHVOLT_ENDBLOCK                       38
#define PHVOLT_EXTENDS                        39
#define PHVOLT_STRING                         40
#define PHVOLT_INCLUDE                        41
#define PHVOLT_RAW_FRAGMENT                   42
#define PHVOLT_DEFINED                        43
#define PHVOLT_BRACKET_OPEN                   44
#define PHVOLT_BRACKET_CLOSE                  45
#define PHVOLT_SBRACKET_CLOSE                 46
#define PHVOLT_DOUBLECOLON                    47
#define PHVOLT_INTEGER                        48
#define PHVOLT_DOUBLE                         49
#define PHVOLT_NULL                           50
#define PHVOLT_FALSE                          51
#define PHVOLT_TRUE                           52




#define PHVOLT_RAW_BUFFER_SIZE 256

#define PHVOLT_SCANNER_RETCODE_EOF -1
#define PHVOLT_SCANNER_RETCODE_ERR -2
#define PHVOLT_SCANNER_RETCODE_IMPOSSIBLE -3

/** Modes */
#define PHVOLT_MODE_RAW 0
#define PHVOLT_MODE_CODE 1
#define PHVOLT_MODE_COMMENT 2

#define PHVOLT_T_IGNORE 257

/* Literals & Identifiers */
#define PHVOLT_T_INTEGER 258
#define PHVOLT_T_DOUBLE 259
#define PHVOLT_T_STRING 260
#define PHVOLT_T_NULL 261
#define PHVOLT_T_FALSE 262
#define PHVOLT_T_TRUE 263
#define PHVOLT_T_IDENTIFIER 265

/* Operators */
#define PHVOLT_T_ADD '+'
#define PHVOLT_T_SUB '-'
#define PHVOLT_T_MUL '*'
#define PHVOLT_T_DIV '/'
#define PHVOLT_T_MOD '%'
#define PHVOLT_T_AND 266
#define PHVOLT_T_OR 267
#define PHVOLT_T_CONCAT '~'
#define PHVOLT_T_PIPE '|'

#define PHVOLT_T_DOT '.'
#define PHVOLT_T_COMMA 269

#define PHVOLT_T_NOT '!'
#define PHVOLT_T_LESS '<'
#define PHVOLT_T_LESSEQUAL 270
#define PHVOLT_T_GREATER '>'
#define PHVOLT_T_GREATEREQUAL 271
#define PHVOLT_T_EQUALS 272
#define PHVOLT_T_NOTEQUALS 273
#define PHVOLT_T_IDENTICAL 274
#define PHVOLT_T_NOTIDENTICAL 275
#define PHVOLT_T_RANGE 276
#define PHVOLT_T_ASSIGN '='
#define PHVOLT_T_DOUBLECOLON 277

#define PHVOLT_T_BRACKET_OPEN '('
#define PHVOLT_T_BRACKET_CLOSE ')'
#define PHVOLT_T_SBRACKET_OPEN '['
#define PHVOLT_T_SBRACKET_CLOSE ']'

/** Reserved words */
#define PHVOLT_T_IF 300
#define PHVOLT_T_ELSE 301
#define PHVOLT_T_ENDIF 303
#define PHVOLT_T_FOR 304
#define PHVOLT_T_ENDFOR 305
#define PHVOLT_T_SET 306
#define PHVOLT_T_BLOCK 307
#define PHVOLT_T_ENDBLOCK 308
#define PHVOLT_T_IN 309
#define PHVOLT_T_EXTENDS 310
#define PHVOLT_T_IS 311
#define PHVOLT_T_DEFINED 312
#define PHVOLT_T_INCLUDE 313

/** Delimiters */
#define PHVOLT_T_OPEN_DELIMITER  330
#define PHVOLT_T_CLOSE_DELIMITER  331
#define PHVOLT_T_OPEN_EDELIMITER  332
#define PHVOLT_T_CLOSE_EDELIMITER  333

/** Special Tokens */
#define PHVOLT_T_FCALL 350
#define PHVOLT_T_EXPR 354
#define PHVOLT_T_QUALIFIED 355
#define PHVOLT_T_ENCLOSED 356
#define PHVOLT_T_RAW_FRAGMENT 357
#define PHVOLT_T_EMPTY 358
#define PHVOLT_T_ECHO 359
#define PHVOLT_T_ARRAY 360
#define PHVOLT_T_ARRAYACCESS 361
#define PHVOLT_T_NOT_ISSET 362
#define PHVOLT_T_ISSET 363

#define PHVOLT_T_MINUS 367

/* list of tokens and their names */
typedef struct _phvolt_token_names
{
	unsigned int code;
	char *name;
} phvolt_token_names;

/* active token state */
typedef struct _phvolt_scanner_state {
	int active_token;
	char* start;
	char* end;
	int mode;
	unsigned int active_line;
	unsigned int statement_position;
	unsigned int extends_mode;
	unsigned int block_level;
	char *raw_buffer;
	unsigned int raw_buffer_cursor;
	unsigned int raw_buffer_size;
} phvolt_scanner_state;

/* extra information tokens */
typedef struct _phvolt_scanner_token {
	int opcode;
	char *value;
	int len;
} phvolt_scanner_token;

int phvolt_get_token(phvolt_scanner_state *s, phvolt_scanner_token *token);

const phvolt_token_names phvolt_tokens[];





zend_class_entry *phalcon_mvc_view_engine_volt_compiler_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Volt_Compiler);

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _functionCall);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _filter);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _expression);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compile);
PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, parse);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, di)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler__expression, 0, 0, 2)
	ZEND_ARG_INFO(0, expr)
	ZEND_ARG_INFO(0, extendsMode)
	ZEND_ARG_INFO(0, prependDollar)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilestring, 0, 0, 1)
	ZEND_ARG_INFO(0, viewCode)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compile, 0, 0, 2)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, compiledPath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_parse, 0, 0, 1)
	ZEND_ARG_INFO(0, viewCode)
ZEND_END_ARG_INFO()

PHALCON_INIT_FUNCS(phalcon_mvc_view_engine_volt_compiler_method_entry){
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI, arginfo_phalcon_mvc_view_engine_volt_compiler_setdi, ZEND_ACC_PUBLIC) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI, NULL, ZEND_ACC_PUBLIC) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _functionCall, NULL, ZEND_ACC_PROTECTED) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _filter, NULL, ZEND_ACC_PROTECTED) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _expression, arginfo_phalcon_mvc_view_engine_volt_compiler__expression, ZEND_ACC_PUBLIC) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList, NULL, ZEND_ACC_PROTECTED) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource, NULL, ZEND_ACC_PROTECTED) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString, arginfo_phalcon_mvc_view_engine_volt_compiler_compilestring, ZEND_ACC_PUBLIC) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compile, arginfo_phalcon_mvc_view_engine_volt_compiler_compile, ZEND_ACC_PUBLIC) 
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, parse, arginfo_phalcon_mvc_view_engine_volt_compiler_parse, ZEND_ACC_PUBLIC) 
	PHP_FE_END
};





/** Main macros */
#define PH_DEBUG 0

#define PH_NOISY 0
#define PH_SILENT 1

#define PH_NOISY_CC PH_NOISY TSRMLS_CC
#define PH_SILENT_CC PH_SILENT TSRMLS_CC

#define PH_CHECK 1
#define PH_NO_CHECK 0

#define PH_SEPARATE 256
#define PH_COPY 1024
#define PH_CTOR 4096

#define PH_FETCH_CLASS_SILENT (zend_bool) ZEND_FETCH_CLASS_SILENT TSRMLS_CC

#define SL(str) ZEND_STRL(str)
#define SS(str) ZEND_STRS(str)

/** SPL dependencies */
#if defined(HAVE_SPL) && ((PHP_MAJOR_VERSION > 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 1))
extern ZEND_API zend_class_entry *zend_ce_iterator;
extern ZEND_API zend_class_entry *zend_ce_arrayaccess;
extern ZEND_API zend_class_entry *zend_ce_serializable;
extern PHPAPI zend_class_entry *spl_ce_RuntimeException;
extern PHPAPI zend_class_entry *spl_ce_Countable;
extern PHPAPI zend_class_entry *spl_ce_SeekableIterator;
#endif

/** Startup functions */
void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC);

/** Globals functions */
int phalcon_init_global(char *global, unsigned int global_length TSRMLS_DC);
int phalcon_get_global(zval **arr, char *global, unsigned int global_length TSRMLS_DC);
int phalcon_get_global_by_index(char *global, char *index, zval *result TSRMLS_DC);

int phalcon_is_callable(zval *var TSRMLS_DC);
int phalcon_function_exists_ex(char *method_name, unsigned int method_len TSRMLS_DC);

/** Count */
void phalcon_fast_count(zval *result, zval *array TSRMLS_DC);
int phalcon_fast_count_ev(zval *array TSRMLS_DC);

/** Low level filters */
int phalcon_filter_alphanum(zval *result, zval *param);
int phalcon_filter_identifier(zval *result, zval *param);

/* Utils functions */
void phalcon_inherit_not_found(char *class_name, char *inherit_name);
int phalcon_valid_foreach(zval *arr TSRMLS_DC);

/** Export symbols to active symbol table */
int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC);
int phalcon_set_symbol_str(char *key_name, unsigned int key_length, zval *value TSRMLS_DC);

/** Compatibility with PHP 5.3 */
#ifndef ZVAL_COPY_VALUE
 #define ZVAL_COPY_VALUE(z, v)\
  (z)->value = (v)->value;\
  Z_TYPE_P(z) = Z_TYPE_P(v);
#endif

#ifndef INIT_PZVAL_COPY
 #define INIT_PZVAL_COPY(z, v) ZVAL_COPY_VALUE(z, v);\
  Z_SET_REFCOUNT_P(z, 1);\
  Z_UNSET_ISREF_P(z);
#endif

/** Symbols */
#define PHALCON_READ_SYMBOL(var, auxarr, name) if (EG(active_symbol_table)){ \
	if (zend_hash_find(EG(active_symbol_table), name, sizeof(name), (void **)  &auxarr) == SUCCESS) { \
			var = *auxarr; \
		} else { \
			ZVAL_NULL(var); \
		} \
	} else { \
		ZVAL_NULL(var); \
	}

#define RETURN_CCTOR(var) { \
		*(return_value) = *(var); \
		if (Z_TYPE_P(var) > IS_BOOL) { \
			phalcon_copy_ctor(return_value, var); \
		} \
		INIT_PZVAL(return_value) \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_CCTORW(var) { \
		*(return_value) = *(var); \
		if (Z_TYPE_P(var) > IS_BOOL) { \
			phalcon_copy_ctor(return_value, var); \
		} \
		INIT_PZVAL(return_value) \
	} \
	return;

#define RETURN_CTOR(var) { \
		*(return_value) = *(var); \
		phalcon_copy_ctor(return_value, var); \
		INIT_PZVAL(return_value) \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_CTORW(var) { \
		*(return_value) = *(var); \
		phalcon_copy_ctor(return_value, var); \
		INIT_PZVAL(return_value) \
	} \
	return;

#define RETURN_NCTOR(var) { \
		*(return_value) = *(var); \
		INIT_PZVAL(return_value) \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_NCTORW(var) { \
		*(return_value) = *(var); \
		INIT_PZVAL(return_value) \
	} \
	return;

#define RETURN_SCTOR() \
	if (Z_TYPE_P(return_value) > IS_BOOL) { \
		zval_copy_ctor(return_value); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_SCTORW() \
	if (Z_TYPE_P(return_value) > IS_BOOL) { \
		zval_copy_ctor(return_value); \
	} \
	return;

#define RETURN_MEMBER(object, member_name) \
 	phalcon_return_property(return_value, object, SL(member_name) TSRMLS_CC); \
	return;

/** Foreach */
#define PHALCON_GET_FOREACH_KEY(var, hash, hash_pointer) \
	PHALCON_INIT_NVAR(var); \
	hash_type = zend_hash_get_current_key_ex(hash, &hash_index, &hash_index_len, &hash_num, 0, &hash_pointer); \
	if (hash_type == HASH_KEY_IS_STRING) { \
		ZVAL_STRINGL(var, hash_index, hash_index_len-1, 1); \
	} else { \
		if (hash_type == HASH_KEY_IS_LONG) { \
			ZVAL_LONG(var, hash_num); \
		}\
	}

#define PHALCON_GET_FOREACH_VALUE(var) \
	PHALCON_OBSERVE_VAR(var); \
	var = *hd; \
	Z_ADDREF_P(var);

/** class/interface registering */
#define PHALCON_REGISTER_CLASS(ns, class_name, name, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #class_name, methods); \
		phalcon_ ##name## _ce = zend_register_internal_class(&ce TSRMLS_CC); \
		phalcon_ ##name## _ce->ce_flags |= flags;  \
	}

#define PHALCON_REGISTER_CLASS_EX(ns, class_name, name, parent, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #class_name, methods); \
		phalcon_ ##name## _ce = zend_register_internal_class_ex(&ce, NULL, parent TSRMLS_CC); \
		if(!phalcon_ ##name## _ce){ \
			phalcon_inherit_not_found(parent, ZEND_NS_NAME(#ns, #class_name)); \
			return FAILURE;	\
		}  \
		phalcon_ ##name## _ce->ce_flags |= flags;  \
	}

#define PHALCON_REGISTER_INTERFACE(ns, classname, name, methods) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #classname, methods); \
		phalcon_ ##name## _ce = zend_register_internal_interface(&ce TSRMLS_CC); \
	}

/** Method declaration for API generation */
#define PHALCON_DOC_METHOD(class_name, method)



void phalcon_init_nvar(zval **var TSRMLS_DC);
void phalcon_cpy_wrt(zval **dest, zval *var TSRMLS_DC);
void phalcon_cpy_wrt_ctor(zval **dest, zval *var TSRMLS_DC);

int PHALCON_FASTCALL phalcon_memory_grow_stack(TSRMLS_D);
int PHALCON_FASTCALL phalcon_memory_restore_stack(TSRMLS_D);

int PHALCON_FASTCALL phalcon_memory_observe(zval **var TSRMLS_DC);
int PHALCON_FASTCALL phalcon_memory_remove(zval **var TSRMLS_DC);
int PHALCON_FASTCALL phalcon_memory_alloc(zval **var TSRMLS_DC);

int PHALCON_FASTCALL phalcon_clean_shutdown_stack(TSRMLS_D);
int PHALCON_FASTCALL phalcon_clean_restore_stack(TSRMLS_D);

void PHALCON_FASTCALL phalcon_copy_ctor(zval *destiny, zval *origin);

#define PHALCON_MM_GROW() phalcon_memory_grow_stack(TSRMLS_C)
#define PHALCON_MM_RESTORE() phalcon_memory_restore_stack(TSRMLS_C)

/** Memory macros */
#define PHALCON_ALLOC_ZVAL(z) \
	ALLOC_ZVAL(z); INIT_PZVAL(z); ZVAL_NULL(z);

#define PHALCON_INIT_VAR(z) \
	PHALCON_ALLOC_ZVAL(z); \
	phalcon_memory_observe(&z TSRMLS_CC);

//#ifndef PHP_WIN32

#define PHALCON_INIT_NVAR(z)\
	if (z) { \
		if (Z_REFCOUNT_P(z) > 1) { \
			Z_DELREF_P(z); \
			ALLOC_ZVAL(z); \
			Z_SET_REFCOUNT_P(z, 1); \
			Z_UNSET_ISREF_P(z); \
			ZVAL_NULL(z); \
		} else {\
			zval_ptr_dtor(&z); \
			PHALCON_ALLOC_ZVAL(z); \
		} \
	} else { \
		phalcon_memory_alloc(&z TSRMLS_CC); \
	}

#define PHALCON_CPY_WRT(d, v) \
	if (d) { \
		if (Z_REFCOUNT_P(d) > 0) { \
			zval_ptr_dtor(&d); \
		} \
	} else { \
		phalcon_memory_observe(&d TSRMLS_CC); \
	} \
	Z_ADDREF_P(v); \
	d = v;

#define PHALCON_CPY_WRT_CTOR(d, v) \
	if (d) { \
		if (Z_REFCOUNT_P(d) > 0) { \
			zval_ptr_dtor(&d); \
		} \
	} else { \
		phalcon_memory_observe(&d TSRMLS_CC); \
	} \
	ALLOC_ZVAL(d); \
	*d = *v; \
	zval_copy_ctor(d); \
	Z_SET_REFCOUNT_P(d, 1); \
	Z_UNSET_ISREF_P(d);

//#else

//#define PHALCON_INIT_NVAR(z) phalcon_init_nvar(&z TSRMLS_CC)
//#define PHALCON_CPY_WRT(d, v) phalcon_cpy_wrt(&d, v TSRMLS_CC)
//#define PHALCON_CPY_WRT_CTOR(d, v) phalcon_cpy_wrt_ctor(&d, v TSRMLS_CC)

//#endif

#define PHALCON_ALLOC_ZVAL_MM(z) \
	PHALCON_ALLOC_ZVAL(z); \
	phalcon_memory_observe(&z TSRMLS_CC);

#define PHALCON_SEPARATE_ARRAY(a) \
	{ \
		if (Z_REFCOUNT_P(a) > 1) { \
			zval *new_zv; \
			Z_DELREF_P(a); \
			ALLOC_ZVAL(new_zv); \
			INIT_PZVAL_COPY(new_zv, a); \
			a = new_zv; \
			zval_copy_ctor(new_zv); \
		} \
	}

#define PHALCON_SEPARATE(z) \
	{ \
		zval *orig_ptr = z; \
		if (Z_REFCOUNT_P(orig_ptr) > 1) { \
			Z_DELREF_P(orig_ptr); \
			ALLOC_ZVAL(z); \
			phalcon_memory_observe(&z TSRMLS_CC); \
			*z = *orig_ptr; \
			zval_copy_ctor(z); \
			Z_SET_REFCOUNT_P(z, 1); \
			Z_UNSET_ISREF_P(z); \
		} \
	}

#define PHALCON_SEPARATE_NMO(z) \
	{\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			Z_DELREF_P(orig_ptr);\
			ALLOC_ZVAL(z);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_SEPARATE_PARAM(z) \
	{\
		zval *orig_ptr = z;\
		if (Z_REFCOUNT_P(orig_ptr) > 1) {\
			ALLOC_ZVAL(z);\
			phalcon_memory_observe(&z TSRMLS_CC);\
			*z = *orig_ptr;\
			zval_copy_ctor(z);\
			Z_SET_REFCOUNT_P(z, 1);\
			Z_UNSET_ISREF_P(z);\
		}\
	}

#define PHALCON_SEPARATE_PARAM_NMO(z) { \
		zval *orig_ptr = z; \
		if (Z_REFCOUNT_P(orig_ptr) > 1) { \
			ALLOC_ZVAL(z); \
			*z = *orig_ptr; \
			zval_copy_ctor(z); \
			Z_SET_REFCOUNT_P(z, 1); \
			Z_UNSET_ISREF_P(z); \
		} \
	}

#define PHALCON_OBSERVE_VAR(var) \
	if (!var) { \
		phalcon_memory_observe(&var TSRMLS_CC); \
	} else { \
		zval_ptr_dtor(&var); \
	}




#define PHALCON_CALL_FUNC(return_value, func_name) if(phalcon_call_func(return_value, func_name, strlen(func_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_NORETURN(func_name) if(phalcon_call_func(NULL, func_name, strlen(func_name), 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS(return_value, func_name, param_count, params) if(phalcon_call_func_params(return_value, func_name, strlen(func_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_NORETURN(func_name, param_count, params) if(phalcon_call_func_params(NULL, func_name, strlen(func_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_1(return_value, func_name, param1) if(phalcon_call_func_one_param(return_value, func_name, strlen(func_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_1_NORETURN(func_name, param1) if(phalcon_call_func_one_param(NULL, func_name, strlen(func_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_2(return_value, func_name, param1, param2) if(phalcon_call_func_two_params(return_value, func_name, strlen(func_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_2_NORETURN(func_name, param1, param2) if(phalcon_call_func_two_params(NULL, func_name, strlen(func_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_3(return_value, func_name, param1, param2, param3) if(phalcon_call_func_three_params(return_value, func_name, strlen(func_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_FUNC_PARAMS_3_NORETURN(func_name, param1, param2, param3) if(phalcon_call_func_three_params(NULL, func_name, strlen(func_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_METHOD(return_value, object, method_name, check) if(phalcon_call_method(return_value, object, method_name, strlen(method_name), check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_NORETURN(object, method_name, check) if(phalcon_call_method(NULL, object, method_name, strlen(method_name), check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS(return_value, object, method_name, param_count, params, check) if(phalcon_call_method_params(return_value, object, method_name, strlen(method_name), param_count, params, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_NORETURN(object, method_name, param_count, params, check) if(phalcon_call_method_params(NULL, object, method_name, strlen(method_name), param_count, params, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_1(return_value, object, method_name, param1, check) if(phalcon_call_method_one_param(return_value, object, method_name, strlen(method_name), param1, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, method_name, param1, check) if(phalcon_call_method_one_param(NULL, object, method_name, strlen(method_name), param1, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_2(return_value, object, method_name, param1, param2, check) if(phalcon_call_method_two_params(return_value, object, method_name, strlen(method_name), param1, param2, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_2_NORETURN(object, method_name, param1, param2, check) if(phalcon_call_method_two_params(NULL, object, method_name, strlen(method_name), param1, param2, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_3(return_value, object, method_name, param1, param2, param3, check) if(phalcon_call_method_three_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_3_NORETURN(object, method_name, param1, param2, param3, check) if(phalcon_call_method_three_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_4(return_value, object, method_name, param1, param2, param3, param4, check) if(phalcon_call_method_four_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, param4, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_4_NORETURN(object, method_name, param1, param2, param3, param4, check) if(phalcon_call_method_four_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, param4, check, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_5(return_value, object, method_name, param1, param2, param3, param4, param5, check) if(phalcon_call_method_five_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, param4, param5, check, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_METHOD_PARAMS_5_NORETURN(object, method_name, param1, param2, param3, param4, param5, check) if(phalcon_call_method_five_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, param4, param5, check, 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_PARENT_PARAMS(return_value, object, active_class, method_name, param_count, params) if(phalcon_call_parent_func_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_NORETURN(object, active_class, method_name, param_count, params) if(phalcon_call_parent_func_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_1(return_value, object, active_class, method_name, param1) if(phalcon_call_parent_func_one_param(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_1_NORETURN(object, active_class, method_name, param1) if(phalcon_call_parent_func_one_param(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_2(return_value, object, active_class, method_name, param1, param2) if(phalcon_call_parent_func_two_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_2_NORETURN(object, active_class, method_name, param1, param2) if(phalcon_call_parent_func_two_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_3(return_value, object, active_class, method_name, param1, param2, param3) if(phalcon_call_parent_func_three_params(return_value, object, active_class, strlen(active_class), method_name, strlen(method_name), param1, param2, param3 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_PARAMS_3_NORETURN(object, active_class, method_name, param1, param2, param3) if(phalcon_call_parent_func_three_params(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT(return_value, object, active_class, method_name) if(phalcon_call_parent_func(return_value, object, active_class, strlen(active_class),method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_PARENT_NORETURN(object, active_class, method_name) if(phalcon_call_parent_func(NULL, object, active_class, strlen(active_class),method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;;

#define PHALCON_CALL_SELF_PARAMS(return_value, object, method_name, param_count, params) if(phalcon_call_self_func_params(return_value, object, method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_NORETURN(object, method_name, param_count, params) if(phalcon_call_self_func_params(NULL, object, method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_1(return_value, object, method_name, param1) if(phalcon_call_self_func_one_param(return_value, object, method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_1_NORETURN(object, method_name, param1) if(phalcon_call_self_func_one_param(NULL, object, method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_2(return_value, object, method_name, param1, param2) if(phalcon_call_self_func_two_params(return_value, object, method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_2_NORETURN(object, method_name, param1, param2) if(phalcon_call_self_func_two_params(NULL, object, method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_3(return_value, object, method_name, param1, param2, param3) if(phalcon_call_self_func_three_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_3_NORETURN(object, method_name, param1, param2, param3) if(phalcon_call_self_func_three_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_4(return_value, object, method_name, param1, param2, param3, param4) if(phalcon_call_self_func_four_params(return_value, object, method_name, strlen(method_name), param1, param2, param3, param4, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_PARAMS_4_NORETURN(object, method_name, param1, param2, param3, param4) if(phalcon_call_self_func_four_params(NULL, object, method_name, strlen(method_name), param1, param2, param3, param4, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF(return_value, object, method_name) if(phalcon_call_self_func(return_value, object, method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_SELF_NORETURN(object, method_name) if(phalcon_call_self_func(NULL, object, method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_STATIC_PARAMS(return_value, class_name, method_name, param_count, params) if(phalcon_call_static_func_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_NORETURN(class_name, method_name, param_count, params) if(phalcon_call_static_func_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param_count, params, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_1(return_value, class_name, method_name, param1) if(phalcon_call_static_func_one_param(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_1_NORETURN(class_name, method_name, param1) if(phalcon_call_static_func_one_param(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_2(return_value, class_name, method_name, param1, param2) if(phalcon_call_static_func_two_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_2_NORETURN(class_name, method_name, param1, param2) if(phalcon_call_static_func_two_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_3(return_value, class_name, method_name, param1, param2, param3) if(phalcon_call_static_func_three_params(return_value, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, param3, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_PARAMS_3_NORETURN(class_name, method_name, param1, param2, param3) if(phalcon_call_static_func_three_params(NULL, class_name, strlen(class_name), method_name, strlen(method_name), param1, param2, param3, 0 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC(return_value, class_name, method_name) if(phalcon_call_static_func(return_value, class_name, strlen(class_name), method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_NORETURN(class_name, method_name) if(phalcon_call_static_func(NULL, class_name, strlen(class_name), method_name, strlen(method_name), 0 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_ZVAL_STATIC(return_value, class_zval, method_name) if(phalcon_call_static_zval_func(return_value, class_zval, method_name, strlen(method_name), 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_ZVAL_PARAMS(return_value, class_zval, method_name, param_count, params) if(phalcon_call_static_zval_func_params(return_value, class_zval, method_name, strlen(method_name), param_count, params, 1 TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_STATIC_ZVAL_PARAMS_1(return_value, class_zval, method_name, param1) if(phalcon_call_static_zval_func_one_param(return_value, class_zval, method_name, strlen(method_name), param1, 1 TSRMLS_CC)==FAILURE) return;

#define PHALCON_CALL_USER_FUNC(return_value, handler) if(phalcon_call_user_func(return_value, handler TSRMLS_CC)==FAILURE) return;
#define PHALCON_CALL_USER_FUNC_ARRAY(return_value, handler, params) if(phalcon_call_user_func_array(return_value, handler, params TSRMLS_CC)==FAILURE) return;

/** Look for call scope */
int phalcon_find_scope(zend_class_entry *ce, char *method_name, int method_len TSRMLS_DC);
int phalcon_find_parent_scope(zend_class_entry *ce, char *active_class, int active_class_len, char *method_name, int method_len TSRMLS_DC);

/** Call single functions */
int phalcon_call_func(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC);
int phalcon_call_func_params(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_func_one_param(zval *return_value, char *func_name, int func_length, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_func_two_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_func_three_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on object instances */
int phalcon_call_method(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC);
int phalcon_call_method_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int check, int noreturn TSRMLS_DC);
int phalcon_call_method_five_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, zval *param5, int check, int noreturn TSRMLS_DC);

/** Call methods on parent class */
int phalcon_call_parent_func(zval *return_value, zval *object, char *active_class, int active_class_len,char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_parent_func_one_param(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_two_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_parent_func_three_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on self class */
int phalcon_call_self_func(zval *return_value, zval *object, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_self_func_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_self_func_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_self_func_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_self_func_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);
int phalcon_call_self_func_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int noreturn TSRMLS_DC);

/** Call methods on static classes */
int phalcon_call_static_func(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_static_func_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_static_func_one_param(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);
int phalcon_call_static_func_two_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC);
int phalcon_call_static_func_three_params(zval *return_value, char *class_name, int class_name_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC);

/** Call methods on static classes from a zval class name */
int phalcon_call_static_zval_func(zval *return_value, zval *mixed_name, char *method_name, int method_len, int noreturn TSRMLS_DC);
int phalcon_call_static_zval_func_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC);
int phalcon_call_static_zval_func_one_param(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC);

/** Fast call_user_func_array/call_user_func */
int phalcon_call_user_func(zval *return_value, zval *handler TSRMLS_DC);
int phalcon_call_user_func_array(zval *return_value, zval *handler, zval *params TSRMLS_DC);

/** Call functions */
int phalcon_call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC);
int phalcon_call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC);
int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC);
int phalcon_lookup_class_ex(const char *name, int name_length, int use_autoload, zend_class_entry ***ce TSRMLS_DC);
int phalcon_lookup_class(const char *name, int name_length, zend_class_entry ***ce TSRMLS_DC);

#if PHP_VERSION_ID <= 50309
#define PHALCON_CALL_USER_FUNCTION_EX phalcon_call_user_function_ex
#else
#define PHALCON_CALL_USER_FUNCTION_EX call_user_function_ex
#endif

#ifndef zend_error_noreturn
#define zend_error_noreturn zend_error
#endif



/** Check for index existence */
int PHALCON_FASTCALL phalcon_array_isset(const zval *arr, zval *index);
int PHALCON_FASTCALL phalcon_array_isset_long(const zval *arr, ulong index);
int PHALCON_FASTCALL phalcon_array_isset_string(const zval *arr, char *index, uint index_length);

/** Unset existing indexes */
int PHALCON_FASTCALL phalcon_array_unset(zval *arr, zval *index);
int PHALCON_FASTCALL phalcon_array_unset_long(zval *arr, ulong index);
int PHALCON_FASTCALL phalcon_array_unset_string(zval *arr, char *index, uint index_length);

/** Append elements to arrays */
int phalcon_array_append(zval **arr, zval *value, int separate TSRMLS_DC);
int phalcon_array_append_long(zval **arr, long value, int separate TSRMLS_DC);
int phalcon_array_append_string(zval **arr, char *value, uint value_length, int separate TSRMLS_DC);

/** Modify arrays */
int phalcon_array_update_zval(zval **arr, zval *index, zval **value, int flags TSRMLS_DC);
int phalcon_array_update_zval_bool(zval **arr, zval *index, int value, int flags TSRMLS_DC);
int phalcon_array_update_zval_string(zval **arr, zval *index, char *value, uint value_length, int flags TSRMLS_DC);

int phalcon_array_update_string(zval **arr, char *index, uint index_length, zval **value, int flags TSRMLS_DC);
int phalcon_array_update_string_bool(zval **arr, char *index, uint index_length, int value, int flags TSRMLS_DC);
int phalcon_array_update_string_long(zval **arr, char *index, uint index_length, long value, int flags TSRMLS_DC);
int phalcon_array_update_string_string(zval **arr, char *index, uint index_length, char *value, uint value_length, int flags TSRMLS_DC);

int phalcon_array_update_long(zval **arr, ulong index, zval **value, int flags TSRMLS_DC);
int phalcon_array_update_long_string(zval **arr, ulong index, char *value, uint value_length, int flags TSRMLS_DC);
int phalcon_array_update_long_long(zval **arr, ulong index, long value, int flags TSRMLS_DC);
int phalcon_array_update_long_bool(zval **arr, ulong index, int value, int flags TSRMLS_DC);

/** Update/Append two dimension arrays */
void phalcon_array_update_multi_2(zval **config, zval *index1, zval *index2, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_string_multi_2(zval **arr, zval *index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_long_long_multi_2(zval **arr, long index1, long index2, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_long_string_multi_2(zval **arr, long index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_append_multi_2(zval **arr, zval *index1, zval *value, int flags TSRMLS_DC);

/** Update/Append three dimension arrays */
void phalcon_array_update_zval_string_append_multi_3(zval **arr, zval *index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_zval_zval_zval_multi_3(zval **arr, zval *index1, zval *index2, zval *index3, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_string_zval_zval_multi_3(zval **arr, zval *index1, zval *index2, char *index3, uint index3_length, zval **value, int flags TSRMLS_DC);
void phalcon_array_update_zval_string_string_multi_3(zval **arr, zval *index1, char *index2, uint index2_length, char *index3, uint index3_length, zval **value, int flags TSRMLS_DC);

/** Fetch items from arrays */
int phalcon_array_fetch(zval **return_value, zval *arr, zval *index, int silent TSRMLS_DC);
int phalcon_array_fetch_string(zval **return_value, zval *arr, char *index, uint index_length, int silent TSRMLS_DC);
int phalcon_array_fetch_long(zval **return_value, zval *arr, ulong index, int silent TSRMLS_DC);





/** Class Retrieving/Checking */
int phalcon_class_exists(zval *class_name TSRMLS_DC);
void phalcon_get_class(zval *result, zval *object TSRMLS_DC);
zend_class_entry *phalcon_fetch_class(zval *class_name TSRMLS_DC);

/** Class constants */
int phalcon_get_class_constant(zval *return_value, zend_class_entry *ce, char *constant_name, int constant_length TSRMLS_DC);

/** Cloning/Instance of*/
int phalcon_clone(zval *destiny, zval *obj TSRMLS_DC);
int phalcon_instance_of(zval *result, const zval *object, const zend_class_entry *ce TSRMLS_DC);
int phalcon_is_instance_of(zval *object, char *class_name, unsigned int class_length TSRMLS_DC);

/** Method exists */
int phalcon_method_exists(zval *object, zval *method_name TSRMLS_DC);
int phalcon_method_exists_ex(zval *object, char *method_name, int method_len TSRMLS_DC);

/** Isset properties */
int phalcon_isset_property(zval *object, char *property_name, int property_length TSRMLS_DC);
int phalcon_isset_property_zval(zval *object, zval *property TSRMLS_DC);

/** Reading properties */
int phalcon_read_property(zval **result, zval *object, char *property_name, int property_length, int silent TSRMLS_DC);
int phalcon_read_property_zval(zval **result, zval *object, zval *property, int silent TSRMLS_DC);
int phalcon_return_property(zval *return_value, zval *object, char *property_name, int property_length TSRMLS_DC);

/** Updating properties */
int phalcon_update_property_long(zval *obj, char *property_name, int property_length, long value TSRMLS_DC);
int phalcon_update_property_string(zval *obj, char *property_name, int property_length, char *value TSRMLS_DC);
int phalcon_update_property_bool(zval *obj, char *property_name, int property_length, int value TSRMLS_DC);
int phalcon_update_property_null(zval *obj, char *property_name, int property_length TSRMLS_DC);
int phalcon_update_property_zval(zval *obj, char *property_name, int property_length, zval *value TSRMLS_DC);
int phalcon_update_property_zval_zval(zval *obj, zval *property, zval *value TSRMLS_DC);
int phalcon_update_property_empty_array(zend_class_entry *ce, zval *object, char *property, unsigned int property_length TSRMLS_DC);

/** Static properties */
int phalcon_read_static_property(zval **result, char *class_name, int class_length, char *property_name, int property_length TSRMLS_DC);
int phalcon_update_static_property(char *class_name, int class_length, char *name, int name_length, zval *value TSRMLS_DC);

/** Create instances */
int phalcon_create_instance(zval *return_value, zval *class_name TSRMLS_DC);
int phalcon_create_instance_params(zval *return_value, zval *class_name, zval *params TSRMLS_DC);



/** Fast char position */
int phalcon_memnstr(zval *haystack, zval *needle TSRMLS_DC);
int phalcon_memnstr_str(zval *haystack, char *needle, int needle_length TSRMLS_DC);

/** Function replacement */
void phalcon_fast_strlen(zval *return_value, zval *str);
void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC);
void phalcon_fast_join_str(zval *result, char *glue, unsigned int glue_length, zval *pieces TSRMLS_DC);
void phalcon_fast_explode(zval *result, zval *delimiter, zval *str TSRMLS_DC);
void phalcon_fast_strpos(zval *return_value, zval *haystack, zval *needle TSRMLS_DC);
void phalcon_fast_strpos_str(zval *return_value, zval *haystack, char *needle, int needle_length TSRMLS_DC);
void phalcon_fast_stripos_str(zval *return_value, zval *haystack, char *needle, int needle_length TSRMLS_DC);
void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject TSRMLS_DC);

/** Camelize/Uncamelize */
void phalcon_camelize(zval *return_value, zval *str TSRMLS_DC);
void phalcon_uncamelize(zval *return_value, zval *str TSRMLS_DC);

/** Extract named parameters */
void phalcon_extract_named_params(zval *return_value, zval *str, zval *matches);

/** Start with */
int phalcon_start_with(zval *str, zval *compared);
int phalcon_start_with_str(zval *str, char *compared, unsigned int compared_length);



/** Operators */
#define PHALCON_COMPARE_STRING(op1, op2) phalcon_compare_strict_string(op1, op2, strlen(op2))

/** strict boolean comparison */
#define PHALCON_IS_FALSE(var) Z_TYPE_P(var) == IS_BOOL && !Z_BVAL_P(var)
#define PHALCON_IS_TRUE(var) Z_TYPE_P(var) == IS_BOOL && Z_BVAL_P(var)

#define PHALCON_IS_NOT_FALSE(var) Z_TYPE_P(var) != IS_BOOL || (Z_TYPE_P(var) == IS_BOOL && Z_BVAL_P(var))
#define PHALCON_IS_NOT_TRUE(var) Z_TYPE_P(var) != IS_BOOL || (Z_TYPE_P(var) == IS_BOOL && !Z_BVAL_P(var))

/** SQL null empty **/
#define PHALCON_IS_EMPTY(var) Z_TYPE_P(var) == IS_NULL || (Z_TYPE_P(var) == IS_STRING && !Z_STRLEN_P(var))
#define PHALCON_IS_NOT_EMPTY(var) !(Z_TYPE_P(var) == IS_NULL || (Z_TYPE_P(var) == IS_STRING && !Z_STRLEN_P(var)))

/** Operator functions */
int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC);
int phalcon_and_function(zval *result, zval *left, zval *right);

void phalcon_concat_self(zval *left, zval *right TSRMLS_DC);
void phalcon_concat_self_str(zval *left, char *right, int right_length TSRMLS_DC);

int phalcon_compare_strict_string(zval *op1, char *op2, int op2_length);

int phalcon_compare_strict_long(zval *op1, long op2 TSRMLS_DC);

int phalcon_is_smaller_strict_long(zval *op1, long op2 TSRMLS_DC);
int phalcon_is_smaller_or_equal_strict_long(zval *op1, long op2 TSRMLS_DC);

void phalcon_cast(zval *result, zval *var, zend_uint type);




#define PHALCON_CONCAT_SV(result, op1, op2) \
	 phalcon_concat_sv(result, op1, strlen(op1), op2, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SV(result, op1, op2) \
	 phalcon_concat_sv(result, op1, strlen(op1), op2, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVS(result, op1, op2, op3) \
	 phalcon_concat_svs(result, op1, strlen(op1), op2, op3, strlen(op3), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVS(result, op1, op2, op3) \
	 phalcon_concat_svs(result, op1, strlen(op1), op2, op3, strlen(op3), 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_svsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_svsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVS(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVS(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVSV(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_svsvsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVSV(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_svsvsv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVSVS(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_svsvsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6, op7, strlen(op7), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVSVS(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_svsvsvs(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, strlen(op5), op6, op7, strlen(op7), 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvv(result, op1, strlen(op1), op2, op3, strlen(op3), op4, op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVV(result, op1, op2, op3) \
	 phalcon_concat_svv(result, op1, strlen(op1), op2, op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVV(result, op1, op2, op3) \
	 phalcon_concat_svv(result, op1, strlen(op1), op2, op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VS(result, op1, op2) \
	 phalcon_concat_vs(result, op1, op2, strlen(op2), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VS(result, op1, op2) \
	 phalcon_concat_vs(result, op1, op2, strlen(op2), 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSV(result, op1, op2, op3) \
	 phalcon_concat_vsv(result, op1, op2, strlen(op2), op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSV(result, op1, op2, op3) \
	 phalcon_concat_vsv(result, op1, op2, strlen(op2), op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvs(result, op1, op2, strlen(op2), op3, op4, strlen(op4), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvs(result, op1, op2, strlen(op2), op3, op4, strlen(op4), 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvsv(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvsv(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSVS(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_vsvsvs(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, op6, strlen(op6), 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSVS(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_vsvsvs(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, op6, strlen(op6), 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSVSV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vsvsvsv(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, op6, strlen(op6), op7, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSVSV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vsvsvsv(result, op1, op2, strlen(op2), op3, op4, strlen(op4), op5, op6, strlen(op6), op7, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VV(result, op1, op2) \
	 phalcon_concat_vv(result, op1, op2, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VV(result, op1, op2) \
	 phalcon_concat_vv(result, op1, op2, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvsv(result, op1, op2, op3, strlen(op3), op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvsv(result, op1, op2, op3, strlen(op3), op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVV(result, op1, op2, op3) \
	 phalcon_concat_vvv(result, op1, op2, op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVV(result, op1, op2, op3) \
	 phalcon_concat_vvv(result, op1, op2, op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvvv(result, op1, op2, op3, op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvvv(result, op1, op2, op3, op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvvv(result, op1, op2, op3, op4, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvvv(result, op1, op2, op3, op4, op5, 1 TSRMLS_CC);


void phalcon_concat_sv(zval *result, char *op1, zend_uint op1_len, zval *op2, int self_var TSRMLS_DC);
void phalcon_concat_svs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, int self_var TSRMLS_DC);
void phalcon_concat_svsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC);
void phalcon_concat_svsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, int self_var TSRMLS_DC);
void phalcon_concat_svsvsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, int self_var TSRMLS_DC);
void phalcon_concat_svsvsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, char *op7, zend_uint op7_len, int self_var TSRMLS_DC);
void phalcon_concat_svsvv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, zval *op5, int self_var TSRMLS_DC);
void phalcon_concat_svv(zval *result, char *op1, zend_uint op1_len, zval *op2, zval *op3, int self_var TSRMLS_DC);
void phalcon_concat_vs(zval *result, zval *op1, char *op2, zend_uint op2_len, int self_var TSRMLS_DC);
void phalcon_concat_vsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, int self_var TSRMLS_DC);
void phalcon_concat_vsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, int self_var TSRMLS_DC);
void phalcon_concat_vsvsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC);
void phalcon_concat_vsvsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, char *op6, zend_uint op6_len, int self_var TSRMLS_DC);
void phalcon_concat_vsvsvsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, char *op6, zend_uint op6_len, zval *op7, int self_var TSRMLS_DC);
void phalcon_concat_vv(zval *result, zval *op1, zval *op2, int self_var TSRMLS_DC);
void phalcon_concat_vvsv(zval *result, zval *op1, zval *op2, char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC);
void phalcon_concat_vvv(zval *result, zval *op1, zval *op2, zval *op3, int self_var TSRMLS_DC);
void phalcon_concat_vvvv(zval *result, zval *op1, zval *op2, zval *op3, zval *op4, int self_var TSRMLS_DC);
void phalcon_concat_vvvvv(zval *result, zval *op1, zval *op2, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC);




/** Exceptions */
#define PHALCON_THROW_EXCEPTION_STR(class_entry, message) phalcon_throw_exception_string(class_entry, message, strlen(message) TSRMLS_CC);
#define PHALCON_THROW_EXCEPTION_ZVAL(class_entry, message) phalcon_throw_exception_zval(class_entry, message TSRMLS_CC);

/** Throw Exceptions */
void phalcon_throw_exception(zval *object TSRMLS_DC);
void phalcon_throw_exception_string(zend_class_entry *ce, char *message, zend_uint message_len TSRMLS_DC);
void phalcon_throw_exception_zval(zend_class_entry *ce, zval *message TSRMLS_DC);
void phalcon_throw_exception_internal(zval *exception TSRMLS_DC);

/** Catch Exceptions */
void phalcon_try_execute(zval *success, zval *return_value, zval *call_object, zval *params, zval **exception TSRMLS_DC);




int PHALCON_FASTCALL phalcon_require(zval *require_path TSRMLS_DC);
int PHALCON_FASTCALL phalcon_require_ret(zval *return_value, zval *require_path TSRMLS_DC);



#ifdef HAVE_CONFIG_H
#endif




void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC){
    phalcon_globals->start_memory = NULL;
	phalcon_globals->active_memory = NULL;
	#ifndef PHALCON_RELEASE
	phalcon_globals->phalcon_stack_stats = 0;
	phalcon_globals->phalcon_number_grows = 0;
	#endif
}

int phalcon_init_global(char *global, unsigned int global_length TSRMLS_DC){
	#if PHP_VERSION_ID < 50400
	zend_bool jit_initialization = (PG(auto_globals_jit) && !PG(register_globals) && !PG(register_long_arrays));
	if (jit_initialization) {
		return zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}
	#else
	if (PG(auto_globals_jit)) {
		return zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}
	#endif
	return SUCCESS;
}

int phalcon_get_global(zval **arr, char *global, unsigned int global_length TSRMLS_DC){

	zval **gv;

	zend_bool jit_initialization = PG(auto_globals_jit);
	if (jit_initialization) {
		zend_is_auto_global(global, global_length-1 TSRMLS_CC);
	}

	if (&EG(symbol_table)) {
		if( zend_hash_find(&EG(symbol_table), global, global_length, (void **) &gv) == SUCCESS) {
			if (Z_TYPE_PP(gv) == IS_ARRAY) {
				*arr = *gv;
			} else {
				PHALCON_INIT_VAR(*arr);
				array_init(*arr);
			}
		}
	}

	if (!*arr) {
		PHALCON_INIT_VAR(*arr);
		array_init(*arr);
	}

	return SUCCESS;
}

void phalcon_fast_count(zval *result, zval *value TSRMLS_DC){
	if (Z_TYPE_P(value) == IS_ARRAY) {
		ZVAL_LONG(result, zend_hash_num_elements(Z_ARRVAL_P(value)));
		return;
	} else {
		if (Z_TYPE_P(value) == IS_OBJECT) {

			#ifdef HAVE_SPL
			zval *retval = NULL;
			#endif

			if (Z_OBJ_HT_P(value)->count_elements) {
				ZVAL_LONG(result, 1);
				if (SUCCESS == Z_OBJ_HT(*value)->count_elements(value, &Z_LVAL_P(result) TSRMLS_CC)) {
					return;
				}
			}

			#ifdef HAVE_SPL
			if (Z_OBJ_HT_P(value)->get_class_entry && instanceof_function(Z_OBJCE_P(value), spl_ce_Countable TSRMLS_CC)) {
				zend_call_method_with_0_params(&value, NULL, NULL, "count", &retval);
				if (retval) {
					convert_to_long_ex(&retval);
					ZVAL_LONG(result, Z_LVAL_P(retval));
					zval_ptr_dtor(&retval);
				}
				return;
			}
			#endif

			ZVAL_LONG(result, 0);
			return;

		} else {
			if (Z_TYPE_P(value) == IS_NULL) {
				ZVAL_LONG(result, 0);
				return;
			}
		}
	}
	ZVAL_LONG(result, 1);
}

int phalcon_fast_count_ev(zval *value TSRMLS_DC){

	long count = 0;

	if (Z_TYPE_P(value) == IS_ARRAY) {
		return (int) zend_hash_num_elements(Z_ARRVAL_P(value)) > 0;
	} else {
		if (Z_TYPE_P(value) == IS_OBJECT) {

			#ifdef HAVE_SPL
			zval *retval = NULL;
			#endif

			if (Z_OBJ_HT_P(value)->count_elements) {
				Z_OBJ_HT(*value)->count_elements(value, &count TSRMLS_CC);
				return (int) count > 0;
			}

			#ifdef HAVE_SPL
			if (Z_OBJ_HT_P(value)->get_class_entry && instanceof_function(Z_OBJCE_P(value), spl_ce_Countable TSRMLS_CC)) {
				zend_call_method_with_0_params(&value, NULL, NULL, "count", &retval);
				if (retval) {
					convert_to_long_ex(&retval);
					count = Z_LVAL_P(retval);
					zval_ptr_dtor(&retval);
					return (int) count > 0;
				}
				return 0;
			}
			#endif

			return 0;
		} else {
			if (Z_TYPE_P(value) == IS_NULL) {
				return 0;
			}
		}
	}
	return 1;
}

int phalcon_function_exists_ex(char *method_name, unsigned int method_len TSRMLS_DC){

	if (zend_hash_exists(CG(function_table), method_name, method_len)) {
		return SUCCESS;
	}

	return FAILURE;
}

int phalcon_is_callable(zval *var TSRMLS_DC){

	char *error = NULL;
	zend_bool retval;

	retval = zend_is_callable_ex(var, NULL, 0, NULL, NULL, NULL, &error TSRMLS_CC);
	if (error) {
		efree(error);
	}

	return (int) retval;
}

int phalcon_filter_alphanum(zval *result, zval *param){

	int i, ch, alloc = 0;
	char temp[2048];
	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(param) != IS_STRING) {
		zend_make_printable_zval(param, &copy, &use_copy);
		if (use_copy) {
			param = &copy;
		}
	}

	for (i=0; i < Z_STRLEN_P(param) && i < 2048; i++) {
		ch = Z_STRVAL_P(param)[i];
		if ((ch>96 && ch<123)||(ch>64 && ch<91)||(ch>47 && ch<58)) {
			temp[alloc] = ch;
			alloc++;
		}
	}

	if (alloc > 0) {
		Z_TYPE_P(result) = IS_STRING;
		Z_STRLEN_P(result) = alloc;
		Z_STRVAL_P(result) = (char *) emalloc(alloc+1);
		memcpy(Z_STRVAL_P(result), temp, alloc);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	} else {
		ZVAL_STRING(result, "", 1);
	}

	if (use_copy) {
		zval_dtor(param);
	}

	return SUCCESS;
}

int phalcon_filter_identifier(zval *result, zval *param){

	int i, ch, alloc = 0;
	char temp[2048];
	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(param) != IS_STRING) {
		zend_make_printable_zval(param, &copy, &use_copy);
		if (use_copy) {
			param = &copy;
		}
	}

	for (i=0; i < Z_STRLEN_P(param) && i < 2048; i++) {
		ch = Z_STRVAL_P(param)[i];
		if ((ch>96 && ch<123) || (ch>64 && ch<91) || (ch>47 && ch<58) || ch==95) {
			temp[alloc] = ch;
			alloc++;
		}
	}

	if (alloc > 0) {
		Z_TYPE_P(result) = IS_STRING;
		Z_STRLEN_P(result) = alloc;
		Z_STRVAL_P(result) = (char *) emalloc(alloc+1);
		memcpy(Z_STRVAL_P(result), temp, alloc);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
	} else {
		ZVAL_STRING(result, "", 1);
	}

	if (use_copy) {
		zval_dtor(param);
	}

	return SUCCESS;
}

int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC){

	if (!EG(active_symbol_table)) {
		zend_rebuild_symbol_table(TSRMLS_C);
	}

	if (EG(active_symbol_table)) {
		if (Z_TYPE_P(key_name) == IS_STRING) {
			Z_ADDREF_P(value);
			zend_hash_update(EG(active_symbol_table), Z_STRVAL_P(key_name), Z_STRLEN_P(key_name)+1, &value, sizeof(zval *), NULL);
			if (EG(exception)) {
				return FAILURE;
			}
		}
	}

	return SUCCESS;
}

int phalcon_set_symbol_str(char *key_name, unsigned int key_length, zval *value TSRMLS_DC){

	if (!EG(active_symbol_table)) {
		zend_rebuild_symbol_table(TSRMLS_C);
	}

	if (&EG(symbol_table)) {
		Z_ADDREF_P(value);
		zend_hash_update(&EG(symbol_table), key_name, key_length, &value, sizeof(zval *), NULL);
		if (EG(exception)) {
			return FAILURE;
		}
	}

	return SUCCESS;
}

int phalcon_valid_foreach(zval *arr TSRMLS_DC){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Invalid argument supplied for foreach()");
		phalcon_memory_restore_stack(TSRMLS_C);
		return 0;
	}
	return 1;
}

void phalcon_inherit_not_found(char *class_name, char *inherit_name){
	fprintf(stderr, "Phalcon Error: Class to extend '%s' was not found when registering class '%s'\n", class_name, inherit_name);
}




#ifdef HAVE_CONFIG_H
#endif


inline void phalcon_init_nvar(zval **var TSRMLS_DC){
	if (*var) {
		if (Z_REFCOUNT_PP(var) > 1) {
			Z_DELREF_PP(var);
			ALLOC_ZVAL(*var);
			Z_SET_REFCOUNT_PP(var, 1);
			Z_UNSET_ISREF_PP(var);
		} else {
			zval_ptr_dtor(var);
			PHALCON_ALLOC_ZVAL(*var);
		}
	} else {
		phalcon_memory_alloc(var TSRMLS_CC);
	}
}

inline void phalcon_cpy_wrt(zval **dest, zval *var TSRMLS_DC){
	if (*dest) {
		if (Z_REFCOUNT_PP(dest) > 0) {
			zval_ptr_dtor(dest);
		}
	} else {
		phalcon_memory_observe(dest TSRMLS_CC);
	}
	Z_ADDREF_P(var);
	*dest = var;
}

inline void phalcon_cpy_wrt_ctor(zval **dest, zval *var TSRMLS_DC){
	if (*dest) {
		if (Z_REFCOUNT_PP(dest) > 0) {
			zval_ptr_dtor(dest);
		}
	} else {
		phalcon_memory_observe(dest TSRMLS_CC);
	}
	Z_ADDREF_P(var);
	*dest = var;
	zval_copy_ctor(*dest);
	Z_SET_REFCOUNT_PP(dest, 1);
	Z_UNSET_ISREF_PP(dest);
}

int PHALCON_FASTCALL phalcon_memory_grow_stack(TSRMLS_D){

	phalcon_memory_entry *entry;

	if (!PHALCON_GLOBAL(start_memory)) {
		PHALCON_GLOBAL(start_memory) = (phalcon_memory_entry *) emalloc(sizeof(phalcon_memory_entry));
		PHALCON_GLOBAL(start_memory)->pointer = -1;
		PHALCON_GLOBAL(start_memory)->prev = NULL;
		PHALCON_GLOBAL(start_memory)->next = NULL;
		PHALCON_GLOBAL(active_memory) = PHALCON_GLOBAL(start_memory);
	}

	entry = (phalcon_memory_entry *) emalloc(sizeof(phalcon_memory_entry));
	entry->addresses[0] = NULL;
	entry->pointer = -1;
	entry->prev = PHALCON_GLOBAL(active_memory);
	PHALCON_GLOBAL(active_memory)->next = entry;
	PHALCON_GLOBAL(active_memory) = entry;

	return SUCCESS;
}

int PHALCON_FASTCALL phalcon_memory_restore_stack(TSRMLS_D){

	register int i;
	phalcon_memory_entry *prev, *active_memory = PHALCON_GLOBAL(active_memory);

	if (active_memory != NULL) {

		/*#ifndef PHALCON_RELEASE
		//if(!PHALCON_GLOBAL(phalcon_stack_stats)){
			PHALCON_GLOBAL(phalcon_stack_stats) += active_memory->pointer;
			PHALCON_GLOBAL(phalcon_number_grows)++;
		//} else {
		//	if (active_memory->pointer > PHALCON_GLOBAL(phalcon_stack_stats)) {
		//		PHALCON_GLOBAL(phalcon_stack_stats) = active_memory->pointer;
		//	}
		//}
		#endif*/

		if (active_memory->pointer > -1) {
			for (i = active_memory->pointer; i>=0; i--) {
				if(active_memory->addresses[i] != NULL){
					if(*active_memory->addresses[i] != NULL ){
						if (Z_REFCOUNT_PP(active_memory->addresses[i])-1 == 0) {
							zval_ptr_dtor(active_memory->addresses[i]);
							//*active_memory->addresses[i] = NULL;
							active_memory->addresses[i] = NULL;
						} else {
							Z_DELREF_PP(active_memory->addresses[i]);
							if (Z_REFCOUNT_PP(active_memory->addresses[i]) == 1) {
								active_memory->addresses[i] = NULL;
							}
						}
					}
				}
			}
		}

		prev = active_memory->prev;
		efree(PHALCON_GLOBAL(active_memory));
		PHALCON_GLOBAL(active_memory) = prev;
		if (prev != NULL) {
			PHALCON_GLOBAL(active_memory)->next = NULL;
			if (PHALCON_GLOBAL(active_memory) == PHALCON_GLOBAL(start_memory)) {
				efree(PHALCON_GLOBAL(active_memory));
				PHALCON_GLOBAL(start_memory) = NULL;
				PHALCON_GLOBAL(active_memory) = NULL;
			}
		} else {
			PHALCON_GLOBAL(start_memory) = NULL;
			PHALCON_GLOBAL(active_memory) = NULL;
		}

	} else {
		return FAILURE;
	}

	return SUCCESS;
}

int PHALCON_FASTCALL phalcon_clean_shutdown_stack(TSRMLS_D){

	#if !ZEND_DEBUG && PHP_VERSION_ID <= 50400

	phalcon_memory_entry *prev, *active_memory = PHALCON_GLOBAL(active_memory);

	while (active_memory != NULL) {

		prev = active_memory->prev;
		efree(active_memory);
		active_memory = prev;
		if (prev != NULL) {
			active_memory->next = NULL;
			if (active_memory == PHALCON_GLOBAL(start_memory)) {
				efree(active_memory);
				PHALCON_GLOBAL(start_memory) = NULL;
				active_memory = NULL;
			}
		} else {
			PHALCON_GLOBAL(start_memory) = NULL;
			active_memory = NULL;
		}

	}

	#else

	PHALCON_GLOBAL(active_memory) = NULL;
	PHALCON_GLOBAL(start_memory) = NULL;

	#endif

	return SUCCESS;

}

int PHALCON_FASTCALL phalcon_memory_observe(zval **var TSRMLS_DC){
	phalcon_memory_entry *active_memory = PHALCON_GLOBAL(active_memory);
	active_memory->pointer++;
	#ifndef PHALCON_RELEASE
	if (active_memory->pointer >= (PHALCON_MAX_MEMORY_STACK-1)) {
		fprintf(stderr, "ERROR: Phalcon memory stack is too small %d\n", PHALCON_MAX_MEMORY_STACK);
		return FAILURE;
	}
	#endif
	active_memory->addresses[active_memory->pointer] = var;
	active_memory->addresses[active_memory->pointer+1] = NULL;
	return SUCCESS;
}

int PHALCON_FASTCALL phalcon_memory_alloc(zval **var TSRMLS_DC){
	phalcon_memory_entry *active_memory = PHALCON_GLOBAL(active_memory);
	active_memory->pointer++;
	#ifndef PHALCON_RELEASE
	if (active_memory->pointer >= (PHALCON_MAX_MEMORY_STACK-1)) {
		fprintf(stderr, "ERROR: Phalcon memory stack is too small %d\n", PHALCON_MAX_MEMORY_STACK);
		return FAILURE;
	}
	#endif
	active_memory->addresses[active_memory->pointer] = var;
	active_memory->addresses[active_memory->pointer+1] = NULL;
	ALLOC_ZVAL(*var);
	INIT_PZVAL(*var);
	ZVAL_NULL(*var);
	return SUCCESS;
}

int PHALCON_FASTCALL phalcon_memory_remove(zval **var TSRMLS_DC){
	zval_ptr_dtor(var);
	*var = NULL;
	return SUCCESS;
}

int PHALCON_FASTCALL phalcon_clean_restore_stack(TSRMLS_D){
	while (PHALCON_GLOBAL(active_memory) != NULL) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}
	return SUCCESS;
}

void PHALCON_FASTCALL phalcon_copy_ctor(zval *destiny, zval *origin){
	if (Z_REFCOUNT_P(origin) > 1) {
		zval_copy_ctor(destiny);
	} else {
		ZVAL_NULL(origin);
	}
}



#ifdef HAVE_CONFIG_H
#endif




inline int phalcon_find_scope(zend_class_entry *ce, char *method_name, int method_len TSRMLS_DC){
	char *lcname = zend_str_tolower_dup(method_name, method_len);
	while (ce) {
		if (zend_hash_exists(&ce->function_table, lcname, method_len+1)) {
			EG(scope) = ce;
			efree(lcname);
			return SUCCESS;
		}
		ce = ce->parent;
	}
	if (lcname) {
		efree(lcname);
	}
	return FAILURE;
}

inline int phalcon_find_parent_scope(zend_class_entry *ce, char *active_class, int active_class_len, char *method_name, int method_len TSRMLS_DC){
	char *lcname = zend_str_tolower_dup(method_name, method_len);
	while (ce) {
		if (ce->name_length == active_class_len) {
			if (!zend_binary_strcasecmp(ce->name, ce->name_length, active_class, active_class_len)) {
				if (zend_hash_exists(&ce->function_table, lcname, method_len+1)) {
					EG(scope) = ce;
					efree(lcname);
					return SUCCESS;
				}
			}
		}
		ce = ce->parent;
	}
	if (lcname) {
		efree(lcname);
	}
	return FAILURE;
}

static inline int phalcon_call_func_normal(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, func_name, func_length, 0);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s()", func_name);
	}

	ZVAL_NULL(fn);
	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_func(zval *return_value, char *func_name, int func_length, int noreturn TSRMLS_DC){
	return phalcon_call_func_normal(return_value, func_name, func_length, noreturn TSRMLS_CC);
}

static inline int phalcon_call_func_params_normal(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, func_name, func_length, 0);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s()", func_name);
	}

	ZVAL_NULL(fn);
	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_func_params(zval *return_value, char *func_name, int func_length, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){
	return phalcon_call_func_params_normal(return_value, func_name, func_length, param_count, params, noreturn TSRMLS_CC);
}

int phalcon_call_func_one_param(zval *return_value, char *func_name, int func_length, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_func_params(return_value, func_name, func_length, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_func_two_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_func_params(return_value, func_name, func_length, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_func_three_params(zval *return_value, char *func_name, int func_length, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_func_params(return_value, func_name, func_length, 3, params, noreturn TSRMLS_CC);
}

static inline int phalcon_call_method_normal(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zend_class_entry *active_scope = NULL;

	if (check) {
		if (!zend_hash_exists(&Z_OBJCE_P(object)->function_table, method_name, strlen(method_name)+1)) {
			return SUCCESS;
		}
	}

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, method_name, method_len, 0);

	if (Z_TYPE_P(object) == IS_OBJECT) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
		status = phalcon_call_user_function(&Z_OBJCE_P(object)->function_table, &object, fn, return_value, 0, NULL TSRMLS_CC);
		if (status == FAILURE) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined method %s()", Z_STRVAL_P(fn));
		}
		EG(scope) = active_scope;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to method %s() on a non object", Z_STRVAL_P(fn));
		status = FAILURE;
	}

	ZVAL_NULL(fn);
	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_method(zval *return_value, zval *object, char *method_name, int method_len, int check, int noreturn TSRMLS_DC){
	return phalcon_call_method_normal(return_value, object, method_name, method_len, check, noreturn TSRMLS_CC);
}

static inline int phalcon_call_method_params_normal(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zend_class_entry *ce, *active_scope = NULL;

	if (check) {
		if (!zend_hash_exists(&Z_OBJCE_P(object)->function_table, method_name, method_len+1)) {
			return SUCCESS;
		}
	}

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRINGL(fn, method_name, method_len, 0);

	if (Z_TYPE_P(object) == IS_OBJECT) {
		active_scope = EG(scope);
		ce = Z_OBJCE_P(object);
		phalcon_find_scope(ce, method_name, method_len TSRMLS_CC);
		status = phalcon_call_user_function(&ce->function_table, &object, fn, return_value, param_count, params TSRMLS_CC);
		if (status == FAILURE) {
			EG(scope) = active_scope;
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined method %s() on class %s", Z_STRVAL_P(fn), Z_OBJCE_P(object)->name);
			status = FAILURE;
		}
		EG(scope) = active_scope;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to method %s() on a non object", Z_STRVAL_P(fn));
		status = FAILURE;
	}

	ZVAL_NULL(fn);
	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
		return_value = NULL;
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_method_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int check, int noreturn TSRMLS_DC){
	return phalcon_call_method_params_normal(return_value, object, method_name, method_len, param_count, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_method_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 1, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_method_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 2, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_method_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 3, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_method_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3, param4 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 4, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_method_five_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, zval *param5, int check, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3, param4, param5 };
	return phalcon_call_method_params(return_value, object, method_name, method_len, 5, params, check, noreturn TSRMLS_CC);
}

int phalcon_call_parent_func(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_parent_scope(Z_OBJCE_P(object), active_class, active_class_len, method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func(return_value, "parent", strlen("parent"), method_name, method_len, noreturn TSRMLS_CC);
	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

inline int phalcon_call_static_func_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, class_name, class_length, 1);
	add_next_index_stringl(fn, method_name, method_len, 1);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", class_name, method_name);
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_parent_func_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_parent_scope(Z_OBJCE_P(object), active_class, active_class_len, method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func_params(return_value, "parent", strlen("parent"), method_name, method_len, param_count, params, noreturn TSRMLS_CC);

	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

int phalcon_call_parent_func_one_param(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_parent_func_two_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_parent_func_three_params(zval *return_value, zval *object, char *active_class, int active_class_len, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_parent_func_params(return_value, object, active_class, active_class_len, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func(zval *return_value, zval *object, char *method_name, int method_len, int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func(return_value, SL("self"), method_name, method_len, noreturn TSRMLS_CC);

	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

inline int phalcon_call_self_func_params(zval *return_value, zval *object, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	int success;
	zend_class_entry *active_scope = NULL;

	if (object) {
		active_scope = EG(scope);
		phalcon_find_scope(Z_OBJCE_P(object), method_name, method_len TSRMLS_CC);
	}

	success = phalcon_call_static_func_params(return_value, SL("self"), method_name, method_len, param_count, params, noreturn TSRMLS_CC);
	if (object) {
		EG(scope) = active_scope;
	}

	return success;
}

int phalcon_call_self_func_one_param(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func_two_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func_three_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

int phalcon_call_self_func_four_params(zval *return_value, zval *object, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, zval *param4, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3, param4 };
	return phalcon_call_self_func_params(return_value, object, method_name, method_len, 4, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_func(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, class_name, class_length, 1);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", class_name, method_name);
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_static_func_one_param(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_func_two_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_func_three_params(zval *return_value, char *class_name, int class_length, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_static_func_params(return_value, class_name, class_length, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_zval_func(zval *return_value, zval *mixed_name, char *method_name, int method_len, int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_zval(fn, mixed_name);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 0, NULL TSRMLS_CC);
	if (status == FAILURE) {
		if(Z_TYPE_P(mixed_name) == IS_STRING) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", Z_STRVAL_P(mixed_name), method_name);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function not-callable::%s()", method_name);
		}
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

inline int phalcon_call_static_zval_func_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status = FAILURE;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_zval(fn, mixed_name);
	add_next_index_stringl(fn, method_name, method_len, 1);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		if(Z_TYPE_P(mixed_name) == IS_STRING) {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", Z_STRVAL_P(mixed_name), method_name);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function not-callable::%s()", method_name);
		}
	}

	zval_ptr_dtor(&fn);

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_static_zval_func_one_param(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, int noreturn TSRMLS_DC){
	zval *params[] = { param1 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 1, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_zval_func_two_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, zval *param2, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 2, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_zval_func_three_params(zval *return_value, zval *mixed_name, char *method_name, int method_len, zval *param1, zval *param2, zval *param3, int noreturn TSRMLS_DC){
	zval *params[] = { param1, param2, param3 };
	return phalcon_call_static_zval_func_params(return_value, mixed_name, method_name, method_len, 3, params, noreturn TSRMLS_CC);
}

int phalcon_call_static_ce_func_params(zval *return_value, zend_class_entry *ce, char *method_name, int method_len, zend_uint param_count, zval *params[], int noreturn TSRMLS_DC){

	zval *fn;
	int status;

	if (!noreturn) {
		ALLOC_INIT_ZVAL(return_value);
	}

	ALLOC_INIT_ZVAL(fn);
	array_init(fn);
	add_next_index_stringl(fn, ce->name, ce->name_length, 0);
	add_next_index_stringl(fn, method_name, method_len, 0);
	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, param_count, params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function %s::%s()", ce->name, method_name);
	}

	if (!noreturn) {
		zval_ptr_dtor(&return_value);
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;

}

int phalcon_call_user_func_array(zval *return_value, zval *handler, zval *params TSRMLS_DC){

	zval *retval_ptr = NULL;
	zend_fcall_info fci;
	zend_fcall_info_cache fci_cache;
	char *is_callable_error = NULL;
	int status = FAILURE;

	if (Z_TYPE_P(params) != IS_ARRAY) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for phalcon_call_user_func_array()");
		phalcon_memory_restore_stack(TSRMLS_C);
		return FAILURE;
	}

	if (zend_fcall_info_init(handler, 0, &fci, &fci_cache, NULL, &is_callable_error TSRMLS_CC) == SUCCESS) {
		if (is_callable_error) {
			zend_error(E_STRICT, "%s", is_callable_error);
			efree(is_callable_error);
		}
		status = SUCCESS;
	} else {
		if (is_callable_error) {
			zend_error(E_WARNING, "%s", is_callable_error);
			efree(is_callable_error);
		} else {
			status = SUCCESS;
		}
	}

	if (status == SUCCESS) {

		zend_fcall_info_args(&fci, params TSRMLS_CC);
		fci.retval_ptr_ptr = &retval_ptr;

		if (zend_call_function(&fci, &fci_cache TSRMLS_CC) == SUCCESS && fci.retval_ptr_ptr && *fci.retval_ptr_ptr) {
			COPY_PZVAL_TO_ZVAL(*return_value, *fci.retval_ptr_ptr);
		}

		if (fci.params) {
			efree(fci.params);
		}
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_user_func(zval *return_value, zval *handler TSRMLS_DC){

	zval *retval_ptr = NULL;
	zend_fcall_info fci;
	zend_fcall_info_cache fci_cache;
	char *is_callable_error = NULL;
	int status = FAILURE;

	if (zend_fcall_info_init(handler, 0, &fci, &fci_cache, NULL, &is_callable_error TSRMLS_CC) == SUCCESS) {
		if (is_callable_error) {
			zend_error(E_STRICT, "%s", is_callable_error);
			efree(is_callable_error);
		}
		status = SUCCESS;
	} else {
		if (is_callable_error) {
			zend_error(E_WARNING, "%s", is_callable_error);
			efree(is_callable_error);
		} else {
			status = SUCCESS;
		}
	}

	if (status == SUCCESS) {

		fci.param_count = 0;
		fci.retval_ptr_ptr = &retval_ptr;

		if (zend_call_function(&fci, &fci_cache TSRMLS_CC) == SUCCESS && fci.retval_ptr_ptr && *fci.retval_ptr_ptr) {
			COPY_PZVAL_TO_ZVAL(*return_value, *fci.retval_ptr_ptr);
		}

		if (fci.params) {
			efree(fci.params);
		}
	}

	if (EG(exception)) {
		status = FAILURE;
	}

	if (status == FAILURE) {
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] TSRMLS_DC) {

	zval ***params_array;
	zend_uint i;
	int ex_retval;
	zval *local_retval_ptr = NULL;

	if (param_count) {
		params_array = (zval ***) emalloc(sizeof(zval **)*param_count);
		for (i=0; i < param_count; i++) {
			params_array[i] = &params[i];
		}
	} else {
		params_array = NULL;
	}

	ex_retval = PHALCON_CALL_USER_FUNCTION_EX(function_table, object_pp, function_name, &local_retval_ptr, param_count, params_array, 1, NULL TSRMLS_CC);
	if (local_retval_ptr) {
		COPY_PZVAL_TO_ZVAL(*retval_ptr, local_retval_ptr);
	} else {
		INIT_ZVAL(*retval_ptr);
	}

	if (params_array) {
		efree(params_array);
	}

	return ex_retval;
}

#if PHP_VERSION_ID <= 50309

int phalcon_call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table TSRMLS_DC) {

	zend_fcall_info fci;

	fci.size = sizeof(fci);
	fci.function_table = function_table;
	fci.object_ptr = object_pp ? *object_pp : NULL;
	fci.function_name = function_name;
	fci.retval_ptr_ptr = retval_ptr_ptr;
	fci.param_count = param_count;
	fci.params = params;
	fci.no_separation = (zend_bool) no_separation;
	fci.symbol_table = symbol_table;

	return phalcon_call_function(&fci, NULL TSRMLS_CC);
}

int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC) {

	zend_uint i;
	zval **original_return_value;
	HashTable *calling_symbol_table;
	zend_op_array *original_op_array;
	zend_op **original_opline_ptr;
	zend_class_entry *current_scope;
	zend_class_entry *current_called_scope;
	zend_class_entry *calling_scope = NULL;
	zend_class_entry *called_scope = NULL;
	zval *current_this;
	zend_execute_data execute_data;

	*fci->retval_ptr_ptr = NULL;

	if (!EG(active)) {
		return FAILURE; /* executor is already inactive */
	}

	if (EG(exception)) {
		return FAILURE; /* we would result in an instable executor otherwise */
	}

	switch (fci->size) {
		case sizeof(zend_fcall_info):
			break; /* nothing to do currently */
		default:
			zend_error(E_ERROR, "Corrupted fcall_info provided to phalcon_call_function()");
			break;
	}

	/* Initialize execute_data */
	if (EG(current_execute_data)) {
		execute_data = *EG(current_execute_data);
		EX(op_array) = NULL;
		EX(opline) = NULL;
		EX(object) = NULL;
	} else {
		/* This only happens when we're called outside any execute()'s
		 * It shouldn't be strictly necessary to NULL execute_data out,
		 * but it may make bugs easier to spot
		 */
		memset(&execute_data, 0, sizeof(zend_execute_data));
	}

	if (!fci_cache || !fci_cache->initialized) {
		zend_fcall_info_cache fci_cache_local;
		char *callable_name;
		char *error = NULL;

		if (!fci_cache) {
			fci_cache = &fci_cache_local;
		}

		if (!zend_is_callable_ex(fci->function_name, fci->object_ptr, IS_CALLABLE_CHECK_SILENT, &callable_name, NULL, fci_cache, &error TSRMLS_CC)) {
			if (error) {
				zend_error(E_WARNING, "Invalid callback %s, %s", callable_name, error);
				efree(error);
			}
			if (callable_name) {
				efree(callable_name);
			}
			return FAILURE;
		} else if (error) {
			/* Capitalize the first latter of the error message */
			if (error[0] >= 'a' && error[0] <= 'z') {
				error[0] += ('A' - 'a');
			}
			zend_error(E_STRICT, "%s", error);
			efree(error);
		}
		efree(callable_name);
	}

	EX(function_state).function = fci_cache->function_handler;
	calling_scope = fci_cache->calling_scope;
	called_scope = fci_cache->called_scope;
	fci->object_ptr = fci_cache->object_ptr;
	EX(object) = fci->object_ptr;
	if (fci->object_ptr && Z_TYPE_P(fci->object_ptr) == IS_OBJECT &&
	    (!EG(objects_store).object_buckets || !EG(objects_store).object_buckets[Z_OBJ_HANDLE_P(fci->object_ptr)].valid)) {
		return FAILURE;
	}

	if (EX(function_state).function->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) {
		if (EX(function_state).function->common.fn_flags & ZEND_ACC_ABSTRACT) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EX(function_state).function->common.scope->name, EX(function_state).function->common.function_name);
		}
		if (EX(function_state).function->common.fn_flags & ZEND_ACC_DEPRECATED) {
 			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				EX(function_state).function->common.scope ? EX(function_state).function->common.scope->name : "",
				EX(function_state).function->common.scope ? "::" : "",
				EX(function_state).function->common.function_name);
		}
	}

	ZEND_VM_STACK_GROW_IF_NEEDED(fci->param_count + 1);

	for (i=0; i<fci->param_count; i++) {
		zval *param;

		if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION
			&& (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) == 0
			&& !ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& PZVAL_IS_REF(*fci->params[i])) {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
			zval_copy_ctor(param);
		} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& !PZVAL_IS_REF(*fci->params[i])) {

			if (Z_REFCOUNT_PP(fci->params[i]) > 1) {
				zval *new_zval;

				if (fci->no_separation &&
				    !ARG_MAY_BE_SENT_BY_REF(EX(function_state).function, i + 1)) {
					if (i || UNEXPECTED(ZEND_VM_STACK_ELEMETS(EG(argument_stack)) == EG(argument_stack)->top)) {
						/* hack to clean up the stack */
						zend_vm_stack_push_nocheck((void *) (zend_uintptr_t)i TSRMLS_CC);
						zend_vm_stack_clear_multiple(TSRMLS_C);
					}

					zend_error(E_WARNING, "Parameter %d to %s%s%s() expected to be a reference, value given",
						i+1,
						EX(function_state).function->common.scope ? EX(function_state).function->common.scope->name : "",
						EX(function_state).function->common.scope ? "::" : "",
						EX(function_state).function->common.function_name);
					return FAILURE;
				}

				ALLOC_ZVAL(new_zval);
				*new_zval = **fci->params[i];
				zval_copy_ctor(new_zval);
				Z_SET_REFCOUNT_P(new_zval, 1);
				Z_DELREF_PP(fci->params[i]);
				*fci->params[i] = new_zval;
			}
			Z_ADDREF_PP(fci->params[i]);
			Z_SET_ISREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else if (*fci->params[i] != &EG(uninitialized_zval)) {
			Z_ADDREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
		}
		zend_vm_stack_push_nocheck(param TSRMLS_CC);
	}

	EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
	zend_vm_stack_push_nocheck((void*)(zend_uintptr_t)fci->param_count TSRMLS_CC);

	current_scope = EG(scope);
	EG(scope) = calling_scope;

	current_this = EG(This);

	current_called_scope = EG(called_scope);
	if (called_scope) {
		EG(called_scope) = called_scope;
	} else if (EX(function_state).function->type != ZEND_INTERNAL_FUNCTION) {
		EG(called_scope) = NULL;
	}

	if (fci->object_ptr) {
		if ((EX(function_state).function->common.fn_flags & ZEND_ACC_STATIC)) {
			EG(This) = NULL;
		} else {
			EG(This) = fci->object_ptr;

			if (!PZVAL_IS_REF(EG(This))) {
				Z_ADDREF_P(EG(This)); /* For $this pointer */
			} else {
				zval *this_ptr;

				ALLOC_ZVAL(this_ptr);
				*this_ptr = *EG(This);
				INIT_PZVAL(this_ptr);
				zval_copy_ctor(this_ptr);
				EG(This) = this_ptr;
			}
		}
	} else {
		EG(This) = NULL;
	}

	EX(prev_execute_data) = EG(current_execute_data);
	EG(current_execute_data) = &execute_data;

	if (EX(function_state).function->type == ZEND_USER_FUNCTION) {
		calling_symbol_table = EG(active_symbol_table);
		EG(scope) = EX(function_state).function->common.scope;
		if (fci->symbol_table) {
			EG(active_symbol_table) = fci->symbol_table;
		} else {
			EG(active_symbol_table) = NULL;
		}

		original_return_value = EG(return_value_ptr_ptr);
		original_op_array = EG(active_op_array);
		EG(return_value_ptr_ptr) = fci->retval_ptr_ptr;
		EG(active_op_array) = (zend_op_array *) EX(function_state).function;
		original_opline_ptr = EG(opline_ptr);
		zend_execute(EG(active_op_array) TSRMLS_CC);
		if (!fci->symbol_table && EG(active_symbol_table)) {
			if (EG(symtable_cache_ptr)>=EG(symtable_cache_limit)) {
				zend_hash_destroy(EG(active_symbol_table));
				FREE_HASHTABLE(EG(active_symbol_table));
			} else {
				/* clean before putting into the cache, since clean
				   could call dtors, which could use cached hash */
				zend_hash_clean(EG(active_symbol_table));
				*(++EG(symtable_cache_ptr)) = EG(active_symbol_table);
			}
		}
		EG(active_symbol_table) = calling_symbol_table;
		EG(active_op_array) = original_op_array;
		EG(return_value_ptr_ptr)=original_return_value;
		EG(opline_ptr) = original_opline_ptr;
	} else if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		int call_via_handler = (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) != 0;
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);
		if (EX(function_state).function->common.scope) {
			EG(scope) = EX(function_state).function->common.scope;
		}
		((zend_internal_function *) EX(function_state).function)->handler(fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		/*  We shouldn't fix bad extensions here,
			because it can break proper ones (Bug #34045)
		if (!EX(function_state).function->common.return_reference)
		{
			INIT_PZVAL(*fci->retval_ptr_ptr);
		}*/
		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}

		if (call_via_handler) {
			/* We must re-initialize function again */
			fci_cache->initialized = 0;
		}
	} else { /* ZEND_OVERLOADED_FUNCTION */
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);

		/* Not sure what should be done here if it's a static method */
		if (fci->object_ptr) {
			Z_OBJ_HT_P(fci->object_ptr)->call_method(EX(function_state).function->common.function_name, fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (EX(function_state).function->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree(EX(function_state).function->common.function_name);
		}
		efree(EX(function_state).function);

		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}
	}
	zend_vm_stack_clear_multiple(TSRMLS_C);

	if (EG(This)) {
		zval_ptr_dtor(&EG(This));
	}
	EG(called_scope) = current_called_scope;
	EG(scope) = current_scope;
	EG(This) = current_this;
	EG(current_execute_data) = EX(prev_execute_data);

	if (EG(exception)) {
		phalcon_throw_exception_internal(NULL TSRMLS_CC);
	}
	return SUCCESS;
}

int phalcon_lookup_class_ex(const char *name, int name_length, int use_autoload, zend_class_entry ***ce TSRMLS_DC){

	zval **args[1];
	zval autoload_function;
	zval *class_name_ptr;
	zval *retval_ptr = NULL;
	int retval, lc_length;
	char *lc_name;
	char *lc_free;
	zend_fcall_info fcall_info;
	zend_fcall_info_cache fcall_cache;
	char dummy = 1;
	ulong hash;
	ALLOCA_FLAG(use_heap)

	if (name == NULL || !name_length) {
		return FAILURE;
	}

	lc_free = lc_name = do_alloca(name_length + 1, use_heap);
	zend_str_tolower_copy(lc_name, name, name_length);
	lc_length = name_length + 1;

	if (lc_name[0] == '\\') {
		lc_name += 1;
		lc_length -= 1;
	}

	hash = zend_inline_hash_func(lc_name, lc_length);

	if (zend_hash_quick_find(EG(class_table), lc_name, lc_length, hash, (void **) ce) == SUCCESS) {
		free_alloca(lc_free, use_heap);
		return SUCCESS;
	}

	/* The compiler is not-reentrant. Make sure we __autoload() only during run-time
	 * (doesn't impact fuctionality of __autoload()
	*/
	if (!use_autoload || zend_is_compiling(TSRMLS_C)) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	if (EG(in_autoload) == NULL) {
		ALLOC_HASHTABLE(EG(in_autoload));
		zend_hash_init(EG(in_autoload), 0, NULL, NULL, 0);
	}

	if (zend_hash_quick_add(EG(in_autoload), lc_name, lc_length, hash, (void**)&dummy, sizeof(char), NULL) == FAILURE) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	ZVAL_STRINGL(&autoload_function, ZEND_AUTOLOAD_FUNC_NAME, sizeof(ZEND_AUTOLOAD_FUNC_NAME) - 1, 0);

	ALLOC_ZVAL(class_name_ptr);
	INIT_PZVAL(class_name_ptr);
	if (name[0] == '\\') {
		ZVAL_STRINGL(class_name_ptr, name+1, name_length-1, 1);
	} else {
		ZVAL_STRINGL(class_name_ptr, name, name_length, 1);
	}

	args[0] = &class_name_ptr;

	fcall_info.size = sizeof(fcall_info);
	fcall_info.function_table = EG(function_table);
	fcall_info.function_name = &autoload_function;
	fcall_info.symbol_table = NULL;
	fcall_info.retval_ptr_ptr = &retval_ptr;
	fcall_info.param_count = 1;
	fcall_info.params = args;
	fcall_info.object_ptr = NULL;
	fcall_info.no_separation = 1;

	fcall_cache.initialized = EG(autoload_func) ? 1 : 0;
	fcall_cache.function_handler = EG(autoload_func);
	fcall_cache.calling_scope = NULL;
	fcall_cache.called_scope = NULL;
	fcall_cache.object_ptr = NULL;

	zend_exception_save(TSRMLS_C);
	retval = phalcon_call_function(&fcall_info, &fcall_cache TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	EG(autoload_func) = fcall_cache.function_handler;

	zval_ptr_dtor(&class_name_ptr);

	zend_hash_quick_del(EG(in_autoload), lc_name, lc_length, hash);

	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}

	if (retval == FAILURE) {
		free_alloca(lc_free, use_heap);
		return FAILURE;
	}

	retval = zend_hash_quick_find(EG(class_table), lc_name, lc_length, hash, (void **) ce);
	free_alloca(lc_free, use_heap);
	return retval;
}

int phalcon_lookup_class(const char *name, int name_length, zend_class_entry ***ce TSRMLS_DC){
	return phalcon_lookup_class_ex(name, name_length, 1, ce TSRMLS_CC);
}

#endif




#ifdef HAVE_CONFIG_H
#endif


int PHALCON_FASTCALL phalcon_array_isset(const zval *arr, zval *index){

	zval *copy;
	int exists, type, copied = 0;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	} else {
		if (!zend_hash_num_elements(Z_ARRVAL_P(arr))) {
			return 0;
		}
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		ALLOC_INIT_ZVAL(copy);
		ZVAL_ZVAL(copy, index, 1, 0);
		convert_to_string(copy);
		index = copy;
		copied = 1;
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			ALLOC_INIT_ZVAL(copy);
			ZVAL_ZVAL(copy, index, 1, 0);
			convert_to_long(copy);
			index = copy;
			copied = 1;
		}
	}

	if (Z_TYPE_P(index) == IS_STRING) {
		if((type = is_numeric_string(Z_STRVAL_P(index), Z_STRLEN_P(index), NULL, NULL, 0))){
			if (type == IS_LONG) {
				ALLOC_INIT_ZVAL(copy);
				ZVAL_ZVAL(copy, index, 1, 0);
				convert_to_long(copy);
				index = copy;
				copied = 1;
			}
		}
	}

	if (Z_TYPE_P(index) == IS_STRING) {
		exists = zend_hash_exists(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1);
	} else {
		exists = zend_hash_index_exists(Z_ARRVAL_P(arr), Z_LVAL_P(index));
	}

	if (copied) {
		zval_ptr_dtor(&copy);
	}

	return exists;
}

int PHALCON_FASTCALL phalcon_array_isset_string(const zval *arr, char *index, uint index_length){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	} else {
		if (!zend_hash_num_elements(Z_ARRVAL_P(arr))) {
			return 0;
		}
	}
	return zend_hash_exists(Z_ARRVAL_P(arr), index, index_length);
}

int PHALCON_FASTCALL phalcon_array_isset_long(const zval *arr, ulong index){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	} else {
		if (!zend_hash_num_elements(Z_ARRVAL_P(arr))) {
			return 0;
		}
	}
	return zend_hash_index_exists(Z_ARRVAL_P(arr), index);
}

int PHALCON_FASTCALL phalcon_array_unset(zval *arr, zval *index){

	zval *copy;
	int exists, copied = 0;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		ALLOC_INIT_ZVAL(copy);
		ZVAL_ZVAL(copy, index, 1, 0);
		convert_to_string(copy);
		index = copy;
		copied = 1;
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			ALLOC_INIT_ZVAL(copy);
			ZVAL_ZVAL(copy, index, 1, 0);
			convert_to_long(copy);
			index = copy;
			copied = 1;
		}
	}

	if (Z_TYPE_P(index) == IS_STRING) {
		exists = zend_hash_del(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1);
	} else {
		exists = zend_hash_index_del(Z_ARRVAL_P(arr), Z_LVAL_P(index));
	}

	if (copied) {
		zval_ptr_dtor(&copy);
	}

	return exists;
}

int PHALCON_FASTCALL phalcon_array_unset_string(zval *arr, char *index, uint index_length){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}
	return zend_hash_del(Z_ARRVAL_P(arr), index, index_length);
}

int PHALCON_FASTCALL phalcon_array_unset_long(zval *arr, ulong index){
	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}
	return zend_hash_index_del(Z_ARRVAL_P(arr), index);
}

int phalcon_array_append(zval **arr, zval *value, int flags TSRMLS_DC){
	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		if ((flags & PH_SEPARATE) == PH_SEPARATE) {
			if (Z_REFCOUNT_PP(arr) > 1) {
				zval *new_zv;
				Z_DELREF_PP(arr);
				ALLOC_ZVAL(new_zv);
				INIT_PZVAL_COPY(new_zv, *arr);
				*arr = new_zv;
				zval_copy_ctor(new_zv);
			}
		}
		Z_ADDREF_P(value);
		return add_next_index_zval(*arr, value);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
	}
	return FAILURE;
}

int phalcon_array_append_long(zval **arr, long value, int separate TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	Z_SET_REFCOUNT_P(zvalue, 0);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_append(arr, zvalue, separate TSRMLS_CC);
}

int phalcon_array_append_string(zval **arr, char *value, uint value_length, int separate TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	Z_SET_REFCOUNT_P(zvalue, 0);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_append(arr, zvalue, separate TSRMLS_CC);
}

int phalcon_array_update_zval(zval **arr, zval *index, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (Z_TYPE_P(index) == IS_NULL) {
		convert_to_string(index);
	} else {
		if (Z_TYPE_P(index) == IS_BOOL || Z_TYPE_P(index) == IS_DOUBLE) {
			convert_to_long(index);
		}
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

 	if (Z_TYPE_P(index) == IS_STRING) {
		return zend_hash_update(Z_ARRVAL_PP(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1, value, sizeof(zval *), NULL);
	} else {
		if (Z_TYPE_P(index) == IS_LONG) {
			return zend_hash_index_update(Z_ARRVAL_PP(arr), Z_LVAL_P(index), value, sizeof(zval *), NULL);
		} else {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
	}

	return FAILURE;
}

int phalcon_array_update_zval_bool(zval **arr, zval *index, int value, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_zval(arr, index, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_zval_string(zval **arr, zval *index, char *value, uint value_length, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_zval(arr, index, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_string(zval **arr, char *index, uint index_length, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

	return zend_hash_update(Z_ARRVAL_PP(arr), index, index_length+1, value, sizeof(zval *), NULL);
}

int phalcon_array_update_string_bool(zval **arr, char *index, uint index_length, int value, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_string(arr, index, index_length, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_string_long(zval **arr, char *index, uint index_length, long value, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_update_string(arr, index, index_length, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_string_string(zval **arr, char *index, uint index_length, char *value, uint value_length, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_string(arr, index, index_length, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_long(zval **arr, ulong index, zval **value, int flags TSRMLS_DC){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if ((flags & PH_CTOR) == PH_CTOR) {
		zval *new_zv;
		Z_DELREF_PP(value);
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *value);
		*value = new_zv;
		zval_copy_ctor(new_zv);
	}

	if ((flags & PH_SEPARATE) == PH_SEPARATE) {
		if (Z_REFCOUNT_PP(arr) > 1) {
			zval *new_zv;
			Z_DELREF_PP(arr);
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, *arr);
			*arr = new_zv;
			zval_copy_ctor(new_zv);
	    }
	}

	if ((flags & PH_COPY) == PH_COPY) {
		Z_ADDREF_PP(value);
	}

	return zend_hash_index_update(Z_ARRVAL_PP(arr), index, value, sizeof(zval *), NULL);
}

int phalcon_array_update_long_string(zval **arr, ulong index, char *value, uint value_length, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_long(arr, index, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_update_long_bool(zval **arr, ulong index, int value, int flags TSRMLS_DC){

	zval *zvalue;

	ALLOC_INIT_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_long(arr, index, &zvalue, flags TSRMLS_CC);
}

int phalcon_array_fetch(zval **return_value, zval *arr, zval *index, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE, type;

 	if (Z_TYPE_P(index) == IS_ARRAY || Z_TYPE_P(index) == IS_OBJECT) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
		return FAILURE;
	}

 	if (Z_TYPE_P(index) == IS_NULL) {
		convert_to_string(index);
	}

	if (Z_TYPE_P(arr) == IS_NULL || Z_TYPE_P(arr) == IS_BOOL) {
		return FAILURE;
	}

	if (Z_TYPE_P(index) != IS_STRING && Z_TYPE_P(index) != IS_LONG && Z_TYPE_P(index) != IS_DOUBLE) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Illegal offset type");
		}
		return FAILURE;
	}

 	if (Z_TYPE_P(index) == IS_STRING) {
       	if ((type = is_numeric_string(Z_STRVAL_P(index), Z_STRLEN_P(index), NULL, NULL, 0))) {
			if (type == IS_LONG) {
				convert_to_long(index);
			}
		}
	} else {
		if (Z_TYPE_P(index) == IS_DOUBLE) {
			convert_to_long(index);
		}
	}

 	if (Z_TYPE_P(index) == IS_STRING) {
		if ((result = zend_hash_find(Z_ARRVAL_P(arr), Z_STRVAL_P(index), Z_STRLEN_P(index)+1, (void**) &zv)) == SUCCESS) {
			zval_ptr_dtor(return_value);
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}
	}

 	if (Z_TYPE_P(index) == IS_LONG) {
		if ((result = zend_hash_index_find(Z_ARRVAL_P(arr), Z_LVAL_P(index), (void**) &zv)) == SUCCESS) {
			zval_ptr_dtor(return_value);
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}
	}

	if (silent == PH_NOISY) {
		if (Z_TYPE_P(index) == IS_LONG) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %ld", Z_LVAL_P(index));
		} else {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %s", Z_STRVAL_P(index));
		}
	}

	return FAILURE;
}

int phalcon_array_fetch_string(zval **return_value, zval *arr, char *index, uint index_length, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		}
		return FAILURE;
	}

	if ((result = zend_hash_find(Z_ARRVAL_P(arr), index, index_length+1, (void**)&zv)) == SUCCESS) {
		zval_ptr_dtor(return_value);
		*return_value = *zv;
		Z_ADDREF_PP(return_value);
		return SUCCESS;
	}

	if (silent == PH_NOISY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %s", index);
	}

	return FAILURE;

}

int phalcon_array_fetch_long(zval **return_value, zval *arr, ulong index, int silent TSRMLS_DC){

	zval **zv;
	int result = FAILURE;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot use a scalar value as an array");
		}
		return FAILURE;
	}

	if ((result = zend_hash_index_find(Z_ARRVAL_P(arr), index, (void**)&zv)) == SUCCESS) {
		zval_ptr_dtor(return_value);
		*return_value = *zv;
		Z_ADDREF_PP(return_value);
		return SUCCESS;
	}

	if (silent == PH_NOISY) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: %ld", index);
	}

	return FAILURE;

}

void phalcon_array_append_multi_2(zval **arr, zval *index, zval *value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_zval(arr, index, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_zval(arr, index, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_append(&temp, value, flags TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_multi_2(zval **arr, zval *index1, zval *index2, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_update_zval(&temp, index2, value, flags | PH_COPY TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_string_multi_2(zval **arr, zval *index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_update_string(&temp, index2, index2_length, value, flags | PH_COPY TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_long_long_multi_2(zval **arr, long index1, long index2, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_long(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_long(arr, index1, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_update_long(&temp, index2, value, flags | PH_COPY TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_long_string_multi_2(zval **arr, long index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_long(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_long(arr, index1, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_update_string(&temp, index2, index2_length, value, flags | PH_COPY TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_append_multi_2(zval **arr, zval *index1, zval *value, int flags TSRMLS_DC){

	zval *temp;

	ALLOC_INIT_ZVAL(temp);

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp) > 1) {
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
			phalcon_array_update_zval(arr, index1, &temp, PH_COPY TSRMLS_CC);
		}
		phalcon_array_append(&temp, value, flags TSRMLS_CC);
	}

	zval_ptr_dtor(&temp);

}

void phalcon_array_update_zval_string_append_multi_3(zval **arr, zval *index1, char *index2, uint index2_length, zval **value, int flags TSRMLS_DC){

	zval *temp1 = NULL, *temp2 = NULL;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		ALLOC_INIT_ZVAL(temp1);
		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp1) > 1) {
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY TSRMLS_CC);
		}

		ALLOC_INIT_ZVAL(temp2);
		phalcon_array_fetch_string(&temp2, temp1, index2, index2_length, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp2) > 1) {
			phalcon_array_update_string(&temp1, index2, index2_length, &temp2, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
			phalcon_array_update_string(&temp1, index2, index2_length, &temp2, PH_COPY TSRMLS_CC);
		}

		phalcon_array_append(&temp2, *value, flags TSRMLS_CC);
	}

	if (temp1 != NULL) {
		zval_ptr_dtor(&temp1);
	}
	if (temp2 != NULL) {
		zval_ptr_dtor(&temp2);
	}

}

void phalcon_array_update_zval_zval_zval_multi_3(zval **arr, zval *index1, zval *index2, zval *index3, zval **value, int flags TSRMLS_DC){

	zval *temp1 = NULL, *temp2 = NULL;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		ALLOC_INIT_ZVAL(temp1);
		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp1) > 1) {
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY TSRMLS_CC);
		}

		ALLOC_INIT_ZVAL(temp2);
		phalcon_array_fetch(&temp2, temp1, index2, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp2) > 1) {
			phalcon_array_update_zval(&temp1, index2, &temp2, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
			phalcon_array_update_zval(&temp1, index2, &temp2, PH_COPY TSRMLS_CC);
		}

		phalcon_array_update_zval(&temp2, index3, value, PH_COPY TSRMLS_CC);
	}

	if (temp1 != NULL) {
		zval_ptr_dtor(&temp1);
	}
	if (temp2 != NULL) {
		zval_ptr_dtor(&temp2);
	}

}

void phalcon_array_update_string_zval_zval_multi_3(zval **arr, zval *index1, zval *index2, char *index3, uint index3_length, zval **value, int flags TSRMLS_DC){

	zval *temp1 = NULL, *temp2 = NULL;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		ALLOC_INIT_ZVAL(temp1);
		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp1) > 1) {
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY TSRMLS_CC);
		}

		ALLOC_INIT_ZVAL(temp2);
		phalcon_array_fetch(&temp2, temp1, index2, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp2) > 1) {
			phalcon_array_update_zval(&temp1, index2, &temp2, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
			phalcon_array_update_zval(&temp1, index2, &temp2, PH_COPY TSRMLS_CC);
		}

		phalcon_array_update_string(&temp2, index3, index3_length, value, PH_COPY TSRMLS_CC);
	}

	if (temp1 != NULL) {
		zval_ptr_dtor(&temp1);
	}
	if (temp2 != NULL) {
		zval_ptr_dtor(&temp2);
	}

}

void phalcon_array_update_zval_string_string_multi_3(zval **arr, zval *index1, char *index2, uint index2_length, char *index3, uint index3_length, zval **value, int flags TSRMLS_DC){

	zval *temp1 = NULL, *temp2 = NULL;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		ALLOC_INIT_ZVAL(temp1);
		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp1) > 1) {
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
			phalcon_array_update_zval(arr, index1, &temp1, PH_COPY TSRMLS_CC);
		}

		ALLOC_INIT_ZVAL(temp2);
		phalcon_array_fetch_string(&temp2, temp1, index2, index2_length, PH_SILENT_CC);
		if (Z_REFCOUNT_P(temp2) > 1) {
			phalcon_array_update_string(&temp1, index2, index2_length, &temp2, PH_COPY | PH_CTOR TSRMLS_CC);
		}
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
			phalcon_array_update_string(&temp1, index2, index2_length, &temp2, PH_COPY TSRMLS_CC);
		}

		phalcon_array_update_string(&temp2, index3, index3_length, value, PH_COPY TSRMLS_CC);
	}

	if (temp1 != NULL) {
		zval_ptr_dtor(&temp1);
	}
	if (temp2 != NULL) {
		zval_ptr_dtor(&temp2);
	}
}




#ifdef HAVE_CONFIG_H
#endif


#ifdef PHP_WIN32
#endif



int phalcon_get_class_constant(zval *return_value, zend_class_entry *ce, char *constant_name, int constant_length TSRMLS_DC){

	zval **result_ptr;

	if (zend_hash_find(&ce->constants_table, constant_name, constant_length, (void **) &result_ptr) != SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Undefined class constant '%s::%s'", ce->name, constant_name);
		phalcon_memory_restore_stack(TSRMLS_C);
		return FAILURE;
	} else {
		ZVAL_ZVAL(return_value, *result_ptr, 1, 0);
	}

	return SUCCESS;
}

int phalcon_instance_of(zval *result, const zval *object, const zend_class_entry *ce TSRMLS_DC){

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "instanceof expects an object instance, constant given");
		phalcon_memory_restore_stack(TSRMLS_C);
		return FAILURE;
	} else {
		ZVAL_BOOL(result, instanceof_function(Z_OBJCE_P(object), ce TSRMLS_CC));
	}

	return SUCCESS;
}

int phalcon_is_instance_of(zval *object, char *class_name, unsigned int class_length TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
		if (ce->name_length == class_length) {
			return !zend_binary_strcasecmp(ce->name, ce->name_length, class_name, class_length);
		}
	}

	return 0;
}

void phalcon_get_class(zval *result, zval *object TSRMLS_DC){
	zend_class_entry *ce;
	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
		Z_STRLEN_P(result) = ce->name_length;
		Z_STRVAL_P(result) = (char *) emalloc(ce->name_length + 1);
		memcpy(Z_STRVAL_P(result), ce->name, ce->name_length);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
		Z_TYPE_P(result) = IS_STRING;
	} else {
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "get_class expects an object");
	}
}

zend_class_entry *phalcon_fetch_class(zval *class_name TSRMLS_DC){
	if (Z_TYPE_P(class_name) == IS_STRING) {
		return zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "class name must be a string");
		return zend_fetch_class("stdclass", strlen("stdclass"), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	}
}

int phalcon_class_exists(zval *class_name TSRMLS_DC){

	zend_class_entry **ce;

	if (Z_TYPE_P(class_name) == IS_STRING) {
		if (zend_lookup_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), &ce TSRMLS_CC) == SUCCESS) {
			return (((*ce)->ce_flags & ZEND_ACC_INTERFACE) == 0);
		}
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "class name must be a string");
	}

	return 0;
}

int phalcon_clone(zval *destiny, zval *obj TSRMLS_DC){

	int status = SUCCESS;
	zend_class_entry *ce;
	zend_object_clone_obj_t clone_call;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "__clone method called on non-object");
		status = FAILURE;
	} else {
		ce = Z_OBJCE_P(obj);
		clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
		if (!clone_call) {
			if (ce) {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
			} else {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object");
			}
			status = FAILURE;
		} else {
			if (!EG(exception)) {
				Z_OBJVAL_P(destiny) = clone_call(obj TSRMLS_CC);
				Z_TYPE_P(destiny) = IS_OBJECT;
				Z_SET_REFCOUNT_P(destiny, 1);
				Z_SET_ISREF_P(destiny);
				if (EG(exception)) {
					zval_ptr_dtor(&destiny);
				}
			}
		}
	}

	if (status == FAILURE){
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int phalcon_isset_property(zval *object, char *property_name, int property_length TSRMLS_DC){
	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (zend_hash_exists(&Z_OBJCE_P(object)->properties_info, property_name, property_length)) {
			return 1;
		} else {
			return zend_hash_exists(Z_OBJ_HT_P(object)->get_properties(object TSRMLS_CC), property_name, property_length);
		}
	} else {
		return 0;
	}
}

int phalcon_isset_property_zval(zval *object, zval *property TSRMLS_DC){
	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (Z_TYPE_P(property) == IS_STRING) {
			if (zend_hash_exists(&Z_OBJCE_P(object)->properties_info, Z_STRVAL_P(property), Z_STRLEN_P(property)+1)) {
				return 1;
			} else {
				return zend_hash_exists(Z_OBJ_HT_P(object)->get_properties(object TSRMLS_CC), Z_STRVAL_P(property), Z_STRLEN_P(property)+1);
			}
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}

static inline zend_class_entry *phalcon_lookup_class_ce(zval *object, char *property_name, int property_length TSRMLS_DC){

	zend_class_entry *ce, *original_ce;

	ce = Z_OBJCE_P(object);
	original_ce = ce;
	while (ce) {
		if (zend_hash_exists(&ce->properties_info, property_name, property_length+1)) {
			return ce;
		}
		ce = ce->parent;
	}
	return original_ce;
}

int phalcon_read_property(zval **result, zval *object, char *property_name, int property_length, int silent TSRMLS_DC){

	zval *tmp = NULL;
	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
		tmp = zend_read_property(ce, object, property_name, property_length, 0 TSRMLS_CC);
		Z_ADDREF_P(tmp);
		zval_ptr_dtor(result);
		*result = tmp;
		return SUCCESS;
	} else {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
		}
	}

	return FAILURE;
}

int phalcon_return_property(zval *return_value, zval *object, char *property_name, int property_length TSRMLS_DC){

	zval *tmp = NULL;
	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
		tmp = zend_read_property(ce, object, property_name, property_length, 0 TSRMLS_CC);
		ZVAL_ZVAL(return_value, tmp, 1, 0);
		return SUCCESS;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
	}

	return FAILURE;
}

int phalcon_read_property_zval(zval **result, zval *object, zval *property, int silent TSRMLS_DC){

	zval *tmp = NULL;
	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (Z_TYPE_P(property) == IS_STRING) {
			ce = phalcon_lookup_class_ce(object, Z_STRVAL_P(property), Z_STRLEN_P(property) TSRMLS_CC);
			tmp = zend_read_property(ce, object, Z_STRVAL_P(property), Z_STRLEN_P(property), 0 TSRMLS_CC);
			Z_ADDREF_P(tmp);
			zval_ptr_dtor(result);
			*result = tmp;
		}
	} else {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
			return FAILURE;
		}
	}
	return SUCCESS;
}

int phalcon_update_property_long(zval *object, char *property_name, int property_length, long value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
	zend_update_property_long(ce, object, property_name, property_length, value TSRMLS_CC);
	return SUCCESS;
}

int phalcon_update_property_string(zval *object, char *property_name, int property_length, char *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
	zend_update_property_string(ce, object, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

int phalcon_update_property_bool(zval *object, char *property_name, int property_length, int value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
	zend_update_property_bool(ce, object, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

int phalcon_update_property_null(zval *object, char *property_name, int property_length TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
	zend_update_property_null(ce, object, property_name, property_length TSRMLS_CC);

	return SUCCESS;
}

int phalcon_update_property_zval(zval *object, char *property_name, int property_length, zval *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, property_name, property_length TSRMLS_CC);
	zend_update_property(ce, object, property_name, property_length, value TSRMLS_CC);

	return SUCCESS;
}

int phalcon_update_property_zval_zval(zval *object, zval *property, zval *value TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	if (Z_TYPE_P(property) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Property should be string");
		return FAILURE;
	}

	ce = phalcon_lookup_class_ce(object, Z_STRVAL_P(property), Z_STRLEN_P(property) TSRMLS_CC);
	zend_update_property(ce, object, Z_STRVAL_P(property), Z_STRLEN_P(property), value TSRMLS_CC);

	return SUCCESS;
}

int phalcon_update_property_empty_array(zend_class_entry *ce, zval *object, char *property, unsigned int property_length TSRMLS_DC){

	zval *empty_array;

	ALLOC_INIT_ZVAL(empty_array);
	array_init(empty_array);
	Z_SET_REFCOUNT_P(empty_array, 0);
	zend_update_property(ce, object, property, property_length, empty_array TSRMLS_CC);

	return SUCCESS;
}

int phalcon_method_exists(zval *object, zval *method_name TSRMLS_DC){

	char *lcname;
	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
	} else {
		if (Z_TYPE_P(object) == IS_STRING) {
			ce = zend_fetch_class(Z_STRVAL_P(object), Z_STRLEN_P(object), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
		} else {
			return FAILURE;
		}
	}

	if (Z_TYPE_P(method_name) != IS_STRING) {
		return FAILURE;
	}

	lcname = zend_str_tolower_dup(Z_STRVAL_P(method_name), Z_STRLEN_P(method_name));
	while (ce) {
		if (zend_hash_exists(&ce->function_table, lcname, Z_STRLEN_P(method_name)+1)) {
			efree(lcname);
			return SUCCESS;
		}
		ce = ce->parent;
	}

	efree(lcname);
	return FAILURE;
}

int phalcon_method_exists_ex(zval *object, char *method_name, int method_len TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
	} else {
		if (Z_TYPE_P(object) == IS_STRING) {
			ce = zend_fetch_class(Z_STRVAL_P(object), Z_STRLEN_P(object), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
		} else {
			return FAILURE;
		}
	}

	ce = Z_OBJCE_P(object);
	while (ce) {
		if (zend_hash_exists(&ce->function_table, method_name, method_len)) {
			return SUCCESS;
		}
		ce = ce->parent;
	}

	return FAILURE;
}

int phalcon_read_static_property(zval **result, char *class_name, int class_length, char *property_name, int property_length TSRMLS_DC){
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		*result = zend_read_static_property(*ce, property_name, property_length, PH_FETCH_CLASS_SILENT);
		if (*result) {
			Z_ADDREF_PP(result);
			return SUCCESS;
		}
	}
	return FAILURE;
}

int phalcon_update_static_property(char *class_name, int class_length, char *name, int name_length, zval *value TSRMLS_DC){
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		return zend_update_static_property(*ce, name, name_length, value TSRMLS_CC);
	}
	return FAILURE;
}

int phalcon_create_instance(zval *return_value, zval *class_name TSRMLS_DC){

	zend_class_entry *ce;

	if (Z_TYPE_P(class_name) != IS_STRING) {
		phalcon_throw_exception_string(phalcon_exception_ce, SL("Invalid class name") TSRMLS_CC);
		return FAILURE;
	}

	ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	if (!ce) {
		return FAILURE;
	}

	object_init_ex(return_value, ce);
	if (phalcon_call_method(NULL, return_value, SL("__construct"), PH_CHECK, 0 TSRMLS_CC) == FAILURE) {
		return FAILURE;
	}

	return SUCCESS;
}

int phalcon_create_instance_params(zval *return_value, zval *class_name, zval *params TSRMLS_DC){

	int i;
	zend_class_entry *ce;
	long param_count;
	zval **params_array;
	HashPosition pos;
	HashTable *params_hash;

	if (Z_TYPE_P(class_name) != IS_STRING) {
		phalcon_throw_exception_string(phalcon_exception_ce, SL("Invalid class name") TSRMLS_CC);
		return FAILURE;
	}

	if (Z_TYPE_P(params) != IS_ARRAY) {
		phalcon_throw_exception_string(phalcon_exception_ce, SL("Instantiation parameters must be an array") TSRMLS_CC);
		return FAILURE;
	}

	ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	if (!ce) {
		return FAILURE;
	}

	object_init_ex(return_value, ce);

	param_count = zend_hash_num_elements(Z_ARRVAL_P(params));
	if (param_count > 0){

		params_array = emalloc(sizeof(zval *) * param_count);

		params_hash = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(params_hash, &pos);
		for (i=0; ; zend_hash_move_forward_ex(params_hash, &pos), i++) {
			zval ** item;
			if (zend_hash_get_current_data_ex(params_hash, (void**)&item, &pos) == FAILURE) {
				break;
			}
			params_array[i] = *item;
		}

		if (phalcon_call_method_params(NULL, return_value, SL("__construct"), (zend_uint) param_count, params_array, PH_CHECK, 0 TSRMLS_CC) == FAILURE) {
			efree(params_array);
			return FAILURE;
		}

		efree(params_array);
	} else {
		if (phalcon_call_method(NULL, return_value, SL("__construct"), PH_CHECK, 0 TSRMLS_CC) == FAILURE) {
			return FAILURE;
		}
	}

	return SUCCESS;
}





void phalcon_fast_strlen(zval *return_value, zval *str){

	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	ZVAL_LONG(return_value, Z_STRLEN_P(str));

	if (use_copy) {
		zval_dtor(str);
	}
}

void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC){

	if (Z_TYPE_P(glue) != IS_STRING || Z_TYPE_P(pieces) != IS_ARRAY) {
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for join()");
		return;
	}

	php_implode(glue, pieces, result TSRMLS_CC);
}

void phalcon_fast_join_str(zval *return_value, char *glue, unsigned int glue_length, zval *pieces TSRMLS_DC){

	zval         **tmp;
	HashTable      *arr;
	HashPosition   pos;
	smart_str      implstr = {0};
	int            str_len, numelems, i = 0;
	zval tmp_val;

	if (Z_TYPE_P(pieces) != IS_ARRAY) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for fast_join()");
		return;
	}

	arr = Z_ARRVAL_P(pieces);
	numelems = zend_hash_num_elements(arr);

	if (numelems == 0) {
		RETURN_EMPTY_STRING();
	}

	zend_hash_internal_pointer_reset_ex(arr, &pos);

	while (zend_hash_get_current_data_ex(arr, (void **) &tmp, &pos) == SUCCESS) {
		switch ((*tmp)->type) {
			case IS_STRING:
				smart_str_appendl(&implstr, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));
				break;

			case IS_LONG: {
				char stmp[MAX_LENGTH_OF_LONG + 1];
				str_len = slprintf(stmp, sizeof(stmp), "%ld", Z_LVAL_PP(tmp));
				smart_str_appendl(&implstr, stmp, str_len);
			}
				break;

			case IS_BOOL:
				if (Z_LVAL_PP(tmp) == 1) {
					smart_str_appendl(&implstr, "1", sizeof("1")-1);
				}
				break;

			case IS_NULL:
				break;

			case IS_DOUBLE: {
				char *stmp;
				str_len = spprintf(&stmp, 0, "%.*G", (int) EG(precision), Z_DVAL_PP(tmp));
				smart_str_appendl(&implstr, stmp, str_len);
				efree(stmp);
			}
				break;

			case IS_OBJECT: {
				int copy;
				zval expr;
				zend_make_printable_zval(*tmp, &expr, &copy);
				smart_str_appendl(&implstr, Z_STRVAL(expr), Z_STRLEN(expr));
				if (copy) {
					zval_dtor(&expr);
				}
			}
				break;

			default:
				tmp_val = **tmp;
				zval_copy_ctor(&tmp_val);
				convert_to_string(&tmp_val);
				smart_str_appendl(&implstr, Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
				zval_dtor(&tmp_val);
				break;

		}

		if (++i != numelems) {
			smart_str_appendl(&implstr, glue, glue_length);
		}
		zend_hash_move_forward_ex(arr, &pos);
	}
	smart_str_0(&implstr);

	if (implstr.len) {
		RETURN_STRINGL(implstr.c, implstr.len, 0);
	} else {
		smart_str_free(&implstr);
		RETURN_EMPTY_STRING();
	}
}

void phalcon_camelize(zval *return_value, zval *str TSRMLS_DC){

	int i;
	smart_str camelize_str = {0};
	char *marker, ch;

	if (Z_TYPE_P(str) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for camelize()");
		return;
	}

	marker = Z_STRVAL_P(str);
	for (i = 0; i < Z_STRLEN_P(str); i++) {
		ch = *marker;
		if (i == 0 || ch == '-' || ch == '_') {
			if (ch == '-' || ch == '_') {
				i++;
				marker++;
				ch = *marker;
			}
			if (ch >= 'a' && ch <= 'z') {
				smart_str_appendc(&camelize_str, (*marker)-32);
			} else {
				smart_str_appendc(&camelize_str, (*marker));
			}
			marker++;
			continue;
		}
		if (ch >= 'A' && ch <= 'Z') {
			smart_str_appendc(&camelize_str, (*marker)+32);
		} else {
			smart_str_appendc(&camelize_str, (*marker));
		}
		marker++;
	}
	smart_str_0(&camelize_str);

	if (camelize_str.len) {
		ZVAL_STRINGL(return_value, camelize_str.c, camelize_str.len, 0);
	} else {
		ZVAL_STRING(return_value, "", 1);
	}

}

void phalcon_uncamelize(zval *return_value, zval *str TSRMLS_DC){

	int i;
	smart_str uncamelize_str = {0};
	char *marker, ch;

	if (Z_TYPE_P(str) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for camelize()");
		return;
	}

	marker = Z_STRVAL_P(str);
	for (i = 0; i < Z_STRLEN_P(str); i++) {
		ch = *marker;
		if (ch >= 'A' && ch <= 'Z') {
			if (i > 0) {
				smart_str_appendc(&uncamelize_str, '_');
			}
			smart_str_appendc(&uncamelize_str, (*marker)+32);
		} else {
			smart_str_appendc(&uncamelize_str, (*marker));
		}
		marker++;
	}
	smart_str_0(&uncamelize_str);

	if (uncamelize_str.len) {
		ZVAL_STRINGL(return_value, uncamelize_str.c, uncamelize_str.len, 0);
	} else {
		ZVAL_STRING(return_value, "", 1);
	}
}

void phalcon_fast_explode(zval *result, zval *delimiter, zval *str TSRMLS_DC){

	if (Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(delimiter) != IS_STRING) {
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for explode()");
		return;
	}

	array_init(result);
	php_explode(delimiter, str, result, LONG_MAX);
}

int phalcon_memnstr(zval *haystack, zval *needle TSRMLS_DC){

	char *found = NULL;

	if (Z_TYPE_P(haystack) != IS_STRING || Z_TYPE_P(needle) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for memnstr()");
		return 0;
	}

	if (Z_STRLEN_P(haystack) >= Z_STRLEN_P(needle)) {
		found = php_memnstr(Z_STRVAL_P(haystack), Z_STRVAL_P(needle), Z_STRLEN_P(needle), Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));
	}

	if (found) {
		return 1;
	}

	return 0;
}

int phalcon_memnstr_str(zval *haystack, char *needle, int needle_length TSRMLS_DC){

	char *found = NULL;

	if (Z_TYPE_P(haystack) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for memnstr()");
		return 0;
	}

	if (Z_STRLEN_P(haystack) >= needle_length) {
		found = php_memnstr(Z_STRVAL_P(haystack), needle, needle_length, Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));
	}

	if (found) {
		return 1;
	}

	return 0;
}

void phalcon_fast_strpos(zval *return_value, zval *haystack, zval *needle TSRMLS_DC){

	char *found = NULL;

	if (Z_TYPE_P(haystack) != IS_STRING || Z_TYPE_P(needle) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for strpos()");
		return;
	}

	if (!Z_STRLEN_P(needle)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Empty delimiter");
		return;
	}

	found = php_memnstr(Z_STRVAL_P(haystack), Z_STRVAL_P(needle), Z_STRLEN_P(needle), Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_BOOL(return_value, 0);
	}

}

void phalcon_fast_strpos_str(zval *return_value, zval *haystack, char *needle, int needle_length TSRMLS_DC){

	char *found = NULL;

	if (Z_TYPE_P(haystack) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for strpos()");
		return;
	}

	found = php_memnstr(Z_STRVAL_P(haystack), needle, needle_length, Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_BOOL(return_value, 0);
	}

}

void phalcon_fast_stripos_str(zval *return_value, zval *haystack, char *needle, int needle_length TSRMLS_DC){

	char *found = NULL;
	char *needle_dup, *haystack_dup;

	if (Z_TYPE_P(haystack) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for stripos()");
		return;
	}

	haystack_dup = estrndup(Z_STRVAL_P(haystack), Z_STRLEN_P(haystack));
	php_strtolower(haystack_dup, Z_STRLEN_P(haystack));

	needle_dup = estrndup(needle, needle_length);
	php_strtolower(needle_dup, needle_length);

	found = php_memnstr(haystack_dup, needle, needle_length, haystack_dup + Z_STRLEN_P(haystack));

	efree(haystack_dup);
	efree(needle_dup);

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_BOOL(return_value, 0);
	}

}


void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject TSRMLS_DC){

	zval replace_copy, search_copy;
	int copy_replace = 0, copy_search = 0;

	if (Z_TYPE_P(subject) != IS_STRING) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for str_replace()");
		return;
	}

	if (Z_TYPE_P(replace) != IS_STRING) {
		zend_make_printable_zval(replace, &replace_copy, &copy_replace);
		if (copy_replace) {
			replace = &replace_copy;
		}
	}

	if (Z_TYPE_P(search) != IS_STRING) {
		zend_make_printable_zval(search, &search_copy, &copy_search);
		if (copy_search) {
			search = &search_copy;
		}
	}

	Z_TYPE_P(return_value) = IS_STRING;
	if (Z_STRLEN_P(subject) == 0) {
		ZVAL_STRINGL(return_value, "", 0, 1);
		return;
	}

	if (Z_STRLEN_P(search) == 1) {
		php_char_to_str_ex(Z_STRVAL_P(subject),
			Z_STRLEN_P(subject),
			Z_STRVAL_P(search)[0],
			Z_STRVAL_P(replace),
			Z_STRLEN_P(replace),
			return_value,
			1,
			NULL);
	} else {
		if (Z_STRLEN_P(search) > 1) {
			Z_STRVAL_P(return_value) = php_str_to_str_ex(Z_STRVAL_P(subject), Z_STRLEN_P(subject),
				Z_STRVAL_P(search), Z_STRLEN_P(search),
				Z_STRVAL_P(replace), Z_STRLEN_P(replace), &Z_STRLEN_P(return_value), 1, NULL);
		} else {
			MAKE_COPY_ZVAL(&subject, return_value);
		}
	}

	if (copy_replace) {
		zval_dtor(replace);
	}

	if (copy_search) {
		zval_dtor(search);
	}

}

void phalcon_extract_named_params(zval *return_value, zval *str, zval *matches){

	unsigned int i, j, bracket_count = 0;
	unsigned int intermediate, length, number_matches = 0;
	int variable_length, regexp_length, not_valid;
	char *cursor, *cursor_var, *marker, ch;
	char *item, *variable = NULL, *regexp;
	smart_str route_str = {0};

	if (Z_TYPE_P(str) != IS_STRING) {
		ZVAL_BOOL(return_value, 0);
		return;
	}

	if (Z_STRLEN_P(str) <= 0) {
		ZVAL_BOOL(return_value, 0);
		return;
	}

	cursor = Z_STRVAL_P(str);
	for (i = 0; i<Z_STRLEN_P(str); i++) {
		ch = *cursor;
		if (ch == '{') {
			if (bracket_count == 0) {
				marker = cursor;
				intermediate = 0;
				not_valid = 0;
			}
			bracket_count++;
		} else {
			if (ch == '}') {
				bracket_count--;
				if (intermediate > 0) {
					if (bracket_count == 0) {

						number_matches++;

						length = cursor - marker - 1;
						item = estrndup(marker + 1, length);
						cursor_var = item;
						marker = item;
						for (j=0; j<length; j++) {
							ch = *cursor_var;
							if (j == 0 && !((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <='Z'))){
								not_valid = 1;
								break;
							}
							if ((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <='Z') || (ch >= '0' && ch <='9') || ch ==  ':') {
								if (ch == ':') {
									regexp_length = length - j - 1;
									variable_length = cursor_var - marker;
									variable = estrndup(marker, variable_length);
									regexp = estrndup(cursor_var+1, regexp_length);
									break;
								}
							} else {
								not_valid = 1;
								break;
							}
							cursor_var++;
						}

						if (!not_valid) {
							{
								zval *tmp;
								ALLOC_INIT_ZVAL(tmp);
								ZVAL_LONG(tmp, number_matches);

								if (variable) {
									smart_str_appendc(&route_str, '(');
									smart_str_appendl(&route_str, regexp, regexp_length);
									smart_str_appendc(&route_str, ')');
									zend_hash_update(Z_ARRVAL_P(matches), variable, variable_length+1, &tmp, sizeof(zval *), NULL);
									efree(regexp);
									efree(variable);
								} else {
									smart_str_appendl(&route_str, "([^/]*)", strlen("([^/]*)"));
									zend_hash_update(Z_ARRVAL_P(matches), item, length+1, &tmp, sizeof(zval *), NULL);
								}
							}
						} else {
							smart_str_appendc(&route_str, '{');
							smart_str_appendl(&route_str, item, length);
							smart_str_appendc(&route_str, '}');
						}

						efree(item);

					}
					variable = NULL;
				}
			} else {
				if (bracket_count > 0) {
					intermediate++;
				} else {
					smart_str_appendc(&route_str, ch);
				}
			}
		}
		cursor++;
	}
	smart_str_0(&route_str);

	if (route_str.len) {
		RETURN_STRINGL(route_str.c, route_str.len, 0);
	} else {
		smart_str_free(&route_str);
		RETURN_EMPTY_STRING();
	}

}

int phalcon_start_with(zval *str, zval *compared){

	int i;
	char *op1_cursor, *op2_cursor;

	if (Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(compared) != IS_STRING) {
		return 0;
	}

	if (Z_STRLEN_P(compared) > Z_STRLEN_P(str)) {
		return 0;
	}

	op1_cursor = Z_STRVAL_P(str);
	op2_cursor = Z_STRVAL_P(compared);
	for (i = 0; i<Z_STRLEN_P(compared); i++){
		if ((*op1_cursor) != (*op2_cursor)) {
			return 0;
		}
		op1_cursor++;
		op2_cursor++;
	}

	return 1;
}

int phalcon_start_with_str(zval *str, char *compared, unsigned int compared_length){

	char *op1_cursor, *op2_cursor;
	int i;

	if (Z_TYPE_P(str) != IS_STRING) {
		return 0;
	}

	if (compared_length > Z_STRLEN_P(str)) {
		return 0;
	}

	op1_cursor = Z_STRVAL_P(str);
	op2_cursor = compared;
	for (i = 0; i<compared_length; i++){
		if ((*op1_cursor) != (*op2_cursor)) {
			return 0;
		}
		op1_cursor++;
		op2_cursor++;
	}

	return 1;
}



#ifdef HAVE_CONFIG_H
#endif



void phalcon_make_printable_zval(zval *expr, zval *expr_copy, int *use_copy){
	zend_make_printable_zval(expr, expr_copy, use_copy);
	if(use_copy){
		Z_SET_REFCOUNT_P(expr_copy, 1);
		Z_UNSET_ISREF_P(expr_copy);
	}
}

int phalcon_and_function(zval *result, zval *left, zval *right){
	int istrue = zend_is_true(left);
	if (istrue) {
		istrue = zend_is_true(right);
	}
	ZVAL_BOOL(result, istrue);
	return SUCCESS;
}

void phalcon_concat_self(zval *left, zval *right TSRMLS_DC){

	zval left_copy;
	uint length;
	int use_copy = 0;

	if (Z_TYPE_P(left) != IS_STRING) {
		phalcon_make_printable_zval(left, &left_copy, &use_copy);
		if (use_copy) {
			PHALCON_CPY_WRT_CTOR(left, (&left_copy));
		}
	}

	length = Z_STRLEN_P(left) + Z_STRLEN_P(right);
	Z_STRVAL_P(left) = erealloc(Z_STRVAL_P(left), length+1);

	memcpy(Z_STRVAL_P(left)+Z_STRLEN_P(left), Z_STRVAL_P(right), Z_STRLEN_P(right));
	Z_STRVAL_P(left)[length] = 0;
	Z_STRLEN_P(left) = length;
	Z_TYPE_P(left) = IS_STRING;

	if (use_copy) {
		zval_dtor(&left_copy);
	}
}

void phalcon_concat_self_str(zval *left, char *right, int right_length TSRMLS_DC){

	zval left_copy;
	uint length;
	int use_copy = 0;

	if (Z_TYPE_P(left) != IS_STRING) {
		phalcon_make_printable_zval(left, &left_copy, &use_copy);
		if (use_copy) {
			PHALCON_CPY_WRT_CTOR(left, (&left_copy));
		}
	}

	length = Z_STRLEN_P(left) + right_length;
	Z_STRVAL_P(left) = erealloc(Z_STRVAL_P(left), length+1);

	memcpy(Z_STRVAL_P(left)+Z_STRLEN_P(left), right, right_length);
	Z_STRVAL_P(left)[length] = 0;
	Z_STRLEN_P(left) = length;
	Z_TYPE_P(left) = IS_STRING;

	if (use_copy) {
		zval_dtor(&left_copy);
	}
}

int phalcon_compare_strict_string(zval *op1, char *op2, int op2_length){

	switch (Z_TYPE_P(op1)) {
		case IS_STRING:
			if (!Z_STRLEN_P(op1) && !op2_length) {
				return 1;
			}
			if (Z_STRLEN_P(op1) != op2_length) {
				return 0;
			}
			return zend_binary_strcmp(Z_STRVAL_P(op1), Z_STRLEN_P(op1), op2, op2_length)==0;
		case IS_NULL:
			return zend_binary_strcmp("", 0, op2, op2_length)==0;
		case IS_BOOL:
			if (!Z_BVAL_P(op1)) {
				return zend_binary_strcmp("0", strlen("0"), op2, op2_length)==0;
			} else {
				return zend_binary_strcmp("1", strlen("1"), op2, op2_length)==0;
			}
	}

	return 0;
}

int phalcon_compare_strict_long(zval *op1, long op2 TSRMLS_DC){

	zval *op2_tmp, *result;
	int bool_result;

	switch (Z_TYPE_P(op1)) {
		case IS_LONG:
			return Z_LVAL_P(op1) == op2;
		case IS_DOUBLE:
			return Z_LVAL_P(op1) == (double) op2;
		case IS_NULL:
			return 0 == op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 == op2;
			} else {
				return 1 == op2;
			}
		default:
			ALLOC_INIT_ZVAL(result);
			ALLOC_INIT_ZVAL(op2_tmp);
			ZVAL_LONG(op2_tmp, op2);
			is_equal_function(result, op1, op2_tmp TSRMLS_CC);
			bool_result = Z_BVAL_P(result);
			zval_ptr_dtor(&result);
			zval_ptr_dtor(&op2_tmp);
			return bool_result;
	}

	return 0;
}

int phalcon_is_smaller_strict_long(zval *op1, long op2 TSRMLS_DC){

	zval *op2_tmp, *result;
	int bool_result;

	switch (Z_TYPE_P(op1)) {
		case IS_LONG:
			return Z_LVAL_P(op1) < op2;
		case IS_DOUBLE:
			return Z_LVAL_P(op1) < (double) op2;
		case IS_NULL:
			return 0 < op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 < op2;
			} else {
				return 1 < op2;
			}
		default:
			ALLOC_INIT_ZVAL(result);
			ALLOC_INIT_ZVAL(op2_tmp);
			ZVAL_LONG(op2_tmp, op2);
			is_smaller_function(result, op1, op2_tmp TSRMLS_CC);
			bool_result = Z_BVAL_P(result);
			zval_ptr_dtor(&result);
			zval_ptr_dtor(&op2_tmp);
			return bool_result;
	}

}

int phalcon_is_smaller_or_equal_strict_long(zval *op1, long op2 TSRMLS_DC){

	zval *op2_tmp, *result;
	int bool_result;

	switch (Z_TYPE_P(op1)) {
		case IS_LONG:
			return Z_LVAL_P(op1) <= op2;
		case IS_DOUBLE:
			return Z_DVAL_P(op1) <= (double) op2;
		case IS_NULL:
			return 0 < op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 <= op2;
			} else {
				return 1 <= op2;
			}
		default:
			ALLOC_INIT_ZVAL(result);
			ALLOC_INIT_ZVAL(op2_tmp);
			ZVAL_LONG(op2_tmp, op2);
			is_smaller_or_equal_function(result, op1, op2_tmp TSRMLS_CC);
			bool_result = Z_BVAL_P(result);
			zval_ptr_dtor(&result);
			zval_ptr_dtor(&op2_tmp);
			return bool_result;
	}

}

int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC){
	int status;
	int ref_count = Z_REFCOUNT_P(result);
	int is_ref = Z_ISREF_P(result);
	status = add_function(result, op1, op2 TSRMLS_CC);
	Z_SET_REFCOUNT_P(result, ref_count);
	Z_SET_ISREF_TO_P(result, is_ref);
	return status;
}

void phalcon_cast(zval *result, zval *var, zend_uint type){

	ZVAL_ZVAL(result, var, 1, 0);

	switch (type) {
		case IS_STRING:
			convert_to_string(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		/*case IS_BOOL:
			convert_to_bool(result);
			break;*/
		case IS_ARRAY:
			if (Z_TYPE_P(result) != IS_ARRAY) {
				convert_to_array(result);
			}
			break;
	}

}




#ifdef HAVE_CONFIG_H
#endif



void phalcon_concat_sv(zval *result, char *op1, zend_uint op1_len, zval *op2, int self_var TSRMLS_DC){

	zval result_copy, op2_copy;
	int use_copy = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy;
	int use_copy = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svsvsv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op6_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svsvsvs(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, char *op5, zend_uint op5_len, zval *op6, char *op7, zend_uint op7_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op6_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4)+op5_len+Z_STRLEN_P(op6), op7, op7_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svsvv(zval *result, char *op1, zend_uint op1_len, zval *op2, char *op3, zend_uint op3_len, zval *op4, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op5_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2)+op3_len+Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_svv(zval *result, char *op1, zend_uint op1_len, zval *op2, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op3_copy;
	int use_copy = 0, use_copy2 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, op1, op1_len);
	memcpy(Z_STRVAL_P(result)+offset+op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+op1_len+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vs(zval *result, zval *op1, char *op2, zend_uint op2_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy;
	int use_copy = 0, use_copy1 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3), op4, op4_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vsvsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vsvsvs(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, char *op6, zend_uint op6_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5) + op6_len;
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len+Z_STRLEN_P(op5), op6, op6_len);
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vsvsvsv(zval *result, zval *op1, char *op2, zend_uint op2_len, zval *op3, char *op4, zend_uint op4_len, zval *op5, char *op6, zend_uint op6_len, zval *op7, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy, op7_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0, use_copy7 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	if (Z_TYPE_P(op7) != IS_STRING) {
		zend_make_printable_zval(op7, &op7_copy, &use_copy7);
		if (use_copy7) {
			op7 = &op7_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5) + op6_len + Z_STRLEN_P(op7);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len+Z_STRLEN_P(op5), op6, op6_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+op2_len+Z_STRLEN_P(op3)+op4_len+Z_STRLEN_P(op5)+op6_len, Z_STRVAL_P(op7), Z_STRLEN_P(op7));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy7) {
		zval_dtor(op7);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vv(zval *result, zval *op1, zval *op2, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vvsv(zval *result, zval *op1, zval *op2, char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2)+op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vvv(zval *result, zval *op1, zval *op2, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vvvv(zval *result, zval *op1, zval *op2, zval *op3, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op4_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2)+Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

void phalcon_concat_vvvvv(zval *result, zval *op1, zval *op2, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op4_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy4 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_P(result) != IS_STRING) {
			zend_make_printable_zval(result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(result, (&result_copy));
			}
		}

		offset = Z_STRLEN_P(result);
		length += offset;
		Z_STRVAL_P(result) = (char *) erealloc(Z_STRVAL_P(result), length+1);

	} else {
		Z_STRVAL_P(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_P(result)+offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2)+Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_P(result)+offset+Z_STRLEN_P(op1)+Z_STRLEN_P(op2)+Z_STRLEN_P(op3)+Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_P(result)[length] = 0;
	Z_TYPE_P(result) = IS_STRING;
	Z_STRLEN_P(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}





#ifdef HAVE_CONFIG_H
#endif





int phalcon_file_exists(zval *filename TSRMLS_DC){

	if (Z_TYPE_P(filename) != IS_STRING) {
		return FAILURE;
	}

	if (VCWD_ACCESS(Z_STRVAL_P(filename), F_OK) == 0) {
		return SUCCESS;
	}

	return FAILURE;
}

int phalcon_compare_mtime(zval *filename1, zval *filename2 TSRMLS_DC){

	php_stream_statbuf statbuffer1, statbuffer2;

	if (Z_TYPE_P(filename1) != IS_STRING || Z_TYPE_P(filename2) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for compare_mtime()");
		return 0;
	}

	if (php_stream_stat_path_ex(Z_STRVAL_P(filename1), 0, &statbuffer1, NULL)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "mstat failed for %s", Z_STRVAL_P(filename1));
		return 0;
	}

	if (php_stream_stat_path_ex(Z_STRVAL_P(filename2), 0, &statbuffer2, NULL)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "mstat failed for %s", Z_STRVAL_P(filename2));
		return 0;
	}

	return (int) (statbuffer1.sb.st_mtime >= statbuffer2.sb.st_mtime);
}

void phalcon_fast_filemtime(zval *return_value, zval *filename TSRMLS_DC){

	if (Z_TYPE_P(filename) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for fast_filemtime()");
		return;
	}

	php_stat(Z_STRVAL_P(filename), (php_stat_len) Z_STRLEN_P(filename), FS_MTIME, return_value TSRMLS_CC);
}



#ifdef HAVE_CONFIG_H
#endif




void phalcon_throw_exception(zval *object TSRMLS_DC){
	Z_ADDREF_P(object);
	zend_throw_exception_object(object TSRMLS_CC);
	phalcon_memory_restore_stack(TSRMLS_C);
}

void phalcon_throw_exception_string(zend_class_entry *ce, char *message, zend_uint message_len TSRMLS_DC){

	zval *object, *msg;

	ALLOC_INIT_ZVAL(object);
	object_init_ex(object, ce);

	PHALCON_INIT_VAR(msg);
	ZVAL_STRINGL(msg, message, message_len, 1);

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", msg, PH_CHECK);

	zend_throw_exception_object(object TSRMLS_CC);

	phalcon_memory_restore_stack(TSRMLS_C);
}

void phalcon_throw_exception_zval(zend_class_entry *ce, zval *message TSRMLS_DC){

	zval *object;

	ALLOC_INIT_ZVAL(object);
	object_init_ex(object, ce);

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", message, PH_CHECK);

	zend_throw_exception_object(object TSRMLS_CC);

	phalcon_memory_restore_stack(TSRMLS_C);
}

void phalcon_throw_exception_internal(zval *exception TSRMLS_DC) {

	if (exception != NULL) {
		zval *previous = EG(exception);
		zend_exception_set_previous(exception, EG(exception) TSRMLS_CC);
		EG(exception) = exception;
		if (previous) {
			return;
		}
	}
	if (!EG(current_execute_data)) {
		if(EG(exception)) {
			zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
		}
		zend_error(E_ERROR, "Exception thrown without a stack frame");
	}

	if (zend_throw_exception_hook) {
    	zend_throw_exception_hook(exception TSRMLS_CC);
	}

	if (EG(current_execute_data)->opline == NULL ||
    	(EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {
		/* no need to rethrow the exception */
		return;
	}
	EG(opline_before_exception) = EG(current_execute_data)->opline;
	EG(current_execute_data)->opline = EG(exception_op);

}

/*void phalcon_try_execute(zval *success, zval *return_value, zval *call_object, zval *params, zval **exception TSRMLS_DC){

	zval *fn = NULL;
	int status = FAILURE;
	zval *func_params[] = { call_object, params };

	PHALCON_ALLOC_ZVAL(fn);
	ZVAL_STRING(fn, "call_user_func_array", 0);

	status = phalcon_call_user_function(CG(function_table), NULL, fn, return_value, 2, func_params TSRMLS_CC);
	if (status == FAILURE) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Call to undefined function call_user_func_array()");
	}

	ZVAL_NULL(fn);
	zval_ptr_dtor(&fn);

	if (status == SUCCESS) {
		zend_exception_restore(TSRMLS_C);
		if (EG(exception)) {
			zval_ptr_dtor(exception);
			*exception = EG(exception);
			EG(exception) = NULL;
			EG(current_execute_data)->opline->opcode = 40;
			ZVAL_BOOL(success, 0);
		} else {
			ZVAL_BOOL(success, 1);
		}
	} else {
		ZVAL_BOOL(success, 0);
	}

}*/



#ifdef HAVE_CONFIG_H
#endif


int PHALCON_FASTCALL phalcon_internal_require(zval **return_value, zval *require_path TSRMLS_DC){

	int ret;
	char *file_path;
	int file_path_length;
	zend_file_handle file_handle;
	zval *result = NULL;
	int status = SUCCESS;
	int dummy = 0;

	zval **original_return_value = EG(return_value_ptr_ptr);
	zend_op **original_opline_ptr = EG(opline_ptr);
	zend_op_array *original_active_op_array = EG(active_op_array);

	zend_op_array *new_op_array = NULL;

	if (Z_TYPE_P(require_path) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Invalid require path value");
		status = FAILURE;
	} else {

		file_path = Z_STRVAL_P(require_path);
		file_path_length = Z_STRLEN_P(require_path);

		ret = php_stream_open_for_zend_ex(file_path, &file_handle, ENFORCE_SAFE_MODE|USE_PATH|STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
		if (ret == SUCCESS) {

			if (!file_handle.opened_path) {
				file_handle.opened_path = estrndup(file_path, file_path_length);
			}

			EG(exit_status) = 0;
			PG(during_request_startup) = 0;

			if (file_handle.filename) {
				if ((file_handle.filename[0] != '-' || file_handle.filename[1] != 0) && file_handle.opened_path == NULL && file_handle.type != ZEND_HANDLE_FILENAME) {
					char realfile[MAXPATHLEN];
					int realfile_len;
					dummy = 1;
					if(expand_filepath(file_handle.filename, realfile TSRMLS_CC)){
						realfile_len =  strlen(realfile);
						zend_hash_add(&EG(included_files), realfile, realfile_len+1, (void *)&dummy, sizeof(int), NULL);
						file_handle.opened_path = estrndup(realfile, realfile_len);
					}
				}
			}

			if (!dummy) {
				if (file_handle.opened_path) {
					zend_hash_add(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path) + 1, (void *)&dummy, sizeof(int), NULL);
				}
			}

			new_op_array = zend_compile_file(&file_handle, ZEND_REQUIRE TSRMLS_CC);
			zend_destroy_file_handle(&file_handle TSRMLS_CC);

			if (new_op_array) {

				EG(return_value_ptr_ptr) = &result;
				EG(active_op_array) = new_op_array;
				if (!EG(active_symbol_table)) {
					zend_rebuild_symbol_table(TSRMLS_C);
				}

				zend_execute(new_op_array TSRMLS_CC);
				zend_exception_restore(TSRMLS_C);

				destroy_op_array(new_op_array TSRMLS_CC);
				efree(new_op_array);
				if (!EG(exception)) {
					if (EG(return_value_ptr_ptr)) {
						if (return_value) {
							//COPY_PZVAL_TO_ZVAL(*return_value, *EG(return_value_ptr_ptr));
						}
						zval_ptr_dtor(EG(return_value_ptr_ptr));
					}
				}

			}

			EG(return_value_ptr_ptr) = original_return_value;
			EG(opline_ptr) = original_opline_ptr;
			EG(active_op_array) = original_active_op_array;

			if (EG(exception) || EG(exit_status) == 255) {
				status = FAILURE;
			}

		} else {
			zend_destroy_file_handle(&file_handle TSRMLS_CC);
			status = FAILURE;
		}

	}

	if (status == FAILURE){
		phalcon_memory_restore_stack(TSRMLS_C);
	}

	return status;
}

int PHALCON_FASTCALL phalcon_require(zval *require_path TSRMLS_DC){
	return phalcon_internal_require(NULL, require_path TSRMLS_CC);
}

int PHALCON_FASTCALL phalcon_require_ret(zval *return_value, zval *require_path TSRMLS_DC){
	return phalcon_internal_require(&return_value, require_path TSRMLS_CC);
}




#define PDO_ATTR_ERRMODE 3
#define PDO_ATTR_CASE 8
#define PDO_ATTR_CURSOR 10
#define PDO_ATTR_PERSISTENT 12

#define PDO_CASE_LOWER 2
#define PDO_CURSOR_SCROLL 1
#define PDO_ERRMODE_SILENT 0
#define PDO_ERRMODE_WARNING 1
#define PDO_ERRMODE_EXCEPTION 2



typedef struct _phql_parser_token {
	int opcode;
	char *token;
	int token_len;
	int free_flag;
} phql_parser_token;

typedef struct _phql_parser_status {
	int status;
	zval *ret;
	phql_scanner_state *scanner_state;
	char *syntax_error;
	zend_uint syntax_error_len;
} phql_parser_status;

#define PHQL_PARSING_OK 1
#define PHQL_PARSING_FAILED 0

int phql_parse_phql(zval *result, zval *phql TSRMLS_DC);
int phql_internal_parse_phql(zval **result, char *phql, zval **error_msg TSRMLS_DC);




typedef struct _phvolt_parser_token {
	int opcode;
	char *token;
	int token_len;
	int free_flag;
} phvolt_parser_token;

typedef struct _phvolt_parser_status {
	int status;
	zval *ret;
	phvolt_scanner_state *scanner_state;
	char *syntax_error;
	zend_uint syntax_error_len;
} phvolt_parser_status;

#define PHVOLT_PARSING_OK 1
#define PHVOLT_PARSING_FAILED 0

int phvolt_parse_view(zval *result, zval *view_code TSRMLS_DC);
int phvolt_internal_parse_view(zval **result, char *view_code, unsigned int view_length, zval **error_msg TSRMLS_DC);




#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Loader){

	PHALCON_REGISTER_CLASS(Phalcon, Loader, loader, phalcon_loader_method_entry, 0);

	zend_declare_property_null(phalcon_loader_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_foundPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_checkedPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_prefixes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_classes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_extensions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_namespaces"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_directories"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_loader_ce, SL("_registered"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_loader_ce TSRMLS_CC, 1, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Loader, __construct){

	zval *a0 = NULL;

	PHALCON_MM_GROW();

	
	PHALCON_INIT_VAR(a0);
	array_init(a0);
	add_next_index_stringl(a0, SL("php"), 1);
	zend_update_property(phalcon_loader_ce, this_ptr, SL("_extensions"), a0 TSRMLS_CC);
	

	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Loader, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Loader, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Loader, setExtensions){

	zval *extensions;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &extensions) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(extensions) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter $extensions must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_extensions"), extensions TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, getExtensions){


	RETURN_MEMBER(this_ptr, "_extensions");
}

PHP_METHOD(Phalcon_Loader, registerNamespaces){

	zval *namespaces, *merge = NULL, *current_namespaces;
	zval *merged_namespaces;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &namespaces, &merge) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!merge) {
		PHALCON_INIT_NVAR(merge);
		ZVAL_BOOL(merge, 0);
	}
	
	if (Z_TYPE_P(namespaces) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter $namespaces must be an Array");
		return;
	}
	if (zend_is_true(merge)) {
		PHALCON_INIT_VAR(current_namespaces);
		phalcon_read_property(&current_namespaces, this_ptr, SL("_namespaces"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(merged_namespaces);
		PHALCON_CALL_FUNC_PARAMS_2(merged_namespaces, "array_merge", current_namespaces, namespaces);
		phalcon_update_property_zval(this_ptr, SL("_namespaces"), merged_namespaces TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_namespaces"), namespaces TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, getNamespaces){


	RETURN_MEMBER(this_ptr, "_namespaces");
}

PHP_METHOD(Phalcon_Loader, registerPrefixes){

	zval *prefixes, *merge = NULL, *current_prefixes, *merged_prefixes;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &prefixes, &merge) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!merge) {
		PHALCON_INIT_NVAR(merge);
		ZVAL_BOOL(merge, 0);
	}
	
	if (Z_TYPE_P(prefixes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter $prefixes must be an Array");
		return;
	}
	if (zend_is_true(merge)) {
		PHALCON_INIT_VAR(current_prefixes);
		phalcon_read_property(&current_prefixes, this_ptr, SL("_prefixes"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(merged_prefixes);
		PHALCON_CALL_FUNC_PARAMS_2(merged_prefixes, "array_merge", current_prefixes, prefixes);
		phalcon_update_property_zval(this_ptr, SL("_prefixes"), merged_prefixes TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_prefixes"), prefixes TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, getPrefixes){


	RETURN_MEMBER(this_ptr, "_prefixes");
}

PHP_METHOD(Phalcon_Loader, registerDirs){

	zval *directories, *merge = NULL, *current_directories;
	zval *merged_directories;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &directories, &merge) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!merge) {
		PHALCON_INIT_NVAR(merge);
		ZVAL_BOOL(merge, 0);
	}
	
	if (Z_TYPE_P(directories) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter $directories must be an Array");
		return;
	}
	if (zend_is_true(merge)) {
		PHALCON_INIT_VAR(current_directories);
		phalcon_read_property(&current_directories, this_ptr, SL("_directories"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(merged_directories);
		PHALCON_CALL_FUNC_PARAMS_2(merged_directories, "array_merge", current_directories, directories);
		phalcon_update_property_zval(this_ptr, SL("_directories"), merged_directories TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_directories"), directories TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, getDirs){


	RETURN_MEMBER(this_ptr, "_directories");
}

PHP_METHOD(Phalcon_Loader, registerClasses){

	zval *classes, *merge = NULL, *current_classes, *merged_classes;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &classes, &merge) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!merge) {
		PHALCON_INIT_NVAR(merge);
		ZVAL_BOOL(merge, 0);
	}
	
	if (Z_TYPE_P(classes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter $classes must be an Array");
		return;
	}
	if (zend_is_true(merge)) {
		PHALCON_INIT_VAR(current_classes);
		phalcon_read_property(&current_classes, this_ptr, SL("_classes"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(merged_classes);
		PHALCON_CALL_FUNC_PARAMS_2(merged_classes, "array_merge", current_classes, classes);
		phalcon_update_property_zval(this_ptr, SL("_classes"), merged_classes TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_classes"), classes TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, getClasses){


	RETURN_MEMBER(this_ptr, "_classes");
}

PHP_METHOD(Phalcon_Loader, register){

	zval *registered, *autoloader;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(registered);
	phalcon_read_property(&registered, this_ptr, SL("_registered"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(registered)) {
		PHALCON_INIT_VAR(autoloader);
		array_init(autoloader);
		phalcon_array_append(&autoloader, this_ptr, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(autoloader, SL("autoLoad"), 1);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("spl_autoload_register", autoloader);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, unregister){

	zval *registered, *autoloader;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(registered);
	phalcon_read_property(&registered, this_ptr, SL("_registered"), PH_NOISY_CC);
	if (PHALCON_IS_TRUE(registered)) {
		PHALCON_INIT_VAR(autoloader);
		array_init(autoloader);
		phalcon_array_append(&autoloader, this_ptr, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(autoloader, SL("autoLoad"), 1);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("spl_autoload_unregister", autoloader);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Loader, autoLoad){

	zval *class_name, *events_manager, *event_name = NULL;
	zval *classes, *file_path = NULL, *extensions, *ds, *namespace_separator;
	zval *empty_str, *zero, *namespaces, *directory = NULL;
	zval *prefix = NULL, *prefix_namespace = NULL, *file_name = NULL;
	zval *extension = NULL, *complete_path = NULL, *pseudo_separator;
	zval *prefixes, *no_prefix_class = NULL, *ds_class_name;
	zval *ns_class_name, *directories;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &class_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "loader:beforeCheckClass", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, class_name, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(classes);
	phalcon_read_property(&classes, this_ptr, SL("_classes"), PH_NOISY_CC);
	if (Z_TYPE_P(classes) == IS_ARRAY) { 
		eval_int = phalcon_array_isset(classes, class_name);
		if (eval_int) {
			PHALCON_INIT_VAR(file_path);
			phalcon_array_fetch(&file_path, classes, class_name, PH_NOISY_CC);
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				phalcon_update_property_zval(this_ptr, SL("_foundPath"), file_path TSRMLS_CC);
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "loader:pathFound", 1);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
			}
	
			if (phalcon_require(file_path TSRMLS_CC) == FAILURE) {
				return;
			}
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_INIT_VAR(extensions);
	phalcon_read_property(&extensions, this_ptr, SL("_extensions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(ds);
	zend_get_constant(SL("DIRECTORY_SEPARATOR"), ds TSRMLS_CC);
	
	PHALCON_INIT_VAR(namespace_separator);
	ZVAL_STRING(namespace_separator, "\\", 1);
	
	PHALCON_INIT_VAR(empty_str);
	ZVAL_STRING(empty_str, "", 1);
	
	PHALCON_INIT_VAR(zero);
	ZVAL_LONG(zero, 0);
	
	PHALCON_INIT_VAR(namespaces);
	phalcon_read_property(&namespaces, this_ptr, SL("_namespaces"), PH_NOISY_CC);
	if (Z_TYPE_P(namespaces) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(namespaces TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(namespaces);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(prefix, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(directory);
	
			if (phalcon_start_with(class_name, prefix)) {
				PHALCON_INIT_NVAR(prefix_namespace);
				PHALCON_CONCAT_VV(prefix_namespace, prefix, namespace_separator);
	
				PHALCON_INIT_NVAR(file_name);
				phalcon_fast_str_replace(file_name, prefix_namespace, empty_str, class_name TSRMLS_CC);
				if (zend_is_true(file_name)) {
	
					if (!phalcon_valid_foreach(extensions TSRMLS_CC)) {
						return;
					}
	
					ah1 = Z_ARRVAL_P(extensions);
					zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
					ph_cycle_start_1:
	
						if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
							goto ph_cycle_end_1;
						}
	
						PHALCON_GET_FOREACH_VALUE(extension);
	
						PHALCON_INIT_NVAR(complete_path);
						PHALCON_CONCAT_VVSV(complete_path, directory, file_name, ".", extension);
	
						PHALCON_INIT_NVAR(file_path);
						phalcon_fast_str_replace(file_path, namespace_separator, ds, complete_path TSRMLS_CC);
						if (Z_TYPE_P(events_manager) == IS_OBJECT) {
							phalcon_update_property_zval(this_ptr, SL("_checkedPath"), file_path TSRMLS_CC);
	
							PHALCON_INIT_NVAR(event_name);
							ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
							PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
						}
	
						if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
							if (Z_TYPE_P(events_manager) == IS_OBJECT) {
								phalcon_update_property_zval(this_ptr, SL("_foundPath"), file_path TSRMLS_CC);
	
								PHALCON_INIT_NVAR(event_name);
								ZVAL_STRING(event_name, "loader:pathFound", 1);
								PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
							}
							if (phalcon_require(file_path TSRMLS_CC) == FAILURE) {
								return;
							}
							PHALCON_MM_RESTORE();
							RETURN_TRUE;
						}
	
						zend_hash_move_forward_ex(ah1, &hp1);
						goto ph_cycle_start_1;
	
					ph_cycle_end_1:
					if(0){}
	
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(pseudo_separator);
	ZVAL_STRING(pseudo_separator, "_", 1);
	
	PHALCON_INIT_VAR(prefixes);
	phalcon_read_property(&prefixes, this_ptr, SL("_prefixes"), PH_NOISY_CC);
	if (Z_TYPE_P(prefixes) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(prefixes TSRMLS_CC)) {
			return;
		}
	
		ah2 = Z_ARRVAL_P(prefixes);
		zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
		ph_cycle_start_2:
	
			if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
				goto ph_cycle_end_2;
			}
	
			PHALCON_GET_FOREACH_KEY(prefix, ah2, hp2);
			PHALCON_GET_FOREACH_VALUE(directory);
	
			if (phalcon_start_with(class_name, prefix)) {
				PHALCON_INIT_NVAR(no_prefix_class);
				phalcon_fast_str_replace(no_prefix_class, prefix, empty_str, class_name TSRMLS_CC);
	
				PHALCON_INIT_NVAR(file_name);
				phalcon_fast_str_replace(file_name, pseudo_separator, ds, no_prefix_class TSRMLS_CC);
				if (zend_is_true(file_name)) {
	
					if (!phalcon_valid_foreach(extensions TSRMLS_CC)) {
						return;
					}
	
					ah3 = Z_ARRVAL_P(extensions);
					zend_hash_internal_pointer_reset_ex(ah3, &hp3);
	
					ph_cycle_start_3:
	
						if (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) != SUCCESS) {
							goto ph_cycle_end_3;
						}
	
						PHALCON_GET_FOREACH_VALUE(extension);
	
						PHALCON_INIT_NVAR(complete_path);
						PHALCON_CONCAT_VVSV(complete_path, directory, file_name, ".", extension);
	
						PHALCON_INIT_NVAR(file_path);
						phalcon_fast_str_replace(file_path, namespace_separator, ds, complete_path TSRMLS_CC);
						if (Z_TYPE_P(events_manager) == IS_OBJECT) {
							phalcon_update_property_zval(this_ptr, SL("_checkedPath"), file_path TSRMLS_CC);
	
							PHALCON_INIT_NVAR(event_name);
							ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
							PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
						}
	
						if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
							if (Z_TYPE_P(events_manager) == IS_OBJECT) {
								phalcon_update_property_zval(this_ptr, SL("_foundPath"), file_path TSRMLS_CC);
	
								PHALCON_INIT_NVAR(event_name);
								ZVAL_STRING(event_name, "loader:pathFound", 1);
								PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
							}
							if (phalcon_require(file_path TSRMLS_CC) == FAILURE) {
								return;
							}
							PHALCON_MM_RESTORE();
							RETURN_TRUE;
						}
	
						zend_hash_move_forward_ex(ah3, &hp3);
						goto ph_cycle_start_3;
	
					ph_cycle_end_3:
					if(0){}
	
				}
			}
	
			zend_hash_move_forward_ex(ah2, &hp2);
			goto ph_cycle_start_2;
	
		ph_cycle_end_2:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(ds_class_name);
	phalcon_fast_str_replace(ds_class_name, pseudo_separator, ds, class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(ns_class_name);
	phalcon_fast_str_replace(ns_class_name, namespace_separator, ds, ds_class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(directories);
	phalcon_read_property(&directories, this_ptr, SL("_directories"), PH_NOISY_CC);
	if (Z_TYPE_P(directories) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(directories TSRMLS_CC)) {
			return;
		}
	
		ah4 = Z_ARRVAL_P(directories);
		zend_hash_internal_pointer_reset_ex(ah4, &hp4);
	
		ph_cycle_start_4:
	
			if (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) != SUCCESS) {
				goto ph_cycle_end_4;
			}
	
			PHALCON_GET_FOREACH_VALUE(directory);
	
	
			if (!phalcon_valid_foreach(extensions TSRMLS_CC)) {
				return;
			}
	
			ah5 = Z_ARRVAL_P(extensions);
			zend_hash_internal_pointer_reset_ex(ah5, &hp5);
	
			ph_cycle_start_5:
	
				if (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) != SUCCESS) {
					goto ph_cycle_end_5;
				}
	
				PHALCON_GET_FOREACH_VALUE(extension);
	
				PHALCON_INIT_NVAR(file_path);
				PHALCON_CONCAT_VVSV(file_path, directory, ns_class_name, ".", extension);
				if (Z_TYPE_P(events_manager) == IS_OBJECT) {
					phalcon_update_property_zval(this_ptr, SL("_checkedPath"), file_path TSRMLS_CC);
	
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
					PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
				}
	
				if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
					if (Z_TYPE_P(events_manager) == IS_OBJECT) {
						phalcon_update_property_zval(this_ptr, SL("_foundPath"), file_path TSRMLS_CC);
	
						PHALCON_INIT_NVAR(event_name);
						ZVAL_STRING(event_name, "loader:pathFound", 1);
						PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, file_path, PH_NO_CHECK);
					}
					if (phalcon_require(file_path TSRMLS_CC) == FAILURE) {
						return;
					}
					PHALCON_MM_RESTORE();
					RETURN_TRUE;
				}
	
				zend_hash_move_forward_ex(ah5, &hp5);
				goto ph_cycle_start_5;
	
			ph_cycle_end_5:
	
	
			zend_hash_move_forward_ex(ah4, &hp4);
			goto ph_cycle_start_4;
	
		ph_cycle_end_4:
		if(0){}
	
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "loader:afterCheckClass", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, class_name, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Loader, getFoundPath){


	RETURN_MEMBER(this_ptr, "_foundPath");
}

PHP_METHOD(Phalcon_Loader, getCheckedPath){


	RETURN_MEMBER(this_ptr, "_checkedPath");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Acl){

	PHALCON_REGISTER_CLASS(Phalcon, Acl, acl, phalcon_acl_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_acl_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_acl_ce, SL("ALLOW"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_acl_ce, SL("DENY"), 0 TSRMLS_CC);

	zend_class_implements(phalcon_acl_ce TSRMLS_CC, 1, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Acl, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Acl, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Backend){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache, Backend, cache_backend, phalcon_cache_backend_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_cache_backend_ce, SL("_frontendObject"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_backend_ce, SL("_backendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_lastKey"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_fresh"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_started"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Backend, __construct){

	zval *frontend_object, *backend_options = NULL, *prefix;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!backend_options) {
		PHALCON_INIT_NVAR(backend_options);
		array_init(backend_options);
	}
	
	if (Z_TYPE_P(frontend_object) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Frontend must be an Object");
		return;
	}
	eval_int = phalcon_array_isset_string(backend_options, SS("prefix"));
	if (eval_int) {
		PHALCON_INIT_VAR(prefix);
		phalcon_array_fetch_string(&prefix, backend_options, SL("prefix"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_prefix"), prefix TSRMLS_CC);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_frontendObject"), frontend_object TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_backendOptions"), backend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend, start){

	zval *key_name, *backend, *front_end, *existing_cache;
	zval *fresh = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(existing_cache);
	PHALCON_CALL_METHOD_PARAMS_1(existing_cache, this_ptr, "get", key_name, PH_NO_CHECK);
	if (Z_TYPE_P(existing_cache) == IS_NULL) {
		PHALCON_INIT_VAR(fresh);
		ZVAL_BOOL(fresh, 1);
		PHALCON_CALL_METHOD_NORETURN(front_end, "start", PH_NO_CHECK);
	} else {
		PHALCON_INIT_NVAR(fresh);
		ZVAL_BOOL(fresh, 0);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_fresh"), fresh TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_started"), 1 TSRMLS_CC);
	
	RETURN_CCTOR(existing_cache);
}

PHP_METHOD(Phalcon_Cache_Backend, stop){

	zval *stop_buffer = NULL, *front_end;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!stop_buffer) {
		PHALCON_INIT_NVAR(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	if (PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend, getFrontend){


	RETURN_MEMBER(this_ptr, "_frontendObject");
}

PHP_METHOD(Phalcon_Cache_Backend, isFresh){


	RETURN_MEMBER(this_ptr, "_fresh");
}

PHP_METHOD(Phalcon_Cache_Backend, isStarted){


	RETURN_MEMBER(this_ptr, "_started");
}

PHP_METHOD(Phalcon_Cache_Backend, getLastKey){


	RETURN_MEMBER(this_ptr, "_lastKey");
}

PHP_METHOD(Phalcon_Cache_Backend, get){


	
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Cache_FrontendInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Cache, FrontendInterface, cache_frontendinterface, phalcon_cache_frontendinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, getLifetime);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, isBuffering);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, start);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, getContent);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, stop);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, beforeStore);

PHALCON_DOC_METHOD(Phalcon_Cache_FrontendInterface, afterRetrieve);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Mongo){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Mongo, cache_backend_mongo, "phalcon\\cache\\backend", phalcon_cache_backend_mongo_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_mongo_ce, SL("_collection"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_mongo_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, __construct){

	zval *frontend_object, *backend_options = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!backend_options) {
		PHALCON_INIT_NVAR(backend_options);
		array_init(backend_options);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("mongo"));
	if (!eval_int) {
		eval_int = phalcon_array_isset_string(backend_options, SS("server"));
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'server' is required");
			return;
		}
	}
	eval_int = phalcon_array_isset_string(backend_options, SS("db"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'db' is required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("collection"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'collection' is required");
		return;
	}
	
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Cache\\Backend\\Mongo", "__construct", frontend_object, backend_options);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, _getCollection){

	zval *mongo_collection = NULL, *backend_options;
	zval *mongo = NULL, *server, *database, *collection, *mongo_database;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(mongo_collection);
	phalcon_read_property(&mongo_collection, this_ptr, SL("_collection"), PH_NOISY_CC);
	if (Z_TYPE_P(mongo_collection) != IS_OBJECT) {
		PHALCON_INIT_VAR(backend_options);
		phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(backend_options, SS("mongo"));
		if (eval_int) {
			PHALCON_INIT_VAR(mongo);
			phalcon_array_fetch_string(&mongo, backend_options, SL("mongo"), PH_NOISY_CC);
			if (Z_TYPE_P(mongo) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The 'mongo' parameter must be a valid Mongo instance");
				return;
			}
		} else {
			PHALCON_INIT_VAR(server);
			phalcon_array_fetch_string(&server, backend_options, SL("server"), PH_NOISY_CC);
			if (Z_TYPE_P(server) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB connection string");
				return;
			}
	
			ce0 = zend_fetch_class(SL("Mongo"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
			PHALCON_INIT_NVAR(mongo);
			object_init_ex(mongo, ce0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(mongo, "__construct", server, PH_CHECK);
		}
	
		PHALCON_INIT_VAR(database);
		phalcon_array_fetch_string(&database, backend_options, SL("db"), PH_NOISY_CC);
		if (Z_TYPE_P(database) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB db");
			return;
		}
	
		PHALCON_INIT_VAR(collection);
		phalcon_array_fetch_string(&collection, backend_options, SL("collection"), PH_NOISY_CC);
		if (Z_TYPE_P(collection) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB collection");
			return;
		}
	
		PHALCON_INIT_VAR(mongo_database);
		PHALCON_CALL_METHOD_PARAMS_1(mongo_database, mongo, "selectdb", database, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(mongo_collection);
		PHALCON_CALL_METHOD_PARAMS_1(mongo_collection, mongo_database, "selectcollection", collection, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(mongo_collection);
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, get){

	zval *key_name, *lifetime = NULL, *front_end, *prefix;
	zval *prefixed_key, *collection, *conditions;
	zval *document, *time, *ttl = NULL, *modified_time, *difference;
	zval *not_expired, *cached_content, *content;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_INIT_VAR(collection);
	PHALCON_CALL_METHOD(collection, this_ptr, "_getcollection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	phalcon_array_update_string(&conditions, SL("key"), &prefixed_key, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(document);
	PHALCON_CALL_METHOD_PARAMS_1(document, collection, "findone", conditions, PH_NO_CHECK);
	if (Z_TYPE_P(document) == IS_ARRAY) { 
		PHALCON_INIT_VAR(time);
		PHALCON_CALL_FUNC(time, "time");
		if (Z_TYPE_P(lifetime) == IS_NULL) {
			PHALCON_INIT_VAR(ttl);
			PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
		} else {
			PHALCON_CPY_WRT(ttl, lifetime);
		}
	
		eval_int = phalcon_array_isset_string(document, SS("time"));
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
			return;
		}
	
		PHALCON_INIT_VAR(modified_time);
		phalcon_array_fetch_string(&modified_time, document, SL("time"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(difference);
		sub_function(difference, time, ttl TSRMLS_CC);
	
		PHALCON_INIT_VAR(not_expired);
		is_smaller_function(not_expired, difference, modified_time TSRMLS_CC);
		if (PHALCON_IS_TRUE(not_expired)) {
			eval_int = phalcon_array_isset_string(document, SS("data"));
			if (!eval_int) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
				return;
			}
	
			PHALCON_INIT_VAR(cached_content);
			phalcon_array_fetch_string(&cached_content, document, SL("data"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(content);
			PHALCON_CALL_METHOD_PARAMS_1(content, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	
			RETURN_CCTOR(content);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *prefix, *front_end, *backend_options;
	zval *cached_content = NULL, *prepared_content, *ttl = NULL;
	zval *collection, *time, *conditions, *document;
	zval *data, *is_buffering;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (!content) {
		PHALCON_INIT_NVAR(content);
	}
	
	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_INIT_NVAR(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	if (Z_TYPE_P(content) == IS_NULL) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_INIT_VAR(ttl);
		PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}
	
	PHALCON_INIT_VAR(collection);
	PHALCON_CALL_METHOD(collection, this_ptr, "_getcollection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(time);
	PHALCON_CALL_FUNC(time, "time");
	
	PHALCON_INIT_NVAR(ttl);
	phalcon_add_function(ttl, lifetime, time TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	phalcon_array_update_string(&conditions, SL("key"), &last_key, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(document);
	PHALCON_CALL_METHOD_PARAMS_1(document, collection, "findone", conditions, PH_NO_CHECK);
	if (Z_TYPE_P(document) == IS_ARRAY) { 
		phalcon_array_update_string(&document, SL("time"), &ttl, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&document, SL("data"), &prepared_content, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(collection, "save", document, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(data);
		array_init(data);
		phalcon_array_update_string(&data, SL("key"), &last_key, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&data, SL("time"), &ttl, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&data, SL("data"), &prepared_content, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(collection, "save", data, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, delete){

	zval *key_name, *prefix, *prefixed_key, *collection;
	zval *conditions, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	
	PHALCON_INIT_VAR(collection);
	PHALCON_CALL_METHOD(collection, this_ptr, "_getcollection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	phalcon_array_update_string(&conditions, SL("key"), &prefixed_key, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, collection, "remove", conditions, PH_NO_CHECK);
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, queryKeys){

	zval *prefix = NULL, *collection, *fields = NULL, *pattern, *regex;
	zval *conditions = NULL, *documents, *keys, *documents_array;
	zval *document = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_INIT_NVAR(prefix);
	}
	
	PHALCON_INIT_VAR(collection);
	PHALCON_CALL_METHOD(collection, this_ptr, "_getcollection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	add_next_index_stringl(fields, SL("key"), 1);
	if (Z_TYPE_P(prefix) != IS_NULL) {
		PHALCON_INIT_VAR(pattern);
		PHALCON_CONCAT_SVS(pattern, "/^", prefix, "/");
		ce0 = zend_fetch_class(SL("MongoRegex"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
		PHALCON_INIT_VAR(regex);
		object_init_ex(regex, ce0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(regex, "__construct", pattern, PH_CHECK);
	
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
		phalcon_array_update_string(&conditions, SL("key"), &regex, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(conditions);
		array_init(conditions);
	}
	
	PHALCON_INIT_NVAR(fields);
	array_init(fields);
	add_next_index_stringl(fields, SL("key"), 1);
	
	PHALCON_INIT_VAR(documents);
	PHALCON_CALL_METHOD_PARAMS_2(documents, collection, "find", conditions, fields, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(keys);
	array_init(keys);
	
	PHALCON_INIT_VAR(documents_array);
	PHALCON_CALL_FUNC_PARAMS_1(documents_array, "iterator_to_array", documents);
	
	if (!phalcon_valid_foreach(documents_array TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(documents_array);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(document);
	
		PHALCON_INIT_NVAR(key);
		phalcon_array_fetch_string(&key, document, SL("key"), PH_NOISY_CC);
		phalcon_array_append(&keys, key, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(keys);
}

PHP_METHOD(Phalcon_Cache_Backend_Mongo, exists){

	zval *key_name = NULL, *last_key = NULL, *prefix, *collection;
	zval *conditions, *number, *zero, *exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}
	if (zend_is_true(last_key)) {
		PHALCON_INIT_VAR(collection);
		PHALCON_CALL_METHOD(collection, this_ptr, "_getcollection", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
		phalcon_array_update_string(&conditions, SL("key"), &last_key, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(number);
		PHALCON_CALL_METHOD_PARAMS_1(number, collection, "count", conditions, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(zero);
		ZVAL_LONG(zero, 0);
	
		PHALCON_INIT_VAR(exists);
		is_smaller_function(exists, zero, number TSRMLS_CC);
	
		RETURN_NCTOR(exists);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Backend_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, File, cache_backend_file, "phalcon\\cache\\backend", phalcon_cache_backend_file_method_entry, 0);

	zend_class_implements(phalcon_cache_backend_file_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Backend_File, __construct){

	zval *frontend_object, *backend_options = NULL, *cache_dir;
	zval *is_writable;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!backend_options) {
		PHALCON_INIT_NVAR(backend_options);
		array_init(backend_options);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("cacheDir"));
	if (eval_int) {
		PHALCON_INIT_VAR(cache_dir);
		phalcon_array_fetch_string(&cache_dir, backend_options, SL("cacheDir"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(is_writable);
		PHALCON_CALL_FUNC_PARAMS_1(is_writable, "is_writable", cache_dir);
		if (PHALCON_IS_FALSE(is_writable)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache directory does not exist or is not writable");
			return;
		}
	
		PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Cache\\Backend\\File", "__construct", frontend_object, backend_options);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "You must specify the cache directory with the option cacheDir");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_File, get){

	zval *key_name, *lifetime = NULL, *backend, *front_end;
	zval *prefix, *filtered, *prefixed_key, *cache_dir;
	zval *cache_file, *time, *ttl = NULL, *modified_time, *difference;
	zval *not_expired, *cached_content, *processed;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(filtered);
	phalcon_filter_alphanum(filtered, key_name);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, filtered);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_INIT_VAR(cache_dir);
	phalcon_array_fetch_string(&cache_dir, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);
	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(time);
		PHALCON_CALL_FUNC(time, "time");
		if (Z_TYPE_P(lifetime) == IS_NULL) {
			PHALCON_INIT_VAR(ttl);
			PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
		} else {
			PHALCON_CPY_WRT(ttl, lifetime);
		}
	
		PHALCON_INIT_VAR(modified_time);
		PHALCON_CALL_FUNC_PARAMS_1(modified_time, "filemtime", cache_file);
	
		PHALCON_INIT_VAR(difference);
		sub_function(difference, time, ttl TSRMLS_CC);
	
		PHALCON_INIT_VAR(not_expired);
		is_smaller_function(not_expired, difference, modified_time TSRMLS_CC);
		if (PHALCON_IS_TRUE(not_expired)) {
			PHALCON_INIT_VAR(cached_content);
			PHALCON_CALL_FUNC_PARAMS_1(cached_content, "file_get_contents", cache_file);
	
			PHALCON_INIT_VAR(processed);
			PHALCON_CALL_METHOD_PARAMS_1(processed, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	
			RETURN_CCTOR(processed);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Cache_Backend_File, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *prefix, *filtered, *front_end;
	zval *backend, *cache_dir, *cache_file, *cached_content = NULL;
	zval *prepared_content, *is_buffering;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (!content) {
		PHALCON_INIT_NVAR(content);
	}
	
	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_INIT_NVAR(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(filtered);
		phalcon_filter_alphanum(filtered, key_name);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, filtered);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_dir);
	phalcon_array_fetch_string(&cache_dir, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, last_key);
	if (!zend_is_true(content)) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	PHALCON_CALL_FUNC_PARAMS_2_NORETURN("file_put_contents", cache_file, prepared_content);
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_File, delete){

	zval *key_name, *backend, *prefix, *filtered, *prefixed_key;
	zval *cache_dir, *cache_file, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(filtered);
	phalcon_filter_alphanum(filtered, key_name);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, filtered);
	
	PHALCON_INIT_VAR(cache_dir);
	phalcon_array_fetch_string(&cache_dir, backend, SL("cacheDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);
	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_FUNC_PARAMS_1(success, "unlink", cache_file);
	
		RETURN_CCTOR(success);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Cache_Backend_File, queryKeys){

	zval *prefix = NULL, *keys, *backend, *cache_dir, *iterator;
	zval *item = NULL, *is_directory = NULL, *key = NULL;
	zval *r0 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_INIT_NVAR(prefix);
	}
	
	PHALCON_INIT_VAR(keys);
	array_init(keys);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache_dir);
	phalcon_array_fetch_string(&cache_dir, backend, SL("cacheDir"), PH_NOISY_CC);
	ce0 = zend_fetch_class(SL("DirectoryIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(iterator, "__construct", cache_dir, PH_CHECK);
	PHALCON_CALL_METHOD_NORETURN(iterator, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, iterator, "valid", PH_NO_CHECK);
		if (!zend_is_true(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(item);
		PHALCON_CALL_METHOD(item, iterator, "current", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_directory);
		PHALCON_CALL_METHOD(is_directory, item, "isdir", PH_NO_CHECK);
		if (PHALCON_IS_FALSE(is_directory)) {
			PHALCON_INIT_NVAR(key);
			PHALCON_CALL_METHOD(key, item, "getfilename", PH_NO_CHECK);
			if (zend_is_true(prefix)) {
				if (!phalcon_start_with(key, prefix)) {
					goto ph_cycle_start_0;
				}
			}
	
			phalcon_array_append(&keys, key, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_CALL_METHOD_NORETURN(iterator, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	RETURN_CTOR(keys);
}

PHP_METHOD(Phalcon_Cache_Backend_File, exists){

	zval *key_name = NULL, *last_key = NULL, *prefix, *filtered, *backend_options;
	zval *cache_dir, *cache_file;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(filtered);
		phalcon_filter_alphanum(filtered, key_name);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, filtered);
	}
	if (zend_is_true(last_key)) {
		PHALCON_INIT_VAR(backend_options);
		phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(cache_dir);
		phalcon_array_fetch_string(&cache_dir, backend_options, SL("cacheDir"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(cache_file);
		PHALCON_CONCAT_VV(cache_file, cache_dir, last_key);
		if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Apc){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Apc, cache_backend_apc, "phalcon\\cache\\backend", phalcon_cache_backend_apc_method_entry, 0);

	zend_class_implements(phalcon_cache_backend_apc_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Backend_Apc, get){

	zval *key_name, *lifetime = NULL, *backend, *front_end;
	zval *prefixed_key, *cached_content, *processed;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCA", t0, key_name);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_INIT_VAR(cached_content);
	PHALCON_CALL_FUNC_PARAMS_1(cached_content, "apc_fetch", prefixed_key);
	if (PHALCON_IS_FALSE(cached_content)) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_INIT_VAR(processed);
	PHALCON_CALL_METHOD_PARAMS_1(processed, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	
	RETURN_CCTOR(processed);
}

PHP_METHOD(Phalcon_Cache_Backend_Apc, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *front_end, *backend, *cached_content = NULL;
	zval *prepared_content, *ttl = NULL, *is_buffering;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (!content) {
		PHALCON_INIT_NVAR(content);
	}
	
	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_INIT_NVAR(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_prefix"), PH_NOISY_CC);
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCA", t0, key_name);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	if (Z_TYPE_P(content) == IS_NULL) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_INIT_VAR(ttl);
		PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}
	
	PHALCON_CALL_FUNC_PARAMS_3_NORETURN("apc_store", last_key, prepared_content, ttl);
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Apc, delete){

	zval *key_name, *prefix, *key, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_SVV(key, "_PHCA", prefix, key_name);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_FUNC_PARAMS_1(success, "apc_delete", key);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Cache_Backend_Apc, queryKeys){

	zval *prefix = NULL, *keys, *type, *prefix_pattern, *iterator;
	zval *key = NULL;
	zval *r0 = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_INIT_NVAR(prefix);
		ZVAL_STRING(prefix, "", 1);
	}
	
	PHALCON_INIT_VAR(keys);
	array_init(keys);
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "user", 1);
	
	PHALCON_INIT_VAR(prefix_pattern);
	PHALCON_CONCAT_SVS(prefix_pattern, "/^_PHCA", prefix, "/");
	ce0 = zend_fetch_class(SL("APCIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, ce0);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(iterator, "__construct", type, prefix_pattern, PH_CHECK);
	PHALCON_CALL_METHOD_NORETURN(iterator, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, iterator, "valid", PH_NO_CHECK);
		if (!zend_is_true(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(key);
		PHALCON_CALL_METHOD(key, iterator, "key", PH_NO_CHECK);
		phalcon_array_append(&keys, key, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_NORETURN(iterator, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	RETURN_CTOR(keys);
}

PHP_METHOD(Phalcon_Cache_Backend_Apc, exists){

	zval *key_name = NULL, *last_key = NULL, *prefix, *cache_exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCA", prefix, key_name);
	}
	if (zend_is_true(last_key)) {
		PHALCON_INIT_VAR(cache_exists);
		PHALCON_CALL_FUNC_PARAMS_1(cache_exists, "apc_exists", last_key);
		if (PHALCON_IS_NOT_FALSE(cache_exists)) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Memcache){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Memcache, cache_backend_memcache, "phalcon\\cache\\backend", phalcon_cache_backend_memcache_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_memcache_ce, SL("_memcache"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_memcache_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, __construct){

	zval *frontend_object, *backend_options = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &frontend_object, &backend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!backend_options) {
		PHALCON_INIT_NVAR(backend_options);
		array_init(backend_options);
	} else {
		PHALCON_SEPARATE_PARAM(backend_options);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("host"));
	if (!eval_int) {
		phalcon_array_update_string_string(&backend_options, SL("host"), SL("127.0.0.1"), PH_SEPARATE TSRMLS_CC);
	}
	eval_int = phalcon_array_isset_string(backend_options, SS("port"));
	if (!eval_int) {
		phalcon_array_update_string_string(&backend_options, SL("port"), SL("11211"), PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("persistent"));
	if (!eval_int) {
		phalcon_array_update_string_bool(&backend_options, SL("persistent"), 0, PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(backend_options, SS("statsKey"));
	if (!eval_int) {
		phalcon_array_update_string_string(&backend_options, SL("statsKey"), SL("_PHCM"), PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_CALL_PARENT_PARAMS_2_NORETURN(this_ptr, "Phalcon\\Cache\\Backend\\Memcache", "__construct", frontend_object, backend_options);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, _connect){

	zval *backend_options, *memcache, *host, *port;
	zval *persistent, *success = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	ce0 = zend_fetch_class(SL("Memcache"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(memcache);
	object_init_ex(memcache, ce0);
	PHALCON_CALL_METHOD_NORETURN(memcache, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(host);
	phalcon_array_fetch_string(&host, backend_options, SL("host"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(port);
	phalcon_array_fetch_string(&port, backend_options, SL("port"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(persistent);
	phalcon_array_fetch_string(&persistent, backend_options, SL("persistent"), PH_NOISY_CC);
	if (zend_is_true(persistent)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_2(success, memcache, "connect", host, port, PH_NO_CHECK);
	} else {
		PHALCON_INIT_NVAR(success);
		PHALCON_CALL_METHOD_PARAMS_2(success, memcache, "pconnect", host, port, PH_NO_CHECK);
	}
	
	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cannot connect to Memcached server");
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_memcache"), memcache TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, get){

	zval *key_name, *lifetime = NULL, *memcache = NULL, *backend;
	zval *front_end, *prefix, *prefixed_key, *cached_content;
	zval *content;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &key_name, &lifetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(memcache);
		phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(backend);
	phalcon_read_property(&backend, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_zval(this_ptr, SL("_lastKey"), prefixed_key TSRMLS_CC);
	
	PHALCON_INIT_VAR(cached_content);
	PHALCON_CALL_METHOD_PARAMS_1(cached_content, memcache, "get", prefixed_key, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(cached_content)) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	PHALCON_INIT_VAR(content);
	PHALCON_CALL_METHOD_PARAMS_1(content, front_end, "afterretrieve", cached_content, PH_NO_CHECK);
	
	RETURN_CCTOR(content);
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key = NULL, *prefix, *front_end, *backend_options;
	zval *memcache = NULL, *cached_content = NULL, *prepared_content;
	zval *ttl = NULL, *flags, *success, *special_key, *keys = NULL, *is_buffering;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzzz", &key_name, &content, &lifetime, &stop_buffer) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (!content) {
		PHALCON_INIT_NVAR(content);
	}
	
	if (!lifetime) {
		PHALCON_INIT_NVAR(lifetime);
	}
	
	if (!stop_buffer) {
		PHALCON_INIT_NVAR(stop_buffer);
		ZVAL_BOOL(stop_buffer, 1);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}
	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	PHALCON_INIT_VAR(front_end);
	phalcon_read_property(&front_end, this_ptr, SL("_frontendObject"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(memcache);
		phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	}
	
	if (Z_TYPE_P(content) == IS_NULL) {
		PHALCON_INIT_VAR(cached_content);
		PHALCON_CALL_METHOD(cached_content, front_end, "getcontent", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(cached_content, content);
	}
	
	PHALCON_INIT_VAR(prepared_content);
	PHALCON_CALL_METHOD_PARAMS_1(prepared_content, front_end, "beforestore", cached_content, PH_NO_CHECK);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_INIT_VAR(ttl);
		PHALCON_CALL_METHOD(ttl, front_end, "getlifetime", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}
	
	PHALCON_INIT_VAR(flags);
	ZVAL_LONG(flags, 0);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_4(success, memcache, "set", last_key, prepared_content, flags, ttl, PH_NO_CHECK);
	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Failed storing data in memcached");
		return;
	}
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(keys);
		array_init(keys);
	}
	
	eval_int = phalcon_array_isset(keys, last_key);
	if (!eval_int) {
		phalcon_array_update_zval(&keys, last_key, &ttl, PH_COPY | PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(memcache, "set", special_key, keys, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(is_buffering);
	PHALCON_CALL_METHOD(is_buffering, front_end, "isbuffering", PH_NO_CHECK);
	if (PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD_NORETURN(front_end, "stop", PH_NO_CHECK);
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 1);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, delete){

	zval *key_name, *memcache = NULL, *prefix, *prefixed_key;
	zval *backend_options, *special_key, *keys, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(memcache);
		phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(prefix);
	phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		PHALCON_SEPARATE(keys);
		phalcon_array_unset(keys, prefixed_key);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(memcache, "set", special_key, keys, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, memcache, "delete", prefixed_key, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, queryKeys){

	zval *prefix = NULL, *memcache = NULL, *backend_options, *special_key;
	zval *keys, *prefixed_keys, *ttl = NULL, *key = NULL, *empty_arr;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &prefix) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prefix) {
		PHALCON_INIT_NVAR(prefix);
	}
	
	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(memcache);
		phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(backend_options);
	phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_key);
	phalcon_array_fetch_string(&special_key, backend_options, SL("statsKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(keys);
	PHALCON_CALL_METHOD_PARAMS_1(keys, memcache, "get", special_key, PH_NO_CHECK);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		PHALCON_INIT_VAR(prefixed_keys);
		array_init(prefixed_keys);
	
		if (!phalcon_valid_foreach(keys TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(keys);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(ttl);
	
			if (zend_is_true(prefix)) {
				if (!phalcon_start_with(key, prefix)) {
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
				}
			}
			phalcon_array_append(&prefixed_keys, key, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
	
		RETURN_CTOR(prefixed_keys);
	}
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	
	RETURN_CTOR(empty_arr);
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, exists){

	zval *key_name = NULL, *last_key = NULL, *prefix, *memcache = NULL, *cache_exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &key_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!key_name) {
		PHALCON_INIT_NVAR(key_name);
	}
	
	if (Z_TYPE_P(key_name) == IS_NULL) {
		PHALCON_INIT_VAR(last_key);
		phalcon_read_property(&last_key, this_ptr, SL("_lastKey"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(prefix);
		phalcon_read_property(&prefix, this_ptr, SL("_prefix"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}
	if (zend_is_true(last_key)) {
		PHALCON_INIT_VAR(memcache);
		phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
		if (Z_TYPE_P(memcache) != IS_OBJECT) {
			PHALCON_CALL_METHOD_NORETURN(this_ptr, "_connect", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(memcache);
			phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
		}
	
		PHALCON_INIT_VAR(cache_exists);
		PHALCON_CALL_METHOD_PARAMS_1(cache_exists, memcache, "get", last_key, PH_NO_CHECK);
		if (PHALCON_IS_NOT_FALSE(cache_exists)) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Cache_Backend_Memcache, __destruct){

	zval *memcache, *backend_options, *persistent;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(memcache);
	phalcon_read_property(&memcache, this_ptr, SL("_memcache"), PH_NOISY_CC);
	if (Z_TYPE_P(memcache) == IS_OBJECT) {
		PHALCON_INIT_VAR(backend_options);
		phalcon_read_property(&backend_options, this_ptr, SL("_backendOptions"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(persistent);
		phalcon_array_fetch_string(&persistent, backend_options, SL("persistent"), PH_NOISY_CC);
		if (!zend_is_true(persistent)) {
			PHALCON_CALL_METHOD_NORETURN(memcache, "close", PH_NO_CHECK);
		}
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Output){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Output, cache_frontend_output, phalcon_cache_frontend_output_method_entry, 0);

	zend_declare_property_bool(phalcon_cache_frontend_output_ce, SL("_buffering"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_frontend_output_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_frontend_output_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, __construct){

	zval *frontend_options = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!frontend_options) {
		PHALCON_INIT_NVAR(frontend_options);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_frontendOptions"), frontend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, getLifetime){

	zval *options, *lifetime;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_frontendOptions"), PH_NOISY_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("lifetime"));
		if (eval_int) {
			PHALCON_INIT_VAR(lifetime);
			phalcon_array_fetch_string(&lifetime, options, SL("lifetime"), PH_NOISY_CC);
	
			RETURN_CCTOR(lifetime);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_LONG(1);
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, isBuffering){

	zval *buffering;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(buffering);
	phalcon_read_property(&buffering, this_ptr, SL("_buffering"), PH_NOISY_CC);
	
	RETURN_CCTOR(buffering);
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, start){


	PHALCON_MM_GROW();

	phalcon_update_property_bool(this_ptr, SL("_buffering"), 1 TSRMLS_CC);
	PHALCON_CALL_FUNC_NORETURN("ob_start");
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, getContent){

	zval *buffering, *contents;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(buffering);
	phalcon_read_property(&buffering, this_ptr, SL("_buffering"), PH_NOISY_CC);
	if (zend_is_true(buffering)) {
		PHALCON_INIT_VAR(contents);
		PHALCON_CALL_FUNC(contents, "ob_get_contents");
	
		RETURN_CCTOR(contents);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, stop){

	zval *buffering;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(buffering);
	phalcon_read_property(&buffering, this_ptr, SL("_buffering"), PH_NOISY_CC);
	if (zend_is_true(buffering)) {
		PHALCON_CALL_FUNC_NORETURN("ob_end_clean");
	}
	
	phalcon_update_property_bool(this_ptr, SL("_buffering"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, beforeStore){

	zval *data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		RETURN_NULL();
	}

	
	RETURN_CCTORW(data);
}

PHP_METHOD(Phalcon_Cache_Frontend_Output, afterRetrieve){

	zval *data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		RETURN_NULL();
	}

	
	RETURN_CCTORW(data);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Base64){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Base64, cache_frontend_base64, phalcon_cache_frontend_base64_method_entry, 0);

	zend_declare_property_null(phalcon_cache_frontend_base64_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_frontend_base64_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, __construct){

	zval *frontend_options = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!frontend_options) {
		PHALCON_INIT_NVAR(frontend_options);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_frontendOptions"), frontend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, getLifetime){

	zval *options, *lifetime;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_frontendOptions"), PH_NOISY_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("lifetime"));
		if (eval_int) {
			PHALCON_INIT_VAR(lifetime);
			phalcon_array_fetch_string(&lifetime, options, SL("lifetime"), PH_NOISY_CC);
	
			RETURN_CCTOR(lifetime);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_LONG(1);
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, isBuffering){


	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, start){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, getContent){


	RETURN_NULL();
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, stop){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, beforeStore){

	zval *data, *serialized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(serialized);
	PHALCON_CALL_FUNC_PARAMS_1(serialized, "base64_encode", data);
	
	RETURN_CCTOR(serialized);
}

PHP_METHOD(Phalcon_Cache_Frontend_Base64, afterRetrieve){

	zval *data, *unserialized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unserialized);
	PHALCON_CALL_FUNC_PARAMS_1(unserialized, "base64_decode", data);
	
	RETURN_CCTOR(unserialized);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Data){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Data, cache_frontend_data, phalcon_cache_frontend_data_method_entry, 0);

	zend_declare_property_null(phalcon_cache_frontend_data_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_frontend_data_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, __construct){

	zval *frontend_options = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!frontend_options) {
		PHALCON_INIT_NVAR(frontend_options);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_frontendOptions"), frontend_options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, getLifetime){

	zval *options, *lifetime;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_frontendOptions"), PH_NOISY_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("lifetime"));
		if (eval_int) {
			PHALCON_INIT_VAR(lifetime);
			phalcon_array_fetch_string(&lifetime, options, SL("lifetime"), PH_NOISY_CC);
	
			RETURN_CCTOR(lifetime);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_LONG(1);
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, isBuffering){


	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, start){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, getContent){


	RETURN_NULL();
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, stop){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, beforeStore){

	zval *data, *serialized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(serialized);
	PHALCON_CALL_FUNC_PARAMS_1(serialized, "serialize", data);
	
	RETURN_CCTOR(serialized);
}

PHP_METHOD(Phalcon_Cache_Frontend_Data, afterRetrieve){

	zval *data, *unserialized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unserialized);
	PHALCON_CALL_FUNC_PARAMS_1(unserialized, "unserialize", data);
	
	RETURN_CCTOR(unserialized);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_None){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, None, cache_frontend_none, phalcon_cache_frontend_none_method_entry, 0);

	zend_class_implements(phalcon_cache_frontend_none_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Cache_Frontend_None, __construct){

	zval *frontend_options = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &frontend_options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!frontend_options) {
		PHALCON_INIT_NVAR(frontend_options);
	}
	
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Cache_Frontend_None, getLifetime){


	RETURN_LONG(1);
}

PHP_METHOD(Phalcon_Cache_Frontend_None, isBuffering){


	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Cache_Frontend_None, start){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_None, getContent){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_None, stop){


	
}

PHP_METHOD(Phalcon_Cache_Frontend_None, beforeStore){

	zval *data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		RETURN_NULL();
	}

	
	RETURN_CCTORW(data);
}

PHP_METHOD(Phalcon_Cache_Frontend_None, afterRetrieve){

	zval *data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		RETURN_NULL();
	}

	
	RETURN_CCTORW(data);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Cache_BackendInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Cache, BackendInterface, cache_backendinterface, phalcon_cache_backendinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, start);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, stop);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, getFrontend);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, isFresh);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, isStarted);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, getLastKey);

PHALCON_DOC_METHOD(Phalcon_Cache_BackendInterface, get);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Cache_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache, Exception, cache_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_FlashInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, FlashInterface, flashinterface, phalcon_flashinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_FlashInterface, error);

PHALCON_DOC_METHOD(Phalcon_FlashInterface, notice);

PHALCON_DOC_METHOD(Phalcon_FlashInterface, success);

PHALCON_DOC_METHOD(Phalcon_FlashInterface, warning);

PHALCON_DOC_METHOD(Phalcon_FlashInterface, message);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Logger){

	PHALCON_REGISTER_CLASS(Phalcon, Logger, logger, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_logger_ce, SL("SPECIAL"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CUSTOM"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("DEBUG"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("INFO"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("NOTICE"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("WARNING"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ERROR"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ALERT"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CRITICAL"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("EMERGENCE"), 0 TSRMLS_CC);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Reference){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Reference, db_reference, phalcon_db_reference_method_entry, 0);

	zend_declare_property_null(phalcon_db_reference_ce, SL("_schemaName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedSchema"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referenceName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedTable"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedColumns"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_reference_ce TSRMLS_CC, 1, phalcon_db_referenceinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Reference, __construct){

	zval *reference_name, *definition, *referenced_table;
	zval *columns, *referenced_columns, *schema;
	zval *referenced_schema, *number_columns;
	zval *number_referenced_columns;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &reference_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_referenceName"), reference_name TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SS("referencedTable"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_table);
		phalcon_array_fetch_string(&referenced_table, definition, SL("referencedTable"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedTable"), referenced_table TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Referenced table is required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("columns"));
	if (eval_int) {
		PHALCON_INIT_VAR(columns);
		phalcon_array_fetch_string(&columns, definition, SL("columns"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_columns"), columns TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Foreign key columns are required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("referencedColumns"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_columns);
		phalcon_array_fetch_string(&referenced_columns, definition, SL("referencedColumns"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedColumns"), referenced_columns TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Referenced columns of the foreign key are required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("schema"));
	if (eval_int) {
		PHALCON_INIT_VAR(schema);
		phalcon_array_fetch_string(&schema, definition, SL("schema"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_schemaName"), schema TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("referencedSchema"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_schema);
		phalcon_array_fetch_string(&referenced_schema, definition, SL("referencedSchema"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_referencedSchema"), referenced_schema TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(number_columns);
	phalcon_fast_count(number_columns, columns TSRMLS_CC);
	
	PHALCON_INIT_VAR(number_referenced_columns);
	phalcon_fast_count(number_referenced_columns, referenced_columns TSRMLS_CC);
	
	PHALCON_INIT_VAR(r0);
	is_not_equal_function(r0, number_columns, number_referenced_columns TSRMLS_CC);
	if (zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Number of columns is not equals than the number of columns referenced");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Reference, getName){


	RETURN_MEMBER(this_ptr, "_referenceName");
}

PHP_METHOD(Phalcon_Db_Reference, getSchemaName){


	RETURN_MEMBER(this_ptr, "_schemaName");
}

PHP_METHOD(Phalcon_Db_Reference, getReferencedSchema){


	RETURN_MEMBER(this_ptr, "_referencedSchema");
}

PHP_METHOD(Phalcon_Db_Reference, getColumns){


	RETURN_MEMBER(this_ptr, "_columns");
}

PHP_METHOD(Phalcon_Db_Reference, getReferencedTable){


	RETURN_MEMBER(this_ptr, "_referencedTable");
}

PHP_METHOD(Phalcon_Db_Reference, getReferencedColumns){


	RETURN_MEMBER(this_ptr, "_referencedColumns");
}

PHP_METHOD(Phalcon_Db_Reference, __set_state){

	zval *data, *constraint_name, *referenced_schema = NULL;
	zval *referenced_table = NULL, *columns = NULL, *referenced_columns = NULL;
	zval *definition, *reference;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(data, SS("_referenceName"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_referenceName parameter is required");
		return;
	} else {
		PHALCON_INIT_VAR(constraint_name);
		phalcon_array_fetch_string(&constraint_name, data, SL("_referenceName"), PH_NOISY_CC);
	}
	eval_int = phalcon_array_isset_string(data, SS("_referencedSchema"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_schema);
		phalcon_array_fetch_string(&referenced_schema, data, SL("_referencedSchema"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(referenced_schema);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_referencedTable"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_table);
		phalcon_array_fetch_string(&referenced_table, data, SL("_referencedTable"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(referenced_table);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_columns"));
	if (eval_int) {
		PHALCON_INIT_VAR(columns);
		phalcon_array_fetch_string(&columns, data, SL("_columns"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(columns);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_referencedColumns"));
	if (eval_int) {
		PHALCON_INIT_VAR(referenced_columns);
		phalcon_array_fetch_string(&referenced_columns, data, SL("_referencedColumns"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(referenced_columns);
	}
	
	PHALCON_INIT_VAR(definition);
	array_init(definition);
	phalcon_array_update_string(&definition, SL("referencedSchema"), &referenced_schema, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&definition, SL("referencedTable"), &referenced_table, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&definition, SL("columns"), &columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&definition, SL("referencedColumns"), &referenced_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(reference);
	object_init_ex(reference, phalcon_db_reference_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(reference, "__construct", constraint_name, definition, PH_CHECK);
	
	RETURN_CTOR(reference);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_ResultInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ResultInterface, db_resultinterface, phalcon_db_resultinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, execute);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, fetch);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, fetchArray);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, fetchAll);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, numRows);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, dataSeek);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, setFetchMode);

PHALCON_DOC_METHOD(Phalcon_Db_ResultInterface, getInternalResult);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_ColumnInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ColumnInterface, db_columninterface, phalcon_db_columninterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getSchemaName);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getType);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getSize);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getScale);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isUnsigned);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isNotNull);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isPrimary);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isAutoIncrement);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isNumeric);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, isFirst);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getAfterPosition);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, getBindType);

PHALCON_DOC_METHOD(Phalcon_Db_ColumnInterface, __set_state);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_ReferenceInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ReferenceInterface, db_referenceinterface, phalcon_db_referenceinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getSchemaName);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getReferencedSchema);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getColumns);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getReferencedTable);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, getReferencedColumns);

PHALCON_DOC_METHOD(Phalcon_Db_ReferenceInterface, __set_state);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Column){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Column, db_column, phalcon_db_column_method_entry, 0);

	zend_declare_property_null(phalcon_db_column_ce, SL("_columnName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_schemaName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_isNumeric"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_size"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_scale"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_unsigned"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_notNull"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_primary"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_autoIncrement"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_first"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_after"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_bindType"), 2, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_INTEGER"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_VARCHAR"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DECIMAL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATETIME"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_CHAR"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_TEXT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_FLOAT"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_NULL"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_INT"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_STR"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_DECIMAL"), 32 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_SKIP"), 1024 TSRMLS_CC);

	zend_class_implements(phalcon_db_column_ce TSRMLS_CC, 1, phalcon_db_columninterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Column, __construct){

	zval *column_name, *definition, *type, *not_null;
	zval *primary, *size, *is_numeric = NULL, *scale, *dunsigned;
	zval *auto_increment, *first, *after, *bind_type;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &column_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_columnName"), column_name TSRMLS_CC);
	eval_int = phalcon_array_isset_string(definition, SS("type"));
	if (eval_int) {
		PHALCON_INIT_VAR(type);
		phalcon_array_fetch_string(&type, definition, SL("type"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type is required");
		return;
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("notNull"));
	if (eval_int) {
		PHALCON_INIT_VAR(not_null);
		phalcon_array_fetch_string(&not_null, definition, SL("notNull"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_notNull"), not_null TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("primary"));
	if (eval_int) {
		PHALCON_INIT_VAR(primary);
		phalcon_array_fetch_string(&primary, definition, SL("primary"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_primary"), primary TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("size"));
	if (eval_int) {
		PHALCON_INIT_VAR(size);
		phalcon_array_fetch_string(&size, definition, SL("size"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_size"), size TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("scale"));
	if (eval_int) {
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 3);
		PHALCON_INIT_VAR(r0);
		is_equal_function(r0, type, t0 TSRMLS_CC);
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 7);
		PHALCON_INIT_VAR(r1);
		is_equal_function(r1, type, t1 TSRMLS_CC);
		PHALCON_INIT_VAR(is_numeric);
		ZVAL_BOOL(is_numeric, zend_is_true(r0) || zend_is_true(r1));
		if (PHALCON_IS_TRUE(is_numeric)) {
			PHALCON_INIT_VAR(scale);
			phalcon_array_fetch_string(&scale, definition, SL("scale"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_scale"), scale TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type does not support scale parameter");
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("unsigned"));
	if (eval_int) {
		PHALCON_INIT_VAR(dunsigned);
		phalcon_array_fetch_string(&dunsigned, definition, SL("unsigned"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_unsigned"), dunsigned TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("isNumeric"));
	if (eval_int) {
		PHALCON_INIT_NVAR(is_numeric);
		phalcon_array_fetch_string(&is_numeric, definition, SL("isNumeric"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_isNumeric"), is_numeric TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("autoIncrement"));
	if (eval_int) {
		if (phalcon_compare_strict_long(type, 0 TSRMLS_CC)) {
			PHALCON_INIT_VAR(auto_increment);
			phalcon_array_fetch_string(&auto_increment, definition, SL("autoIncrement"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_autoIncrement"), auto_increment TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column type cannot be auto-increment");
			return;
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("first"));
	if (eval_int) {
		PHALCON_INIT_VAR(first);
		phalcon_array_fetch_string(&first, definition, SL("first"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_first"), first TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("after"));
	if (eval_int) {
		PHALCON_INIT_VAR(after);
		phalcon_array_fetch_string(&after, definition, SL("after"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_after"), after TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("bindType"));
	if (eval_int) {
		PHALCON_INIT_VAR(bind_type);
		phalcon_array_fetch_string(&bind_type, definition, SL("bindType"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_bindType"), bind_type TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Column, getSchemaName){


	RETURN_MEMBER(this_ptr, "_schemaName");
}

PHP_METHOD(Phalcon_Db_Column, getName){


	RETURN_MEMBER(this_ptr, "_columnName");
}

PHP_METHOD(Phalcon_Db_Column, getType){


	RETURN_MEMBER(this_ptr, "_type");
}

PHP_METHOD(Phalcon_Db_Column, getSize){


	RETURN_MEMBER(this_ptr, "_size");
}

PHP_METHOD(Phalcon_Db_Column, getScale){


	RETURN_MEMBER(this_ptr, "_scale");
}

PHP_METHOD(Phalcon_Db_Column, isUnsigned){


	RETURN_MEMBER(this_ptr, "_unsigned");
}

PHP_METHOD(Phalcon_Db_Column, isNotNull){


	RETURN_MEMBER(this_ptr, "_notNull");
}

PHP_METHOD(Phalcon_Db_Column, isPrimary){


	RETURN_MEMBER(this_ptr, "_primary");
}

PHP_METHOD(Phalcon_Db_Column, isAutoIncrement){


	RETURN_MEMBER(this_ptr, "_autoIncrement");
}

PHP_METHOD(Phalcon_Db_Column, isNumeric){


	RETURN_MEMBER(this_ptr, "_isNumeric");
}

PHP_METHOD(Phalcon_Db_Column, isFirst){


	RETURN_MEMBER(this_ptr, "_first");
}

PHP_METHOD(Phalcon_Db_Column, getAfterPosition){


	RETURN_MEMBER(this_ptr, "_after");
}

PHP_METHOD(Phalcon_Db_Column, getBindType){


	RETURN_MEMBER(this_ptr, "_bindType");
}

PHP_METHOD(Phalcon_Db_Column, __set_state){

	zval *data, *definition, *column_name, *column_type;
	zval *not_null, *primary, *size, *dunsigned, *after;
	zval *is_numeric, *first, *bind_type, *column;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(definition);
	array_init(definition);
	eval_int = phalcon_array_isset_string(data, SS("_columnName"));
	if (eval_int) {
		PHALCON_INIT_VAR(column_name);
		phalcon_array_fetch_string(&column_name, data, SL("_columnName"), PH_NOISY_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_type"));
	if (eval_int) {
		PHALCON_INIT_VAR(column_type);
		phalcon_array_fetch_string(&column_type, data, SL("_type"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("type"), &column_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_notNull"));
	if (eval_int) {
		PHALCON_INIT_VAR(not_null);
		phalcon_array_fetch_string(&not_null, data, SL("_notNull"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("notNull"), &not_null, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_primary"));
	if (eval_int) {
		PHALCON_INIT_VAR(primary);
		phalcon_array_fetch_string(&primary, data, SL("_primary"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("primary"), &primary, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_size"));
	if (eval_int) {
		PHALCON_INIT_VAR(size);
		phalcon_array_fetch_string(&size, data, SL("_size"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("size"), &size, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_unsigned"));
	if (eval_int) {
		PHALCON_INIT_VAR(dunsigned);
		phalcon_array_fetch_string(&dunsigned, data, SL("_unsigned"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("unsigned"), &dunsigned, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_after"));
	if (eval_int) {
		PHALCON_INIT_VAR(after);
		phalcon_array_fetch_string(&after, data, SL("_after"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("after"), &after, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_isNumeric"));
	if (eval_int) {
		PHALCON_INIT_VAR(is_numeric);
		phalcon_array_fetch_string(&is_numeric, data, SL("_isNumeric"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("isNumeric"), &is_numeric, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_first"));
	if (eval_int) {
		PHALCON_INIT_VAR(first);
		phalcon_array_fetch_string(&first, data, SL("_first"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("first"), &first, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(data, SS("_bindType"));
	if (eval_int) {
		PHALCON_INIT_VAR(bind_type);
		phalcon_array_fetch_string(&bind_type, data, SL("_bindType"), PH_NOISY_CC);
		phalcon_array_update_string(&definition, SL("bindType"), &bind_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(column);
	object_init_ex(column, phalcon_db_column_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(column, "__construct", column_name, definition, PH_CHECK);
	
	RETURN_CTOR(column);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Postgresql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Postgresql, db_adapter_pdo_postgresql, "phalcon\\db\\adapter\\pdo", phalcon_db_adapter_pdo_postgresql_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_postgresql_ce, SL("_type"), "pgsql", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_postgresql_ce, SL("_dialectType"), "postgresql", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_postgresql_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, connect){

	zval *descriptor = NULL, *schema = NULL, *sql;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_INIT_NVAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_NVAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(schema);
	eval_int = phalcon_array_isset_string(descriptor, SS("schema"));
	if (eval_int) {
		phalcon_array_fetch_string(&schema, descriptor, SL("schema"), PH_NOISY_CC);
		PHALCON_SEPARATE_PARAM(descriptor);
		phalcon_array_unset_string(descriptor, SS("schema"));
	}
	
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Db\\Adapter\\Pdo\\Postgresql", "connect", descriptor);
	if (Z_TYPE_P(schema) == IS_STRING) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SET search_path TO '", schema, "'");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "execute", sql, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, describeColumns){

	zval *table, *schema = NULL, *columns, *sql, *fetch_assoc;
	zval *describe, *old_column = NULL, *field = NULL, *definition = NULL;
	zval *char_size = NULL, *numeric_size = NULL, *column_type = NULL;
	zval *attribute = NULL, *column_name = NULL, *column = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, t0, "describecolumns", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(old_column);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init(definition);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_INIT_NVAR(char_size);
		phalcon_array_fetch_string(&char_size, field, SL("size"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(numeric_size);
		phalcon_array_fetch_string(&numeric_size, field, SL("numericsize"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(column_type);
		phalcon_array_fetch_string(&column_type, field, SL("type"), PH_NOISY_CC);
		if (phalcon_memnstr_str(column_type, SL("int") TSRMLS_CC)) {
			phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&definition, SL("size"), &numeric_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE TSRMLS_CC);
		} else {
			if (phalcon_memnstr_str(column_type, SL("varying") TSRMLS_CC)) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE TSRMLS_CC);
				phalcon_array_update_string(&definition, SL("size"), &char_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
			} else {
				if (phalcon_memnstr_str(column_type, SL("date") TSRMLS_CC)) {
					phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE TSRMLS_CC);
					phalcon_array_update_string_long(&definition, SL("size"), 0, PH_SEPARATE TSRMLS_CC);
				} else {
					if (phalcon_memnstr_str(column_type, SL("numeric") TSRMLS_CC)) {
						phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string(&definition, SL("size"), &numeric_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
					} else {
						if (phalcon_memnstr_str(column_type, SL("char") TSRMLS_CC)) {
							phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
							phalcon_array_update_string(&definition, SL("size"), &char_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
						} else {
							if (phalcon_memnstr_str(column_type, SL("timestamp") TSRMLS_CC)) {
								phalcon_array_update_string_long(&definition, SL("type"), 4, PH_SEPARATE TSRMLS_CC);
								phalcon_array_update_string_long(&definition, SL("size"), 0, PH_SEPARATE TSRMLS_CC);
							} else {
								if (phalcon_memnstr_str(column_type, SL("text") TSRMLS_CC)) {
									phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE TSRMLS_CC);
									phalcon_array_update_string(&definition, SL("size"), &char_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
								} else {
									if (phalcon_memnstr_str(column_type, SL("float") TSRMLS_CC)) {
										phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string(&definition, SL("size"), &numeric_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
									} else {
										if (phalcon_memnstr_str(column_type, SL("uuid") TSRMLS_CC)) {
											phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
											phalcon_array_update_string_long(&definition, SL("size"), 36, PH_SEPARATE TSRMLS_CC);
										} else {
											phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
											phalcon_array_update_string(&definition, SL("size"), &char_size, PH_COPY | PH_SEPARATE TSRMLS_CC);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned") TSRMLS_CC)) {
			phalcon_array_update_string_bool(&definition, SL("unsigned"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		if (Z_TYPE_P(old_column) == IS_NULL) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string(&definition, SL("after"), &old_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("key"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "PRI")) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("null"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "NO")) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("extra"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "auto_increment")) {
			phalcon_array_update_string_bool(&definition, SL("autoIncrement"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(column_name);
		phalcon_array_fetch_string(&column_name, field, SL("field"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(column, "__construct", column_name, definition, PH_CHECK);
		phalcon_array_append(&columns, column, PH_SEPARATE TSRMLS_CC);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(columns);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, getDefaultIdValue){

	zval *null_value, *default_value;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(null_value);
	ZVAL_STRING(null_value, "default", 1);
	
	PHALCON_INIT_VAR(default_value);
	object_init_ex(default_value, phalcon_db_rawvalue_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(default_value, "__construct", null_value, PH_CHECK);
	
	RETURN_CTOR(default_value);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, supportSequences){


	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Sqlite, db_adapter_pdo_sqlite, "phalcon\\db\\adapter\\pdo", phalcon_db_adapter_pdo_sqlite_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("_type"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("_dialectType"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_sqlite_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, connect){

	zval *descriptor = NULL, *dbname;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_INIT_NVAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_INIT_NVAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}
	eval_int = phalcon_array_isset_string(descriptor, SS("dbname"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "dbname must be specified");
		return;
	} else {
		PHALCON_INIT_VAR(dbname);
		phalcon_array_fetch_string(&dbname, descriptor, SL("dbname"), PH_NOISY_CC);
		phalcon_array_update_string(&descriptor, SL("dsn"), &dbname, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Db\\Adapter\\Pdo\\Sqlite", "connect", descriptor);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeColumns){

	zval *table, *schema = NULL, *columns, *dialect, *size_pattern;
	zval *sql, *fetch_assoc, *describe, *old_column = NULL;
	zval *field = NULL, *definition = NULL, *column_type = NULL, *pos = NULL, *attribute = NULL;
	zval *matches = NULL, *match_one = NULL, *column_name = NULL, *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(size_pattern);
	ZVAL_STRING(size_pattern, "#\\(([0-9]+)(,[0-9]+)*\\)#", 1);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describecolumns", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(old_column);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init(definition);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_INIT_NVAR(column_type);
		phalcon_array_fetch_string(&column_type, field, SL("type"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(pos);
		phalcon_fast_stripos_str(pos, column_type, SL("int") TSRMLS_CC);
		if (PHALCON_IS_NOT_FALSE(pos)) {
			phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(attribute);
			phalcon_array_fetch_string(&attribute, field, SL("pk"), PH_NOISY_CC);
			if (zend_is_true(attribute)) {
				phalcon_array_update_string_bool(&definition, SL("autoIncrement"), 1, PH_SEPARATE TSRMLS_CC);
			}
		} else {
			if (phalcon_memnstr_str(column_type, SL("varchar") TSRMLS_CC)) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE TSRMLS_CC);
			} else {
				if (phalcon_memnstr_str(column_type, SL("date") TSRMLS_CC)) {
					phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE TSRMLS_CC);
				} else {
					if (phalcon_memnstr_str(column_type, SL("decimal") TSRMLS_CC)) {
						phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
					} else {
						if (phalcon_memnstr_str(column_type, SL("char") TSRMLS_CC)) {
							phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
						} else {
							if (phalcon_memnstr_str(column_type, SL("datetime") TSRMLS_CC)) {
								phalcon_array_update_string_long(&definition, SL("type"), 4, PH_SEPARATE TSRMLS_CC);
							} else {
								if (phalcon_memnstr_str(column_type, SL("text") TSRMLS_CC)) {
									phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE TSRMLS_CC);
								} else {
									if (phalcon_memnstr_str(column_type, SL("float") TSRMLS_CC)) {
										phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
									} else {
										if (phalcon_memnstr_str(column_type, SL("enum") TSRMLS_CC)) {
											phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
										} else {
											phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE TSRMLS_CC);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("(") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(matches);
			array_init(matches);
			Z_SET_ISREF_P(matches);
	
			PHALCON_INIT_NVAR(pos);
			PHALCON_CALL_FUNC_PARAMS_3(pos, "preg_match", size_pattern, column_type, matches);
			Z_UNSET_ISREF_P(matches);
			if (zend_is_true(pos)) {
				eval_int = phalcon_array_isset_long(matches, 1);
				if (eval_int) {
					PHALCON_INIT_NVAR(match_one);
					phalcon_array_fetch_long(&match_one, matches, 1, PH_NOISY_CC);
					phalcon_array_update_string(&definition, SL("size"), &match_one, PH_COPY | PH_SEPARATE TSRMLS_CC);
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned") TSRMLS_CC)) {
			phalcon_array_update_string_bool(&definition, SL("unsigned"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		if (!zend_is_true(old_column)) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string(&definition, SL("after"), &old_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("pk"), PH_NOISY_CC);
		if (zend_is_true(attribute)) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("notnull"), PH_NOISY_CC);
		if (zend_is_true(attribute)) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(column_name);
		phalcon_array_fetch_string(&column_name, field, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(column, "__construct", column_name, definition, PH_CHECK);
		phalcon_array_append(&columns, column, PH_SEPARATE TSRMLS_CC);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(columns);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeIndexes){

	zval *table, *schema = NULL, *dialect, *fetch_assoc, *sql;
	zval *describe, *indexes, *index = NULL, *key_name = NULL, *empty_arr = NULL;
	zval *sql_index_describe = NULL, *describe_index = NULL;
	zval *index_column = NULL, *column_name = NULL, *index_objects;
	zval *index_columns = NULL, *name = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describeindexes", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(indexes);
	array_init(indexes);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(index);
	
		PHALCON_INIT_NVAR(key_name);
		phalcon_array_fetch_string(&key_name, index, SL("name"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(indexes, key_name);
		if (!eval_int) {
			PHALCON_INIT_NVAR(empty_arr);
			array_init(empty_arr);
			phalcon_array_update_zval(&indexes, key_name, &empty_arr, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(sql_index_describe);
		PHALCON_CALL_METHOD_PARAMS_1(sql_index_describe, dialect, "describeindex", key_name, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(describe_index);
		PHALCON_CALL_METHOD_PARAMS_2(describe_index, this_ptr, "fetchall", sql_index_describe, fetch_assoc, PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(describe_index TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(describe_index);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(index_column);
	
			PHALCON_INIT_NVAR(column_name);
			phalcon_array_fetch_string(&column_name, index_column, SL("name"), PH_NOISY_CC);
			phalcon_array_update_append_multi_2(&indexes, key_name, column_name, 0 TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
	
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(index_objects);
	array_init(index_objects);
	
	if (!phalcon_valid_foreach(indexes TSRMLS_CC)) {
		return;
	}
	
	ah2 = Z_ARRVAL_P(indexes);
	zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
	ph_cycle_start_2:
	
		if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
			goto ph_cycle_end_2;
		}
	
		PHALCON_GET_FOREACH_KEY(name, ah2, hp2);
		PHALCON_GET_FOREACH_VALUE(index_columns);
	
		PHALCON_INIT_NVAR(index);
		object_init_ex(index, phalcon_db_index_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(index, "__construct", name, index_columns, PH_CHECK);
		phalcon_array_update_zval(&index_objects, name, &index, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah2, &hp2);
		goto ph_cycle_start_2;
	
	ph_cycle_end_2:
	
	
	RETURN_CTOR(index_objects);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeReferences){

	zval *table, *schema = NULL, *dialect, *sql, *fetch_assoc;
	zval *describe, *reference_objects, *reference_describe = NULL;
	zval *number = NULL, *constraint_name = NULL, *referenced_table = NULL;
	zval *from = NULL, *to = NULL, *columns = NULL, *referenced_columns = NULL;
	zval *reference_array = NULL, *reference = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describereferences", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(reference_objects);
	array_init(reference_objects);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(number, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(reference_describe);
	
		PHALCON_INIT_NVAR(constraint_name);
		PHALCON_CONCAT_SV(constraint_name, "foreign_key_", number);
	
		PHALCON_INIT_NVAR(referenced_table);
		phalcon_array_fetch_string(&referenced_table, reference_describe, SL("table"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(from);
		phalcon_array_fetch_string(&from, reference_describe, SL("from"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(to);
		phalcon_array_fetch_string(&to, reference_describe, SL("to"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(columns);
		array_init(columns);
		phalcon_array_append(&columns, from, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(referenced_columns);
		array_init(referenced_columns);
		phalcon_array_append(&referenced_columns, to, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(reference_array);
		array_init(reference_array);
		add_assoc_null_ex(reference_array, SS("referencedSchema"));
		phalcon_array_update_string(&reference_array, SL("referencedTable"), &referenced_table, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&reference_array, SL("columns"), &columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&reference_array, SL("referencedColumns"), &referenced_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(reference);
		object_init_ex(reference, phalcon_db_reference_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(reference, "__construct", constraint_name, reference_array, PH_CHECK);
		phalcon_array_update_zval(&reference_objects, constraint_name, &reference, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(reference_objects);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Mysql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Mysql, db_adapter_pdo_mysql, "phalcon\\db\\adapter\\pdo", phalcon_db_adapter_pdo_mysql_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_mysql_ce, SL("_type"), "mysql", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_mysql_ce, SL("_dialectType"), "mysql", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_mysql_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo_Mysql, describeColumns){

	zval *table, *schema = NULL, *columns, *dialect, *sql, *fetch_assoc;
	zval *describe, *old_column = NULL, *size_pattern, *field = NULL;
	zval *definition = NULL, *column_type = NULL, *matches = NULL, *pos = NULL;
	zval *match_one = NULL, *attribute = NULL, *column_name = NULL, *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describecolumns", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(old_column);
	
	PHALCON_INIT_VAR(size_pattern);
	ZVAL_STRING(size_pattern, "#\\(([0-9]+)(,[0-9]+)*\\)#", 1);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init(definition);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_INIT_NVAR(column_type);
		phalcon_array_fetch_string(&column_type, field, SL("type"), PH_NOISY_CC);
		if (phalcon_memnstr_str(column_type, SL("int") TSRMLS_CC)) {
			phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE TSRMLS_CC);
		} else {
			if (phalcon_memnstr_str(column_type, SL("varchar") TSRMLS_CC)) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE TSRMLS_CC);
			} else {
				if (phalcon_memnstr_str(column_type, SL("date") TSRMLS_CC)) {
					phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE TSRMLS_CC);
				} else {
					if (phalcon_memnstr_str(column_type, SL("decimal") TSRMLS_CC)) {
						phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
						phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
					} else {
						if (phalcon_memnstr_str(column_type, SL("char") TSRMLS_CC)) {
							phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
						} else {
							if (phalcon_memnstr_str(column_type, SL("datetime") TSRMLS_CC)) {
								phalcon_array_update_string_long(&definition, SL("type"), 4, PH_SEPARATE TSRMLS_CC);
							} else {
								if (phalcon_memnstr_str(column_type, SL("text") TSRMLS_CC)) {
									phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE TSRMLS_CC);
								} else {
									if (phalcon_memnstr_str(column_type, SL("float") TSRMLS_CC)) {
										phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE TSRMLS_CC);
										phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE TSRMLS_CC);
									} else {
										if (phalcon_memnstr_str(column_type, SL("enum") TSRMLS_CC)) {
											phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE TSRMLS_CC);
										} else {
											phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE TSRMLS_CC);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("(") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(matches);
			array_init(matches);
			Z_SET_ISREF_P(matches);
	
			PHALCON_INIT_NVAR(pos);
			PHALCON_CALL_FUNC_PARAMS_3(pos, "preg_match", size_pattern, column_type, matches);
			Z_UNSET_ISREF_P(matches);
			if (zend_is_true(pos)) {
				eval_int = phalcon_array_isset_long(matches, 1);
				if (eval_int) {
					PHALCON_INIT_NVAR(match_one);
					phalcon_array_fetch_long(&match_one, matches, 1, PH_NOISY_CC);
					phalcon_array_update_string(&definition, SL("size"), &match_one, PH_COPY | PH_SEPARATE TSRMLS_CC);
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned") TSRMLS_CC)) {
			phalcon_array_update_string_bool(&definition, SL("unsigned"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		if (!zend_is_true(old_column)) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string(&definition, SL("after"), &old_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("key"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "PRI")) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("null"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "NO")) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		phalcon_array_fetch_string(&attribute, field, SL("extra"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(attribute, "auto_increment")) {
			phalcon_array_update_string_bool(&definition, SL("autoIncrement"), 1, PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(column_name);
		phalcon_array_fetch_string(&column_name, field, SL("field"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(column, "__construct", column_name, definition, PH_CHECK);
		phalcon_array_append(&columns, column, PH_SEPARATE TSRMLS_CC);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(columns);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter, Pdo, db_adapter_pdo, "phalcon\\db\\adapter", phalcon_db_adapter_pdo_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_db_adapter_pdo_ce, SL("_pdo"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_pdo_ce, SL("_affectedRows"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, __construct){

	zval *descriptor;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(descriptor) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "$descriptor must be an array");
		return;
	}
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "connect", descriptor, PH_NO_CHECK);
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Db\\Adapter\\Pdo", "__construct", descriptor);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, connect){

	zval *descriptor = NULL, *username, *password, *dsn_parts;
	zval *value = NULL, *key = NULL, *dsn_attribute = NULL, *dot_comma, *dsn_attributes;
	zval *pdo_type, *dsn, *options, *persistent, *pdo;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type, eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!descriptor) {
		PHALCON_INIT_VAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}

	if (Z_TYPE_P(descriptor) == IS_NULL) {
		PHALCON_INIT_VAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY_CC);
	}

	eval_int = phalcon_array_isset_string(descriptor, SS("username"));
	if (eval_int) {
		PHALCON_INIT_VAR(username);
		phalcon_array_fetch_string(&username, descriptor, SL("username"), PH_NOISY_CC);
		PHALCON_SEPARATE_PARAM(descriptor);
		phalcon_array_unset_string(descriptor, SS("username"));
	} else {
		PHALCON_INIT_VAR(username);
		ZVAL_NULL(username);
	}

	eval_int = phalcon_array_isset_string(descriptor, SS("password"));
	if (eval_int) {
		PHALCON_INIT_VAR(password);
		phalcon_array_fetch_string(&password, descriptor, SL("password"), PH_NOISY_CC);
		PHALCON_SEPARATE_PARAM(descriptor);
		phalcon_array_unset_string(descriptor, SS("password"));
	} else {
		PHALCON_INIT_VAR(password);
		ZVAL_NULL(password);
	}

	eval_int = phalcon_array_isset_string(descriptor, SS("dsn"));
	if (!eval_int) {
		PHALCON_INIT_VAR(dsn_parts);
		array_init(dsn_parts);

		if (!phalcon_valid_foreach(descriptor TSRMLS_CC)) {
			return;
		}

		ah0 = Z_ARRVAL_P(descriptor);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);

		ph_cycle_start_0:

			if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
				goto ph_cycle_end_0;
			}

			PHALCON_INIT_NVAR(key);
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);

			PHALCON_INIT_NVAR(dsn_attribute);
			PHALCON_CONCAT_VSV(dsn_attribute, key, "=", value);
			phalcon_array_append(&dsn_parts, dsn_attribute, 0 TSRMLS_CC);

			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;

		ph_cycle_end_0:

		PHALCON_INIT_VAR(dot_comma);
		ZVAL_STRING(dot_comma, ";", 1);

		PHALCON_INIT_VAR(dsn_attributes);
		phalcon_fast_join(dsn_attributes, dot_comma, dsn_parts TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(dsn_attributes);
		phalcon_array_fetch_string(&dsn_attributes, descriptor, SL("dsn"), PH_NOISY_CC);
	}

	PHALCON_INIT_VAR(pdo_type);
	phalcon_read_property(&pdo_type, this_ptr, SL("_type"), PH_NOISY_CC);

	PHALCON_INIT_VAR(dsn);
	PHALCON_CONCAT_VSV(dsn, pdo_type, ":", dsn_attributes);

	PHALCON_INIT_VAR(options);
	array_init(options);
	add_index_long(options, PDO_ATTR_ERRMODE, PDO_ERRMODE_EXCEPTION);
	add_index_long(options, PDO_ATTR_CASE, PDO_CASE_LOWER);
	add_index_long(options, PDO_ATTR_CURSOR, PDO_CURSOR_SCROLL);

	eval_int = phalcon_array_isset_string(descriptor, SS("persistent"));
	if (eval_int) {
		PHALCON_INIT_VAR(persistent);
		phalcon_array_fetch_string(&persistent, descriptor, SL("persistent"), PH_NOISY_CC);
		if (zend_is_true(persistent)) {
			phalcon_array_update_long_bool(&options, PDO_ATTR_PERSISTENT, 1, 0 TSRMLS_CC);
		}
	}

	ce0 = zend_fetch_class(SL("PDO"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_INIT_VAR(pdo);
	object_init_ex(pdo, ce0);
	PHALCON_CALL_METHOD_PARAMS_4_NORETURN(pdo, "__construct", dsn, username, password, options, PH_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_pdo"), pdo TSRMLS_CC);

	PHALCON_MM_RESTORE();}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, _executePrepared){

	zval *statement = NULL, *placeholders = NULL, *data_types = NULL;
	zval *one, *value = NULL, *wildcard = NULL, *parameter = NULL, *type = NULL, *cast_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &statement, &placeholders, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(one);
	ZVAL_LONG(one, 1);

	if (!phalcon_valid_foreach(placeholders TSRMLS_CC)) {
		return;
	}

	ah0 = Z_ARRVAL_P(placeholders);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);

	ph_cycle_start_0:

		if(zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS){
			goto ph_cycle_end_0;
		}

		PHALCON_GET_FOREACH_KEY(wildcard, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);

		if (Z_TYPE_P(wildcard) == IS_LONG) {
			PHALCON_INIT_NVAR(parameter);
			phalcon_add_function(parameter, wildcard, one TSRMLS_CC);
		} else {
			if (Z_TYPE_P(wildcard) == IS_STRING) {
				PHALCON_CPY_WRT(parameter, wildcard);
			} else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind parameter");
				return;
			}
		}
		if (Z_TYPE_P(data_types) == IS_ARRAY) {
			eval_int = phalcon_array_isset(data_types, wildcard);
			if (eval_int) {

				PHALCON_INIT_NVAR(type);
				phalcon_array_fetch(&type, data_types, wildcard, PH_NOISY_CC);
				if (phalcon_compare_strict_long(type, 32 TSRMLS_CC)) {

					PHALCON_INIT_NVAR(cast_value);
					PHALCON_CALL_FUNC_PARAMS_1(cast_value, "doubleval", value);

					PHALCON_INIT_NVAR(type);
					ZVAL_LONG(type, 2);
				} else {
					PHALCON_CPY_WRT(cast_value, value);
				}

				Z_SET_ISREF_P(cast_value);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(statement, "bindparam", parameter, cast_value, type, PH_NO_CHECK);
				Z_UNSET_ISREF_P(cast_value);
			} else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind type parameter");
				return;
			}
		} else {
			Z_SET_ISREF_P(value);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(statement, "bindparam", parameter, value, PH_NO_CHECK);
			Z_UNSET_ISREF_P(value);
		}

		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;

	ph_cycle_end_0:

	PHALCON_CALL_METHOD_NORETURN(statement, "execute", PH_NO_CHECK);

	RETURN_CCTOR(statement);}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, query){

	zval *sql_statement, *placeholders = NULL, *data_types = NULL;
	zval *events_manager, *event_name = NULL, *status, *pdo;
	zval *statement = NULL, *pdo_result;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &sql_statement, &placeholders, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	if (!data_types) {
		PHALCON_INIT_NVAR(data_types);
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "db:beforeQuery", 1);
		phalcon_update_property_zval(this_ptr, SL("_sqlStatement"), sql_statement TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_sqlVariables"), placeholders TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_sqlBindTypes"), data_types TSRMLS_CC);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, placeholders, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
		PHALCON_INIT_VAR(statement);
		PHALCON_CALL_METHOD_PARAMS_1(statement, pdo, "prepare", sql_statement, PH_NO_CHECK);
		if (Z_TYPE_P(statement) == IS_OBJECT) {
			PHALCON_INIT_VAR(r0);
			PHALCON_CALL_METHOD_PARAMS_3(r0, this_ptr, "_executeprepared", statement, placeholders, data_types, PH_NO_CHECK);
			PHALCON_CPY_WRT(statement, r0);
		}
	} else {
		PHALCON_INIT_NVAR(statement);
		PHALCON_CALL_METHOD_PARAMS_1(statement, pdo, "query", sql_statement, PH_NO_CHECK);
	}
	
	if (Z_TYPE_P(statement) == IS_OBJECT) {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "db:afterQuery", 1);
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, placeholders, PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(pdo_result);
		object_init_ex(pdo_result, phalcon_db_result_pdo_ce);
		PHALCON_CALL_METHOD_PARAMS_5_NORETURN(pdo_result, "__construct", this_ptr, statement, sql_statement, placeholders, data_types, PH_CHECK);
	
		RETURN_CTOR(pdo_result);
	}
	
	
	RETURN_CCTOR(statement);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, execute){

	zval *sql_statement, *placeholders = NULL, *data_types = NULL;
	zval *events_manager, *event_name = NULL, *status, *pdo;
	zval *statement = NULL, *affected_rows = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &sql_statement, &placeholders, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	if (!data_types) {
		PHALCON_INIT_NVAR(data_types);
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "db:beforeQuery", 1);
		phalcon_update_property_zval(this_ptr, SL("_sqlStatement"), sql_statement TSRMLS_CC);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, placeholders, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
		PHALCON_INIT_VAR(statement);
		PHALCON_CALL_METHOD_PARAMS_1(statement, pdo, "prepare", sql_statement, PH_NO_CHECK);
		if (Z_TYPE_P(statement) == IS_OBJECT) {
			PHALCON_INIT_VAR(r0);
			PHALCON_CALL_METHOD_PARAMS_3(r0, this_ptr, "_executeprepared", statement, placeholders, data_types, PH_NO_CHECK);
			PHALCON_CPY_WRT(statement, r0);
	
			PHALCON_INIT_VAR(affected_rows);
			PHALCON_CALL_METHOD(affected_rows, statement, "rowcount", PH_NO_CHECK);
		}
	} else {
		PHALCON_INIT_NVAR(affected_rows);
		PHALCON_CALL_METHOD_PARAMS_1(affected_rows, pdo, "exec", sql_statement, PH_NO_CHECK);
	}
	
	if (Z_TYPE_P(affected_rows) == IS_LONG) {
		phalcon_update_property_zval(this_ptr, SL("_affectedRows"), affected_rows TSRMLS_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "db:afterQuery", 1);
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, placeholders, PH_NO_CHECK);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, affectedRows){


	RETURN_MEMBER(this_ptr, "_affectedRows");
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, close){

	zval *pdo;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	if (Z_TYPE_P(pdo) == IS_OBJECT) {
		phalcon_update_property_null(this_ptr, SL("_pdo") TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, escapeString){

	zval *str, *pdo, *quoted_str;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(quoted_str);
	PHALCON_CALL_METHOD_PARAMS_1(quoted_str, pdo, "quote", str, PH_NO_CHECK);
	
	RETURN_CCTOR(quoted_str);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, bindParams){

	zval *sql_statement, *params, *sql = NULL, *pdo, *bind_value = NULL;
	zval *index = NULL, *is_numeric = NULL, *value = NULL, *place_key = NULL, *replaced_sql = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_statement, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(params) == IS_ARRAY) { 
		if (phalcon_fast_count_ev(params TSRMLS_CC)) {
			PHALCON_CPY_WRT(sql, sql_statement);
	
			PHALCON_INIT_VAR(pdo);
			phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
			if (!phalcon_valid_foreach(params TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(params);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_KEY(index, ah0, hp0);
				PHALCON_GET_FOREACH_VALUE(bind_value);
	
				PHALCON_INIT_NVAR(is_numeric);
				PHALCON_CALL_FUNC_PARAMS_1(is_numeric, "is_numeric", bind_value);
				if (PHALCON_IS_TRUE(is_numeric)) {
					PHALCON_CPY_WRT(value, bind_value);
				} else {
					PHALCON_INIT_NVAR(value);
					PHALCON_CALL_METHOD_PARAMS_1(value, pdo, "quote", bind_value, PH_NO_CHECK);
				}
	
				if (Z_TYPE_P(index) == IS_LONG) {
					PHALCON_INIT_NVAR(place_key);
					PHALCON_CONCAT_SV(place_key, "?", index);
	
					PHALCON_INIT_NVAR(replaced_sql);
					phalcon_fast_str_replace(replaced_sql, place_key, value, sql TSRMLS_CC);
					PHALCON_CPY_WRT(sql, replaced_sql);
				} else {
					if (Z_TYPE_P(index) == IS_STRING) {
						PHALCON_INIT_NVAR(place_key);
						PHALCON_CONCAT_SVS(place_key, ":", index, ":");
	
						PHALCON_INIT_NVAR(replaced_sql);
						phalcon_fast_str_replace(replaced_sql, place_key, value, sql TSRMLS_CC);
						PHALCON_CPY_WRT(sql, replaced_sql);
					} else {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind parameter");
						return;
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
	
	
			RETURN_CCTOR(sql);
		}
	}
	
	RETURN_CCTOR(sql_statement);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, convertBoundParams){

	zval *sql, *params, *query_params = NULL, *placeholders;
	zval *matches, *set_order, *bind_pattern, *status = NULL;
	zval *place_match = NULL, *numeric_place = NULL, *value = NULL, *str_place = NULL;
	zval *question, *bound_sql = NULL;
	zval *r0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(query_params);
	array_init(query_params);
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(matches);
	
	PHALCON_INIT_VAR(set_order);
	ZVAL_LONG(set_order, 2);
	
	PHALCON_INIT_VAR(bind_pattern);
	ZVAL_STRING(bind_pattern, "/\\?([0-9]+)|:([a-zA-Z0-9_]+):/", 1);
	p0[0] = bind_pattern;
	p0[1] = sql;
	Z_SET_ISREF_P(matches);
	p0[2] = matches;
	p0[3] = set_order;
	
	PHALCON_INIT_VAR(r0);
	PHALCON_CALL_FUNC_PARAMS(r0, "preg_match_all", 4, p0);
	Z_UNSET_ISREF_P(p0[2]);
	PHALCON_CPY_WRT(status, r0);
	if (zend_is_true(status)) {
	
		if (!phalcon_valid_foreach(matches TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(matches);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(place_match);
	
			PHALCON_INIT_NVAR(numeric_place);
			phalcon_array_fetch_long(&numeric_place, place_match, 1, PH_NOISY_CC);
			eval_int = phalcon_array_isset(params, numeric_place);
			if (eval_int) {
				PHALCON_INIT_NVAR(value);
				phalcon_array_fetch(&value, params, numeric_place, PH_NOISY_CC);
			} else {
				eval_int = phalcon_array_isset_long(place_match, 2);
				if (eval_int) {
					PHALCON_INIT_NVAR(str_place);
					phalcon_array_fetch_long(&str_place, place_match, 2, PH_NOISY_CC);
					eval_int = phalcon_array_isset(params, str_place);
					if (eval_int) {
						PHALCON_INIT_NVAR(value);
						phalcon_array_fetch(&value, params, str_place, PH_NOISY_CC);
					} else {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Matched parameter wasn't found in parameters list");
						return;
					}
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Matched parameter wasn't found in parameters list");
					return;
				}
			}
	
			phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		PHALCON_INIT_VAR(question);
		ZVAL_STRING(question, "?", 1);
	
		PHALCON_INIT_VAR(bound_sql);
		PHALCON_CALL_FUNC_PARAMS_3(bound_sql, "preg_replace", bind_pattern, question, sql);
	} else {
		PHALCON_CPY_WRT(bound_sql, sql);
	}
	
	PHALCON_INIT_NVAR(query_params);
	array_init(query_params);
	phalcon_array_update_string(&query_params, SL("sql"), &bound_sql, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&query_params, SL("params"), &placeholders, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	RETURN_CTOR(query_params);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, lastInsertId){

	zval *sequence_name = NULL, *pdo, *insert_id;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &sequence_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!sequence_name) {
		PHALCON_INIT_NVAR(sequence_name);
	}
	
	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	if (Z_TYPE_P(pdo) != IS_OBJECT) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(insert_id);
	PHALCON_CALL_METHOD_PARAMS_1(insert_id, pdo, "lastinsertid", sequence_name, PH_NO_CHECK);
	
	RETURN_CCTOR(insert_id);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, begin){

	zval *pdo, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD(status, pdo, "begintransaction", PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, rollback){

	zval *pdo, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD(status, pdo, "rollback", PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, commit){

	zval *pdo, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD(status, pdo, "commit", PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, isUnderTransaction){

	zval *pdo, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD(status, pdo, "intransaction", PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, getInternalHandler){

	zval *pdo;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo);
	phalcon_read_property(&pdo, this_ptr, SL("_pdo"), PH_NOISY_CC);
	
	RETURN_CCTOR(pdo);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, describeIndexes){

	zval *table, *schema = NULL, *dialect, *fetch_assoc, *sql;
	zval *describe, *indexes, *index = NULL, *key_name = NULL, *empty_arr = NULL;
	zval *column_name = NULL, *index_objects, *index_columns = NULL;
	zval *name = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describeindexes", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(indexes);
	array_init(indexes);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(index);
	
		PHALCON_INIT_NVAR(key_name);
		phalcon_array_fetch_string(&key_name, index, SL("key_name"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(indexes, key_name);
		if (!eval_int) {
			PHALCON_INIT_NVAR(empty_arr);
			array_init(empty_arr);
			phalcon_array_update_zval(&indexes, key_name, &empty_arr, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(column_name);
		phalcon_array_fetch_string(&column_name, index, SL("column_name"), PH_NOISY_CC);
		phalcon_array_update_append_multi_2(&indexes, key_name, column_name, 0 TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(index_objects);
	array_init(index_objects);
	
	if (!phalcon_valid_foreach(indexes TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(indexes);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_KEY(name, ah1, hp1);
		PHALCON_GET_FOREACH_VALUE(index_columns);
	
		PHALCON_INIT_NVAR(index);
		object_init_ex(index, phalcon_db_index_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(index, "__construct", name, index_columns, PH_CHECK);
		phalcon_array_update_zval(&index_objects, name, &index, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	
	RETURN_CTOR(index_objects);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, describeReferences){

	zval *table, *schema = NULL, *dialect, *sql, *empty_arr, *references;
	zval *fetch_assoc, *describe, *reference = NULL, *constraint_name = NULL;
	zval *referenced_schema = NULL, *referenced_table = NULL;
	zval *reference_array = NULL, *column_name = NULL, *referenced_columns = NULL;
	zval *reference_objects, *array_reference = NULL;
	zval *name = NULL, *columns = NULL, *definition = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "describereferences", table, schema, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	
	PHALCON_INIT_VAR(references);
	array_init(references);
	
	PHALCON_INIT_VAR(fetch_assoc);
	phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
	PHALCON_INIT_VAR(describe);
	PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
	if (!phalcon_valid_foreach(describe TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(describe);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(reference);
	
		PHALCON_INIT_NVAR(constraint_name);
		phalcon_array_fetch_string(&constraint_name, reference, SL("constraint_name"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(references, constraint_name);
		if (!eval_int) {
			PHALCON_INIT_NVAR(referenced_schema);
			phalcon_array_fetch_string(&referenced_schema, reference, SL("referenced_table_schema"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(referenced_table);
			phalcon_array_fetch_string(&referenced_table, reference, SL("referenced_table_name"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(reference_array);
			array_init(reference_array);
			phalcon_array_update_string(&reference_array, SL("referencedSchema"), &referenced_schema, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&reference_array, SL("referencedTable"), &referenced_table, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&reference_array, SL("columns"), &empty_arr, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&reference_array, SL("referencedColumns"), &empty_arr, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&references, constraint_name, &reference_array, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(column_name);
		phalcon_array_fetch_string(&column_name, reference, SL("column_name"), PH_NOISY_CC);
		phalcon_array_update_zval_string_append_multi_3(&references, constraint_name, SL("columns"), &column_name, 0 TSRMLS_CC);
	
		PHALCON_INIT_NVAR(referenced_columns);
		phalcon_array_fetch_string(&referenced_columns, reference, SL("referenced_column_name"), PH_NOISY_CC);
		phalcon_array_update_zval_string_append_multi_3(&references, constraint_name, SL("referencedColumns"), &referenced_columns, 0 TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(reference_objects);
	array_init(reference_objects);
	
	if (!phalcon_valid_foreach(references TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(references);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_KEY(name, ah1, hp1);
		PHALCON_GET_FOREACH_VALUE(array_reference);
	
		PHALCON_INIT_NVAR(referenced_schema);
		phalcon_array_fetch_string(&referenced_schema, array_reference, SL("referencedSchema"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(referenced_table);
		phalcon_array_fetch_string(&referenced_table, array_reference, SL("referencedTable"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(columns);
		phalcon_array_fetch_string(&columns, array_reference, SL("columns"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(referenced_columns);
		phalcon_array_fetch_string(&referenced_columns, array_reference, SL("referencedColumns"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(definition);
		array_init(definition);
		phalcon_array_update_string(&definition, SL("referencedSchema"), &referenced_schema, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&definition, SL("referencedTable"), &referenced_table, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&definition, SL("columns"), &columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&definition, SL("referencedColumns"), &referenced_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(reference);
		object_init_ex(reference, phalcon_db_reference_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(reference, "__construct", name, definition, PH_CHECK);
		phalcon_array_update_zval(&reference_objects, name, &reference, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	
	RETURN_CTOR(reference_objects);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, tableOptions){

	zval *table_name, *schema_name = NULL, *dialect, *sql;
	zval *fetch_assoc, *describe, *first, *empty_arr;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "tableoptions", table_name, schema_name, PH_NO_CHECK);
	if (zend_is_true(sql)) {
		PHALCON_INIT_VAR(fetch_assoc);
		phalcon_get_class_constant(fetch_assoc, phalcon_db_ce, SS("FETCH_ASSOC") TSRMLS_CC);
	
		PHALCON_INIT_VAR(describe);
		PHALCON_CALL_METHOD_PARAMS_2(describe, this_ptr, "fetchall", sql, fetch_assoc, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(first);
		phalcon_array_fetch_long(&first, describe, 0, PH_NOISY_CC);
	
		RETURN_CCTOR(first);
	}
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	
	RETURN_CTOR(empty_arr);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, getDefaultIdValue){

	zval *null_value, *default_value;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(null_value);
	ZVAL_STRING(null_value, "null", 1);
	
	PHALCON_INIT_VAR(default_value);
	object_init_ex(default_value, phalcon_db_rawvalue_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(default_value, "__construct", null_value, PH_CHECK);
	
	RETURN_CTOR(default_value);
}

PHP_METHOD(Phalcon_Db_Adapter_Pdo, supportSequences){


	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Adapter, db_adapter, phalcon_db_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_db_adapter_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_descriptor"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_dialectType"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_dialect"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_connectionId"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlVariables"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlBindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_adapter_ce, SL("_connectionConsecutive"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_ce TSRMLS_CC, 1, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Adapter, __construct){

	zval *descriptor, *one, *connection_consecutive = NULL;
	zval *next_consecutive, *dialect_type, *dialect_class = NULL;
	zval *dialect_object;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &descriptor) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(one);
	ZVAL_LONG(one, 1);
	
	PHALCON_OBSERVE_VAR(connection_consecutive);
	phalcon_read_static_property(&connection_consecutive, SL("phalcon\\db\\adapter"), SL("_connectionConsecutive") TSRMLS_CC);
	
	PHALCON_INIT_VAR(next_consecutive);
	phalcon_add_function(next_consecutive, connection_consecutive, one TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\db\\adapter"), SL("_connectionConsecutive"), next_consecutive TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_connectionId"), connection_consecutive TSRMLS_CC);
	eval_int = phalcon_array_isset_string(descriptor, SS("dialectClass"));
	if (!eval_int) {
		PHALCON_INIT_VAR(dialect_type);
		phalcon_read_property(&dialect_type, this_ptr, SL("_dialectType"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(dialect_class);
		PHALCON_CONCAT_SV(dialect_class, "phalcon\\db\\dialect\\", dialect_type);
	} else {
		PHALCON_INIT_NVAR(dialect_class);
		phalcon_array_fetch_string(&dialect_class, descriptor, SL("dialectClass"), PH_NOISY_CC);
	}
	
	ce0 = phalcon_fetch_class(dialect_class TSRMLS_CC);
	
	PHALCON_INIT_VAR(dialect_object);
	object_init_ex(dialect_object, ce0);
	PHALCON_CALL_METHOD_NORETURN(dialect_object, "__construct", PH_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_dialect"), dialect_object TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_descriptor"), descriptor TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Adapter, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Adapter, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Db_Adapter, fetchOne){

	zval *sql_query, *fetch_mode = NULL, *result, *row, *empty_row;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &sql_query, &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!fetch_mode) {
		PHALCON_INIT_NVAR(fetch_mode);
		ZVAL_LONG(fetch_mode, 2);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, this_ptr, "query", sql_query, PH_NO_CHECK);
	if (Z_TYPE_P(result) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_mode, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(row);
		PHALCON_CALL_METHOD(row, result, "fetcharray", PH_NO_CHECK);
	
		RETURN_CCTOR(row);
	}
	
	PHALCON_INIT_VAR(empty_row);
	array_init(empty_row);
	
	RETURN_CTOR(empty_row);
}

PHP_METHOD(Phalcon_Db_Adapter, fetchAll){

	zval *sql_query, *fetch_mode = NULL, *results, *result;
	zval *row = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &sql_query, &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!fetch_mode) {
		PHALCON_INIT_NVAR(fetch_mode);
		ZVAL_LONG(fetch_mode, 2);
	}
	
	PHALCON_INIT_VAR(results);
	array_init(results);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, this_ptr, "query", sql_query, PH_NO_CHECK);
	if (Z_TYPE_P(result) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_mode, PH_NO_CHECK);
		ph_cycle_start_0:
	
			PHALCON_INIT_NVAR(r0);
			PHALCON_CALL_METHOD(r0, result, "fetcharray", PH_NO_CHECK);
			PHALCON_CPY_WRT(row, r0);
			if (!zend_is_true(row)) {
				goto ph_cycle_end_0;
			}
			phalcon_array_append(&results, row, PH_SEPARATE TSRMLS_CC);
			goto ph_cycle_start_0;
		ph_cycle_end_0:
		if(0){}
	}
	
	
	RETURN_CTOR(results);
}

PHP_METHOD(Phalcon_Db_Adapter, insert){

	zval *table, *values, *fields = NULL, *data_types = NULL, *exception_message;
	zval *placeholders, *insert_values, *bind_data_types = NULL;
	zval *value = NULL, *position = NULL, *str_value = NULL, *bind_type = NULL;
	zval *joined_values, *joined_fields, *insert_sql = NULL;
	zval *success;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &table, &values, &fields, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!fields) {
		PHALCON_INIT_NVAR(fields);
	}
	
	if (!data_types) {
		PHALCON_INIT_NVAR(data_types);
	}
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The second parameter for insert isn't an Array");
		return;
	}
	if (!phalcon_fast_count_ev(values TSRMLS_CC)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Unable to insert into ", table, " without data");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(insert_values);
	array_init(insert_values);
	if (Z_TYPE_P(data_types) == IS_ARRAY) { 
		PHALCON_INIT_VAR(bind_data_types);
		array_init(bind_data_types);
	} else {
		PHALCON_CPY_WRT(bind_data_types, data_types);
	}
	
	
	if (!phalcon_valid_foreach(values TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(values);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(position, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(value) == IS_OBJECT) {
			PHALCON_INIT_NVAR(str_value);
			PHALCON_CALL_FUNC_PARAMS_1(str_value, "strval", value);
			phalcon_array_append(&placeholders, str_value, PH_SEPARATE TSRMLS_CC);
		} else {
			if (Z_TYPE_P(value) == IS_NULL) {
				phalcon_array_append_string(&placeholders, SL("null"), PH_SEPARATE TSRMLS_CC);
			} else {
				phalcon_array_append_string(&placeholders, SL("?"), PH_SEPARATE TSRMLS_CC);
				phalcon_array_append(&insert_values, value, PH_SEPARATE TSRMLS_CC);
				if (Z_TYPE_P(data_types) == IS_ARRAY) { 
					eval_int = phalcon_array_isset(data_types, position);
					if (!eval_int) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Incomplete number of bind types");
						return;
					}
	
					PHALCON_INIT_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, data_types, position, PH_NOISY_CC);
					phalcon_array_append(&bind_data_types, bind_type, PH_SEPARATE TSRMLS_CC);
				}
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(joined_values);
	phalcon_fast_join_str(joined_values, SL(", "), placeholders TSRMLS_CC);
	if (Z_TYPE_P(fields) == IS_ARRAY) { 
		PHALCON_INIT_VAR(joined_fields);
		phalcon_fast_join_str(joined_fields, SL(", "), fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(insert_sql);
		PHALCON_CONCAT_SVSVSVS(insert_sql, "INSERT INTO ", table, " (", joined_fields, ") VALUES (", joined_values, ")");
	} else {
		PHALCON_INIT_NVAR(insert_sql);
		PHALCON_CONCAT_SVSVS(insert_sql, "INSERT INTO ", table, " VALUES (", joined_values, ")");
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_3(success, this_ptr, "execute", insert_sql, insert_values, bind_data_types, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, update){

	zval *table, *fields, *values, *where_condition = NULL;
	zval *data_types = NULL, *placeholders, *update_values;
	zval *bind_data_types = NULL, *value = NULL, *position = NULL, *field = NULL;
	zval *set_clause_part = NULL, *bind_type = NULL, *set_clause;
	zval *update_sql = NULL, *success;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|zz", &table, &fields, &values, &where_condition, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!where_condition) {
		PHALCON_INIT_NVAR(where_condition);
	}
	
	if (!data_types) {
		PHALCON_INIT_NVAR(data_types);
	}
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(update_values);
	array_init(update_values);
	if (Z_TYPE_P(data_types) == IS_ARRAY) { 
		PHALCON_INIT_VAR(bind_data_types);
		array_init(bind_data_types);
	} else {
		PHALCON_CPY_WRT(bind_data_types, data_types);
	}
	
	
	if (!phalcon_valid_foreach(values TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(values);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(position, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		eval_int = phalcon_array_isset(fields, position);
		if (eval_int) {
			PHALCON_INIT_NVAR(field);
			phalcon_array_fetch(&field, fields, position, PH_NOISY_CC);
			if (Z_TYPE_P(value) == IS_OBJECT) {
				PHALCON_INIT_NVAR(set_clause_part);
				PHALCON_CONCAT_VSV(set_clause_part, field, " = ", value);
				phalcon_array_append(&placeholders, set_clause_part, PH_SEPARATE TSRMLS_CC);
			} else {
				if (Z_TYPE_P(value) == IS_NULL) {
					PHALCON_INIT_NVAR(set_clause_part);
					PHALCON_CONCAT_VS(set_clause_part, field, " = null");
				} else {
					PHALCON_INIT_NVAR(set_clause_part);
					PHALCON_CONCAT_VS(set_clause_part, field, " = ?");
					phalcon_array_append(&update_values, value, PH_SEPARATE TSRMLS_CC);
					if (Z_TYPE_P(data_types) == IS_ARRAY) { 
						eval_int = phalcon_array_isset(data_types, position);
						if (!eval_int) {
							PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Incomplete number of bind types");
							return;
						}
	
						PHALCON_INIT_NVAR(bind_type);
						phalcon_array_fetch(&bind_type, data_types, position, PH_NOISY_CC);
						phalcon_array_append(&bind_data_types, bind_type, PH_SEPARATE TSRMLS_CC);
					}
				}
				phalcon_array_append(&placeholders, set_clause_part, PH_SEPARATE TSRMLS_CC);
			}
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The number of values in the update is not the same as fields");
			return;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(set_clause);
	phalcon_fast_join_str(set_clause, SL(", "), placeholders TSRMLS_CC);
	if (Z_TYPE_P(where_condition) != IS_NULL) {
		PHALCON_INIT_VAR(update_sql);
		PHALCON_CONCAT_SVSVSV(update_sql, "UPDATE ", table, " SET ", set_clause, " WHERE ", where_condition);
	} else {
		PHALCON_INIT_NVAR(update_sql);
		PHALCON_CONCAT_SVSV(update_sql, "UPDATE ", table, " SET ", set_clause);
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_3(success, this_ptr, "execute", update_sql, update_values, bind_data_types, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, delete){

	zval *table, *where_condition = NULL, *placeholders = NULL;
	zval *data_types = NULL, *sql = NULL, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzz", &table, &where_condition, &placeholders, &data_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!where_condition) {
		PHALCON_INIT_NVAR(where_condition);
	}
	
	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	if (!data_types) {
		PHALCON_INIT_NVAR(data_types);
	}
	
	if (Z_TYPE_P(where_condition) != IS_NULL) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSV(sql, "DELETE FROM ", table, " WHERE ", where_condition);
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SV(sql, "DELETE FROM ", table);
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_3(success, this_ptr, "execute", sql, placeholders, data_types, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, getColumnList){

	zval *column_list, *dialect, *transformed_list;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(transformed_list);
	PHALCON_CALL_METHOD_PARAMS_1(transformed_list, dialect, "getcolumnlist", column_list, PH_NO_CHECK);
	
	RETURN_CCTOR(transformed_list);
}

PHP_METHOD(Phalcon_Db_Adapter, limit){

	zval *sql_query, *number, *dialect, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "limit", sql_query, number, PH_NO_CHECK);
	
	RETURN_CCTOR(sql);
}

PHP_METHOD(Phalcon_Db_Adapter, tableExists){

	zval *table_name, *schema_name = NULL, *dialect, *sql;
	zval *fetch_num, *num, *first;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "tableexists", table_name, schema_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_num);
	phalcon_get_class_constant(fetch_num, phalcon_db_ce, SS("FETCH_NUM") TSRMLS_CC);
	
	PHALCON_INIT_VAR(num);
	PHALCON_CALL_METHOD_PARAMS_2(num, this_ptr, "fetchone", sql, fetch_num, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(first);
	phalcon_array_fetch_long(&first, num, 0, PH_NOISY_CC);
	
	RETURN_CCTOR(first);
}

PHP_METHOD(Phalcon_Db_Adapter, viewExists){

	zval *view_name, *schema_name = NULL, *exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &view_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_2(exists, this_ptr, "tableexists", view_name, schema_name, PH_NO_CHECK);
	
	RETURN_CCTOR(exists);
}

PHP_METHOD(Phalcon_Db_Adapter, forUpdate){

	zval *sql_query, *dialect, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_1(sql, dialect, "forupdate", sql_query, PH_NO_CHECK);
	
	RETURN_CCTOR(sql);
}

PHP_METHOD(Phalcon_Db_Adapter, sharedLock){

	zval *sql_query, *dialect, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_1(sql, dialect, "sharedlock", sql_query, PH_NO_CHECK);
	
	RETURN_CCTOR(sql);
}

PHP_METHOD(Phalcon_Db_Adapter, createTable){

	zval *table_name, *schema_name, *definition;
	zval *exception_message, *columns, *dialect;
	zval *sql, *success;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid definition to create the table '", table_name, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SS("columns"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, definition, SL("columns"), PH_NOISY_CC);
	if (!phalcon_fast_count_ev(columns TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "createtable", table_name, schema_name, definition, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *dialect;
	zval *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_INIT_NVAR(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "droptable", table_name, schema_name, if_exists, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, addColumn){

	zval *table_name, *schema_name, *column, *dialect;
	zval *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "addcolumn", table_name, schema_name, column, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, modifyColumn){

	zval *table_name, *schema_name, *column, *dialect;
	zval *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "modifycolumn", table_name, schema_name, column, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, dropColumn){

	zval *table_name, *schema_name, *column_name;
	zval *dialect, *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "dropcolumn", table_name, schema_name, column_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, addIndex){

	zval *table_name, *schema_name, *index, *dialect;
	zval *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "addindex", table_name, schema_name, index, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, dropIndex){

	zval *table_name, *schema_name, *index_name;
	zval *dialect, *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "dropindex", table_name, schema_name, index_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, addPrimaryKey){

	zval *table_name, *schema_name, *index, *sql, *success;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_dialect"), PH_NOISY_CC);
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, t0, "addprimarykey", table_name, schema_name, index, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, dropPrimaryKey){

	zval *table_name, *schema_name, *dialect, *sql;
	zval *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_2(sql, dialect, "dropprimarykey", table_name, schema_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, addForeignKey){

	zval *table_name, *schema_name, *reference, *dialect;
	zval *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "addforeignkey", table_name, schema_name, reference, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;
	zval *dialect, *sql, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_3(sql, dialect, "dropforeignkey", table_name, schema_name, reference_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_1(success, this_ptr, "execute", sql, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Db_Adapter, getColumnDefinition){

	zval *column, *dialect, *definition;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(definition);
	PHALCON_CALL_METHOD_PARAMS_1(definition, dialect, "getcolumndefinition", column, PH_NO_CHECK);
	
	RETURN_CCTOR(definition);
}

PHP_METHOD(Phalcon_Db_Adapter, listTables){

	zval *schema_name = NULL, *dialect, *sql, *fetch_num, *tables;
	zval *all_tables, *table = NULL, *table_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(dialect);
	phalcon_read_property(&dialect, this_ptr, SL("_dialect"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_1(sql, dialect, "listtables", schema_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(fetch_num);
	phalcon_get_class_constant(fetch_num, phalcon_db_ce, SS("FETCH_NUM") TSRMLS_CC);
	
	PHALCON_INIT_VAR(tables);
	PHALCON_CALL_METHOD_PARAMS_2(tables, this_ptr, "fetchall", sql, fetch_num, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(all_tables);
	array_init(all_tables);
	
	if (!phalcon_valid_foreach(tables TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(tables);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(table);
	
		PHALCON_INIT_NVAR(table_name);
		phalcon_array_fetch_long(&table_name, table, 0, PH_NOISY_CC);
		phalcon_array_append(&all_tables, table_name, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(all_tables);
}

PHP_METHOD(Phalcon_Db_Adapter, getDescriptor){


	RETURN_MEMBER(this_ptr, "_descriptor");
}

PHP_METHOD(Phalcon_Db_Adapter, getConnectionId){


	RETURN_MEMBER(this_ptr, "_connectionId");
}

PHP_METHOD(Phalcon_Db_Adapter, getSQLStatement){


	RETURN_MEMBER(this_ptr, "_sqlStatement");
}

PHP_METHOD(Phalcon_Db_Adapter, getRealSQLStatement){


	RETURN_MEMBER(this_ptr, "_sqlStatement");
}

PHP_METHOD(Phalcon_Db_Adapter, getSQLVariables){


	RETURN_MEMBER(this_ptr, "_sqlVariables");
}

PHP_METHOD(Phalcon_Db_Adapter, getSQLBindTypes){


	RETURN_MEMBER(this_ptr, "_sqlBindTypes");
}

PHP_METHOD(Phalcon_Db_Adapter, getType){


	RETURN_MEMBER(this_ptr, "_type");
}

PHP_METHOD(Phalcon_Db_Adapter, getDialectType){


	RETURN_MEMBER(this_ptr, "_dialectType");
}

PHP_METHOD(Phalcon_Db_Adapter, getDialect){


	RETURN_MEMBER(this_ptr, "_dialect");
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_DialectInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, DialectInterface, db_dialectinterface, phalcon_db_dialectinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, limit);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, forUpdate);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, sharedLock);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, select);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, getColumnList);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, getColumnDefinition);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, addColumn);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, modifyColumn);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, dropColumn);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, addIndex);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, dropIndex);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, addPrimaryKey);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, dropPrimaryKey);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, addForeignKey);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, dropForeignKey);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, createTable);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, dropTable);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, tableExists);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, describeColumns);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, listTables);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, describeIndexes);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, describeReferences);

PHALCON_DOC_METHOD(Phalcon_Db_DialectInterface, tableOptions);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Profiler){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Profiler, db_profiler, phalcon_db_profiler_method_entry, 0);

	zend_declare_property_null(phalcon_db_profiler_ce, SL("_allProfiles"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_ce, SL("_activeProfile"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_profiler_ce, SL("_totalSeconds"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Profiler, __construct){


	phalcon_update_property_empty_array(phalcon_db_profiler_ce, this_ptr, SL("_allProfiles") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Profiler, startProfile){

	zval *sql_statement, *active_profile, *micro;
	zval *time;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(active_profile);
	object_init_ex(active_profile, phalcon_db_profiler_item_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(active_profile, "setsqlstatement", sql_statement, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(micro);
	ZVAL_BOOL(micro, 1);
	
	PHALCON_INIT_VAR(time);
	PHALCON_CALL_FUNC_PARAMS_1(time, "microtime", micro);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(active_profile, "setinitialtime", time, PH_NO_CHECK);
	if (phalcon_method_exists_ex(this_ptr, SS("beforestartprofile") TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "beforestartprofile", active_profile, PH_NO_CHECK);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_activeProfile"), active_profile TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Db_Profiler, stopProfile){

	zval *micro, *final_time, *active_profile, *initial_time;
	zval *diference, *total_seconds, *new_total_seconds;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(micro);
	ZVAL_BOOL(micro, 1);
	
	PHALCON_INIT_VAR(final_time);
	PHALCON_CALL_FUNC_PARAMS_1(final_time, "microtime", micro);
	
	PHALCON_INIT_VAR(active_profile);
	phalcon_read_property(&active_profile, this_ptr, SL("_activeProfile"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(active_profile, "setfinaltime", final_time, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(initial_time);
	PHALCON_CALL_METHOD(initial_time, active_profile, "getinitialtime", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(diference);
	sub_function(diference, final_time, initial_time TSRMLS_CC);
	
	PHALCON_INIT_VAR(total_seconds);
	phalcon_read_property(&total_seconds, this_ptr, SL("_totalSeconds"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(new_total_seconds);
	phalcon_add_function(new_total_seconds, total_seconds, diference TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_totalSeconds"), new_total_seconds TSRMLS_CC);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_allProfiles"), PH_NOISY_CC);
	phalcon_array_append(&t0, active_profile, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_allProfiles"), t0 TSRMLS_CC);
	if (phalcon_method_exists_ex(this_ptr, SS("afterendprofile") TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "afterendprofile", active_profile, PH_NO_CHECK);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Db_Profiler, getNumberTotalStatements){

	zval *all_profiles, *number_profiles;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(all_profiles);
	phalcon_read_property(&all_profiles, this_ptr, SL("_allProfiles"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(number_profiles);
	phalcon_fast_count(number_profiles, all_profiles TSRMLS_CC);
	
	RETURN_CCTOR(number_profiles);
}

PHP_METHOD(Phalcon_Db_Profiler, getTotalElapsedSeconds){


	RETURN_MEMBER(this_ptr, "_totalSeconds");
}

PHP_METHOD(Phalcon_Db_Profiler, getProfiles){


	RETURN_MEMBER(this_ptr, "_allProfiles");
}

PHP_METHOD(Phalcon_Db_Profiler, reset){

	zval *empty_arr;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	phalcon_update_property_zval(this_ptr, SL("_allProfiles"), empty_arr TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Db_Profiler, getLastProfile){


	RETURN_MEMBER(this_ptr, "_activeProfile");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Result_Pdo){

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Result, Pdo, db_result_pdo, phalcon_db_result_pdo_method_entry, 0);

	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_result_pdo_ce, SL("_fetchMode"), 4, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_pdoStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_bindParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_bindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_result_pdo_ce, SL("_rowCount"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Result_Pdo, __construct){

	zval *connection, *result, *sql_statement = NULL, *bind_params = NULL;
	zval *bind_types = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zzz", &connection, &result, &sql_statement, &bind_params, &bind_types) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!sql_statement) {
		PHALCON_INIT_NVAR(sql_statement);
	}
	
	if (!bind_params) {
		PHALCON_INIT_NVAR(bind_params);
	}
	
	if (!bind_types) {
		PHALCON_INIT_NVAR(bind_types);
	}
	
	if (Z_TYPE_P(result) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid PDOStatement supplied to Phalcon\\Db\\Result\\Pdo");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_pdoStatement"), result TSRMLS_CC);
	if (Z_TYPE_P(sql_statement) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_sqlStatement"), sql_statement TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_params) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_bindParams"), bind_params TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_bindTypes"), bind_types TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Result_Pdo, execute){

	zval *pdo_statement, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD(status, pdo_statement, "execute", PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Db_Result_Pdo, fetch){

	zval *pdo_statement, *row;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(row);
	PHALCON_CALL_METHOD(row, pdo_statement, "fetch", PH_NO_CHECK);
	
	RETURN_CCTOR(row);
}

PHP_METHOD(Phalcon_Db_Result_Pdo, fetchArray){

	zval *pdo_statement, *row;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(row);
	PHALCON_CALL_METHOD(row, pdo_statement, "fetch", PH_NO_CHECK);
	
	RETURN_CCTOR(row);
}

PHP_METHOD(Phalcon_Db_Result_Pdo, fetchAll){

	zval *pdo_statement, *rows;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(rows);
	PHALCON_CALL_METHOD(rows, pdo_statement, "fetchall", PH_NO_CHECK);
	
	RETURN_CCTOR(rows);
}

PHP_METHOD(Phalcon_Db_Result_Pdo, numRows){

	zval *row_count = NULL, *connection, *type, *sql_statement;
	zval *bind_params, *bind_types, *matches, *pattern;
	zval *match, *else_clauses, *sql, *fetch_num, *result;
	zval *row, *pdo_statement;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(row_count);
	phalcon_read_property(&row_count, this_ptr, SL("_rowCount"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(row_count)) {
		PHALCON_INIT_VAR(connection);
		phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(type);
		PHALCON_CALL_METHOD(type, connection, "gettype", PH_NO_CHECK);
		if (PHALCON_COMPARE_STRING(type, "sqlite")) {
			PHALCON_INIT_VAR(sql_statement);
			phalcon_read_property(&sql_statement, this_ptr, SL("_sqlStatement"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(bind_params);
			phalcon_read_property(&bind_params, this_ptr, SL("_bindParams"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(bind_types);
			phalcon_read_property(&bind_types, this_ptr, SL("_bindTypes"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(matches);
	
			PHALCON_INIT_VAR(pattern);
			ZVAL_STRING(pattern, "/^SELECT\\s+(.*)$/i", 1);
			Z_SET_ISREF_P(matches);
	
			PHALCON_INIT_VAR(match);
			PHALCON_CALL_FUNC_PARAMS_3(match, "preg_match", pattern, sql_statement, matches);
			Z_UNSET_ISREF_P(matches);
			if (zend_is_true(match)) {
				PHALCON_INIT_VAR(else_clauses);
				phalcon_array_fetch_long(&else_clauses, matches, 1, PH_NOISY_CC);
	
				PHALCON_INIT_VAR(sql);
				PHALCON_CONCAT_SVS(sql, "SELECT COUNT(*) FROM (SELECT ", else_clauses, ")");
	
				PHALCON_INIT_VAR(fetch_num);
				ZVAL_LONG(fetch_num, 3);
	
				PHALCON_INIT_VAR(result);
				PHALCON_CALL_METHOD_PARAMS_3(result, connection, "query", sql, bind_params, bind_types, PH_NO_CHECK);
	
				PHALCON_INIT_VAR(row);
				PHALCON_CALL_METHOD(row, result, "fetch", PH_NO_CHECK);
	
				PHALCON_INIT_NVAR(row_count);
				phalcon_array_fetch_long(&row_count, row, 0, PH_NOISY_CC);
			}
		} else {
			PHALCON_INIT_VAR(pdo_statement);
			phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(row_count);
			PHALCON_CALL_METHOD(row_count, pdo_statement, "rowcount", PH_NO_CHECK);
		}
	
		phalcon_update_property_zval(this_ptr, SL("_rowCount"), row_count TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(row_count);
}

PHP_METHOD(Phalcon_Db_Result_Pdo, dataSeek){

	long number = 0, n;
	zval *pdo_statement = NULL;
	pdo_stmt_t *stmt;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);

	stmt = (pdo_stmt_t*) zend_object_store_get_object(pdo_statement TSRMLS_CC);
	if (!stmt->dbh) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}

	if (!stmt->methods->executer(stmt TSRMLS_CC)) {
		stmt->executed = 1;
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}

	n = -1;
	number--;
	while (n != number) {

		if(!stmt->methods->fetcher(stmt, PDO_FETCH_ORI_NEXT, 0 TSRMLS_CC)) {
			PHALCON_MM_RESTORE();
			RETURN_NULL();
		}

		n++;
	}

	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Db_Result_Pdo, setFetchMode){

	long fetch_mode;
	zval *pdo_statement, *fetch_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &fetch_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(fetch_type);

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	if (fetch_mode == 1) {
		ZVAL_LONG(fetch_type, 2);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(pdo_statement, "setfetchmode", fetch_type, PH_NO_CHECK);
		phalcon_update_property_long(this_ptr, SL("_fetchMode"), 2 TSRMLS_CC);
	} else {
		if (fetch_mode == 2) {
			ZVAL_LONG(fetch_type, 4);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(pdo_statement, "setfetchmode", fetch_type, PH_NO_CHECK);
			phalcon_update_property_long(this_ptr, SL("_fetchMode"), 4 TSRMLS_CC);
		} else {
			if (fetch_mode == 3) {
				ZVAL_LONG(fetch_type, 3);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(pdo_statement, "setfetchmode", fetch_type, PH_NO_CHECK);
				phalcon_update_property_long(this_ptr, SL("_fetchMode"), 3 TSRMLS_CC);
			} else {
				if (fetch_mode == 4) {
					ZVAL_LONG(fetch_type, 5);
					PHALCON_CALL_METHOD_PARAMS_1_NORETURN(pdo_statement, "setfetchmode", fetch_type, PH_NO_CHECK);
					phalcon_update_property_long(this_ptr, SL("_fetchMode"), 5 TSRMLS_CC);
				}
			}
		}
	}

	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Db_Result_Pdo, getInternalResult){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY_CC);
	
	RETURN_CCTOR(pdo_statement);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_RawValue){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, RawValue, db_rawvalue, phalcon_db_rawvalue_method_entry, 0);

	zend_declare_property_null(phalcon_db_rawvalue_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_RawValue, __construct){

	zval *value;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &value) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_value"), value TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_RawValue, getValue){


	RETURN_MEMBER(this_ptr, "_value");
}

PHP_METHOD(Phalcon_Db_RawValue, __toString){


	RETURN_MEMBER(this_ptr, "_value");
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, AdapterInterface, db_adapterinterface, phalcon_db_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, fetchOne);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, fetchAll);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, insert);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, update);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, delete);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getColumnList);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, limit);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, tableExists);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, viewExists);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, forUpdate);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, sharedLock);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, createTable);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, dropTable);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, addColumn);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, modifyColumn);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, dropColumn);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, addIndex);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, dropIndex);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, addPrimaryKey);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, dropPrimaryKey);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, addForeignKey);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, dropForeignKey);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getColumnDefinition);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, listTables);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getDescriptor);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getConnectionId);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getSQLStatement);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getRealSQLStatement);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getSQLVariables);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getSQLBindTypes);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getType);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getDialectType);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getDialect);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, connect);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, query);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, execute);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, affectedRows);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, close);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, escapeString);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, bindParams);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, convertBoundParams);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, lastInsertId);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, begin);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, rollback);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, commit);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, isUnderTransaction);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getInternalHandler);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, describeIndexes);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, describeReferences);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, tableOptions);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, getDefaultIdValue);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, supportSequences);

PHALCON_DOC_METHOD(Phalcon_Db_AdapterInterface, describeColumns);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Postgresql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Postgresql, db_dialect_postgresql, "phalcon\\db\\dialect", phalcon_db_dialect_postgresql_method_entry, 0);

	zend_class_implements(phalcon_db_dialect_postgresql_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnList){

	zval *column_list, *str_list, *column = NULL, *column_quoted = NULL;
	zval *joined_list;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	
	if (!phalcon_valid_foreach(column_list TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(column_list);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(column_quoted);
		PHALCON_CONCAT_SVS(column_quoted, "\"", column, "\"");
		phalcon_array_append(&str_list, column_quoted, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(joined_list);
	phalcon_fast_join_str(joined_list, SL(", "), str_list TSRMLS_CC);
	
	RETURN_CTOR(joined_list);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnDefinition){

	zval *column, *size, *column_type, *column_sql = NULL;
	zval *scale;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an object compatible with Phalcon\\Db\\ColumnInterface");
		return;
	}
	
	PHALCON_INIT_VAR(size);
	PHALCON_CALL_METHOD(size, column, "getsize", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_type);
	PHALCON_CALL_METHOD(column_type, column, "gettype", PH_NO_CHECK);
	
	if (phalcon_compare_strict_long(column_type, 0 TSRMLS_CC)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "INT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 1 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "DATE", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 2 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHARACTER VARYING(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 3 TSRMLS_CC)) {
		PHALCON_INIT_VAR(scale);
		PHALCON_CALL_METHOD(scale, column, "getscale", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVSVS(column_sql, "NUMERIC(", size, ",", scale, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 4 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "TIMESTAMP", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 5 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHARACTER(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 6 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "TEXT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 7 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "FLOAT", 1);
		goto ph_end_0;
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized PostgreSQL data type");
	return;
	
	ph_end_0:
	
	RETURN_CTOR(column_sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addColumn){

	zval *table_name, *schema_name, *column;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, modifyColumn){

	zval *table_name, *schema_name, *column;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropColumn){

	zval *table_name, *schema_name, *column_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addIndex){

	zval *table_name, *schema_name, *index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropIndex){

	zval *table_name, *schema_name, *index_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addPrimaryKey){

	zval *table_name, *schema_name, *index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropPrimaryKey){

	zval *table_name, *schema_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addForeignKey){

	zval *table_name, *schema_name, *reference;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, _getTableOptions){

	zval *definition, *empty_array;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	
	RETURN_CTOR(empty_array);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createTable){

	zval *table_name, *schema_name, *definition;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_INIT_NVAR(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		PHALCON_CPY_WRT(table, table_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE ", table);
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableExists){

	zval *table_name, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM information_schema.tables WHERE table_schema = '", schema_name, "' AND table_name='", table_name, "'");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM information_schema.tables WHERE table_schema = 'public' AND table_name='", table_name, "'");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeColumns){

	zval *table, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT DISTINCT c.column_name AS Field, c.data_type AS Type, c.character_maximum_length AS Size, c.numeric_precision AS NumericSize, c.is_nullable AS Null, CASE WHEN pkc.column_name NOTNULL THEN 'PRI' ELSE '' END AS Key, CASE WHEN c.data_type LIKE '%int%' AND c.column_default LIKE '%nextval%' THEN 'auto_increment' ELSE '' END AS Extra, c.ordinal_position AS Position FROM information_schema.columns c LEFT JOIN ( SELECT kcu.column_name, kcu.table_name, kcu.table_schema FROM information_schema.table_constraints tc INNER JOIN information_schema.key_column_usage kcu on (kcu.constraint_name = tc.constraint_name and kcu.table_name=tc.table_name and kcu.table_schema=tc.table_schema) WHERE tc.constraint_type='PRIMARY KEY') pkc ON (c.column_name=pkc.column_name AND c.table_schema = pkc.table_schema AND c.table_name=pkc.table_name) WHERE c.table_schema='", schema, "' AND c.table_name='", table, "' ORDER BY c.ordinal_position");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT DISTINCT c.column_name AS Field, c.data_type AS Type, c.character_maximum_length AS Size, c.numeric_precision AS NumericSize, c.is_nullable AS Null, CASE WHEN pkc.column_name NOTNULL THEN 'PRI' ELSE '' END AS Key, CASE WHEN c.data_type LIKE '%int%' AND c.column_default LIKE '%nextval%' THEN 'auto_increment' ELSE '' END AS Extra, c.ordinal_position AS Position FROM information_schema.columns c LEFT JOIN ( SELECT kcu.column_name, kcu.table_name, kcu.table_schema FROM information_schema.table_constraints tc INNER JOIN information_schema.key_column_usage kcu on (kcu.constraint_name = tc.constraint_name and kcu.table_name=tc.table_name and kcu.table_schema=tc.table_schema) WHERE tc.constraint_type='PRIMARY KEY') pkc ON (c.column_name=pkc.column_name AND c.table_schema = pkc.table_schema AND c.table_name=pkc.table_name) WHERE c.table_schema='public' AND c.table_name='", table, "' ORDER BY c.ordinal_position");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listTables){

	zval *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT table_name FROM information_schema.tables WHERE table_schema = '", schema_name, "' ORDER BY table_name");
	} else {
		PHALCON_INIT_NVAR(sql);
		ZVAL_STRING(sql, "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name", 1);
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeIndexes){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "SELECT t.relname as table_name, i.relname as key_name, a.attname as column_name FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND a.attnum = ANY(ix.indkey) AND t.relkind = 'r' AND t.relname = '", table, "' ORDER BY t.relname, i.relname;");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT tc.table_name as TABLE_NAME, kcu.column_name as COLUMN_NAME, tc.constraint_name as CONSTRAINT_NAME, tc.table_catalog as REFERENCED_TABLE_SCHEMA, ccu.table_name AS REFERENCED_TABLE_NAME, ccu.column_name AS REFERENCED_COLUMN_NAME FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND ", 1);
	if (zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "tc.table_schema = '", schema, "' AND tc.table_name='", table, "'");
	} else {
		PHALCON_SCONCAT_SVS(sql, "tc.table_name='", table, "'");
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableOptions){

	zval *table, *schema = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Sqlite){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Sqlite, db_dialect_sqlite, "phalcon\\db\\dialect", phalcon_db_dialect_sqlite_method_entry, 0);

	zend_class_implements(phalcon_db_dialect_sqlite_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, getColumnList){

	zval *column_list, *str_list, *column = NULL, *quoted_column = NULL;
	zval *joined_list;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	
	if (!phalcon_valid_foreach(column_list TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(column_list);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(quoted_column);
		PHALCON_CONCAT_SVS(quoted_column, "\"", column, "\"");
		phalcon_array_append(&str_list, quoted_column, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(joined_list);
	phalcon_fast_join_str(joined_list, SL(", "), column_list TSRMLS_CC);
	
	RETURN_CTOR(joined_list);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, getColumnDefinition){

	zval *column, *size, *column_type, *column_sql = NULL;
	zval *scale;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an instance of Phalcon\\Db\\Column");
		return;
	}
	
	PHALCON_INIT_VAR(size);
	PHALCON_CALL_METHOD(size, column, "getsize", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_type);
	PHALCON_CALL_METHOD(column_type, column, "gettype", PH_NO_CHECK);
	
	if (phalcon_compare_strict_long(column_type, 0 TSRMLS_CC)) {
		PHALCON_INIT_VAR(column_sql);
		ZVAL_STRING(column_sql, "INT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 1 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "DATE", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 2 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "VARCHAR(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 3 TSRMLS_CC)) {
		PHALCON_INIT_VAR(scale);
		PHALCON_CALL_METHOD(scale, column, "getscale", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVSVS(column_sql, "NUMERIC(", size, ",", scale, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 4 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "TIMESTAMP", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 5 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHARACTER(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 6 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "TEXT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 7 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "FLOAT", 1);
		goto ph_end_0;
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized Sqlite data type");
	return;
	
	ph_end_0:
	
	RETURN_CTOR(column_sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addColumn){

	zval *table_name, *schema_name, *column;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, modifyColumn){

	zval *table_name, *schema_name, *column;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropColumn){

	zval *table_name, *schema_name, *column_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addIndex){

	zval *table_name, *schema_name, *index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropIndex){

	zval *table_name, *schema_name, *index_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addPrimaryKey){

	zval *table_name, *schema_name, *index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropPrimaryKey){

	zval *table_name, *schema_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addForeignKey){

	zval *table_name, *schema_name, *reference;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, _getTableOptions){

	zval *definition, *empty_array;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	
	RETURN_CTOR(empty_array);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, createTable){

	zval *table_name, *schema_name, *definition;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_INIT_NVAR(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		PHALCON_CPY_WRT(table, table_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE ", table);
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableExists){

	zval *table_name, *schema_name = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM sqlite_master WHERE type='table' AND tbl_name='", table_name, "'");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeColumns){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "PRAGMA table_info('", table, "')");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, listTables){

	zval *schema_name = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT tbl_name FROM sqlite_master WHERE type = 'table' ORDER BY tbl_name", 1);
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndexes){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "PRAGMA index_list('", table, "')");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndex){

	zval *index_name, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "PRAGMA index_info('", index_name, "')");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "PRAGMA foreign_key_list('", table, "')");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableOptions){

	zval *table, *schema = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Mysql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Mysql, db_dialect_mysql, "phalcon\\db\\dialect", phalcon_db_dialect_mysql_method_entry, 0);

	zend_class_implements(phalcon_db_dialect_mysql_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnList){

	zval *column_list, *str_list, *column = NULL, *column_quoted = NULL;
	zval *joined_list;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	
	if (!phalcon_valid_foreach(column_list TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(column_list);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(column_quoted);
		PHALCON_CONCAT_SVS(column_quoted, "`", column, "`");
		phalcon_array_append(&str_list, column_quoted, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(joined_list);
	phalcon_fast_join_str(joined_list, SL(", "), str_list TSRMLS_CC);
	
	RETURN_CTOR(joined_list);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnDefinition){

	zval *column, *size, *column_type, *column_sql = NULL;
	zval *is_unsigned = NULL, *scale = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an object compatible with Phalcon\\Db\\ColumnInterface");
		return;
	}
	
	PHALCON_INIT_VAR(size);
	PHALCON_CALL_METHOD(size, column, "getsize", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_type);
	PHALCON_CALL_METHOD(column_type, column, "gettype", PH_NO_CHECK);
	
	if (phalcon_compare_strict_long(column_type, 0 TSRMLS_CC)) {
		PHALCON_INIT_VAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "INT(", size, ")");
	
		PHALCON_INIT_VAR(is_unsigned);
		PHALCON_CALL_METHOD(is_unsigned, column, "isunsigned", PH_NO_CHECK);
		if (zend_is_true(is_unsigned)) {
			phalcon_concat_self_str(column_sql, SL(" UNSIGNED") TSRMLS_CC);
		}
	
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 1 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "DATE", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 2 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "VARCHAR(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 3 TSRMLS_CC)) {
		PHALCON_INIT_VAR(scale);
		PHALCON_CALL_METHOD(scale, column, "getscale", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVSVS(column_sql, "DECIMAL(", size, ",", scale, ")");
	
		PHALCON_INIT_NVAR(is_unsigned);
		PHALCON_CALL_METHOD(is_unsigned, column, "isunsigned", PH_NO_CHECK);
		if (zend_is_true(is_unsigned)) {
			phalcon_concat_self_str(column_sql, SL(" UNSIGNED") TSRMLS_CC);
		}
	
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 4 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "DATETIME", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 5 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		PHALCON_CONCAT_SVS(column_sql, "CHAR(", size, ")");
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 6 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "TEXT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(column_type, 7 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(column_sql);
		ZVAL_STRING(column_sql, "FLOAT", 1);
	
		PHALCON_INIT_NVAR(scale);
		PHALCON_CALL_METHOD(scale, column, "getscale", PH_NO_CHECK);
		if (zend_is_true(size)) {
			PHALCON_SCONCAT_SV(column_sql, "(", size);
			if (zend_is_true(scale)) {
				PHALCON_SCONCAT_SVS(column_sql, ",", scale, ")");
			} else {
				phalcon_concat_self_str(column_sql, SL(")") TSRMLS_CC);
			}
		}
	
		PHALCON_INIT_NVAR(is_unsigned);
		PHALCON_CALL_METHOD(is_unsigned, column, "isunsigned", PH_NO_CHECK);
		if (zend_is_true(is_unsigned)) {
			phalcon_concat_self_str(column_sql, SL(" UNSIGNED") TSRMLS_CC);
		}
	
		goto ph_end_0;
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized MySQL data type");
	return;
	
	ph_end_0:
	
	RETURN_CTOR(column_sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, addColumn){

	zval *table_name, *schema_name, *column, *sql = NULL, *name;
	zval *column_definition, *is_not_null, *is_first;
	zval *after_position;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon\\Db\\Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD ");
	}
	
	PHALCON_INIT_VAR(name);
	PHALCON_CALL_METHOD(name, column, "getname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_definition);
	PHALCON_CALL_METHOD_PARAMS_1(column_definition, this_ptr, "getcolumndefinition", column, PH_NO_CHECK);
	PHALCON_SCONCAT_SVSV(sql, "`", name, "` ", column_definition);
	
	PHALCON_INIT_VAR(is_not_null);
	PHALCON_CALL_METHOD(is_not_null, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(is_not_null)) {
		phalcon_concat_self_str(sql, SL(" NOT NULL") TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(is_first);
	PHALCON_CALL_METHOD(is_first, column, "isfirst", PH_NO_CHECK);
	if (zend_is_true(is_first)) {
		phalcon_concat_self_str(sql, SL(" FIRST") TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(after_position);
		PHALCON_CALL_METHOD(after_position, column, "getafterposition", PH_NO_CHECK);
		if (zend_is_true(after_position)) {
			PHALCON_SCONCAT_SV(sql, " AFTER ", after_position);
		}
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, modifyColumn){

	zval *table_name, *schema_name, *column, *sql = NULL, *name;
	zval *column_definition, *is_not_null;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column parameter must be an instance of Phalcon\\Db\\Column");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` MODIFY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` MODIFY ");
	}
	
	PHALCON_INIT_VAR(name);
	PHALCON_CALL_METHOD(name, column, "getname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_definition);
	PHALCON_CALL_METHOD_PARAMS_1(column_definition, this_ptr, "getcolumndefinition", column, PH_NO_CHECK);
	PHALCON_SCONCAT_SVSV(sql, "`", name, "` ", column_definition);
	
	PHALCON_INIT_VAR(is_not_null);
	PHALCON_CALL_METHOD(is_not_null, column, "isnotnull", PH_NO_CHECK);
	if (zend_is_true(is_not_null)) {
		phalcon_concat_self_str(sql, SL(" NOT NULL") TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropColumn){

	zval *table_name, *schema_name, *column_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &column_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP COLUMN ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP COLUMN ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", column_name, "`");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, addIndex){

	zval *table_name, *schema_name, *index, *sql = NULL, *columns;
	zval *quoted_column_list, *name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon\\Db\\Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD INDEX ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD INDEX ");
	}
	
	PHALCON_INIT_VAR(columns);
	PHALCON_CALL_METHOD(columns, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(quoted_column_list);
	PHALCON_CALL_METHOD_PARAMS_1(quoted_column_list, this_ptr, "getcolumnlist", columns, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(name);
	PHALCON_CALL_METHOD(name, index, "getname", PH_NO_CHECK);
	PHALCON_SCONCAT_SVSVS(sql, "`", name, "` (", quoted_column_list, ")");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropIndex){

	zval *table_name, *schema_name, *index_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP INDEX ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP INDEX ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", index_name, "`");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, addPrimaryKey){

	zval *table_name, *schema_name, *index, *sql = NULL, *columns;
	zval *column_list;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(index) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Index parameter must be an instance of Phalcon\\Db\\Index");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD PRIMARY KEY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD PRIMARY KEY ");
	}
	
	PHALCON_INIT_VAR(columns);
	PHALCON_CALL_METHOD(columns, index, "getcolumns", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(column_list);
	PHALCON_CALL_METHOD_PARAMS_1(column_list, this_ptr, "getcolumnlist", columns, PH_NO_CHECK);
	PHALCON_SCONCAT_SVS(sql, "(", column_list, ")");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropPrimaryKey){

	zval *table_name, *schema_name, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP PRIMARY KEY");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP PRIMARY KEY");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, addForeignKey){

	zval *table_name, *schema_name, *reference, *sql = NULL;
	zval *columns, *quoted_column_list, *reference_name;
	zval *referenced_schema, *referenced_columns;
	zval *quoted_columns, *referenced_table;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(reference) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Reference parameter must be an instance of Phalcon\\Db\\Reference");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD FOREIGN KEY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD FOREIGN KEY ");
	}
	
	PHALCON_INIT_VAR(columns);
	PHALCON_CALL_METHOD(columns, reference, "getcolumns", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(quoted_column_list);
	PHALCON_CALL_METHOD_PARAMS_1(quoted_column_list, this_ptr, "getcolumnlist", columns, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(reference_name);
	PHALCON_CALL_METHOD(reference_name, reference, "getname", PH_NO_CHECK);
	PHALCON_SCONCAT_SVSVS(sql, "`", reference_name, "`(", quoted_column_list, ") REFERENCES ");
	
	PHALCON_INIT_VAR(referenced_schema);
	PHALCON_CALL_METHOD(referenced_schema, reference, "getreferencedschema", PH_NO_CHECK);
	if (zend_is_true(referenced_schema)) {
		PHALCON_SCONCAT_SVS(sql, "`", referenced_schema, "`.");
	}
	
	PHALCON_INIT_VAR(referenced_columns);
	PHALCON_CALL_METHOD(referenced_columns, reference, "getreferencedcolumns", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(quoted_columns);
	PHALCON_CALL_METHOD_PARAMS_1(quoted_columns, this_ptr, "getcolumnlist", referenced_columns, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(referenced_table);
	PHALCON_CALL_METHOD(referenced_table, reference, "getreferencedtable", PH_NO_CHECK);
	PHALCON_SCONCAT_SVSVS(sql, "`", referenced_table, "`(", quoted_columns, ")");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &reference_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP FOREIGN KEY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP FOREIGN KEY ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", reference_name, "`");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, _getTableOptions){

	zval *definition, *table_options, *engine, *sql_engine;
	zval *auto_increment, *sql_autoincrement;
	zval *table_collation, *under_score, *collation_parts;
	zval *sql_charset, *sql_collate, *sql_table_options;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(table_options);
	array_init(table_options);
	
	PHALCON_INIT_VAR(r0);
	phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r0, SS("ENGINE"));
	if (eval_int) {
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(engine);
		phalcon_array_fetch_string(&engine, r1, SL("ENGINE"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r2);
		phalcon_array_fetch_string(&r2, definition, SL("options"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r3);
		phalcon_array_fetch_string(&r3, r2, SL("ENGINE"), PH_NOISY_CC);
		if (zend_is_true(r3)) {
			PHALCON_INIT_VAR(sql_engine);
			PHALCON_CONCAT_SV(sql_engine, "ENGINE=", engine);
			phalcon_array_append(&table_options, sql_engine, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(r4);
	phalcon_array_fetch_string(&r4, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r4, SS("AUTO_INCREMENT"));
	if (eval_int) {
		PHALCON_INIT_VAR(r5);
		phalcon_array_fetch_string(&r5, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(auto_increment);
		phalcon_array_fetch_string(&auto_increment, r5, SL("AUTO_INCREMENT"), PH_NOISY_CC);
		if (zend_is_true(auto_increment)) {
			PHALCON_INIT_VAR(sql_autoincrement);
			PHALCON_CONCAT_SV(sql_autoincrement, "AUTO_INCREMENT=", auto_increment);
			phalcon_array_append(&table_options, sql_autoincrement, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(r6);
	phalcon_array_fetch_string(&r6, definition, SL("options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(r6, SS("TABLE_COLLATION"));
	if (eval_int) {
		PHALCON_INIT_VAR(r7);
		phalcon_array_fetch_string(&r7, definition, SL("options"), PH_NOISY_CC);
		PHALCON_INIT_VAR(table_collation);
		phalcon_array_fetch_string(&table_collation, r7, SL("TABLE_COLLATION"), PH_NOISY_CC);
		if (zend_is_true(table_collation)) {
			PHALCON_INIT_VAR(under_score);
			ZVAL_STRING(under_score, "_", 1);
	
			PHALCON_INIT_VAR(collation_parts);
			phalcon_fast_explode(collation_parts, under_score, table_collation TSRMLS_CC);
	
			PHALCON_INIT_VAR(r8);
			phalcon_array_fetch_long(&r8, collation_parts, 0, PH_NOISY_CC);
	
			PHALCON_INIT_VAR(sql_charset);
			PHALCON_CONCAT_SV(sql_charset, "DEFAULT CHARSET=", r8);
			phalcon_array_append(&table_options, sql_charset, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_VAR(sql_collate);
			PHALCON_CONCAT_SV(sql_collate, "COLLATE=", table_collation);
			phalcon_array_append(&table_options, sql_collate, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	if (phalcon_fast_count_ev(table_options TSRMLS_CC)) {
		PHALCON_INIT_VAR(sql_table_options);
		phalcon_fast_join_str(sql_table_options, SL(" "), table_options TSRMLS_CC);
	
		RETURN_CTOR(sql_table_options);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, createTable){

	zval *table_name, *schema_name, *definition;
	zval *table = NULL, *temporary = NULL, *sql = NULL, *create_lines, *columns = NULL;
	zval *column = NULL, *column_name = NULL, *column_definition = NULL;
	zval *column_line = NULL, *attribute = NULL, *indexes, *index = NULL;
	zval *index_name = NULL, *column_list = NULL, *index_sql = NULL, *references;
	zval *reference = NULL, *name = NULL, *referenced_table = NULL, *referenced_columns = NULL;
	zval *constaint_sql = NULL, *reference_sql = NULL, *joined_lines;
	zval *options;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &table_name, &schema_name, &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(definition, SS("columns"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'columns' is required in the definition array");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_NVAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	
	PHALCON_INIT_VAR(temporary);
	ZVAL_BOOL(temporary, 0);
	eval_int = phalcon_array_isset_string(definition, SS("options"));
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_string(&r0, definition, SL("options"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(r0, SS("temporary"));
		if (eval_int) {
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch_string(&r1, definition, SL("options"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r2);
			phalcon_array_fetch_string(&r2, r1, SL("temporary"), PH_NOISY_CC);
			if (zend_is_true(r2)) {
				ZVAL_BOOL(temporary, 1);
			}
		}
	}
	
	if (PHALCON_IS_TRUE(temporary)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TEMPORARY TABLE ", table, " (\n\t");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TABLE ", table, " (\n\t");
	}
	
	PHALCON_INIT_VAR(create_lines);
	array_init(create_lines);
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, definition, SL("columns"), PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(columns TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(columns);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(column_name);
		PHALCON_CALL_METHOD(column_name, column, "getname", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(column_definition);
		PHALCON_CALL_METHOD_PARAMS_1(column_definition, this_ptr, "getcolumndefinition", column, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(column_line);
		PHALCON_CONCAT_SVSV(column_line, "`", column_name, "` ", column_definition);
	
		PHALCON_INIT_NVAR(attribute);
		PHALCON_CALL_METHOD(attribute, column, "isnotnull", PH_NO_CHECK);
		if (zend_is_true(attribute)) {
			phalcon_concat_self_str(column_line, SL(" NOT NULL") TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(attribute);
		PHALCON_CALL_METHOD(attribute, column, "isautoincrement", PH_NO_CHECK);
		if (zend_is_true(attribute)) {
			phalcon_concat_self_str(column_line, SL(" AUTO_INCREMENT") TSRMLS_CC);
		}
	
		phalcon_array_append(&create_lines, column_line, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	eval_int = phalcon_array_isset_string(definition, SS("indexes"));
	if (eval_int) {
		PHALCON_INIT_VAR(indexes);
		phalcon_array_fetch_string(&indexes, definition, SL("indexes"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(indexes TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(indexes);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(index);
	
			PHALCON_INIT_NVAR(index_name);
			PHALCON_CALL_METHOD(index_name, index, "getname", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(columns);
			PHALCON_CALL_METHOD(columns, index, "getcolumns", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(column_list);
			PHALCON_CALL_METHOD_PARAMS_1(column_list, this_ptr, "getcolumnlist", columns, PH_NO_CHECK);
			if (PHALCON_COMPARE_STRING(index_name, "PRIMARY")) {
				PHALCON_INIT_NVAR(index_sql);
				PHALCON_CONCAT_SVS(index_sql, "PRIMARY KEY (", column_list, ")");
			} else {
				PHALCON_INIT_NVAR(index_sql);
				PHALCON_CONCAT_SVSVS(index_sql, "KEY `", index_name, "` (", column_list, ")");
			}
	
			phalcon_array_append(&create_lines, index_sql, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		if(0){}
	
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("references"));
	if (eval_int) {
		PHALCON_INIT_VAR(references);
		phalcon_array_fetch_string(&references, definition, SL("references"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(references TSRMLS_CC)) {
			return;
		}
	
		ah2 = Z_ARRVAL_P(references);
		zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
		ph_cycle_start_2:
	
			if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
				goto ph_cycle_end_2;
			}
	
			PHALCON_GET_FOREACH_VALUE(reference);
	
			PHALCON_INIT_NVAR(name);
			PHALCON_CALL_METHOD(name, reference, "getname", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(columns);
			PHALCON_CALL_METHOD(columns, reference, "getcolumns", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(column_list);
			PHALCON_CALL_METHOD_PARAMS_1(column_list, this_ptr, "getcolumnlist", columns, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(referenced_table);
			PHALCON_CALL_METHOD(referenced_table, reference, "getreferencedtable", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(referenced_columns);
			PHALCON_CALL_METHOD(referenced_columns, reference, "getreferencedcolumns", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(column_list);
			PHALCON_CALL_METHOD_PARAMS_1(column_list, this_ptr, "getcolumnlist", referenced_columns, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(constaint_sql);
			PHALCON_CONCAT_SVSVS(constaint_sql, "CONSTRAINT `", name, "` FOREIGN KEY (", column_list, ")");
	
			PHALCON_INIT_NVAR(reference_sql);
			PHALCON_CONCAT_VSVSVS(reference_sql, constaint_sql, " REFERENCES `", referenced_table, "`(", column_list, ")");
			phalcon_array_append(&create_lines, reference_sql, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah2, &hp2);
			goto ph_cycle_start_2;
	
		ph_cycle_end_2:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(joined_lines);
	phalcon_fast_join_str(joined_lines, SL(",\n\t"), create_lines TSRMLS_CC);
	PHALCON_SCONCAT_VS(sql, joined_lines, "\n)");
	eval_int = phalcon_array_isset_string(definition, SS("options"));
	if (eval_int) {
		PHALCON_INIT_VAR(options);
		PHALCON_CALL_METHOD_PARAMS_1(options, this_ptr, "_gettableoptions", definition, PH_NO_CHECK);
		PHALCON_SCONCAT_SV(sql, " ", options);
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &table_name, &schema_name, &if_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!if_exists) {
		PHALCON_INIT_NVAR(if_exists);
		ZVAL_BOOL(if_exists, 1);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_NVAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	if (zend_is_true(if_exists)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP TABLE ", table);
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableExists){

	zval *table_name, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table_name, &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`= '", table_name, "' AND `TABLE_SCHEMA`='", schema_name, "'");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`='", table_name, "'");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeColumns){

	zval *table, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "DESCRIBE `", schema, "`.`", table, "`");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "DESCRIBE `", table, "`");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, listTables){

	zval *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &schema_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema_name) {
		PHALCON_INIT_NVAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SHOW TABLES FROM `", schema_name, "`");
	} else {
		PHALCON_INIT_NVAR(sql);
		ZVAL_STRING(sql, "SHOW TABLES", 1);
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeIndexes){

	zval *table, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SHOW INDEXES FROM `", schema, "`.`", table, "`");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SHOW INDEXES FROM `", table, "`");
	}
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,REFERENCED_TABLE_SCHEMA,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_NAME IS NOT NULL AND ", 1);
	if (zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "CONSTRAINT_SCHEMA = \"", schema, "\" AND TABLE_NAME = \"", table, "\"");
	} else {
		PHALCON_SCONCAT_SVS(sql, "TABLE_NAME = \"", table, "\"");
	}
	
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableOptions){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!schema) {
		PHALCON_INIT_NVAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLES.TABLE_TYPE,TABLES.AUTO_INCREMENT,TABLES.ENGINE,TABLES.TABLE_COLLATION FROM INFORMATION_SCHEMA.TABLES WHERE ", 1);
	if (zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "TABLES.TABLE_SCHEMA = \"", schema, "\" AND TABLES.TABLE_NAME = \"", table, "\"");
	} else {
		PHALCON_SCONCAT_SVS(sql, "TABLES.TABLE_NAME = \"", table, "\"");
	}
	
	
	RETURN_CTOR(sql);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Profiler_Item){

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Profiler, Item, db_profiler_item, phalcon_db_profiler_item_method_entry, 0);

	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_initialTime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_finalTime"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLStatement){

	zval *sql_statement;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_statement) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_sqlStatement"), sql_statement TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLStatement){


	RETURN_MEMBER(this_ptr, "_sqlStatement");
}

PHP_METHOD(Phalcon_Db_Profiler_Item, setInitialTime){

	zval *initial_time;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &initial_time) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_initialTime"), initial_time TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Profiler_Item, setFinalTime){

	zval *final_time;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &final_time) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_finalTime"), final_time TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Profiler_Item, getInitialTime){


	RETURN_MEMBER(this_ptr, "_initialTime");
}

PHP_METHOD(Phalcon_Db_Profiler_Item, getFinalTime){


	RETURN_MEMBER(this_ptr, "_finalTime");
}

PHP_METHOD(Phalcon_Db_Profiler_Item, getTotalElapsedSeconds){

	zval *final_time, *initial_time, *elapsed;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(final_time);
	phalcon_read_property(&final_time, this_ptr, SL("_finalTime"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(initial_time);
	phalcon_read_property(&initial_time, this_ptr, SL("_initialTime"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(elapsed);
	sub_function(elapsed, final_time, initial_time TSRMLS_CC);
	
	RETURN_CTOR(elapsed);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Index){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Index, db_index, phalcon_db_index_method_entry, 0);

	zend_declare_property_null(phalcon_db_index_ce, SL("_indexName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_index_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_index_ce TSRMLS_CC, 1, phalcon_db_indexinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Index, __construct){

	zval *index_name, *columns;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index_name, &columns) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_indexName"), index_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_columns"), columns TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Db_Index, getName){


	RETURN_MEMBER(this_ptr, "_indexName");
}

PHP_METHOD(Phalcon_Db_Index, getColumns){


	RETURN_MEMBER(this_ptr, "_columns");
}

PHP_METHOD(Phalcon_Db_Index, __set_state){

	zval *data, *index_name, *columns, *index;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(data, SS("_indexName"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_indexName parameter is required");
		return;
	}
	eval_int = phalcon_array_isset_string(data, SS("_columns"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "_columns parameter is required");
		return;
	}
	
	PHALCON_INIT_VAR(index_name);
	phalcon_array_fetch_string(&index_name, data, SL("_indexName"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, data, SL("_columns"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(index);
	object_init_ex(index, phalcon_db_index_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(index, "__construct", index_name, columns, PH_CHECK);
	
	RETURN_CTOR(index);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Db_IndexInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, IndexInterface, db_indexinterface, phalcon_db_indexinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Db_IndexInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Db_IndexInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Db_IndexInterface, getColumns);

PHALCON_DOC_METHOD(Phalcon_Db_IndexInterface, __set_state);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Db_Dialect){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Dialect, db_dialect, phalcon_db_dialect_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Db_Dialect, limit){

	zval *sql_query, *number, *is_numeric, *limit, *sql_limit;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(is_numeric);
	PHALCON_CALL_FUNC_PARAMS_1(is_numeric, "is_numeric", number);
	if (PHALCON_IS_TRUE(is_numeric)) {
		PHALCON_INIT_VAR(limit);
		PHALCON_CALL_FUNC_PARAMS_1(limit, "intval", number);
	
		PHALCON_INIT_VAR(sql_limit);
		PHALCON_CONCAT_VSV(sql_limit, sql_query, " LIMIT ", limit);
	
		RETURN_CTOR(sql_limit);
	}
	
	
	RETURN_CCTOR(sql_query);
}

PHP_METHOD(Phalcon_Db_Dialect, forUpdate){

	zval *sql_query, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_VS(sql, sql_query, " FOR UPDATE");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect, sharedLock){

	zval *sql_query, *sql;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &sql_query) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_VS(sql, sql_query, " LOCK IN SHARE MODE");
	
	RETURN_CTOR(sql);
}

PHP_METHOD(Phalcon_Db_Dialect, select){

	zval *definition, *columns, *columns_sql = NULL, *tables;
	zval *tables_sql = NULL, *sql, *joins, *join = NULL, *type = NULL, *source = NULL;
	zval *sql_join = NULL, *join_conditions_array = NULL, *join_conditions = NULL;
	zval *where_conditions, *group_fields, *group_clause;
	zval *having_conditions, *order_fields, *limit_value;
	zval *number, *offset;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(definition, SS("tables"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'tables' is required in the definition array");
		return;
	}
	eval_int = phalcon_array_isset_string(definition, SS("columns"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'columns' is required in the definition array");
		return;
	}
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, definition, SL("columns"), PH_NOISY_CC);
	if (Z_TYPE_P(columns) == IS_ARRAY) { 
		PHALCON_INIT_VAR(columns_sql);
		phalcon_fast_join_str(columns_sql, SL(","), columns TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(columns_sql, columns);
	}
	
	PHALCON_INIT_VAR(tables);
	phalcon_array_fetch_string(&tables, definition, SL("tables"), PH_NOISY_CC);
	if (Z_TYPE_P(tables) == IS_ARRAY) { 
		PHALCON_INIT_VAR(tables_sql);
		phalcon_fast_join_str(tables_sql, SL(","), tables TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(tables_sql, tables);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVSV(sql, "SELECT ", columns_sql, " FROM ", tables_sql);
	eval_int = phalcon_array_isset_string(definition, SS("joins"));
	if (eval_int) {
		PHALCON_INIT_VAR(joins);
		phalcon_array_fetch_string(&joins, definition, SL("joins"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(joins TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(joins);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(join);
	
			PHALCON_INIT_NVAR(type);
			phalcon_array_fetch_string(&type, join, SL("type"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(source);
			phalcon_array_fetch_string(&source, join, SL("source"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(sql_join);
			PHALCON_CONCAT_SVSV(sql_join, " ", type, " JOIN ", source);
			eval_int = phalcon_array_isset_string(join, SS("conditions"));
			if (eval_int) {
				PHALCON_INIT_NVAR(join_conditions_array);
				phalcon_array_fetch_string(&join_conditions_array, join, SL("conditions"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(join_conditions);
				phalcon_fast_join_str(join_conditions, SL(" AND "), join_conditions_array TSRMLS_CC);
				PHALCON_SCONCAT_SV(sql_join, " ON ", join_conditions);
			}
	
			phalcon_concat_self(sql, sql_join TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("where"));
	if (eval_int) {
		PHALCON_INIT_VAR(where_conditions);
		phalcon_array_fetch_string(&where_conditions, definition, SL("where"), PH_NOISY_CC);
		PHALCON_SCONCAT_SV(sql, " WHERE ", where_conditions);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("group"));
	if (eval_int) {
		PHALCON_INIT_VAR(group_fields);
		phalcon_array_fetch_string(&group_fields, definition, SL("group"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(group_clause);
		PHALCON_CONCAT_SV(group_clause, " GROUP BY ", group_fields);
		phalcon_concat_self(sql, group_clause TSRMLS_CC);
		eval_int = phalcon_array_isset_string(definition, SS("having"));
		if (eval_int) {
			PHALCON_INIT_VAR(having_conditions);
			phalcon_array_fetch_string(&having_conditions, definition, SL("having"), PH_NOISY_CC);
			PHALCON_SCONCAT_SV(sql, " HAVING ", having_conditions);
		}
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("order"));
	if (eval_int) {
		PHALCON_INIT_VAR(order_fields);
		phalcon_array_fetch_string(&order_fields, definition, SL("order"), PH_NOISY_CC);
		PHALCON_SCONCAT_SV(sql, " ORDER BY ", order_fields);
	}
	
	eval_int = phalcon_array_isset_string(definition, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit_value);
		phalcon_array_fetch_string(&limit_value, definition, SL("limit"), PH_NOISY_CC);
		if (Z_TYPE_P(limit_value) == IS_ARRAY) { 
			PHALCON_INIT_VAR(number);
			phalcon_array_fetch_string(&number, limit_value, SL("number"), PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(limit_value, SS("offset"));
			if (eval_int) {
				PHALCON_INIT_VAR(offset);
				phalcon_array_fetch_string(&offset, limit_value, SL("offset"), PH_NOISY_CC);
				PHALCON_SCONCAT_SVSV(sql, " LIMIT ", number, " OFFSET ", offset);
			} else {
				PHALCON_SCONCAT_SV(sql, " LIMIT ", number);
			}
		} else {
			PHALCON_SCONCAT_SV(sql, " LIMIT ", limit_value);
		}
	}
	
	
	RETURN_CTOR(sql);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Db_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db, Exception, db_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_DiInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, DiInterface, diinterface, phalcon_diinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_DiInterface, set);

PHALCON_DOC_METHOD(Phalcon_DiInterface, remove);

PHALCON_DOC_METHOD(Phalcon_DiInterface, attempt);

PHALCON_DOC_METHOD(Phalcon_DiInterface, get);

PHALCON_DOC_METHOD(Phalcon_DiInterface, getShared);

PHALCON_DOC_METHOD(Phalcon_DiInterface, has);

PHALCON_DOC_METHOD(Phalcon_DiInterface, wasFreshInstance);

PHALCON_DOC_METHOD(Phalcon_DiInterface, setDefault);

PHALCON_DOC_METHOD(Phalcon_DiInterface, getDefault);

PHALCON_DOC_METHOD(Phalcon_DiInterface, reset);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Text){

	PHALCON_REGISTER_CLASS(Phalcon, Text, text, phalcon_text_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Text, camelize){

	zval *str, *camelized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(camelized);
	phalcon_camelize(camelized, str TSRMLS_CC);
	
	RETURN_CCTOR(camelized);
}

PHP_METHOD(Phalcon_Text, uncamelize){

	zval *str, *uncamelized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &str) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(uncamelized);
	phalcon_uncamelize(uncamelized, str TSRMLS_CC);
	
	RETURN_CCTOR(uncamelized);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Translate){

	PHALCON_REGISTER_CLASS(Phalcon, Translate, translate, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Filter){

	PHALCON_REGISTER_CLASS(Phalcon, Filter, filter, phalcon_filter_method_entry, 0);

	zend_declare_property_null(phalcon_filter_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_filter_ce TSRMLS_CC, 1, phalcon_filterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Filter, __construct){


	phalcon_update_property_empty_array(phalcon_filter_ce, this_ptr, SL("_filters") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Filter, add){

	zval *name, *handler;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_filter_exception_ce, "Filter name must be string");
		return;
	}
	if (Z_TYPE_P(handler) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_filter_exception_ce, "Filter must be an object");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_filters"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, name, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_filters"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Filter, sanitize){

	zval *value, *filters, *new_value = NULL, *filter = NULL, *filter_value = NULL;
	zval *sanizited_value;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &value, &filters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		PHALCON_CPY_WRT(new_value, value);
		if (Z_TYPE_P(value) != IS_NULL) {
	
			if (!phalcon_valid_foreach(filters TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(filters);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_VALUE(filter);
	
				PHALCON_INIT_NVAR(filter_value);
				PHALCON_CALL_METHOD_PARAMS_2(filter_value, this_ptr, "_sanitize", new_value, filter, PH_NO_CHECK);
				PHALCON_CPY_WRT(new_value, filter_value);
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
			if(0){}
	
		}
	
	
		RETURN_CCTOR(new_value);
	}
	
	PHALCON_INIT_VAR(sanizited_value);
	PHALCON_CALL_METHOD_PARAMS_2(sanizited_value, this_ptr, "_sanitize", value, filters, PH_NO_CHECK);
	
	RETURN_CCTOR(sanizited_value);
}

PHP_METHOD(Phalcon_Filter, _sanitize){

	zval *value, *filter, *filters, *filter_object;
	zval *arguments, *filtered = NULL, *type = NULL, *quote, *empty_str;
	zval *escaped, *allow_fraction, *options, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &value, &filter) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(filters);
	phalcon_read_property(&filters, this_ptr, SL("_filters"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(filters, filter);
	if (eval_int) {
		PHALCON_INIT_VAR(filter_object);
		phalcon_array_fetch(&filter_object, filters, filter, PH_NOISY_CC);
		if (phalcon_is_instance_of(filter_object, SL("Closure") TSRMLS_CC)) {
			PHALCON_INIT_VAR(arguments);
			array_init(arguments);
			phalcon_array_append(&arguments, value, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_VAR(filtered);
			PHALCON_CALL_USER_FUNC_ARRAY(filtered, filter_object, arguments);
		} else {
			PHALCON_INIT_NVAR(filtered);
			PHALCON_CALL_METHOD_PARAMS_1(filtered, filter_object, "filter", value, PH_NO_CHECK);
		}
	
	
		RETURN_CCTOR(filtered);
	}
	
	PHALCON_INIT_NVAR(filtered);
	
	if (PHALCON_COMPARE_STRING(filter, "email")) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 517);
	
		PHALCON_INIT_VAR(quote);
		ZVAL_STRING(quote, "'", 1);
	
		PHALCON_INIT_VAR(empty_str);
		ZVAL_STRING(empty_str, "", 1);
	
		PHALCON_INIT_VAR(escaped);
		phalcon_fast_str_replace(escaped, quote, empty_str, value TSRMLS_CC);
	
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", escaped, type);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "int")) {
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 519);
	
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", value, type);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "string")) {
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 513);
	
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_2(filtered, "filter_var", value, type);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "float")) {
		PHALCON_INIT_VAR(allow_fraction);
		ZVAL_LONG(allow_fraction, 4096);
	
		PHALCON_INIT_VAR(options);
		array_init(options);
		phalcon_array_update_string(&options, SL("flags"), &allow_fraction, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 520);
	
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_3(filtered, "filter_var", value, type, options);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "alphanum")) {
		PHALCON_INIT_NVAR(filtered);
		phalcon_filter_alphanum(filtered, value);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "trim")) {
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_1(filtered, "trim", value);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "striptags")) {
		PHALCON_INIT_NVAR(filtered);
		PHALCON_CALL_FUNC_PARAMS_1(filtered, "strip_tags", value);
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "lower")) {
		if (phalcon_function_exists_ex(SS("mb_strtolower") TSRMLS_CC) == SUCCESS) {
			PHALCON_INIT_NVAR(filtered);
			PHALCON_CALL_FUNC_PARAMS_1(filtered, "mb_strtolower", value);
		} else {
			PHALCON_INIT_NVAR(filtered);
			PHALCON_CALL_FUNC_PARAMS_1(filtered, "strtolower", value);
		}
		goto ph_end_0;
	}
	
	if (PHALCON_COMPARE_STRING(filter, "upper")) {
		if (phalcon_function_exists_ex(SS("mb_strtoupper") TSRMLS_CC) == SUCCESS) {
			PHALCON_INIT_NVAR(filtered);
			PHALCON_CALL_FUNC_PARAMS_1(filtered, "mb_strtoupper", value);
		} else {
			PHALCON_INIT_NVAR(filtered);
			PHALCON_CALL_FUNC_PARAMS_1(filtered, "strtoupper", value);
		}
		goto ph_end_0;
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Sanitize filter ", filter, " is not supported");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_filter_exception_ce, exception_message);
	return;
	
	ph_end_0:
	
	RETURN_CCTOR(filtered);
}

PHP_METHOD(Phalcon_Filter, getFilters){


	RETURN_MEMBER(this_ptr, "_filters");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Response){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Response, http_response, phalcon_http_response_method_entry, 0);

	zend_declare_property_bool(phalcon_http_response_ce, SL("_sent"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_http_response_ce, SL("_content"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_response_ce TSRMLS_CC, 2, phalcon_http_responseinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Response, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Response, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Http_Response, setStatusCode){

	zval *code, *message, *headers, *header_value, *status_value;
	zval *status_header;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &code, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(header_value);
	PHALCON_CONCAT_SVSV(header_value, "HTTP/1.1 ", code, " ", message);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(headers, "setraw", header_value, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(status_value);
	PHALCON_CONCAT_VSV(status_value, code, " ", message);
	
	PHALCON_INIT_VAR(status_header);
	ZVAL_STRING(status_header, "Status", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", status_header, status_value, PH_NO_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_headers"), headers TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, getHeaders){

	zval *headers = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	if (Z_TYPE_P(headers) == IS_NULL) {
		PHALCON_INIT_NVAR(headers);
		object_init_ex(headers, phalcon_http_response_headers_ce);
		PHALCON_CALL_METHOD_NORETURN(headers, "__construct", PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_headers"), headers TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(headers);
}

PHP_METHOD(Phalcon_Http_Response, setHeader){

	zval *name, *value, *headers;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", name, value, PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, setRawHeader){

	zval *header, *headers;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(headers, "setraw", header, PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, resetHeaders){

	zval *headers;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(headers, "reset", PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, setExpires){

	zval *datetime, *headers, *date, *utc_zone, *timezone;
	zval *format, *utc_format, *utc_date, *expires_header;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &datetime) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(datetime) == IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_response_exception_ce, "datetime parameter must be an instance of DateTime");
		return;
	}
	
	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(date);
	if (phalcon_clone(date, datetime TSRMLS_CC) == FAILURE) {
		return;
	}
	
	PHALCON_INIT_VAR(utc_zone);
	ZVAL_STRING(utc_zone, "UTC", 1);
	ce0 = zend_fetch_class(SL("DateTimeZone"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(timezone);
	object_init_ex(timezone, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(timezone, "__construct", utc_zone, PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(date, "settimezone", timezone, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "D, d M Y H:i:s", 1);
	
	PHALCON_INIT_VAR(utc_format);
	PHALCON_CALL_METHOD_PARAMS_1(utc_format, date, "format", format, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(utc_date);
	PHALCON_CONCAT_VS(utc_date, utc_format, " GMT");
	
	PHALCON_INIT_VAR(expires_header);
	ZVAL_STRING(expires_header, "Expires", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setheader", expires_header, utc_date, PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, setNotModified){

	zval *code, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(code);
	ZVAL_LONG(code, 304);
	
	PHALCON_INIT_VAR(status);
	ZVAL_STRING(status, "Not modified", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setstatuscode", code, status, PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, setContentType){

	zval *content_type, *charset = NULL, *headers, *name, *header_value;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &content_type, &charset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!charset) {
		PHALCON_INIT_NVAR(charset);
	}
	
	PHALCON_INIT_VAR(headers);
	PHALCON_CALL_METHOD(headers, this_ptr, "getheaders", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "Content-Type", 1);
	if (Z_TYPE_P(charset) == IS_NULL) {
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", name, content_type, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(header_value);
		PHALCON_CONCAT_VSV(header_value, content_type, "; charset=", charset);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", name, header_value, PH_NO_CHECK);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, redirect){

	zval *location, *external_redirect = NULL, *status_code = NULL;
	zval *header = NULL, *dependency_injector, *service;
	zval *url, *status_text, *header_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &location, &external_redirect, &status_code) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!external_redirect) {
		PHALCON_INIT_NVAR(external_redirect);
		ZVAL_BOOL(external_redirect, 0);
	}
	
	if (!status_code) {
		PHALCON_INIT_NVAR(status_code);
		ZVAL_LONG(status_code, 302);
	}
	
	if (zend_is_true(external_redirect)) {
		PHALCON_CPY_WRT(header, location);
	} else {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'url' service");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "url", 1);
	
		PHALCON_INIT_VAR(url);
		PHALCON_CALL_METHOD_PARAMS_1(url, dependency_injector, "getshared", service, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(header);
		PHALCON_CALL_METHOD_PARAMS_1(header, url, "get", location, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(status_text);
	ZVAL_STRING(status_text, "Redirect", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setstatuscode", status_code, status_text, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(header_name);
	ZVAL_STRING(header_name, "Location", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "setheader", header_name, header, PH_NO_CHECK);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, setContent){

	zval *content;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_content"), content TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, appendContent){

	zval *content;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_content"), PH_NOISY_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	concat_function(r0, t0, content TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_content"), r0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, getContent){


	RETURN_MEMBER(this_ptr, "_content");
}

PHP_METHOD(Phalcon_Http_Response, sendHeaders){

	zval *headers;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	if (Z_TYPE_P(headers) != IS_NULL) {
		PHALCON_CALL_METHOD_NORETURN(headers, "send", PH_NO_CHECK);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Http_Response, send){

	zval *sent, *headers, *content;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(sent);
	phalcon_read_property(&sent, this_ptr, SL("_sent"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(sent)) {
		PHALCON_INIT_VAR(headers);
		phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
		if (Z_TYPE_P(headers) != IS_NULL) {
			PHALCON_CALL_METHOD_NORETURN(headers, "send", PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(content);
		phalcon_read_property(&content, this_ptr, SL("_content"), PH_NOISY_CC);
		zend_print_zval(content, 1);
		phalcon_update_property_bool(this_ptr, SL("_sent"), 1 TSRMLS_CC);
	
		RETURN_CTOR(this_ptr);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_response_exception_ce, "Response was already sent");
		return;
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Http_ResponseInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http, ResponseInterface, http_responseinterface, phalcon_http_responseinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setStatusCode);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, getHeaders);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setHeader);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setRawHeader);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, resetHeaders);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setExpires);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setNotModified);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setContentType);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, redirect);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, setContent);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, appendContent);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, getContent);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, sendHeaders);

PHALCON_DOC_METHOD(Phalcon_Http_ResponseInterface, send);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Http_Request_FileInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http\\Request, FileInterface, http_request_fileinterface, phalcon_http_request_fileinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Http_Request_FileInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Http_Request_FileInterface, getSize);

PHALCON_DOC_METHOD(Phalcon_Http_Request_FileInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Http_Request_FileInterface, getTempName);

PHALCON_DOC_METHOD(Phalcon_Http_Request_FileInterface, moveTo);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Request_File){

	PHALCON_REGISTER_CLASS(Phalcon\\Http\\Request, File, http_request_file, phalcon_http_request_file_method_entry, 0);

	zend_declare_property_null(phalcon_http_request_file_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_tmp"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_size"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_request_file_ce TSRMLS_CC, 1, phalcon_http_request_fileinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Request_File, __construct){

	zval *file, *name, *temp_name, *size;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &file) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(file) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "Phalcon\\Http\\Request\\File requires a valid uploaded file");
		return;
	}
	eval_int = phalcon_array_isset_string(file, SS("name"));
	if (eval_int) {
		PHALCON_INIT_VAR(name);
		phalcon_array_fetch_string(&name, file, SL("name"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(file, SS("tmp_name"));
	if (eval_int) {
		PHALCON_INIT_VAR(temp_name);
		phalcon_array_fetch_string(&temp_name, file, SL("tmp_name"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_tmp"), temp_name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(file, SS("size"));
	if (eval_int) {
		PHALCON_INIT_VAR(size);
		phalcon_array_fetch_string(&size, file, SL("size"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_size"), size TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Http_Request_File, getSize){


	RETURN_MEMBER(this_ptr, "_size");
}

PHP_METHOD(Phalcon_Http_Request_File, getName){


	RETURN_MEMBER(this_ptr, "_name");
}

PHP_METHOD(Phalcon_Http_Request_File, getTempName){


	RETURN_MEMBER(this_ptr, "_tmp");
}

PHP_METHOD(Phalcon_Http_Request_File, moveTo){

	zval *destination, *temp_file, *success;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &destination) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(temp_file);
	phalcon_read_property(&temp_file, this_ptr, SL("_tmp"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_FUNC_PARAMS_2(success, "move_uploaded_file", temp_file, destination);
	
	RETURN_CCTOR(success);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Http_Request_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Request, Exception, http_request_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Http_RequestInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http, RequestInterface, http_requestinterface, phalcon_http_requestinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, get);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getPost);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getQuery);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getServer);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, has);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, hasPost);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, hasQuery);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, hasServer);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getHeader);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getScheme);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isAjax);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isSoapRequested);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isSecureRequest);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getRawBody);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getServerAddress);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getServerName);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getHttpHost);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getClientAddress);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getMethod);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getUserAgent);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isMethod);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isPost);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isGet);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isPut);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isHead);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isDelete);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, isOptions);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, hasFiles);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getUploadedFiles);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getHTTPReferer);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getAcceptableContent);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getBestAccept);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getClientCharsets);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getBestCharset);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getLanguages);

PHALCON_DOC_METHOD(Phalcon_Http_RequestInterface, getBestLanguage);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Response_Cookies){

	PHALCON_REGISTER_CLASS(Phalcon\\Http\\Response, Cookies, http_response_cookies, phalcon_http_response_cookies_method_entry, 0);

	zend_declare_property_null(phalcon_http_response_cookies_ce, SL("_cookies"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Response_Cookies, __construct){


	phalcon_update_property_empty_array(phalcon_http_response_cookies_ce, this_ptr, SL("_cookies") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Response_Cookies, set){


	
}

PHP_METHOD(Phalcon_Http_Response_Cookies, get){


	
}

PHP_METHOD(Phalcon_Http_Response_Cookies, reset){

	zval *empty_array;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_cookies"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Response_Headers){

	PHALCON_REGISTER_CLASS(Phalcon\\Http\\Response, Headers, http_response_headers, phalcon_http_response_headers_method_entry, 0);

	zend_declare_property_null(phalcon_http_response_headers_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Response_Headers, __construct){


	phalcon_update_property_empty_array(phalcon_http_response_headers_ce, this_ptr, SL("_headers") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Response_Headers, set){

	zval *name, *value;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_headers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, name, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_headers"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Http_Response_Headers, get){

	zval *name, *headers, *header_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(headers, name);
	if (eval_int) {
		PHALCON_INIT_VAR(header_value);
		phalcon_array_fetch(&header_value, headers, name, PH_NOISY_CC);
	
		RETURN_CCTOR(header_value);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Http_Response_Headers, setRaw){

	zval *header;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_headers"), PH_NOISY_CC);
	phalcon_array_update_zval_bool(&t0, header, 0, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_headers"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Http_Response_Headers, send){

	zval *headers_was_sent, *t, *headers, *value = NULL, *header = NULL;
	zval *http_header = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(headers_was_sent);
	PHALCON_CALL_FUNC(headers_was_sent, "headers_sent");
	if (!zend_is_true(headers_was_sent)) {
		PHALCON_INIT_VAR(t);
		ZVAL_BOOL(t, 1);
	
		PHALCON_INIT_VAR(headers);
		phalcon_read_property(&headers, this_ptr, SL("_headers"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(headers TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(headers);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(header, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			if (zend_is_true(value)) {
				PHALCON_INIT_NVAR(http_header);
				PHALCON_CONCAT_VSV(http_header, header, ": ", value);
				PHALCON_CALL_FUNC_PARAMS_2_NORETURN("header", http_header, t);
			} else {
				PHALCON_CALL_FUNC_PARAMS_2_NORETURN("header", header, t);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Http_Response_Headers, reset){

	zval *empty_array;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_headers"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Http_Response_Headers, __set_state){

	zval *data, *headers, *data_headers, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(headers);
	object_init_ex(headers, phalcon_http_response_headers_ce);
	PHALCON_CALL_METHOD_NORETURN(headers, "__construct", PH_CHECK);
	eval_int = phalcon_array_isset_string(data, SS("_headers"));
	if (eval_int) {
		PHALCON_INIT_VAR(data_headers);
		phalcon_array_fetch_string(&data_headers, data, SL("_headers"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(data_headers TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(data_headers);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(headers, "set", key, value, PH_NO_CHECK);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	
	RETURN_CTOR(headers);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Http_Response_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Response, Exception, http_response_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Request){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Request, http_request, phalcon_http_request_method_entry, 0);

	zend_declare_property_null(phalcon_http_request_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_ce, SL("_filter"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_request_ce TSRMLS_CC, 2, phalcon_http_requestinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Request, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Request, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Http_Request, get){

	zval *name, *filters = NULL, *default_value = NULL, *value, *filter = NULL;
	zval *dependency_injector, *service, *sanitized_value;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &name, &filters, &default_value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_INIT_NVAR(filters);
	}
	
	if (!default_value) {
		PHALCON_INIT_NVAR(default_value);
	}
	
	phalcon_get_global(&g0, SL("_REQUEST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, g0, name, PH_NOISY_CC);
		if (Z_TYPE_P(filters) != IS_NULL) {
			PHALCON_INIT_VAR(filter);
			phalcon_read_property(&filter, this_ptr, SL("_filter"), PH_NOISY_CC);
			if (Z_TYPE_P(filter) != IS_OBJECT) {
				PHALCON_INIT_VAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
					return;
				}
	
				PHALCON_INIT_VAR(service);
				ZVAL_STRING(service, "filter", 1);
	
				PHALCON_INIT_NVAR(filter);
				PHALCON_CALL_METHOD_PARAMS_1(filter, dependency_injector, "getshared", service, PH_NO_CHECK);
				phalcon_update_property_zval(this_ptr, SL("_filter"), filter TSRMLS_CC);
			}
	
			PHALCON_INIT_VAR(sanitized_value);
			PHALCON_CALL_METHOD_PARAMS_2(sanitized_value, filter, "sanitize", value, filters, PH_NO_CHECK);
	
			RETURN_CCTOR(sanitized_value);
		} else {
	
			RETURN_CCTOR(value);
		}
	}
	
	RETURN_CCTOR(default_value);
}

PHP_METHOD(Phalcon_Http_Request, getPost){

	zval *name, *filters = NULL, *default_value = NULL, *value, *filter = NULL;
	zval *dependency_injector, *service, *sanitized_value;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &name, &filters, &default_value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_INIT_NVAR(filters);
	}
	
	if (!default_value) {
		PHALCON_INIT_NVAR(default_value);
	}
	
	phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, g0, name, PH_NOISY_CC);
		if (Z_TYPE_P(filters) != IS_NULL) {
			PHALCON_INIT_VAR(filter);
			phalcon_read_property(&filter, this_ptr, SL("_filter"), PH_NOISY_CC);
			if (Z_TYPE_P(filter) != IS_OBJECT) {
				PHALCON_INIT_VAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
					return;
				}
	
				PHALCON_INIT_VAR(service);
				ZVAL_STRING(service, "filter", 1);
	
				PHALCON_INIT_NVAR(filter);
				PHALCON_CALL_METHOD_PARAMS_1(filter, dependency_injector, "getshared", service, PH_NO_CHECK);
				phalcon_update_property_zval(this_ptr, SL("_filter"), filter TSRMLS_CC);
			}
	
			PHALCON_INIT_VAR(sanitized_value);
			PHALCON_CALL_METHOD_PARAMS_2(sanitized_value, filter, "sanitize", value, filters, PH_NO_CHECK);
	
			RETURN_CCTOR(sanitized_value);
		} else {
	
			RETURN_CCTOR(value);
		}
	}
	
	RETURN_CCTOR(default_value);
}

PHP_METHOD(Phalcon_Http_Request, getQuery){

	zval *name, *filters = NULL, *default_value = NULL, *value, *filter = NULL;
	zval *dependency_injector, *service, *sanitized_value;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &name, &filters, &default_value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_INIT_NVAR(filters);
	}
	
	if (!default_value) {
		PHALCON_INIT_NVAR(default_value);
	}
	
	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, g0, name, PH_NOISY_CC);
		if (Z_TYPE_P(filters) != IS_NULL) {
			PHALCON_INIT_VAR(filter);
			phalcon_read_property(&filter, this_ptr, SL("_filter"), PH_NOISY_CC);
			if (Z_TYPE_P(filter) != IS_OBJECT) {
				PHALCON_INIT_VAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
					return;
				}
	
				PHALCON_INIT_VAR(service);
				ZVAL_STRING(service, "filter", 1);
	
				PHALCON_INIT_NVAR(filter);
				PHALCON_CALL_METHOD_PARAMS_1(filter, dependency_injector, "getshared", service, PH_NO_CHECK);
				phalcon_update_property_zval(this_ptr, SL("_filter"), filter TSRMLS_CC);
			}
	
			PHALCON_INIT_VAR(sanitized_value);
			PHALCON_CALL_METHOD_PARAMS_2(sanitized_value, filter, "sanitize", value, filters, PH_NO_CHECK);
	
			RETURN_CCTOR(sanitized_value);
		} else {
	
			RETURN_CCTOR(value);
		}
	}
	
	RETURN_CCTOR(default_value);
}

PHP_METHOD(Phalcon_Http_Request, getServer){

	zval *name, *server_value;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	if (eval_int) {
		PHALCON_INIT_VAR(server_value);
		phalcon_array_fetch(&server_value, g0, name, PH_NOISY_CC);
	
		RETURN_CCTOR(server_value);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Http_Request, has){

	zval *name;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_REQUEST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

PHP_METHOD(Phalcon_Http_Request, hasPost){

	zval *name;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

PHP_METHOD(Phalcon_Http_Request, hasQuery){

	zval *name;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

PHP_METHOD(Phalcon_Http_Request, hasServer){

	zval *name;
	zval *g0 = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, name);
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	
	RETURN_NCTOR(r0);
}

PHP_METHOD(Phalcon_Http_Request, getHeader){

	zval *header, *server_value = NULL, *key;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, header);
	if (eval_int) {
		PHALCON_INIT_VAR(server_value);
		phalcon_array_fetch(&server_value, g0, header, PH_NOISY_CC);
	
		RETURN_CCTOR(server_value);
	} else {
		PHALCON_INIT_VAR(key);
		PHALCON_CONCAT_SV(key, "HTTP_", header);
		eval_int = phalcon_array_isset(g0, key);
		if (eval_int) {
			PHALCON_INIT_NVAR(server_value);
			phalcon_array_fetch(&server_value, g0, key, PH_NOISY_CC);
	
			RETURN_CCTOR(server_value);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

PHP_METHOD(Phalcon_Http_Request, getScheme){

	zval *https_header, *https, *scheme = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(https_header);
	ZVAL_STRING(https_header, "HTTP_HTTPS", 1);
	
	PHALCON_INIT_VAR(https);
	PHALCON_CALL_METHOD_PARAMS_1(https, this_ptr, "getserver", https_header, PH_NO_CHECK);
	if (PHALCON_COMPARE_STRING(https, "on")) {
		PHALCON_INIT_VAR(scheme);
		ZVAL_STRING(scheme, "https", 1);
	} else {
		PHALCON_INIT_NVAR(scheme);
		ZVAL_STRING(scheme, "http", 1);
	}
	
	
	RETURN_CTOR(scheme);
}

PHP_METHOD(Phalcon_Http_Request, isAjax){

	zval *requested_header, *xml_http_request;
	zval *requested_with, *is_ajax;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(requested_header);
	ZVAL_STRING(requested_header, "HTTP_X_REQUESTED_WITH", 1);
	
	PHALCON_INIT_VAR(xml_http_request);
	ZVAL_STRING(xml_http_request, "XMLHttpRequest", 1);
	
	PHALCON_INIT_VAR(requested_with);
	PHALCON_CALL_METHOD_PARAMS_1(requested_with, this_ptr, "getheader", requested_header, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_ajax);
	is_equal_function(is_ajax, requested_with, xml_http_request TSRMLS_CC);
	
	RETURN_NCTOR(is_ajax);
}

PHP_METHOD(Phalcon_Http_Request, isSoapRequested){

	zval *server = NULL, *content_type;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	eval_int = phalcon_array_isset_string(server, SS("HTTP_SOAPACTION"));
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		eval_int = phalcon_array_isset_string(server, SS("CONTENT_TYPE"));
		if (eval_int) {
			PHALCON_INIT_VAR(content_type);
			phalcon_array_fetch_string(&content_type, server, SL("CONTENT_TYPE"), PH_NOISY_CC);
			if (phalcon_memnstr_str(content_type, SL("application/soap+xml") TSRMLS_CC)) {
				PHALCON_MM_RESTORE();
				RETURN_TRUE;
			}
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Http_Request, isSecureRequest){

	zval *scheme, *https, *is_equal;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(scheme);
	PHALCON_CALL_METHOD(scheme, this_ptr, "getscheme", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(https);
	ZVAL_STRING(https, "https", 1);
	
	PHALCON_INIT_VAR(is_equal);
	is_identical_function(is_equal, https, scheme TSRMLS_CC);
	
	RETURN_NCTOR(is_equal);
}

PHP_METHOD(Phalcon_Http_Request, getRawBody){

	zval *input, *contents;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(input);
	ZVAL_STRING(input, "php://input", 1);
	
	PHALCON_INIT_VAR(contents);
	PHALCON_CALL_FUNC_PARAMS_1(contents, "file_get_contents", input);
	
	RETURN_CCTOR(contents);
}

PHP_METHOD(Phalcon_Http_Request, getServerAddress){

	zval *server = NULL, *server_addr = NULL, *localhost;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	eval_int = phalcon_array_isset_string(server, SS("SERVER_ADDR"));
	if (eval_int) {
		PHALCON_INIT_VAR(server_addr);
		phalcon_array_fetch_string(&server_addr, server, SL("SERVER_ADDR"), PH_NOISY_CC);
	
		RETURN_CCTOR(server_addr);
	}
	
	PHALCON_INIT_VAR(localhost);
	ZVAL_STRING(localhost, "localhost", 1);
	
	PHALCON_INIT_NVAR(server_addr);
	PHALCON_CALL_FUNC_PARAMS_1(server_addr, "gethostbyname", localhost);
	
	RETURN_CCTOR(server_addr);
}

PHP_METHOD(Phalcon_Http_Request, getServerName){

	zval *server = NULL, *server_name = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	eval_int = phalcon_array_isset_string(server, SS("SERVER_NAME"));
	if (eval_int) {
		PHALCON_INIT_VAR(server_name);
		phalcon_array_fetch_string(&server_name, server, SL("SERVER_NAME"), PH_NOISY_CC);
	
		RETURN_CCTOR(server_name);
	}
	
	PHALCON_INIT_NVAR(server_name);
	ZVAL_STRING(server_name, "localhost", 1);
	
	RETURN_CCTOR(server_name);
}

PHP_METHOD(Phalcon_Http_Request, getHttpHost){

	zval *scheme, *server_name, *name, *server_port;
	zval *port = NULL, *http, *is_std_http, *https, *secure_port;
	zval *is_secure_http, *is_http_normal, *name_port;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(scheme);
	PHALCON_CALL_METHOD(scheme, this_ptr, "getscheme", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(server_name);
	ZVAL_STRING(server_name, "HTTP_SERVER_NAME", 1);
	
	PHALCON_INIT_VAR(name);
	PHALCON_CALL_METHOD_PARAMS_1(name, this_ptr, "getserver", server_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(server_port);
	ZVAL_STRING(server_port, "HTTP_SERVER_PORT", 1);
	
	PHALCON_INIT_VAR(port);
	PHALCON_CALL_METHOD_PARAMS_1(port, this_ptr, "getserver", server_port, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(http);
	ZVAL_STRING(http, "http", 1);
	
	PHALCON_INIT_NVAR(port);
	ZVAL_LONG(port, 80);
	
	PHALCON_INIT_VAR(r0);
	is_equal_function(r0, scheme, http TSRMLS_CC);
	
	PHALCON_INIT_VAR(r1);
	is_equal_function(r1, port, port TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_std_http);
	phalcon_and_function(is_std_http, r0, r1);
	
	PHALCON_INIT_VAR(https);
	ZVAL_STRING(https, "https", 1);
	
	PHALCON_INIT_VAR(secure_port);
	ZVAL_LONG(secure_port, 443);
	
	PHALCON_INIT_VAR(r2);
	is_equal_function(r2, scheme, https TSRMLS_CC);
	
	PHALCON_INIT_VAR(r3);
	is_equal_function(r3, port, secure_port TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_secure_http);
	phalcon_and_function(is_secure_http, r2, r3);
	
	PHALCON_INIT_VAR(is_http_normal);
	ZVAL_BOOL(is_http_normal, zend_is_true(is_std_http) || zend_is_true(is_secure_http));
	if (PHALCON_IS_TRUE(is_http_normal)) {
	
		RETURN_CCTOR(name);
	}
	
	PHALCON_INIT_VAR(name_port);
	PHALCON_CONCAT_VSV(name_port, name, ":", port);
	
	RETURN_CTOR(name_port);
}

PHP_METHOD(Phalcon_Http_Request, getClientAddress){

	zval *trust_forwarded_header = NULL, *server = NULL, *address = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &trust_forwarded_header) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!trust_forwarded_header) {
		PHALCON_INIT_NVAR(trust_forwarded_header);
		ZVAL_BOOL(trust_forwarded_header, 0);
	}
	
	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	if (PHALCON_IS_TRUE(trust_forwarded_header)) {
		eval_int = phalcon_array_isset_string(server, SS("HTTP_X_FORWARDED_FOR"));
		if (eval_int) {
			PHALCON_INIT_VAR(address);
			phalcon_array_fetch_string(&address, server, SL("HTTP_X_FORWARDED_FOR"), PH_NOISY_CC);
	
			RETURN_CCTOR(address);
		}
	}
	
	eval_int = phalcon_array_isset_string(server, SS("REMOTE_ADDR"));
	if (eval_int) {
		PHALCON_INIT_NVAR(address);
		phalcon_array_fetch_string(&address, server, SL("REMOTE_ADDR"), PH_NOISY_CC);
	
		RETURN_CCTOR(address);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Http_Request, getMethod){

	zval *server = NULL, *request_method = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	eval_int = phalcon_array_isset_string(server, SS("REQUEST_METHOD"));
	if (eval_int) {
		PHALCON_INIT_VAR(request_method);
		phalcon_array_fetch_string(&request_method, server, SL("REQUEST_METHOD"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(request_method);
		ZVAL_STRING(request_method, "", 1);
	}
	
	
	RETURN_CCTOR(request_method);
}

PHP_METHOD(Phalcon_Http_Request, getUserAgent){

	zval *server = NULL, *user_agent = NULL;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(server, g0);
	eval_int = phalcon_array_isset_string(server, SS("HTTP_USER_AGENT"));
	if (eval_int) {
		PHALCON_INIT_VAR(user_agent);
		phalcon_array_fetch_string(&user_agent, server, SL("HTTP_USER_AGENT"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(user_agent);
		ZVAL_STRING(user_agent, "", 1);
	}
	
	
	RETURN_CCTOR(user_agent);
}

PHP_METHOD(Phalcon_Http_Request, isMethod){

	zval *methods, *http_method, *is_equals = NULL, *method = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &methods) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(http_method);
	PHALCON_CALL_METHOD(http_method, this_ptr, "getmethod", PH_NO_CHECK);
	if (Z_TYPE_P(methods) == IS_STRING) {
		PHALCON_INIT_VAR(is_equals);
		is_equal_function(is_equals, methods, http_method TSRMLS_CC);
	
		RETURN_NCTOR(is_equals);
	} else {
	
		if (!phalcon_valid_foreach(methods TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(methods);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(method);
	
			PHALCON_INIT_NVAR(is_equals);
			is_equal_function(is_equals, method, http_method TSRMLS_CC);
			if (PHALCON_IS_TRUE(is_equals)) {
				PHALCON_MM_RESTORE();
				RETURN_TRUE;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Http_Request, isPost){

	zval *post, *method, *is_post;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(post);
	ZVAL_STRING(post, "POST", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_post);
	is_equal_function(is_post, method, post TSRMLS_CC);
	
	RETURN_NCTOR(is_post);
}

PHP_METHOD(Phalcon_Http_Request, isGet){

	zval *get, *method, *is_get;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(get);
	ZVAL_STRING(get, "GET", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_get);
	is_equal_function(is_get, method, get TSRMLS_CC);
	
	RETURN_NCTOR(is_get);
}

PHP_METHOD(Phalcon_Http_Request, isPut){

	zval *put, *method, *is_put;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(put);
	ZVAL_STRING(put, "PUT", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_put);
	is_equal_function(is_put, method, put TSRMLS_CC);
	
	RETURN_NCTOR(is_put);
}

PHP_METHOD(Phalcon_Http_Request, isHead){

	zval *head, *method, *is_head;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(head);
	ZVAL_STRING(head, "HEAD", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_head);
	is_equal_function(is_head, method, head TSRMLS_CC);
	
	RETURN_NCTOR(is_head);
}

PHP_METHOD(Phalcon_Http_Request, isDelete){

	zval *delete, *method, *is_delete;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(delete);
	ZVAL_STRING(delete, "DELETE", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_delete);
	is_equal_function(is_delete, method, delete TSRMLS_CC);
	
	RETURN_NCTOR(is_delete);
}

PHP_METHOD(Phalcon_Http_Request, isOptions){

	zval *options, *method, *is_options;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	ZVAL_STRING(options, "OPTIONS", 1);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_METHOD(method, this_ptr, "getmethod", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_options);
	is_equal_function(is_options, method, options TSRMLS_CC);
	
	RETURN_NCTOR(is_options);
}

PHP_METHOD(Phalcon_Http_Request, hasFiles){

	zval *files = NULL, *number_files, *has_files;
	zval *g0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_FILES")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(files, g0);
	
	PHALCON_INIT_VAR(number_files);
	phalcon_fast_count(number_files, g0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_INIT_VAR(has_files);
	is_smaller_function(has_files, t0, number_files TSRMLS_CC);
	
	RETURN_NCTOR(has_files);
}

PHP_METHOD(Phalcon_Http_Request, getUploadedFiles){

	zval *super_files = NULL, *number_files, *files, *file = NULL;
	zval *request_file = NULL, *empty_files;
	zval *g0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_FILES")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(super_files, g0);
	
	PHALCON_INIT_VAR(number_files);
	phalcon_fast_count(number_files, super_files TSRMLS_CC);
	if (zend_is_true(number_files)) {
		PHALCON_INIT_VAR(files);
		array_init(files);
	
		if (!phalcon_valid_foreach(super_files TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(super_files);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(file);
	
			PHALCON_INIT_NVAR(request_file);
			object_init_ex(request_file, phalcon_http_request_file_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(request_file, "__construct", file, PH_CHECK);
			phalcon_array_append(&files, request_file, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
	
		RETURN_CTOR(files);
	}
	
	PHALCON_INIT_VAR(empty_files);
	array_init(empty_files);
	
	RETURN_CTOR(empty_files);
}

PHP_METHOD(Phalcon_Http_Request, getHTTPReferer){

	zval *http_referer;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset_string(g0, SS("HTTP_REFERER"));
	if (eval_int) {
		PHALCON_INIT_VAR(http_referer);
		phalcon_array_fetch_string(&http_referer, g0, SL("HTTP_REFERER"), PH_NOISY_CC);
	
		RETURN_CCTOR(http_referer);
	}
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

PHP_METHOD(Phalcon_Http_Request, _getQualityHeader){

	zval *server_index, *name, *quality_one, *returned_parts;
	zval *http_server, *pattern, *parts, *two, *dot_comma;
	zval *part = NULL, *header_parts = NULL, *quality_part = NULL, *quality = NULL;
	zval *header_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &server_index, &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(quality_one);
	ZVAL_DOUBLE(quality_one, 1);
	
	PHALCON_INIT_VAR(returned_parts);
	array_init(returned_parts);
	
	PHALCON_INIT_VAR(http_server);
	PHALCON_CALL_METHOD_PARAMS_1(http_server, this_ptr, "getserver", server_index, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "/,\\s*/", 1);
	PHALCON_INIT_VAR(parts);
	PHALCON_CALL_FUNC_PARAMS_2(parts, "preg_split", pattern, http_server);
	
	PHALCON_INIT_VAR(two);
	ZVAL_LONG(two, 2);
	
	PHALCON_INIT_VAR(dot_comma);
	ZVAL_STRING(dot_comma, ";", 1);
	
	if (!phalcon_valid_foreach(parts TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(parts);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(part);
	
		PHALCON_INIT_NVAR(header_parts);
		phalcon_fast_explode(header_parts, dot_comma, part TSRMLS_CC);
		eval_int = phalcon_array_isset_long(header_parts, 1);
		if (eval_int) {
			PHALCON_INIT_NVAR(quality_part);
			phalcon_array_fetch_long(&quality_part, header_parts, 1, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(quality);
			PHALCON_CALL_FUNC_PARAMS_2(quality, "substr", quality_part, two);
		} else {
			PHALCON_CPY_WRT(quality, quality_one);
		}
	
		PHALCON_INIT_NVAR(header_name);
		phalcon_array_fetch_long(&header_name, header_parts, 0, PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(quality_part);
		array_init(quality_part);
		phalcon_array_update_zval(&quality_part, name, &header_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&quality_part, SL("quality"), &quality, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&returned_parts, quality_part, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(returned_parts);
}

PHP_METHOD(Phalcon_Http_Request, _getBestQuality){

	zval *quality_parts, *name, *i, *quality = NULL, *selected_name = NULL;
	zval *accept = NULL, *accept_quality = NULL, *best_quality = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &quality_parts, &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(i);
	ZVAL_LONG(i, 0);
	
	PHALCON_INIT_VAR(quality);
	ZVAL_LONG(quality, 0);
	
	PHALCON_INIT_VAR(selected_name);
	ZVAL_STRING(selected_name, "", 1);
	
	if (!phalcon_valid_foreach(quality_parts TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(quality_parts);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(accept);
	
		if (phalcon_compare_strict_long(i, 0 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(quality);
			phalcon_array_fetch_string(&quality, accept, SL("quality"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(selected_name);
			phalcon_array_fetch(&selected_name, accept, name, PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(accept_quality);
			phalcon_array_fetch_string(&accept_quality, accept, SL("quality"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(best_quality);
			is_smaller_function(best_quality, quality, accept_quality TSRMLS_CC);
			if (PHALCON_IS_TRUE(best_quality)) {
				PHALCON_CPY_WRT(quality, accept_quality);
	
				PHALCON_INIT_NVAR(selected_name);
				phalcon_array_fetch(&selected_name, accept, name, PH_NOISY_CC);
			}
		}
		PHALCON_SEPARATE(i);
		increment_function(i);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CCTOR(selected_name);
}

PHP_METHOD(Phalcon_Http_Request, getAcceptableContent){

	zval *accept_header, *quality_index, *quality_header;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(accept_header);
	ZVAL_STRING(accept_header, "HTTP_ACCEPT", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "accept", 1);
	
	PHALCON_INIT_VAR(quality_header);
	PHALCON_CALL_METHOD_PARAMS_2(quality_header, this_ptr, "_getqualityheader", accept_header, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(quality_header);
}

PHP_METHOD(Phalcon_Http_Request, getBestAccept){

	zval *quality_index, *acceptable_content;
	zval *best_quality;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "accept", 1);
	
	PHALCON_INIT_VAR(acceptable_content);
	PHALCON_CALL_METHOD(acceptable_content, this_ptr, "getacceptablecontent", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(best_quality);
	PHALCON_CALL_METHOD_PARAMS_2(best_quality, this_ptr, "_getbestquality", acceptable_content, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(best_quality);
}

PHP_METHOD(Phalcon_Http_Request, getClientCharsets){

	zval *charset_header, *quality_index, *quality_charset;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(charset_header);
	ZVAL_STRING(charset_header, "HTTP_ACCEPT_CHARSET", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "charset", 1);
	
	PHALCON_INIT_VAR(quality_charset);
	PHALCON_CALL_METHOD_PARAMS_2(quality_charset, this_ptr, "_getqualityheader", charset_header, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(quality_charset);
}

PHP_METHOD(Phalcon_Http_Request, getBestCharset){

	zval *quality_index, *client_charsets, *best_charset;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "charset", 1);
	
	PHALCON_INIT_VAR(client_charsets);
	PHALCON_CALL_METHOD(client_charsets, this_ptr, "getclientcharsets", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(best_charset);
	PHALCON_CALL_METHOD_PARAMS_2(best_charset, this_ptr, "_getbestquality", client_charsets, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(best_charset);
}

PHP_METHOD(Phalcon_Http_Request, getLanguages){

	zval *language_header, *quality_index, *languages;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(language_header);
	ZVAL_STRING(language_header, "HTTP_ACCEPT_LANGUAGE", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "language", 1);
	
	PHALCON_INIT_VAR(languages);
	PHALCON_CALL_METHOD_PARAMS_2(languages, this_ptr, "_getqualityheader", language_header, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(languages);
}

PHP_METHOD(Phalcon_Http_Request, getBestLanguage){

	zval *languages, *quality_index, *best_language;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(languages);
	PHALCON_CALL_METHOD(languages, this_ptr, "getlanguages", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "language", 1);
	
	PHALCON_INIT_VAR(best_language);
	PHALCON_CALL_METHOD_PARAMS_2(best_language, this_ptr, "_getbestquality", languages, quality_index, PH_NO_CHECK);
	
	RETURN_CCTOR(best_language);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Http_Cookie){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Cookie, http_cookie, phalcon_http_cookie_method_entry, 0);

	zend_declare_property_bool(phalcon_http_cookie_ce, SL("_readed"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_expire"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_path"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_cookie_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Http_Cookie, __construct){

	zval *name, *value = NULL, *expire = NULL, *path = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zzz", &name, &value, &expire, &path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!value) {
		PHALCON_INIT_NVAR(value);
	}
	
	if (!expire) {
		PHALCON_INIT_NVAR(expire);
		ZVAL_LONG(expire, 0);
	}
	
	if (!path) {
		PHALCON_INIT_NVAR(path);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	if (Z_TYPE_P(value) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_value"), value TSRMLS_CC);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_expire"), expire TSRMLS_CC);
	if (Z_TYPE_P(path) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_path"), path TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Http_Cookie, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Cookie, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Http_Cookie, get){


	
}

PHP_METHOD(Phalcon_Http_Cookie, setValue){

	zval *value;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &value) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_value"), value TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_readed"), 1 TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Http_Cookie, setExpiration){

	zval *expire;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &expire) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_expire"), expire TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Http_Cookie, getValue){

	zval *readed;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(readed);
	phalcon_read_property(&readed, this_ptr, SL("_readed"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(readed)) {
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Config_Adapter_Ini){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Ini, config_adapter_ini, "phalcon\\config", phalcon_config_adapter_ini_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Config_Adapter_Ini, __construct){

	zval *file_path, *config, *process_sections;
	zval *ini_config, *base_path, *exception_message;
	zval *dot, *directives = NULL, *section = NULL, *value = NULL, *key = NULL, *directive_parts = NULL;
	zval *left_part = NULL, *right_part = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &file_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(config);
	array_init(config);
	
	PHALCON_INIT_VAR(process_sections);
	ZVAL_BOOL(process_sections, 1);
	
	PHALCON_INIT_VAR(ini_config);
	PHALCON_CALL_FUNC_PARAMS_2(ini_config, "parse_ini_file", file_path, process_sections);
	if (PHALCON_IS_FALSE(ini_config)) {
		PHALCON_INIT_VAR(base_path);
		PHALCON_CALL_FUNC_PARAMS_1(base_path, "basename", file_path);
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Configuration file ", base_path, " can't be loaded");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_config_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(dot);
	ZVAL_STRING(dot, ".", 1);
	
	if (!phalcon_valid_foreach(ini_config TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(ini_config);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(section, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(directives);
	
	
		if (!phalcon_valid_foreach(directives TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(directives);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah1, hp1);
			PHALCON_GET_FOREACH_VALUE(value);
	
			if (phalcon_memnstr_str(key, SL(".") TSRMLS_CC)) {
				PHALCON_INIT_NVAR(directive_parts);
				phalcon_fast_explode(directive_parts, dot, key TSRMLS_CC);
	
				PHALCON_INIT_NVAR(left_part);
				phalcon_array_fetch_long(&left_part, directive_parts, 0, PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(right_part);
				phalcon_array_fetch_long(&right_part, directive_parts, 1, PH_NOISY_CC);
				phalcon_array_update_zval_zval_zval_multi_3(&config, section, left_part, right_part, &value, 0 TSRMLS_CC);
			} else {
				phalcon_array_update_multi_2(&config, section, key, &value, 0 TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
	
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Config\\Adapter\\Ini", "__construct", config);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Config_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config, Exception, config_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Filter_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Filter, Exception, filter_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Events_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Events, ManagerInterface, events_managerinterface, phalcon_events_managerinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Events_ManagerInterface, attach);

PHALCON_DOC_METHOD(Phalcon_Events_ManagerInterface, dettachAll);

PHALCON_DOC_METHOD(Phalcon_Events_ManagerInterface, fire);

PHALCON_DOC_METHOD(Phalcon_Events_ManagerInterface, getListeners);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Events_Event){

	PHALCON_REGISTER_CLASS(Phalcon\\Events, Event, events_event, phalcon_events_event_method_entry, 0);

	zend_declare_property_null(phalcon_events_event_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_events_event_ce, SL("_source"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_events_event_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_event_ce, SL("_stopped"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_event_ce, SL("_cancelable"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Events_Event, __construct){

	zval *type, *source, *data = NULL, *cancelable = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &type, &source, &data, &cancelable) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_INIT_NVAR(data);
	}
	
	if (!cancelable) {
		PHALCON_INIT_NVAR(cancelable);
		ZVAL_BOOL(cancelable, 1);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	if (Z_TYPE_P(data) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_data"), data TSRMLS_CC);
	}
	
	if (PHALCON_IS_NOT_TRUE(cancelable)) {
		phalcon_update_property_zval(this_ptr, SL("_cancelable"), cancelable TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Events_Event, setType){

	zval *event_type;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_type) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_type"), event_type TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Events_Event, getType){


	RETURN_MEMBER(this_ptr, "_type");
}

PHP_METHOD(Phalcon_Events_Event, getSource){


	RETURN_MEMBER(this_ptr, "_source");
}

PHP_METHOD(Phalcon_Events_Event, setData){

	zval *data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_data"), data TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Events_Event, getData){


	RETURN_MEMBER(this_ptr, "_data");
}

PHP_METHOD(Phalcon_Events_Event, setCancelable){

	zval *cancelable;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &cancelable) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_cancelable"), cancelable TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Events_Event, getCancelable){


	RETURN_MEMBER(this_ptr, "_cancelable");
}

PHP_METHOD(Phalcon_Events_Event, stop){

	zval *cancelable;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(cancelable);
	phalcon_read_property(&cancelable, this_ptr, SL("_cancelable"), PH_NOISY_CC);
	if (zend_is_true(cancelable)) {
		phalcon_update_property_bool(this_ptr, SL("_stopped"), 1 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Trying to cancel a non-cancelable event");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Events_Event, isStopped){


	RETURN_MEMBER(this_ptr, "_stopped");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Events_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Events, Manager, events_manager, phalcon_events_manager_method_entry, 0);

	zend_declare_property_null(phalcon_events_manager_ce, SL("_events"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_events_manager_ce TSRMLS_CC, 1, phalcon_events_managerinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Events_Manager, attach){

	zval *event_type, *handler, *events = NULL, *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &event_type, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(event_type) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event type must be a string");
		return;
	}
	if (Z_TYPE_P(handler) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event handler must be an Object");
		return;
	}
	
	PHALCON_INIT_VAR(events);
	phalcon_read_property(&events, this_ptr, SL("_events"), PH_NOISY_CC);
	if (Z_TYPE_P(events) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(events);
		array_init(events);
	}
	
	eval_int = phalcon_array_isset(events, event_type);
	if (!eval_int) {
		PHALCON_INIT_VAR(empty_array);
		array_init(empty_array);
		phalcon_array_update_zval(&events, event_type, &empty_array, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	phalcon_array_update_append_multi_2(&events, event_type, handler, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_events"), events TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Events_Manager, dettachAll){

	zval *type = NULL, *events = NULL, *null_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!type) {
		PHALCON_INIT_NVAR(type);
	}
	
	PHALCON_INIT_VAR(events);
	phalcon_read_property(&events, this_ptr, SL("_events"), PH_NOISY_CC);
	if (Z_TYPE_P(type) == IS_NULL) {
		PHALCON_INIT_NVAR(events);
	} else {
		eval_int = phalcon_array_isset(events, type);
		if (eval_int) {
			PHALCON_INIT_VAR(null_value);
			phalcon_array_update_zval(&events, type, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	phalcon_update_property_zval(this_ptr, SL("_events"), events TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Events_Manager, fire){

	zval *event_type, *source, *data = NULL, *cancelable = NULL, *events;
	zval *exception_message, *colon, *event_parts;
	zval *type, *event_name, *event = NULL, *status = NULL, *fire_events = NULL;
	zval *handler = NULL, *arguments = NULL, *is_stopped = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &event_type, &source, &data, &cancelable) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_INIT_NVAR(data);
	}
	
	if (!cancelable) {
		PHALCON_INIT_NVAR(cancelable);
		ZVAL_BOOL(cancelable, 1);
	}
	
	if (Z_TYPE_P(event_type) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event type must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(events);
	phalcon_read_property(&events, this_ptr, SL("_events"), PH_NOISY_CC);
	if (Z_TYPE_P(events) != IS_ARRAY) { 
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	
	if (!phalcon_memnstr_str(event_type, SL(":") TSRMLS_CC)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "Invalid event type ", event_type);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_events_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(colon);
	ZVAL_STRING(colon, ":", 1);
	
	PHALCON_INIT_VAR(event_parts);
	phalcon_fast_explode(event_parts, colon, event_type TSRMLS_CC);
	
	PHALCON_INIT_VAR(type);
	phalcon_array_fetch_long(&type, event_parts, 0, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(event_name);
	phalcon_array_fetch_long(&event_name, event_parts, 1, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(event);
	
	PHALCON_INIT_VAR(status);
	eval_int = phalcon_array_isset(events, type);
	if (eval_int) {
		PHALCON_INIT_VAR(fire_events);
		phalcon_array_fetch(&fire_events, events, type, PH_NOISY_CC);
		if (Z_TYPE_P(fire_events) == IS_ARRAY) { 
	
			if (!phalcon_valid_foreach(fire_events TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(fire_events);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_VALUE(handler);
	
				if (Z_TYPE_P(handler) == IS_OBJECT) {
					if (phalcon_is_instance_of(handler, SL("Closure") TSRMLS_CC)) {
						if (Z_TYPE_P(event) == IS_NULL) {
							PHALCON_INIT_NVAR(event);
							object_init_ex(event, phalcon_events_event_ce);
							PHALCON_CALL_METHOD_PARAMS_4_NORETURN(event, "__construct", event_name, source, data, cancelable, PH_CHECK);
	
							PHALCON_INIT_NVAR(arguments);
							array_init(arguments);
							phalcon_array_append(&arguments, event, PH_SEPARATE TSRMLS_CC);
							phalcon_array_append(&arguments, source, PH_SEPARATE TSRMLS_CC);
							phalcon_array_append(&arguments, data, PH_SEPARATE TSRMLS_CC);
						}
	
						PHALCON_INIT_NVAR(status);
						PHALCON_CALL_USER_FUNC_ARRAY(status, handler, arguments);
						if (zend_is_true(cancelable)) {
							PHALCON_INIT_NVAR(is_stopped);
							PHALCON_CALL_METHOD(is_stopped, event, "isstopped", PH_NO_CHECK);
							if (zend_is_true(is_stopped)) {
								goto ph_cycle_end_0;
							}
						}
					} else {
						if (phalcon_method_exists(handler, event_name TSRMLS_CC) == SUCCESS) {
							if (Z_TYPE_P(event) == IS_NULL) {
								PHALCON_INIT_NVAR(event);
								object_init_ex(event, phalcon_events_event_ce);
								PHALCON_CALL_METHOD_PARAMS_4_NORETURN(event, "__construct", event_name, source, data, cancelable, PH_CHECK);
							}
	
							PHALCON_INIT_NVAR(status);
							PHALCON_CALL_METHOD_PARAMS_3(status, handler, Z_STRVAL_P(event_name), event, source, data, PH_NO_CHECK);
							if (zend_is_true(cancelable)) {
								PHALCON_INIT_NVAR(is_stopped);
								PHALCON_CALL_METHOD(is_stopped, event, "isstopped", PH_NO_CHECK);
								if (zend_is_true(is_stopped)) {
									goto ph_cycle_end_0;
								}
							}
						}
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
			if(0){}
	
		}
	}
	
	eval_int = phalcon_array_isset(events, event_type);
	if (eval_int) {
		PHALCON_INIT_NVAR(fire_events);
		phalcon_array_fetch(&fire_events, events, event_type, PH_NOISY_CC);
		if (Z_TYPE_P(fire_events) == IS_ARRAY) { 
	
			if (!phalcon_valid_foreach(fire_events TSRMLS_CC)) {
				return;
			}
	
			ah1 = Z_ARRVAL_P(fire_events);
			zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
			ph_cycle_start_1:
	
				if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
					goto ph_cycle_end_1;
				}
	
				PHALCON_GET_FOREACH_VALUE(handler);
	
				if (Z_TYPE_P(handler) == IS_OBJECT) {
					if (phalcon_is_instance_of(handler, SL("Closure") TSRMLS_CC)) {
						if (Z_TYPE_P(event) == IS_NULL) {
							PHALCON_INIT_NVAR(event);
							object_init_ex(event, phalcon_events_event_ce);
							PHALCON_CALL_METHOD_PARAMS_4_NORETURN(event, "__construct", event_name, source, data, cancelable, PH_CHECK);
	
							PHALCON_INIT_NVAR(arguments);
							array_init(arguments);
							phalcon_array_append(&arguments, event, PH_SEPARATE TSRMLS_CC);
							phalcon_array_append(&arguments, source, PH_SEPARATE TSRMLS_CC);
							phalcon_array_append(&arguments, data, PH_SEPARATE TSRMLS_CC);
						}
	
						PHALCON_INIT_NVAR(status);
						PHALCON_CALL_USER_FUNC_ARRAY(status, handler, arguments);
						if (zend_is_true(cancelable)) {
							PHALCON_INIT_NVAR(is_stopped);
							PHALCON_CALL_METHOD(is_stopped, event, "isstopped", PH_NO_CHECK);
							if (zend_is_true(is_stopped)) {
								goto ph_cycle_end_1;
							}
						}
					} else {
						if (phalcon_method_exists(handler, event_name TSRMLS_CC) == SUCCESS) {
							if (Z_TYPE_P(event) == IS_NULL) {
								PHALCON_INIT_NVAR(event);
								object_init_ex(event, phalcon_events_event_ce);
								PHALCON_CALL_METHOD_PARAMS_4_NORETURN(event, "__construct", event_name, source, data, cancelable, PH_CHECK);
							}
	
							PHALCON_INIT_NVAR(status);
							PHALCON_CALL_METHOD_PARAMS_3(status, handler, Z_STRVAL_P(event_name), event, source, data, PH_NO_CHECK);
							if (zend_is_true(cancelable)) {
								PHALCON_INIT_NVAR(is_stopped);
								PHALCON_CALL_METHOD(is_stopped, event, "isstopped", PH_NO_CHECK);
								if (zend_is_true(is_stopped)) {
									goto ph_cycle_end_1;
								}
							}
						}
					}
				}
	
				zend_hash_move_forward_ex(ah1, &hp1);
				goto ph_cycle_start_1;
	
			ph_cycle_end_1:
			if(0){}
	
		}
	}
	
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Events_Manager, hasListeners){

	zval *type, *events;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(events);
	phalcon_read_property(&events, this_ptr, SL("_events"), PH_NOISY_CC);
	if (Z_TYPE_P(events) == IS_ARRAY) { 
		eval_int = phalcon_array_isset(events, type);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Events_Manager, getListeners){

	zval *type, *events, *fire_events;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(events);
	phalcon_read_property(&events, this_ptr, SL("_events"), PH_NOISY_CC);
	if (Z_TYPE_P(events) == IS_ARRAY) { 
		eval_int = phalcon_array_isset(events, type);
		if (eval_int) {
			PHALCON_INIT_VAR(fire_events);
			phalcon_array_fetch(&fire_events, events, type, PH_NOISY_CC);
	
			RETURN_CCTOR(fire_events);
		}
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Events_EventsAwareInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Events, EventsAwareInterface, events_eventsawareinterface, phalcon_events_eventsawareinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Events_EventsAwareInterface, setEventsManager);

PHALCON_DOC_METHOD(Phalcon_Events_EventsAwareInterface, getEventsManager);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Events_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Events, Exception, events_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Session){

	PHALCON_REGISTER_CLASS(Phalcon, Session, session, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Config){

	PHALCON_REGISTER_CLASS(Phalcon, Config, config, phalcon_config_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Config, __construct){

	zval *array_config = NULL, *value = NULL, *key = NULL, *config_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &array_config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!array_config) {
		PHALCON_INIT_NVAR(array_config);
	}
	
	if (Z_TYPE_P(array_config) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(array_config TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(array_config);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			if (Z_TYPE_P(value) == IS_ARRAY) { 
				eval_int = phalcon_array_isset_long(value, 0);
				if (!eval_int) {
					PHALCON_INIT_NVAR(config_value);
					object_init_ex(config_value, phalcon_config_ce);
					PHALCON_CALL_METHOD_PARAMS_1_NORETURN(config_value, "__construct", value, PH_CHECK);
					phalcon_update_property_zval_zval(this_ptr, key, config_value TSRMLS_CC);
				} else {
					phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
				}
			} else {
				phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_config_exception_ce, "The configuration must be an Array");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Config, __set_state){

	zval *data, *config;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(config);
	object_init_ex(config, phalcon_config_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(config, "__construct", data, PH_CHECK);
	
	RETURN_CTOR(config);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Escaper){

	PHALCON_REGISTER_CLASS(Phalcon, Escaper, escaper, phalcon_escaper_method_entry, 0);

	zend_declare_property_string(phalcon_escaper_ce, SL("_encoding"), "utf-8", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_escaper_ce, SL("_htmlEscapeMap"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_escaper_ce, SL("_htmlQuoteType"), 3, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_escaper_ce TSRMLS_CC, 1, phalcon_escaperinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Escaper, setEnconding){

	zval *encoding;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &encoding) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(encoding) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_escaper_exception_ce, "The character set must be string");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_encoding"), encoding TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Escaper, getEncoding){


	RETURN_MEMBER(this_ptr, "_encoding");
}

PHP_METHOD(Phalcon_Escaper, setHtmlQuoteType){

	zval *quote_type;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &quote_type) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_htmlQuoteType"), quote_type TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Escaper, escapeHtml){

	zval *text, *html_quote_type, *encoding, *escaped;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &text) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(text) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_escaper_exception_ce, "The text must be string");
		return;
	}
	
	PHALCON_INIT_VAR(html_quote_type);
	phalcon_read_property(&html_quote_type, this_ptr, SL("_htmlQuoteType"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(encoding);
	phalcon_read_property(&encoding, this_ptr, SL("_encoding"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(escaped);
	PHALCON_CALL_FUNC_PARAMS_3(escaped, "htmlspecialchars", text, html_quote_type, encoding);
	
	RETURN_CCTOR(escaped);
}

PHP_METHOD(Phalcon_Escaper, escapeHtmlAttr){

	zval *text, *html_map = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &text) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(html_map);
	phalcon_read_property(&html_map, this_ptr, SL("_htmlEscapeMap"), PH_NOISY_CC);
	if (Z_TYPE_P(html_map) == IS_NULL) {
		PHALCON_INIT_NVAR(html_map);
		array_init(html_map);
		add_index_stringl(html_map, 34, SL("quot"), 1);
		add_index_stringl(html_map, 38, SL("amp"), 1);
		add_index_stringl(html_map, 60, SL("lt"), 1);
		add_index_stringl(html_map, 62, SL("gt"), 1);
		phalcon_update_property_zval(this_ptr, SL("_htmlEscapeMap"), html_map TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Escaper, cssSanitize){

	zval *matches, *chr, *length, *ord = NULL, *format, *css_sanitize;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &matches) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(matches) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_long(matches, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(chr);
			phalcon_array_fetch_long(&chr, matches, 0, PH_NOISY_CC);
	
			PHALCON_INIT_VAR(length);
			phalcon_fast_strlen(length, chr);
			if (phalcon_compare_strict_long(length, 1 TSRMLS_CC)) {
				PHALCON_INIT_VAR(ord);
				PHALCON_CALL_FUNC_PARAMS_1(ord, "ord", chr);
			} else {
				PHALCON_INIT_NVAR(ord);
				PHALCON_CALL_FUNC_PARAMS_1(ord, "hexdec", chr);
			}
	
			PHALCON_INIT_VAR(format);
			ZVAL_STRING(format, "\\%X ", 1);
	
			PHALCON_INIT_VAR(css_sanitize);
			PHALCON_CALL_FUNC_PARAMS_2(css_sanitize, "sprintf", format, ord);
	
			RETURN_CCTOR(css_sanitize);
		}
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Escaper, escapeCss){

	zval *css, *pattern, *callback, *sanitized;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &css) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(css) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_escaper_exception_ce, "The CSS must be string");
		return;
	}
	if (zend_is_true(css)) {
		PHALCON_INIT_VAR(pattern);
		ZVAL_STRING(pattern, "/[^a-z0-9]/iSu", 1);
	
		PHALCON_INIT_VAR(callback);
		array_init(callback);
		phalcon_array_append(&callback, this_ptr, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(callback, SL("cssSanitize"), 1);
	
		PHALCON_INIT_VAR(sanitized);
		PHALCON_CALL_FUNC_PARAMS_3(sanitized, "preg_replace_callback", pattern, callback, css);
	
		RETURN_CCTOR(sanitized);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Escaper, escapeUrl){

	zval *url, *escaped;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &url) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(escaped);
	PHALCON_CALL_FUNC_PARAMS_1(escaped, "rawurlencode", url);
	
	RETURN_CCTOR(escaped);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_DispatcherInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, DispatcherInterface, dispatcherinterface, phalcon_dispatcherinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setActionSuffix);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setDefaultNamespace);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setDefaultAction);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setActionName);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, getActionName);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setParams);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, getParams);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, setParam);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, getParam);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, isFinished);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, getReturnedValue);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, dispatch);

PHALCON_DOC_METHOD(Phalcon_DispatcherInterface, forward);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Flash){

	PHALCON_REGISTER_CLASS(Phalcon, Flash, flash, phalcon_flash_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_flash_ce, SL("_cssClasses"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_flash_ce, SL("_implicitFlush"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_flash_ce, SL("_automaticHtml"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Flash, __construct){

	zval *css_classes = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &css_classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!css_classes) {
		PHALCON_INIT_NVAR(css_classes);
	} else {
		PHALCON_SEPARATE_PARAM(css_classes);
	}
	
	if (Z_TYPE_P(css_classes) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(css_classes);
		array_init(css_classes);
		add_assoc_stringl_ex(css_classes, SS("error"), SL("errorMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("notice"), SL("noticeMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("success"), SL("successMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("warning"), SL("warningMessage"), 1);
	}
	phalcon_update_property_zval(this_ptr, SL("_cssClasses"), css_classes TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Flash, setImplicitFlush){

	zval *implicit_flush;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &implicit_flush) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_implicitFlush"), implicit_flush TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Flash, setAutomaticHtml){

	zval *automatic_html;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &automatic_html) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_automaticHtml"), automatic_html TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Flash, setCssClasses){

	zval *css_classes;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &css_classes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(css_classes) == IS_ARRAY) { 
		phalcon_update_property_zval(this_ptr, SL("_cssClasses"), css_classes TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_flash_exception_ce, "CSS classes must be an Array");
		return;
	}
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Flash, error){

	zval *message, *type, *flash_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "error", 1);
	
	PHALCON_INIT_VAR(flash_message);
	PHALCON_CALL_METHOD_PARAMS_2(flash_message, this_ptr, "message", type, message, PH_NO_CHECK);
	
	RETURN_CCTOR(flash_message);
}

PHP_METHOD(Phalcon_Flash, notice){

	zval *message, *type, *flash_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "notice", 1);
	
	PHALCON_INIT_VAR(flash_message);
	PHALCON_CALL_METHOD_PARAMS_2(flash_message, this_ptr, "message", type, message, PH_NO_CHECK);
	
	RETURN_CCTOR(flash_message);
}

PHP_METHOD(Phalcon_Flash, success){

	zval *message, *type, *flash_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "success", 1);
	
	PHALCON_INIT_VAR(flash_message);
	PHALCON_CALL_METHOD_PARAMS_2(flash_message, this_ptr, "message", type, message, PH_NO_CHECK);
	
	RETURN_CCTOR(flash_message);
}

PHP_METHOD(Phalcon_Flash, warning){

	zval *message, *type, *flash_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "warning", 1);
	
	PHALCON_INIT_VAR(flash_message);
	PHALCON_CALL_METHOD_PARAMS_2(flash_message, this_ptr, "message", type, message, PH_NO_CHECK);
	
	RETURN_CCTOR(flash_message);
}

PHP_METHOD(Phalcon_Flash, outputMessage){

	zval *type, *message, *automatic_html, *classes;
	zval *type_classes, *joined_classes, *css_classes = NULL;
	zval *eol, *implicit_flush, *content, *msg = NULL, *html_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &type, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(automatic_html);
	phalcon_read_property(&automatic_html, this_ptr, SL("_automaticHtml"), PH_NOISY_CC);
	if (PHALCON_IS_TRUE(automatic_html)) {
		PHALCON_INIT_VAR(classes);
		phalcon_read_property(&classes, this_ptr, SL("_cssClasses"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(classes, type);
		if (eval_int) {
			PHALCON_INIT_VAR(type_classes);
			phalcon_array_fetch(&type_classes, classes, type, PH_NOISY_CC);
			if (Z_TYPE_P(type_classes) == IS_ARRAY) { 
				PHALCON_INIT_VAR(joined_classes);
				phalcon_fast_join_str(joined_classes, SL(" "), type_classes TSRMLS_CC);
	
				PHALCON_INIT_VAR(css_classes);
				PHALCON_CONCAT_SVS(css_classes, " class=\"", joined_classes, "\"");
			} else {
				PHALCON_INIT_NVAR(css_classes);
				PHALCON_CONCAT_SVS(css_classes, " class=\"", type_classes, "\"");
			}
		} else {
			PHALCON_INIT_NVAR(css_classes);
			ZVAL_STRING(css_classes, "", 1);
		}
	
		PHALCON_INIT_VAR(eol);
		zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(implicit_flush);
	phalcon_read_property(&implicit_flush, this_ptr, SL("_implicitFlush"), PH_NOISY_CC);
	if (Z_TYPE_P(message) == IS_ARRAY) { 
		if (PHALCON_IS_FALSE(implicit_flush)) {
			PHALCON_INIT_VAR(content);
			ZVAL_STRING(content, "", 1);
		}
	
		if (!phalcon_valid_foreach(message TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(message);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(msg);
	
			if (PHALCON_IS_TRUE(automatic_html)) {
				PHALCON_INIT_NVAR(html_message);
				PHALCON_CONCAT_SVSVSV(html_message, "<div", css_classes, ">", msg, "</div>", eol);
			} else {
				PHALCON_CPY_WRT(html_message, msg);
			}
			if (PHALCON_IS_TRUE(implicit_flush)) {
				zend_print_zval(html_message, 1);
			} else {
				phalcon_concat_self(content, html_message TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		if (PHALCON_IS_FALSE(implicit_flush)) {
	
			RETURN_CTOR(content);
		}
	} else {
		if (PHALCON_IS_TRUE(automatic_html)) {
			PHALCON_INIT_NVAR(html_message);
			PHALCON_CONCAT_SVSVSV(html_message, "<div", css_classes, ">", message, "</div>", eol);
		} else {
			PHALCON_CPY_WRT(html_message, message);
		}
		if (PHALCON_IS_TRUE(implicit_flush)) {
			zend_print_zval(html_message, 1);
		} else {
	
			RETURN_CCTOR(html_message);
		}
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Tag){

	PHALCON_REGISTER_CLASS(Phalcon, Tag, tag, phalcon_tag_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_tag_ce, SL("_displayValues"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_string(phalcon_tag_ce, SL("_documentTitle"), "", ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_string(phalcon_tag_ce, SL("_documentType"), "", ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_urlService"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_dispatcherService"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML32"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_STRICT"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_TRANSITIONAL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_FRAMESET"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML5"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_STRICT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_TRANSITIONAL"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_FRAMESET"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML11"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML20"), 10 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML5"), 11 TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Tag, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Parameter dependencyInjector must be an Object");
		return;
	}
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, getDI){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(dependency_injector);
	phalcon_read_static_property(&dependency_injector, SL("phalcon\\tag"), SL("_dependencyInjector") TSRMLS_CC);
	
	RETURN_CCTOR(dependency_injector);
}

PHP_METHOD(Phalcon_Tag, getUrlService){

	zval *url = NULL, *dependency_injector = NULL, *service;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(url);
	phalcon_read_static_property(&url, SL("phalcon\\tag"), SL("_urlService") TSRMLS_CC);
	if (Z_TYPE_P(url) == IS_NULL) {
		PHALCON_OBSERVE_VAR(dependency_injector);
		phalcon_read_static_property(&dependency_injector, SL("phalcon\\tag"), SL("_dependencyInjector") TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_INIT_NVAR(dependency_injector);
			PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
		}
	
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "A dependency injector container is required to obtain the \"url\" service");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "url", 1);
	
		PHALCON_INIT_NVAR(url);
		PHALCON_CALL_METHOD_PARAMS_1(url, dependency_injector, "getshared", service, PH_NO_CHECK);
		phalcon_update_static_property(SL("phalcon\\tag"), SL("_urlService"), url TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(url);
}

PHP_METHOD(Phalcon_Tag, getDispatcherService){

	zval *dispatcher = NULL, *dependency_injector = NULL, *service;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(dispatcher);
	phalcon_read_static_property(&dispatcher, SL("phalcon\\tag"), SL("_dispatcherService") TSRMLS_CC);
	if (Z_TYPE_P(dispatcher) == IS_NULL) {
		PHALCON_OBSERVE_VAR(dependency_injector);
		phalcon_read_static_property(&dependency_injector, SL("phalcon\\tag"), SL("_dependencyInjector") TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_INIT_NVAR(dependency_injector);
			PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
		}
	
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "A dependency injector container is required to obtain the \"dispatcher\" service");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "dispatcher", 1);
	
		PHALCON_INIT_NVAR(dispatcher);
		PHALCON_CALL_METHOD_PARAMS_1(dispatcher, dependency_injector, "getshared", service, PH_NO_CHECK);
		phalcon_update_static_property(SL("phalcon\\tag"), SL("_dispatcherService"), dispatcher TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(dispatcher);
}

PHP_METHOD(Phalcon_Tag, setDefault){

	zval *id, *value, *is_scalar;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &id, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (zend_is_true(value)) {
		PHALCON_INIT_VAR(is_scalar);
		PHALCON_CALL_FUNC_PARAMS_1(is_scalar, "is_scalar", value);
		if (PHALCON_IS_FALSE(is_scalar)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Only scalar values can be assigned to UI components");
			return;
		}
	}
	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_displayValues") TSRMLS_CC);
	if (Z_TYPE_P(t0) != IS_ARRAY) {
		convert_to_array(t0);
	}
	phalcon_array_update_zval(&t0, id, &value, PH_COPY TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_displayValues"), t0 TSRMLS_CC);
	
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, displayTo){

	zval *id, *value, *default_value;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &id, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(default_value);
	PHALCON_CALL_SELF_PARAMS_2(default_value, this_ptr, "setdefault", id, value);
	
	RETURN_CCTOR(default_value);
}

PHP_METHOD(Phalcon_Tag, getValue){

	zval *name, *display_values = NULL, *default_value;
	zval *post = NULL, *post_name;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(display_values);
	phalcon_read_static_property(&display_values, SL("phalcon\\tag"), SL("_displayValues") TSRMLS_CC);
	eval_int = phalcon_array_isset(display_values, name);
	if (eval_int) {
		PHALCON_INIT_VAR(default_value);
		phalcon_array_fetch(&default_value, display_values, name, PH_NOISY_CC);
	
		RETURN_CCTOR(default_value);
	} else {
		phalcon_get_global(&g0, SL("_POST")+1 TSRMLS_CC);
		PHALCON_CPY_WRT(post, g0);
		eval_int = phalcon_array_isset(post, name);
		if (eval_int) {
			PHALCON_INIT_VAR(post_name);
			phalcon_array_fetch(&post_name, post, name, PH_NOISY_CC);
	
			RETURN_CCTOR(post_name);
		}
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, resetInput){

	zval *empty_array = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);

	phalcon_update_static_property(SL("phalcon\\tag"), SL("_displayValues"), empty_array TSRMLS_CC);

	phalcon_set_symbol_str(SS("_POST"), empty_array TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, linkTo){

	zval *parameters, *text = NULL, *params = NULL, *action = NULL, *url, *internal_url;
	zval *code, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &text) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!text) {
		PHALCON_INIT_NVAR(text);
	} else {
		PHALCON_SEPARATE_PARAM(text);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, text, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(action);
	ZVAL_STRING(action, "", 1);
	eval_int = phalcon_array_isset_long(params, 0);
	if (eval_int) {
		PHALCON_INIT_NVAR(action);
		phalcon_array_fetch_long(&action, params, 0, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("action"));
		if (eval_int) {
			PHALCON_INIT_NVAR(action);
			phalcon_array_fetch_string(&action, params, SL("action"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SS("action"));
		}
	}
	
	PHALCON_INIT_NVAR(text);
	ZVAL_STRING(text, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_NVAR(text);
		phalcon_array_fetch_long(&text, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("text"));
		if (eval_int) {
			PHALCON_INIT_NVAR(text);
			phalcon_array_fetch_string(&text, params, SL("text"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SS("text"));
		}
	}
	
	PHALCON_INIT_VAR(url);
	PHALCON_CALL_SELF(url, this_ptr, "geturlservice");
	
	PHALCON_INIT_VAR(internal_url);
	PHALCON_CALL_METHOD_PARAMS_1(internal_url, url, "get", action, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<a href=\"", internal_url, "\"");
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", value, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_SCONCAT_SVS(code, ">", text, "</a>");
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, _inputField){

	zval *type, *parameters, *as_value = NULL, *params = NULL, *id = NULL, *name;
	zval *value = NULL, *code, *key = NULL, *doctype;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &type, &parameters, &as_value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!as_value) {
		PHALCON_INIT_NVAR(as_value);
		ZVAL_BOOL(as_value, 0);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	if (PHALCON_IS_FALSE(as_value)) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (!eval_int) {
			PHALCON_INIT_VAR(id);
			phalcon_array_fetch_string(&id, params, SL("id"), PH_NOISY_CC);
			phalcon_array_update_long(&params, 0, &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(id);
		phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(params, SS("name"));
		if (!eval_int) {
			phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(name);
			phalcon_array_fetch_string(&name, params, SL("name"), PH_NOISY_CC);
			if (!zend_is_true(name)) {
				phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
		}
	
		eval_int = phalcon_array_isset_string(params, SS("id"));
		if (!eval_int) {
			phalcon_array_update_string(&params, SL("id"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		eval_int = phalcon_array_isset_string(params, SS("value"));
		if (!eval_int) {
			PHALCON_INIT_VAR(value);
			PHALCON_CALL_SELF_PARAMS_1(value, this_ptr, "getvalue", id);
			phalcon_array_update_string(&params, SL("value"), &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_NVAR(value);
			phalcon_array_fetch_long(&value, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("value"), &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<input type=\"", type, "\"");
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", value, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(doctype);
	PHALCON_CALL_SELF(doctype, this_ptr, "getdoctype");
	if (phalcon_memnstr_str(doctype, SL("XHTML") TSRMLS_CC)) {
		phalcon_concat_self_str(code, SL(" />") TSRMLS_CC);
	} else {
		phalcon_concat_self_str(code, SL(">") TSRMLS_CC);
	}
	
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, textField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "text", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, passwordField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "password", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, hiddenField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "hidden", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, fileField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "file", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, checkField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "checkbox", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, radioField){

	zval *parameters, *name, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "radio", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_2(html, this_ptr, "_inputfield", name, parameters);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, submitButton){

	zval *parameters, *name, *as_value, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "submit", 1);
	
	PHALCON_INIT_VAR(as_value);
	ZVAL_BOOL(as_value, 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_SELF_PARAMS_3(html, this_ptr, "_inputfield", name, parameters, as_value);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, selectStatic){

	zval *parameters, *data = NULL, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_INIT_NVAR(data);
	}
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_STATIC_PARAMS_2(html, "phalcon\\tag\\select", "selectfield", parameters, data);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, select){

	zval *parameters, *data = NULL, *html;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_INIT_NVAR(data);
	}
	
	PHALCON_INIT_VAR(html);
	PHALCON_CALL_STATIC_PARAMS_2(html, "phalcon\\tag\\select", "selectfield", parameters, data);
	
	RETURN_CCTOR(html);
}

PHP_METHOD(Phalcon_Tag, textArea){

	zval *parameters, *params = NULL, *id = NULL, *name, *content = NULL, *code;
	zval *avalue = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		eval_int = phalcon_array_isset_string(params, SS("id"));
		if (eval_int) {
			PHALCON_INIT_VAR(id);
			phalcon_array_fetch_string(&id, params, SL("id"), PH_NOISY_CC);
			phalcon_array_update_long(&params, 0, &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_NVAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("name"));
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(name);
		phalcon_array_fetch_string(&name, params, SL("name"), PH_NOISY_CC);
		if (!zend_is_true(name)) {
			phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("id"));
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("id"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("value"));
	if (eval_int) {
		PHALCON_INIT_VAR(content);
		phalcon_array_fetch_string(&content, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SS("value"));
	} else {
		PHALCON_INIT_NVAR(content);
		PHALCON_CALL_SELF_PARAMS_1(content, this_ptr, "getvalue", id);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<textarea", 1);
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(avalue);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", avalue, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_SCONCAT_SVS(code, ">", content, "</textarea>");
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, form){

	zval *parameters = NULL, *params = NULL, *dispatcher, *dispatch_params;
	zval *action_parameters, *params_action = NULL, *controller_name;
	zval *action_name, *url, *action = NULL, *form_action;
	zval *code, *avalue = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	} else {
		PHALCON_SEPARATE_PARAM(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(dispatcher);
	PHALCON_CALL_SELF(dispatcher, this_ptr, "getdispatcherservice");
	
	PHALCON_INIT_VAR(dispatch_params);
	PHALCON_CALL_METHOD(dispatch_params, dispatcher, "getparams", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(action_parameters);
	phalcon_fast_join_str(action_parameters, SL("/"), dispatch_params TSRMLS_CC);
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		eval_int = phalcon_array_isset_string(params, SS("action"));
		if (eval_int) {
			PHALCON_INIT_VAR(params_action);
			phalcon_array_fetch_string(&params_action, params, SL("action"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_VAR(controller_name);
			PHALCON_CALL_METHOD(controller_name, dispatcher, "getcontrollername", PH_NO_CHECK);
	
			PHALCON_INIT_VAR(action_name);
			PHALCON_CALL_METHOD(action_name, dispatcher, "getactionname", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(params_action);
			PHALCON_CONCAT_VSV(params_action, controller_name, "/", action_name);
		}
	} else {
		PHALCON_INIT_NVAR(params_action);
		phalcon_array_fetch_long(&params_action, params, 0, PH_NOISY_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("method"));
	if (!eval_int) {
		phalcon_array_update_string_string(&params, SL("method"), SL("post"), PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(url);
	PHALCON_CALL_SELF(url, this_ptr, "geturlservice");
	if (zend_is_true(action_parameters)) {
		PHALCON_INIT_VAR(action);
		PHALCON_CALL_METHOD_PARAMS_1(action, url, "get", params_action, PH_NO_CHECK);
	} else {
		PHALCON_INIT_VAR(form_action);
		PHALCON_CONCAT_VSV(form_action, params_action, "/", action_parameters);
	
		PHALCON_INIT_NVAR(action);
		PHALCON_CALL_METHOD_PARAMS_1(action, url, "get", form_action, PH_NO_CHECK);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("parameters"));
	if (eval_int) {
		PHALCON_INIT_NVAR(parameters);
		phalcon_array_fetch_string(&parameters, params, SL("parameters"), PH_NOISY_CC);
		PHALCON_SCONCAT_SV(action, "?", parameters);
	}
	
	PHALCON_INIT_VAR(code);
	PHALCON_CONCAT_SVS(code, "<form action=\"", action, "\"");
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(avalue);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", avalue, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	phalcon_concat_self_str(code, SL(">") TSRMLS_CC);
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, endForm){

	zval *end_form;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(end_form);
	ZVAL_STRING(end_form, "</form>", 1);
	
	RETURN_CTOR(end_form);
}

PHP_METHOD(Phalcon_Tag, setTitle){

	zval *title;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), title TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Tag, appendTitle){

	zval *title;
	zval *t0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(t0);
	phalcon_read_static_property(&t0, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	PHALCON_ALLOC_ZVAL_MM(r0);
	concat_function(r0, t0, title TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), r0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, prependTitle){

	zval *title, *document_title = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &title) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_OBSERVE_VAR(document_title);
	phalcon_read_static_property(&document_title, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	
	PHALCON_INIT_VAR(r0);
	PHALCON_CONCAT_VV(r0, title, document_title);
	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentTitle"), r0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Tag, getTitle){

	zval *document_title = NULL, *eol, *title_html;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(document_title);
	phalcon_read_static_property(&document_title, SL("phalcon\\tag"), SL("_documentTitle") TSRMLS_CC);
	
	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	
	PHALCON_INIT_VAR(title_html);
	PHALCON_CONCAT_SVSV(title_html, "<title>", document_title, "</title>", eol);
	
	RETURN_CTOR(title_html);
}

PHP_METHOD(Phalcon_Tag, stylesheetLink){

	zval *parameters = NULL, *local = NULL, *params = NULL, *first_param;
	zval *url, *url_href, *href, *code, *value = NULL, *key = NULL, *doctype;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &parameters, &local) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (!local) {
		PHALCON_INIT_NVAR(local);
		ZVAL_BOOL(local, 1);
	} else {
		PHALCON_SEPARATE_PARAM(local);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, local, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SS("href"));
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(first_param);
			phalcon_array_fetch_long(&first_param, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("href"), &first_param, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string_string(&params, SL("href"), SL(""), PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_NVAR(local);
	ZVAL_STRING(local, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_NVAR(local);
		phalcon_array_fetch_long(&local, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("local"));
		if (eval_int) {
			PHALCON_INIT_NVAR(local);
			phalcon_array_fetch_string(&local, params, SL("local"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SS("local"));
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("type"));
	if (!eval_int) {
		phalcon_array_update_string_string(&params, SL("type"), SL("text/css"), PH_SEPARATE TSRMLS_CC);
	}
	
	if (zend_is_true(local)) {
		PHALCON_INIT_VAR(url);
		PHALCON_CALL_SELF(url, this_ptr, "geturlservice");
	
		PHALCON_INIT_VAR(url_href);
		phalcon_array_fetch_string(&url_href, params, SL("href"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(href);
		PHALCON_CALL_METHOD_PARAMS_1(href, url, "get", url_href, PH_NO_CHECK);
		phalcon_array_update_string(&params, SL("href"), &href, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<link rel=\"stylesheet\"", 1);
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", value, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(doctype);
	PHALCON_CALL_SELF(doctype, this_ptr, "getdoctype");
	if (phalcon_memnstr_str(doctype, SL("XHTML") TSRMLS_CC)) {
		phalcon_concat_self_str(code, SL(" />") TSRMLS_CC);
	} else {
		phalcon_concat_self_str(code, SL(">") TSRMLS_CC);
	}
	
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, javascriptInclude){

	zval *parameters = NULL, *local = NULL, *params = NULL, *first_param;
	zval *url, *params_src, *src, *code, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &parameters, &local) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (!local) {
		PHALCON_INIT_NVAR(local);
		ZVAL_BOOL(local, 1);
	} else {
		PHALCON_SEPARATE_PARAM(local);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, local, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SS("src"));
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(first_param);
			phalcon_array_fetch_long(&first_param, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("src"), &first_param, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string_string(&params, SL("src"), SL(""), PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_NVAR(local);
	ZVAL_STRING(local, "", 1);
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_NVAR(local);
		phalcon_array_fetch_long(&local, params, 1, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("local"));
		if (eval_int) {
			PHALCON_INIT_NVAR(local);
			phalcon_array_fetch_string(&local, params, SL("local"), PH_NOISY_CC);
			PHALCON_SEPARATE(params);
			phalcon_array_unset_string(params, SS("local"));
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("type"));
	if (!eval_int) {
		phalcon_array_update_string_string(&params, SL("type"), SL("text/javascript"), PH_SEPARATE TSRMLS_CC);
	}
	
	if (zend_is_true(local)) {
		PHALCON_INIT_VAR(url);
		PHALCON_CALL_SELF(url, this_ptr, "geturlservice");
	
		PHALCON_INIT_VAR(params_src);
		phalcon_array_fetch_string(&params_src, params, SL("src"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(src);
		PHALCON_CALL_METHOD_PARAMS_1(src, url, "get", params_src, PH_NO_CHECK);
		phalcon_array_update_string(&params, SL("src"), &src, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<script", 1);
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", value, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	phalcon_concat_self_str(code, SL("></script>") TSRMLS_CC);
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, image){

	zval *parameters = NULL, *params = NULL, *first_param, *url, *url_src;
	zval *src, *code, *value = NULL, *key = NULL, *doctype;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SS("src"));
	if (!eval_int) {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(first_param);
			phalcon_array_fetch_long(&first_param, params, 0, PH_NOISY_CC);
			phalcon_array_update_string(&params, SL("src"), &first_param, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_string_string(&params, SL("src"), SL(""), PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(url);
	PHALCON_CALL_SELF(url, this_ptr, "geturlservice");
	
	PHALCON_INIT_VAR(url_src);
	phalcon_array_fetch_string(&url_src, params, SL("src"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(src);
	PHALCON_CALL_METHOD_PARAMS_1(src, url, "get", url_src, PH_NO_CHECK);
	phalcon_array_update_string(&params, SL("src"), &src, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<img", 1);
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (Z_TYPE_P(key) != IS_LONG) {
			PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", value, "\"");
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(doctype);
	PHALCON_CALL_SELF(doctype, this_ptr, "getdoctype");
	if (phalcon_memnstr_str(doctype, SL("XHTML") TSRMLS_CC)) {
		phalcon_concat_self_str(code, SL(" />") TSRMLS_CC);
	} else {
		phalcon_concat_self_str(code, SL(">") TSRMLS_CC);
	}
	
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag, friendlyTitle){

	zval *text, *separator = NULL, *lowercase = NULL, *pattern, *friendly;
	zval *friendly_text = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &text, &separator, &lowercase) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!separator) {
		PHALCON_INIT_NVAR(separator);
		ZVAL_STRING(separator, "-", 1);
	}
	
	if (!lowercase) {
		PHALCON_INIT_NVAR(lowercase);
		ZVAL_BOOL(lowercase, 0);
	}
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "~[ \\t]+~", 1);
	
	PHALCON_INIT_VAR(friendly);
	PHALCON_CALL_FUNC_PARAMS_3(friendly, "preg_replace", pattern, separator, text);
	if (PHALCON_IS_FALSE(lowercase)) {
		PHALCON_INIT_VAR(friendly_text);
		PHALCON_CALL_FUNC_PARAMS_1(friendly_text, "strtolower", friendly);
	} else {
		PHALCON_CPY_WRT(friendly_text, friendly);
	}
	
	
	RETURN_CTOR(friendly_text);
}

PHP_METHOD(Phalcon_Tag, setDocType){

	zval *doctype;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &doctype) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_static_property(SL("phalcon\\tag"), SL("_documentType"), doctype TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Tag, getDocType){

	zval *doctype = NULL, *declaration, *eol, *doctype_html;

	PHALCON_MM_GROW();
	PHALCON_OBSERVE_VAR(doctype);
	phalcon_read_static_property(&doctype, SL("phalcon\\tag"), SL("_documentType") TSRMLS_CC);

	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);

	PHALCON_INIT_VAR(declaration);
	if (phalcon_compare_strict_long(doctype, 1 TSRMLS_CC)) {
		ZVAL_STRING(declaration, " PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"", 1);
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 2 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD HTML 4.01//EN\"", eol, "\t\"http://www.w3.org/TR/html4/strict.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 3 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"", eol, "\t\"http://www.w3.org/TR/html4/loose.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 4 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"", eol, "\t\"http://www.w3.org/TR/html4/frameset.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 6 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"", eol, "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 7 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"", eol, "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 8 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"", eol, "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 9 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"", eol, "\t\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"");
		goto ph_end_0;
	}
	if (phalcon_compare_strict_long(doctype, 10 TSRMLS_CC)) {
		PHALCON_CONCAT_SVS(declaration, " PUBLIC \"-//W3C//DTD XHTML 2.0//EN\"", eol, "\t\"http://www.w3.org/MarkUp/DTD/xhtml2.dtd\"");
		goto ph_end_0;
	}

	ph_end_0:

	PHALCON_INIT_VAR(doctype_html);
	PHALCON_CONCAT_SVSV(doctype_html, "<!DOCTYPE html", declaration, ">", eol);

	RETURN_CTOR(doctype_html);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_FilterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, FilterInterface, filterinterface, phalcon_filterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_FilterInterface, add);

PHALCON_DOC_METHOD(Phalcon_FilterInterface, sanitize);

PHALCON_DOC_METHOD(Phalcon_FilterInterface, getFilters);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Escaper_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Escaper, Exception, escaper_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_EscaperInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, EscaperInterface, escaperinterface, phalcon_escaperinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, setEnconding);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, getEncoding);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, setHtmlQuoteType);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, escapeHtml);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, escapeHtmlAttr);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, escapeCss);

PHALCON_DOC_METHOD(Phalcon_EscaperInterface, escapeUrl);





#ifdef HAVE_CONFIG_H
#endif





PHP_METHOD(Phalcon_Mvc_User, setDI){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_User, getDI){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	
	RETURN_CCTOR(dependency_injector);
}

PHP_METHOD(Phalcon_Mvc_User, setEventsManager){

	zval *events_manager = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_User, getEventsManager){

	zval *events_manager = NULL;

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	
	RETURN_CCTOR(events_manager);
}

PHP_METHOD(Phalcon_Mvc_User, __get){

	zval *property_name = NULL, *dependency_injector = NULL;
	zval *has_service = NULL, *service = NULL, *class_name = NULL, *arguments = NULL;
	zval *persistent = NULL, *error_msg = NULL;

	PHALCON_MM_GROW();
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injection object is required to access the application services");
		return;
	}
	
	PHALCON_INIT_VAR(has_service);
	PHALCON_CALL_METHOD_PARAMS_1(has_service, dependency_injector, "has", property_name, PH_NO_CHECK);
	if (zend_is_true(has_service)) {
		PHALCON_INIT_VAR(service);
		PHALCON_CALL_METHOD_PARAMS_1(service, dependency_injector, "getshared", property_name, PH_NO_CHECK);
		phalcon_update_property_zval_zval(this_ptr, property_name, service TSRMLS_CC);
		
		RETURN_CCTOR(service);
	}
	
	if (PHALCON_COMPARE_STRING(property_name, "di")) {
		phalcon_update_property_zval(this_ptr, SL("di"), dependency_injector TSRMLS_CC);
		
		RETURN_CCTOR(dependency_injector);
	}
	
	if (PHALCON_COMPARE_STRING(property_name, "persistent")) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, this_ptr TSRMLS_CC);
		
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
		phalcon_array_append(&arguments, class_name, PH_SEPARATE TSRMLS_CC);
		
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "sessionBag", 1);
		
		PHALCON_INIT_VAR(persistent);
		PHALCON_CALL_METHOD_PARAMS_2(persistent, dependency_injector, "get", service, arguments, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("persistent"), persistent TSRMLS_CC);
		
		RETURN_CCTOR(persistent);
	}
	
	PHALCON_INIT_VAR(error_msg);
	PHALCON_CONCAT_SV(error_msg, "Access to undefined property ", property_name);
	PHALCON_CALL_FUNC_PARAMS_1_NORETURN("trigger_error", error_msg);
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_RouterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, RouterInterface, mvc_routerinterface, phalcon_mvc_routerinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, setDefaultModule);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, setDefaultController);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, setDefaultAction);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, setDefaults);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, handle);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, add);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addGet);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addPost);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addPut);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addDelete);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addOptions);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, addHead);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, clear);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getModuleName);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getControllerName);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getActionName);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getParams);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getMatchedRoute);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getMatches);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, wasMatched);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getRoutes);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getRouteById);

PHALCON_DOC_METHOD(Phalcon_Mvc_RouterInterface, getRouteByName);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Application_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Application, Exception, mvc_application_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Micro){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Micro, mvc_micro, "phalcon\\di\\injectable", phalcon_mvc_micro_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_handlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_router"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_notFoundHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_activeHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_returnedValue"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Micro, __construct){


	phalcon_update_property_empty_array(phalcon_mvc_micro_ce, this_ptr, SL("_handlers") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Micro, setDI){

	zval *dependency_injector, *service, *exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "The dependency injector must be an object");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "application", 1);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_1(exists, dependency_injector, "has", service, PH_NO_CHECK);
	if (!zend_is_true(exists)) {
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(dependency_injector, "set", service, this_ptr, PH_NO_CHECK);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Micro, map){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "add", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, get){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "addget", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, post){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "addpost", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, put){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "addput", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, head){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "addhead", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, delete){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "adddelete", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, options){

	zval *route_pattern, *handler, *router, *route;
	zval *route_id;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &route_pattern, &handler) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD(router, this_ptr, "getrouter", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_1(route, router, "addoptions", route_pattern, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(route_id);
	PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_handlers"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, route_id, &handler, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_handlers"), t0 TSRMLS_CC);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Micro, notFound){

	zval *handler;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &handler) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_notFoundHandler"), handler TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Micro, getRouter){

	zval *router = NULL, *service_name;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(router);
	phalcon_read_property(&router, this_ptr, SL("_router"), PH_NOISY_CC);
	if (Z_TYPE_P(router) != IS_OBJECT) {
		PHALCON_INIT_VAR(service_name);
		ZVAL_STRING(service_name, "router", 1);
	
		PHALCON_INIT_NVAR(router);
		PHALCON_CALL_METHOD_PARAMS_1(router, this_ptr, "getsharedservice", service_name, PH_NO_CHECK);
		PHALCON_CALL_METHOD_NORETURN(router, "clear", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_router"), router TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(router);
}

PHP_METHOD(Phalcon_Mvc_Micro, getService){

	zval *service_name, *dependency_injector = NULL;
	zval *service;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &service_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD_NORETURN(dependency_injector, "__construct", PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_CALL_METHOD_PARAMS_1(service, dependency_injector, "get", service_name, PH_NO_CHECK);
	
	RETURN_CCTOR(service);
}

PHP_METHOD(Phalcon_Mvc_Micro, getSharedService){

	zval *service_name, *dependency_injector = NULL;
	zval *service;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &service_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD_NORETURN(dependency_injector, "__construct", PH_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_CALL_METHOD_PARAMS_1(service, dependency_injector, "getshared", service_name, PH_NO_CHECK);
	
	RETURN_CCTOR(service);
}

PHP_METHOD(Phalcon_Mvc_Micro, handle){

	zval *dependency_injector, *events_manager = NULL;
	zval *event_name = NULL, *status = NULL, *service, *router, *matched_route;
	zval *handlers, *route_id, *handler = NULL, *params, *returned_value = NULL;
	zval *not_found_handler;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "A dependency injection container is required to access related dispatching services");
		return;
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "micro:beforeHandleRoute", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "router", 1);
	
	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD_PARAMS_1(router, dependency_injector, "getshared", service, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(router, "handle", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(matched_route);
	PHALCON_CALL_METHOD(matched_route, router, "getmatchedroute", PH_NO_CHECK);
	if (Z_TYPE_P(matched_route) == IS_OBJECT) {
		PHALCON_INIT_VAR(handlers);
		phalcon_read_property(&handlers, this_ptr, SL("_handlers"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(route_id);
		PHALCON_CALL_METHOD(route_id, matched_route, "getrouteid", PH_NO_CHECK);
		eval_int = phalcon_array_isset(handlers, route_id);
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "Matched route doesn't have an associate handler");
			return;
		}
	
		PHALCON_INIT_VAR(handler);
		phalcon_array_fetch(&handler, handlers, route_id, PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_activeHandler"), handler TSRMLS_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:beforeExecuteRoute", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			} else {
				PHALCON_INIT_NVAR(handler);
				phalcon_read_property(&handler, this_ptr, SL("_activeHandler"), PH_NOISY_CC);
			}
		}
	
		PHALCON_INIT_VAR(params);
		PHALCON_CALL_METHOD(params, router, "getparams", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(returned_value);
		PHALCON_CALL_USER_FUNC_ARRAY(returned_value, handler, params);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:afterExecuteRoute", 1);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		}
	} else {
		PHALCON_INIT_NVAR(events_manager);
		phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:beforeNotFound", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	
		PHALCON_INIT_VAR(not_found_handler);
		phalcon_read_property(&not_found_handler, this_ptr, SL("_notFoundHandler"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_FUNC_PARAMS_1(r0, "is_callable", not_found_handler);
		if (!zend_is_true(r0)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "The Not-Found handler is not callable or is not defined");
			return;
		}
	
		PHALCON_INIT_NVAR(returned_value);
		PHALCON_CALL_USER_FUNC(returned_value, not_found_handler);
	
		RETURN_CCTOR(returned_value);
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "micro:afterHandleRoute", 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(returned_value);
}

PHP_METHOD(Phalcon_Mvc_Micro, setActiveHandler){

	zval *active_handler;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &active_handler) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_activeHandler"), active_handler TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Micro, getActiveHandler){


	RETURN_MEMBER(this_ptr, "_activeHandler");
}

PHP_METHOD(Phalcon_Mvc_Micro, getReturnedValue){


	RETURN_MEMBER(this_ptr, "_returnedValue");
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_CriteriaInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, CriteriaInterface, mvc_model_criteriainterface, phalcon_mvc_model_criteriainterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, setModelName);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getModelName);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, bind);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, where);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, conditions);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, order);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, limit);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, forUpdate);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, sharedLock);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getWhere);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getConditions);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getLimit);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getOrder);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, getParams);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, fromInput);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_CriteriaInterface, execute);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset_Complex){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Resultset, Complex, mvc_model_resultset_complex, "phalcon\\mvc\\model\\resultset", phalcon_mvc_model_resultset_complex_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_resultset_complex_ce, SL("_columnTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_complex_ce TSRMLS_CC, 1, phalcon_mvc_model_resultsetinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, __construct){

	zval *columns_types, *result, *cache = NULL, *fetch_assoc;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &columns_types, &result, &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!cache) {
		PHALCON_INIT_NVAR(cache);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_columnTypes"), columns_types TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_result"), result TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	phalcon_update_property_long(this_ptr, SL("_type"), 1 TSRMLS_CC);
	if (PHALCON_IS_NOT_FALSE(result)) {
		PHALCON_INIT_VAR(fetch_assoc);
		ZVAL_LONG(fetch_assoc, 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_assoc, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, valid){

	zval *type = NULL, *result, *row = NULL, *rows, *underscore, *empty_str;
	zval *active_row, *columns_types, *column = NULL, *alias = NULL;
	zval *source = NULL, *instance = NULL, *attributes = NULL, *model = NULL, *row_model = NULL;
	zval *attribute = NULL, *column_alias = NULL, *value = NULL, *model_attribute = NULL;
	zval *model_name = NULL, *n_alias = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(type)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
			PHALCON_INIT_VAR(row);
			PHALCON_CALL_METHOD_PARAMS_1(row, result, "fetcharray", result, PH_NO_CHECK);
		} else {
			PHALCON_INIT_NVAR(row);
			ZVAL_BOOL(row, 0);
		}
	} else {
		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
		Z_SET_ISREF_P(rows);
	
		PHALCON_INIT_NVAR(row);
		PHALCON_CALL_FUNC_PARAMS_1(row, "current", rows);
		Z_UNSET_ISREF_P(rows);
		if (zend_is_true(row)) {
			Z_SET_ISREF_P(rows);
			PHALCON_CALL_FUNC_PARAMS_1_NORETURN("next", rows);
			Z_UNSET_ISREF_P(rows);
		}
	}
	
	if (PHALCON_IS_NOT_FALSE(row)) {
		PHALCON_INIT_VAR(underscore);
		ZVAL_STRING(underscore, "_", 1);
	
		PHALCON_INIT_VAR(empty_str);
		ZVAL_STRING(empty_str, "", 1);
	
		PHALCON_INIT_VAR(active_row);
		object_init_ex(active_row, phalcon_mvc_model_row_ce);
	
		PHALCON_INIT_VAR(columns_types);
		phalcon_read_property(&columns_types, this_ptr, SL("_columnTypes"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(columns_types TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(columns_types);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(alias, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(column);
	
			PHALCON_INIT_NVAR(type);
			phalcon_array_fetch_string(&type, column, SL("type"), PH_NOISY_CC);
			if (PHALCON_COMPARE_STRING(type, "object")) {
				PHALCON_INIT_NVAR(source);
				phalcon_array_fetch_string(&source, column, SL("column"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(instance);
				phalcon_array_fetch_string(&instance, column, SL("instance"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(attributes);
				phalcon_array_fetch_string(&attributes, column, SL("attributes"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(model);
				if (phalcon_clone(model, instance TSRMLS_CC) == FAILURE) {
					return;
				}
	
				PHALCON_INIT_NVAR(row_model);
				array_init(row_model);
	
				if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
					return;
				}
	
				ah1 = Z_ARRVAL_P(attributes);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
				ph_cycle_start_1:
	
					if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
						goto ph_cycle_end_1;
					}
	
					PHALCON_GET_FOREACH_VALUE(attribute);
	
					PHALCON_INIT_NVAR(column_alias);
					PHALCON_CONCAT_VVVV(column_alias, underscore, source, underscore, attribute);
	
					PHALCON_INIT_NVAR(value);
					phalcon_array_fetch(&value, row, column_alias, PH_NOISY_CC);
					phalcon_array_update_zval(&row_model, attribute, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
					zend_hash_move_forward_ex(ah1, &hp1);
					goto ph_cycle_start_1;
	
				ph_cycle_end_1:
	
				PHALCON_INIT_NVAR(model_attribute);
				PHALCON_CALL_STATIC_PARAMS_2(model_attribute, "phalcon\\mvc\\model", "dumpresult", model, row_model);
	
				PHALCON_INIT_NVAR(model_name);
				phalcon_array_fetch_string(&model_name, column, SL("model"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(attribute);
				PHALCON_CALL_FUNC_PARAMS_1(attribute, "lcfirst", model_name);
				phalcon_update_property_zval_zval(active_row, attribute, model_attribute TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(value);
				phalcon_array_fetch(&value, row, alias, PH_NOISY_CC);
				eval_int = phalcon_array_isset_string(column, SS("balias"));
				if (eval_int) {
					phalcon_update_property_zval_zval(active_row, alias, value TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(n_alias);
					phalcon_fast_str_replace(n_alias, underscore, empty_str, alias TSRMLS_CC);
					phalcon_update_property_zval_zval(active_row, n_alias, value TSRMLS_CC);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		phalcon_update_property_zval(this_ptr, SL("_activeRow"), active_row TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		phalcon_update_property_bool(this_ptr, SL("_activeRow"), 0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, serialize){

	zval *records, *valid = NULL, *current = NULL, *cache, *data, *serialized;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(records);
	array_init(records);
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, this_ptr, "valid", PH_NO_CHECK);
		PHALCON_CPY_WRT(valid, r0);
		if (PHALCON_IS_NOT_TRUE(valid)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(current);
		PHALCON_CALL_METHOD(current, this_ptr, "current", PH_NO_CHECK);
		phalcon_array_append(&records, current, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(cache);
	phalcon_read_property(&cache, this_ptr, SL("_cache"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	phalcon_array_update_string(&data, SL("cache"), &cache, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&data, SL("rows"), &records, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(serialized);
	PHALCON_CALL_FUNC_PARAMS_1(serialized, "serialize", data);
	
	RETURN_CCTOR(serialized);
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, unserialize){

	zval *data, *resultset, *rows, *cache;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_FUNC_PARAMS_1(resultset, "unserialize", data);
	if (Z_TYPE_P(resultset) == IS_ARRAY) { 
		PHALCON_INIT_VAR(rows);
		phalcon_array_fetch_string(&rows, resultset, SL("rows"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
	
		PHALCON_INIT_VAR(cache);
		phalcon_array_fetch_string(&cache, resultset, SL("cache"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
		return;
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset_Simple){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Resultset, Simple, mvc_model_resultset_simple, "phalcon\\mvc\\model\\resultset", phalcon_mvc_model_resultset_simple_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_resultset_simple_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_simple_ce TSRMLS_CC, 5, zend_ce_iterator, spl_ce_SeekableIterator, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_serializable);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, __construct){

	zval *model, *result, *cache = NULL, *fetch_assoc, *limit;
	zval *row_count, *big_resultset;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &model, &result, &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!cache) {
		PHALCON_INIT_NVAR(cache);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_result"), result TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	if (PHALCON_IS_NOT_FALSE(result)) {
		PHALCON_INIT_VAR(fetch_assoc);
		ZVAL_LONG(fetch_assoc, 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_assoc, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(limit);
		ZVAL_LONG(limit, 32);
	
		PHALCON_INIT_VAR(row_count);
		PHALCON_CALL_METHOD(row_count, result, "numrows", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(big_resultset);
		is_smaller_function(big_resultset, limit, row_count TSRMLS_CC);
		if (PHALCON_IS_TRUE(big_resultset)) {
			phalcon_update_property_long(this_ptr, SL("_type"), 1 TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
		}
	
		phalcon_update_property_zval(this_ptr, SL("_count"), row_count TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, valid){

	zval *type, *result = NULL, *row = NULL, *rows = NULL, *model, *active_row;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(type)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
			PHALCON_INIT_VAR(row);
			PHALCON_CALL_METHOD_PARAMS_1(row, result, "fetcharray", result, PH_NO_CHECK);
		} else {
			PHALCON_INIT_NVAR(row);
			ZVAL_BOOL(row, 0);
		}
	} else {
		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
		if (Z_TYPE_P(rows) == IS_NULL) {
			PHALCON_INIT_NVAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
			if (PHALCON_IS_NOT_FALSE(result)) {
				PHALCON_INIT_NVAR(rows);
				PHALCON_CALL_METHOD(rows, result, "fetchall", PH_NO_CHECK);
				phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
			}
		}
	
		if (Z_TYPE_P(rows) == IS_ARRAY) { 
			Z_SET_ISREF_P(rows);
			PHALCON_INIT_NVAR(row);
			PHALCON_CALL_FUNC_PARAMS_1(row, "current", rows);
			Z_UNSET_ISREF_P(rows);
			if (PHALCON_IS_NOT_FALSE(row)) {
				Z_SET_ISREF_P(rows);
				PHALCON_CALL_FUNC_PARAMS_1_NORETURN("next", rows);
				Z_UNSET_ISREF_P(rows);
			}
		} else {
			PHALCON_INIT_NVAR(row);
			ZVAL_BOOL(row, 0);
		}
	}
	
	if (PHALCON_IS_NOT_FALSE(row)) {
		PHALCON_INIT_VAR(model);
		phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(active_row);
		PHALCON_CALL_STATIC_PARAMS_2(active_row, "phalcon\\mvc\\model", "dumpresult", model, row);
		phalcon_update_property_zval(this_ptr, SL("_activeRow"), active_row TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	} else {
		phalcon_update_property_bool(this_ptr, SL("_activeRow"), 0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, serialize){

	zval *type, *result = NULL, *records = NULL, *row_count, *model;
	zval *cache, *data, *serialized;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(type)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
			PHALCON_CALL_METHOD_NORETURN(result, "execute", PH_NO_CHECK);
	
			PHALCON_INIT_VAR(records);
			PHALCON_CALL_METHOD(records, result, "fetchall", PH_NO_CHECK);
		} else {
			PHALCON_INIT_NVAR(records);
			array_init(records);
		}
	} else {
		PHALCON_INIT_NVAR(records);
		phalcon_read_property(&records, this_ptr, SL("_rows"), PH_NOISY_CC);
		if (Z_TYPE_P(records) == IS_NULL) {
			PHALCON_INIT_NVAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
			if (PHALCON_IS_NOT_FALSE(result)) {
				PHALCON_INIT_NVAR(records);
				PHALCON_CALL_METHOD(records, result, "fetchall", PH_NO_CHECK);
	
				PHALCON_INIT_VAR(row_count);
				phalcon_fast_count(row_count, records TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_rows"), row_count TSRMLS_CC);
			}
		}
	}
	
	PHALCON_INIT_VAR(model);
	phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(cache);
	phalcon_read_property(&cache, this_ptr, SL("_cache"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	phalcon_array_update_string(&data, SL("model"), &model, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&data, SL("cache"), &cache, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&data, SL("rows"), &records, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(serialized);
	PHALCON_CALL_FUNC_PARAMS_1(serialized, "serialize", data);
	
	RETURN_CCTOR(serialized);
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, unserialize){

	zval *data, *resultset, *model, *rows, *cache;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_FUNC_PARAMS_1(resultset, "unserialize", data);
	if (Z_TYPE_P(resultset) == IS_ARRAY) { 
		PHALCON_INIT_VAR(model);
		phalcon_array_fetch_string(&model, resultset, SL("model"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	
		PHALCON_INIT_VAR(rows);
		phalcon_array_fetch_string(&rows, resultset, SL("rows"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
	
		PHALCON_INIT_VAR(cache);
		phalcon_array_fetch_string(&cache, resultset, SL("cache"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
		return;
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, MetaData, mvc_model_metadata, phalcon_mvc_model_metadata_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_metadata_ce, SL("_metaData"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_ATTRIBUTES"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_PRIMARY_KEY"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_NON_PRIMARY_KEY"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_NOT_NULL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES_NUMERIC"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATE_AT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATE_IN"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_IDENTITY_COLUMN"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES_BIND"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_AUTOMATIC_DEFAULT_INSERT"), 10 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_AUTOMATIC_DEFAULT_UPDATE"), 11 TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, _initializeMetaData){

	zval *model, *key, *table, *schema, *meta_data, *data;
	zval *table_metadata = NULL, *class_name = NULL, *exception_message = NULL;
	zval *connection, *exists, *complete_table = NULL, *attributes;
	zval *primary_keys, *non_primary_keys, *numeric_typed;
	zval *not_null, *field_types, *field_bind_types;
	zval *automatic_default, *identity_field = NULL;
	zval *columns, *column = NULL, *field_name = NULL, *feature = NULL, *type = NULL;
	zval *bind_type = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &model, &key, &table, &schema) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(meta_data);
	phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(meta_data, key);
	if (!eval_int) {
		PHALCON_INIT_VAR(data);
		PHALCON_CALL_METHOD_PARAMS_1(data, this_ptr, "read", key, PH_NO_CHECK);
		if (Z_TYPE_P(data) != IS_NULL) {
			phalcon_array_update_zval(&meta_data, key, &data, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_metaData"), meta_data TSRMLS_CC);
			PHALCON_MM_RESTORE();
			RETURN_NULL();
		}
	
		if (phalcon_method_exists_ex(model, SS("metadata") TSRMLS_CC) == SUCCESS) {
			PHALCON_INIT_VAR(table_metadata);
			PHALCON_CALL_METHOD(table_metadata, model, "metadata", PH_NO_CHECK);
			if (Z_TYPE_P(table_metadata) != IS_ARRAY) { 
				PHALCON_INIT_VAR(class_name);
				phalcon_get_class(class_name, model TSRMLS_CC);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "Invalid meta-data for model ", class_name);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_INIT_VAR(connection);
			PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
	
			PHALCON_INIT_VAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, connection, "tableexists", table, schema, PH_NO_CHECK);
			if (!zend_is_true(exists)) {
				if (zend_is_true(schema)) {
					PHALCON_INIT_VAR(complete_table);
					PHALCON_CONCAT_VSV(complete_table, schema, "\".\"", table);
				} else {
					PHALCON_CPY_WRT(complete_table, table);
				}
	
				PHALCON_INIT_NVAR(class_name);
				phalcon_get_class(class_name, model TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Table \"", complete_table, "\" doesn't exist on database when dumping meta-data for ", class_name);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_VAR(attributes);
			array_init(attributes);
	
			PHALCON_INIT_VAR(primary_keys);
			array_init(primary_keys);
	
			PHALCON_INIT_VAR(non_primary_keys);
			array_init(non_primary_keys);
	
			PHALCON_INIT_VAR(numeric_typed);
			array_init(numeric_typed);
	
			PHALCON_INIT_VAR(not_null);
			array_init(not_null);
	
			PHALCON_INIT_VAR(field_types);
			array_init(field_types);
	
			PHALCON_INIT_VAR(field_bind_types);
			array_init(field_bind_types);
	
			PHALCON_INIT_VAR(automatic_default);
			array_init(automatic_default);
	
			PHALCON_INIT_VAR(identity_field);
			ZVAL_BOOL(identity_field, 0);
	
			PHALCON_INIT_VAR(columns);
			PHALCON_CALL_METHOD_PARAMS_2(columns, connection, "describecolumns", table, schema, PH_NO_CHECK);
			if (!phalcon_fast_count_ev(columns TSRMLS_CC)) {
				if (zend_is_true(schema)) {
					PHALCON_INIT_NVAR(complete_table);
					PHALCON_CONCAT_VSV(complete_table, schema, "\".\"", table);
				} else {
					PHALCON_CPY_WRT(complete_table, table);
				}
	
				PHALCON_INIT_NVAR(class_name);
				phalcon_get_class(class_name, model TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Cannot obtain table columns for the mapped source \"", complete_table, "\" used in model ", class_name);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
	
			if (!phalcon_valid_foreach(columns TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(columns);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_VALUE(column);
	
				PHALCON_INIT_NVAR(field_name);
				PHALCON_CALL_METHOD(field_name, column, "getname", PH_NO_CHECK);
				phalcon_array_append(&attributes, field_name, PH_SEPARATE TSRMLS_CC);
	
				PHALCON_INIT_NVAR(feature);
				PHALCON_CALL_METHOD(feature, column, "isprimary", PH_NO_CHECK);
				if (PHALCON_IS_TRUE(feature)) {
					phalcon_array_append(&primary_keys, field_name, PH_SEPARATE TSRMLS_CC);
				} else {
					phalcon_array_append(&non_primary_keys, field_name, PH_SEPARATE TSRMLS_CC);
				}
	
				PHALCON_INIT_NVAR(feature);
				PHALCON_CALL_METHOD(feature, column, "isnumeric", PH_NO_CHECK);
				if (PHALCON_IS_TRUE(feature)) {
					phalcon_array_update_zval_bool(&numeric_typed, field_name, 1, PH_SEPARATE TSRMLS_CC);
				}
	
				PHALCON_INIT_NVAR(feature);
				PHALCON_CALL_METHOD(feature, column, "isnotnull", PH_NO_CHECK);
				if (PHALCON_IS_TRUE(feature)) {
					phalcon_array_append(&not_null, field_name, PH_SEPARATE TSRMLS_CC);
				}
	
				PHALCON_INIT_NVAR(feature);
				PHALCON_CALL_METHOD(feature, column, "isautoincrement", PH_NO_CHECK);
				if (PHALCON_IS_TRUE(feature)) {
					PHALCON_CPY_WRT(identity_field, field_name);
				}
	
				PHALCON_INIT_NVAR(type);
				PHALCON_CALL_METHOD(type, column, "gettype", PH_NO_CHECK);
				phalcon_array_update_zval(&field_types, field_name, &type, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
				PHALCON_INIT_NVAR(bind_type);
				PHALCON_CALL_METHOD(bind_type, column, "getbindtype", PH_NO_CHECK);
				phalcon_array_update_zval(&field_bind_types, field_name, &bind_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
	
			PHALCON_INIT_NVAR(table_metadata);
			array_init(table_metadata);
			phalcon_array_update_long(&table_metadata, 0, &attributes, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 1, &primary_keys, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 2, &non_primary_keys, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 3, &not_null, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 4, &field_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 5, &numeric_typed, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 8, &identity_field, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 9, &field_bind_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 10, &automatic_default, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_long(&table_metadata, 11, &automatic_default, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_metaData"), PH_NOISY_CC);
		phalcon_array_update_zval(&t0, key, &table_metadata, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_metaData"), t0 TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "write", key, table_metadata, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, readMetaDataIndex){

	zval *model, *index, *table, *schema, *key, *meta_data = NULL;
	zval *attributes;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model, &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A model instance is required to retrieve the meta-data");
		return;
	}
	if (Z_TYPE_P(index) != IS_LONG) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Index must be a valid integer constant");
		return;
	}
	
	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, schema, table);
	
	PHALCON_INIT_VAR(meta_data);
	phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(meta_data, key);
	if (!eval_int) {
		PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_initializemetadata", model, key, table, schema, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(meta_data);
		phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	}
	
	PHALCON_INIT_VAR(r0);
	phalcon_array_fetch(&r0, meta_data, key, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(attributes);
	phalcon_array_fetch(&attributes, r0, index, PH_NOISY_CC);
	
	RETURN_CCTOR(attributes);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, writeMetaDataIndex){

	zval *model, *index, *data, *table, *schema, *key, *meta_data = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &model, &index, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A model instance is required to retrieve the meta-data");
		return;
	}
	if (Z_TYPE_P(index) != IS_LONG) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Index must be a valid integer constant");
		return;
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		if (Z_TYPE_P(data) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid data for index");
			return;
		}
	}
	
	PHALCON_INIT_VAR(table);
	PHALCON_CALL_METHOD(table, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, schema, table);
	
	PHALCON_INIT_VAR(meta_data);
	phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(meta_data, key);
	if (!eval_int) {
		PHALCON_CALL_METHOD_PARAMS_4_NORETURN(this_ptr, "_initializemetadata", model, key, table, schema, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(meta_data);
		phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	}
	
	phalcon_array_update_multi_2(&meta_data, key, index, &data, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), meta_data TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 0);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getPrimaryKeyAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 1);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNonPrimaryKeyAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 2);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNotNullAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 3);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 4);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypesNumeric){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 5);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getIdentityField){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 8);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getBindTypes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 9);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticCreateAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 10);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticUpdateAttributes){

	zval *model, *index, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 11);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_2(data, this_ptr, "readmetadataindex", model, index, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}
	
	
	RETURN_CCTOR(data);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticCreateAttributes){

	zval *model, *attributes, *create_index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model, &attributes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(create_index);
	ZVAL_LONG(create_index, 10);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "writemetadataindex", model, create_index, attributes, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticUpdateAttributes){

	zval *model, *attributes, *create_index;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model, &attributes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(create_index);
	ZVAL_LONG(create_index, 11);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "writemetadataindex", model, create_index, attributes, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, isEmpty){

	zval *meta_data, *number, *is_empty;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(meta_data);
	phalcon_read_property(&meta_data, this_ptr, SL("_metaData"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(number);
	phalcon_fast_count(number, meta_data TSRMLS_CC);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_INIT_VAR(is_empty);
	is_equal_function(is_empty, number, t0 TSRMLS_CC);
	
	RETURN_NCTOR(is_empty);
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData, reset){

	zval *empty_array;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model\\Transaction, ManagerInterface, mvc_model_transaction_managerinterface, phalcon_mvc_model_transaction_managerinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, has);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, get);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, rollbackPendent);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, commit);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, rollback);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, notifyRollback);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, notifyCommit);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Transaction_ManagerInterface, collectTransactions);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Failed){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Transaction, Failed, mvc_model_transaction_failed, "exception", phalcon_mvc_model_transaction_failed_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_failed_ce, SL("_record"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, __construct){

	zval *message, *record;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &message, &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_record"), record TSRMLS_CC);
	PHALCON_CALL_PARENT_PARAMS_1_NORETURN(this_ptr, "Phalcon\\Mvc\\Model\\Transaction\\Failed", "__construct", message);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecordMessages){

	zval *record = NULL, *messages;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(record);
	phalcon_read_property(&record, this_ptr, SL("_record"), PH_NOISY_CC);
	if (Z_TYPE_P(record) != IS_NULL) {
		PHALCON_INIT_NVAR(record);
		PHALCON_CALL_METHOD(record, record, "getmessages", PH_NO_CHECK);
	
		RETURN_CCTOR(record);
	}
	
	PHALCON_INIT_VAR(messages);
	PHALCON_CALL_METHOD(messages, this_ptr, "getmessage", PH_NO_CHECK);
	
	RETURN_CCTOR(messages);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecord){


	RETURN_MEMBER(this_ptr, "_record");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Transaction, Manager, mvc_model_transaction_manager, phalcon_mvc_model_transaction_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_manager_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_manager_ce, SL("_initialized"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_transaction_manager_ce, SL("_number"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_manager_ce, SL("_transactions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_transaction_manager_ce TSRMLS_CC, 2, phalcon_mvc_model_transaction_managerinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, __construct){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_mvc_model_transaction_manager_ce, this_ptr, SL("_transactions") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!dependency_injector) {
		PHALCON_INIT_NVAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	if (zend_is_true(dependency_injector)) {
		phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(dependency_injector);
		PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
		phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	}
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, has){

	zval *number, *has_transactions;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(number);
	phalcon_read_property(&number, this_ptr, SL("_number"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 0);
	
	PHALCON_INIT_VAR(has_transactions);
	is_smaller_function(has_transactions, t0, number TSRMLS_CC);
	
	RETURN_NCTOR(has_transactions);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, get){

	zval *auto_begin = NULL, *initialized, *rollback_pendent;
	zval *dependency_injector, *number, *transaction = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL;
	zval *r0 = NULL;
	zval *c0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &auto_begin) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!auto_begin) {
		PHALCON_INIT_NVAR(auto_begin);
		ZVAL_BOOL(auto_begin, 1);
	}
	
	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	if (zend_is_true(initialized)) {
		PHALCON_INIT_VAR(rollback_pendent);
		array_init(rollback_pendent);
		phalcon_array_append(&rollback_pendent, this_ptr, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(rollback_pendent, SL("rollbackPendent"), 1);
		PHALCON_CALL_FUNC_PARAMS_1_NORETURN("register_shutdown_function", rollback_pendent);
		phalcon_update_property_bool(this_ptr, SL("_initialized"), 1 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(number);
	phalcon_read_property(&number, this_ptr, SL("_number"), PH_NOISY_CC);
	if (!zend_is_true(number)) {
		PHALCON_INIT_VAR(transaction);
		object_init_ex(transaction, phalcon_mvc_model_transaction_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(transaction, "__construct", dependency_injector, auto_begin, PH_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "settransactionmanager", this_ptr, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_transactions"), PH_NOISY_CC);
		phalcon_array_append(&t0, transaction, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_transactions"), t0 TSRMLS_CC);
	
		PHALCON_INIT_VAR(t1);
		phalcon_read_property(&t1, this_ptr, SL("_number"), PH_NOISY_CC);
		PHALCON_SEPARATE_NMO(t1);
		increment_function(t1);
		phalcon_update_property_zval(this_ptr, SL("_number"), t1 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 1);
		PHALCON_INIT_VAR(r0);
		sub_function(r0, number, t2 TSRMLS_CC);
		PHALCON_INIT_VAR(t3);
		phalcon_read_property(&t3, this_ptr, SL("_transactions"), PH_NOISY_CC);
		PHALCON_INIT_NVAR(transaction);
		phalcon_array_fetch(&transaction, t3, r0, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(c0);
		ZVAL_BOOL(c0, 0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(transaction, "setisnewtransaction", c0, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(transaction);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollbackPendent){


	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD_NORETURN(this_ptr, "rollback", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, commit){

	zval *transactions, *transaction = NULL, *connection = NULL;
	zval *is_under_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(transactions);
	phalcon_read_property(&transactions, this_ptr, SL("_transactions"), PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(transactions TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(transactions);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(transaction);
	
		PHALCON_INIT_NVAR(connection);
		PHALCON_CALL_METHOD(connection, transaction, "getconnection", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_under_transaction);
		PHALCON_CALL_METHOD(is_under_transaction, connection, "isundertransaction", PH_NO_CHECK);
		if (zend_is_true(is_under_transaction)) {
			PHALCON_CALL_METHOD_NORETURN(connection, "commit", PH_NO_CHECK);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	if(0){}
	
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollback){

	zval *collect = NULL, *transactions, *transaction = NULL, *connection = NULL;
	zval *is_under_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &collect) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!collect) {
		PHALCON_INIT_NVAR(collect);
		ZVAL_BOOL(collect, 0);
	}
	
	PHALCON_INIT_VAR(transactions);
	phalcon_read_property(&transactions, this_ptr, SL("_transactions"), PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(transactions TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(transactions);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(transaction);
	
		PHALCON_INIT_NVAR(connection);
		PHALCON_CALL_METHOD(connection, transaction, "getconnection", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_under_transaction);
		PHALCON_CALL_METHOD(is_under_transaction, connection, "isundertransaction", PH_NO_CHECK);
		if (zend_is_true(is_under_transaction)) {
			PHALCON_CALL_METHOD_NORETURN(connection, "rollback", PH_NO_CHECK);
			PHALCON_CALL_METHOD_NORETURN(connection, "close", PH_NO_CHECK);
		}
	
		if (zend_is_true(collect)) {
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction, PH_NO_CHECK);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	if(0){}
	
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyRollback){

	zval *transaction;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyCommit){

	zval *transaction;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_collecttransaction", transaction, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, _collectTransaction){

	zval *transaction, *transactions = NULL, *number, *managed_transaction = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(transactions);
	phalcon_read_property(&transactions, this_ptr, SL("_transactions"), PH_NOISY_CC);
	if (phalcon_fast_count_ev(transactions TSRMLS_CC)) {
		PHALCON_INIT_VAR(number);
		ZVAL_LONG(number, 0);
	
		if (!phalcon_valid_foreach(transactions TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(transactions);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(managed_transaction);
	
			PHALCON_INIT_NVAR(r0);
			is_equal_function(r0, managed_transaction, transaction TSRMLS_CC);
			if (zend_is_true(r0)) {
				PHALCON_INIT_NVAR(t0);
				phalcon_read_property(&t0, this_ptr, SL("_number"), PH_NOISY_CC);
				PHALCON_SEPARATE_NMO(t0);
				decrement_function(t0);
				phalcon_update_property_zval(this_ptr, SL("_number"), t0 TSRMLS_CC);
			}
			PHALCON_SEPARATE(number);
			increment_function(number);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		PHALCON_INIT_NVAR(transactions);
		array_init(transactions);
	
		if (!phalcon_valid_foreach(transactions TSRMLS_CC)) {
			return;
		}
	
		ALLOC_HASHTABLE(ah1);
		zend_hash_init(ah1, 0, NULL, NULL, 0);
		zend_hash_copy(ah1, Z_ARRVAL_P(transactions), NULL, NULL, sizeof(zval*));
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(managed_transaction);
	
			phalcon_array_append(&transactions, managed_transaction, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		zend_hash_destroy(ah1);
		efree(ah1);
	
		phalcon_update_property_zval(this_ptr, SL("_transactions"), transactions TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, collectTransactions){

	zval *transactions, *number, *managed_transaction = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(transactions);
	phalcon_read_property(&transactions, this_ptr, SL("_transactions"), PH_NOISY_CC);
	if (phalcon_fast_count_ev(transactions TSRMLS_CC)) {
		PHALCON_INIT_VAR(number);
		ZVAL_LONG(number, 0);
	
		if (!phalcon_valid_foreach(transactions TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(transactions);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(managed_transaction);
	
			PHALCON_INIT_NVAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_number"), PH_NOISY_CC);
			PHALCON_SEPARATE_NMO(t0);
			decrement_function(t0);
			phalcon_update_property_zval(this_ptr, SL("_number"), t0 TSRMLS_CC);
			PHALCON_SEPARATE(number);
			increment_function(number);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Transaction, Exception, mvc_model_transaction_exception, "phalcon\\mvc\\model\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ValidatorInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ValidatorInterface, mvc_model_validatorinterface, phalcon_mvc_model_validatorinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ValidatorInterface, getMessages);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ValidatorInterface, validate);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ManagerInterface, mvc_model_managerinterface, phalcon_mvc_model_managerinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, initialize);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, isInitialized);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getLastInitialized);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, load);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, addHasOne);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, addBelongsTo);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, addHasMany);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, existsBelongsTo);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, existsHasMany);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, existsHasOne);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getBelongsToRecords);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getHasManyRecords);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getHasOneRecords);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getBelongsTo);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getHasMany);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getHasOne);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getHasOneAndHasMany);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, getRelations);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, createQuery);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ManagerInterface, executeQuery);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_QueryInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, QueryInterface, mvc_model_queryinterface, phalcon_mvc_model_queryinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_QueryInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_QueryInterface, parse);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_QueryInterface, execute);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Query, mvc_model_query, phalcon_mvc_model_query_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_ast"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_tempSQLModels"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_tempSQLAliases"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_tempSQLAliasesModels"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_query_ce TSRMLS_CC, 2, phalcon_mvc_model_queryinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Query, __construct){

	zval *phql, *ast;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &phql) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(ast);
	if (phql_parse_phql(ast, phql TSRMLS_CC) == FAILURE) {
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_ast"), ast TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Query, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Query, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getQualified){

	zval *expr, *sql_aliases, *column_domain, *exception_message;
	zval *column_name = NULL, *source, *source_column;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &expr, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(expr, SS("domain"));
	if (eval_int) {
		PHALCON_INIT_VAR(column_domain);
		phalcon_array_fetch_string(&column_domain, expr, SL("domain"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(sql_aliases, column_domain);
		if (!eval_int) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Unknown table or alias '", column_domain, "'");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_INIT_VAR(column_name);
		phalcon_array_fetch_string(&column_name, expr, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(source);
		phalcon_array_fetch(&source, sql_aliases, column_domain, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(source_column);
		PHALCON_CONCAT_VSV(source_column, source, ".", column_name);
	
		RETURN_CTOR(source_column);
	}
	
	PHALCON_INIT_NVAR(column_name);
	phalcon_array_fetch_string(&column_name, expr, SL("name"), PH_NOISY_CC);
	
	RETURN_CCTOR(column_name);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getCallArgument){

	zval *argument, *sql_aliases, *argument_type;
	zval *argument_expr = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &argument, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(argument_type);
	phalcon_array_fetch_string(&argument_type, argument, SL("type"), PH_NOISY_CC);
	if (phalcon_compare_strict_long(argument_type, 352 TSRMLS_CC)) {
		PHALCON_INIT_VAR(argument_expr);
		ZVAL_STRING(argument_expr, "*", 1);
	} else {
		PHALCON_INIT_NVAR(argument_expr);
		PHALCON_CALL_METHOD_PARAMS_2(argument_expr, this_ptr, "_getexpression", argument, sql_aliases, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(argument_expr);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getFunctionCall){

	zval *expr, *sql_aliases, *name, *arguments, *arguments_expr;
	zval *argument = NULL, *argument_expr = NULL, *function_args = NULL;
	zval *function_call = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &expr, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(name);
	phalcon_array_fetch_string(&name, expr, SL("name"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(expr, SS("arguments"));
	if (eval_int) {
		PHALCON_INIT_VAR(arguments);
		phalcon_array_fetch_string(&arguments, expr, SL("arguments"), PH_NOISY_CC);
		eval_int = phalcon_array_isset_long(arguments, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(arguments_expr);
			array_init(arguments_expr);
	
			if (!phalcon_valid_foreach(arguments TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(arguments);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_VALUE(argument);
	
				PHALCON_INIT_NVAR(argument_expr);
				PHALCON_CALL_METHOD_PARAMS_2(argument_expr, this_ptr, "_getcallargument", argument, sql_aliases, PH_NO_CHECK);
				phalcon_array_append(&arguments_expr, argument_expr, PH_SEPARATE TSRMLS_CC);
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
	
			PHALCON_INIT_VAR(function_args);
			phalcon_fast_join_str(function_args, SL(","), arguments_expr TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(argument_expr);
			PHALCON_CALL_METHOD_PARAMS_2(argument_expr, this_ptr, "_getcallargument", arguments, sql_aliases, PH_NO_CHECK);
			PHALCON_CPY_WRT(function_args, argument_expr);
		}
	
		PHALCON_INIT_VAR(function_call);
		PHALCON_CONCAT_VSVS(function_call, name, "(", function_args, ")");
	} else {
		PHALCON_INIT_NVAR(function_call);
		PHALCON_CONCAT_VS(function_call, name, "()");
	}
	
	
	RETURN_CTOR(function_call);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getExpression){

	zval *expr, *sql_aliases, *quoting = NULL, *full_placeholder = NULL;
	zval *temp_not_quoting, *expr_left, *left, *expr_right;
	zval *right, *expr_type, *expr_return = NULL, *value = NULL, *question_mark;
	zval *empty_string, *numeric_place, *expression_message;
	zval *expression, *expr_domain, *list_items;
	zval *expr_list_item = NULL, *expr_item = NULL, *joined_list;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|zz", &expr, &sql_aliases, &quoting, &full_placeholder) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!quoting) {
		PHALCON_INIT_NVAR(quoting);
		ZVAL_BOOL(quoting, 1);
	}
	
	if (!full_placeholder) {
		PHALCON_INIT_NVAR(full_placeholder);
		ZVAL_BOOL(full_placeholder, 0);
	}
	
	eval_int = phalcon_array_isset_string(expr, SS("type"));
	if (eval_int) {
		PHALCON_INIT_VAR(temp_not_quoting);
		ZVAL_BOOL(temp_not_quoting, 1);
		eval_int = phalcon_array_isset_string(expr, SS("left"));
		if (eval_int) {
			PHALCON_INIT_VAR(expr_left);
			phalcon_array_fetch_string(&expr_left, expr, SL("left"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(left);
			PHALCON_CALL_METHOD_PARAMS_4(left, this_ptr, "_getexpression", expr_left, sql_aliases, temp_not_quoting, full_placeholder, PH_NO_CHECK);
		}
	
		eval_int = phalcon_array_isset_string(expr, SS("right"));
		if (eval_int) {
			PHALCON_INIT_VAR(expr_right);
			phalcon_array_fetch_string(&expr_right, expr, SL("right"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(right);
			PHALCON_CALL_METHOD_PARAMS_4(right, this_ptr, "_getexpression", expr_right, sql_aliases, temp_not_quoting, full_placeholder, PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(expr_type);
		phalcon_array_fetch_string(&expr_type, expr, SL("type"), PH_NOISY_CC);
	
		if (phalcon_compare_strict_long(expr_type, 60 TSRMLS_CC)) {
			PHALCON_INIT_VAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "<", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 61 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "=", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 62 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, ">", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 270 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "<>", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 271 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "<=", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 272 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, ">=", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 266 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " AND ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 267 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " OR ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 355 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CALL_METHOD_PARAMS_2(expr_return, this_ptr, "_getqualified", expr, sql_aliases, PH_NO_CHECK);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 43 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "+", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 45 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "-", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 42 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "*", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 47 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "/", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 37 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, "%", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 356 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_SVS(expr_return, "(", left, ")");
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 367 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_SV(expr_return, "-", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 258 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			phalcon_array_fetch_string(&expr_return, expr, SL("value"), PH_NOISY_CC);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 259 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			phalcon_array_fetch_string(&expr_return, expr, SL("value"), PH_NOISY_CC);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 260 TSRMLS_CC)) {
			PHALCON_INIT_VAR(value);
			phalcon_array_fetch_string(&value, expr, SL("value"), PH_NOISY_CC);
			if (PHALCON_IS_TRUE(quoting)) {
				PHALCON_INIT_NVAR(expr_return);
				PHALCON_CONCAT_SVS(expr_return, "'", value, "'");
			} else {
				PHALCON_CPY_WRT(expr_return, value);
			}
	
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 273 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(value);
			phalcon_array_fetch_string(&value, expr, SL("value"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(question_mark);
			ZVAL_STRING(question_mark, "?", 1);
	
			PHALCON_INIT_VAR(empty_string);
			ZVAL_STRING(empty_string, "", 1);
	
			PHALCON_INIT_VAR(numeric_place);
			phalcon_fast_str_replace(numeric_place, question_mark, empty_string, value TSRMLS_CC);
			if (PHALCON_IS_TRUE(full_placeholder)) {
				PHALCON_INIT_NVAR(expr_return);
				PHALCON_CONCAT_SVS(expr_return, ":", numeric_place, ":");
			} else {
				PHALCON_INIT_NVAR(expr_return);
				PHALCON_CONCAT_SV(expr_return, ":", numeric_place);
			}
	
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 274 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(value);
			phalcon_array_fetch_string(&value, expr, SL("value"), PH_NOISY_CC);
			if (PHALCON_IS_TRUE(full_placeholder)) {
				PHALCON_INIT_NVAR(expr_return);
				PHALCON_CONCAT_SVS(expr_return, ":", value, ":");
			} else {
				PHALCON_INIT_NVAR(expr_return);
				PHALCON_CONCAT_SV(expr_return, ":", value);
			}
	
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 322 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			ZVAL_STRING(expr_return, "NULL", 1);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 268 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " LIKE ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 351 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " NOT LIKE ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 33 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_SV(expr_return, "NOT ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 365 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VS(expr_return, left, " IS NULL");
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 366 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VS(expr_return, left, " IS NOT NULL");
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 315 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " IN ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 323 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CONCAT_VSV(expr_return, left, " NOT IN ", right);
			goto ph_end_0;
		}
	
		if (phalcon_compare_strict_long(expr_type, 350 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(expr_return);
			PHALCON_CALL_METHOD_PARAMS_2(expr_return, this_ptr, "_getfunctioncall", expr, sql_aliases, PH_NO_CHECK);
			goto ph_end_0;
		}
	
		PHALCON_INIT_VAR(expression_message);
		PHALCON_CONCAT_SV(expression_message, "Unkown expression type ", expr_type);
	
		PHALCON_INIT_VAR(expression);
		object_init_ex(expression, phalcon_mvc_model_exception_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(expression, "__construct", expression_message, PH_CHECK);
		phalcon_throw_exception(expression TSRMLS_CC);
		return;
	
		ph_end_0:
	
		RETURN_CCTOR(expr_return);
	}
	eval_int = phalcon_array_isset_string(expr, SS("domain"));
	if (eval_int) {
		PHALCON_INIT_VAR(expr_domain);
		PHALCON_CALL_METHOD_PARAMS_2(expr_domain, this_ptr, "_getqualified", expr, sql_aliases, PH_NO_CHECK);
	
		RETURN_CCTOR(expr_domain);
	}
	
	eval_int = phalcon_array_isset_long(expr, 0);
	if (eval_int) {
		PHALCON_INIT_VAR(list_items);
		array_init(list_items);
	
		if (!phalcon_valid_foreach(expr TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(expr);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(expr_list_item);
	
			PHALCON_INIT_NVAR(expr_item);
			PHALCON_CALL_METHOD_PARAMS_2(expr_item, this_ptr, "_getexpression", expr_list_item, sql_aliases, PH_NO_CHECK);
			phalcon_array_append(&list_items, expr_item, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
	
		PHALCON_INIT_VAR(joined_list);
		phalcon_fast_join_str(joined_list, SL(","), list_items TSRMLS_CC);
	
		PHALCON_INIT_NVAR(expr_return);
		PHALCON_CONCAT_SVS(expr_return, "(", joined_list, ")");
	
		RETURN_CCTOR(expr_return);
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Unknown expression");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getSelectColumn){

	zval *column = NULL, *models, *sql_aliases, *sql_aliases_models;
	zval *sql_columns, *column_type, *source = NULL, *model_name = NULL;
	zval *sql_column_alias = NULL, *sql_column = NULL, *column_domain;
	zval *exception_message = NULL, *type, *name, *sql_expr_column;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &column, &models, &sql_aliases, &sql_aliases_models) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(column);
	
	eval_int = phalcon_array_isset_string(column, SS("type"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	PHALCON_INIT_VAR(sql_columns);
	array_init(sql_columns);
	
	PHALCON_INIT_VAR(column_type);
	phalcon_array_fetch_string(&column_type, column, SL("type"), PH_NOISY_CC);
	if (phalcon_compare_strict_long(column_type, 352 TSRMLS_CC)) {
	
		if (!phalcon_valid_foreach(models TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(models);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(model_name, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(source);
	
			PHALCON_CPY_WRT(sql_column_alias, source);
	
			PHALCON_INIT_NVAR(sql_column);
			array_init(sql_column);
			add_assoc_stringl_ex(sql_column, SS("type"), SL("object"), 1);
			phalcon_array_update_string(&sql_column, SL("model"), &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&sql_column, SL("column"), &sql_column_alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&sql_columns, sql_column, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
	
		RETURN_CTOR(sql_columns);
	}
	
	eval_int = phalcon_array_isset_string(column, SS("column"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	if (phalcon_compare_strict_long(column_type, 353 TSRMLS_CC)) {
		PHALCON_INIT_VAR(column_domain);
		phalcon_array_fetch_string(&column_domain, column, SL("column"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(sql_aliases, column_domain);
		if (!eval_int) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Unknown table or alias '", column_domain, "'");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_INIT_VAR(source);
		phalcon_array_fetch(&source, sql_aliases, column_domain, PH_NOISY_CC);
		PHALCON_CPY_WRT(sql_column_alias, source);
	
		PHALCON_INIT_VAR(model_name);
		phalcon_array_fetch(&model_name, sql_aliases_models, column_domain, PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(sql_column);
		array_init(sql_column);
		add_assoc_stringl_ex(sql_column, SS("type"), SL("object"), 1);
		phalcon_array_update_string(&sql_column, SL("model"), &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&sql_column, SL("column"), &sql_column_alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&sql_columns, sql_column, PH_SEPARATE TSRMLS_CC);
	
		RETURN_CTOR(sql_columns);
	}
	
	if (phalcon_compare_strict_long(column_type, 354 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(sql_column);
		array_init(sql_column);
		add_assoc_stringl_ex(sql_column, SS("type"), SL("scalar"), 1);
	
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch_string(&r0, column, SL("column"), PH_NOISY_CC);
		PHALCON_CPY_WRT(column, r0);
		eval_int = phalcon_array_isset_string(column, SS("type"));
		if (eval_int) {
			PHALCON_INIT_VAR(type);
			phalcon_array_fetch_string(&type, column, SL("type"), PH_NOISY_CC);
			if (phalcon_compare_strict_long(type, 355 TSRMLS_CC)) {
				PHALCON_INIT_VAR(name);
				phalcon_array_fetch_string(&name, column, SL("name"), PH_NOISY_CC);
				phalcon_array_update_string(&sql_column, SL("balias"), &name, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
		}
	
		PHALCON_INIT_VAR(sql_expr_column);
		PHALCON_CALL_METHOD_PARAMS_2(sql_expr_column, this_ptr, "_getexpression", column, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_column, SL("column"), &sql_expr_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&sql_columns, sql_column, PH_SEPARATE TSRMLS_CC);
	
		RETURN_CTOR(sql_columns);
	}
	
	PHALCON_INIT_NVAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown type of column ", column_type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getTable){

	zval *manager, *qualified_name, *model_name;
	zval *model, *source;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &qualified_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(qualified_name, SS("name"));
	if (eval_int) {
		PHALCON_INIT_VAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(model);
		PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(source);
		PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	
		RETURN_CCTOR(source);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoin){

	zval *manager, *join, *qualified, *qualified_type;
	zval *model_name, *model, *source, *data;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &join) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(join, SS("qualifiedName"));
	if (eval_int) {
		PHALCON_INIT_VAR(qualified);
		phalcon_array_fetch_string(&qualified, join, SL("qualifiedName"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(qualified_type);
		phalcon_array_fetch_string(&qualified_type, qualified, SL("type"), PH_NOISY_CC);
		if (phalcon_compare_strict_long(qualified_type, 355 TSRMLS_CC)) {
			PHALCON_INIT_VAR(model_name);
			phalcon_array_fetch_string(&model_name, qualified, SL("name"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(model);
			PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(source);
			PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	
			PHALCON_INIT_VAR(data);
			array_init(data);
			phalcon_array_update_string(&data, SL("source"), &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&data, SL("model"), &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			RETURN_CTOR(data);
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoinType){

	zval *join, *type, *join_type = NULL, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &join) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(join, SS("type"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	PHALCON_INIT_VAR(type);
	phalcon_array_fetch_string(&type, join, SL("type"), PH_NOISY_CC);
	
	if (phalcon_compare_strict_long(type, 360 TSRMLS_CC)) {
		PHALCON_INIT_VAR(join_type);
		ZVAL_STRING(join_type, "INNER", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 361 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(join_type);
		ZVAL_STRING(join_type, "LEFT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 362 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(join_type);
		ZVAL_STRING(join_type, "RIGHT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 363 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(join_type);
		ZVAL_STRING(join_type, "CROSS", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 364 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(join_type);
		ZVAL_STRING(join_type, "FULL OUTER", 1);
		goto ph_end_0;
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown join type ", type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
	
	ph_end_0:
	
	RETURN_CTOR(join_type);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoins){

	zval *select, *manager, *models, *sql_models, *sql_aliases;
	zval *sql_aliases_models, *sql_joins, *join_models;
	zval *join_sources, *join_types, *join_pre_condition;
	zval *joins, *select_joins = NULL, *join_item = NULL, *join = NULL, *join_data = NULL;
	zval *source = NULL, *model_name = NULL, *join_type = NULL, *alias = NULL, *source_alias = NULL;
	zval *join_expr = NULL, *pre_condition = NULL, *join_alias = NULL;
	zval *join_model = NULL, *has_relations = NULL, *sql_join_conditions = NULL;
	zval *relations = NULL, *fields = NULL, *referenced_fields = NULL;
	zval *sql_join_condition = NULL, *join_source = NULL, *sql_join = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzzzz", &select, &manager, &models, &sql_models, &sql_aliases, &sql_aliases_models) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(sql_models);
	
	PHALCON_SEPARATE_PARAM(sql_aliases);
	
	PHALCON_SEPARATE_PARAM(sql_aliases_models);
	
	PHALCON_INIT_VAR(sql_joins);
	array_init(sql_joins);
	
	PHALCON_INIT_VAR(join_models);
	array_init(join_models);
	
	PHALCON_INIT_VAR(join_sources);
	array_init(join_sources);
	
	PHALCON_INIT_VAR(join_types);
	array_init(join_types);
	
	PHALCON_INIT_VAR(join_pre_condition);
	array_init(join_pre_condition);
	
	PHALCON_INIT_VAR(joins);
	phalcon_array_fetch_string(&joins, select, SL("joins"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(joins, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(select_joins);
		array_init(select_joins);
		phalcon_array_append(&select_joins, joins, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(select_joins, joins);
	}
	
	
	if (!phalcon_valid_foreach(select_joins TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(select_joins);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(join_item);
	
		PHALCON_INIT_NVAR(join);
		phalcon_array_fetch_string(&join, join_item, SL("join"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(join_data);
		PHALCON_CALL_METHOD_PARAMS_2(join_data, this_ptr, "_getjoin", manager, join, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(source);
		phalcon_array_fetch_string(&source, join_data, SL("source"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, join_data, SL("model"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(join_type);
		PHALCON_CALL_METHOD_PARAMS_1(join_type, this_ptr, "_getjointype", join, PH_NO_CHECK);
		phalcon_array_update_zval(&join_types, model_name, &join_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
		eval_int = phalcon_array_isset_string(joins, SS("alias"));
		if (eval_int) {
			PHALCON_INIT_NVAR(alias);
			phalcon_array_fetch_string(&alias, joins, SL("alias"), PH_NOISY_CC);
			phalcon_array_update_zval(&sql_aliases, alias, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&join_models, model_name, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(source_alias);
			PHALCON_CONCAT_VSV(source_alias, source, " ", alias);
			phalcon_array_update_zval(&join_sources, model_name, &source_alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&sql_aliases_models, alias, &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&join_models, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&join_sources, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&sql_aliases_models, model_name, &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		phalcon_array_append(&sql_models, model_name, PH_SEPARATE TSRMLS_CC);
		eval_int = phalcon_array_isset_string(join, SS("expr"));
		if (eval_int) {
			PHALCON_INIT_NVAR(join_expr);
			phalcon_array_fetch_string(&join_expr, join, SL("expr"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(pre_condition);
			PHALCON_CALL_METHOD_PARAMS_2(pre_condition, this_ptr, "_getexpression", join_expr, sql_aliases, PH_NO_CHECK);
			phalcon_array_update_zval(&join_pre_condition, model_name, &pre_condition, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	if (!phalcon_valid_foreach(join_models TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(join_models);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_KEY(join_model, ah1, hp1);
		PHALCON_GET_FOREACH_VALUE(join_alias);
	
		PHALCON_INIT_NVAR(has_relations);
		ZVAL_BOOL(has_relations, 0);
	
		if (!phalcon_valid_foreach(models TSRMLS_CC)) {
			return;
		}
	
		ah2 = Z_ARRVAL_P(models);
		zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
		ph_cycle_start_2:
	
			if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
				goto ph_cycle_end_2;
			}
	
			PHALCON_GET_FOREACH_KEY(model_name, ah2, hp2);
			PHALCON_GET_FOREACH_VALUE(source);
	
			PHALCON_INIT_NVAR(sql_join_conditions);
			array_init(sql_join_conditions);
			eval_int = phalcon_array_isset(join_pre_condition, join_model);
			if (!eval_int) {
				PHALCON_INIT_NVAR(relations);
				PHALCON_CALL_METHOD_PARAMS_2(relations, manager, "getrelations", model_name, join_model, PH_NO_CHECK);
				if (PHALCON_IS_NOT_FALSE(relations)) {
					PHALCON_INIT_NVAR(fields);
					phalcon_array_fetch_string(&fields, relations, SL("fi"), PH_NOISY_CC);
	
					PHALCON_INIT_NVAR(referenced_fields);
					phalcon_array_fetch_string(&referenced_fields, relations, SL("rf"), PH_NOISY_CC);
					if (Z_TYPE_P(fields) == IS_ARRAY) { 
						PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Not implemented yet");
						return;
					} else {
						PHALCON_INIT_NVAR(sql_join_condition);
						PHALCON_CONCAT_VSVSVSV(sql_join_condition, source, ".", fields, "=", join_alias, ".", referenced_fields);
						phalcon_array_append(&sql_join_conditions, sql_join_condition, PH_SEPARATE TSRMLS_CC);
					}
				}
			} else {
				PHALCON_INIT_NVAR(pre_condition);
				phalcon_array_fetch(&pre_condition, join_pre_condition, join_model, PH_NOISY_CC);
				phalcon_array_append(&sql_join_conditions, pre_condition, PH_SEPARATE TSRMLS_CC);
			}
	
			PHALCON_INIT_NVAR(join_type);
			phalcon_array_fetch(&join_type, join_types, join_model, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(join_source);
			phalcon_array_fetch(&join_source, join_sources, join_model, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(sql_join);
			array_init(sql_join);
			phalcon_array_update_string(&sql_join, SL("type"), &join_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&sql_join, SL("source"), &join_source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_string(&sql_join, SL("conditions"), &sql_join_conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&sql_joins, sql_join, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah2, &hp2);
			goto ph_cycle_start_2;
	
		ph_cycle_end_2:
	
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	phalcon_update_property_zval(this_ptr, SL("_tempSQLModels"), sql_models TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_tempSQLAliases"), sql_aliases TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_tempSQLAliasesModels"), sql_aliases_models TSRMLS_CC);
	
	RETURN_CTOR(sql_joins);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getLimitClause){

	zval *limit, *sql_aliases, *limit_expr;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &limit, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(limit_expr);
	PHALCON_CALL_METHOD_PARAMS_2(limit_expr, this_ptr, "_getexpression", limit, sql_aliases, PH_NO_CHECK);
	
	RETURN_CCTOR(limit_expr);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getOrderClause){

	zval *order, *sql_aliases, *order_columns = NULL, *order_parts;
	zval *order_item = NULL, *order_column = NULL, *order_part_expr = NULL;
	zval *order_sort = NULL, *order_part_sort = NULL, *order_expr;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &order, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_long(order, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(order_columns);
		array_init(order_columns);
		phalcon_array_append(&order_columns, order, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(order_columns, order);
	}
	
	PHALCON_INIT_VAR(order_parts);
	array_init(order_parts);
	
	if (!phalcon_valid_foreach(order_columns TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(order_columns);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(order_item);
	
		PHALCON_INIT_NVAR(order_column);
		phalcon_array_fetch_string(&order_column, order_item, SL("column"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(order_part_expr);
		PHALCON_CALL_METHOD_PARAMS_2(order_part_expr, this_ptr, "_getexpression", order_column, sql_aliases, PH_NO_CHECK);
		eval_int = phalcon_array_isset_string(order_item, SS("sort"));
		if (eval_int) {
			PHALCON_INIT_NVAR(order_sort);
			phalcon_array_fetch_string(&order_sort, order_item, SL("sort"), PH_NOISY_CC);
			if (phalcon_compare_strict_long(order_sort, 327 TSRMLS_CC)) {
				PHALCON_INIT_NVAR(order_part_sort);
				PHALCON_CONCAT_VS(order_part_sort, order_part_expr, " ASC");
			} else {
				PHALCON_INIT_NVAR(order_part_sort);
				PHALCON_CONCAT_VS(order_part_sort, order_part_expr, " DESC");
			}
	
			phalcon_array_append(&order_parts, order_part_sort, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_append(&order_parts, order_part_expr, PH_SEPARATE TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(order_expr);
	phalcon_fast_join_str(order_expr, SL(","), order_parts TSRMLS_CC);
	
	RETURN_CTOR(order_expr);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _getGroupClause){

	zval *order, *sql_aliases, *order_parts, *order_item = NULL;
	zval *order_part_expr = NULL, *order_expr = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &order, &sql_aliases) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_long(order, 0);
	if (eval_int) {
		PHALCON_INIT_VAR(order_parts);
		array_init(order_parts);
	
		if (!phalcon_valid_foreach(order TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(order);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(order_item);
	
			PHALCON_INIT_NVAR(order_part_expr);
			PHALCON_CALL_METHOD_PARAMS_2(order_part_expr, this_ptr, "_getexpression", order_item, sql_aliases, PH_NO_CHECK);
			phalcon_array_append(&order_parts, order_part_expr, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		PHALCON_INIT_VAR(order_expr);
		phalcon_fast_join_str(order_expr, SL(","), order_parts TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(order_expr);
		PHALCON_CALL_METHOD_PARAMS_2(order_expr, this_ptr, "_getexpression", order, sql_aliases, PH_NO_CHECK);
	}
	
	RETURN_CCTOR(order_expr);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareSelect){

	zval *manager, *ast, *select, *sql_models = NULL, *sql_tables;
	zval *sql_aliases = NULL, *sql_aliases_models = NULL, *models;
	zval *tables, *select_tables = NULL, *table = NULL, *qualified_name = NULL;
	zval *model_name = NULL, *source = NULL, *alias = NULL, *source_alias = NULL;
	zval *sql_joins = NULL, *sql_columns, *columns, *select_columns = NULL;
	zval *position, *column = NULL, *sql_column_group = NULL, *sql_column = NULL;
	zval *type = NULL, *sql_select, *where, *where_expr, *group_by;
	zval *sql_group, *having, *having_expr, *order;
	zval *sql_order, *limit;
	zval *r0 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL, NULL, NULL };
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &ast) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(select);
	phalcon_array_fetch_string(&select, ast, SL("select"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(select, SS("tables"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	eval_int = phalcon_array_isset_string(select, SS("columns"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	PHALCON_INIT_VAR(sql_models);
	array_init(sql_models);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_aliases_models);
	array_init(sql_aliases_models);
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(tables);
	phalcon_array_fetch_string(&tables, select, SL("tables"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(tables, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(select_tables);
		array_init(select_tables);
		phalcon_array_append(&select_tables, tables, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(select_tables, tables);
	}
	
	
	if (!phalcon_valid_foreach(select_tables TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(select_tables);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(table);
	
		PHALCON_INIT_NVAR(qualified_name);
		phalcon_array_fetch_string(&qualified_name, table, SL("qualifiedName"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(source);
		PHALCON_CALL_METHOD_PARAMS_2(source, this_ptr, "_gettable", manager, qualified_name, PH_NO_CHECK);
		eval_int = phalcon_array_isset_string(table, SS("alias"));
		if (eval_int) {
			PHALCON_INIT_NVAR(alias);
			phalcon_array_fetch_string(&alias, table, SL("alias"), PH_NOISY_CC);
			phalcon_array_update_zval(&sql_aliases, alias, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&sql_aliases_models, alias, &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(source_alias);
			PHALCON_CONCAT_VSV(source_alias, source, " ", alias);
			phalcon_array_append(&sql_tables, source_alias, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&models, model_name, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&sql_aliases_models, model_name, &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&sql_tables, source, PH_SEPARATE TSRMLS_CC);
			phalcon_array_update_zval(&models, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		phalcon_array_append(&sql_models, model_name, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	eval_int = phalcon_array_isset_string(select, SS("joins"));
	if (eval_int) {
		p0[0] = select;
		p0[1] = manager;
		p0[2] = models;
		p0[3] = sql_models;
		p0[4] = sql_aliases;
		p0[5] = sql_aliases_models;
		PHALCON_INIT_VAR(r0);
		PHALCON_CALL_METHOD_PARAMS(r0, this_ptr, "_getjoins", 6, p0, PH_NO_CHECK);
		PHALCON_CPY_WRT(sql_joins, r0);
	
		PHALCON_INIT_NVAR(sql_aliases);
		phalcon_read_property(&sql_aliases, this_ptr, SL("_tempSQLAliases"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(sql_aliases_models);
		phalcon_read_property(&sql_aliases_models, this_ptr, SL("_tempSQLAliasesModels"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(sql_models);
		phalcon_read_property(&sql_models, this_ptr, SL("_tempSQLModels"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_VAR(sql_joins);
		array_init(sql_joins);
	}
	
	PHALCON_INIT_VAR(sql_columns);
	array_init(sql_columns);
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, select, SL("columns"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(columns, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(select_columns);
		array_init(select_columns);
		phalcon_array_append(&select_columns, columns, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(select_columns, columns);
	}
	
	PHALCON_INIT_VAR(position);
	ZVAL_LONG(position, 0);
	
	if (!phalcon_valid_foreach(select_columns TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(select_columns);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(sql_column_group);
		PHALCON_CALL_METHOD_PARAMS_4(sql_column_group, this_ptr, "_getselectcolumn", column, models, sql_aliases, sql_aliases_models, PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(sql_column_group TSRMLS_CC)) {
			return;
		}
	
		ah2 = Z_ARRVAL_P(sql_column_group);
		zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
		ph_cycle_start_2:
	
			if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
				goto ph_cycle_end_2;
			}
	
			PHALCON_GET_FOREACH_VALUE(sql_column);
	
			eval_int = phalcon_array_isset_string(column, SS("alias"));
			if (eval_int) {
				PHALCON_INIT_NVAR(alias);
				phalcon_array_fetch_string(&alias, column, SL("alias"), PH_NOISY_CC);
				phalcon_array_update_string(&sql_column, SL("balias"), &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
				phalcon_array_update_zval(&sql_columns, alias, &sql_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
			} else {
				eval_int = phalcon_array_isset_string(sql_column, SS("balias"));
				if (eval_int) {
					PHALCON_INIT_NVAR(alias);
					phalcon_array_fetch_string(&alias, sql_column, SL("balias"), PH_NOISY_CC);
					phalcon_array_update_zval(&sql_columns, alias, &sql_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(type);
					phalcon_array_fetch_string(&type, sql_column, SL("type"), PH_NOISY_CC);
					if (PHALCON_COMPARE_STRING(type, "scalar")) {
						PHALCON_INIT_NVAR(alias);
						PHALCON_CONCAT_SV(alias, "_", position);
						phalcon_array_update_zval(&sql_columns, alias, &sql_column, PH_COPY | PH_SEPARATE TSRMLS_CC);
					} else {
						phalcon_array_append(&sql_columns, sql_column, PH_SEPARATE TSRMLS_CC);
					}
				}
			}
			PHALCON_SEPARATE(position);
			increment_function(position);
	
			zend_hash_move_forward_ex(ah2, &hp2);
			goto ph_cycle_start_2;
	
		ph_cycle_end_2:
	
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	PHALCON_INIT_VAR(sql_select);
	array_init(sql_select);
	phalcon_array_update_string(&sql_select, SL("models"), &sql_models, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_select, SL("tables"), &sql_tables, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_select, SL("columns"), &sql_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	if (phalcon_fast_count_ev(sql_joins TSRMLS_CC)) {
		phalcon_array_update_string(&sql_select, SL("joins"), &sql_joins, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("where"));
	if (eval_int) {
		PHALCON_INIT_VAR(where);
		phalcon_array_fetch_string(&where, ast, SL("where"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(where_expr);
		PHALCON_CALL_METHOD_PARAMS_2(where_expr, this_ptr, "_getexpression", where, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_select, SL("where"), &where_expr, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("groupBy"));
	if (eval_int) {
		PHALCON_INIT_VAR(group_by);
		phalcon_array_fetch_string(&group_by, ast, SL("groupBy"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(sql_group);
		PHALCON_CALL_METHOD_PARAMS_2(sql_group, this_ptr, "_getgroupclause", group_by, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_select, SL("group"), &sql_group, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("having"));
	if (eval_int) {
		PHALCON_INIT_VAR(having);
		phalcon_array_fetch_string(&having, ast, SL("having"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(having_expr);
		PHALCON_CALL_METHOD_PARAMS_2(having_expr, this_ptr, "_getexpression", having, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_select, SL("having"), &having_expr, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("orderBy"));
	if (eval_int) {
		PHALCON_INIT_VAR(order);
		phalcon_array_fetch_string(&order, ast, SL("orderBy"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(sql_order);
		PHALCON_CALL_METHOD_PARAMS_2(sql_order, this_ptr, "_getorderclause", order, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_select, SL("order"), &sql_order, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, ast, SL("limit"), PH_NOISY_CC);
		phalcon_array_update_string(&sql_select, SL("limit"), &limit, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql_select);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareInsert){

	zval *manager, *ast, *qualified_name, *model_name;
	zval *source, *sql_aliases, *expr_values, *values;
	zval *not_quoting, *expr_value = NULL, *expr_insert = NULL;
	zval *expr_type = NULL, *value = NULL, *sql_insert, *sql_fields;
	zval *fields, *field = NULL, *name = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &ast) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(ast, SS("qualifiedName"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted INSERT AST");
		return;
	}
	eval_int = phalcon_array_isset_string(ast, SS("values"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted INSERT AST");
		return;
	}
	
	PHALCON_INIT_VAR(qualified_name);
	phalcon_array_fetch_string(&qualified_name, ast, SL("qualifiedName"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(model_name);
	phalcon_array_fetch_string(&model_name, qualified_name, SL("name"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD_PARAMS_2(source, this_ptr, "_gettable", manager, qualified_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(expr_values);
	array_init(expr_values);
	
	PHALCON_INIT_VAR(values);
	phalcon_array_fetch_string(&values, ast, SL("values"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(not_quoting);
	ZVAL_BOOL(not_quoting, 0);
	
	if (!phalcon_valid_foreach(values TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(values);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(expr_value);
	
		PHALCON_INIT_NVAR(expr_insert);
		PHALCON_CALL_METHOD_PARAMS_3(expr_insert, this_ptr, "_getexpression", expr_value, sql_aliases, not_quoting, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(expr_type);
		phalcon_array_fetch_string(&expr_type, expr_value, SL("type"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(value);
		array_init(value);
		phalcon_array_update_string(&value, SL("type"), &expr_type, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&value, SL("value"), &expr_insert, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&expr_values, value, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(sql_insert);
	array_init(sql_insert);
	phalcon_array_update_string(&sql_insert, SL("model"), &model_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_insert, SL("table"), &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
	eval_int = phalcon_array_isset_string(ast, SS("fields"));
	if (eval_int) {
		PHALCON_INIT_VAR(sql_fields);
		array_init(sql_fields);
	
		PHALCON_INIT_VAR(fields);
		phalcon_array_fetch_string(&fields, ast, SL("fields"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(fields TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(fields);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(field);
	
			PHALCON_INIT_NVAR(name);
			phalcon_array_fetch_string(&name, field, SL("name"), PH_NOISY_CC);
			phalcon_array_append(&sql_fields, name, PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
	
		phalcon_array_update_string(&sql_insert, SL("fields"), &sql_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	phalcon_array_update_string(&sql_insert, SL("values"), &expr_values, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	RETURN_CTOR(sql_insert);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareUpdate){

	zval *manager, *ast, *update, *models, *sql_aliases;
	zval *sql_tables, *tables, *update_tables = NULL, *table = NULL;
	zval *qualified_name = NULL, *model_name = NULL, *source = NULL, *alias = NULL;
	zval *source_alias = NULL, *sql_fields, *sql_values;
	zval *values, *update_values = NULL, *not_quoting = NULL, *full_placeholder;
	zval *update_value = NULL, *column = NULL, *sql_column = NULL, *expr_column = NULL;
	zval *expr_value = NULL, *type = NULL, *value = NULL, *sql_update, *where;
	zval *where_expr, *limit, *sql_limit;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &ast) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(ast, SS("update"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	PHALCON_INIT_VAR(update);
	phalcon_array_fetch_string(&update, ast, SL("update"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(update, SS("tables"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	eval_int = phalcon_array_isset_string(update, SS("values"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(tables);
	phalcon_array_fetch_string(&tables, update, SL("tables"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(tables, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(update_tables);
		array_init(update_tables);
		phalcon_array_append(&update_tables, tables, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(update_tables, tables);
	}
	
	
	if (!phalcon_valid_foreach(update_tables TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(update_tables);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(table);
	
		PHALCON_INIT_NVAR(qualified_name);
		phalcon_array_fetch_string(&qualified_name, table, SL("qualifiedName"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(source);
		PHALCON_CALL_METHOD_PARAMS_2(source, this_ptr, "_gettable", manager, qualified_name, PH_NO_CHECK);
		eval_int = phalcon_array_isset_string(table, SS("alias"));
		if (eval_int) {
			PHALCON_INIT_NVAR(alias);
			phalcon_array_fetch_string(&alias, table, SL("alias"), PH_NOISY_CC);
			phalcon_array_update_zval(&sql_aliases, alias, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(source_alias);
			PHALCON_CONCAT_VSV(source_alias, source, " ", alias);
			phalcon_array_append(&sql_tables, source_alias, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&sql_tables, source, PH_SEPARATE TSRMLS_CC);
		}
	
		phalcon_array_append(&models, model_name, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(sql_fields);
	array_init(sql_fields);
	
	PHALCON_INIT_VAR(sql_values);
	array_init(sql_values);
	
	PHALCON_INIT_VAR(values);
	phalcon_array_fetch_string(&values, update, SL("values"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(values, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(update_values);
		array_init(update_values);
		phalcon_array_append(&update_values, values, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(update_values, values);
	}
	
	PHALCON_INIT_VAR(not_quoting);
	ZVAL_BOOL(not_quoting, 0);
	
	PHALCON_INIT_VAR(full_placeholder);
	ZVAL_BOOL(full_placeholder, 1);
	
	if (!phalcon_valid_foreach(update_values TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(update_values);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_VALUE(update_value);
	
		PHALCON_INIT_NVAR(column);
		phalcon_array_fetch_string(&column, update_value, SL("column"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(sql_column);
		PHALCON_CALL_METHOD_PARAMS_4(sql_column, this_ptr, "_getexpression", column, sql_aliases, not_quoting, full_placeholder, PH_NO_CHECK);
		phalcon_array_append(&sql_fields, sql_column, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(expr_column);
		phalcon_array_fetch_string(&expr_column, update_value, SL("expr"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(expr_value);
		PHALCON_CALL_METHOD_PARAMS_4(expr_value, this_ptr, "_getexpression", expr_column, sql_aliases, not_quoting, full_placeholder, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(type);
		phalcon_array_fetch_string(&type, expr_column, SL("type"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(value);
		array_init(value);
		phalcon_array_update_string(&value, SL("type"), &type, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&value, SL("value"), &expr_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&sql_values, value, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	PHALCON_INIT_VAR(sql_update);
	array_init(sql_update);
	phalcon_array_update_string(&sql_update, SL("tables"), &sql_tables, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_update, SL("models"), &models, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_update, SL("fields"), &sql_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_update, SL("values"), &sql_values, PH_COPY | PH_SEPARATE TSRMLS_CC);
	eval_int = phalcon_array_isset_string(ast, SS("where"));
	if (eval_int) {
		ZVAL_BOOL(not_quoting, 1);
	
		PHALCON_INIT_VAR(where);
		phalcon_array_fetch_string(&where, ast, SL("where"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(where_expr);
		PHALCON_CALL_METHOD_PARAMS_4(where_expr, this_ptr, "_getexpression", where, sql_aliases, not_quoting, full_placeholder, PH_NO_CHECK);
		phalcon_array_update_string(&sql_update, SL("where"), &where_expr, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, ast, SL("limit"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(sql_limit);
		PHALCON_CALL_METHOD_PARAMS_2(sql_limit, this_ptr, "_getlimitclause", limit, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_update, SL("limit"), &sql_limit, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql_update);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareDelete){

	zval *manager, *ast, *delete, *models, *sql_aliases;
	zval *sql_tables, *tables, *delete_tables = NULL, *table = NULL;
	zval *qualified_name = NULL, *model_name = NULL, *source = NULL, *alias = NULL;
	zval *source_alias = NULL, *sql_delete, *not_quoting;
	zval *full_placeholder, *where, *where_expr;
	zval *limit, *sql_limit;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &manager, &ast) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(ast, SS("delete"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted DELETE AST");
		return;
	}
	
	PHALCON_INIT_VAR(delete);
	phalcon_array_fetch_string(&delete, ast, SL("delete"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(delete, SS("tables"));
	if (!eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted DELETE AST");
		return;
	}
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(tables);
	phalcon_array_fetch_string(&tables, delete, SL("tables"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(tables, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(delete_tables);
		array_init(delete_tables);
		phalcon_array_append(&delete_tables, tables, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(delete_tables, tables);
	}
	
	
	if (!phalcon_valid_foreach(delete_tables TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(delete_tables);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(table);
	
		PHALCON_INIT_NVAR(qualified_name);
		phalcon_array_fetch_string(&qualified_name, table, SL("qualifiedName"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, SL("name"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(source);
		PHALCON_CALL_METHOD_PARAMS_2(source, this_ptr, "_gettable", manager, qualified_name, PH_NO_CHECK);
		eval_int = phalcon_array_isset_string(table, SS("alias"));
		if (eval_int) {
			PHALCON_INIT_NVAR(alias);
			phalcon_array_fetch_string(&alias, table, SL("alias"), PH_NOISY_CC);
			phalcon_array_update_zval(&sql_aliases, alias, &alias, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(source_alias);
			PHALCON_CONCAT_VSV(source_alias, source, " ", alias);
			phalcon_array_append(&sql_tables, source_alias, PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&sql_tables, source, PH_SEPARATE TSRMLS_CC);
		}
	
		phalcon_array_append(&models, model_name, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(sql_delete);
	array_init(sql_delete);
	phalcon_array_update_string(&sql_delete, SL("tables"), &sql_tables, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&sql_delete, SL("models"), &models, PH_COPY | PH_SEPARATE TSRMLS_CC);
	eval_int = phalcon_array_isset_string(ast, SS("where"));
	if (eval_int) {
		PHALCON_INIT_VAR(not_quoting);
		ZVAL_BOOL(not_quoting, 1);
	
		PHALCON_INIT_VAR(full_placeholder);
		ZVAL_BOOL(full_placeholder, 1);
	
		PHALCON_INIT_VAR(where);
		phalcon_array_fetch_string(&where, ast, SL("where"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(where_expr);
		PHALCON_CALL_METHOD_PARAMS_4(where_expr, this_ptr, "_getexpression", where, sql_aliases, not_quoting, full_placeholder, PH_NO_CHECK);
		phalcon_array_update_string(&sql_delete, SL("where"), &where_expr, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(ast, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, ast, SL("limit"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(sql_limit);
		PHALCON_CALL_METHOD_PARAMS_2(sql_limit, this_ptr, "_getlimitclause", limit, sql_aliases, PH_NO_CHECK);
		phalcon_array_update_string(&sql_delete, SL("limit"), &sql_limit, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	
	RETURN_CTOR(sql_delete);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, parse){

	zval *manager = NULL, *parsedph_ql = NULL, *ast, *dependency_injector;
	zval *service, *type, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!manager) {
		PHALCON_INIT_NVAR(manager);
	} else {
		PHALCON_SEPARATE_PARAM(manager);
	}
	
	PHALCON_INIT_VAR(parsedph_ql);
	
	PHALCON_INIT_VAR(ast);
	phalcon_read_property(&ast, this_ptr, SL("_ast"), PH_NOISY_CC);
	if (Z_TYPE_P(ast) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(ast, SS("type"));
		if (eval_int) {
			if (Z_TYPE_P(manager) != IS_OBJECT) {
				PHALCON_INIT_VAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the models-manager service");
					return;
				}
	
				PHALCON_INIT_VAR(service);
				ZVAL_STRING(service, "modelsManager", 1);
	
				PHALCON_INIT_NVAR(manager);
				PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
			}
	
			PHALCON_INIT_VAR(type);
			phalcon_array_fetch_string(&type, ast, SL("type"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	
			if (phalcon_compare_strict_long(type, 309 TSRMLS_CC)) {
				PHALCON_CALL_METHOD_PARAMS_2(parsedph_ql, this_ptr, "_prepareselect", manager, ast, PH_NO_CHECK);
				goto ph_end_0;
			}
	
			if (phalcon_compare_strict_long(type, 306 TSRMLS_CC)) {
				PHALCON_INIT_NVAR(parsedph_ql);
				PHALCON_CALL_METHOD_PARAMS_2(parsedph_ql, this_ptr, "_prepareinsert", manager, ast, PH_NO_CHECK);
				goto ph_end_0;
			}
	
			if (phalcon_compare_strict_long(type, 300 TSRMLS_CC)) {
				PHALCON_INIT_NVAR(parsedph_ql);
				PHALCON_CALL_METHOD_PARAMS_2(parsedph_ql, this_ptr, "_prepareupdate", manager, ast, PH_NO_CHECK);
				goto ph_end_0;
			}
	
			if (phalcon_compare_strict_long(type, 303 TSRMLS_CC)) {
				PHALCON_INIT_NVAR(parsedph_ql);
				PHALCON_CALL_METHOD_PARAMS_2(parsedph_ql, this_ptr, "_preparedelete", manager, ast, PH_NO_CHECK);
				goto ph_end_0;
			}
	
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SV(exception_message, "Unknown statement ", type);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
	
			ph_end_0:
			if(0){}
		}
	}
	
	if (Z_TYPE_P(parsedph_ql) == IS_NULL) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted AST");
		return;
	}
	
	
	RETURN_CCTOR(parsedph_ql);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _executeSelect){

	zval *manager, *meta_data, *intermediate, *placeholders;
	zval *models_instances, *models, *number_models;
	zval *model_name = NULL, *model = NULL, *connection = NULL, *connections;
	zval *type = NULL, *connection_types = NULL, *columns, *have_objects = NULL;
	zval *have_scalars = NULL, *is_complex = NULL, *number_objects;
	zval *column = NULL, *column_type = NULL, *is_simple_std = NULL, *select_columns;
	zval *alias = NULL, *sql_column = NULL, *instance = NULL, *attributes = NULL;
	zval *attribute = NULL, *column_alias = NULL, *dialect, *sql_select;
	zval *processed = NULL, *value = NULL, *wildcard = NULL, *string_wildcard = NULL;
	zval *result, *count, *result_data = NULL, *cache, *result_object = NULL;
	zval *resultset = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4;
	HashPosition hp0, hp1, hp2, hp3, hp4;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &manager, &meta_data, &intermediate, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(intermediate);
	
	PHALCON_INIT_VAR(models_instances);
	array_init(models_instances);
	
	PHALCON_INIT_VAR(models);
	phalcon_array_fetch_string(&models, intermediate, SL("models"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(number_models);
	phalcon_fast_count(number_models, models TSRMLS_CC);
	if (phalcon_compare_strict_long(number_models, 1 TSRMLS_CC)) {
		PHALCON_INIT_VAR(model_name);
		phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(model);
		PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
		phalcon_array_update_zval(&models_instances, model_name, &model, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(connections);
		array_init(connections);
	
		if (!phalcon_valid_foreach(models TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(models);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(model_name);
	
			PHALCON_INIT_NVAR(model);
			PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(connection);
			PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(type);
			PHALCON_CALL_METHOD(type, connection, "gettype", PH_NO_CHECK);
			phalcon_array_update_zval_bool(&connections, type, 1, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(connection_types);
			phalcon_fast_count(connection_types, connections TSRMLS_CC);
			if (phalcon_compare_strict_long(connection_types, 2 TSRMLS_CC)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cannot use models of different database sytem in the same query");
				return;
			}
	
			phalcon_array_update_zval(&models_instances, model_name, &model, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(columns);
	phalcon_array_fetch_string(&columns, intermediate, SL("columns"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(have_objects);
	ZVAL_BOOL(have_objects, 0);
	
	PHALCON_INIT_VAR(have_scalars);
	ZVAL_BOOL(have_scalars, 0);
	
	PHALCON_INIT_VAR(is_complex);
	ZVAL_BOOL(is_complex, 0);
	
	PHALCON_INIT_VAR(number_objects);
	ZVAL_LONG(number_objects, 0);
	
	if (!phalcon_valid_foreach(columns TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(columns);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_1:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_1;
		}
	
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(column_type);
		phalcon_array_fetch_string(&column_type, column, SL("type"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(column_type, "scalar")) {
			eval_int = phalcon_array_isset_string(column, SS("balias"));
			if (!eval_int) {
				PHALCON_INIT_NVAR(is_complex);
				ZVAL_BOOL(is_complex, 1);
			}
	
			PHALCON_INIT_NVAR(have_scalars);
			ZVAL_BOOL(have_scalars, 1);
		} else {
			PHALCON_INIT_NVAR(have_objects);
			ZVAL_BOOL(have_objects, 1);
			PHALCON_SEPARATE(number_objects);
			increment_function(number_objects);
		}
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_1;
	
	ph_cycle_end_1:
	
	if (PHALCON_IS_FALSE(is_complex)) {
		if (PHALCON_IS_TRUE(have_objects)) {
			if (PHALCON_IS_TRUE(have_scalars)) {
				ZVAL_BOOL(is_complex, 1);
			} else {
				if (phalcon_compare_strict_long(number_objects, 1 TSRMLS_CC)) {
					PHALCON_INIT_VAR(is_simple_std);
					ZVAL_BOOL(is_simple_std, 0);
				} else {
					ZVAL_BOOL(is_complex, 1);
				}
			}
		} else {
			PHALCON_INIT_NVAR(is_simple_std);
			ZVAL_BOOL(is_simple_std, 1);
		}
	}
	
	PHALCON_INIT_VAR(select_columns);
	array_init(select_columns);
	
	if (!phalcon_valid_foreach(columns TSRMLS_CC)) {
		return;
	}
	
	ALLOC_HASHTABLE(ah2);
	zend_hash_init(ah2, 0, NULL, NULL, 0);
	zend_hash_copy(ah2, Z_ARRVAL_P(columns), NULL, NULL, sizeof(zval*));
	zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
	ph_cycle_start_2:
	
		if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
			goto ph_cycle_end_2;
		}
	
		PHALCON_GET_FOREACH_KEY(alias, ah2, hp2);
		PHALCON_GET_FOREACH_VALUE(column);
	
		PHALCON_INIT_NVAR(sql_column);
		phalcon_array_fetch_string(&sql_column, column, SL("column"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(type);
		phalcon_array_fetch_string(&type, column, SL("type"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(type, "object")) {
			PHALCON_INIT_NVAR(model_name);
			phalcon_array_fetch_string(&model_name, column, SL("model"), PH_NOISY_CC);
			if (PHALCON_IS_TRUE(is_complex)) {
				PHALCON_INIT_NVAR(instance);
				phalcon_array_fetch(&instance, models_instances, model_name, PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(attributes);
				PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", instance, PH_NO_CHECK);
	
				if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
					return;
				}
	
				ah3 = Z_ARRVAL_P(attributes);
				zend_hash_internal_pointer_reset_ex(ah3, &hp3);
	
				ph_cycle_start_3:
	
					if (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) != SUCCESS) {
						goto ph_cycle_end_3;
					}
	
					PHALCON_GET_FOREACH_VALUE(attribute);
	
					PHALCON_INIT_NVAR(column_alias);
					PHALCON_CONCAT_VSVSVSV(column_alias, sql_column, ".", attribute, " AS _", sql_column, "_", attribute);
					phalcon_array_append(&select_columns, column_alias, PH_SEPARATE TSRMLS_CC);
	
					zend_hash_move_forward_ex(ah3, &hp3);
					goto ph_cycle_start_3;
	
				ph_cycle_end_3:
	
				phalcon_array_update_string_multi_2(&columns, alias, SL("instance"), &instance, 0 TSRMLS_CC);
				phalcon_array_update_string_multi_2(&columns, alias, SL("attributes"), &attributes, 0 TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(column_alias);
				PHALCON_CONCAT_VS(column_alias, sql_column, ".*");
				phalcon_array_append(&select_columns, column_alias, PH_SEPARATE TSRMLS_CC);
			}
		} else {
			if (Z_TYPE_P(alias) == IS_LONG) {
				phalcon_array_append(&select_columns, sql_column, PH_SEPARATE TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(column_alias);
				PHALCON_CONCAT_VSV(column_alias, sql_column, " AS ", alias);
				phalcon_array_append(&select_columns, column_alias, PH_SEPARATE TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah2, &hp2);
		goto ph_cycle_start_2;
	
	ph_cycle_end_2:
	zend_hash_destroy(ah2);
	efree(ah2);
	
	phalcon_array_update_string(&intermediate, SL("columns"), &select_columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(dialect);
	PHALCON_CALL_METHOD(dialect, connection, "getdialect", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(sql_select);
	PHALCON_CALL_METHOD_PARAMS_1(sql_select, dialect, "select", intermediate, PH_NO_CHECK);
	if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
		PHALCON_INIT_VAR(processed);
		array_init(processed);
	
		if (!phalcon_valid_foreach(placeholders TSRMLS_CC)) {
			return;
		}
	
		ah4 = Z_ARRVAL_P(placeholders);
		zend_hash_internal_pointer_reset_ex(ah4, &hp4);
	
		ph_cycle_start_4:
	
			if (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) != SUCCESS) {
				goto ph_cycle_end_4;
			}
	
			PHALCON_GET_FOREACH_KEY(wildcard, ah4, hp4);
			PHALCON_GET_FOREACH_VALUE(value);
	
			if (Z_TYPE_P(wildcard) == IS_LONG) {
				PHALCON_INIT_NVAR(string_wildcard);
				PHALCON_CONCAT_SV(string_wildcard, ":", wildcard);
				phalcon_array_update_zval(&processed, string_wildcard, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
			} else {
				phalcon_array_update_zval(&processed, wildcard, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah4, &hp4);
			goto ph_cycle_start_4;
	
		ph_cycle_end_4:
		if(0){}
	
	} else {
		PHALCON_CPY_WRT(processed, placeholders);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_2(result, connection, "query", sql_select, processed, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD_PARAMS_1(count, result, "numrows", result, PH_NO_CHECK);
	if (zend_is_true(count)) {
		PHALCON_CPY_WRT(result_data, result);
	} else {
		PHALCON_INIT_VAR(result_data);
		ZVAL_BOOL(result_data, 0);
	}
	
	PHALCON_INIT_VAR(cache);
	if (PHALCON_IS_FALSE(is_complex)) {
		if (PHALCON_IS_TRUE(is_simple_std)) {
			PHALCON_INIT_VAR(result_object);
			object_init_ex(result_object, phalcon_mvc_model_row_ce);
		} else {
			PHALCON_CPY_WRT(result_object, model);
		}
	
		PHALCON_INIT_VAR(resultset);
		object_init_ex(resultset, phalcon_mvc_model_resultset_simple_ce);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(resultset, "__construct", result_object, result_data, cache, PH_CHECK);
	
		RETURN_CTOR(resultset);
	}
	
	PHALCON_INIT_NVAR(resultset);
	object_init_ex(resultset, phalcon_mvc_model_resultset_complex_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(resultset, "__construct", columns, result_data, cache, PH_CHECK);
	
	RETURN_CTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _executeInsert){

	zval *manager, *meta_data, *intermediate, *placeholders;
	zval *model_name, *model, *connection, *attributes;
	zval *fields = NULL, *values, *number_fields, *number_values;
	zval *not_equal, *double_colon, *empty_string;
	zval *null_value, *not_exists, *insert_values;
	zval *value = NULL, *number = NULL, *type = NULL, *expr_value = NULL, *insert_value = NULL;
	zval *wildcard = NULL, *exception_message = NULL, *field_name = NULL;
	zval *attribute = NULL, *insert_model, *success, *status;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &manager, &meta_data, &intermediate, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_array_fetch_string(&model_name, intermediate, SL("model"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", model, PH_NO_CHECK);
	eval_int = phalcon_array_isset_string(intermediate, SS("fields"));
	if (eval_int) {
		PHALCON_INIT_VAR(fields);
		phalcon_array_fetch_string(&fields, intermediate, SL("fields"), PH_NOISY_CC);
	} else {
		PHALCON_CPY_WRT(fields, attributes);
	}
	
	PHALCON_INIT_VAR(values);
	phalcon_array_fetch_string(&values, intermediate, SL("values"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(number_fields);
	phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
	PHALCON_INIT_VAR(number_values);
	phalcon_fast_count(number_values, values TSRMLS_CC);
	
	PHALCON_INIT_VAR(not_equal);
	is_identical_function(not_equal, number_values, number_fields TSRMLS_CC);
	if (PHALCON_IS_FALSE(not_equal)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The columns count does not match the values count");
		return;
	}
	
	PHALCON_INIT_VAR(double_colon);
	ZVAL_STRING(double_colon, ":", 1);
	
	PHALCON_INIT_VAR(empty_string);
	ZVAL_STRING(empty_string, "", 1);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(not_exists);
	ZVAL_BOOL(not_exists, 0);
	
	PHALCON_INIT_VAR(insert_values);
	array_init(insert_values);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "setforceexists", not_exists, PH_NO_CHECK);
	
	if (!phalcon_valid_foreach(values TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(values);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(number, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		PHALCON_INIT_NVAR(type);
		phalcon_array_fetch_string(&type, value, SL("type"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(expr_value);
		phalcon_array_fetch_string(&expr_value, value, SL("value"), PH_NOISY_CC);
	
		if (phalcon_compare_strict_long(type, 260 TSRMLS_CC)) {
			PHALCON_CPY_WRT(insert_value, expr_value);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 258 TSRMLS_CC)) {
			PHALCON_CPY_WRT(insert_value, expr_value);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 259 TSRMLS_CC)) {
			PHALCON_CPY_WRT(insert_value, expr_value);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 322 TSRMLS_CC)) {
			PHALCON_CPY_WRT(insert_value, null_value);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 274 TSRMLS_CC)) {
			if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
				PHALCON_INIT_NVAR(wildcard);
				phalcon_fast_str_replace(wildcard, double_colon, empty_string, expr_value TSRMLS_CC);
				eval_int = phalcon_array_isset(placeholders, wildcard);
				if (eval_int) {
					PHALCON_INIT_NVAR(insert_value);
					phalcon_array_fetch(&insert_value, placeholders, wildcard, PH_NOISY_CC);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Bound parameter '", wildcard, "' cannot be replaced because it's not in the placeholders list");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Bound parameter cannot be replaced because placeholders is not an array");
				return;
			}
			goto ph_end_1;
		}
	
		PHALCON_INIT_NVAR(insert_value);
		object_init_ex(insert_value, phalcon_db_rawvalue_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(insert_value, "__construct", expr_value, PH_CHECK);
		goto ph_end_1;
	
		ph_end_1:
	
		PHALCON_INIT_NVAR(field_name);
		phalcon_array_fetch(&field_name, fields, number, PH_NOISY_CC);
		phalcon_array_update_zval(&insert_values, field_name, &insert_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah1 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
	ph_cycle_start_2:
	
		if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
			goto ph_cycle_end_2;
		}
	
		PHALCON_GET_FOREACH_VALUE(attribute);
	
		eval_int = phalcon_array_isset(insert_values, attribute);
		if (!eval_int) {
			phalcon_array_update_zval(&insert_values, attribute, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah1, &hp1);
		goto ph_cycle_start_2;
	
	ph_cycle_end_2:
	
	PHALCON_INIT_VAR(insert_model);
	PHALCON_CALL_STATIC_PARAMS_2(insert_model, "phalcon\\mvc\\model", "dumpresult", model, insert_values);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, insert_model, "create", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(status);
	object_init_ex(status, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(status, "__construct", success, insert_model, PH_CHECK);
	
	RETURN_CTOR(status);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _executeUpdate){

	zval *manager, *meta_data, *intermediate, *placeholders;
	zval *models, *model_name, *model, *parameters;
	zval *where_conditions = NULL, *records, *double_colon;
	zval *empty_string, *fields, *values, *null_value;
	zval *record = NULL, *field = NULL, *number = NULL, *value = NULL, *type = NULL, *expr_value = NULL;
	zval *update_value = NULL, *wildcard = NULL, *exception_message = NULL;
	zval *success = NULL, *status = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &manager, &meta_data, &intermediate, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(models);
	phalcon_array_fetch_string(&models, intermediate, SL("models"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(models, 1);
	if (eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Updating several models at the same time is still not supported");
		return;
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(parameters);
	array_init(parameters);
	eval_int = phalcon_array_isset_string(intermediate, SS("where"));
	if (eval_int) {
		PHALCON_INIT_VAR(where_conditions);
		phalcon_array_fetch_string(&where_conditions, intermediate, SL("where"), PH_NOISY_CC);
		phalcon_array_update_string(&parameters, SL("conditions"), &where_conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(where_conditions);
	}
	
	if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
		phalcon_array_update_string(&parameters, SL("bind"), &placeholders, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_1(records, model, "find", parameters, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(double_colon);
	ZVAL_STRING(double_colon, ":", 1);
	
	PHALCON_INIT_VAR(empty_string);
	ZVAL_STRING(empty_string, "", 1);
	
	PHALCON_INIT_VAR(fields);
	phalcon_array_fetch_string(&fields, intermediate, SL("fields"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(values);
	phalcon_array_fetch_string(&values, intermediate, SL("values"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(null_value);
	PHALCON_CALL_METHOD_NORETURN(records, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, records, "valid", PH_NO_CHECK);
		if (PHALCON_IS_NOT_TRUE(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(record);
		PHALCON_CALL_METHOD(record, records, "current", PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(fields TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(fields);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_KEY(number, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(field);
	
			PHALCON_INIT_NVAR(value);
			phalcon_array_fetch(&value, values, number, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(type);
			phalcon_array_fetch_string(&type, value, SL("type"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(expr_value);
			phalcon_array_fetch_string(&expr_value, value, SL("value"), PH_NOISY_CC);
	
			if (phalcon_compare_strict_long(type, 260 TSRMLS_CC)) {
				PHALCON_CPY_WRT(update_value, expr_value);
				goto ph_end_2;
			}
	
			if (phalcon_compare_strict_long(type, 258 TSRMLS_CC)) {
				PHALCON_CPY_WRT(update_value, expr_value);
				goto ph_end_2;
			}
	
			if (phalcon_compare_strict_long(type, 259 TSRMLS_CC)) {
				PHALCON_CPY_WRT(update_value, expr_value);
				goto ph_end_2;
			}
	
			if (phalcon_compare_strict_long(type, 322 TSRMLS_CC)) {
				PHALCON_CPY_WRT(update_value, null_value);
				goto ph_end_2;
			}
	
			if (phalcon_compare_strict_long(type, 274 TSRMLS_CC)) {
				if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
					PHALCON_INIT_NVAR(wildcard);
					phalcon_fast_str_replace(wildcard, double_colon, empty_string, expr_value TSRMLS_CC);
					eval_int = phalcon_array_isset(placeholders, wildcard);
					if (eval_int) {
						PHALCON_INIT_NVAR(update_value);
						phalcon_array_fetch(&update_value, placeholders, wildcard, PH_NOISY_CC);
					} else {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SVS(exception_message, "Bound parameter '", wildcard, "' cannot be replaced because it's not in the placeholders list");
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Bound parameter cannot be replaced because placeholders is not an array");
					return;
				}
				goto ph_end_2;
			}
	
			PHALCON_INIT_NVAR(update_value);
			object_init_ex(update_value, phalcon_db_rawvalue_ce);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(update_value, "__construct", expr_value, PH_CHECK);
			goto ph_end_2;
	
			ph_end_2:
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(record, "writeattribute", field, update_value, PH_NO_CHECK);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
	
		PHALCON_INIT_NVAR(success);
		PHALCON_CALL_METHOD(success, record, "update", PH_NO_CHECK);
		if (PHALCON_IS_FALSE(success)) {
			PHALCON_INIT_NVAR(status);
			object_init_ex(status, phalcon_mvc_model_query_status_ce);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(status, "__construct", success, record, PH_CHECK);
	
			RETURN_CTOR(status);
		}
	
		PHALCON_CALL_METHOD_NORETURN(records, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	PHALCON_INIT_NVAR(success);
	ZVAL_BOOL(success, 1);
	
	PHALCON_INIT_NVAR(status);
	object_init_ex(status, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(status, "__construct", success, null_value, PH_CHECK);
	
	RETURN_CTOR(status);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, _executeDelete){

	zval *manager, *meta_data, *intermediate, *placeholders;
	zval *models, *model_name, *model, *parameters;
	zval *where_conditions = NULL, *records, *record = NULL, *success = NULL;
	zval *status = NULL, *null_value;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &manager, &meta_data, &intermediate, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(models);
	phalcon_array_fetch_string(&models, intermediate, SL("models"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_long(models, 1);
	if (eval_int) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Updating several models at the same time is still not supported");
		return;
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_METHOD_PARAMS_1(model, manager, "load", model_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(parameters);
	array_init(parameters);
	eval_int = phalcon_array_isset_string(intermediate, SS("where"));
	if (eval_int) {
		PHALCON_INIT_VAR(where_conditions);
		phalcon_array_fetch_string(&where_conditions, intermediate, SL("where"), PH_NOISY_CC);
		phalcon_array_update_string(&parameters, SL("conditions"), &where_conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(where_conditions);
	}
	
	if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
		phalcon_array_update_string(&parameters, SL("bind"), &placeholders, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_1(records, model, "find", parameters, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(records, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, records, "valid", PH_NO_CHECK);
		if (PHALCON_IS_NOT_TRUE(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(record);
		PHALCON_CALL_METHOD(record, records, "current", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(success);
		PHALCON_CALL_METHOD(success, record, "delete", PH_NO_CHECK);
		if (PHALCON_IS_FALSE(success)) {
			PHALCON_INIT_NVAR(status);
			object_init_ex(status, phalcon_mvc_model_query_status_ce);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(status, "__construct", success, record, PH_CHECK);
	
			RETURN_CTOR(status);
		}
	
		PHALCON_CALL_METHOD_NORETURN(records, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	PHALCON_INIT_NVAR(success);
	ZVAL_BOOL(success, 1);
	
	PHALCON_INIT_VAR(null_value);
	ZVAL_BOOL(null_value, 1);
	
	PHALCON_INIT_NVAR(status);
	object_init_ex(status, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(status, "__construct", success, null_value, PH_CHECK);
	
	RETURN_CTOR(status);
}

PHP_METHOD(Phalcon_Mvc_Model_Query, execute){

	zval *placeholders = NULL, *dependency_injector;
	zval *service = NULL, *manager, *meta_data, *intermediate;
	zval *type, *result = NULL, *exception_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the models-manager service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_NVAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(intermediate);
	PHALCON_CALL_METHOD_PARAMS_1(intermediate, this_ptr, "parse", manager, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	
	if (phalcon_compare_strict_long(type, 309 TSRMLS_CC)) {
		PHALCON_INIT_VAR(result);
		PHALCON_CALL_METHOD_PARAMS_4(result, this_ptr, "_executeselect", manager, meta_data, intermediate, placeholders, PH_NO_CHECK);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 306 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(result);
		PHALCON_CALL_METHOD_PARAMS_4(result, this_ptr, "_executeinsert", manager, meta_data, intermediate, placeholders, PH_NO_CHECK);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 300 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(result);
		PHALCON_CALL_METHOD_PARAMS_4(result, this_ptr, "_executeupdate", manager, meta_data, intermediate, placeholders, PH_NO_CHECK);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 303 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(result);
		PHALCON_CALL_METHOD_PARAMS_4(result, this_ptr, "_executedelete", manager, meta_data, intermediate, placeholders, PH_NO_CHECK);
		goto ph_end_0;
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown statement ", type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
	
	ph_end_0:
	
	RETURN_CCTOR(result);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Resultset, mvc_model_resultset, phalcon_mvc_model_resultset_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_long(phalcon_mvc_model_resultset_ce, SL("_type"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_resultset_ce, SL("_isFresh"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_resultset_ce, SL("_pointer"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_count"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_activeRow"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_rows"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_ce TSRMLS_CC, 6, phalcon_mvc_model_resultsetinterface_ce, zend_ce_iterator, spl_ce_SeekableIterator, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_serializable);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, next){

	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_pointer"), PH_NOISY_CC);
	PHALCON_SEPARATE_NMO(t0);
	increment_function(t0);
	phalcon_update_property_zval(this_ptr, SL("_pointer"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, key){


	RETURN_MEMBER(this_ptr, "_pointer");
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, rewind){

	zval *type, *result, *active_row, *zero, *rows;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(type)) {
		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
			phalcon_update_property_long(this_ptr, SL("_pointer"), 1 TSRMLS_CC);
	
			PHALCON_INIT_VAR(active_row);
			phalcon_read_property(&active_row, this_ptr, SL("_activeRow"), PH_NOISY_CC);
			if (Z_TYPE_P(active_row) != IS_NULL) {
				PHALCON_INIT_VAR(zero);
				ZVAL_LONG(zero, 0);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "dataseek", zero, PH_NO_CHECK);
			}
		}
	} else {
		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
		if (Z_TYPE_P(rows) == IS_ARRAY) { 
			Z_SET_ISREF_P(rows);
			PHALCON_CALL_FUNC_PARAMS_1_NORETURN("reset", rows);
			Z_UNSET_ISREF_P(rows);
		}
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, seek){

	zval *numeric_position, *type, *result, *rows;
	long i, position = 0;
	HashTable *ah0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &position) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
	if (zend_is_true(type)) {

		PHALCON_INIT_VAR(numeric_position);
		ZVAL_LONG(numeric_position, position);

		PHALCON_INIT_VAR(result);
		phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "dataseek", numeric_position, PH_NO_CHECK);

	} else {

		PHALCON_INIT_VAR(rows);
		phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);

		if (Z_TYPE_P(rows) == IS_NULL) {
			PHALCON_INIT_VAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
			if (PHALCON_IS_NOT_FALSE(result)) {
				PHALCON_INIT_NVAR(rows);
				PHALCON_CALL_METHOD(rows, result, "fetchall", PH_NO_CHECK);
				phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
			}
		}

		if(Z_TYPE_P(rows) == IS_ARRAY){

			ah0 = Z_ARRVAL_P(rows);
			zend_hash_internal_pointer_reset(ah0);

			i = 0;
			ph_cycle_start_0:

				if (i >= position) {
					goto ph_cycle_end_0;
				}

				zend_hash_move_forward(ah0);
				i++;
				goto ph_cycle_start_0;

			ph_cycle_end_0:
			if(0){}
		}
	}

	PHALCON_MM_RESTORE();}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, count){

	zval *count = NULL, *type, *result = NULL, *number_rows, *rows = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(count);
	phalcon_read_property(&count, this_ptr, SL("_count"), PH_NOISY_CC);
	if (Z_TYPE_P(count) == IS_NULL) {
		PHALCON_INIT_NVAR(count);
		ZVAL_LONG(count, 0);
	
		PHALCON_INIT_VAR(type);
		phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY_CC);
		if (zend_is_true(type)) {
			PHALCON_INIT_VAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
			if (PHALCON_IS_NOT_FALSE(result)) {
				PHALCON_INIT_VAR(number_rows);
				PHALCON_CALL_METHOD(number_rows, result, "numrows", PH_NO_CHECK);
	
				PHALCON_INIT_NVAR(count);
				PHALCON_CALL_FUNC_PARAMS_1(count, "intval", number_rows);
			}
		} else {
			PHALCON_INIT_VAR(rows);
			phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY_CC);
			if (Z_TYPE_P(rows) == IS_NULL) {
				PHALCON_INIT_NVAR(result);
				phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY_CC);
				if (PHALCON_IS_NOT_FALSE(result)) {
					PHALCON_INIT_NVAR(rows);
					PHALCON_CALL_METHOD(rows, result, "fetchall", PH_NO_CHECK);
					phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
				}
			}
	
			PHALCON_INIT_NVAR(count);
			phalcon_fast_count(count, rows TSRMLS_CC);
		}
	
		phalcon_update_property_zval(this_ptr, SL("_count"), count TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(count);
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetExists){

	zval *index, *count, *exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD(count, this_ptr, "count", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(exists);
	is_smaller_function(exists, index, count TSRMLS_CC);
	
	RETURN_NCTOR(exists);
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetGet){

	zval *index, *count, *exists, *valid, *current;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD(count, this_ptr, "count", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(exists);
	is_smaller_function(exists, index, count TSRMLS_CC);
	if (PHALCON_IS_TRUE(exists)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "seek", index, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(valid);
		PHALCON_CALL_METHOD(valid, this_ptr, "valid", PH_NO_CHECK);
		if (PHALCON_IS_NOT_FALSE(valid)) {
			PHALCON_INIT_VAR(current);
			PHALCON_CALL_METHOD(current, this_ptr, "current", PH_NO_CHECK);
	
			RETURN_CCTOR(current);
		} else {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The index does not exist in the cursor");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetSet){

	zval *index, *value;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetUnset){

	zval *offset;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, getFirst){

	zval *valid, *current;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD_NORETURN(this_ptr, "rewind", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(valid);
	PHALCON_CALL_METHOD(valid, this_ptr, "valid", PH_NO_CHECK);
	if (PHALCON_IS_NOT_FALSE(valid)) {
		PHALCON_INIT_VAR(current);
		PHALCON_CALL_METHOD(current, this_ptr, "current", PH_NO_CHECK);
	
		RETURN_CCTOR(current);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, getLast){

	zval *count, *pre_count, *valid, *current;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD(count, this_ptr, "count", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(t0);
	ZVAL_LONG(t0, 1);
	
	PHALCON_INIT_VAR(pre_count);
	sub_function(pre_count, count, t0 TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "seek", pre_count, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(valid);
	PHALCON_CALL_METHOD(valid, this_ptr, "valid", PH_NO_CHECK);
	if (PHALCON_IS_NOT_FALSE(valid)) {
		PHALCON_INIT_VAR(current);
		PHALCON_CALL_METHOD(current, this_ptr, "current", PH_NO_CHECK);
	
		RETURN_CCTOR(current);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, setIsFresh){

	zval *is_fresh;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &is_fresh) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_isFresh"), is_fresh TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, isFresh){


	RETURN_MEMBER(this_ptr, "_isFresh");
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, getCache){


	RETURN_MEMBER(this_ptr, "_cache");
}

PHP_METHOD(Phalcon_Mvc_Model_Resultset, current){


	RETURN_MEMBER(this_ptr, "_activeRow");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Criteria){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Criteria, mvc_model_criteria, phalcon_mvc_model_criteria_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_criteria_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_criteria_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_criteria_ce TSRMLS_CC, 2, phalcon_mvc_model_criteriainterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, __construct){


	phalcon_update_property_empty_array(phalcon_mvc_model_criteria_ce, this_ptr, SL("_params") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, setDI){

	zval *dependency_injector;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Dependency Injector is invalid");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("di"), &dependency_injector, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getDI){

	zval *params, *dependency_injector;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("di"));
	if (eval_int) {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_array_fetch_string(&dependency_injector, params, SL("di"), PH_NOISY_CC);
	
		RETURN_CCTOR(dependency_injector);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, setModelName){

	zval *model_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(model_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model name must be string");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_model"), model_name TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getModelName){

	zval *model;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(model);
	phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	
	RETURN_CCTOR(model);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, bind){

	zval *bind_params;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &bind_params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(bind_params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Bind parameters must be an Array");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("bind"), &bind_params, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, where){

	zval *conditions;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &conditions) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("conditions"), &conditions, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, conditions){

	zval *conditions;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &conditions) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("conditions"), &conditions, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, order){

	zval *order_columns;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &order_columns) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(order_columns) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Order columns must be string");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("order"), &order_columns, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, limit){

	zval *limit, *offset = NULL, *limit_clause;
	zval *r0 = NULL;
	zval *t0 = NULL, *t1 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &limit, &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!offset) {
		PHALCON_INIT_NVAR(offset);
	}
	
	PHALCON_INIT_VAR(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_numeric", limit);
	if (!zend_is_true(r0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Rows limit parameter must be integer");
		return;
	}
	if (Z_TYPE_P(offset) == IS_NULL) {
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
		phalcon_array_update_string(&t0, SL("limit"), &limit, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(limit_clause);
		array_init(limit_clause);
		phalcon_array_update_string(&limit_clause, SL("number"), &limit, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&limit_clause, SL("offset"), &offset, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(t1);
		phalcon_read_property(&t1, this_ptr, SL("_params"), PH_NOISY_CC);
		phalcon_array_update_string(&t1, SL("limit"), &limit_clause, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_params"), t1 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, forUpdate){

	zval *for_update = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &for_update) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!for_update) {
		PHALCON_INIT_NVAR(for_update);
		ZVAL_BOOL(for_update, 1);
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("for_update"), &for_update, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, sharedLock){

	zval *shared_lock = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &shared_lock) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!shared_lock) {
		PHALCON_INIT_NVAR(shared_lock);
		ZVAL_BOOL(shared_lock, 1);
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_string(&t0, SL("shared_lock"), &shared_lock, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getWhere){

	zval *params, *conditions;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("conditions"));
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	
		RETURN_CCTOR(conditions);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getConditions){

	zval *params, *conditions;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("conditions"));
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	
		RETURN_CCTOR(conditions);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getLimit){

	zval *params, *conditions;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("limit"), PH_NOISY_CC);
	
		RETURN_CCTOR(conditions);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getOrder){

	zval *params, *conditions;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("order"));
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_string(&conditions, params, SL("order"), PH_NOISY_CC);
	
		RETURN_CCTOR(conditions);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, getParams){


	RETURN_MEMBER(this_ptr, "_params");
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, fromInput){

	zval *dependency_injector, *model_name, *data;
	zval *conditions, *service, *meta_data, *model;
	zval *data_types, *bind, *value = NULL, *field = NULL, *type = NULL, *condition = NULL;
	zval *value_pattern = NULL, *criteria, *join_conditions;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &dependency_injector, &model_name, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Input data must be an Array");
		return;
	}
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the ORM services");
		return;
	}
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	if (phalcon_fast_count_ev(data TSRMLS_CC)) {
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "modelsMetadata", 1);
	
		PHALCON_INIT_VAR(meta_data);
		PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
	
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	
		PHALCON_INIT_VAR(data_types);
		PHALCON_CALL_METHOD_PARAMS_1(data_types, meta_data, "getdatatypes", model, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(bind);
		array_init(bind);
	
		if (!phalcon_valid_foreach(data TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(data);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(field, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			eval_int = phalcon_array_isset(data_types, field);
			if (eval_int) {
				if (Z_TYPE_P(value) != IS_NULL) {
					if (!PHALCON_COMPARE_STRING(value, "")) {
						PHALCON_INIT_NVAR(type);
						phalcon_array_fetch(&type, data_types, field, PH_NOISY_CC);
						if (phalcon_compare_strict_long(type, 2 TSRMLS_CC)) {
							PHALCON_INIT_NVAR(condition);
							PHALCON_CONCAT_VSVS(condition, field, " LIKE :", field, ":");
	
							PHALCON_INIT_NVAR(value_pattern);
							PHALCON_CONCAT_SVS(value_pattern, "%", value, "%");
							phalcon_array_update_zval(&bind, field, &value_pattern, PH_COPY | PH_SEPARATE TSRMLS_CC);
						} else {
							PHALCON_INIT_NVAR(condition);
							PHALCON_CONCAT_VSVS(condition, field, "=:", field, ":");
							phalcon_array_update_zval(&bind, field, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
						}
	
						phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(criteria);
	object_init_ex(criteria, phalcon_mvc_model_criteria_ce);
	PHALCON_CALL_METHOD_NORETURN(criteria, "__construct", PH_CHECK);
	if (phalcon_fast_count_ev(conditions TSRMLS_CC)) {
		PHALCON_INIT_VAR(join_conditions);
		phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(criteria, "where", join_conditions, PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(criteria, "bind", bind, PH_NO_CHECK);
	}
	
	
	RETURN_CTOR(criteria);
}

PHP_METHOD(Phalcon_Mvc_Model_Criteria, execute){

	zval *model, *params, *resultset;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(model);
	phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	if (Z_TYPE_P(model) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model name must be string");
		return;
	}
	
	PHALCON_INIT_VAR(params);
	PHALCON_CALL_METHOD(params, this_ptr, "getparams", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_STATIC_ZVAL_PARAMS_1(resultset, model, "find", params);
	
	RETURN_CCTOR(resultset);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ResultsetInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ResultsetInterface, mvc_model_resultsetinterface, phalcon_mvc_model_resultsetinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ResultsetInterface, getFirst);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ResultsetInterface, getLast);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ResultsetInterface, setIsFresh);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ResultsetInterface, isFresh);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_ResultsetInterface, getCache);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaDataInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, MetaDataInterface, mvc_model_metadatainterface, phalcon_mvc_model_metadatainterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, readMetaDataIndex);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, writeMetaDataIndex);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getPrimaryKeyAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getNonPrimaryKeyAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getNotNullAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getDataTypes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getDataTypesNumeric);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getIdentityField);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getBindTypes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getAutomaticCreateAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, getAutomaticUpdateAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, setAutomaticCreateAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, setAutomaticUpdateAttributes);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, isEmpty);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, reset);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, read);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MetaDataInterface, write);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Inclusionin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Inclusionin, mvc_model_validator_inclusionin, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_inclusionin_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_inclusionin_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Inclusionin, validate){

	zval *record, *field = NULL, *field_name, *is_set, *domain;
	zval *value, *is_in_array, *joined_domain, *message;
	zval *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(field);
	ZVAL_STRING(field, "field", 1);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", field, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(field);
	ZVAL_STRING(field, "domain", 1);
	
	PHALCON_INIT_VAR(is_set);
	PHALCON_CALL_METHOD_PARAMS_1(is_set, this_ptr, "issetoption", field, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_NVAR(field);
	ZVAL_STRING(field, "domain", 1);
	
	PHALCON_INIT_VAR(domain);
	PHALCON_CALL_METHOD_PARAMS_1(domain, this_ptr, "getoption", field, PH_NO_CHECK);
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_in_array);
	PHALCON_CALL_FUNC_PARAMS_2(is_in_array, "in_array", value, domain);
	if (PHALCON_IS_FALSE(is_in_array)) {
		PHALCON_INIT_VAR(joined_domain);
		phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CONCAT_SVSV(message, "Value of field '", field_name, "' must be part of list: ", joined_domain);
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "inclusion", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field_name, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Exclusionin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Exclusionin, mvc_model_validator_exclusionin, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_exclusionin_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_exclusionin_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Exclusionin, validate){

	zval *record, *option = NULL, *field_name, *is_set, *domain;
	zval *value, *is_in_array, *type, *joined_domain;
	zval *message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_INIT_VAR(is_set);
	PHALCON_CALL_METHOD_PARAMS_1(is_set, this_ptr, "issetoption", option, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_INIT_VAR(domain);
	PHALCON_CALL_METHOD_PARAMS_1(domain, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(is_in_array);
	PHALCON_CALL_FUNC_PARAMS_2(is_in_array, "in_array", value, domain);
	if (PHALCON_IS_TRUE(is_in_array)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "exclusion", 1);
	
		PHALCON_INIT_VAR(joined_domain);
		phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CONCAT_SVSV(message, "Value of field '", field_name, "' must not be part of list: ", joined_domain);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field_name, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Uniqueness){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Uniqueness, mvc_model_validator_uniqueness, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_uniqueness_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_uniqueness_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Uniqueness, validate){

	zval *record, *option = NULL, *field, *dependency_injector;
	zval *service, *meta_data, *bind_types, *bind_data_types;
	zval *conditions = NULL, *placeholders, *number = NULL, *compose_field = NULL;
	zval *exception_message = NULL, *value = NULL, *bind_type = NULL;
	zval *condition = NULL, *operation_made, *primary_fields;
	zval *primary_field = NULL, *params, *class_name, *type;
	zval *message = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field);
	PHALCON_CALL_METHOD_PARAMS_1(field, this_ptr, "getoption", option, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(dependency_injector);
	PHALCON_CALL_METHOD(dependency_injector, record, "getdi", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_INIT_VAR(bind_data_types);
	PHALCON_CALL_METHOD_PARAMS_1(bind_data_types, meta_data, "getbindtypes", record, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(number);
	ZVAL_LONG(number, 0);
	if (Z_TYPE_P(field) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(field TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(field);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(compose_field);
	
			eval_int = phalcon_array_isset(bind_data_types, compose_field);
			if (!eval_int) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", compose_field, "\" isn't part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_NVAR(value);
			PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", compose_field, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(r0);
			PHALCON_CONCAT_VSV(r0, compose_field, " = ?", number);
			phalcon_array_append(&conditions, r0, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(bind_type);
			phalcon_array_fetch(&bind_type, bind_data_types, compose_field, PH_NOISY_CC);
			phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
			PHALCON_SEPARATE(number);
			increment_function(number);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	} else {
		eval_int = phalcon_array_isset(bind_data_types, field);
		if (!eval_int) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Column '", field, "\" isn't part of the table columns");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_INIT_NVAR(value);
		PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(condition);
		PHALCON_CONCAT_VS(condition, field, " = ?0");
		phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(bind_type);
		phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY_CC);
		phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
		PHALCON_SEPARATE(number);
		increment_function(number);
	}
	
	PHALCON_INIT_VAR(operation_made);
	PHALCON_CALL_METHOD(operation_made, record, "getoperationmade", PH_NO_CHECK);
	if (phalcon_compare_strict_long(operation_made, 2 TSRMLS_CC)) {
		PHALCON_INIT_VAR(primary_fields);
		PHALCON_CALL_METHOD_PARAMS_1(primary_fields, meta_data, "getprimarykeyattributes", record, PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(primary_fields TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(primary_fields);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(primary_field);
	
			eval_int = phalcon_array_isset(bind_data_types, primary_field);
			if (!eval_int) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", primary_field, "\" isn't part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_NVAR(value);
			PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", primary_field, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(condition);
			PHALCON_CONCAT_VSV(condition, primary_field, " <> ?", number);
			phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(bind_type);
			phalcon_array_fetch(&bind_type, bind_data_types, primary_field, PH_NOISY_CC);
			phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
			PHALCON_SEPARATE(number);
			increment_function(number);
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(r1);
	phalcon_fast_join_str(r1, SL(" AND "), conditions TSRMLS_CC);
	PHALCON_CPY_WRT(conditions, r1);
	
	PHALCON_INIT_VAR(params);
	array_init(params);
	phalcon_array_update_string(&params, SL("di"), &dependency_injector, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&params, SL("conditions"), &conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&params, SL("bind"), &placeholders, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&params, SL("bindTypes"), &bind_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, record TSRMLS_CC);
	
	PHALCON_CALL_STATIC_ZVAL_PARAMS_1(number, class_name, "count", params);
	if (!phalcon_compare_strict_long(number, 0 TSRMLS_CC)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "unique", 1);
	
		PHALCON_INIT_NVAR(option);
		ZVAL_STRING(option, "message", 1);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CALL_METHOD_PARAMS_1(message, this_ptr, "getoption", option, PH_NO_CHECK);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "Value of field '", field, "' is already present in another record");
		}
	
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Email){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Email, mvc_model_validator_email, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_email_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_email_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Email, validate){

	zval *record, *option, *field_name, *regs, *invalid = NULL;
	zval *value, *pattern, *match_pattern, *match_zero;
	zval *type, *message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(regs);
	
	PHALCON_INIT_VAR(invalid);
	ZVAL_BOOL(invalid, 0);
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "/^[a-zA-Z0-9\\-_\\.\\+]+@[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)*$/", 1);
	Z_SET_ISREF_P(regs);
	
	PHALCON_INIT_VAR(match_pattern);
	PHALCON_CALL_FUNC_PARAMS_3(match_pattern, "preg_match", pattern, value, regs);
	Z_UNSET_ISREF_P(regs);
	if (zend_is_true(match_pattern)) {
		PHALCON_INIT_VAR(match_zero);
		phalcon_array_fetch_long(&match_zero, regs, 0, PH_NOISY_CC);
	
		is_not_equal_function(invalid, match_zero, value TSRMLS_CC);
	} else {
		ZVAL_BOOL(invalid, 1);
	}
	
	if (PHALCON_IS_TRUE(invalid)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "email", 1);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CONCAT_SVS(message, "Value of field '", field_name, "' must have a valid e-mail format");
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field_name, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Numericality){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Numericality, mvc_model_validator_numericality, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_numericality_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_numericality_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Numericality, validate){

	zval *record, *option, *field, *value, *type, *message;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field);
	PHALCON_CALL_METHOD_PARAMS_1(field, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(r0);
	PHALCON_CALL_FUNC_PARAMS_1(r0, "is_numeric", value);
	if (!zend_is_true(r0)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "numericality", 1);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CONCAT_SVS(message, "Value of field '", field, "' must be numeric");
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_StringLength){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, StringLength, mvc_model_validator_stringlength, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_stringlength_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_stringlength_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_StringLength, validate){

	zval *record = NULL, *field_name = NULL, *value_length = NULL, *value = NULL, *failed = NULL;
	zval *min = NULL, *max = NULL;
	zval *min_is_set = NULL, *max_is_set = NULL;
	zval *message0 = NULL, *message1 = NULL;
	zval *c0 = NULL, *c1 = NULL, *c2 = NULL, *c3 = NULL, *c4 = NULL;
	zval *r0 = NULL, *r1 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(c0);
	ZVAL_STRING(c0, "field", 1);
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", c0, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}

	PHALCON_INIT_VAR(c1);
	ZVAL_STRING(c1, "max", 1);

	PHALCON_INIT_VAR(max_is_set);
	PHALCON_CALL_METHOD_PARAMS_1(max_is_set, this_ptr, "issetoption", c1, PH_NO_CHECK);

	PHALCON_INIT_VAR(c2);
	ZVAL_STRING(c2, "min", 1);

	PHALCON_INIT_VAR(min_is_set);
	PHALCON_CALL_METHOD_PARAMS_1(min_is_set, this_ptr, "issetoption", c2, PH_NO_CHECK);
	if (!zend_is_true(max_is_set) && !zend_is_true(min_is_set)) {
		//the user didn't specify a min or a max... time to throw up
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A minimum or maximum must be set.");
		return;
	}

	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);

	PHALCON_INIT_VAR(value_length);
	PHALCON_CALL_FUNC_PARAMS_1(value_length, "strlen", value);

	PHALCON_INIT_VAR(failed);
	ZVAL_BOOL(failed, 0);

	//validate the max
	if (zend_is_true(max_is_set)) {
		PHALCON_INIT_VAR(max);
		PHALCON_CALL_METHOD_PARAMS_1(max, this_ptr, "getoption", c1, PH_NO_CHECK);
		PHALCON_INIT_VAR(r0);
		is_smaller_function(r0, max, value_length TSRMLS_CC);
		if (zend_is_true(r0)) {
			PHALCON_INIT_VAR(message0);
			PHALCON_CONCAT_SVSVS(message0, "Value of field '", field_name, "' exceeds the maximum ", max, " characters");
			PHALCON_INIT_VAR(c3);
			ZVAL_STRING(c3, "too_long", 1);

			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message0, field_name, c3, PH_NO_CHECK);

			ZVAL_BOOL(failed, 1);
		}
	}

	//validate the min
	if (zend_is_true(min_is_set)) {
		PHALCON_INIT_VAR(min);
		PHALCON_CALL_METHOD_PARAMS_1(min, this_ptr, "getoption", c2, PH_NO_CHECK);
		PHALCON_INIT_VAR(r1);
		is_smaller_function(r1, value_length, min TSRMLS_CC);
		if (zend_is_true(r1)) {
			PHALCON_INIT_VAR(message1);
			PHALCON_CONCAT_SVSVS(message1, "Value of field '", field_name, "' is less than the minimum ", min, " characters");
			PHALCON_INIT_VAR(c4);
			ZVAL_STRING(c4, "too_short", 1);
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message1, field_name, c4, PH_NO_CHECK);

			ZVAL_BOOL(failed, 1);
		}
	}

	if (zend_is_true(failed)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}

	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Regex){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Regex, mvc_model_validator_regex, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_regex_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_regex_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_Regex, validate){

	zval *record, *option = NULL, *field_name, *is_set, *value;
	zval *failed = NULL, *matches, *pattern, *match_pattern;
	zval *match_zero, *type, *message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "pattern", 1);
	
	PHALCON_INIT_VAR(is_set);
	PHALCON_CALL_METHOD_PARAMS_1(is_set, this_ptr, "issetoption", option, PH_NO_CHECK);
	if (!zend_is_true(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Validator requires a perl-compatible regex pattern");
		return;
	}
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(failed);
	ZVAL_BOOL(failed, 0);
	
	PHALCON_INIT_VAR(matches);
	
	PHALCON_INIT_VAR(pattern);
	PHALCON_CALL_METHOD_PARAMS_1(pattern, this_ptr, "getoption", option, PH_NO_CHECK);
	Z_SET_ISREF_P(matches);
	
	PHALCON_INIT_VAR(match_pattern);
	PHALCON_CALL_FUNC_PARAMS_3(match_pattern, "preg_match", pattern, value, matches);
	Z_UNSET_ISREF_P(matches);
	if (zend_is_true(match_pattern)) {
		PHALCON_INIT_VAR(match_zero);
		phalcon_array_fetch_long(&match_zero, matches, 0, PH_NOISY_CC);
	
		is_not_equal_function(failed, match_zero, value TSRMLS_CC);
	} else {
		ZVAL_BOOL(failed, 1);
	}
	
	if (PHALCON_IS_TRUE(failed)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "regex", 1);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CONCAT_SVS(message, "Value of field '", field_name, "' doesn't match regular expression");
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field_name, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_PresenceOf){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, PresenceOf, mvc_model_validator_presenceof, "phalcon\\mvc\\model\\validator", phalcon_mvc_model_validator_presenceof_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_presenceof_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator_PresenceOf, validate){

	zval *record, *option = NULL, *field_name, *value, *type;
	zval *message = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_INIT_VAR(field_name);
	PHALCON_CALL_METHOD_PARAMS_1(field_name, this_ptr, "getoption", option, PH_NO_CHECK);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(value);
	PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field_name, PH_NO_CHECK);
	if (PHALCON_IS_EMPTY(value)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "PresenceOf", 1);
	
		PHALCON_INIT_NVAR(option);
		ZVAL_STRING(option, "message", 1);
	
		PHALCON_INIT_VAR(message);
		PHALCON_CALL_METHOD_PARAMS_1(message, this_ptr, "getoption", option, PH_NO_CHECK);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "The field '", field_name, "' is required");
		}
	
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(this_ptr, "appendmessage", message, field_name, type, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MessageInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, MessageInterface, mvc_model_messageinterface, phalcon_mvc_model_messageinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, setType);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, getType);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, setMessage);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, getMessage);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, setField);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, getField);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, __toString);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_MessageInterface, __set_state);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Apc){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Apc, mvc_model_metadata_apc, "phalcon\\mvc\\model\\metadata", phalcon_mvc_model_metadata_apc_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_apc_ce, SL("_suffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_metadata_apc_ce, SL("_ttl"), 172800, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_apc_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, __construct){

	zval *options = NULL, *suffix, *ttl, *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("suffix"));
		if (eval_int) {
			PHALCON_INIT_VAR(suffix);
			phalcon_array_fetch_string(&suffix, options, SL("suffix"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_suffix"), suffix TSRMLS_CC);
		}
		eval_int = phalcon_array_isset_string(options, SS("lifetime"));
		if (eval_int) {
			PHALCON_INIT_VAR(ttl);
			phalcon_array_fetch_string(&ttl, options, SL("lifetime"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_ttl"), ttl TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, read){

	zval *key, *suffix, *apc_key, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(suffix);
	phalcon_read_property(&suffix, this_ptr, SL("_suffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(apc_key);
	PHALCON_CONCAT_SVV(apc_key, "$PMM$", suffix, key);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_FUNC_PARAMS_1(data, "apc_fetch", apc_key);
	if (Z_TYPE_P(data) == IS_ARRAY) { 
	
		RETURN_CCTOR(data);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, write){

	zval *key, *data, *suffix, *apc_key, *ttl;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(suffix);
	phalcon_read_property(&suffix, this_ptr, SL("_suffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(apc_key);
	PHALCON_CONCAT_SVV(apc_key, "$PMM$", suffix, key);
	
	PHALCON_INIT_VAR(ttl);
	phalcon_read_property(&ttl, this_ptr, SL("_ttl"), PH_NOISY_CC);
	PHALCON_CALL_FUNC_PARAMS_3_NORETURN("apc_store", apc_key, data, ttl);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Session){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Session, mvc_model_metadata_session, "phalcon\\mvc\\model\\metadata", phalcon_mvc_model_metadata_session_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_session_ce, SL("_suffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_session_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, __construct){

	zval *options = NULL, *suffix, *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("suffix"));
		if (eval_int) {
			PHALCON_INIT_VAR(suffix);
			phalcon_array_fetch_string(&suffix, options, SL("suffix"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_suffix"), suffix TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, read){

	zval *key, *session = NULL, *suffix, *suffix_key, *meta_data;
	zval *g0 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(session, g0);
	
	PHALCON_INIT_VAR(suffix);
	phalcon_read_property(&suffix, this_ptr, SL("_suffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(suffix_key);
	PHALCON_CONCAT_SV(suffix_key, "$PMM$", suffix);
	eval_int = phalcon_array_isset(session, suffix_key);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, session, suffix_key, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, key);
		if (eval_int) {
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch(&r1, session, suffix_key, PH_NOISY_CC);
			PHALCON_INIT_VAR(meta_data);
			phalcon_array_fetch(&meta_data, r1, key, PH_NOISY_CC);
	
			RETURN_CCTOR(meta_data);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, write){

	zval *key, *data, *suffix, *suffix_key;
	zval *g0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(suffix);
	phalcon_read_property(&suffix, this_ptr, SL("_suffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(suffix_key);
	PHALCON_CONCAT_SV(suffix_key, "$PMM$", suffix);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	phalcon_array_update_multi_2(&g0, suffix_key, key, &data, 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Memory, mvc_model_metadata_memory, "phalcon\\mvc\\model\\metadata", phalcon_mvc_model_metadata_memory_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_metadata_memory_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, __construct){

	zval *options = NULL, *empty_array;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, read){

	zval *key;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key) == FAILURE) {
		RETURN_NULL();
	}

	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, write){

	zval *key, *meta_data;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &meta_data) == FAILURE) {
		RETURN_NULL();
	}

	RETURN_NULL();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Files){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Files, mvc_model_metadata_files, "phalcon\\mvc\\model\\metadata", phalcon_mvc_model_metadata_files_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_files_ce, SL("_metaDataDir"), "./", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_files_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, __construct){

	zval *options = NULL, *meta_data_dir, *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	eval_int = phalcon_array_isset_string(options, SS("metaDataDir"));
	if (eval_int) {
		PHALCON_INIT_VAR(meta_data_dir);
		phalcon_array_fetch_string(&meta_data_dir, options, SL("metaDataDir"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_metaDataDir"), meta_data_dir TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_metaData"), empty_array TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, read){

	zval *key, *meta_data_dir, *path, *data;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(meta_data_dir);
	phalcon_read_property(&meta_data_dir, this_ptr, SL("_metaDataDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VV(path, meta_data_dir, key);
	if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(data);
		if (phalcon_require_ret(data, path TSRMLS_CC) == FAILURE) {
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, write){

	zval *key, *data, *meta_data_dir, *path;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(meta_data_dir);
	phalcon_read_property(&meta_data_dir, this_ptr, SL("_metaDataDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VV(path, meta_data_dir, key);
	PHALCON_CALL_FUNC_PARAMS_2_NORETURN("file_put_contents", path, data);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_TransactionInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, TransactionInterface, mvc_model_transactioninterface, phalcon_mvc_model_transactioninterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, setTransactionManager);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, begin);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, commit);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, rollback);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, getConnection);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, setIsNewTransaction);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, setRollbackOnAbort);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, isManaged);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, getMessages);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, isValid);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_TransactionInterface, setRollbackedRecord);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Manager, mvc_model_manager, phalcon_mvc_model_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasMany"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasOne"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_belongsTo"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_initialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_lastInitialized"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_manager_ce TSRMLS_CC, 3, phalcon_mvc_model_managerinterface_ce, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, __construct){


	phalcon_update_property_empty_array(phalcon_mvc_model_manager_ce, this_ptr, SL("_hasMany") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_model_manager_ce, this_ptr, SL("_hasOne") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_model_manager_ce, this_ptr, SL("_belongsTo") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_model_manager_ce, this_ptr, SL("_initialized") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The dependency injector is invalid");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, initialize){

	zval *model, *class_name, *initialized, *events_manager;
	zval *event_name;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(initialized, class_name);
	if (!eval_int) {
		if (phalcon_method_exists_ex(model, SS("initialize") TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD_NORETURN(model, "initialize", PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_initialized"), PH_NOISY_CC);
		phalcon_array_update_zval_bool(&t0, class_name, 1, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_initialized"), t0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_lastInitialized"), model TSRMLS_CC);
	
		PHALCON_INIT_VAR(events_manager);
		phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "modelsManager:afterInitialize", 1);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		}
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, isInitialized){

	zval *model_name, *initialized, *is_intitialized = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(initialized, model_name);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(is_intitialized, r0);
	
	RETURN_NCTOR(is_intitialized);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getLastInitialized){


	RETURN_MEMBER(this_ptr, "_lastInitialized");
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, load){

	zval *model_name, *model, *exception_message;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_class_exists(model_name TSRMLS_CC)) {
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	
		RETURN_CTOR(model);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "The model '", model_name, "' could not be loaded");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasOne){

	zval *model, *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *entity_name, *has_one, *number_fields;
	zval *number_referenced, *diferent_fields;
	zval *relation;
	zval *a0 = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(has_one);
	phalcon_read_property(&has_one, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_one, entity_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		phalcon_array_update_zval(&has_one, entity_name, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(r0);
	phalcon_array_fetch(&r0, has_one, entity_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_INIT_VAR(number_fields);
			phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(number_referenced);
			phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(diferent_fields);
			is_not_equal_function(diferent_fields, number_fields, number_referenced TSRMLS_CC);
			if (PHALCON_IS_TRUE(diferent_fields)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
	
		PHALCON_INIT_VAR(relation);
		array_init(relation);
		phalcon_array_update_string(&relation, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_hasOne"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t0, entity_name, reference_model, &relation, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasOne"), t0 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, addBelongsTo){

	zval *model, *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *model_name, *belongs_to, *number_fields;
	zval *number_referenced, *diferent_fields;
	zval *relation;
	zval *a0 = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(belongs_to);
	phalcon_read_property(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(belongs_to, model_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		phalcon_array_update_zval(&belongs_to, model_name, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(r0);
	phalcon_array_fetch(&r0, belongs_to, model_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_INIT_VAR(number_fields);
			phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(number_referenced);
			phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(diferent_fields);
			is_not_equal_function(diferent_fields, number_fields, number_referenced TSRMLS_CC);
			if (PHALCON_IS_TRUE(diferent_fields)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
	
		PHALCON_INIT_VAR(relation);
		array_init(relation);
		phalcon_array_update_string(&relation, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t0, model_name, reference_model, &relation, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_belongsTo"), t0 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasMany){

	zval *model, *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *entity_name, *has_many, *number_fields;
	zval *number_referenced, *diferent_fields;
	zval *relation;
	zval *a0 = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &model, &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(has_many);
	phalcon_read_property(&has_many, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_many, entity_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		phalcon_array_update_zval(&has_many, entity_name, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(r0);
	phalcon_array_fetch(&r0, has_many, entity_name, PH_NOISY_CC);
	eval_int = phalcon_array_isset(r0, reference_model);
	if (!eval_int) {
		if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
			PHALCON_INIT_VAR(number_fields);
			phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(number_referenced);
			phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
	
			PHALCON_INIT_VAR(diferent_fields);
			is_not_equal_function(diferent_fields, number_fields, number_referenced TSRMLS_CC);
			if (PHALCON_IS_TRUE(diferent_fields)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
				return;
			}
		}
	
		PHALCON_INIT_VAR(relation);
		array_init(relation);
		phalcon_array_update_string(&relation, SL("fi"), &fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rt"), &reference_model, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("rf"), &referenced_fields, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&relation, SL("op"), &options, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_hasMany"), PH_NOISY_CC);
		phalcon_array_update_multi_2(&t0, entity_name, reference_model, &relation, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_hasMany"), t0 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, existsBelongsTo){

	zval *model_name, *model_relation, *initialized;
	zval *model = NULL, *belongs_to;
	zval *r0 = NULL;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(initialized, model_name);
	if (!eval_int) {
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	eval_int = phalcon_array_isset(initialized, model_relation);
	if (!eval_int) {
		ce1 = phalcon_fetch_class(model_relation TSRMLS_CC);
		PHALCON_INIT_NVAR(model);
		object_init_ex(model, ce1);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	PHALCON_INIT_VAR(belongs_to);
	phalcon_read_property(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(belongs_to, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, belongs_to, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasMany){

	zval *model_name, *model_relation, *initialized;
	zval *model = NULL, *has_many;
	zval *r0 = NULL;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(initialized, model_name);
	if (!eval_int) {
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	eval_int = phalcon_array_isset(initialized, model_relation);
	if (!eval_int) {
		ce1 = phalcon_fetch_class(model_relation TSRMLS_CC);
		PHALCON_INIT_NVAR(model);
		object_init_ex(model, ce1);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	PHALCON_INIT_VAR(has_many);
	phalcon_read_property(&has_many, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_many, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, has_many, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasOne){

	zval *model_name, *model_relation, *initialized;
	zval *model = NULL, *has_one;
	zval *r0 = NULL;
	int eval_int;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &model_name, &model_relation) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initialized);
	phalcon_read_property(&initialized, this_ptr, SL("_initialized"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(initialized, model_name);
	if (!eval_int) {
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	eval_int = phalcon_array_isset(initialized, model_relation);
	if (!eval_int) {
		ce1 = phalcon_fetch_class(model_relation TSRMLS_CC);
		PHALCON_INIT_NVAR(model);
		object_init_ex(model, ce1);
		PHALCON_CALL_METHOD_NORETURN(model, "__construct", PH_CHECK);
	}
	
	PHALCON_INIT_VAR(has_one);
	phalcon_read_property(&has_one, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_one, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, has_one, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, _getRelationRecords){

	zval *relation, *method, *record, *parameters = NULL, *placeholders = NULL;
	zval *pre_conditions = NULL, *conditions = NULL, *fields, *field = NULL;
	zval *value = NULL, *referenced_field = NULL, *condition = NULL, *i;
	zval *referenced_fields, *join_conditions;
	zval *find_params, *find_arguments = NULL, *arguments;
	zval *reference_table, *referenced_entity;
	zval *connection_service, *call_object, *records;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &relation, &method, &record, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	} else {
		PHALCON_SEPARATE_PARAM(parameters);
	}
	
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(parameters, SS("bind"));
		if (eval_int) {
			PHALCON_INIT_VAR(placeholders);
			phalcon_array_fetch_string(&placeholders, parameters, SL("bind"), PH_NOISY_CC);
			PHALCON_SEPARATE_PARAM(parameters);
			phalcon_array_unset_string(parameters, SS("bind"));
		} else {
			PHALCON_INIT_NVAR(placeholders);
			array_init(placeholders);
		}
	} else {
		PHALCON_INIT_NVAR(placeholders);
		array_init(placeholders);
	}
	
	PHALCON_INIT_VAR(pre_conditions);
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_long(parameters, 0);
		if (eval_int) {
			phalcon_array_fetch_long(&pre_conditions, parameters, 0, PH_NOISY_CC);
			PHALCON_SEPARATE_PARAM(parameters);
			phalcon_array_unset_long(parameters, 0);
		} else {
			eval_int = phalcon_array_isset_string(parameters, SS("conditions"));
			if (eval_int) {
				PHALCON_INIT_NVAR(pre_conditions);
				phalcon_array_fetch_string(&pre_conditions, parameters, SL("conditions"), PH_NOISY_CC);
				PHALCON_SEPARATE_PARAM(parameters);
				phalcon_array_unset_string(parameters, SS("conditions"));
			}
		}
	} else {
		if (Z_TYPE_P(parameters) == IS_STRING) {
			PHALCON_CPY_WRT(pre_conditions, parameters);
		}
	}
	
	if (Z_TYPE_P(pre_conditions) != IS_NULL) {
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
		phalcon_array_append(&conditions, pre_conditions, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(conditions);
		array_init(conditions);
	}
	
	PHALCON_INIT_VAR(fields);
	phalcon_array_fetch_string(&fields, relation, SL("fi"), PH_NOISY_CC);
	if (Z_TYPE_P(fields) != IS_ARRAY) { 
		PHALCON_CPY_WRT(field, fields);
	
		PHALCON_INIT_VAR(value);
		PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(referenced_field);
		phalcon_array_fetch_string(&referenced_field, relation, SL("rf"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(condition);
		PHALCON_CONCAT_VS(condition, referenced_field, " = ?0");
		phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 0);
	
		PHALCON_INIT_VAR(referenced_fields);
		phalcon_array_fetch_string(&referenced_fields, relation, SL("rf"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(fields TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(fields);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(field);
	
			PHALCON_INIT_NVAR(value);
			PHALCON_CALL_METHOD_PARAMS_1(value, record, "readattribute", field, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(referenced_field);
			phalcon_array_fetch(&referenced_field, referenced_fields, i, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(condition);
			PHALCON_CONCAT_VSV(condition, referenced_field, " = ?", i);
			phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&placeholders, value, PH_SEPARATE TSRMLS_CC);
			PHALCON_SEPARATE(i);
			increment_function(i);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_INIT_VAR(join_conditions);
	phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
	PHALCON_INIT_VAR(find_params);
	array_init(find_params);
	phalcon_array_append(&find_params, join_conditions, PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&find_params, SL("bind"), &placeholders, PH_COPY | PH_SEPARATE TSRMLS_CC);
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		PHALCON_INIT_VAR(find_arguments);
		PHALCON_CALL_FUNC_PARAMS_2(find_arguments, "array_merge", find_params, parameters);
	} else {
		PHALCON_CPY_WRT(find_arguments, find_params);
	}
	
	PHALCON_INIT_VAR(arguments);
	array_init(arguments);
	phalcon_array_append(&arguments, find_arguments, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(reference_table);
	phalcon_array_fetch_string(&reference_table, relation, SL("rt"), PH_NOISY_CC);
	ce0 = phalcon_fetch_class(reference_table TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_entity);
	object_init_ex(referenced_entity, ce0);
	PHALCON_CALL_METHOD_NORETURN(referenced_entity, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(connection_service);
	PHALCON_CALL_METHOD(connection_service, record, "getconnectionservice", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_entity, "setconnectionservice", connection_service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(call_object);
	array_init(call_object);
	phalcon_array_append(&call_object, referenced_entity, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&call_object, method, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_USER_FUNC_ARRAY(records, call_object, arguments);
	
	RETURN_CCTOR(records);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsToRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *belongs_to, *relation, *records;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &method, &model_name, &model_relation, &record, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(belongs_to);
	phalcon_read_property(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(belongs_to, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, belongs_to, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(r1);
	phalcon_array_fetch(&r1, belongs_to, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_4(records, this_ptr, "_getrelationrecords", relation, method, record, parameters, PH_NO_CHECK);
	
	RETURN_CCTOR(records);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasManyRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *has_many, *relation, *records;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &method, &model_name, &model_relation, &record, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(has_many);
	phalcon_read_property(&has_many, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_many, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, has_many, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(r1);
	phalcon_array_fetch(&r1, has_many, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_4(records, this_ptr, "_getrelationrecords", relation, method, record, parameters, PH_NO_CHECK);
	
	RETURN_CCTOR(records);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *has_one, *relation, *records;
	zval *r0 = NULL, *r1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz|z", &method, &model_name, &model_relation, &record, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(has_one);
	phalcon_read_property(&has_one, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_one, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, has_one, model_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, model_relation);
		if (!eval_int) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(r1);
	phalcon_array_fetch(&r1, has_one, model_name, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(relation);
	phalcon_array_fetch(&relation, r1, model_relation, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_4(records, this_ptr, "_getrelationrecords", relation, method, record, parameters, PH_NO_CHECK);
	
	RETURN_CCTOR(records);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsTo){

	zval *model, *model_name, *belongs_to, *relations;
	zval *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(belongs_to);
	phalcon_read_property(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(belongs_to, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(relations);
		phalcon_array_fetch(&relations, belongs_to, model_name, PH_NOISY_CC);
	
		RETURN_CCTOR(relations);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	
	RETURN_CTOR(empty_array);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasMany){

	zval *model, *model_name, *has_many, *relations;
	zval *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(has_many);
	phalcon_read_property(&has_many, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_many, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(relations);
		phalcon_array_fetch(&relations, has_many, model_name, PH_NOISY_CC);
	
		RETURN_CCTOR(relations);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	
	RETURN_CTOR(empty_array);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOne){

	zval *model, *model_name, *has_one, *relations;
	zval *empty_array;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model TSRMLS_CC);
	
	PHALCON_INIT_VAR(has_one);
	phalcon_read_property(&has_one, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_one, model_name);
	if (eval_int) {
		PHALCON_INIT_VAR(relations);
		phalcon_array_fetch(&relations, has_one, model_name, PH_NOISY_CC);
	
		RETURN_CCTOR(relations);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	
	RETURN_CTOR(empty_array);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneAndHasMany){

	zval *model, *has_one, *has_many, *merge;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &model) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(has_one);
	PHALCON_CALL_METHOD_PARAMS_1(has_one, this_ptr, "gethasone", model, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(has_many);
	PHALCON_CALL_METHOD_PARAMS_1(has_many, this_ptr, "gethasmany", model, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(merge);
	PHALCON_CALL_FUNC_PARAMS_2(merge, "array_merge", has_one, has_many);
	
	RETURN_CCTOR(merge);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelations){

	zval *first, *second, *belongs_to, *relation = NULL, *has_many;
	zval *has_one;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &first, &second) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(belongs_to);
	phalcon_read_property(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(belongs_to, first);
	if (eval_int) {
		PHALCON_INIT_VAR(r0);
		phalcon_array_fetch(&r0, belongs_to, first, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r0, second);
		if (eval_int) {
			PHALCON_INIT_VAR(r1);
			phalcon_array_fetch(&r1, belongs_to, first, PH_NOISY_CC);
			PHALCON_INIT_VAR(relation);
			phalcon_array_fetch(&relation, r1, second, PH_NOISY_CC);
	
			RETURN_CCTOR(relation);
		}
	}
	
	PHALCON_INIT_VAR(has_many);
	phalcon_read_property(&has_many, this_ptr, SL("_hasMany"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_many, first);
	if (eval_int) {
		PHALCON_INIT_VAR(r2);
		phalcon_array_fetch(&r2, has_many, first, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r2, second);
		if (eval_int) {
			PHALCON_INIT_VAR(r3);
			phalcon_array_fetch(&r3, has_many, first, PH_NOISY_CC);
			PHALCON_INIT_NVAR(relation);
			phalcon_array_fetch(&relation, r3, second, PH_NOISY_CC);
	
			RETURN_CCTOR(relation);
		}
	}
	
	PHALCON_INIT_VAR(has_one);
	phalcon_read_property(&has_one, this_ptr, SL("_hasOne"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(has_one, first);
	if (eval_int) {
		PHALCON_INIT_VAR(r4);
		phalcon_array_fetch(&r4, has_one, first, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r4, second);
		if (eval_int) {
			PHALCON_INIT_VAR(r5);
			phalcon_array_fetch(&r5, has_one, first, PH_NOISY_CC);
			PHALCON_INIT_NVAR(relation);
			phalcon_array_fetch(&relation, r5, second, PH_NOISY_CC);
	
			RETURN_CCTOR(relation);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, createQuery){

	zval *phql, *dependency_injector, *query;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &phql) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injection object is required to access ORM services");
		return;
	}
	
	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "__construct", phql, PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "setdi", dependency_injector, PH_NO_CHECK);
	
	RETURN_CTOR(query);
}

PHP_METHOD(Phalcon_Mvc_Model_Manager, executeQuery){

	zval *phql, *placeholders = NULL, *dependency_injector;
	zval *query, *result;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &phql, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injection object is required to access ORM services");
		return;
	}
	
	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "__construct", phql, PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(query, "setdi", dependency_injector, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_1(result, query, "execute", placeholders, PH_NO_CHECK);
	
	RETURN_CCTOR(result);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Status){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Query, Status, mvc_model_query_status, phalcon_mvc_model_query_status_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_query_status_ce, SL("_success"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_status_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_query_status_ce TSRMLS_CC, 1, phalcon_mvc_model_query_statusinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Query_Status, __construct){

	zval *success, *model;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &success, &model) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_success"), success TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_model"), model TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getModel){


	RETURN_MEMBER(this_ptr, "_model");
}

PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getMessages){

	zval *model, *messages, *empty_arr;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(model);
	phalcon_read_property(&model, this_ptr, SL("_model"), PH_NOISY_CC);
	if (Z_TYPE_P(model) == IS_OBJECT) {
		PHALCON_INIT_VAR(messages);
		PHALCON_CALL_METHOD(messages, model, "getmessages", PH_NO_CHECK);
	
		RETURN_CCTOR(messages);
	}
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	
	RETURN_CTOR(empty_arr);
}

PHP_METHOD(Phalcon_Mvc_Model_Query_Status, success){


	RETURN_MEMBER(this_ptr, "_success");
}



/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is include which follows the "include" declaration
** in the input file. */


#ifdef HAVE_CONFIG_H
#endif




static zval *phql_ret_literal_zval(int type, phql_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (T) {
		add_assoc_stringl(ret, "value", T->token, T->token_len, 1);
		efree(T->token);
		efree(T);
	}

	return ret;
}

static zval *phql_ret_placeholder_zval(int type, phql_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	add_assoc_stringl(ret, "value", T->token, T->token_len, 1);
	efree(T->token);
	efree(T);

	return ret;
}

static zval *phql_ret_qualified_name(phql_parser_token *A, phql_parser_token *B)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHQL_T_QUALIFIED);
	if (B != NULL) {
		add_assoc_stringl(ret, "domain", A->token, A->token_len, 1);
		add_assoc_stringl(ret, "name", B->token, B->token_len, 1);
		efree(B->token);
		efree(B);
	} else {
		add_assoc_stringl(ret, "name", A->token, A->token_len, 1);
	}
	efree(A->token);
	efree(A);

	return ret;
}

static zval *phql_ret_select_statement(zval *S, zval *W, zval *O, zval *G, zval *H, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHQL_T_SELECT);
	add_assoc_zval(ret, "select", S);

	if (W != NULL) {
		add_assoc_zval(ret, "where", W);
	}
	if (O != NULL) {
		add_assoc_zval(ret, "orderBy", O);
	}
	if (G != NULL) {
		add_assoc_zval(ret, "groupBy", G);
	}
	if (H != NULL) {
		add_assoc_zval(ret, "having", H);
	}
	if (L != NULL) {
		add_assoc_zval(ret, "limit", L);
	}

	return ret;
}

static zval *phql_ret_select_clause(zval *columns, zval *tables, zval *join_list)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "columns", columns);
	add_assoc_zval(ret, "tables", tables);
	if (join_list) {
		add_assoc_zval(ret, "joins", join_list);
	}

	return ret;
}

static zval *phql_ret_order_item(zval *column, int sort){

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "column", column);
	if (sort != 0 ) {
		add_assoc_long(ret, "sort", sort);
	}

	return ret;
}

static zval *phql_ret_select_limit_clause(phql_parser_token *L, phql_parser_token *O)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_stringl(ret, "number", L->token, L->token_len, 1);
	efree(L->token);
	efree(L);

	if (O != NULL) {
		add_assoc_stringl(ret, "offset", O->token, O->token_len, 1);
		efree(O->token);
		efree(O);
	}

	return ret;
}

static zval *phql_ret_insert_statement(zval *Q, zval *F, zval *V)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHQL_T_INSERT);
	add_assoc_zval(ret, "qualifiedName", Q);
	if (F != NULL) {
		add_assoc_zval(ret, "fields", F);
	}
	add_assoc_zval(ret, "values", V);

	return ret;
}

static zval *phql_ret_update_statement(zval *U, zval *W, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHQL_T_UPDATE);
	add_assoc_zval(ret, "update", U);
	if (W != NULL) {
		add_assoc_zval(ret, "where", W);
	}
	if (L != NULL) {
		add_assoc_zval(ret, "limit", L);
	}

	return ret;
}

static zval *phql_ret_update_clause(zval *tables, zval *values)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "tables", tables);
	add_assoc_zval(ret, "values", values);

	return ret;
}

static zval *phql_ret_update_item(zval *column, zval *expr)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "column", column);
	add_assoc_zval(ret, "expr", expr);

	return ret;
}

static zval *phql_ret_delete_statement(zval *D, zval *W, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHQL_T_DELETE);
	add_assoc_zval(ret, "delete", D);
	if (W != NULL) {
		add_assoc_zval(ret, "where", W);
	}
	if (L != NULL) {
		add_assoc_zval(ret, "limit", L);
	}

	return ret;
}

static zval *phql_ret_delete_clause(zval *tables)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "tables", tables);

	return ret;
}

static zval *phql_ret_zval_list(zval *list_left, zval *right_list)
{

	zval *ret;
	HashPosition pos;
	HashTable *list;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	list = Z_ARRVAL_P(list_left);
	if (zend_hash_index_exists(list, 0)) {
		zend_hash_internal_pointer_reset_ex(list, &pos);
		for (;; zend_hash_move_forward_ex(list, &pos)) {

			zval ** item;

			if (zend_hash_get_current_data_ex(list, (void**)&item, &pos) == FAILURE) {
				break;
			}

			Z_ADDREF_PP(item);
			add_next_index_zval(ret, *item);

		}
		zval_ptr_dtor(&list_left);
	} else {
		add_next_index_zval(ret, list_left);
	}

	add_next_index_zval(ret, right_list);

	return ret;
}

static zval *phql_ret_column_item(int type, zval *column, phql_parser_token *identifier_column, phql_parser_token *alias)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (column) {
		add_assoc_zval(ret, "column", column);
	}
	if (identifier_column) {
		add_assoc_stringl(ret, "column", identifier_column->token, identifier_column->token_len, 1);
		efree(identifier_column->token);
		efree(identifier_column);
	}
	if (alias) {
		add_assoc_stringl(ret, "alias", alias->token, alias->token_len, 1);
		efree(alias->token);
		efree(alias);
	}

	return ret;
}

static zval *phql_ret_assoc_name(zval *qualified_name, phql_parser_token *alias)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "qualifiedName", qualified_name);
	if (alias) {
		add_assoc_stringl(ret, "alias", alias->token, alias->token_len, 1);
		efree(alias->token);
		efree(alias);
	}

	return ret;

}

static zval *phql_ret_join_item(zval *join, phql_parser_token *alias)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "join", join);
	if (alias) {
		add_assoc_stringl(ret, "alias", alias->token, alias->token_len, 1);
		efree(alias->token);
		efree(alias);
	}

	return ret;

}

static zval *phql_ret_join_clause(int type, zval *qualified_name, zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	add_assoc_zval(ret, "qualifiedName", qualified_name);
	if (expr) {
		add_assoc_zval(ret, "expr", expr);
	}

	return ret;
}

static zval *phql_ret_expr(int type, zval *left, zval *right)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (left) {
		add_assoc_zval(ret, "left", left);
	}
	if (right) {
		add_assoc_zval(ret, "right", right);
	}

	return ret;
}

static zval *phql_ret_func_call(phql_parser_token *name, zval *arguments)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHQL_T_FCALL);
	add_assoc_stringl(ret, "name", name->token, name->token_len, 1);
	efree(name->token);
	efree(name);

	if (arguments) {
		add_assoc_zval(ret, "arguments", arguments);
	}

	return ret;
}


/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    YYNOCODE           is a number of type YYCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash 
**                       table.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    YYACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    phql_TOKENTYPE     is the data type used for minor tokens given 
**                       directly to the parser from the tokenizer.
**    YYMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is phql_TOKENTYPE.  The entry in the union
**                       for base tokens is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.
**    phql_ARG_SDECL     A static variable declaration for the %extra_argument
**    phql_ARG_PDECL     A parameter declaration for the %extra_argument
**    phql_ARG_STORE     Code to store %extra_argument into yypParser
**    phql_ARG_FETCH     Code to extract %extra_argument from yypParser
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define YYCODETYPE unsigned char
#define YYNOCODE 98
#define YYACTIONTYPE unsigned short int
#define phql_TOKENTYPE phql_parser_token*
typedef union {
  phql_TOKENTYPE yy0;
  zval* yy66;
  int yy195;
} YYMINORTYPE;
#define YYSTACKDEPTH 100
#define phql_ARG_SDECL phql_parser_status *status;
#define phql_ARG_PDECL ,phql_parser_status *status
#define phql_ARG_FETCH phql_parser_status *status = yypParser->status
#define phql_ARG_STORE yypParser->status = status
#define YYNSTATE 244
#define YYNRULE 143
#define YYERRORSYMBOL 55
#define YYERRSYMDT yy195
#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)
#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)
#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)

/* Next are that tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   YYNSTATE <= N < YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.
**
**   N == YYNSTATE+YYNRULE              A syntax error has occurred.
**
**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.
**
**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as
**
**      yy_action[ yy_shift_ofst[S] + X ]
**
** If the index value yy_shift_ofst[S]+X is out of range or if the value
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
** and that yy_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
** YY_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
*/
static YYACTIONTYPE yy_action[] = {
 /*     0 */    55,   57,   59,   61,   63,   65,   51,   53,   67,   47,
 /*    10 */    45,   49,   43,   40,   75,   72,   69,    7,  117,  119,
 /*    20 */   196,  127,  194,  104,   55,   57,   59,   61,   63,   65,
 /*    30 */    51,   53,   67,   47,   45,   49,   43,   40,   75,   72,
 /*    40 */    69,   55,   57,   59,   61,   63,   65,   51,   53,   67,
 /*    50 */    47,   45,   49,   43,   40,   75,   72,   69,   89,   94,
 /*    60 */    35,   41,   17,   37,   90,  135,  136,  137,   83,   51,
 /*    70 */    53,   67,   47,   45,   49,   43,   40,   75,   72,   69,
 /*    80 */   114,   89,   92,   87,   41,  131,   77,   90,  197,  193,
 /*    90 */   313,   83,   96,  249,   95,  111,  116,   99,   97,   98,
 /*   100 */   100,  101,  207,  189,   29,   92,   41,   95,  214,   90,
 /*   110 */   263,  208,   82,  190,   24,   96,   23,   34,   26,   76,
 /*   120 */    99,   97,   98,  100,  101,   82,  315,   92,   41,   31,
 /*   130 */   128,   90,  133,  128,   21,   83,  186,   96,  223,  109,
 /*   140 */   181,   10,   99,   97,   98,  100,  101,  192,  141,   92,
 /*   150 */   145,  150,  153,   30,  163,  173,  134,   33,   10,   96,
 /*   160 */   185,  136,  137,  228,   99,   97,   98,  100,  101,   67,
 /*   170 */    47,   45,   49,   43,   40,   75,   72,   69,  388,    1,
 /*   180 */     2,    3,    4,    5,    6,   47,   45,   49,   43,   40,
 /*   190 */    75,   72,   69,  179,   29,    8,   16,  141,  108,  145,
 /*   200 */   150,  153,   31,  163,  173,  220,   18,   25,   26,   20,
 /*   210 */   237,   43,   40,   75,   72,   69,   74,  250,  207,  132,
 /*   220 */   187,   95,  232,   95,  203,   74,  267,  208,   74,  205,
 /*   230 */    95,  231,  227,   95,  252,  161,  181,  207,   85,   82,
 /*   240 */    88,   82,   95,  130,  230,  215,  206,   79,   82,   88,
 /*   250 */   105,   82,   88,  188,  193,  268,  235,  198,   21,   95,
 /*   260 */    82,   95,  226,  109,  241,   10,  160,   21,   75,   72,
 /*   270 */    69,  234,  260,   38,   10,   21,  345,   82,   74,   82,
 /*   280 */    31,   38,   10,   95,  167,   62,   64,  144,   66,   95,
 /*   290 */    95,   95,   95,   95,  149,  120,   12,  122,  126,   95,
 /*   300 */    68,   82,  102,  253,  115,   95,  233,   82,   82,   82,
 /*   310 */    82,   82,  159,  157,   71,  162,  172,   82,   95,   95,
 /*   320 */    95,   95,  178,   82,   91,   14,   93,   95,  164,   95,
 /*   330 */    39,   95,  322,  168,  258,   95,   82,   82,   82,   82,
 /*   340 */   156,   44,  269,   46,   21,   82,   95,   82,   95,   82,
 /*   350 */   107,   10,   42,   82,   48,   95,   50,   95,   52,   95,
 /*   360 */   232,   95,   54,   95,   82,   56,   82,   95,  229,  236,
 /*   370 */    95,   58,  128,   82,  251,   82,   95,   82,  261,   82,
 /*   380 */   223,   82,  129,   21,   60,   82,  323,   95,   82,   95,
 /*   390 */    10,  238,   81,  221,   82,  314,   70,  210,  254,  154,
 /*   400 */   219,   27,   28,  103,  158,   82,   32,   82,   80,  184,
 /*   410 */   262,  182,  240,  243,  225,  191,   81,  181,  256,   84,
 /*   420 */    81,  180,   10,  216,  205,  181,   10,  140,   84,  138,
 /*   430 */   123,  114,  106,  125,  223,  272,   86,  143,  155,  211,
 /*   440 */   204,  201,  209,  223,  257,  142,   10,  113,  239,  325,
 /*   450 */   324,  177,  242,  152,  112,   22,    9,  148,   10,  139,
 /*   460 */   151,  118,  264,  248,   32,   15,   10,  147,  346,  183,
 /*   470 */   244,  245,   33,  347,   13,   78,  247,  195,   36,  255,
 /*   480 */   259,  110,  121,   69,  175,  199,  200,  265,  202,  305,
 /*   490 */   174,  176,   11,  170,  171,  218,  169,  246,  212,  165,
 /*   500 */   213,  306,  166,  217,   19,  271,  266,  124,  146,  270,
 /*   510 */    73,  222,  316,  348,  242,  242,  242,  242,  242,  242,
 /*   520 */   242,  242,  242,  224,
};
static YYCODETYPE yy_lookahead[] = {
 /*     0 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*    10 */    11,   12,   13,   14,   15,   16,   17,   63,   64,   65,
 /*    20 */    21,   67,   23,   35,    1,    2,    3,    4,    5,    6,
 /*    30 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*    40 */    17,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*    50 */    10,   11,   12,   13,   14,   15,   16,   17,   11,   36,
 /*    60 */    64,   14,   66,   67,   17,   74,   75,   76,   21,    7,
 /*    70 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*    80 */    77,   11,   35,   36,   14,   68,   17,   17,   71,   72,
 /*    90 */     0,   21,   45,    0,   77,   92,   93,   50,   51,   52,
 /*   100 */    53,   54,   72,   11,   77,   35,   14,   77,   78,   17,
 /*   110 */     0,   81,   95,   21,   20,   45,   89,   90,   91,   50,
 /*   120 */    50,   51,   52,   53,   54,   95,    0,   35,   14,   21,
 /*   130 */    40,   17,   69,   40,   41,   21,   73,   45,   48,   46,
 /*   140 */    77,   48,   50,   51,   52,   53,   54,   11,   24,   35,
 /*   150 */    26,   27,   28,   45,   30,   31,   70,   21,   48,   45,
 /*   160 */    74,   75,   76,   38,   50,   51,   52,   53,   54,    9,
 /*   170 */    10,   11,   12,   13,   14,   15,   16,   17,   56,   57,
 /*   180 */    58,   59,   60,   61,   62,   10,   11,   12,   13,   14,
 /*   190 */    15,   16,   17,   20,   77,   64,   65,   24,   67,   26,
 /*   200 */    27,   28,   21,   30,   31,   83,   64,   90,   91,   67,
 /*   210 */    88,   13,   14,   15,   16,   17,   72,    0,   72,   19,
 /*   220 */    20,   77,   77,   77,   78,   72,    0,   81,   72,   20,
 /*   230 */    77,   86,   73,   77,    0,   25,   77,   72,   94,   95,
 /*   240 */    96,   95,   77,   18,   20,   36,   81,   94,   95,   96,
 /*   250 */    94,   95,   96,   71,   72,    0,   72,   32,   41,   77,
 /*   260 */    95,   77,   37,   46,   39,   48,   77,   41,   15,   16,
 /*   270 */    17,   87,    0,   47,   48,   41,    0,   95,   72,   95,
 /*   280 */    21,   47,   48,   77,   72,   72,   72,   72,   72,   77,
 /*   290 */    77,   77,   77,   77,   72,   64,   20,   66,   67,   77,
 /*   300 */    72,   95,   96,    0,   45,   77,    1,   95,   95,   95,
 /*   310 */    95,   95,   24,   72,   72,   72,   72,   95,   77,   77,
 /*   320 */    77,   77,   72,   95,   72,   49,   72,   77,   24,   77,
 /*   330 */    72,   77,    0,   29,    0,   77,   95,   95,   95,   95,
 /*   340 */    25,   72,    0,   72,   41,   95,   77,   95,   77,   95,
 /*   350 */    72,   48,   72,   95,   72,   77,   72,   77,   72,   77,
 /*   360 */    77,   77,   72,   77,   95,   72,   95,   77,   85,   86,
 /*   370 */    77,   72,   40,   95,    0,   95,   77,   95,    0,   95,
 /*   380 */    48,   95,   72,   41,   72,   95,    0,   77,   95,   77,
 /*   390 */    48,   63,   20,   63,   95,    0,    9,   79,    0,   24,
 /*   400 */    82,   43,   44,   16,   29,   95,   22,   95,   36,   21,
 /*   410 */     0,   23,   84,   73,   84,   22,   20,   77,    0,   35,
 /*   420 */    20,   73,   48,   20,   20,   77,   48,   21,   35,   23,
 /*   430 */    64,   77,   36,   67,   48,    0,   36,   25,   77,   36,
 /*   440 */    36,   34,   35,   48,    0,   77,   48,   93,   84,    0,
 /*   450 */     0,   25,   19,   77,   20,   42,   67,   25,   48,   21,
 /*   460 */    24,   67,    0,    0,   22,   45,   48,   77,    0,   21,
 /*   470 */     0,    0,   21,    0,   45,   50,    0,   21,   67,    0,
 /*   480 */     0,   42,   67,   17,   24,   33,   77,    0,   35,    0,
 /*   490 */    29,   77,   45,   77,   25,   21,   24,    0,   34,   77,
 /*   500 */    35,    0,   25,   82,   67,    0,    0,   67,   24,    0,
 /*   510 */    35,   84,    0,    0,   97,   97,   97,   97,   97,   97,
 /*   520 */    97,   97,   97,   45,
};
#define YY_SHIFT_USE_DFLT (-13)
static short yy_shift_ofst[] = {
 /*     0 */   225,  470,  471,  497,  476,  463,   93,  217,  374,  334,
 /*    10 */   447,  276,  429,  468,  420,  473,  234,  303,  418,  506,
 /*    20 */   272,  413,  108,   94,  108,  -13,  358,  -13,  -13,  -13,
 /*    30 */   -13,  442,  451,  -13,  -13,  398,  479,  480,  114,   40,
 /*    40 */   114,  114,  253,  114,  253,  114,  198,  114,  198,  114,
 /*    50 */   198,  114,  160,  114,  160,  114,   62,  114,   62,  114,
 /*    60 */    62,  114,   62,  114,   62,  114,   62,  114,  175,  387,
 /*    70 */   114,  466,  475,   70,   40,   69,  -13,  425,  -13,  372,
 /*    80 */   -13,   70,  -13,  384,   47,  400,  -13,  -13,  -13,  -13,
 /*    90 */   114,  466,  114,   23,  -13,  -13,  -13,  -13,  -13,  -13,
 /*   100 */   -13,  -13,  -13,  -12,   70,  396,  -13,  253,  444,  439,
 /*   110 */   259,  434,  259,  -13,  -13,  -13,  -13,  378,  462,  226,
 /*   120 */   410,  487,  342,  110,  505,  509,  255,  435,  114,   40,
 /*   130 */    92,  200,  181,  173,  124,  -13,  -13,  406,  438,  -13,
 /*   140 */   -13,  181,  412,  114,   40,  484,  181,  432,  114,   40,
 /*   150 */   436,  181,  -13,  375,  181,  315,  114,   40,  288,  181,
 /*   160 */   210,  114,   40,  304,  181,  477,  114,   40,  472,  181,
 /*   170 */   469,  114,   40,  461,  460,  181,  426,  114,   40,  181,
 /*   180 */   -13,  388,  448,  -13,  -13,  -13,  -13,   92,  -13,  -13,
 /*   190 */   393,  136,  -13,   -1,  456,  -13,  -13,  -13,  452,  181,
 /*   200 */   407,  453,  114,  404,  489,  114,  -13,   40,  -13,  474,
 /*   210 */   403,  464,  465,  114,  209,  501,  474,  -13,  -13,  -13,
 /*   220 */    90,  395,  512,  478,  513,  126,  181,  125,  181,  224,
 /*   230 */   181,  -13,  305,  114,  -13,   40,  -13,  332,  386,  449,
 /*   240 */   450,  433,  181,  -13,
};
#define YY_REDUCE_USE_DFLT (-47)
static short yy_reduce_ofst[] = {
 /*     0 */   122,  -47,  -47,  -47,  -47,  -47,  -46,  131,  389,  -47,
 /*    10 */   -47,  -47,  -47,  -47,  -47,  -47,   -4,  142,  437,  -47,
 /*    20 */   -47,  -47,   27,  -47,  117,  -47,  -47,  -47,  -47,  -47,
 /*    30 */   -47,  -47,  -47,  -47,  -47,  411,  -47,  -47,  258,  -47,
 /*    40 */   278,  280,  -47,  269,  -47,  271,  -47,  282,  -47,  284,
 /*    50 */   -47,  286,  -47,  290,  -47,  293,  -47,  299,  -47,  312,
 /*    60 */   -47,  213,  -47,  214,  -47,  216,  -47,  228,  -47,  -47,
 /*    70 */   242,  -47,  -47,  153,  -47,  -47,  -47,  -47,  -47,  -47,
 /*    80 */   -47,  206,  -47,  -47,  144,  -47,  -47,  -47,  -47,  -47,
 /*    90 */   252,  -47,  254,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
 /*   100 */   -47,  -47,  -47,  -47,  156,  -47,  -47,  -47,  -47,  -47,
 /*   110 */     3,  -47,  354,  -47,  -47,  -47,  -47,  394,  -47,  231,
 /*   120 */   415,  -47,  366,  440,  -47,  -47,  -47,  -47,  310,  -47,
 /*   130 */    17,  -47,   63,   86,   -9,  -47,  -47,  -47,  -47,  -47,
 /*   140 */   -47,  368,  -47,  215,  -47,  -47,  390,  -47,  222,  -47,
 /*   150 */   -47,  376,  -47,  -47,  361,  -47,  241,  -47,  -47,  189,
 /*   160 */   -47,  243,  -47,  -47,  422,  -47,  212,  -47,  -47,  416,
 /*   170 */   -47,  244,  -47,  -47,  -47,  414,  -47,  250,  -47,  348,
 /*   180 */   -47,  -47,  -47,  -47,  -47,  -47,  -47,  182,  -47,  -47,
 /*   190 */   -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  409,
 /*   200 */   -47,  -47,  146,  -47,  -47,  165,  -47,  -47,  -47,  318,
 /*   210 */   -47,  -47,  -47,   30,  -47,  -47,  421,  -47,  -47,  -47,
 /*   220 */   330,  427,  -47,  -47,  -47,  -47,  159,  -47,  283,  -47,
 /*   230 */   145,  -47,  -47,  184,  -47,  -47,  -47,  328,  364,  -47,
 /*   240 */   -47,  -47,  340,  -47,
};
static YYACTIONTYPE yy_default[] = {
 /*     0 */   387,  387,  387,  387,  387,  387,  387,  387,  387,  387,
 /*    10 */   387,  387,  387,  387,  387,  387,  387,  387,  387,  387,
 /*    20 */   387,  387,  387,  331,  387,  332,  334,  335,  336,  337,
 /*    30 */   338,  386,  387,  385,  333,  387,  387,  387,  387,  344,
 /*    40 */   387,  387,  349,  387,  351,  387,  352,  387,  353,  387,
 /*    50 */   354,  387,  355,  387,  356,  387,  357,  387,  358,  387,
 /*    60 */   359,  387,  360,  387,  361,  387,  362,  387,  363,  387,
 /*    70 */   387,  364,  387,  387,  373,  387,  374,  387,  375,  387,
 /*    80 */   365,  387,  367,  386,  387,  387,  368,  369,  371,  372,
 /*    90 */   387,  376,  387,  387,  377,  378,  379,  380,  381,  382,
 /*   100 */   383,  384,  370,  387,  387,  387,  366,  350,  387,  387,
 /*   110 */   387,  339,  387,  340,  342,  343,  341,  387,  387,  387,
 /*   120 */   387,  387,  387,  387,  387,  387,  387,  387,  387,  330,
 /*   130 */   387,  387,  387,  273,  274,  284,  286,  287,  387,  288,
 /*   140 */   289,  387,  290,  387,  291,  387,  387,  292,  387,  293,
 /*   150 */   387,  387,  294,  387,  387,  295,  387,  297,  387,  387,
 /*   160 */   296,  387,  298,  387,  387,  299,  387,  301,  387,  387,
 /*   170 */   300,  387,  302,  387,  387,  387,  303,  387,  304,  387,
 /*   180 */   282,  329,  387,  327,  328,  285,  283,  387,  275,  277,
 /*   190 */   386,  387,  278,  281,  387,  279,  280,  276,  387,  387,
 /*   200 */   387,  387,  387,  387,  387,  387,  307,  309,  308,  387,
 /*   210 */   387,  387,  387,  387,  387,  387,  387,  310,  312,  311,
 /*   220 */   387,  387,  387,  387,  387,  387,  387,  387,  387,  317,
 /*   230 */   387,  318,  387,  387,  320,  321,  319,  387,  387,  387,
 /*   240 */   387,  387,  387,  326,
};
#define YY_SZ_ACTTAB (sizeof(yy_action)/sizeof(yy_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammer, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
};
#endif /* YYFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct yyStackEntry {
  int stateno;       /* The state-number */
  int major;         /* The major token value.  This is the code
                     ** number for the token at this stack level */
  YYMINORTYPE minor; /* The user-supplied minor token value.  This
                     ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct yyParser {
  int yyidx;                    /* Index of top element in stack */
  int yyerrcnt;                 /* Shifts left before out of the error */
  phql_ARG_SDECL                /* A place to hold %extra_argument */
  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
};
typedef struct yyParser yyParser;

#ifndef NDEBUG
static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
void phql_Trace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  if( yyTraceFILE==0 ) yyTracePrompt = 0;
  else if( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *yyTokenName[] = { 
  "$",             "EQUALS",        "NOTEQUALS",     "LESS",        
  "GREATER",       "GREATEREQUAL",  "LESSEQUAL",     "AND",         
  "OR",            "LIKE",          "DIVIDE",        "TIMES",       
  "MOD",           "PLUS",          "MINUS",         "IS",          
  "IN",            "NOT",           "SELECT",        "FROM",        
  "COMMA",         "IDENTIFIER",    "DOT",           "AS",          
  "JOIN",          "ON",            "INNER",         "CROSS",       
  "LEFT",          "OUTER",         "RIGHT",         "FULL",        
  "INSERT",        "INTO",          "VALUES",        "BRACKET_OPEN",
  "BRACKET_CLOSE",  "UPDATE",        "SET",           "DELETE",      
  "WHERE",         "ORDER",         "BY",            "ASC",         
  "DESC",          "INTEGER",       "GROUP",         "HAVING",      
  "LIMIT",         "OFFSET",        "NULL",          "STRING",      
  "DOUBLE",        "NPLACEHOLDER",  "SPLACEHOLDER",  "error",       
  "program",       "query_language",  "select_statement",  "insert_statement",
  "update_statement",  "delete_statement",  "select_clause",  "where_clause",
  "order_clause",  "group_clause",  "having_clause",  "select_limit_clause",
  "column_list",   "associated_name_list",  "join_list",     "column_item", 
  "expr",          "associated_name",  "join_item",     "join_associated_name",
  "join_clause",   "qualified_name",  "values_list",   "field_list",  
  "value_list",    "value_item",    "field_item",    "update_clause",
  "limit_clause",  "update_item_list",  "update_item",   "new_value",   
  "delete_clause",  "order_list",    "order_item",    "order_qualified_or_int",
  "group_list",    "group_item",    "argument_list",  "function_call",
  "argument_item",
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *yyRuleName[] = {
 /*   0 */ "program ::= query_language",
 /*   1 */ "query_language ::= select_statement",
 /*   2 */ "query_language ::= insert_statement",
 /*   3 */ "query_language ::= update_statement",
 /*   4 */ "query_language ::= delete_statement",
 /*   5 */ "select_statement ::= select_clause",
 /*   6 */ "select_statement ::= select_clause where_clause",
 /*   7 */ "select_statement ::= select_clause where_clause order_clause",
 /*   8 */ "select_statement ::= select_clause where_clause group_clause",
 /*   9 */ "select_statement ::= select_clause where_clause group_clause having_clause",
 /*  10 */ "select_statement ::= select_clause where_clause group_clause order_clause",
 /*  11 */ "select_statement ::= select_clause where_clause group_clause order_clause select_limit_clause",
 /*  12 */ "select_statement ::= select_clause where_clause group_clause having_clause order_clause",
 /*  13 */ "select_statement ::= select_clause where_clause select_limit_clause",
 /*  14 */ "select_statement ::= select_clause where_clause order_clause select_limit_clause",
 /*  15 */ "select_statement ::= select_clause where_clause group_clause select_limit_clause",
 /*  16 */ "select_statement ::= select_clause where_clause group_clause having_clause select_limit_clause",
 /*  17 */ "select_statement ::= select_clause order_clause",
 /*  18 */ "select_statement ::= select_clause group_clause order_clause",
 /*  19 */ "select_statement ::= select_clause group_clause having_clause order_clause",
 /*  20 */ "select_statement ::= select_clause order_clause select_limit_clause",
 /*  21 */ "select_statement ::= select_clause group_clause order_clause select_limit_clause",
 /*  22 */ "select_statement ::= select_clause where_clause group_clause having_clause order_clause select_limit_clause",
 /*  23 */ "select_statement ::= select_clause group_clause",
 /*  24 */ "select_statement ::= select_clause group_clause select_limit_clause",
 /*  25 */ "select_statement ::= select_clause group_clause having_clause",
 /*  26 */ "select_statement ::= select_clause group_clause having_clause select_limit_clause",
 /*  27 */ "select_statement ::= select_clause group_clause having_clause order_clause select_limit_clause",
 /*  28 */ "select_statement ::= select_clause select_limit_clause",
 /*  29 */ "select_clause ::= SELECT column_list FROM associated_name_list",
 /*  30 */ "select_clause ::= SELECT column_list FROM associated_name_list join_list",
 /*  31 */ "column_list ::= column_list COMMA column_item",
 /*  32 */ "column_list ::= column_item",
 /*  33 */ "column_item ::= TIMES",
 /*  34 */ "column_item ::= IDENTIFIER DOT TIMES",
 /*  35 */ "column_item ::= expr AS IDENTIFIER",
 /*  36 */ "column_item ::= expr IDENTIFIER",
 /*  37 */ "column_item ::= expr",
 /*  38 */ "associated_name_list ::= associated_name_list COMMA associated_name",
 /*  39 */ "associated_name_list ::= associated_name",
 /*  40 */ "join_list ::= join_list join_item",
 /*  41 */ "join_list ::= join_item",
 /*  42 */ "join_item ::= join_associated_name",
 /*  43 */ "join_associated_name ::= join_clause",
 /*  44 */ "join_associated_name ::= join_clause AS IDENTIFIER",
 /*  45 */ "join_associated_name ::= join_clause IDENTIFIER",
 /*  46 */ "join_clause ::= JOIN qualified_name",
 /*  47 */ "join_clause ::= JOIN qualified_name ON expr",
 /*  48 */ "join_clause ::= INNER JOIN qualified_name",
 /*  49 */ "join_clause ::= INNER JOIN qualified_name ON expr",
 /*  50 */ "join_clause ::= CROSS JOIN qualified_name",
 /*  51 */ "join_clause ::= LEFT JOIN qualified_name",
 /*  52 */ "join_clause ::= LEFT OUTER JOIN qualified_name",
 /*  53 */ "join_clause ::= LEFT JOIN qualified_name ON expr",
 /*  54 */ "join_clause ::= LEFT OUTER JOIN qualified_name ON expr",
 /*  55 */ "join_clause ::= RIGHT JOIN qualified_name",
 /*  56 */ "join_clause ::= RIGHT OUTER JOIN qualified_name",
 /*  57 */ "join_clause ::= RIGHT JOIN qualified_name ON expr",
 /*  58 */ "join_clause ::= RIGHT OUTER JOIN qualified_name ON expr",
 /*  59 */ "join_clause ::= FULL OUTER JOIN qualified_name",
 /*  60 */ "join_clause ::= FULL OUTER JOIN qualified_name ON expr",
 /*  61 */ "insert_statement ::= INSERT INTO qualified_name VALUES BRACKET_OPEN values_list BRACKET_CLOSE",
 /*  62 */ "insert_statement ::= INSERT INTO qualified_name BRACKET_OPEN field_list BRACKET_CLOSE VALUES BRACKET_OPEN values_list BRACKET_CLOSE",
 /*  63 */ "values_list ::= values_list COMMA value_item",
 /*  64 */ "values_list ::= value_item",
 /*  65 */ "value_item ::= expr",
 /*  66 */ "field_list ::= field_list COMMA field_item",
 /*  67 */ "field_list ::= field_item",
 /*  68 */ "field_item ::= IDENTIFIER",
 /*  69 */ "update_statement ::= update_clause",
 /*  70 */ "update_statement ::= update_clause where_clause",
 /*  71 */ "update_statement ::= update_clause limit_clause",
 /*  72 */ "update_statement ::= update_clause where_clause limit_clause",
 /*  73 */ "update_clause ::= UPDATE associated_name SET update_item_list",
 /*  74 */ "update_item_list ::= update_item_list COMMA update_item",
 /*  75 */ "update_item_list ::= update_item",
 /*  76 */ "update_item ::= qualified_name EQUALS new_value",
 /*  77 */ "new_value ::= expr",
 /*  78 */ "delete_statement ::= delete_clause",
 /*  79 */ "delete_statement ::= delete_clause where_clause",
 /*  80 */ "delete_statement ::= delete_clause limit_clause",
 /*  81 */ "delete_statement ::= delete_clause where_clause limit_clause",
 /*  82 */ "delete_clause ::= DELETE FROM associated_name",
 /*  83 */ "associated_name ::= qualified_name AS IDENTIFIER",
 /*  84 */ "associated_name ::= qualified_name IDENTIFIER",
 /*  85 */ "associated_name ::= qualified_name",
 /*  86 */ "where_clause ::= WHERE expr",
 /*  87 */ "order_clause ::= ORDER BY order_list",
 /*  88 */ "order_list ::= order_list COMMA order_item",
 /*  89 */ "order_list ::= order_item",
 /*  90 */ "order_item ::= order_qualified_or_int",
 /*  91 */ "order_item ::= order_qualified_or_int ASC",
 /*  92 */ "order_item ::= order_qualified_or_int DESC",
 /*  93 */ "order_qualified_or_int ::= qualified_name",
 /*  94 */ "order_qualified_or_int ::= INTEGER",
 /*  95 */ "group_clause ::= GROUP BY group_list",
 /*  96 */ "group_list ::= group_list COMMA group_item",
 /*  97 */ "group_list ::= group_item",
 /*  98 */ "group_item ::= qualified_name",
 /*  99 */ "group_item ::= INTEGER",
 /* 100 */ "having_clause ::= HAVING expr",
 /* 101 */ "select_limit_clause ::= LIMIT INTEGER",
 /* 102 */ "select_limit_clause ::= LIMIT INTEGER COMMA INTEGER",
 /* 103 */ "select_limit_clause ::= LIMIT INTEGER OFFSET INTEGER",
 /* 104 */ "limit_clause ::= LIMIT INTEGER",
 /* 105 */ "expr ::= MINUS expr",
 /* 106 */ "expr ::= expr MINUS expr",
 /* 107 */ "expr ::= expr PLUS expr",
 /* 108 */ "expr ::= expr TIMES expr",
 /* 109 */ "expr ::= expr DIVIDE expr",
 /* 110 */ "expr ::= expr MOD expr",
 /* 111 */ "expr ::= expr AND expr",
 /* 112 */ "expr ::= expr OR expr",
 /* 113 */ "expr ::= expr EQUALS expr",
 /* 114 */ "expr ::= expr NOTEQUALS expr",
 /* 115 */ "expr ::= expr LESS expr",
 /* 116 */ "expr ::= expr GREATER expr",
 /* 117 */ "expr ::= expr GREATEREQUAL expr",
 /* 118 */ "expr ::= expr LESSEQUAL expr",
 /* 119 */ "expr ::= expr LIKE expr",
 /* 120 */ "expr ::= expr NOT LIKE expr",
 /* 121 */ "expr ::= expr IN BRACKET_OPEN argument_list BRACKET_CLOSE",
 /* 122 */ "expr ::= expr NOT IN BRACKET_OPEN argument_list BRACKET_CLOSE",
 /* 123 */ "expr ::= function_call",
 /* 124 */ "function_call ::= IDENTIFIER BRACKET_OPEN argument_list BRACKET_CLOSE",
 /* 125 */ "function_call ::= IDENTIFIER BRACKET_OPEN BRACKET_CLOSE",
 /* 126 */ "argument_list ::= argument_list COMMA argument_item",
 /* 127 */ "argument_list ::= argument_item",
 /* 128 */ "argument_item ::= TIMES",
 /* 129 */ "argument_item ::= expr",
 /* 130 */ "expr ::= expr IS NULL",
 /* 131 */ "expr ::= expr IS NOT NULL",
 /* 132 */ "expr ::= NOT expr",
 /* 133 */ "expr ::= BRACKET_OPEN expr BRACKET_CLOSE",
 /* 134 */ "expr ::= qualified_name",
 /* 135 */ "expr ::= INTEGER",
 /* 136 */ "expr ::= STRING",
 /* 137 */ "expr ::= DOUBLE",
 /* 138 */ "expr ::= NULL",
 /* 139 */ "expr ::= NPLACEHOLDER",
 /* 140 */ "expr ::= SPLACEHOLDER",
 /* 141 */ "qualified_name ::= IDENTIFIER DOT IDENTIFIER",
 /* 142 */ "qualified_name ::= IDENTIFIER",
};
#endif /* NDEBUG */

const char *phql_TokenName(int tokenType){
#ifndef NDEBUG
  if( tokenType>0 && tokenType<(sizeof(yyTokenName)/sizeof(yyTokenName[0])) ){
    return yyTokenName[tokenType];
  }else{
    return "Unknown";
  }
#else
  return "";
#endif
}

void *phql_Alloc(void *(*mallocProc)(size_t)){
  yyParser *pParser;
  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );
  if( pParser ){
    pParser->yyidx = -1;
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "yymajor" is the symbol code, and "yypminor" is a pointer to
** the value.
*/
static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){
  switch( yymajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
{
	if ((yypminor->yy0)) {
		efree((yypminor->yy0)->token);
		efree((yypminor->yy0));
	}
}
      break;
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 79:
    case 80:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 88:
    case 89:
    case 90:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
{ zval_ptr_dtor(&(yypminor->yy66)); }
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

static int yy_pop_parser_stack(yyParser *pParser){
  YYCODETYPE yymajor;
  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];

  if( pParser->yyidx<0 ) return 0;
#ifndef NDEBUG
  if( yyTraceFILE && pParser->yyidx>=0 ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yymajor = yytos->major;
  yy_destructor( yymajor, &yytos->minor);
  pParser->yyidx--;
  return yymajor;
}

void phql_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  yyParser *pParser = (yyParser*)p;
  if( pParser==0 ) return;
  while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);
  (*freeProc)((void*)pParser);
}

static int yy_find_shift_action(
  yyParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;
 
  /* if( pParser->yyidx<0 ) return YY_NO_ACTION;  */
  i = yy_shift_ofst[stateno];
  if( i==YY_SHIFT_USE_DFLT ){
    return yy_default[stateno];
  }
  if( iLookAhead==YYNOCODE ){
    return YY_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
    int iFallback;            /* Fallback token */
    if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])
           && (iFallback = yyFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
           yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
      }
#endif
      return yy_find_shift_action(pParser, iFallback);
    }
#endif
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}

static int yy_find_reduce_action(
  yyParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;
 
  i = yy_reduce_ofst[stateno];
  if( i==YY_REDUCE_USE_DFLT ){
    return yy_default[stateno];
  }
  if( iLookAhead==YYNOCODE ){
    return YY_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}

static void yy_shift(
  yyParser *yypParser,          /* The parser to be shifted */
  int yyNewState,               /* The new state to shift in */
  int yyMajor,                  /* The major token to shift in */
  YYMINORTYPE *yypMinor         /* Pointer ot the minor token to shift in */
){
  yyStackEntry *yytos;
  yypParser->yyidx++;
  if( yypParser->yyidx>=YYSTACKDEPTH ){
     phql_ARG_FETCH;
     yypParser->yyidx--;
#ifndef NDEBUG
     if( yyTraceFILE ){
       fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
     }
#endif
     while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
     /* Here code is inserted which will execute if the parser
     ** stack every overflows */
     phql_ARG_STORE; /* Suppress warning about unused %extra_argument var */
     return;
  }
  yytos = &yypParser->yystack[yypParser->yyidx];
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor = *yypMinor;
#ifndef NDEBUG
  if( yyTraceFILE && yypParser->yyidx>0 ){
    int i;
    fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState);
    fprintf(yyTraceFILE,"%sStack:",yyTracePrompt);
    for(i=1; i<=yypParser->yyidx; i++)
      fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]);
    fprintf(yyTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static struct {
  YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} yyRuleInfo[] = {
  { 56, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 58, 1 },
  { 58, 2 },
  { 58, 3 },
  { 58, 3 },
  { 58, 4 },
  { 58, 4 },
  { 58, 5 },
  { 58, 5 },
  { 58, 3 },
  { 58, 4 },
  { 58, 4 },
  { 58, 5 },
  { 58, 2 },
  { 58, 3 },
  { 58, 4 },
  { 58, 3 },
  { 58, 4 },
  { 58, 6 },
  { 58, 2 },
  { 58, 3 },
  { 58, 3 },
  { 58, 4 },
  { 58, 5 },
  { 58, 2 },
  { 62, 4 },
  { 62, 5 },
  { 68, 3 },
  { 68, 1 },
  { 71, 1 },
  { 71, 3 },
  { 71, 3 },
  { 71, 2 },
  { 71, 1 },
  { 69, 3 },
  { 69, 1 },
  { 70, 2 },
  { 70, 1 },
  { 74, 1 },
  { 75, 1 },
  { 75, 3 },
  { 75, 2 },
  { 76, 2 },
  { 76, 4 },
  { 76, 3 },
  { 76, 5 },
  { 76, 3 },
  { 76, 3 },
  { 76, 4 },
  { 76, 5 },
  { 76, 6 },
  { 76, 3 },
  { 76, 4 },
  { 76, 5 },
  { 76, 6 },
  { 76, 4 },
  { 76, 6 },
  { 59, 7 },
  { 59, 10 },
  { 78, 3 },
  { 78, 1 },
  { 81, 1 },
  { 79, 3 },
  { 79, 1 },
  { 82, 1 },
  { 60, 1 },
  { 60, 2 },
  { 60, 2 },
  { 60, 3 },
  { 83, 4 },
  { 85, 3 },
  { 85, 1 },
  { 86, 3 },
  { 87, 1 },
  { 61, 1 },
  { 61, 2 },
  { 61, 2 },
  { 61, 3 },
  { 88, 3 },
  { 73, 3 },
  { 73, 2 },
  { 73, 1 },
  { 63, 2 },
  { 64, 3 },
  { 89, 3 },
  { 89, 1 },
  { 90, 1 },
  { 90, 2 },
  { 90, 2 },
  { 91, 1 },
  { 91, 1 },
  { 65, 3 },
  { 92, 3 },
  { 92, 1 },
  { 93, 1 },
  { 93, 1 },
  { 66, 2 },
  { 67, 2 },
  { 67, 4 },
  { 67, 4 },
  { 84, 2 },
  { 72, 2 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 3 },
  { 72, 4 },
  { 72, 5 },
  { 72, 6 },
  { 72, 1 },
  { 95, 4 },
  { 95, 3 },
  { 94, 3 },
  { 94, 1 },
  { 96, 1 },
  { 96, 1 },
  { 72, 3 },
  { 72, 4 },
  { 72, 2 },
  { 72, 3 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 77, 3 },
  { 77, 1 },
};

static void yy_accept(yyParser*);  /* Forward Declaration */

static void yy_reduce(
  yyParser *yypParser,         /* The parser */
  int yyruleno                 /* Number of the rule by which to reduce */
){
  int yygoto;                     /* The next state */
  int yyact;                      /* The next action */
  YYMINORTYPE yygotominor;        /* The LHS of the rule reduced */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  phql_ARG_FETCH;
  yymsp = &yypParser->yystack[yypParser->yyidx];
#ifndef NDEBUG
  if( yyTraceFILE && yyruleno>=0 
        && yyruleno<sizeof(yyRuleName)/sizeof(yyRuleName[0]) ){
    fprintf(yyTraceFILE, "%sReduce [%s].\n", yyTracePrompt,
      yyRuleName[yyruleno]);
  }
#endif /* NDEBUG */

  switch( yyruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
      case 0:
{
	status->ret = yymsp[0].minor.yy66;
}
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 32:
      case 39:
      case 41:
      case 42:
      case 64:
      case 65:
      case 67:
      case 75:
      case 77:
      case 89:
      case 93:
      case 97:
      case 98:
      case 123:
      case 127:
      case 129:
      case 134:
{
	yygotominor.yy66 = yymsp[0].minor.yy66;
}
        break;
      case 5:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[0].minor.yy66, NULL, NULL, NULL, NULL, NULL);
}
        break;
      case 6:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL, NULL, NULL, NULL);
}
        break;
      case 7:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL, NULL, NULL);
}
        break;
      case 8:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66, NULL, NULL);
}
        break;
      case 9:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, NULL, yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL);
}
        break;
      case 10:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, yymsp[0].minor.yy66, yymsp[-1].minor.yy66, NULL, NULL);
}
        break;
      case 11:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-4].minor.yy66, yymsp[-3].minor.yy66, yymsp[-1].minor.yy66, yymsp[-2].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 12:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-4].minor.yy66, yymsp[-3].minor.yy66, yymsp[0].minor.yy66, yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, NULL);
}
        break;
      case 13:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, NULL, NULL, NULL, yymsp[0].minor.yy66);
}
        break;
      case 14:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, NULL, NULL, yymsp[0].minor.yy66);
}
        break;
      case 15:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, NULL, yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 16:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-4].minor.yy66, yymsp[-3].minor.yy66, NULL, yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 17:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66, NULL, NULL, NULL);
}
        break;
      case 18:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, NULL, yymsp[0].minor.yy66, yymsp[-1].minor.yy66, NULL, NULL);
}
        break;
      case 19:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, NULL, yymsp[0].minor.yy66, yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, NULL);
}
        break;
      case 20:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, NULL, yymsp[-1].minor.yy66, NULL, NULL, yymsp[0].minor.yy66);
}
        break;
      case 21:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, NULL, yymsp[-1].minor.yy66, yymsp[-2].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 22:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-5].minor.yy66, yymsp[-4].minor.yy66, yymsp[-1].minor.yy66, yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 23:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-1].minor.yy66, NULL, NULL, yymsp[0].minor.yy66, NULL, NULL);
}
        break;
      case 24:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, NULL, NULL, yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 25:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-2].minor.yy66, NULL, NULL, yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL);
}
        break;
      case 26:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-3].minor.yy66, NULL, NULL, yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 27:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-4].minor.yy66, NULL, yymsp[-1].minor.yy66, yymsp[-3].minor.yy66, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 28:
{
	yygotominor.yy66 = phql_ret_select_statement(yymsp[-1].minor.yy66, NULL, NULL, NULL, NULL, yymsp[0].minor.yy66);
}
        break;
      case 29:
{
	yygotominor.yy66 = phql_ret_select_clause(yymsp[-2].minor.yy66, yymsp[0].minor.yy66, NULL);
  yy_destructor(18,&yymsp[-3].minor);
  yy_destructor(19,&yymsp[-1].minor);
}
        break;
      case 30:
{
	yygotominor.yy66 = phql_ret_select_clause(yymsp[-3].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(18,&yymsp[-4].minor);
  yy_destructor(19,&yymsp[-2].minor);
}
        break;
      case 31:
      case 38:
      case 63:
      case 66:
      case 74:
      case 88:
      case 96:
      case 126:
{
	yygotominor.yy66 = phql_ret_zval_list(yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(20,&yymsp[-1].minor);
}
        break;
      case 33:
      case 128:
{
	yygotominor.yy66 = phql_ret_column_item(PHQL_T_ALL, NULL, NULL, NULL);
  yy_destructor(11,&yymsp[0].minor);
}
        break;
      case 34:
{
	yygotominor.yy66 = phql_ret_column_item(PHQL_T_DOMAINALL, NULL, yymsp[-2].minor.yy0, NULL);
  yy_destructor(22,&yymsp[-1].minor);
  yy_destructor(11,&yymsp[0].minor);
}
        break;
      case 35:
{
	yygotominor.yy66 = phql_ret_column_item(PHQL_T_EXPR, yymsp[-2].minor.yy66, NULL, yymsp[0].minor.yy0);
  yy_destructor(23,&yymsp[-1].minor);
}
        break;
      case 36:
{
	yygotominor.yy66 = phql_ret_column_item(PHQL_T_EXPR, yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy0);
}
        break;
      case 37:
{
	yygotominor.yy66 = phql_ret_column_item(PHQL_T_EXPR, yymsp[0].minor.yy66, NULL, NULL);
}
        break;
      case 40:
{
	yygotominor.yy66 = phql_ret_zval_list(yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 43:
{
	yygotominor.yy66 = phql_ret_join_item(yymsp[0].minor.yy66, NULL);
}
        break;
      case 44:
{
	yygotominor.yy66 = phql_ret_join_item(yymsp[-2].minor.yy66, yymsp[0].minor.yy0);
  yy_destructor(23,&yymsp[-1].minor);
}
        break;
      case 45:
{
	yygotominor.yy66 = phql_ret_join_item(yymsp[-1].minor.yy66, yymsp[0].minor.yy0);
}
        break;
      case 46:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_INNERJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 47:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_INNERJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 48:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_INNERJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(26,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 49:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_INNERJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(26,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 50:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_CROSSJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(27,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 51:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_LEFTJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(28,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 52:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_LEFTJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(28,&yymsp[-3].minor);
  yy_destructor(29,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 53:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_LEFTJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(28,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 54:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_LEFTJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(28,&yymsp[-5].minor);
  yy_destructor(29,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 55:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_RIGHTJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(30,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 56:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_RIGHTJOIN, yymsp[0].minor.yy66, NULL);
  yy_destructor(30,&yymsp[-3].minor);
  yy_destructor(29,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 57:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_RIGHTJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(30,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 58:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_RIGHTJOIN, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(30,&yymsp[-5].minor);
  yy_destructor(29,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 59:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_FULLOUTER, yymsp[0].minor.yy66, NULL);
  yy_destructor(31,&yymsp[-3].minor);
  yy_destructor(29,&yymsp[-2].minor);
  yy_destructor(24,&yymsp[-1].minor);
}
        break;
      case 60:
{
	yygotominor.yy66 = phql_ret_join_clause(PHQL_T_FULLOUTER, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(31,&yymsp[-5].minor);
  yy_destructor(29,&yymsp[-4].minor);
  yy_destructor(24,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
        break;
      case 61:
{
	yygotominor.yy66 = phql_ret_insert_statement(yymsp[-4].minor.yy66, NULL, yymsp[-1].minor.yy66);
  yy_destructor(32,&yymsp[-6].minor);
  yy_destructor(33,&yymsp[-5].minor);
  yy_destructor(34,&yymsp[-3].minor);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 62:
{
	yygotominor.yy66 = phql_ret_insert_statement(yymsp[-7].minor.yy66, yymsp[-5].minor.yy66, yymsp[-1].minor.yy66);
  yy_destructor(32,&yymsp[-9].minor);
  yy_destructor(33,&yymsp[-8].minor);
  yy_destructor(35,&yymsp[-6].minor);
  yy_destructor(36,&yymsp[-4].minor);
  yy_destructor(34,&yymsp[-3].minor);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 68:
      case 142:
{
	yygotominor.yy66 = phql_ret_qualified_name(yymsp[0].minor.yy0, NULL);
}
        break;
      case 69:
{
	yygotominor.yy66 = phql_ret_update_statement(yymsp[0].minor.yy66, NULL, NULL);
}
        break;
      case 70:
{
	yygotominor.yy66 = phql_ret_update_statement(yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL);
}
        break;
      case 71:
{
	yygotominor.yy66 = phql_ret_update_statement(yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 72:
{
	yygotominor.yy66 = phql_ret_update_statement(yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 73:
{
	yygotominor.yy66 = phql_ret_update_clause(yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(37,&yymsp[-3].minor);
  yy_destructor(38,&yymsp[-1].minor);
}
        break;
      case 76:
{
	yygotominor.yy66 = phql_ret_update_item(yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(1,&yymsp[-1].minor);
}
        break;
      case 78:
{
	yygotominor.yy66 = phql_ret_delete_statement(yymsp[0].minor.yy66, NULL, NULL);
}
        break;
      case 79:
{
	yygotominor.yy66 = phql_ret_delete_statement(yymsp[-1].minor.yy66, yymsp[0].minor.yy66, NULL);
}
        break;
      case 80:
{
	yygotominor.yy66 = phql_ret_delete_statement(yymsp[-1].minor.yy66, NULL, yymsp[0].minor.yy66);
}
        break;
      case 81:
{
	yygotominor.yy66 = phql_ret_delete_statement(yymsp[-2].minor.yy66, yymsp[-1].minor.yy66, yymsp[0].minor.yy66);
}
        break;
      case 82:
{
	yygotominor.yy66 = phql_ret_delete_clause(yymsp[0].minor.yy66);
  yy_destructor(39,&yymsp[-2].minor);
  yy_destructor(19,&yymsp[-1].minor);
}
        break;
      case 83:
{
	yygotominor.yy66 = phql_ret_assoc_name(yymsp[-2].minor.yy66, yymsp[0].minor.yy0);
  yy_destructor(23,&yymsp[-1].minor);
}
        break;
      case 84:
{
	yygotominor.yy66 = phql_ret_assoc_name(yymsp[-1].minor.yy66, yymsp[0].minor.yy0);
}
        break;
      case 85:
{
	yygotominor.yy66 = phql_ret_assoc_name(yymsp[0].minor.yy66, NULL);
}
        break;
      case 86:
{
	yygotominor.yy66 = yymsp[0].minor.yy66;
  yy_destructor(40,&yymsp[-1].minor);
}
        break;
      case 87:
{
	yygotominor.yy66 = yymsp[0].minor.yy66;
  yy_destructor(41,&yymsp[-2].minor);
  yy_destructor(42,&yymsp[-1].minor);
}
        break;
      case 90:
{
	yygotominor.yy66 = phql_ret_order_item(yymsp[0].minor.yy66, 0);
}
        break;
      case 91:
{
	yygotominor.yy66 = phql_ret_order_item(yymsp[-1].minor.yy66, PHQL_T_ASC);
  yy_destructor(43,&yymsp[0].minor);
}
        break;
      case 92:
{
	yygotominor.yy66 = phql_ret_order_item(yymsp[-1].minor.yy66, PHQL_T_DESC);
  yy_destructor(44,&yymsp[0].minor);
}
        break;
      case 94:
      case 99:
      case 135:
{
	yygotominor.yy66 = phql_ret_literal_zval(PHQL_T_INTEGER, yymsp[0].minor.yy0);
}
        break;
      case 95:
{
	yygotominor.yy66 = yymsp[0].minor.yy66;
  yy_destructor(46,&yymsp[-2].minor);
  yy_destructor(42,&yymsp[-1].minor);
}
        break;
      case 100:
{
	yygotominor.yy66 = yymsp[0].minor.yy66;
  yy_destructor(47,&yymsp[-1].minor);
}
        break;
      case 101:
{
	yygotominor.yy66 = phql_ret_select_limit_clause(yymsp[0].minor.yy0, NULL);
  yy_destructor(48,&yymsp[-1].minor);
}
        break;
      case 102:
{
	yygotominor.yy66 = phql_ret_select_limit_clause(yymsp[0].minor.yy0, yymsp[-2].minor.yy0);
  yy_destructor(48,&yymsp[-3].minor);
  yy_destructor(20,&yymsp[-1].minor);
}
        break;
      case 103:
{
	yygotominor.yy66 = phql_ret_select_limit_clause(yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
  yy_destructor(48,&yymsp[-3].minor);
  yy_destructor(49,&yymsp[-1].minor);
}
        break;
      case 104:
{
	yygotominor.yy66 = phql_ret_literal_zval(PHQL_T_INTEGER, yymsp[0].minor.yy0);
  yy_destructor(48,&yymsp[-1].minor);
}
        break;
      case 105:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_MINUS, NULL, yymsp[0].minor.yy66);
  yy_destructor(14,&yymsp[-1].minor);
}
        break;
      case 106:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_SUB, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(14,&yymsp[-1].minor);
}
        break;
      case 107:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_ADD, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(13,&yymsp[-1].minor);
}
        break;
      case 108:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_MUL, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(11,&yymsp[-1].minor);
}
        break;
      case 109:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_DIV, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(10,&yymsp[-1].minor);
}
        break;
      case 110:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_MOD, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(12,&yymsp[-1].minor);
}
        break;
      case 111:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_AND, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(7,&yymsp[-1].minor);
}
        break;
      case 112:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_OR, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(8,&yymsp[-1].minor);
}
        break;
      case 113:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_EQUALS, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(1,&yymsp[-1].minor);
}
        break;
      case 114:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_NOTEQUALS, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(2,&yymsp[-1].minor);
}
        break;
      case 115:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_LESS, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(3,&yymsp[-1].minor);
}
        break;
      case 116:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_GREATER, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(4,&yymsp[-1].minor);
}
        break;
      case 117:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_GREATEREQUAL, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(5,&yymsp[-1].minor);
}
        break;
      case 118:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_LESSEQUAL, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(6,&yymsp[-1].minor);
}
        break;
      case 119:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_LIKE, yymsp[-2].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(9,&yymsp[-1].minor);
}
        break;
      case 120:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_NLIKE, yymsp[-3].minor.yy66, yymsp[0].minor.yy66);
  yy_destructor(17,&yymsp[-2].minor);
  yy_destructor(9,&yymsp[-1].minor);
}
        break;
      case 121:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_IN, yymsp[-4].minor.yy66, yymsp[-1].minor.yy66);
  yy_destructor(16,&yymsp[-3].minor);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 122:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_NOTIN, yymsp[-5].minor.yy66, yymsp[-1].minor.yy66);
  yy_destructor(17,&yymsp[-4].minor);
  yy_destructor(16,&yymsp[-3].minor);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 124:
{
	yygotominor.yy66 = phql_ret_func_call(yymsp[-3].minor.yy0, yymsp[-1].minor.yy66);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 125:
{
	yygotominor.yy66 = phql_ret_func_call(yymsp[-2].minor.yy0, NULL);
  yy_destructor(35,&yymsp[-1].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 130:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_ISNULL, yymsp[-2].minor.yy66, NULL);
  yy_destructor(15,&yymsp[-1].minor);
  yy_destructor(50,&yymsp[0].minor);
}
        break;
      case 131:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_ISNOTNULL, yymsp[-3].minor.yy66, NULL);
  yy_destructor(15,&yymsp[-2].minor);
  yy_destructor(17,&yymsp[-1].minor);
  yy_destructor(50,&yymsp[0].minor);
}
        break;
      case 132:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_NOT, NULL, yymsp[0].minor.yy66);
  yy_destructor(17,&yymsp[-1].minor);
}
        break;
      case 133:
{
	yygotominor.yy66 = phql_ret_expr(PHQL_T_ENCLOSED, yymsp[-1].minor.yy66, NULL);
  yy_destructor(35,&yymsp[-2].minor);
  yy_destructor(36,&yymsp[0].minor);
}
        break;
      case 136:
{
	yygotominor.yy66 = phql_ret_literal_zval(PHQL_T_STRING, yymsp[0].minor.yy0);
}
        break;
      case 137:
{
	yygotominor.yy66 = phql_ret_literal_zval(PHQL_T_DOUBLE, yymsp[0].minor.yy0);
}
        break;
      case 138:
{
	yygotominor.yy66 = phql_ret_literal_zval(PHQL_T_NULL, NULL);
  yy_destructor(50,&yymsp[0].minor);
}
        break;
      case 139:
{
	yygotominor.yy66 = phql_ret_placeholder_zval(PHQL_T_NPLACEHOLDER, yymsp[0].minor.yy0);
}
        break;
      case 140:
{
	yygotominor.yy66 = phql_ret_placeholder_zval(PHQL_T_SPLACEHOLDER, yymsp[0].minor.yy0);
}
        break;
      case 141:
{
	yygotominor.yy66 = phql_ret_qualified_name(yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
  yy_destructor(22,&yymsp[-1].minor);
}
        break;
  };
  yygoto = yyRuleInfo[yyruleno].lhs;
  yysize = yyRuleInfo[yyruleno].nrhs;
  yypParser->yyidx -= yysize;
  yyact = yy_find_reduce_action(yypParser,yygoto);
  if( yyact < YYNSTATE ){
    yy_shift(yypParser,yyact,yygoto,&yygotominor);
  }else if( yyact == YYNSTATE + YYNRULE + 1 ){
    yy_accept(yypParser);
  }
}

static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  phql_ARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  YYMINORTYPE yyminor            /* The minor type of the error token */
){
  phql_ARG_FETCH;
#define TOKEN (yyminor.yy0)

	if (status->scanner_state->start) {
		{

			char *token_name = NULL;
			int token_found = 0;
			const phql_token_names *tokens = phql_tokens;
			int active_token = status->scanner_state->active_token;
			int near_length = strlen(status->scanner_state->start);

			if (active_token) {

				do {
					if (tokens->code == active_token) {
						token_name = tokens->name;
						token_found = 1;
						break;
					}
					++tokens;
				} while (tokens[0].code != 0);

			}

			if (!token_name) {
				token_name = estrndup("UNKNOWN", strlen("UNKNOWN"));
				token_found = 0;
			}

			status->syntax_error_len = 64 + strlen(token_name) + near_length;
			status->syntax_error = emalloc(sizeof(char)*status->syntax_error_len);
			if (near_length > 0) {
				sprintf(status->syntax_error, "Syntax error, unexpected token %s, near to %s", token_name, status->scanner_state->start);
			} else {
				sprintf(status->syntax_error, "Syntax error, unexpected token %s, at the end of query", token_name);
			}

			if (!token_found) {
				if (token_name) {
					efree(token_name);
				}
			}
		}
	} else {
		status->syntax_error_len = strlen("Syntax error, unexpected EOF");
		status->syntax_error = estrndup("Syntax error, unexpected EOF", status->syntax_error_len);
	}

	status->status = PHQL_PARSING_FAILED;

  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  phql_ARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "phql_Alloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
void phql_(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  phql_TOKENTYPE yyminor       /* The value for the token */
  phql_ARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  int yyact;            /* The parser action. */
  int yyendofinput;     /* True if we are at the end of input */
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
  yyParser *yypParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  yypParser = (yyParser*)yyp;
  if( yypParser->yyidx<0 ){
    if( yymajor==0 ) return;
    yypParser->yyidx = 0;
    yypParser->yyerrcnt = -1;
    yypParser->yystack[0].stateno = 0;
    yypParser->yystack[0].major = 0;
  }
  yyminorunion.yy0 = yyminor;
  yyendofinput = (yymajor==0);
  phql_ARG_STORE;

#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sInput %s\n",yyTracePrompt,yyTokenName[yymajor]);
  }
#endif

  do{
    yyact = yy_find_shift_action(yypParser,yymajor);
    if( yyact<YYNSTATE ){
      yy_shift(yypParser,yyact,yymajor,&yyminorunion);
      yypParser->yyerrcnt--;
      if( yyendofinput && yypParser->yyidx>=0 ){
        yymajor = 0;
      }else{
        yymajor = YYNOCODE;
      }
    }else if( yyact < YYNSTATE + YYNRULE ){
      yy_reduce(yypParser,yyact-YYNSTATE);
    }else if( yyact == YY_ERROR_ACTION ){
      int yymx;
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yymx = yypParser->yystack[yypParser->yyidx].major;
      if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yymajor,&yyminorunion);
        yymajor = YYNOCODE;
      }else{
         while(
          yypParser->yyidx >= 0 &&
          yymx != YYERRORSYMBOL &&
          (yyact = yy_find_shift_action(yypParser,YYERRORSYMBOL)) >= YYNSTATE
        ){
          yy_pop_parser_stack(yypParser);
        }
        if( yypParser->yyidx < 0 || yymajor==0 ){
          yy_destructor(yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
          yymajor = YYNOCODE;
        }else if( yymx!=YYERRORSYMBOL ){
          YYMINORTYPE u2;
          u2.YYERRSYMDT = 0;
          yy_shift(yypParser,yyact,YYERRORSYMBOL,&u2);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
#else  /* YYERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yymajor,&yyminorunion);
      if( yyendofinput ){
        yy_parse_failed(yypParser);
      }
      yymajor = YYNOCODE;
#endif
    }else{
      yy_accept(yypParser);
      yymajor = YYNOCODE;
    }
  }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );
  return;
}


const phql_token_names phql_tokens[] =
{
  { PHQL_T_INTEGER,       "INTEGER" },
  { PHQL_T_DOUBLE,        "DOUBLE" },
  { PHQL_T_STRING,        "STRING" },
  { PHQL_T_IDENTIFIER,    "IDENTIFIER" },
  { PHQL_T_MINUS,         "MINUS"},
  { PHQL_T_ADD,           "+" },
  { PHQL_T_SUB,           "-" },
  { PHQL_T_MUL,           "*" },
  { PHQL_T_DIV,           "/" },
  { PHQL_T_MOD,           "%%" },
  { PHQL_T_AND,           "AND" },
  { PHQL_T_OR,            "OR" },
  { PHQL_T_LIKE,          "LIKE" },
  { PHQL_T_DOT,           "DOT" },
  { PHQL_T_COMMA,         "COMMA" },
  { PHQL_T_EQUALS,        "EQUALS" },
  { PHQL_T_NOTEQUALS,     "NOT EQUALS" },
  { PHQL_T_NOT,           "NOT" },
  { PHQL_T_LESS,          "<" },
  { PHQL_T_LESSEQUAL,     "<=" },
  { PHQL_T_GREATER,       ">" },
  { PHQL_T_GREATEREQUAL,  ">=" },
  { PHQL_T_BRACKET_OPEN,  "(" },
  { PHQL_T_BRACKET_CLOSE, ")" },
  { PHQL_T_NPLACEHOLDER,  "NUMERIC PLACEHOLDER" },
  { PHQL_T_SPLACEHOLDER,  "STRING PLACEHOLDER" },
  { PHQL_T_UPDATE,        "UPDATE" },
  { PHQL_T_SET,           "SET" },
  { PHQL_T_WHERE,         "WHERE" },
  { PHQL_T_DELETE,        "DELETE" },
  { PHQL_T_FROM,          "FROM" },
  { PHQL_T_AS,            "AS" },
  { PHQL_T_INSERT,        "INSERT" },
  { PHQL_T_INTO,          "INTO" },
  { PHQL_T_VALUES,        "VALUES" },
  { PHQL_T_SELECT,        "SELECT" },
  { PHQL_T_ORDER,         "ORDER" },
  { PHQL_T_BY,            "BY" },
  { PHQL_T_LIMIT,         "LIMIT" },
  { PHQL_T_OFFSET,        "OFFSET" },
  { PHQL_T_GROUP,         "GROUP" },
  { PHQL_T_HAVING,        "HAVING" },
  { PHQL_T_IN,            "IN" },
  { PHQL_T_ON,            "ON" },
  { PHQL_T_INNER,         "INNER" },
  { PHQL_T_JOIN,          "JOIN" },
  { PHQL_T_LEFT,          "LEFT" },
  { PHQL_T_RIGHT,         "RIGHT" },
  { PHQL_T_IS,            "IS" },
  { PHQL_T_NULL,          "NULL" },
  { PHQL_T_NOTIN,         "NOT IN" },
  { PHQL_T_CROSS,         "CROSS" },
  { PHQL_T_OUTER,         "OUTER" },
  { PHQL_T_FULL,          "FULL" },
  { PHQL_T_ASC,           "ASC" },
  { PHQL_T_DESC,          "DESC" },
  {  0, NULL }
};

static void *phql_wrapper_alloc(size_t bytes){
	return emalloc(bytes);
}

static void phql_wrapper_free(void *pointer){
	efree(pointer);
}

static void phql_parse_with_token(void* phql_parser, int opcode, int parsercode, phql_scanner_token *token, phql_parser_status *parser_status){
	phql_parser_token *pToken;
	pToken = emalloc(sizeof(phql_parser_token));
	pToken->opcode = opcode;
	pToken->token = estrndup(token->value, token->len);
	pToken->token_len = token->len;
	phql_(phql_parser, parsercode, pToken, parser_status);
	efree(token->value);
}

int phql_parse_phql(zval *result, zval *phql TSRMLS_DC){

	zval *error_msg = NULL;

	ZVAL_NULL(result);

	if(phql_internal_parse_phql(&result, Z_STRVAL_P(phql), &error_msg TSRMLS_CC) == FAILURE){
		phalcon_throw_exception_string(phalcon_mvc_model_exception_ce, Z_STRVAL_P(error_msg), Z_STRLEN_P(error_msg) TSRMLS_CC);
		return FAILURE;
	}

	return SUCCESS;
}

int phql_internal_parse_phql(zval **result, char *phql, zval **error_msg TSRMLS_DC) {

	char *error;
	phql_scanner_state *state;
	phql_scanner_token *token;
	int scanner_status, status = SUCCESS;
	phql_parser_status *parser_status = NULL;
	void* phql_parser;

	if (!phql) {
		PHALCON_INIT_VAR(*error_msg);
		ZVAL_STRING(*error_msg, "PHQL statement cannot be NULL", 1);
		return FAILURE;
	}

	phql_parser = phql_Alloc(phql_wrapper_alloc);

	parser_status = emalloc(sizeof(phql_parser_status));
	state = emalloc(sizeof(phql_scanner_state));
	token = emalloc(sizeof(phql_scanner_token));

	parser_status->status = PHQL_PARSING_OK;
	parser_status->scanner_state = state;
	parser_status->ret = NULL;
	parser_status->syntax_error = NULL;

	state->active_token = 0;
	state->start = phql;

	state->end = state->start;

	while(0 <= (scanner_status = phql_get_token(state, token))) {

		state->active_token = token->opcode;

		switch(token->opcode){

			case PHQL_T_IGNORE:
				break;

			case PHQL_T_ADD:
				phql_(phql_parser, PHQL_PLUS, NULL, parser_status);
				break;
			case PHQL_T_SUB:
				phql_(phql_parser, PHQL_MINUS, NULL, parser_status);
				break;
			case PHQL_T_MUL:
				phql_(phql_parser, PHQL_TIMES, NULL, parser_status);
				break;
			case PHQL_T_DIV:
				phql_(phql_parser, PHQL_DIVIDE, NULL, parser_status);
				break;
			case PHQL_T_MOD:
				phql_(phql_parser, PHQL_MOD, NULL, parser_status);
				break;
			case PHQL_T_AND:
				phql_(phql_parser, PHQL_AND, NULL, parser_status);
				break;
			case PHQL_T_OR:
				phql_(phql_parser, PHQL_OR, NULL, parser_status);
				break;
			case PHQL_T_EQUALS:
				phql_(phql_parser, PHQL_EQUALS, NULL, parser_status);
				break;
			case PHQL_T_NOTEQUALS:
				phql_(phql_parser, PHQL_NOTEQUALS, NULL, parser_status);
				break;
			case PHQL_T_LESS:
				phql_(phql_parser, PHQL_LESS, NULL, parser_status);
				break;
			case PHQL_T_GREATER:
				phql_(phql_parser, PHQL_GREATER, NULL, parser_status);
				break;
			case PHQL_T_GREATEREQUAL:
				phql_(phql_parser, PHQL_GREATEREQUAL, NULL, parser_status);
				break;
			case PHQL_T_LESSEQUAL:
				phql_(phql_parser, PHQL_LESSEQUAL, NULL, parser_status);
				break;
			case PHQL_T_LIKE:
				phql_(phql_parser, PHQL_LIKE, NULL, parser_status);
				break;
			case PHQL_T_NOT:
				phql_(phql_parser, PHQL_NOT, NULL, parser_status);
				break;
			case PHQL_T_DOT:
				phql_(phql_parser, PHQL_DOT, NULL, parser_status);
				break;
			case PHQL_T_COMMA:
				phql_(phql_parser, PHQL_COMMA, NULL, parser_status);
				break;

			case PHQL_T_BRACKET_OPEN:
				phql_(phql_parser, PHQL_BRACKET_OPEN, NULL, parser_status);
				break;
			case PHQL_T_BRACKET_CLOSE:
				phql_(phql_parser, PHQL_BRACKET_CLOSE, NULL, parser_status);
				break;

			case PHQL_T_INTEGER:
				phql_parse_with_token(phql_parser, PHQL_T_INTEGER, PHQL_INTEGER, token, parser_status);
				break;
			case PHQL_T_DOUBLE:
				phql_parse_with_token(phql_parser, PHQL_T_DOUBLE, PHQL_DOUBLE, token, parser_status);
				break;
			case PHQL_T_STRING:
				phql_parse_with_token(phql_parser, PHQL_T_STRING, PHQL_STRING, token, parser_status);
				break;
			case PHQL_T_IDENTIFIER:
				phql_parse_with_token(phql_parser, PHQL_T_IDENTIFIER, PHQL_IDENTIFIER, token, parser_status);
				break;
			case PHQL_T_NPLACEHOLDER:
				phql_parse_with_token(phql_parser, PHQL_T_NPLACEHOLDER, PHQL_NPLACEHOLDER, token, parser_status);
				break;
			case PHQL_T_SPLACEHOLDER:
				phql_parse_with_token(phql_parser, PHQL_T_SPLACEHOLDER, PHQL_SPLACEHOLDER, token, parser_status);
				break;

			case PHQL_T_FROM:
				phql_(phql_parser, PHQL_FROM, NULL, parser_status);
				break;
			case PHQL_T_UPDATE:
				phql_(phql_parser, PHQL_UPDATE, NULL, parser_status);
				break;
			case PHQL_T_SET:
				phql_(phql_parser, PHQL_SET, NULL, parser_status);
				break;
			case PHQL_T_WHERE:
				phql_(phql_parser, PHQL_WHERE, NULL, parser_status);
				break;
			case PHQL_T_DELETE:
				phql_(phql_parser, PHQL_DELETE, NULL, parser_status);
				break;
			case PHQL_T_INSERT:
				phql_(phql_parser, PHQL_INSERT, NULL, parser_status);
				break;
			case PHQL_T_INTO:
				phql_(phql_parser, PHQL_INTO, NULL, parser_status);
				break;
			case PHQL_T_VALUES:
				phql_(phql_parser, PHQL_VALUES, NULL, parser_status);
				break;
			case PHQL_T_SELECT:
				phql_(phql_parser, PHQL_SELECT, NULL, parser_status);
				break;
			case PHQL_T_AS:
				phql_(phql_parser, PHQL_AS, NULL, parser_status);
				break;
			case PHQL_T_ORDER:
				phql_(phql_parser, PHQL_ORDER, NULL, parser_status);
				break;
			case PHQL_T_BY:
				phql_(phql_parser, PHQL_BY, NULL, parser_status);
				break;
			case PHQL_T_LIMIT:
				phql_(phql_parser, PHQL_LIMIT, NULL, parser_status);
				break;
			case PHQL_T_OFFSET:
				phql_(phql_parser, PHQL_OFFSET, NULL, parser_status);
				break;
			case PHQL_T_GROUP:
				phql_(phql_parser, PHQL_GROUP, NULL, parser_status);
				break;
			case PHQL_T_HAVING:
				phql_(phql_parser, PHQL_HAVING, NULL, parser_status);
				break;
			case PHQL_T_ASC:
				phql_(phql_parser, PHQL_ASC, NULL, parser_status);
				break;
			case PHQL_T_DESC:
				phql_(phql_parser, PHQL_DESC, NULL, parser_status);
				break;
			case PHQL_T_IN:
				phql_(phql_parser, PHQL_IN, NULL, parser_status);
				break;
			case PHQL_T_ON:
				phql_(phql_parser, PHQL_ON, NULL, parser_status);
				break;
			case PHQL_T_INNER:
				phql_(phql_parser, PHQL_INNER, NULL, parser_status);
				break;
			case PHQL_T_JOIN:
				phql_(phql_parser, PHQL_JOIN, NULL, parser_status);
				break;
			case PHQL_T_LEFT:
				phql_(phql_parser, PHQL_LEFT, NULL, parser_status);
				break;
			case PHQL_T_RIGHT:
				phql_(phql_parser, PHQL_RIGHT, NULL, parser_status);
				break;
			case PHQL_T_CROSS:
				phql_(phql_parser, PHQL_CROSS, NULL, parser_status);
				break;
			case PHQL_T_FULL:
				phql_(phql_parser, PHQL_FULL, NULL, parser_status);
				break;
			case PHQL_T_OUTER:
				phql_(phql_parser, PHQL_OUTER, NULL, parser_status);
				break;
			case PHQL_T_IS:
				phql_(phql_parser, PHQL_IS, NULL, parser_status);
				break;
			case PHQL_T_NULL:
				phql_(phql_parser, PHQL_NULL, NULL, parser_status);
				break;
			default:
				parser_status->status = PHQL_PARSING_FAILED;
				error = emalloc(sizeof(char)*32);
				sprintf(error, "scanner: unknown opcode %c", token->opcode);
				PHALCON_INIT_VAR(*error_msg);
				ZVAL_STRING(*error_msg, error, 1);
				efree(error);
				break;
		}

		if (parser_status->status != PHQL_PARSING_OK) {
			status = FAILURE;
			break;
		}

		state->end = state->start;
	}

	state->active_token = 0;
	state->start = NULL;

	if (status != FAILURE) {
		switch (scanner_status) {
			case PHQL_SCANNER_RETCODE_ERR:
			case PHQL_SCANNER_RETCODE_IMPOSSIBLE:
				if (!*error_msg) {
					PHALCON_INIT_VAR(*error_msg);
					if (state->start) {
						error = emalloc(sizeof(char)*(48+strlen(state->start)));
						sprintf(error, "Parsing error near to %s (%d)", state->start, status);
						ZVAL_STRING(*error_msg, error, 1);
						efree(error);
					} else {
						ZVAL_STRING(*error_msg, "Parsing error near to EOF", 1);
					}
				}
				status = FAILURE;
				break;
			default:
				phql_(phql_parser, 0, NULL, parser_status);
		}
	}

	if (parser_status->status != PHQL_PARSING_OK) {
		status = FAILURE;
		if (parser_status->syntax_error) {
			if (!*error_msg) {
				PHALCON_ALLOC_ZVAL_MM(*error_msg);
				ZVAL_STRING(*error_msg, parser_status->syntax_error, 1);
			}
			efree(parser_status->syntax_error);
		}
	}

	phql_Free(phql_parser, phql_wrapper_free);

	if (status != FAILURE) {
		if (parser_status->status == PHQL_PARSING_OK) {
			if (parser_status->ret) {
				ZVAL_ZVAL(*result, parser_status->ret, 0, 0);
				ZVAL_NULL(parser_status->ret);
				zval_ptr_dtor(&parser_status->ret);
			} else {
				efree(parser_status->ret);
			}
		}
	}

	efree(parser_status);
	efree(state);
	efree(token);

	return status;
}



#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Lang){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Query, Lang, mvc_model_query_lang, phalcon_mvc_model_query_lang_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Query_Lang, parsePHQL){

	zval *phql, *intermediate;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &phql) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(phql) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "PHQL statement must be string");
		return;
	}
	
	PHALCON_INIT_VAR(intermediate);
	if (phql_parse_phql(intermediate, phql TSRMLS_CC) == FAILURE) {
		return;
	}
	
	RETURN_CCTOR(intermediate);
}



/* Generated by re2c 0.13.5 on Sat Nov 10 22:49:40 2012 */


#ifdef HAVE_CONFIG_H
#endif



#define YYCTYPE char
#define YYCURSOR (s->start)
#define YYLIMIT (s->end)
#define YYMARKER q

int phql_get_token(phql_scanner_state *s, phql_scanner_token *token) {

	char *q = YYCURSOR;
	int status = PHQL_SCANNER_RETCODE_IMPOSSIBLE;

	while(PHQL_SCANNER_RETCODE_IMPOSSIBLE == status) {

		
		{
			YYCTYPE yych;

			yych = *YYCURSOR;
			switch (yych) {
			case 0x00:	goto yy56;
			case '\t':
			case '\n':
			case '\r':
			case ' ':	goto yy54;
			case '!':	goto yy46;
			case '"':	goto yy27;
			case '%':	goto yy38;
			case '\'':	goto yy28;
			case '(':	goto yy42;
			case ')':	goto yy44;
			case '*':	goto yy34;
			case '+':	goto yy30;
			case ',':	goto yy40;
			case '-':	goto yy32;
			case '.':	goto yy4;
			case '/':	goto yy36;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy2;
			case ':':	goto yy8;
			case '<':	goto yy48;
			case '=':	goto yy52;
			case '>':	goto yy50;
			case '?':	goto yy6;
			case 'A':
			case 'a':	goto yy14;
			case 'B':
			case 'b':	goto yy19;
			case 'C':
			case 'c':	goto yy26;
			case 'D':
			case 'd':	goto yy12;
			case 'E':
			case 'K':
			case 'M':
			case 'P':
			case 'Q':
			case 'T':
			case 'X':
			case 'Y':
			case 'Z':
			case 'e':
			case 'k':
			case 'm':
			case 'p':
			case 'q':
			case 't':
			case 'x':
			case 'y':
			case 'z':	goto yy29;
			case 'F':
			case 'f':	goto yy13;
			case 'G':
			case 'g':	goto yy20;
			case 'H':
			case 'h':	goto yy21;
			case 'I':
			case 'i':	goto yy15;
			case 'J':
			case 'j':	goto yy24;
			case 'L':
			case 'l':	goto yy22;
			case 'N':
			case 'n':	goto yy23;
			case 'O':
			case 'o':	goto yy18;
			case 'R':
			case 'r':	goto yy25;
			case 'S':
			case 's':	goto yy11;
			case 'U':
			case 'u':	goto yy9;
			case 'V':
			case 'v':	goto yy16;
			case 'W':
			case 'w':	goto yy17;
			default:	goto yy58;
			}
yy2:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '.':	goto yy220;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy222;
			default:	goto yy3;
			}
yy3:
			{
			token->opcode = PHQL_T_INTEGER;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
yy4:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy217;
			default:	goto yy5;
			}
yy5:
			{
			token->opcode = PHQL_T_DOT;
			return 0;
		}
yy6:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy214;
			default:	goto yy7;
			}
yy7:
			{
			status = PHQL_SCANNER_RETCODE_ERR;
			break;
		}
yy8:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy210;
			default:	goto yy7;
			}
yy9:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 'P':
			case 'p':	goto yy204;
			default:	goto yy70;
			}
yy10:
			{
			token->opcode = PHQL_T_IDENTIFIER;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
yy11:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy196;
			default:	goto yy70;
			}
yy12:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy187;
			default:	goto yy70;
			}
yy13:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy179;
			case 'U':
			case 'u':	goto yy180;
			default:	goto yy70;
			}
yy14:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'N':
			case 'n':	goto yy172;
			case 'S':
			case 's':	goto yy173;
			default:	goto yy70;
			}
yy15:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'N':
			case 'n':	goto yy156;
			case 'S':
			case 's':	goto yy158;
			default:	goto yy70;
			}
yy16:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'A':
			case 'a':	goto yy150;
			default:	goto yy70;
			}
yy17:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'H':
			case 'h':	goto yy145;
			default:	goto yy70;
			}
yy18:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'F':
			case 'f':	goto yy126;
			case 'N':
			case 'n':	goto yy127;
			case 'R':
			case 'r':	goto yy129;
			case 'U':
			case 'u':	goto yy131;
			default:	goto yy70;
			}
yy19:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'Y':
			case 'y':	goto yy124;
			default:	goto yy70;
			}
yy20:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy119;
			default:	goto yy70;
			}
yy21:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'A':
			case 'a':	goto yy113;
			default:	goto yy70;
			}
yy22:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy101;
			case 'I':
			case 'i':	goto yy102;
			default:	goto yy70;
			}
yy23:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy94;
			case 'U':
			case 'u':	goto yy95;
			default:	goto yy70;
			}
yy24:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy90;
			default:	goto yy70;
			}
yy25:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'I':
			case 'i':	goto yy85;
			default:	goto yy70;
			}
yy26:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy80;
			default:	goto yy70;
			}
yy27:
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 0x00) goto yy7;
			goto yy78;
yy28:
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 0x00) goto yy7;
			goto yy72;
yy29:
			yych = *++YYCURSOR;
			goto yy70;
yy30:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_ADD;
			return 0;
		}
yy32:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_SUB;
			return 0;
		}
yy34:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_MUL;
			return 0;
		}
yy36:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_DIV;
			return 0;
		}
yy38:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_MOD;
			return 0;
		}
yy40:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_COMMA;
			return 0;
		}
yy42:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_BRACKET_OPEN;
			return 0;
		}
yy44:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_BRACKET_CLOSE;
			return 0;
		}
yy46:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '=':	goto yy67;
			default:	goto yy47;
			}
yy47:
			{
			token->opcode = PHQL_T_NOT;
			return 0;
		}
yy48:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '=':	goto yy63;
			case '>':	goto yy65;
			default:	goto yy49;
			}
yy49:
			{
			token->opcode = PHQL_T_LESS;
			return 0;
		}
yy50:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '=':	goto yy61;
			default:	goto yy51;
			}
yy51:
			{
			token->opcode = PHQL_T_GREATER;
			return 0;
		}
yy52:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_EQUALS;
			return 0;
		}
yy54:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy60;
yy55:
			{
			token->opcode = PHQL_T_IGNORE;
			return 0;
		}
yy56:
			++YYCURSOR;
			{
			status = PHQL_SCANNER_RETCODE_EOF;
			break;
		}
yy58:
			yych = *++YYCURSOR;
			goto yy7;
yy59:
			++YYCURSOR;
			yych = *YYCURSOR;
yy60:
			switch (yych) {
			case '\t':
			case '\n':
			case '\r':
			case ' ':	goto yy59;
			default:	goto yy55;
			}
yy61:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_GREATEREQUAL;
			return 0;
		}
yy63:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_LESSEQUAL;
			return 0;
		}
yy65:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_NOTEQUALS;
			return 0;
		}
yy67:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_NOTEQUALS;
			return 0;
		}
yy69:
			++YYCURSOR;
			yych = *YYCURSOR;
yy70:
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy10;
			}
yy71:
			++YYCURSOR;
			yych = *YYCURSOR;
yy72:
			switch (yych) {
			case 0x00:	goto yy73;
			case '\'':	goto yy75;
			case '\\':	goto yy74;
			default:	goto yy71;
			}
yy73:
			YYCURSOR = YYMARKER;
			goto yy7;
yy74:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy73;
			default:	goto yy71;
			}
yy75:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_STRING;
			token->value = estrndup(q, YYCURSOR - q - 1);
			token->len = YYCURSOR - q - 1;
			q = YYCURSOR;
			return 0;
		}
yy77:
			++YYCURSOR;
			yych = *YYCURSOR;
yy78:
			switch (yych) {
			case 0x00:	goto yy73;
			case '"':	goto yy75;
			case '\\':	goto yy79;
			default:	goto yy77;
			}
yy79:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':	goto yy73;
			default:	goto yy77;
			}
yy80:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy81;
			default:	goto yy70;
			}
yy81:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'S':
			case 's':	goto yy82;
			default:	goto yy70;
			}
yy82:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'S':
			case 's':	goto yy83;
			default:	goto yy70;
			}
yy83:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy84;
			}
yy84:
			{
			token->opcode = PHQL_T_CROSS;
			return 0;
		}
yy85:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'G':
			case 'g':	goto yy86;
			default:	goto yy70;
			}
yy86:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'H':
			case 'h':	goto yy87;
			default:	goto yy70;
			}
yy87:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy88;
			default:	goto yy70;
			}
yy88:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy89;
			}
yy89:
			{
			token->opcode = PHQL_T_RIGHT;
			return 0;
		}
yy90:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'I':
			case 'i':	goto yy91;
			default:	goto yy70;
			}
yy91:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'N':
			case 'n':	goto yy92;
			default:	goto yy70;
			}
yy92:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy93;
			}
yy93:
			{
			token->opcode = PHQL_T_JOIN;
			return 0;
		}
yy94:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy99;
			default:	goto yy70;
			}
yy95:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy96;
			default:	goto yy70;
			}
yy96:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy97;
			default:	goto yy70;
			}
yy97:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy98;
			}
yy98:
			{
			token->opcode = PHQL_T_NULL;
			return 0;
		}
yy99:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy100;
			}
yy100:
			{
			token->opcode = PHQL_T_NOT;
			return 0;
		}
yy101:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'F':
			case 'f':	goto yy110;
			default:	goto yy70;
			}
yy102:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'K':
			case 'k':	goto yy104;
			case 'M':
			case 'm':	goto yy103;
			default:	goto yy70;
			}
yy103:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'I':
			case 'i':	goto yy107;
			default:	goto yy70;
			}
yy104:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy105;
			default:	goto yy70;
			}
yy105:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy106;
			}
yy106:
			{
			token->opcode = PHQL_T_LIKE;
			return 0;
		}
yy107:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy108;
			default:	goto yy70;
			}
yy108:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy109;
			}
yy109:
			{
			token->opcode = PHQL_T_LIMIT;
			return 0;
		}
yy110:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy111;
			default:	goto yy70;
			}
yy111:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy112;
			}
yy112:
			{
			token->opcode = PHQL_T_LEFT;
			return 0;
		}
yy113:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'V':
			case 'v':	goto yy114;
			default:	goto yy70;
			}
yy114:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'I':
			case 'i':	goto yy115;
			default:	goto yy70;
			}
yy115:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'N':
			case 'n':	goto yy116;
			default:	goto yy70;
			}
yy116:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'G':
			case 'g':	goto yy117;
			default:	goto yy70;
			}
yy117:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy118;
			}
yy118:
			{
			token->opcode = PHQL_T_HAVING;
			return 0;
		}
yy119:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy120;
			default:	goto yy70;
			}
yy120:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'U':
			case 'u':	goto yy121;
			default:	goto yy70;
			}
yy121:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'P':
			case 'p':	goto yy122;
			default:	goto yy70;
			}
yy122:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy123;
			}
yy123:
			{
			token->opcode = PHQL_T_GROUP;
			return 0;
		}
yy124:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy125;
			}
yy125:
			{
			token->opcode = PHQL_T_BY;
			return 0;
		}
yy126:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'F':
			case 'f':	goto yy140;
			default:	goto yy70;
			}
yy127:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy128;
			}
yy128:
			{
			token->opcode = PHQL_T_ON;
			return 0;
		}
yy129:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			case 'D':
			case 'd':	goto yy136;
			default:	goto yy130;
			}
yy130:
			{
			token->opcode = PHQL_T_OR;
			return 0;
		}
yy131:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy132;
			default:	goto yy70;
			}
yy132:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy133;
			default:	goto yy70;
			}
yy133:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy134;
			default:	goto yy70;
			}
yy134:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy135;
			}
yy135:
			{
			token->opcode = PHQL_T_OUTER;
			return 0;
		}
yy136:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy137;
			default:	goto yy70;
			}
yy137:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy138;
			default:	goto yy70;
			}
yy138:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy139;
			}
yy139:
			{
			token->opcode = PHQL_T_ORDER;
			return 0;
		}
yy140:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'S':
			case 's':	goto yy141;
			default:	goto yy70;
			}
yy141:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy142;
			default:	goto yy70;
			}
yy142:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy143;
			default:	goto yy70;
			}
yy143:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy144;
			}
yy144:
			{
			token->opcode = PHQL_T_OFFSET;
			return 0;
		}
yy145:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy146;
			default:	goto yy70;
			}
yy146:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy147;
			default:	goto yy70;
			}
yy147:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy148;
			default:	goto yy70;
			}
yy148:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy149;
			}
yy149:
			{
			token->opcode = PHQL_T_WHERE;
			return 0;
		}
yy150:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy151;
			default:	goto yy70;
			}
yy151:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'U':
			case 'u':	goto yy152;
			default:	goto yy70;
			}
yy152:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy153;
			default:	goto yy70;
			}
yy153:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'S':
			case 's':	goto yy154;
			default:	goto yy70;
			}
yy154:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy155;
			}
yy155:
			{
			token->opcode = PHQL_T_VALUES;
			return 0;
		}
yy156:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			case 'N':
			case 'n':	goto yy162;
			case 'S':
			case 's':	goto yy160;
			case 'T':
			case 't':	goto yy161;
			default:	goto yy157;
			}
yy157:
			{
			token->opcode = PHQL_T_IN;
			return 0;
		}
yy158:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy159;
			}
yy159:
			{
			token->opcode = PHQL_T_IS;
			return 0;
		}
yy160:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy168;
			default:	goto yy70;
			}
yy161:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy166;
			default:	goto yy70;
			}
yy162:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy163;
			default:	goto yy70;
			}
yy163:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy164;
			default:	goto yy70;
			}
yy164:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy165;
			}
yy165:
			{
			token->opcode = PHQL_T_INNER;
			return 0;
		}
yy166:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy167;
			}
yy167:
			{
			token->opcode = PHQL_T_INTO;
			return 0;
		}
yy168:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'R':
			case 'r':	goto yy169;
			default:	goto yy70;
			}
yy169:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy170;
			default:	goto yy70;
			}
yy170:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy171;
			}
yy171:
			{
			token->opcode = PHQL_T_INSERT;
			return 0;
		}
yy172:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'D':
			case 'd':	goto yy177;
			default:	goto yy70;
			}
yy173:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			case 'C':
			case 'c':	goto yy175;
			default:	goto yy174;
			}
yy174:
			{
			token->opcode = PHQL_T_AS;
			return 0;
		}
yy175:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy176;
			}
yy176:
			{
			token->opcode = PHQL_T_ASC;
			return 0;
		}
yy177:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy178;
			}
yy178:
			{
			token->opcode = PHQL_T_AND;
			return 0;
		}
yy179:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'O':
			case 'o':	goto yy184;
			default:	goto yy70;
			}
yy180:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy181;
			default:	goto yy70;
			}
yy181:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy182;
			default:	goto yy70;
			}
yy182:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy183;
			}
yy183:
			{
			token->opcode = PHQL_T_FULL;
			return 0;
		}
yy184:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'M':
			case 'm':	goto yy185;
			default:	goto yy70;
			}
yy185:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy186;
			}
yy186:
			{
			token->opcode = PHQL_T_FROM;
			return 0;
		}
yy187:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy188;
			case 'S':
			case 's':	goto yy189;
			default:	goto yy70;
			}
yy188:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy192;
			default:	goto yy70;
			}
yy189:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'C':
			case 'c':	goto yy190;
			default:	goto yy70;
			}
yy190:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy191;
			}
yy191:
			{
			token->opcode = PHQL_T_DESC;
			return 0;
		}
yy192:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy193;
			default:	goto yy70;
			}
yy193:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy194;
			default:	goto yy70;
			}
yy194:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy195;
			}
yy195:
			{
			token->opcode = PHQL_T_DELETE;
			return 0;
		}
yy196:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'L':
			case 'l':	goto yy199;
			case 'T':
			case 't':	goto yy197;
			default:	goto yy70;
			}
yy197:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy198;
			}
yy198:
			{
			token->opcode = PHQL_T_SET;
			return 0;
		}
yy199:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy200;
			default:	goto yy70;
			}
yy200:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'C':
			case 'c':	goto yy201;
			default:	goto yy70;
			}
yy201:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy202;
			default:	goto yy70;
			}
yy202:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy203;
			}
yy203:
			{
			token->opcode = PHQL_T_SELECT;
			return 0;
		}
yy204:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'D':
			case 'd':	goto yy205;
			default:	goto yy70;
			}
yy205:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'A':
			case 'a':	goto yy206;
			default:	goto yy70;
			}
yy206:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'T':
			case 't':	goto yy207;
			default:	goto yy70;
			}
yy207:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'E':
			case 'e':	goto yy208;
			default:	goto yy70;
			}
yy208:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy69;
			default:	goto yy209;
			}
yy209:
			{
			token->opcode = PHQL_T_UPDATE;
			return 0;
		}
yy210:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto yy210;
			case ':':	goto yy212;
			default:	goto yy73;
			}
yy212:
			++YYCURSOR;
			{
			token->opcode = PHQL_T_SPLACEHOLDER;
			token->value = estrndup(q, YYCURSOR - q - 1);
			token->len = YYCURSOR - q - 1;
			q = YYCURSOR;
			return 0;
		}
yy214:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy214;
			default:	goto yy216;
			}
yy216:
			{
			token->opcode = PHQL_T_NPLACEHOLDER;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
yy217:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy217;
			default:	goto yy219;
			}
yy219:
			{
			token->opcode = PHQL_T_DOUBLE;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
yy220:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy220;
			default:	goto yy219;
			}
yy222:
			++YYCURSOR;
			yych = *YYCURSOR;
			switch (yych) {
			case '.':	goto yy220;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy222;
			default:	goto yy3;
			}
		}

	}

	return status;
}




#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_StatusInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model\\Query, StatusInterface, mvc_model_query_statusinterface, phalcon_mvc_model_query_statusinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Query_StatusInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Query_StatusInterface, getModel);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Query_StatusInterface, getMessages);

PHALCON_DOC_METHOD(Phalcon_Mvc_Model_Query_StatusInterface, success);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Row){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Row, mvc_model_row, phalcon_mvc_model_row_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_row_ce TSRMLS_CC, 1, zend_ce_arrayaccess);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Row, setForceExists){


	
}

PHP_METHOD(Phalcon_Mvc_Model_Row, offsetExists){

	zval *index;
	int eval_int;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		RETURN_NULL();
	}

	eval_int = phalcon_isset_property_zval(this_ptr, index TSRMLS_CC);
	if (eval_int) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model_Row, offsetGet){

	zval *index, *value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_isset_property_zval(this_ptr, index TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_read_property_zval(&value, this_ptr, index, PH_NOISY_CC);
	
		RETURN_CCTOR(value);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The index does not exist in the row");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Row, offsetSet){

	zval *index, *value;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Row is an immutable ArrayAccess object");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model_Row, offsetUnset){

	zval *offset;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Row is an immutable ArrayAccess object");
	return;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Message){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Message, mvc_model_message, phalcon_mvc_model_message_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_field"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_message_ce TSRMLS_CC, 1, phalcon_mvc_model_messageinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Message, __construct){

	zval *message, *field = NULL, *type = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &message, &field, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!field) {
		PHALCON_INIT_NVAR(field);
	}
	
	if (!type) {
		PHALCON_INIT_NVAR(type);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_field"), field TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Message, setType){

	zval *type;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Message, getType){


	RETURN_MEMBER(this_ptr, "_type");
}

PHP_METHOD(Phalcon_Mvc_Model_Message, setMessage){

	zval *message;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Message, getMessage){


	RETURN_MEMBER(this_ptr, "_message");
}

PHP_METHOD(Phalcon_Mvc_Model_Message, setField){

	zval *field;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &field) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_field"), field TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Message, getField){


	RETURN_MEMBER(this_ptr, "_field");
}

PHP_METHOD(Phalcon_Mvc_Model_Message, __toString){


	RETURN_MEMBER(this_ptr, "_message");
}

PHP_METHOD(Phalcon_Mvc_Model_Message, __set_state){

	zval *message, *message_text, *field, *type, *message_object;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(message_text);
	phalcon_array_fetch_string(&message_text, message, SL("_message"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(field);
	phalcon_array_fetch_string(&field, message, SL("_field"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(type);
	phalcon_array_fetch_string(&type, message, SL("_type"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(message_object);
	object_init_ex(message_object, phalcon_mvc_model_message_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(message_object, "__construct", message_text, field, type, PH_CHECK);
	
	RETURN_CTOR(message_object);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model, Exception, mvc_model_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Transaction, mvc_model_transaction, phalcon_mvc_model_transaction_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_activeTransaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_isNewTransaction"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_rollbackOnAbort"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_rollbackRecord"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_transaction_ce TSRMLS_CC, 1, phalcon_mvc_model_transactioninterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, __construct){

	zval *dependency_injector, *auto_begin = NULL, *service;
	zval *connection;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_mvc_model_transaction_ce, this_ptr, SL("_messages") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &dependency_injector, &auto_begin) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!auto_begin) {
		PHALCON_INIT_NVAR(auto_begin);
		ZVAL_BOOL(auto_begin, 0);
	}
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "db", 1);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD_PARAMS_1(connection, dependency_injector, "get", service, PH_NO_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	if (zend_is_true(auto_begin)) {
		PHALCON_CALL_METHOD_NORETURN(connection, "begin", PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, setTransactionManager){

	zval *manager;
	zval *i0 = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &manager) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_INIT_VAR(i0);
		object_init_ex(i0, phalcon_mvc_model_transaction_exception_ce);
		PHALCON_INIT_VAR(r0);
		PHALCON_CONCAT_VS(r0, manager, " must be an Object");
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(i0, "__construct", r0, PH_CHECK);
		phalcon_throw_exception(i0 TSRMLS_CC);
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_manager"), manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, begin){

	zval *connection, *success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, connection, "begin", PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, commit){

	zval *manager, *call_object, *arguments, *connection;
	zval *success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(call_object);
		array_init(call_object);
		phalcon_array_append(&call_object, manager, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(call_object, SL("notifyCommit"), 1);
	
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
		phalcon_array_append(&arguments, this_ptr, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("call_user_func_array", call_object, arguments);
	}
	
	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, connection, "commit", PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, rollback){

	zval *rollback_message = NULL, *rollback_record = NULL;
	zval *manager, *call_object, *arguments, *connection;
	zval *success, *exception;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &rollback_message, &rollback_record) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!rollback_message) {
		PHALCON_INIT_NVAR(rollback_message);
	} else {
		PHALCON_SEPARATE_PARAM(rollback_message);
	}
	
	if (!rollback_record) {
		PHALCON_INIT_NVAR(rollback_record);
	} else {
		PHALCON_SEPARATE_PARAM(rollback_record);
	}
	
	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(call_object);
		array_init(call_object);
		phalcon_array_append(&call_object, manager, PH_SEPARATE TSRMLS_CC);
		add_next_index_stringl(call_object, SL("notifyRollback"), 1);
	
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
		phalcon_array_append(&arguments, this_ptr, PH_SEPARATE TSRMLS_CC);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("call_user_func_array", call_object, arguments);
	}
	
	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, connection, "rollback", PH_NO_CHECK);
	if (zend_is_true(success)) {
		if (!zend_is_true(rollback_message)) {
			PHALCON_INIT_NVAR(rollback_message);
			ZVAL_STRING(rollback_message, "Transaction aborted", 1);
		}
		if (Z_TYPE_P(rollback_record) == IS_OBJECT) {
			phalcon_update_property_zval(this_ptr, SL("_rollbackRecord"), rollback_record TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(rollback_record);
		phalcon_read_property(&rollback_record, this_ptr, SL("_rollbackRecord"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(exception);
		object_init_ex(exception, phalcon_mvc_model_transaction_failed_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(exception, "__construct", rollback_message, rollback_record, PH_CHECK);
		phalcon_throw_exception(exception TSRMLS_CC);
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, getConnection){

	zval *rollback_on_abort, *was_aborted, *message;
	zval *connection;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(rollback_on_abort);
	phalcon_read_property(&rollback_on_abort, this_ptr, SL("_rollbackOnAbort"), PH_NOISY_CC);
	if (zend_is_true(rollback_on_abort)) {
		PHALCON_INIT_VAR(was_aborted);
		PHALCON_CALL_FUNC(was_aborted, "connection_aborted");
		if (zend_is_true(was_aborted)) {
			PHALCON_INIT_VAR(message);
			ZVAL_STRING(message, "The request was aborted", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "rollback", message, PH_NO_CHECK);
		}
	}
	
	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	RETURN_CCTOR(connection);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, setIsNewTransaction){

	zval *is_new;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &is_new) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_isNewTransaction"), is_new TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackOnAbort){

	zval *rollback_on_abort;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &rollback_on_abort) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_rollbackOnAbort"), rollback_on_abort TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, isManaged){

	zval *manager, *is_managed = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(manager);
	phalcon_read_property(&manager, this_ptr, SL("_manager"), PH_NOISY_CC);
	
	PHALCON_ALLOC_ZVAL_MM(r0);
	boolean_not_function(r0, manager TSRMLS_CC);
	PHALCON_CPY_WRT(is_managed, r0);
	
	RETURN_NCTOR(is_managed);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, getMessages){


	RETURN_MEMBER(this_ptr, "_messages");
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, isValid){

	zval *connection, *is_valid;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(is_valid);
	PHALCON_CALL_METHOD(is_valid, connection, "isundertransaction", PH_NO_CHECK);
	
	RETURN_CCTOR(is_valid);
}

PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackedRecord){

	zval *record;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &record) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_rollbackRecord"), record TSRMLS_CC);
	
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Validator, mvc_model_validator, phalcon_mvc_model_validator_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_validator_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_validator_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, __construct){

	zval *options;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_mvc_model_validator_ce, this_ptr, SL("_options") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_model_validator_ce, this_ptr, SL("_messages") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "$options argument must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, appendMessage){

	zval *message, *field = NULL, *type = NULL, *class_name, *suffix;
	zval *empty_string, *model_message;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &message, &field, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!field) {
		PHALCON_INIT_NVAR(field);
	}
	
	if (!type) {
		PHALCON_INIT_NVAR(type);
	} else {
		PHALCON_SEPARATE_PARAM(type);
	}
	
	if (!zend_is_true(type)) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, this_ptr TSRMLS_CC);
	
		PHALCON_INIT_VAR(suffix);
		ZVAL_STRING(suffix, "Validator", 1);
	
		PHALCON_INIT_VAR(empty_string);
		ZVAL_STRING(empty_string, "", 1);
	
		PHALCON_INIT_NVAR(type);
		phalcon_fast_str_replace(type, suffix, empty_string, class_name TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(model_message);
	object_init_ex(model_message, phalcon_mvc_model_message_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(model_message, "__construct", message, field, type, PH_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_messages"), PH_NOISY_CC);
	phalcon_array_append(&t0, model_message, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_messages"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, getMessages){


	RETURN_MEMBER(this_ptr, "_messages");
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, getOptions){


	RETURN_MEMBER(this_ptr, "_options");
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, getOption){

	zval *option, *options, *value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(options, option);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, options, option, PH_NOISY_CC);
	
		RETURN_CCTOR(value);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_STRING("", 1);
}

PHP_METHOD(Phalcon_Mvc_Model_Validator, isSetOption){

	zval *option, *options, *is_set = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(options, option);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(is_set, r0);
	
	RETURN_NCTOR(is_set);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_Router_RouteInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Router, RouteInterface, mvc_router_routeinterface, phalcon_mvc_router_routeinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, compilePattern);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, via);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, reConfigure);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, setName);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, setHttpMethods);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getRouteId);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getPattern);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getCompiledPattern);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getPaths);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, getHttpMethods);

PHALCON_DOC_METHOD(Phalcon_Mvc_Router_RouteInterface, reset);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Route){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Router, Route, mvc_router_route, phalcon_mvc_router_route_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_pattern"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_compiledPattern"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_paths"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_methods"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_id"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_uniqueId"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_router_route_ce TSRMLS_CC, 1, phalcon_mvc_router_routeinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Router_Route, __construct){

	zval *pattern, *paths = NULL, *http_methods = NULL, *unique_id = NULL;
	zval *route_id = NULL, *one, *next_id;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &pattern, &paths, &http_methods) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	if (!http_methods) {
		PHALCON_INIT_NVAR(http_methods);
	}
	
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "reconfigure", pattern, paths, PH_NO_CHECK);
	phalcon_update_property_zval(this_ptr, SL("_methods"), http_methods TSRMLS_CC);
	PHALCON_OBSERVE_VAR(unique_id);
	phalcon_read_static_property(&unique_id, SL("phalcon\\mvc\\router\\route"), SL("_uniqueId") TSRMLS_CC);
	if (Z_TYPE_P(unique_id) == IS_NULL) {
		PHALCON_INIT_NVAR(unique_id);
		ZVAL_LONG(unique_id, 0);
	}
	
	PHALCON_CPY_WRT(route_id, unique_id);
	phalcon_update_property_zval(this_ptr, SL("_id"), route_id TSRMLS_CC);
	
	PHALCON_INIT_VAR(one);
	ZVAL_LONG(one, 1);
	
	PHALCON_INIT_VAR(next_id);
	phalcon_add_function(next_id, unique_id, one TSRMLS_CC);
	phalcon_update_static_property(SL("phalcon\\mvc\\router\\route"), SL("_uniqueId"), next_id TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router_Route, compilePattern){

	zval *pattern, *compiled_pattern = NULL, *id_pattern;
	zval *wildcard = NULL, *pattern_copy = NULL, *params_pattern;
	zval *int_pattern, *final_pattern = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &pattern) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_CPY_WRT(compiled_pattern, pattern);
	if (phalcon_memnstr_str(pattern, SL(":") TSRMLS_CC)) {
		PHALCON_INIT_VAR(id_pattern);
		ZVAL_STRING(id_pattern, "/([a-zA-Z0-9\\_\\-]+)", 1);
		if (phalcon_memnstr_str(pattern, SL("/:module") TSRMLS_CC)) {
			PHALCON_INIT_VAR(wildcard);
			ZVAL_STRING(wildcard, "/:module", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_VAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, id_pattern, pattern_copy TSRMLS_CC);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:controller") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, "/:controller", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, id_pattern, pattern_copy TSRMLS_CC);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:namespace") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, "/:namespace", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, id_pattern, pattern_copy TSRMLS_CC);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:action") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, "/:action", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, id_pattern, pattern_copy TSRMLS_CC);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:params") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, "/:params", 1);
	
			PHALCON_INIT_VAR(params_pattern);
			ZVAL_STRING(params_pattern, "(/.*)*", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, params_pattern, pattern_copy TSRMLS_CC);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:int") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, "/:int", 1);
	
			PHALCON_INIT_VAR(int_pattern);
			ZVAL_STRING(int_pattern, "/([0-9]+)", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, wildcard, int_pattern, pattern_copy TSRMLS_CC);
		}
	}
	
	if (phalcon_memnstr_str(compiled_pattern, SL("(") TSRMLS_CC)) {
		PHALCON_INIT_VAR(final_pattern);
		PHALCON_CONCAT_SVS(final_pattern, "#^", compiled_pattern, "$#");
	} else {
		PHALCON_CPY_WRT(final_pattern, compiled_pattern);
	}
	
	
	RETURN_CCTOR(final_pattern);
}

PHP_METHOD(Phalcon_Mvc_Router_Route, via){

	zval *http_methods;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &http_methods) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_methods"), http_methods TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Router_Route, reConfigure){

	zval *pattern, *paths = NULL, *double_colon, *parts, *part_zero;
	zval *controller_name, *route_paths = NULL, *part_one;
	zval *pcre_pattern = NULL, *compiled_pattern = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	if (Z_TYPE_P(pattern) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "The pattern must be string");
		return;
	}
	if (Z_TYPE_P(paths) != IS_NULL) {
		if (Z_TYPE_P(paths) == IS_STRING) {
			PHALCON_INIT_VAR(double_colon);
			ZVAL_STRING(double_colon, "::", 1);
	
			PHALCON_INIT_VAR(parts);
			phalcon_fast_explode(parts, double_colon, paths TSRMLS_CC);
	
			PHALCON_INIT_VAR(part_zero);
			phalcon_array_fetch_long(&part_zero, parts, 0, PH_NOISY_CC);
	
			PHALCON_INIT_VAR(controller_name);
			PHALCON_CALL_FUNC_PARAMS_1(controller_name, "strtolower", part_zero);
	
			PHALCON_INIT_VAR(route_paths);
			array_init(route_paths);
			phalcon_array_update_string(&route_paths, SL("controller"), &controller_name, PH_COPY | PH_SEPARATE TSRMLS_CC);
			eval_int = phalcon_array_isset_long(parts, 1);
			if (eval_int) {
				PHALCON_INIT_VAR(part_one);
				phalcon_array_fetch_long(&part_one, parts, 1, PH_NOISY_CC);
				phalcon_array_update_string(&route_paths, SL("action"), &part_one, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
		} else {
			PHALCON_CPY_WRT(route_paths, paths);
		}
	} else {
		PHALCON_INIT_NVAR(route_paths);
		array_init(route_paths);
	}
	
	if (!phalcon_start_with_str(pattern, SL("#"))) {
		if (phalcon_memnstr_str(pattern, SL("{") TSRMLS_CC)) {
			PHALCON_INIT_VAR(pcre_pattern);
			phalcon_extract_named_params(pcre_pattern, pattern, route_paths);
		} else {
			PHALCON_CPY_WRT(pcre_pattern, pattern);
		}
	
		PHALCON_INIT_VAR(compiled_pattern);
		PHALCON_CALL_METHOD_PARAMS_1(compiled_pattern, this_ptr, "compilepattern", pcre_pattern, PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(compiled_pattern, pattern);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_pattern"), pattern TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_compiledPattern"), compiled_pattern TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_paths"), route_paths TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getName){


	RETURN_MEMBER(this_ptr, "_name");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, setName){

	zval *name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Router_Route, setHttpMethods){

	zval *http_methods;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &http_methods) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_methods"), http_methods TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getRouteId){


	RETURN_MEMBER(this_ptr, "_id");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getPattern){


	RETURN_MEMBER(this_ptr, "_pattern");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getCompiledPattern){


	RETURN_MEMBER(this_ptr, "_compiledPattern");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getPaths){


	RETURN_MEMBER(this_ptr, "_paths");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, getHttpMethods){


	RETURN_MEMBER(this_ptr, "_methods");
}

PHP_METHOD(Phalcon_Mvc_Router_Route, reset){

	zval *zero;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(zero);
	ZVAL_LONG(zero, 0);
	phalcon_update_static_property(SL("phalcon\\mvc\\router\\route"), SL("_uniqueId"), zero TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Router, Exception, mvc_router_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Url){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Url, mvc_url, phalcon_mvc_url_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_url_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_baseUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_basePath"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_url_ce TSRMLS_CC, 2, phalcon_mvc_urlinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Url, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_url_exception_ce, "The dependency injector must be an Object");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Url, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Url, setBaseUri){

	zval *base_uri;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_uri) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_baseUri"), base_uri TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Url, getBaseUri){

	zval *base_uri = NULL, *slash, *one, *minus_one = NULL, *php_self;
	zval *dirname, *dir_parts, *slice, *uri = NULL;
	zval *g0 = NULL;
	zval *c0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(base_uri);
	phalcon_read_property(&base_uri, this_ptr, SL("_baseUri"), PH_NOISY_CC);
	if (Z_TYPE_P(base_uri) == IS_NULL) {
		PHALCON_INIT_VAR(slash);
		ZVAL_STRING(slash, "/", 1);
		phalcon_get_global(&g0, SL("_SERVER")+1 TSRMLS_CC);
		eval_int = phalcon_array_isset_string(g0, SS("PHP_SELF"));
		if (eval_int) {
			PHALCON_INIT_VAR(one);
			ZVAL_LONG(one, 1);
	
			PHALCON_INIT_VAR(c0);
			ZVAL_LONG(c0, -1);
			PHALCON_CPY_WRT(minus_one, c0);
	
			PHALCON_INIT_VAR(php_self);
			phalcon_array_fetch_string(&php_self, g0, SL("PHP_SELF"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(dirname);
			PHALCON_CALL_FUNC_PARAMS_1(dirname, "dirname", php_self);
	
			PHALCON_INIT_VAR(dir_parts);
			phalcon_fast_explode(dir_parts, slash, dirname TSRMLS_CC);
	
			PHALCON_INIT_VAR(slice);
			PHALCON_CALL_FUNC_PARAMS_3(slice, "array_slice", dir_parts, one, minus_one);
	
			PHALCON_INIT_VAR(uri);
			phalcon_fast_join(uri, slash, slice TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(uri);
			ZVAL_STRING(uri, "", 1);
		}
	
		if (PHALCON_COMPARE_STRING(uri, "")) {
			PHALCON_CPY_WRT(base_uri, slash);
		} else {
			PHALCON_INIT_NVAR(base_uri);
			PHALCON_CONCAT_VVV(base_uri, slash, uri, slash);
		}
	
		phalcon_update_property_zval(this_ptr, SL("_baseUri"), base_uri TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(base_uri);
}

PHP_METHOD(Phalcon_Mvc_Url, setBasePath){

	zval *base_path;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Url, getBasePath){


	RETURN_MEMBER(this_ptr, "_basePath");
}

PHP_METHOD(Phalcon_Mvc_Url, get){

	zval *uri = NULL, *base_uri, *dependency_injector, *service;
	zval *router, *route_name, *route, *exception_message;
	zval *pattern, *replaced_pattern = NULL, *controller_name;
	zval *wildcard = NULL, *action_name, *matches, *match_position;
	zval *set_order, *names_pattern, *have_variables = NULL;
	zval *match = NULL, *match_zero = NULL, *match_one = NULL, *value = NULL, *new_pcre_pattern = NULL;
	zval *final_uri;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL;
	zval *p0[] = { NULL, NULL, NULL, NULL };
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!uri) {
		PHALCON_INIT_NVAR(uri);
	}
	
	PHALCON_INIT_VAR(base_uri);
	PHALCON_CALL_METHOD(base_uri, this_ptr, "getbaseuri", PH_NO_CHECK);
	if (Z_TYPE_P(uri) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(uri, SS("for"));
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_url_exception_ce, "It's necessary to define the route name with the parameter \"for\"");
			return;
		}
	
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
		if (!zend_is_true(dependency_injector)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_url_exception_ce, "A dependency injector container is required to obtain the \"url\" service");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "router", 1);
	
		PHALCON_INIT_VAR(router);
		PHALCON_CALL_METHOD_PARAMS_1(router, dependency_injector, "getshared", service, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(route_name);
		phalcon_array_fetch_string(&route_name, uri, SL("for"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(route);
		PHALCON_CALL_METHOD_PARAMS_1(route, router, "getroutebyname", route_name, PH_NO_CHECK);
		if (Z_TYPE_P(route) != IS_OBJECT) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Cannot obtain a route using the name \"", route_name, "\"");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_url_exception_ce, exception_message);
			return;
		}
	
		PHALCON_INIT_VAR(pattern);
		PHALCON_CALL_METHOD(pattern, route, "getpattern", PH_NO_CHECK);
		PHALCON_CPY_WRT(replaced_pattern, pattern);
		eval_int = phalcon_array_isset_string(uri, SS("controller"));
		if (eval_int) {
			PHALCON_INIT_VAR(controller_name);
			phalcon_array_fetch_string(&controller_name, uri, SL("controller"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(wildcard);
			ZVAL_STRING(wildcard, ":controller", 1);
	
			PHALCON_INIT_VAR(r0);
			phalcon_fast_str_replace(r0, wildcard, controller_name, replaced_pattern TSRMLS_CC);
			PHALCON_CPY_WRT(replaced_pattern, r0);
		}
	
		eval_int = phalcon_array_isset_string(uri, SS("action"));
		if (eval_int) {
			PHALCON_INIT_VAR(action_name);
			phalcon_array_fetch_string(&action_name, uri, SL("action"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(wildcard);
			ZVAL_STRING(wildcard, ":action", 1);
	
			PHALCON_INIT_VAR(r1);
			phalcon_fast_str_replace(r1, wildcard, action_name, replaced_pattern TSRMLS_CC);
			PHALCON_CPY_WRT(replaced_pattern, r1);
		}
	
		if (phalcon_memnstr_str(replaced_pattern, SL("{") TSRMLS_CC)) {
			PHALCON_INIT_VAR(matches);
	
			PHALCON_INIT_VAR(match_position);
			ZVAL_LONG(match_position, 1);
	
			PHALCON_INIT_VAR(set_order);
			ZVAL_LONG(set_order, 2);
	
			PHALCON_INIT_VAR(names_pattern);
			ZVAL_STRING(names_pattern, "#{(([a-zA-Z][a-zA-Z0-9\\_\\-]*)*)(:([^}]+}?))*}#", 1);
			p0[0] = names_pattern;
			p0[1] = replaced_pattern;
			Z_SET_ISREF_P(matches);
			p0[2] = matches;
			p0[3] = set_order;
	
			PHALCON_INIT_VAR(r2);
			PHALCON_CALL_FUNC_PARAMS(r2, "preg_match_all", 4, p0);
			Z_UNSET_ISREF_P(p0[2]);
			PHALCON_CPY_WRT(have_variables, r2);
			if (zend_is_true(have_variables)) {
	
				if (!phalcon_valid_foreach(matches TSRMLS_CC)) {
					return;
				}
	
				ah0 = Z_ARRVAL_P(matches);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
				ph_cycle_start_0:
	
					if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
						goto ph_cycle_end_0;
					}
	
					PHALCON_GET_FOREACH_VALUE(match);
	
					PHALCON_INIT_NVAR(match_zero);
					phalcon_array_fetch_long(&match_zero, match, 0, PH_NOISY_CC);
	
					PHALCON_INIT_NVAR(match_one);
					phalcon_array_fetch_long(&match_one, match, 1, PH_NOISY_CC);
					eval_int = phalcon_array_isset(uri, match_one);
					if (eval_int) {
						PHALCON_INIT_NVAR(value);
						phalcon_array_fetch(&value, uri, match_one, PH_NOISY_CC);
	
						PHALCON_INIT_NVAR(new_pcre_pattern);
						phalcon_fast_str_replace(new_pcre_pattern, match_zero, value, replaced_pattern TSRMLS_CC);
						PHALCON_CPY_WRT(replaced_pattern, new_pcre_pattern);
					}
	
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
	
				ph_cycle_end_0:
				if(0){}
	
			}
		}
	
	
		RETURN_CCTOR(replaced_pattern);
	} else {
		PHALCON_INIT_VAR(final_uri);
		PHALCON_CONCAT_VV(final_uri, base_uri, uri);
	
		RETURN_CTOR(final_uri);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Url, path){

	zval *path = NULL, *base_path, *final_path;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!path) {
		PHALCON_INIT_NVAR(path);
	}
	
	PHALCON_INIT_VAR(base_path);
	phalcon_read_property(&base_path, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(final_path);
	PHALCON_CONCAT_VV(final_path, base_path, path);
	
	RETURN_CTOR(final_path);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_ModelInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ModelInterface, mvc_modelinterface, phalcon_mvc_modelinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, setTransaction);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getSource);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getSchema);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, setConnectionService);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getConnectionService);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, setForceExists);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getConnection);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, dumpResult);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, find);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, findFirst);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, query);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, count);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, sum);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, maximum);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, minimum);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, average);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, appendMessage);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, validationHasFailed);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getMessages);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, save);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, create);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, update);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, delete);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getOperationMade);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, readAttribute);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, writeAttribute);

PHALCON_DOC_METHOD(Phalcon_Mvc_ModelInterface, getRelated);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_UrlInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, UrlInterface, mvc_urlinterface, phalcon_mvc_urlinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, setBaseUri);

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, getBaseUri);

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, setBasePath);

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, getBasePath);

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, get);

PHALCON_DOC_METHOD(Phalcon_Mvc_UrlInterface, path);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Collection, Manager, mvc_collection_manager, phalcon_mvc_collection_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_initialized"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Collection_Manager, __construct){


	phalcon_update_property_empty_array(phalcon_mvc_collection_manager_ce, this_ptr, SL("_initialized") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Collection_Manager, isInitialized){

	zval *collection;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &collection) == FAILURE) {
		RETURN_NULL();
	}

	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Collection_Manager, initialize){


	
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Collection, Exception, mvc_collection_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_User_Module){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Module, mvc_user_module, "phalcon\\di\\injectable", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_User_Plugin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Plugin, mvc_user_plugin, "phalcon\\di\\injectable", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_User_Component){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Component, mvc_user_component, "phalcon\\di\\injectable", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_View_EngineInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\View, EngineInterface, mvc_view_engineinterface, phalcon_mvc_view_engineinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_View_EngineInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Mvc_View_EngineInterface, getContent);

PHALCON_DOC_METHOD(Phalcon_Mvc_View_EngineInterface, partial);

PHALCON_DOC_METHOD(Phalcon_Mvc_View_EngineInterface, render);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Volt){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View\\Engine, Volt, mvc_view_engine_volt, "phalcon\\mvc\\view\\engine", phalcon_mvc_view_engine_volt_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_engine_volt_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_engine_volt_ce TSRMLS_CC, 2, phalcon_mvc_view_engineinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, setOptions){

	zval *options;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Options parameter must be an array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getOptions){


	RETURN_MEMBER(this_ptr, "_options");
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, render){

	zval *template_path, *params, *must_clean, *stat = NULL;
	zval *compiled_path = NULL, *compiled_separator = NULL;
	zval *compiled_extension = NULL, *options, *win_separator;
	zval *unix_separator, *template_win_path;
	zval *template_sep_path = NULL, *compiled_template_path;
	zval *compiler = NULL, *exception_message, *value = NULL, *key = NULL;
	zval *contents, *view;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &template_path, &params, &must_clean) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (PHALCON_IS_TRUE(must_clean)) {
		PHALCON_CALL_FUNC_NORETURN("ob_clean");
	}
	
	PHALCON_INIT_VAR(stat);
	ZVAL_BOOL(stat, 1);
	
	PHALCON_INIT_VAR(compiled_path);
	
	PHALCON_INIT_VAR(compiled_separator);
	ZVAL_STRING(compiled_separator, "%%", 1);
	
	PHALCON_INIT_VAR(compiled_extension);
	ZVAL_STRING(compiled_extension, ".php", 1);
	
	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("compiledPath"));
		if (eval_int) {
			phalcon_array_fetch_string(&compiled_path, options, SL("compiledPath"), PH_NOISY_CC);
			if (Z_TYPE_P(compiled_path) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledPath must be a string");
				return;
			}
		}
		eval_int = phalcon_array_isset_string(options, SS("compiledSeparator"));
		if (eval_int) {
			PHALCON_INIT_NVAR(compiled_separator);
			phalcon_array_fetch_string(&compiled_separator, options, SL("compiledSeparator"), PH_NOISY_CC);
			if (Z_TYPE_P(compiled_separator) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledSeparator must be a string");
				return;
			}
		}
	
		eval_int = phalcon_array_isset_string(options, SS("compiledExtension"));
		if (eval_int) {
			PHALCON_INIT_NVAR(compiled_extension);
			phalcon_array_fetch_string(&compiled_extension, options, SL("compiledExtension"), PH_NOISY_CC);
			if (Z_TYPE_P(compiled_extension) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledExtension must be a string");
				return;
			}
		}
	
		eval_int = phalcon_array_isset_string(options, SS("stat"));
		if (eval_int) {
			phalcon_array_fetch_string(&stat, options, SL("stat"), PH_NOISY_CC);
		}
	}
	
	if (Z_TYPE_P(compiled_path) != IS_NULL) {
		PHALCON_INIT_VAR(win_separator);
		ZVAL_STRING(win_separator, "\\", 1);
	
		PHALCON_INIT_VAR(unix_separator);
		ZVAL_STRING(unix_separator, "/", 1);
	
		PHALCON_INIT_VAR(template_win_path);
		phalcon_fast_str_replace(template_win_path, win_separator, compiled_separator, template_path TSRMLS_CC);
	
		PHALCON_INIT_VAR(template_sep_path);
		phalcon_fast_str_replace(template_sep_path, unix_separator, compiled_separator, template_win_path TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(template_sep_path, template_path);
	}
	
	PHALCON_INIT_VAR(compiled_template_path);
	PHALCON_CONCAT_VVV(compiled_template_path, compiled_path, template_sep_path, compiled_extension);
	if (PHALCON_IS_TRUE(stat)) {
		if (phalcon_file_exists(compiled_template_path TSRMLS_CC) == SUCCESS) {
			if (phalcon_compare_mtime(template_path, compiled_template_path TSRMLS_CC)) {
				PHALCON_INIT_VAR(compiler);
				object_init_ex(compiler, phalcon_mvc_view_engine_volt_compiler_ce);
				PHALCON_CALL_METHOD_PARAMS_2_NORETURN(compiler, "compile", template_path, compiled_template_path, PH_NO_CHECK);
			}
		} else {
			PHALCON_INIT_NVAR(compiler);
			object_init_ex(compiler, phalcon_mvc_view_engine_volt_compiler_ce);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(compiler, "compile", template_path, compiled_template_path, PH_NO_CHECK);
		}
	} else {
		if (phalcon_file_exists(compiled_template_path TSRMLS_CC) == FAILURE) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Compiled template file ", compiled_template_path, " does not exist");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
			return;
		}
	}
	
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (phalcon_set_symbol(key, value TSRMLS_CC) == FAILURE){
			return;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (phalcon_require(compiled_template_path TSRMLS_CC) == FAILURE) {
		return;
	}
	if (PHALCON_IS_TRUE(must_clean)) {
		PHALCON_INIT_VAR(contents);
		PHALCON_CALL_FUNC(contents, "ob_get_contents");
	
		PHALCON_INIT_VAR(view);
		phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(view, "setcontent", contents, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, length){

	zval *item, *length = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &item) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(item) == IS_STRING) {
		PHALCON_INIT_VAR(length);
		phalcon_fast_strlen(length, item);
	} else {
		PHALCON_INIT_NVAR(length);
		phalcon_fast_count(length, item TSRMLS_CC);
	}
	
	RETURN_CCTOR(length);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Php){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View\\Engine, Php, mvc_view_engine_php, "phalcon\\mvc\\view\\engine", phalcon_mvc_view_engine_php_method_entry, 0);

	zend_class_implements(phalcon_mvc_view_engine_php_ce TSRMLS_CC, 1, phalcon_mvc_view_engineinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Php, render){

	zval *path, *params, *must_clean, *value = NULL, *key = NULL, *contents;
	zval *view;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &path, &params, &must_clean) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (PHALCON_IS_TRUE(must_clean)) {
		PHALCON_CALL_FUNC_NORETURN("ob_clean");
	}
	
	if (!phalcon_valid_foreach(params TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(params);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (phalcon_set_symbol(key, value TSRMLS_CC) == FAILURE){
			return;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (phalcon_require(path TSRMLS_CC) == FAILURE) {
		return;
	}
	if (PHALCON_IS_TRUE(must_clean)) {
		PHALCON_INIT_VAR(contents);
		PHALCON_CALL_FUNC(contents, "ob_get_contents");
	
		PHALCON_INIT_VAR(view);
		phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(view, "setcontent", contents, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Volt_Compiler){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\View\\Engine\\Volt, Compiler, mvc_view_engine_volt_compiler, phalcon_mvc_view_engine_volt_compiler_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_arrayHelpers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_engine_volt_compiler_ce, SL("_extendsMode"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_extendsNode"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_currentBlock"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_blocks"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI){

	zval *di;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &di) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), di TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _functionCall){

	zval *expr, *extends_mode, *code = NULL, *func_arguments;
	zval *arguments = NULL, *name, *camelized, *method, *class_name;
	zval *array_helpers = NULL, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &expr, &extends_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(code);
	eval_int = phalcon_array_isset_string(expr, SS("arguments"));
	if (eval_int) {
		PHALCON_INIT_VAR(func_arguments);
		phalcon_array_fetch_string(&func_arguments, expr, SL("arguments"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(arguments);
		PHALCON_CALL_METHOD_PARAMS_2(arguments, this_ptr, "_expression", func_arguments, extends_mode, PH_NO_CHECK);
	} else {
		PHALCON_INIT_NVAR(arguments);
		ZVAL_STRING(arguments, "", 1);
	}
	
	PHALCON_INIT_VAR(name);
	phalcon_array_fetch_string(&name, expr, SL("name"), PH_NOISY_CC);
	if (PHALCON_COMPARE_STRING(name, "content")) {
		ZVAL_STRING(code, "$this->getContent()", 1);
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "partial")) {
		PHALCON_INIT_NVAR(code);
		PHALCON_CONCAT_SVS(code, "$this->partial(", arguments, ")");
	
		RETURN_CCTOR(code);
	}
	
	PHALCON_INIT_VAR(camelized);
	phalcon_camelize(camelized, name TSRMLS_CC);
	
	PHALCON_INIT_VAR(method);
	PHALCON_CALL_FUNC_PARAMS_1(method, "lcfirst", camelized);
	
	PHALCON_INIT_VAR(class_name);
	ZVAL_STRING(class_name, "Phalcon\\Tag", 1);
	if (phalcon_method_exists(class_name, method TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(array_helpers);
		phalcon_read_property(&array_helpers, this_ptr, SL("_arrayHelpers"), PH_NOISY_CC);
		if (Z_TYPE_P(array_helpers) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(array_helpers);
			array_init(array_helpers);
			add_assoc_bool_ex(array_helpers, SS("link_to"), 1);
			add_assoc_bool_ex(array_helpers, SS("image"), 1);
			add_assoc_bool_ex(array_helpers, SS("form"), 1);
			add_assoc_bool_ex(array_helpers, SS("select"), 1);
			add_assoc_bool_ex(array_helpers, SS("select_static"), 1);
			add_assoc_bool_ex(array_helpers, SS("submit_button"), 1);
			add_assoc_bool_ex(array_helpers, SS("radio_field"), 1);
			add_assoc_bool_ex(array_helpers, SS("checkbox_field"), 1);
			add_assoc_bool_ex(array_helpers, SS("file_field"), 1);
			add_assoc_bool_ex(array_helpers, SS("hidden_field"), 1);
			add_assoc_bool_ex(array_helpers, SS("password_field"), 1);
			add_assoc_bool_ex(array_helpers, SS("text_area"), 1);
			add_assoc_bool_ex(array_helpers, SS("text_field"), 1);
			phalcon_update_property_zval(this_ptr, SL("_arrayHelpers"), array_helpers TSRMLS_CC);
		}
	
		eval_int = phalcon_array_isset(array_helpers, name);
		if (eval_int) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVSVS(code, "Phalcon\\Tag::", method, "(array(", arguments, "))");
		} else {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVSVS(code, "Phalcon\\Tag::", method, "(", arguments, ")");
		}
	
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "date")) {
		PHALCON_INIT_NVAR(code);
		PHALCON_CONCAT_SVS(code, "date(", arguments, ")");
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "time")) {
		PHALCON_INIT_NVAR(code);
		ZVAL_STRING(code, "time()", 1);
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "dump")) {
		PHALCON_INIT_NVAR(code);
		PHALCON_CONCAT_SVS(code, "var_dump(", arguments, ")");
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "version")) {
		PHALCON_INIT_NVAR(code);
		ZVAL_STRING(code, "Phalcon\\Version::get()", 1);
	
		RETURN_CCTOR(code);
	}
	
	if (PHALCON_COMPARE_STRING(name, "version_id")) {
		PHALCON_INIT_NVAR(code);
		ZVAL_STRING(code, "Phalcon\\Version::getId()", 1);
	
		RETURN_CCTOR(code);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Undefined function ", name);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _filter){

	zval *filter, *left, *exists = NULL, *type, *code = NULL, *name, *exception_message = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &filter, &left) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(exists);
	ZVAL_BOOL(exists, 0);
	
	PHALCON_INIT_VAR(type);
	phalcon_array_fetch_string(&type, filter, SL("type"), PH_NOISY_CC);
	if (phalcon_compare_strict_long(type, 355 TSRMLS_CC)) {
		PHALCON_INIT_VAR(code);
	
		PHALCON_INIT_VAR(name);
		phalcon_array_fetch_string(&name, filter, SL("name"), PH_NOISY_CC);
		if (PHALCON_COMPARE_STRING(name, "length")) {
			PHALCON_CONCAT_SVS(code, "$this->length(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "e")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "$this->escaper->escapeHtml(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "escape")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "$this->escaper->escapeHtml(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "trim")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "trim(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "striptags")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "striptags(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "slashes")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "addslashes(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "stripslashes")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "stripslashes(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "nl2br")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "nl2br(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "lowercase")) {
			if (phalcon_function_exists_ex(SS("mb_strtolower") TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_NVAR(code);
				PHALCON_CONCAT_SVS(code, "mb_strtolower(", left, ")");
			} else {
				PHALCON_INIT_NVAR(code);
				PHALCON_CONCAT_SVS(code, "strtolower(", left, ")");
			}
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "uppercase")) {
			if (phalcon_function_exists_ex(SS("mb_strtoupper") TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_NVAR(code);
				PHALCON_CONCAT_SVS(code, "mb_strtoupper(", left, ")");
			} else {
				PHALCON_INIT_NVAR(code);
				PHALCON_CONCAT_SVS(code, "strtoupper(", left, ")");
			}
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_COMPARE_STRING(name, "sort")) {
			PHALCON_INIT_NVAR(code);
			PHALCON_CONCAT_SVS(code, "asort(", left, ")");
	
			ZVAL_BOOL(exists, 1);
		}
	
		if (PHALCON_IS_TRUE(exists)) {
	
			RETURN_CCTOR(code);
		}
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "Unknown filter ", name);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_NVAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown filter type ", type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _expression){

	zval *expr, *extends_mode, *prepend_dollar = NULL, *expr_code = NULL;
	zval *items, *exprs = NULL, *single_expr = NULL, *single_expr_expr = NULL;
	zval *single_expr_code = NULL, *name = NULL, *parameter = NULL, *joined_items;
	zval *type, *left, *left_code, *right_code = NULL, *right;
	zval *applied_filter, *qualified, *qualified_code;
	zval *qualified_arrow, *value, *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &expr, &extends_mode, &prepend_dollar) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!prepend_dollar) {
		PHALCON_INIT_NVAR(prepend_dollar);
		ZVAL_BOOL(prepend_dollar, 1);
	} else {
		PHALCON_SEPARATE_PARAM(prepend_dollar);
	}
	
	PHALCON_INIT_VAR(expr_code);
	eval_int = phalcon_array_isset_string(expr, SS("type"));
	if (!eval_int) {
		ZVAL_STRING(expr_code, "", 1);
	
		PHALCON_INIT_VAR(items);
		array_init(items);
		eval_int = phalcon_array_isset_long(expr, 0);
		if (!eval_int) {
			PHALCON_INIT_VAR(exprs);
			array_init(exprs);
			phalcon_array_append(&exprs, expr, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(exprs, expr);
		}
	
	
		if (!phalcon_valid_foreach(exprs TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(exprs);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(single_expr);
	
			PHALCON_INIT_NVAR(single_expr_expr);
			phalcon_array_fetch_string(&single_expr_expr, single_expr, SL("expr"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(single_expr_code);
			PHALCON_CALL_METHOD_PARAMS_2(single_expr_code, this_ptr, "_expression", single_expr_expr, extends_mode, PH_NO_CHECK);
			eval_int = phalcon_array_isset_string(single_expr, SS("name"));
			if (eval_int) {
				PHALCON_INIT_NVAR(name);
				phalcon_array_fetch_string(&name, single_expr, SL("name"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(parameter);
				PHALCON_CONCAT_SVSV(parameter, "'", name, "' => ", single_expr_code);
				phalcon_array_append(&items, parameter, PH_SEPARATE TSRMLS_CC);
			} else {
				phalcon_array_append(&items, single_expr_code, PH_SEPARATE TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		PHALCON_INIT_VAR(joined_items);
		phalcon_fast_join_str(joined_items, SL(", "), items TSRMLS_CC);
		phalcon_concat_self(expr_code, joined_items TSRMLS_CC);
	
		RETURN_CCTOR(expr_code);
	}
	
	PHALCON_INIT_VAR(type);
	phalcon_array_fetch_string(&type, expr, SL("type"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(expr, SS("left"));
	if (eval_int) {
		PHALCON_INIT_VAR(left);
		phalcon_array_fetch_string(&left, expr, SL("left"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(left_code);
		PHALCON_CALL_METHOD_PARAMS_2(left_code, this_ptr, "_expression", left, extends_mode, PH_NO_CHECK);
	}
	
	if (phalcon_compare_strict_long(type, 124 TSRMLS_CC)) {
		PHALCON_INIT_VAR(right_code);
		phalcon_array_fetch_string(&right_code, expr, SL("right"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(expr, SS("right"));
		if (eval_int) {
			PHALCON_INIT_VAR(right);
			phalcon_array_fetch_string(&right, expr, SL("right"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(right_code);
			PHALCON_CALL_METHOD_PARAMS_2(right_code, this_ptr, "_expression", right, extends_mode, PH_NO_CHECK);
		}
	}
	
	PHALCON_INIT_NVAR(expr_code);
	
	if (phalcon_compare_strict_long(type, 33 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SV(expr_code, "!", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 42 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " * ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 43 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " + ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 45 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " - ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 47 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " / ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 37 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " % ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 60 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " < ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 61 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " > ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 62 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " > ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 126 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " . ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 124 TSRMLS_CC)) {
		PHALCON_INIT_VAR(applied_filter);
		PHALCON_CALL_METHOD_PARAMS_2(applied_filter, this_ptr, "_filter", right_code, left_code, PH_NO_CHECK);
		PHALCON_CPY_WRT(expr_code, applied_filter);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 355 TSRMLS_CC)) {
		if (PHALCON_IS_TRUE(prepend_dollar)) {
			PHALCON_INIT_NVAR(expr_code);
			ZVAL_STRING(expr_code, "$", 1);
	
			PHALCON_INIT_NVAR(prepend_dollar);
			ZVAL_BOOL(prepend_dollar, 0);
		}
		eval_int = phalcon_array_isset_string(expr, SS("qualified"));
		if (eval_int) {
			PHALCON_INIT_VAR(qualified);
			phalcon_array_fetch_string(&qualified, expr, SL("qualified"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(qualified_code);
			PHALCON_CALL_METHOD_PARAMS_3(qualified_code, this_ptr, "_expression", qualified, extends_mode, prepend_dollar, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(qualified_arrow);
			PHALCON_CONCAT_VS(qualified_arrow, qualified_code, "->");
			phalcon_concat_self(expr_code, qualified_arrow TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(name);
		phalcon_array_fetch_string(&name, expr, SL("name"), PH_NOISY_CC);
		phalcon_concat_self(expr_code, name TSRMLS_CC);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 360 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVS(expr_code, "array(", left_code, ")");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 258 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		phalcon_array_fetch_string(&expr_code, expr, SL("value"), PH_NOISY_CC);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 259 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		phalcon_array_fetch_string(&expr_code, expr, SL("value"), PH_NOISY_CC);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 260 TSRMLS_CC)) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch_string(&value, expr, SL("value"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVS(expr_code, "'", value, "'");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 261 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		ZVAL_STRING(expr_code, "null", 1);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 262 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		ZVAL_STRING(expr_code, "false", 1);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 263 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		ZVAL_STRING(expr_code, "true", 1);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 266 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " && ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 270 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " <= ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 271 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " >= ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 272 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " == ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 273 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " != ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 274 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " === ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 275 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSV(expr_code, left_code, " !== ", right_code);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 276 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVSVS(expr_code, "range(", left_code, ", ", right_code, ")");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 350 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CALL_METHOD_PARAMS_2(expr_code, this_ptr, "_functioncall", expr, extends_mode, PH_NO_CHECK);
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 356 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVS(expr_code, "(", left_code, ")");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 361 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_VSVS(expr_code, left_code, "[", right_code, "]");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 362 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVS(expr_code, "!isset(", left_code, ")");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 363 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SVS(expr_code, "isset(", left_code, ")");
		goto ph_end_1;
	}
	
	if (phalcon_compare_strict_long(type, 367 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(expr_code);
		PHALCON_CONCAT_SV(expr_code, "-", right_code);
		goto ph_end_1;
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown expression ", type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
	return;
	
	ph_end_1:
	
	RETURN_CCTOR(expr_code);
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList){

	zval *statements, *extends_mode, *exec_statements = NULL;
	zval *compilation, *statement = NULL, *expr = NULL, *expr_code = NULL;
	zval *type = NULL, *code = NULL, *block_statements = NULL, *qualified = NULL;
	zval *qualified_code = NULL, *block_name = NULL, *blocks = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &statements, &extends_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!phalcon_fast_count_ev(statements TSRMLS_CC)) {
		PHALCON_MM_RESTORE();
		RETURN_STRING("", 1);
	}
	eval_int = phalcon_array_isset_long(statements, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(exec_statements);
		array_init(exec_statements);
		phalcon_array_append(&exec_statements, statements, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(exec_statements, statements);
	}
	
	PHALCON_INIT_VAR(compilation);
	ZVAL_STRING(compilation, "", 1);
	
	if (!phalcon_valid_foreach(exec_statements TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(exec_statements);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(statement);
	
		eval_int = phalcon_array_isset_string(statement, SS("expr"));
		if (eval_int) {
			PHALCON_INIT_NVAR(expr);
			phalcon_array_fetch_string(&expr, statement, SL("expr"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(expr_code);
			PHALCON_CALL_METHOD_PARAMS_2(expr_code, this_ptr, "_expression", expr, extends_mode, PH_NO_CHECK);
		}
		eval_int = phalcon_array_isset_string(statement, SS("type"));
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Invalid statement");
			return;
		}
	
		PHALCON_INIT_NVAR(type);
		phalcon_array_fetch_string(&type, statement, SL("type"), PH_NOISY_CC);
	
		if (phalcon_compare_strict_long(type, 357 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(code);
			phalcon_array_fetch_string(&code, statement, SL("value"), PH_NOISY_CC);
			phalcon_concat_self(compilation, code TSRMLS_CC);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 300 TSRMLS_CC)) {
			PHALCON_SCONCAT_SVS(compilation, "<?php if (", expr_code, ") { ?>");
			PHALCON_INIT_NVAR(block_statements);
			phalcon_array_fetch_string(&block_statements, statement, SL("true_statements"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(code);
			PHALCON_CALL_METHOD_PARAMS_2(code, this_ptr, "_statementlist", block_statements, extends_mode, PH_NO_CHECK);
			phalcon_concat_self(compilation, code TSRMLS_CC);
			eval_int = phalcon_array_isset_string(statement, SS("false_statements"));
			if (eval_int) {
				phalcon_concat_self_str(compilation, SL("<?php } else { ?>") TSRMLS_CC);
	
				PHALCON_INIT_NVAR(block_statements);
				phalcon_array_fetch_string(&block_statements, statement, SL("false_statements"), PH_NOISY_CC);
	
				PHALCON_INIT_NVAR(code);
				PHALCON_CALL_METHOD_PARAMS_2(code, this_ptr, "_statementlist", block_statements, extends_mode, PH_NO_CHECK);
				phalcon_concat_self(compilation, code TSRMLS_CC);
			}
	
			phalcon_concat_self_str(compilation, SL("<?php } ?>") TSRMLS_CC);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 304 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(qualified);
			phalcon_array_fetch_string(&qualified, statement, SL("qualified"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(qualified_code);
			PHALCON_CALL_METHOD_PARAMS_2(qualified_code, this_ptr, "_expression", qualified, extends_mode, PH_NO_CHECK);
			PHALCON_SCONCAT_SVSVS(compilation, "<?php foreach (", expr_code, " as ", qualified_code, ") { ?>");
	
			PHALCON_INIT_NVAR(block_statements);
			phalcon_array_fetch_string(&block_statements, statement, SL("block_statements"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(code);
			PHALCON_CALL_METHOD_PARAMS_2(code, this_ptr, "_statementlist", block_statements, extends_mode, PH_NO_CHECK);
			phalcon_concat_self(compilation, code TSRMLS_CC);
			phalcon_concat_self_str(compilation, SL("<?php } ?>") TSRMLS_CC);
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 306 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(qualified);
			phalcon_array_fetch_string(&qualified, statement, SL("qualified"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(qualified_code);
			PHALCON_CALL_METHOD_PARAMS_2(qualified_code, this_ptr, "_expression", qualified, extends_mode, PH_NO_CHECK);
			PHALCON_SCONCAT_SVSVS(compilation, "<?php ", qualified_code, " = ", expr_code, "; ?>");
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 359 TSRMLS_CC)) {
			PHALCON_SCONCAT_SVS(compilation, "<?php echo ", expr_code, "; ?>");
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 307 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(block_name);
			phalcon_array_fetch_string(&block_name, statement, SL("name"), PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(statement, SS("block_statements"));
			if (eval_int) {
				PHALCON_INIT_NVAR(block_statements);
				phalcon_array_fetch_string(&block_statements, statement, SL("block_statements"), PH_NOISY_CC);
			} else {
				PHALCON_INIT_NVAR(block_statements);
			}
	
			PHALCON_INIT_NVAR(blocks);
			phalcon_read_property(&blocks, this_ptr, SL("_blocks"), PH_NOISY_CC);
			if (Z_TYPE_P(blocks) != IS_ARRAY) { 
				PHALCON_INIT_NVAR(blocks);
				array_init(blocks);
			}
	
			if (PHALCON_IS_FALSE(extends_mode)) {
				if (Z_TYPE_P(block_statements) == IS_ARRAY) { 
					PHALCON_INIT_NVAR(code);
					PHALCON_CALL_METHOD_PARAMS_2(code, this_ptr, "_statementlist", block_statements, extends_mode, PH_NO_CHECK);
					phalcon_array_update_zval(&blocks, block_name, &code, PH_COPY | PH_SEPARATE TSRMLS_CC);
				} else {
					phalcon_array_update_zval(&blocks, block_name, &block_statements, PH_COPY | PH_SEPARATE TSRMLS_CC);
				}
				phalcon_update_property_zval(this_ptr, SL("_blocks"), blocks TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(blocks);
				phalcon_read_property(&blocks, this_ptr, SL("_blocks"), PH_NOISY_CC);
				eval_int = phalcon_array_isset(blocks, block_name);
				if (eval_int) {
					PHALCON_INIT_NVAR(code);
					phalcon_array_fetch(&code, blocks, block_name, PH_NOISY_CC);
					phalcon_concat_self(compilation, code TSRMLS_CC);
				} else {
					if (Z_TYPE_P(block_statements) == IS_ARRAY) { 
						PHALCON_INIT_NVAR(code);
						PHALCON_CALL_METHOD_PARAMS_2(code, this_ptr, "_statementlist", block_statements, extends_mode, PH_NO_CHECK);
						phalcon_concat_self(compilation, code TSRMLS_CC);
					}
				}
			}
	
			goto ph_end_1;
		}
	
		if (phalcon_compare_strict_long(type, 310 TSRMLS_CC)) {
			phalcon_update_property_zval(this_ptr, SL("_extendsNode"), statement TSRMLS_CC);
			phalcon_update_property_bool(this_ptr, SL("_extendsMode"), 1 TSRMLS_CC);
			goto ph_end_1;
		}
	
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "Unknown statement ", type);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	
		ph_end_1:
		if(0){}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(compilation);
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource){

	zval *view_code, *extends_mode = NULL, *intermediate;
	zval *compilation = NULL, *views_dir = NULL, *dependency_injector;
	zval *service, *view, *path, *view_path, *exception_message;
	zval *extended, *extends_view_code;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &view_code, &extends_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!extends_mode) {
		PHALCON_INIT_NVAR(extends_mode);
		ZVAL_BOOL(extends_mode, 0);
	} else {
		PHALCON_SEPARATE_PARAM(extends_mode);
	}
	
	PHALCON_INIT_VAR(intermediate);
	if (phvolt_parse_view(intermediate, view_code TSRMLS_CC) == FAILURE) {
		return;
	}
	if (Z_TYPE_P(intermediate) == IS_ARRAY) { 
		phalcon_update_property_null(this_ptr, SL("_extendsNode") TSRMLS_CC);
	
		PHALCON_INIT_VAR(compilation);
		PHALCON_CALL_METHOD_PARAMS_2(compilation, this_ptr, "_statementlist", intermediate, extends_mode, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(extends_mode)) {
			PHALCON_INIT_NVAR(extends_mode);
			phalcon_read_property(&extends_mode, this_ptr, SL("_extendsNode"), PH_NOISY_CC);
			if (Z_TYPE_P(extends_mode) != IS_NULL) {
				PHALCON_INIT_VAR(views_dir);
	
				PHALCON_INIT_VAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
					PHALCON_INIT_VAR(service);
					ZVAL_STRING(service, "view", 1);
	
					PHALCON_INIT_VAR(view);
					PHALCON_CALL_METHOD_PARAMS_1(view, dependency_injector, "get", service, PH_NO_CHECK);
	
					PHALCON_CALL_METHOD(views_dir, view, "getviewsdir", PH_NO_CHECK);
				}
	
				PHALCON_INIT_VAR(path);
				phalcon_array_fetch_string(&path, extends_mode, SL("path"), PH_NOISY_CC);
	
				PHALCON_INIT_VAR(view_path);
				PHALCON_CONCAT_VV(view_path, views_dir, path);
				if (phalcon_file_exists(view_path TSRMLS_CC) == FAILURE) {
					PHALCON_INIT_VAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Template view to extend '", view_path, "' doesn't exists");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
					return;
				}
	
				PHALCON_INIT_VAR(extended);
				ZVAL_BOOL(extended, 1);
	
				PHALCON_INIT_VAR(extends_view_code);
				PHALCON_CALL_FUNC_PARAMS_1(extends_view_code, "file_get_contents", view_path);
	
				PHALCON_INIT_NVAR(compilation);
				PHALCON_CALL_METHOD_PARAMS_2(compilation, this_ptr, "_compilesource", extends_view_code, extended, PH_NO_CHECK);
			}
		}
	
	
		RETURN_CCTOR(compilation);
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Invalid intermediate representation");
	return;
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString){

	zval *view_code, *extends_mode = NULL, *compilation;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &view_code, &extends_mode) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!extends_mode) {
		PHALCON_INIT_NVAR(extends_mode);
		ZVAL_BOOL(extends_mode, 0);
	}
	
	if (Z_TYPE_P(view_code) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The code must be string");
		return;
	}
	
	PHALCON_INIT_VAR(compilation);
	PHALCON_CALL_METHOD_PARAMS_1(compilation, this_ptr, "_compilesource", view_code, PH_NO_CHECK);
	
	RETURN_CCTOR(compilation);
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compile){

	zval *path, *compiled_path, *same, *view_code, *compilation;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &path, &compiled_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(same);
	is_equal_function(same, path, compiled_path TSRMLS_CC);
	if (PHALCON_IS_TRUE(same)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Template path and compilation path cannot be the same");
		return;
	}
	
	PHALCON_INIT_VAR(view_code);
	PHALCON_CALL_FUNC_PARAMS_1(view_code, "file_get_contents", path);
	
	PHALCON_INIT_VAR(compilation);
	PHALCON_CALL_METHOD_PARAMS_1(compilation, this_ptr, "_compilesource", view_code, PH_NO_CHECK);
	PHALCON_CALL_FUNC_PARAMS_2_NORETURN("file_put_contents", compiled_path, compilation);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, parse){

	zval *view_code, *intermediate;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &view_code) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(intermediate);
	if (phvolt_parse_view(intermediate, view_code TSRMLS_CC) == FAILURE) {
		return;
	}
	
	RETURN_CCTOR(intermediate);
}



/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is include which follows the "include" declaration
** in the input file. */
// 37 "parser.lemon"


#ifdef HAVE_CONFIG_H
#endif




static zval *phvolt_ret_literal_zval(int type, phvolt_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (T) {
		add_assoc_stringl(ret, "value", T->token, T->token_len, 1);
		efree(T->token);
		efree(T);
	}

	return ret;
}

static zval *phvolt_ret_if_statement(zval *expr, zval *true_statements, zval *false_statements)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_IF);
	add_assoc_zval(ret, "expr", expr);
	add_assoc_zval(ret, "true_statements", true_statements);
	if (false_statements) {
		add_assoc_zval(ret, "false_statements", false_statements);
	}

	return ret;
}

static zval *phvolt_ret_for_statement(zval *qualified_name, zval *expr, zval *block_statements)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_FOR);
	add_assoc_zval(ret, "qualified", qualified_name);
	add_assoc_zval(ret, "expr", expr);
	add_assoc_zval(ret, "block_statements", block_statements);

	return ret;
}

static zval *phvolt_ret_set_statement(zval *qualified_name, zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_SET);
	add_assoc_zval(ret, "qualified", qualified_name);
	add_assoc_zval(ret, "expr", expr);

	return ret;
}

static zval *phvolt_ret_echo_statement(zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_ECHO);
	add_assoc_zval(ret, "expr", expr);

	return ret;
}

static zval *phvolt_ret_block_statement(phvolt_parser_token *name, zval *block_statements)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHVOLT_T_BLOCK);

	add_assoc_stringl(ret, "name", name->token, name->token_len, 1);
	efree(name->token);
	efree(name);

	if (block_statements) {
		add_assoc_zval(ret, "block_statements", block_statements);
	}

	return ret;
}

static zval *phvolt_ret_extends_statement(phvolt_parser_token *P)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHVOLT_T_EXTENDS);

	add_assoc_stringl(ret, "path", P->token, P->token_len, 1);
	efree(P->token);
	efree(P);

	return ret;
}

static zval *phvolt_ret_include_statement(phvolt_parser_token *P)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHVOLT_T_INCLUDE);

	add_assoc_stringl(ret, "path", P->token, P->token_len, 1);
	efree(P->token);
	efree(P);

	return ret;
}

static zval *phvolt_ret_empty_statement()
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_EMPTY);

	return ret;
}

static zval *phvolt_ret_qualified_name(zval *A, phvolt_parser_token *B)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_QUALIFIED);
	if (A != NULL) {
		add_assoc_zval(ret, "qualified", A);
	}

	add_assoc_stringl(ret, "name", B->token, B->token_len, 1);
	efree(B->token);
	efree(B);

	return ret;
}

static zval *phvolt_ret_zval_list(zval *list_left, zval *right_list)
{

	zval *ret;
	HashPosition pos;
	HashTable *list;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	list = Z_ARRVAL_P(list_left);
	if (zend_hash_index_exists(list, 0)) {
		zend_hash_internal_pointer_reset_ex(list, &pos);
		for (;; zend_hash_move_forward_ex(list, &pos)) {

			zval ** item;

			if (zend_hash_get_current_data_ex(list, (void**)&item, &pos) == FAILURE) {
				break;
			}

			Z_ADDREF_PP(item);
			add_next_index_zval(ret, *item);

		}
		zval_ptr_dtor(&list_left);
	} else {
		add_next_index_zval(ret, list_left);
	}

	add_next_index_zval(ret, right_list);

	return ret;
}

static zval *phvolt_ret_named_item(phvolt_parser_token *name, zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "expr", expr);
	if (name != NULL) {
		add_assoc_stringl(ret, "name", name->token, name->token_len, 1);
		efree(name->token);
		efree(name);
	}

	return ret;
}

static zval *phvolt_ret_expr(int type, zval *left, zval *right)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (left) {
		add_assoc_zval(ret, "left", left);
	}
	if (right) {
		add_assoc_zval(ret, "right", right);
	}

	return ret;
}

static zval *phvolt_ret_func_call(phvolt_parser_token *name, zval *arguments)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_FCALL);
	add_assoc_stringl(ret, "name", name->token, name->token_len, 1);
	efree(name->token);
	efree(name);

	if (arguments) {
		add_assoc_zval(ret, "arguments", arguments);
	}

	return ret;
}


// 268 "parser.c"
/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    KKCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    KKNOCODE           is a number of type KKCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash 
**                       table.
**    KKFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    KKACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    phvolt_KTOKENTYPE     is the data type used for minor tokens given 
**                       directly to the parser from the tokenizer.
**    KKMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is phvolt_KTOKENTYPE.  The entry in the union
**                       for base tokens is called "kk0".
**    KKSTACKDEPTH       is the maximum depth of the parser's stack.
**    phvolt_ARG_SDECL     A static variable declaration for the %extra_argument
**    phvolt_ARG_PDECL     A parameter declaration for the %extra_argument
**    phvolt_ARG_STORE     Code to store %extra_argument into kkpParser
**    phvolt_ARG_FETCH     Code to extract %extra_argument from kkpParser
**    KKNSTATE           the combined number of states.
**    KKNRULE            the number of rules in the grammar
**    KKERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define KKCODETYPE unsigned char
#define KKNOCODE 75
#define KKACTIONTYPE unsigned char
#define phvolt_KTOKENTYPE phvolt_parser_token*
typedef union {
  phvolt_KTOKENTYPE kk0;
  zval* kk96;
  int kk149;
} KKMINORTYPE;
#define KKSTACKDEPTH 100
#define phvolt_ARG_SDECL phvolt_parser_status *status;
#define phvolt_ARG_PDECL ,phvolt_parser_status *status
#define phvolt_ARG_FETCH phvolt_parser_status *status = kkpParser->status
#define phvolt_ARG_STORE kkpParser->status = status
#define KKNSTATE 147
#define KKNRULE 70
#define KKERRORSYMBOL 53
#define KKERRSYMDT kk149
#define KK_NO_ACTION      (KKNSTATE+KKNRULE+2)
#define KK_ACCEPT_ACTION  (KKNSTATE+KKNRULE+1)
#define KK_ERROR_ACTION   (KKNSTATE+KKNRULE)

/* Next are that tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < KKNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   KKNSTATE <= N < KKNSTATE+KKNRULE   Reduce by rule N-KKNSTATE.
**
**   N == KKNSTATE+KKNRULE              A syntax error has occurred.
**
**   N == KKNSTATE+KKNRULE+1            The parser accepts its input.
**
**   N == KKNSTATE+KKNRULE+2            No such action.  Denotes unused
**                                      slots in the kk_action[] table.
**
** The action table is constructed as a single large table named kk_action[].
** Given state S and lookahead X, the action is computed as
**
**      kk_action[ kk_shift_ofst[S] + X ]
**
** If the index value kk_shift_ofst[S]+X is out of range or if the value
** kk_lookahead[kk_shift_ofst[S]+X] is not equal to X or if kk_shift_ofst[S]
** is equal to KK_SHIFT_USE_DFLT, it means that the action is not in the table
** and that kk_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the kk_reduce_ofst[] array is used in place of
** the kk_shift_ofst[] array and KK_REDUCE_USE_DFLT is used in place of
** KK_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  kk_action[]        A single table containing all actions.
**  kk_lookahead[]     A table containing the lookahead for each entry in
**                     kk_action.  Used to detect hash collisions.
**  kk_shift_ofst[]    For each state, the offset into kk_action for
**                     shifting terminals.
**  kk_reduce_ofst[]   For each state, the offset into kk_action for
**                     shifting non-terminals after a reduce.
**  kk_default[]       Default action for each state.
*/
static KKACTIONTYPE kk_action[] = {
 /*     0 */    80,   60,   64,   62,   66,   72,   74,   76,   78,   68,
 /*    10 */    70,   52,   54,   58,   48,   46,   50,   44,   41,   56,
 /*    20 */   134,   80,   60,   64,   62,   66,   72,   74,   76,   78,
 /*    30 */    68,   70,   52,   54,   58,   48,   46,   50,   44,   41,
 /*    40 */    56,   26,   51,  108,   82,   40,   97,   80,   60,   64,
 /*    50 */    62,   66,   72,   74,   76,   78,   68,   70,   52,   54,
 /*    60 */    58,   48,   46,   50,   44,   41,   56,   80,   60,   64,
 /*    70 */    62,   66,   72,   74,   76,   78,   68,   70,   52,   54,
 /*    80 */    58,   48,   46,   50,   44,   41,   56,   44,   41,   56,
 /*    90 */    87,   52,   54,   58,   48,   46,   50,   44,   41,   56,
 /*   100 */   141,   22,   37,   80,   60,   64,   62,   66,   72,   74,
 /*   110 */    76,   78,   68,   70,   52,   54,   58,   48,   46,   50,
 /*   120 */    44,   41,   56,   28,  127,   89,  108,   16,   93,   97,
 /*   130 */    80,   60,   64,   62,   66,   72,   74,   76,   78,   68,
 /*   140 */    70,   52,   54,   58,   48,   46,   50,   44,   41,   56,
 /*   150 */   106,   15,  108,  128,   31,   97,  137,   80,   60,   64,
 /*   160 */    62,   66,   72,   74,   76,   78,   68,   70,   52,   54,
 /*   170 */    58,   48,   46,   50,   44,   41,   56,   64,   62,   66,
 /*   180 */    72,   74,   76,   78,   68,   70,   52,   54,   58,   48,
 /*   190 */    46,   50,   44,   41,   56,  218,    1,    2,  143,    4,
 /*   200 */     5,    6,    7,    8,    9,   10,   11,   12,   88,   89,
 /*   210 */   108,   90,  119,   97,   32,  143,    4,    5,    6,    7,
 /*   220 */     8,    9,   10,   11,   12,  110,   42,  109,   83,   88,
 /*   230 */    23,  143,    4,    5,    6,    7,    8,    9,   10,   11,
 /*   240 */    12,  135,  109,   98,   69,  108,  105,   42,   97,  120,
 /*   250 */    85,  117,   38,  124,  111,  113,  114,  115,  116,  100,
 /*   260 */   108,  103,   92,   97,   98,  104,  138,  112,   53,  108,
 /*   270 */   122,   85,   97,   88,  132,  111,  113,  114,  115,  116,
 /*   280 */   129,  143,    4,    5,    6,    7,    8,    9,   10,   11,
 /*   290 */    12,   42,   95,   83,   17,  143,    4,    5,    6,    7,
 /*   300 */     8,    9,   10,   11,   12,  102,   24,   91,   98,   99,
 /*   310 */    35,  112,  147,  146,  121,   85,  139,   88,   20,  111,
 /*   320 */   113,  114,  115,  116,  142,    3,    4,    5,    6,    7,
 /*   330 */     8,    9,   10,   11,   12,   42,  146,   83,   88,   58,
 /*   340 */    48,   46,   50,   44,   41,   56,   14,  125,   19,   21,
 /*   350 */    27,  146,   98,   36,  146,   94,   42,  126,   83,   85,
 /*   360 */   133,   88,  136,  111,  113,  114,  115,  116,   55,  108,
 /*   370 */   107,  108,   97,   98,   97,  146,  112,  146,  146,   42,
 /*   380 */    85,   83,  146,  146,  111,  113,  114,  115,  116,  146,
 /*   390 */    14,  125,   25,  109,   27,  146,   98,   36,  148,  105,
 /*   400 */    29,  126,  146,   85,  133,  146,  136,  111,  113,  114,
 /*   410 */   115,  116,   14,  125,   30,  108,   27,  146,   97,   36,
 /*   420 */    14,  125,   13,  126,   27,  131,  133,   36,  136,   33,
 /*   430 */   146,  126,  139,  145,  133,  146,  136,   14,  125,  139,
 /*   440 */   142,   27,  146,   34,   36,   14,  125,  142,  126,   27,
 /*   450 */    13,  133,   36,  136,  146,  146,  126,  146,  146,  133,
 /*   460 */   139,  136,   48,   46,   50,   44,   41,   56,  142,  100,
 /*   470 */   108,   18,  146,   97,  101,  118,   79,  108,   84,  108,
 /*   480 */    97,  139,   97,   59,  108,  146,  146,   97,  146,  142,
 /*   490 */    73,  108,   71,  108,   97,  146,   97,   61,  108,   77,
 /*   500 */   108,   97,  146,   97,   57,  108,   47,  108,   97,  146,
 /*   510 */    97,   49,  108,  146,  144,   97,  140,  108,   63,  108,
 /*   520 */    97,  146,   97,  130,  139,  146,  146,   75,  108,  146,
 /*   530 */   146,   97,  142,  139,   45,  108,   65,  108,   97,  146,
 /*   540 */    97,  142,   86,  108,   43,  108,   97,  146,   97,   39,
 /*   550 */   108,   67,  108,   97,  146,   97,  146,  146,   96,  108,
 /*   560 */    81,  108,   97,  146,   97,  123,  108,  146,  146,   97,
};
static KKCODETYPE kk_lookahead[] = {
 /*     0 */     2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
 /*    10 */    12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*    20 */    40,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*    30 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*    40 */    21,   26,   67,   68,   46,   26,   71,    2,    3,    4,
 /*    50 */     5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
 /*    60 */    15,   16,   17,   18,   19,   20,   21,    2,    3,    4,
 /*    70 */     5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
 /*    80 */    15,   16,   17,   18,   19,   20,   21,   19,   20,   21,
 /*    90 */    45,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*   100 */    35,   26,   68,    2,    3,    4,    5,    6,    7,    8,
 /*   110 */     9,   10,   11,   12,   13,   14,   15,   16,   17,   18,
 /*   120 */    19,   20,   21,   68,   37,   67,   68,   26,   70,   71,
 /*   130 */     2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
 /*   140 */    12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*   150 */    47,   67,   68,   26,   26,   71,   40,    2,    3,    4,
 /*   160 */     5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
 /*   170 */    15,   16,   17,   18,   19,   20,   21,    4,    5,    6,
 /*   180 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*   190 */    17,   18,   19,   20,   21,   54,   55,   56,   57,   58,
 /*   200 */    59,   60,   61,   62,   63,   64,   65,   66,    2,   67,
 /*   210 */    68,   69,   70,   71,   56,   57,   58,   59,   60,   61,
 /*   220 */    62,   63,   64,   65,   66,   37,   20,   23,   22,    2,
 /*   230 */    56,   57,   58,   59,   60,   61,   62,   63,   64,   65,
 /*   240 */    66,   26,   23,   37,   67,   68,   40,   20,   71,   22,
 /*   250 */    44,   45,   33,   37,   48,   49,   50,   51,   52,   67,
 /*   260 */    68,    1,    1,   71,   37,   73,   26,   40,   67,   68,
 /*   270 */    43,   44,   71,    2,   26,   48,   49,   50,   51,   52,
 /*   280 */    56,   57,   58,   59,   60,   61,   62,   63,   64,   65,
 /*   290 */    66,   20,   47,   22,   56,   57,   58,   59,   60,   61,
 /*   300 */    62,   63,   64,   65,   66,   45,   24,   46,   37,   44,
 /*   310 */    26,   40,    0,   26,   43,   44,   34,    2,   26,   48,
 /*   320 */    49,   50,   51,   52,   42,   57,   58,   59,   60,   61,
 /*   330 */    62,   63,   64,   65,   66,   20,   74,   22,    2,   15,
 /*   340 */    16,   17,   18,   19,   20,   21,   25,   26,   27,   28,
 /*   350 */    29,   74,   37,   32,   74,   40,   20,   36,   22,   44,
 /*   360 */    39,    2,   41,   48,   49,   50,   51,   52,   67,   68,
 /*   370 */    67,   68,   71,   37,   71,   74,   40,   74,   74,   20,
 /*   380 */    44,   22,   74,   74,   48,   49,   50,   51,   52,   74,
 /*   390 */    25,   26,   27,   23,   29,   74,   37,   32,    0,   40,
 /*   400 */    30,   36,   74,   44,   39,   74,   41,   48,   49,   50,
 /*   410 */    51,   52,   25,   26,   67,   68,   29,   74,   71,   32,
 /*   420 */    25,   26,   24,   36,   29,   38,   39,   32,   41,   24,
 /*   430 */    74,   36,   34,   38,   39,   74,   41,   25,   26,   34,
 /*   440 */    42,   29,   74,   31,   32,   25,   26,   42,   36,   29,
 /*   450 */    24,   39,   32,   41,   74,   74,   36,   74,   74,   39,
 /*   460 */    34,   41,   16,   17,   18,   19,   20,   21,   42,   67,
 /*   470 */    68,   24,   74,   71,   72,   73,   67,   68,   67,   68,
 /*   480 */    71,   34,   71,   67,   68,   74,   74,   71,   74,   42,
 /*   490 */    67,   68,   67,   68,   71,   74,   71,   67,   68,   67,
 /*   500 */    68,   71,   74,   71,   67,   68,   67,   68,   71,   74,
 /*   510 */    71,   67,   68,   74,   24,   71,   67,   68,   67,   68,
 /*   520 */    71,   74,   71,   24,   34,   74,   74,   67,   68,   74,
 /*   530 */    74,   71,   42,   34,   67,   68,   67,   68,   71,   74,
 /*   540 */    71,   42,   67,   68,   67,   68,   71,   74,   71,   67,
 /*   550 */    68,   67,   68,   71,   74,   71,   74,   74,   67,   68,
 /*   560 */    67,   68,   71,   74,   71,   67,   68,   74,   74,   71,
};
#define KK_SHIFT_USE_DFLT (-21)
static short kk_shift_ofst[] = {
 /*     0 */   426,  312,  398,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
 /*    10 */   -21,  -21,  -21,  420,  336,  101,  426,  447,  321,  292,
 /*    20 */   -21,   75,  426,  282,  365,   15,  -21,  216,  370,  336,
 /*    30 */   128,  426,  405,  412,  284,  -21,  216,  219,  336,   19,
 /*    40 */   -21,  336,  336,  -21,  336,  -21,  336,   68,  336,   68,
 /*    50 */   336,   68,  336,  324,  336,  324,  336,  -21,  336,  446,
 /*    60 */   336,  173,  336,   78,  227,   78,  336,   78,  336,   78,
 /*    70 */   336,   78,  336,   78,  336,   78,  336,   78,  336,   78,
 /*    80 */   336,   -2,  -21,  336,  -21,  336,   45,  -21,  315,  155,
 /*    90 */   261,  -21,  315,  -21,  245,  336,  155,  -21,  265,  206,
 /*   100 */   155,  260,  -21,  359,  -21,  103,  336,  155,  204,  188,
 /*   110 */   -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
 /*   120 */   271,  -21,  -21,  -21,  -21,  -21,   87,  127,  490,  499,
 /*   130 */   387,  248,  -21,  -20,  215,  -21,  116,  240,  -21,  336,
 /*   140 */    65,  -21,  -21,  -21,  395,  287,  -21,
};
#define KK_REDUCE_USE_DFLT (-26)
static short kk_reduce_ofst[] = {
 /*     0 */   141,  -26,  268,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
 /*    10 */   -26,  -26,  -26,  -26,   84,  -26,  238,  268,  -26,  -26,
 /*    20 */   -26,  -26,  174,  268,  -26,  -26,  -26,   55,  -26,  347,
 /*    30 */   -26,  158,  268,  -26,  -26,  -26,   34,  -26,  482,  -26,
 /*    40 */   -26,  498,  477,  -26,  467,  -26,  439,  -26,  444,  -26,
 /*    50 */   -25,  -26,  201,  -26,  301,  -26,  437,  -26,  416,  -26,
 /*    60 */   430,  -26,  451,  -26,  469,  -26,  484,  -26,  177,  -26,
 /*    70 */   425,  -26,  423,  -26,  460,  -26,  432,  -26,  409,  -26,
 /*    80 */   493,  -26,  -26,  411,  -26,  475,  -26,  -26,  142,  -26,
 /*    90 */   -26,  -26,   58,  -26,  -26,  491,  -26,  -26,  -26,  402,
 /*   100 */   -26,  -26,  -26,  192,  -26,  -26,  303,  -26,  -26,  -26,
 /*   110 */   -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
 /*   120 */   411,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  224,  268,
 /*   130 */   -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  449,
 /*   140 */   -26,  -26,  -26,  -26,  -26,  -26,  -26,
};
static KKACTIONTYPE kk_default[] = {
 /*     0 */   217,  217,  217,  149,  151,  152,  153,  154,  155,  156,
 /*    10 */   157,  158,  159,  217,  217,  217,  217,  217,  217,  217,
 /*    20 */   160,  217,  217,  217,  217,  217,  161,  217,  217,  217,
 /*    30 */   217,  217,  217,  217,  217,  162,  217,  217,  217,  217,
 /*    40 */   163,  217,  217,  171,  217,  173,  217,  174,  217,  175,
 /*    50 */   217,  176,  217,  177,  217,  178,  217,  179,  217,  180,
 /*    60 */   217,  181,  217,  182,  217,  185,  217,  186,  217,  187,
 /*    70 */   217,  188,  217,  189,  217,  190,  217,  191,  217,  192,
 /*    80 */   217,  217,  208,  217,  193,  217,  217,  194,  217,  199,
 /*    90 */   217,  195,  217,  196,  210,  217,  198,  200,  216,  217,
 /*   100 */   205,  217,  201,  217,  203,  210,  217,  206,  207,  217,
 /*   110 */   215,  209,  210,  211,  212,  213,  214,  202,  204,  197,
 /*   120 */   217,  183,  184,  172,  216,  164,  217,  217,  217,  217,
 /*   130 */   217,  217,  166,  217,  217,  168,  217,  217,  169,  217,
 /*   140 */   217,  165,  170,  150,  217,  217,  167,
};
#define KK_SZ_ACTTAB (sizeof(kk_action)/sizeof(kk_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammer, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef KKFALLBACK
static const KKCODETYPE kkFallback[] = {
};
#endif /* KKFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct kkStackEntry {
  int stateno;       /* The state-number */
  int major;         /* The major token value.  This is the code
                     ** number for the token at this stack level */
  KKMINORTYPE minor; /* The user-supplied minor token value.  This
                     ** is the value of the token  */
};
typedef struct kkStackEntry kkStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct kkParser {
  int kkidx;                    /* Index of top element in stack */
  int kkerrcnt;                 /* Shifts left before out of the error */
  phvolt_ARG_SDECL                /* A place to hold %extra_argument */
  kkStackEntry kkstack[KKSTACKDEPTH];  /* The parser's stack */
};
typedef struct kkParser kkParser;

#ifndef NDEBUG
static FILE *kkTraceFILE = 0;
static char *kkTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
void phvolt_Trace(FILE *TraceFILE, char *zTracePrompt){
  kkTraceFILE = TraceFILE;
  kkTracePrompt = zTracePrompt;
  if( kkTraceFILE==0 ) kkTracePrompt = 0;
  else if( kkTracePrompt==0 ) kkTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *kkTokenName[] = { 
  "$",             "COMMA",         "SBRACKET_OPEN",  "RANGE",       
  "IS",            "EQUALS",        "NOTEQUALS",     "LESS",        
  "GREATER",       "GREATEREQUAL",  "LESSEQUAL",     "IDENTICAL",   
  "NOTIDENTICAL",  "AND",           "OR",            "PIPE",        
  "DIVIDE",        "TIMES",         "MOD",           "PLUS",        
  "MINUS",         "CONCAT",        "NOT",           "DOT",         
  "OPEN_DELIMITER",  "IF",            "CLOSE_DELIMITER",  "ENDIF",       
  "ELSE",          "FOR",           "IN",            "ENDFOR",      
  "SET",           "ASSIGN",        "OPEN_EDELIMITER",  "CLOSE_EDELIMITER",
  "BLOCK",         "IDENTIFIER",    "ENDBLOCK",      "EXTENDS",     
  "STRING",        "INCLUDE",       "RAW_FRAGMENT",  "DEFINED",     
  "BRACKET_OPEN",  "BRACKET_CLOSE",  "SBRACKET_CLOSE",  "DOUBLECOLON", 
  "INTEGER",       "DOUBLE",        "NULL",          "FALSE",       
  "TRUE",          "error",         "program",       "volt_language",
  "statement_list",  "statement",     "raw_fragment",  "if_statement",
  "for_statement",  "set_statement",  "echo_statement",  "block_statement",
  "extends_statement",  "include_statement",  "empty_statement",  "expr",        
  "qualified_name",  "array_list",    "array_item",    "function_call",
  "argument_list",  "argument_item",
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *kkRuleName[] = {
 /*   0 */ "program ::= volt_language",
 /*   1 */ "volt_language ::= statement_list",
 /*   2 */ "statement_list ::= statement_list statement",
 /*   3 */ "statement_list ::= statement",
 /*   4 */ "statement ::= raw_fragment",
 /*   5 */ "statement ::= if_statement",
 /*   6 */ "statement ::= for_statement",
 /*   7 */ "statement ::= set_statement",
 /*   8 */ "statement ::= echo_statement",
 /*   9 */ "statement ::= block_statement",
 /*  10 */ "statement ::= extends_statement",
 /*  11 */ "statement ::= include_statement",
 /*  12 */ "statement ::= empty_statement",
 /*  13 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  14 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ELSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  15 */ "for_statement ::= OPEN_DELIMITER FOR qualified_name IN expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDFOR CLOSE_DELIMITER",
 /*  16 */ "set_statement ::= OPEN_DELIMITER SET qualified_name ASSIGN expr CLOSE_DELIMITER",
 /*  17 */ "empty_statement ::= OPEN_DELIMITER CLOSE_DELIMITER",
 /*  18 */ "echo_statement ::= OPEN_EDELIMITER expr CLOSE_EDELIMITER",
 /*  19 */ "block_statement ::= OPEN_DELIMITER BLOCK IDENTIFIER CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDBLOCK CLOSE_DELIMITER",
 /*  20 */ "block_statement ::= OPEN_DELIMITER BLOCK IDENTIFIER CLOSE_DELIMITER OPEN_DELIMITER ENDBLOCK CLOSE_DELIMITER",
 /*  21 */ "extends_statement ::= OPEN_DELIMITER EXTENDS STRING CLOSE_DELIMITER",
 /*  22 */ "include_statement ::= OPEN_DELIMITER INCLUDE STRING CLOSE_DELIMITER",
 /*  23 */ "raw_fragment ::= RAW_FRAGMENT",
 /*  24 */ "expr ::= MINUS expr",
 /*  25 */ "expr ::= expr MINUS expr",
 /*  26 */ "expr ::= expr PLUS expr",
 /*  27 */ "expr ::= expr TIMES expr",
 /*  28 */ "expr ::= expr DIVIDE expr",
 /*  29 */ "expr ::= expr MOD expr",
 /*  30 */ "expr ::= expr AND expr",
 /*  31 */ "expr ::= expr OR expr",
 /*  32 */ "expr ::= expr CONCAT expr",
 /*  33 */ "expr ::= expr PIPE expr",
 /*  34 */ "expr ::= expr RANGE expr",
 /*  35 */ "expr ::= expr EQUALS expr",
 /*  36 */ "expr ::= expr IS NOT DEFINED",
 /*  37 */ "expr ::= expr IS DEFINED",
 /*  38 */ "expr ::= expr IS expr",
 /*  39 */ "expr ::= expr NOTEQUALS expr",
 /*  40 */ "expr ::= expr IDENTICAL expr",
 /*  41 */ "expr ::= expr NOTIDENTICAL expr",
 /*  42 */ "expr ::= expr LESS expr",
 /*  43 */ "expr ::= expr GREATER expr",
 /*  44 */ "expr ::= expr GREATEREQUAL expr",
 /*  45 */ "expr ::= expr LESSEQUAL expr",
 /*  46 */ "expr ::= NOT expr",
 /*  47 */ "expr ::= BRACKET_OPEN expr BRACKET_CLOSE",
 /*  48 */ "expr ::= SBRACKET_OPEN array_list SBRACKET_CLOSE",
 /*  49 */ "array_list ::= array_list COMMA array_item",
 /*  50 */ "array_list ::= array_item",
 /*  51 */ "array_item ::= STRING DOUBLECOLON expr",
 /*  52 */ "array_item ::= expr",
 /*  53 */ "expr ::= function_call",
 /*  54 */ "function_call ::= IDENTIFIER BRACKET_OPEN argument_list BRACKET_CLOSE",
 /*  55 */ "function_call ::= IDENTIFIER BRACKET_OPEN BRACKET_CLOSE",
 /*  56 */ "argument_list ::= argument_list COMMA argument_item",
 /*  57 */ "argument_list ::= argument_item",
 /*  58 */ "argument_item ::= expr",
 /*  59 */ "argument_item ::= STRING DOUBLECOLON expr",
 /*  60 */ "expr ::= qualified_name",
 /*  61 */ "expr ::= expr SBRACKET_OPEN expr SBRACKET_CLOSE",
 /*  62 */ "expr ::= INTEGER",
 /*  63 */ "expr ::= STRING",
 /*  64 */ "expr ::= DOUBLE",
 /*  65 */ "expr ::= NULL",
 /*  66 */ "expr ::= FALSE",
 /*  67 */ "expr ::= TRUE",
 /*  68 */ "qualified_name ::= qualified_name DOT IDENTIFIER",
 /*  69 */ "qualified_name ::= IDENTIFIER",
};
#endif /* NDEBUG */

const char *phvolt_TokenName(int tokenType){
#ifndef NDEBUG
  if( tokenType>0 && tokenType<(sizeof(kkTokenName)/sizeof(kkTokenName[0])) ){
    return kkTokenName[tokenType];
  }else{
    return "Unknown";
  }
#else
  return "";
#endif
}

void *phvolt_Alloc(void *(*mallocProc)(size_t)){
  kkParser *pParser;
  pParser = (kkParser*)(*mallocProc)( (size_t)sizeof(kkParser) );
  if( pParser ){
    pParser->kkidx = -1;
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "kkmajor" is the symbol code, and "kkpminor" is a pointer to
** the value.
*/
static void kk_destructor(KKCODETYPE kkmajor, KKMINORTYPE *kkpminor){
  switch( kkmajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
// 342 "parser.lemon"
{
	if ((kkpminor->kk0)) {
		efree((kkpminor->kk0)->token);
		efree((kkpminor->kk0));
	}
}
// 853 "parser.c"
      break;
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 71:
    case 72:
    case 73:
// 357 "parser.lemon"
{ zval_ptr_dtor(&(kkpminor->kk96)); }
// 874 "parser.c"
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

static int kk_pop_parser_stack(kkParser *pParser){
  KKCODETYPE kkmajor;
  kkStackEntry *kktos = &pParser->kkstack[pParser->kkidx];

  if( pParser->kkidx<0 ) return 0;
#ifndef NDEBUG
  if( kkTraceFILE && pParser->kkidx>=0 ){
    fprintf(kkTraceFILE,"%sPopping %s\n",
      kkTracePrompt,
      kkTokenName[kktos->major]);
  }
#endif
  kkmajor = kktos->major;
  kk_destructor( kkmajor, &kktos->minor);
  pParser->kkidx--;
  return kkmajor;
}

void phvolt_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  kkParser *pParser = (kkParser*)p;
  if( pParser==0 ) return;
  while( pParser->kkidx>=0 ) kk_pop_parser_stack(pParser);
  (*freeProc)((void*)pParser);
}

static int kk_find_shift_action(
  kkParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->kkstack[pParser->kkidx].stateno;
 
  /* if( pParser->kkidx<0 ) return KK_NO_ACTION;  */
  i = kk_shift_ofst[stateno];
  if( i==KK_SHIFT_USE_DFLT ){
    return kk_default[stateno];
  }
  if( iLookAhead==KKNOCODE ){
    return KK_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=KK_SZ_ACTTAB || kk_lookahead[i]!=iLookAhead ){
#ifdef KKFALLBACK
    int iFallback;            /* Fallback token */
    if( iLookAhead<sizeof(kkFallback)/sizeof(kkFallback[0])
           && (iFallback = kkFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
      if( kkTraceFILE ){
        fprintf(kkTraceFILE, "%sFALLBACK %s => %s\n",
           kkTracePrompt, kkTokenName[iLookAhead], kkTokenName[iFallback]);
      }
#endif
      return kk_find_shift_action(pParser, iFallback);
    }
#endif
    return kk_default[stateno];
  }else{
    return kk_action[i];
  }
}

static int kk_find_reduce_action(
  kkParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->kkstack[pParser->kkidx].stateno;
 
  i = kk_reduce_ofst[stateno];
  if( i==KK_REDUCE_USE_DFLT ){
    return kk_default[stateno];
  }
  if( iLookAhead==KKNOCODE ){
    return KK_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=KK_SZ_ACTTAB || kk_lookahead[i]!=iLookAhead ){
    return kk_default[stateno];
  }else{
    return kk_action[i];
  }
}

static void kk_shift(
  kkParser *kkpParser,          /* The parser to be shifted */
  int kkNewState,               /* The new state to shift in */
  int kkMajor,                  /* The major token to shift in */
  KKMINORTYPE *kkpMinor         /* Pointer ot the minor token to shift in */
){
  kkStackEntry *kktos;
  kkpParser->kkidx++;
  if( kkpParser->kkidx>=KKSTACKDEPTH ){
     phvolt_ARG_FETCH;
     kkpParser->kkidx--;
#ifndef NDEBUG
     if( kkTraceFILE ){
       fprintf(kkTraceFILE,"%sStack Overflow!\n",kkTracePrompt);
     }
#endif
     while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
     /* Here code is inserted which will execute if the parser
     ** stack every overflows */
     phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument var */
     return;
  }
  kktos = &kkpParser->kkstack[kkpParser->kkidx];
  kktos->stateno = kkNewState;
  kktos->major = kkMajor;
  kktos->minor = *kkpMinor;
#ifndef NDEBUG
  if( kkTraceFILE && kkpParser->kkidx>0 ){
    int i;
    fprintf(kkTraceFILE,"%sShift %d\n",kkTracePrompt,kkNewState);
    fprintf(kkTraceFILE,"%sStack:",kkTracePrompt);
    for(i=1; i<=kkpParser->kkidx; i++)
      fprintf(kkTraceFILE," %s",kkTokenName[kkpParser->kkstack[i].major]);
    fprintf(kkTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static struct {
  KKCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} kkRuleInfo[] = {
  { 54, 1 },
  { 55, 1 },
  { 56, 2 },
  { 56, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 57, 1 },
  { 59, 8 },
  { 59, 12 },
  { 60, 10 },
  { 61, 6 },
  { 66, 2 },
  { 62, 3 },
  { 63, 8 },
  { 63, 7 },
  { 64, 4 },
  { 65, 4 },
  { 58, 1 },
  { 67, 2 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 4 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 3 },
  { 67, 2 },
  { 67, 3 },
  { 67, 3 },
  { 69, 3 },
  { 69, 1 },
  { 70, 3 },
  { 70, 1 },
  { 67, 1 },
  { 71, 4 },
  { 71, 3 },
  { 72, 3 },
  { 72, 1 },
  { 73, 1 },
  { 73, 3 },
  { 67, 1 },
  { 67, 4 },
  { 67, 1 },
  { 67, 1 },
  { 67, 1 },
  { 67, 1 },
  { 67, 1 },
  { 67, 1 },
  { 68, 3 },
  { 68, 1 },
};

static void kk_accept(kkParser*);  /* Forward Declaration */

static void kk_reduce(
  kkParser *kkpParser,         /* The parser */
  int kkruleno                 /* Number of the rule by which to reduce */
){
  int kkgoto;                     /* The next state */
  int kkact;                      /* The next action */
  KKMINORTYPE kkgotominor;        /* The LHS of the rule reduced */
  kkStackEntry *kkmsp;            /* The top of the parser's stack */
  int kksize;                     /* Amount to pop the stack */
  phvolt_ARG_FETCH;
  kkmsp = &kkpParser->kkstack[kkpParser->kkidx];
#ifndef NDEBUG
  if( kkTraceFILE && kkruleno>=0 
        && kkruleno<sizeof(kkRuleName)/sizeof(kkRuleName[0]) ){
    fprintf(kkTraceFILE, "%sReduce [%s].\n", kkTracePrompt,
      kkRuleName[kkruleno]);
  }
#endif /* NDEBUG */

  switch( kkruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  // <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  // <lineno> <thisfile>
  **     break;
  */
      case 0:
// 349 "parser.lemon"
{
	status->ret = kkmsp[0].minor.kk96;
}
// 1161 "parser.c"
        break;
      case 1:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 50:
      case 53:
      case 57:
      case 60:
// 353 "parser.lemon"
{
	kkgotominor.kk96 = kkmsp[0].minor.kk96;
}
// 1182 "parser.c"
        break;
      case 2:
// 359 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_zval_list(kkmsp[-1].minor.kk96, kkmsp[0].minor.kk96);
}
// 1189 "parser.c"
        break;
      case 13:
// 407 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_if_statement(kkmsp[-5].minor.kk96, kkmsp[-3].minor.kk96, NULL);
  kk_destructor(24,&kkmsp[-7].minor);
  kk_destructor(25,&kkmsp[-6].minor);
  kk_destructor(26,&kkmsp[-4].minor);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(27,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1202 "parser.c"
        break;
      case 14:
// 411 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_if_statement(kkmsp[-9].minor.kk96, kkmsp[-7].minor.kk96, kkmsp[-3].minor.kk96);
  kk_destructor(24,&kkmsp[-11].minor);
  kk_destructor(25,&kkmsp[-10].minor);
  kk_destructor(26,&kkmsp[-8].minor);
  kk_destructor(24,&kkmsp[-6].minor);
  kk_destructor(28,&kkmsp[-5].minor);
  kk_destructor(26,&kkmsp[-4].minor);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(27,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1218 "parser.c"
        break;
      case 15:
// 417 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_for_statement(kkmsp[-7].minor.kk96, kkmsp[-5].minor.kk96, kkmsp[-3].minor.kk96);
  kk_destructor(24,&kkmsp[-9].minor);
  kk_destructor(29,&kkmsp[-8].minor);
  kk_destructor(30,&kkmsp[-6].minor);
  kk_destructor(26,&kkmsp[-4].minor);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(31,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1232 "parser.c"
        break;
      case 16:
// 423 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_set_statement(kkmsp[-3].minor.kk96, kkmsp[-1].minor.kk96);
  kk_destructor(24,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(33,&kkmsp[-2].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1243 "parser.c"
        break;
      case 17:
// 429 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_empty_statement();
  kk_destructor(24,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1252 "parser.c"
        break;
      case 18:
// 435 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_echo_statement(kkmsp[-1].minor.kk96);
  kk_destructor(34,&kkmsp[-2].minor);
  kk_destructor(35,&kkmsp[0].minor);
}
// 1261 "parser.c"
        break;
      case 19:
// 441 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_block_statement(kkmsp[-5].minor.kk0, kkmsp[-3].minor.kk96);
  kk_destructor(24,&kkmsp[-7].minor);
  kk_destructor(36,&kkmsp[-6].minor);
  kk_destructor(26,&kkmsp[-4].minor);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(38,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1274 "parser.c"
        break;
      case 20:
// 445 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_block_statement(kkmsp[-4].minor.kk0, NULL);
  kk_destructor(24,&kkmsp[-6].minor);
  kk_destructor(36,&kkmsp[-5].minor);
  kk_destructor(26,&kkmsp[-3].minor);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(38,&kkmsp[-1].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1287 "parser.c"
        break;
      case 21:
// 451 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_extends_statement(kkmsp[-1].minor.kk0);
  kk_destructor(24,&kkmsp[-3].minor);
  kk_destructor(39,&kkmsp[-2].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1297 "parser.c"
        break;
      case 22:
// 457 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_include_statement(kkmsp[-1].minor.kk0);
  kk_destructor(24,&kkmsp[-3].minor);
  kk_destructor(41,&kkmsp[-2].minor);
  kk_destructor(26,&kkmsp[0].minor);
}
// 1307 "parser.c"
        break;
      case 23:
// 463 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_RAW_FRAGMENT, kkmsp[0].minor.kk0);
}
// 1314 "parser.c"
        break;
      case 24:
// 469 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_MINUS, NULL, kkmsp[0].minor.kk96);
  kk_destructor(20,&kkmsp[-1].minor);
}
// 1322 "parser.c"
        break;
      case 25:
// 473 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_SUB, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(20,&kkmsp[-1].minor);
}
// 1330 "parser.c"
        break;
      case 26:
// 477 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_ADD, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(19,&kkmsp[-1].minor);
}
// 1338 "parser.c"
        break;
      case 27:
// 481 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_MUL, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(17,&kkmsp[-1].minor);
}
// 1346 "parser.c"
        break;
      case 28:
// 485 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_DIV, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(16,&kkmsp[-1].minor);
}
// 1354 "parser.c"
        break;
      case 29:
// 489 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_MOD, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(18,&kkmsp[-1].minor);
}
// 1362 "parser.c"
        break;
      case 30:
// 493 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_AND, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(13,&kkmsp[-1].minor);
}
// 1370 "parser.c"
        break;
      case 31:
// 497 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_OR, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(14,&kkmsp[-1].minor);
}
// 1378 "parser.c"
        break;
      case 32:
// 501 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_CONCAT, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(21,&kkmsp[-1].minor);
}
// 1386 "parser.c"
        break;
      case 33:
// 505 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_PIPE, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(15,&kkmsp[-1].minor);
}
// 1394 "parser.c"
        break;
      case 34:
// 509 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_RANGE, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(3,&kkmsp[-1].minor);
}
// 1402 "parser.c"
        break;
      case 35:
// 513 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_EQUALS, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(5,&kkmsp[-1].minor);
}
// 1410 "parser.c"
        break;
      case 36:
// 517 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_NOT_ISSET, kkmsp[-3].minor.kk96, NULL);
  kk_destructor(4,&kkmsp[-2].minor);
  kk_destructor(22,&kkmsp[-1].minor);
  kk_destructor(43,&kkmsp[0].minor);
}
// 1420 "parser.c"
        break;
      case 37:
// 521 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_ISSET, kkmsp[-2].minor.kk96, NULL);
  kk_destructor(4,&kkmsp[-1].minor);
  kk_destructor(43,&kkmsp[0].minor);
}
// 1429 "parser.c"
        break;
      case 38:
// 525 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_EQUALS, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(4,&kkmsp[-1].minor);
}
// 1437 "parser.c"
        break;
      case 39:
// 529 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_NOTEQUALS, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(6,&kkmsp[-1].minor);
}
// 1445 "parser.c"
        break;
      case 40:
// 533 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_IDENTICAL, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(11,&kkmsp[-1].minor);
}
// 1453 "parser.c"
        break;
      case 41:
// 537 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_NOTIDENTICAL, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(12,&kkmsp[-1].minor);
}
// 1461 "parser.c"
        break;
      case 42:
// 541 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_LESS, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(7,&kkmsp[-1].minor);
}
// 1469 "parser.c"
        break;
      case 43:
// 545 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_GREATER, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(8,&kkmsp[-1].minor);
}
// 1477 "parser.c"
        break;
      case 44:
// 549 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_GREATEREQUAL, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(9,&kkmsp[-1].minor);
}
// 1485 "parser.c"
        break;
      case 45:
// 553 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_LESSEQUAL, kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(10,&kkmsp[-1].minor);
}
// 1493 "parser.c"
        break;
      case 46:
// 557 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_NOT, NULL, kkmsp[0].minor.kk96);
  kk_destructor(22,&kkmsp[-1].minor);
}
// 1501 "parser.c"
        break;
      case 47:
// 561 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_ENCLOSED, kkmsp[-1].minor.kk96, NULL);
  kk_destructor(44,&kkmsp[-2].minor);
  kk_destructor(45,&kkmsp[0].minor);
}
// 1510 "parser.c"
        break;
      case 48:
// 565 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_ARRAY, kkmsp[-1].minor.kk96, NULL);
  kk_destructor(2,&kkmsp[-2].minor);
  kk_destructor(46,&kkmsp[0].minor);
}
// 1519 "parser.c"
        break;
      case 49:
      case 56:
// 571 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_zval_list(kkmsp[-2].minor.kk96, kkmsp[0].minor.kk96);
  kk_destructor(1,&kkmsp[-1].minor);
}
// 1528 "parser.c"
        break;
      case 51:
      case 59:
// 579 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_named_item(kkmsp[-2].minor.kk0, kkmsp[0].minor.kk96);
  kk_destructor(47,&kkmsp[-1].minor);
}
// 1537 "parser.c"
        break;
      case 52:
      case 58:
// 583 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_named_item(NULL, kkmsp[0].minor.kk96);
}
// 1545 "parser.c"
        break;
      case 54:
// 593 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_func_call(kkmsp[-3].minor.kk0, kkmsp[-1].minor.kk96);
  kk_destructor(44,&kkmsp[-2].minor);
  kk_destructor(45,&kkmsp[0].minor);
}
// 1554 "parser.c"
        break;
      case 55:
// 597 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_func_call(kkmsp[-2].minor.kk0, NULL);
  kk_destructor(44,&kkmsp[-1].minor);
  kk_destructor(45,&kkmsp[0].minor);
}
// 1563 "parser.c"
        break;
      case 61:
// 625 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_expr(PHVOLT_T_ARRAYACCESS, kkmsp[-3].minor.kk96, kkmsp[-1].minor.kk96);
  kk_destructor(2,&kkmsp[-2].minor);
  kk_destructor(46,&kkmsp[0].minor);
}
// 1572 "parser.c"
        break;
      case 62:
// 629 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_INTEGER, kkmsp[0].minor.kk0);
}
// 1579 "parser.c"
        break;
      case 63:
// 633 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_STRING, kkmsp[0].minor.kk0);
}
// 1586 "parser.c"
        break;
      case 64:
// 637 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_DOUBLE, kkmsp[0].minor.kk0);
}
// 1593 "parser.c"
        break;
      case 65:
// 641 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_NULL, NULL);
  kk_destructor(50,&kkmsp[0].minor);
}
// 1601 "parser.c"
        break;
      case 66:
// 645 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_FALSE, NULL);
  kk_destructor(51,&kkmsp[0].minor);
}
// 1609 "parser.c"
        break;
      case 67:
// 649 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_literal_zval(PHVOLT_T_TRUE, NULL);
  kk_destructor(52,&kkmsp[0].minor);
}
// 1617 "parser.c"
        break;
      case 68:
// 655 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_qualified_name(kkmsp[-2].minor.kk96, kkmsp[0].minor.kk0);
  kk_destructor(23,&kkmsp[-1].minor);
}
// 1625 "parser.c"
        break;
      case 69:
// 659 "parser.lemon"
{
	kkgotominor.kk96 = phvolt_ret_qualified_name(NULL, kkmsp[0].minor.kk0);
}
// 1632 "parser.c"
        break;
  };
  kkgoto = kkRuleInfo[kkruleno].lhs;
  kksize = kkRuleInfo[kkruleno].nrhs;
  kkpParser->kkidx -= kksize;
  kkact = kk_find_reduce_action(kkpParser,kkgoto);
  if( kkact < KKNSTATE ){
    kk_shift(kkpParser,kkact,kkgoto,&kkgotominor);
  }else if( kkact == KKNSTATE + KKNRULE + 1 ){
    kk_accept(kkpParser);
  }
}

static void kk_parse_failed(
  kkParser *kkpParser           /* The parser */
){
  phvolt_ARG_FETCH;
#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sFail!\n",kkTracePrompt);
  }
#endif
  while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void kk_syntax_error(
  kkParser *kkpParser,           /* The parser */
  int kkmajor,                   /* The major type of the error token */
  KKMINORTYPE kkminor            /* The minor type of the error token */
){
  phvolt_ARG_FETCH;
#define KTOKEN (kkminor.kk0)
// 297 "parser.lemon"

	if (status->scanner_state->start) {
		{

			char *token_name = NULL;
			const phvolt_token_names *tokens = phvolt_tokens;
			int token_found = 0;
			int active_token = status->scanner_state->active_token;

			if (active_token) {

				do {
					if (tokens->code == active_token) {
						token_found = 1;
						token_name = tokens->name;
						break;
					}
					++tokens;
				} while (tokens[0].code != 0);

			}

			if (!token_name) {
				token_found = 0;
				token_name = estrndup("UNKNOWN", strlen("UNKNOWN"));
			}

			status->syntax_error_len = 64 + strlen(token_name);
			status->syntax_error = emalloc(sizeof(char)*status->syntax_error_len);
			sprintf(status->syntax_error, "Syntax error, unexpected token %s on line %d", token_name, status->scanner_state->active_line);

			if (!token_found) {
				if (token_name) {
					efree(token_name);
				}
			}
		}
	} else {
		status->syntax_error_len = strlen("Syntax error, unexpected EOF");
		status->syntax_error = estrndup("Syntax error, unexpected EOF", status->syntax_error_len);
	}

	status->status = PHVOLT_PARSING_FAILED;

// 1719 "parser.c"
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void kk_accept(
  kkParser *kkpParser           /* The parser */
){
  phvolt_ARG_FETCH;
#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sAccept!\n",kkTracePrompt);
  }
#endif
  while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "phvolt_Alloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
void phvolt_(
  void *kkp,                   /* The parser */
  int kkmajor,                 /* The major token code number */
  phvolt_KTOKENTYPE kkminor       /* The value for the token */
  phvolt_ARG_PDECL               /* Optional %extra_argument parameter */
){
  KKMINORTYPE kkminorunion;
  int kkact;            /* The parser action. */
  int kkendofinput;     /* True if we are at the end of input */
  int kkerrorhit = 0;   /* True if kkmajor has invoked an error */
  kkParser *kkpParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  kkpParser = (kkParser*)kkp;
  if( kkpParser->kkidx<0 ){
    if( kkmajor==0 ) return;
    kkpParser->kkidx = 0;
    kkpParser->kkerrcnt = -1;
    kkpParser->kkstack[0].stateno = 0;
    kkpParser->kkstack[0].major = 0;
  }
  kkminorunion.kk0 = kkminor;
  kkendofinput = (kkmajor==0);
  phvolt_ARG_STORE;

#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sInput %s\n",kkTracePrompt,kkTokenName[kkmajor]);
  }
#endif

  do{
    kkact = kk_find_shift_action(kkpParser,kkmajor);
    if( kkact<KKNSTATE ){
      kk_shift(kkpParser,kkact,kkmajor,&kkminorunion);
      kkpParser->kkerrcnt--;
      if( kkendofinput && kkpParser->kkidx>=0 ){
        kkmajor = 0;
      }else{
        kkmajor = KKNOCODE;
      }
    }else if( kkact < KKNSTATE + KKNRULE ){
      kk_reduce(kkpParser,kkact-KKNSTATE);
    }else if( kkact == KK_ERROR_ACTION ){
      int kkmx;
#ifndef NDEBUG
      if( kkTraceFILE ){
        fprintf(kkTraceFILE,"%sSyntax Error!\n",kkTracePrompt);
      }
#endif
#ifdef KKERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( kkpParser->kkerrcnt<0 ){
        kk_syntax_error(kkpParser,kkmajor,kkminorunion);
      }
      kkmx = kkpParser->kkstack[kkpParser->kkidx].major;
      if( kkmx==KKERRORSYMBOL || kkerrorhit ){
#ifndef NDEBUG
        if( kkTraceFILE ){
          fprintf(kkTraceFILE,"%sDiscard input token %s\n",
             kkTracePrompt,kkTokenName[kkmajor]);
        }
#endif
        kk_destructor(kkmajor,&kkminorunion);
        kkmajor = KKNOCODE;
      }else{
         while(
          kkpParser->kkidx >= 0 &&
          kkmx != KKERRORSYMBOL &&
          (kkact = kk_find_shift_action(kkpParser,KKERRORSYMBOL)) >= KKNSTATE
        ){
          kk_pop_parser_stack(kkpParser);
        }
        if( kkpParser->kkidx < 0 || kkmajor==0 ){
          kk_destructor(kkmajor,&kkminorunion);
          kk_parse_failed(kkpParser);
          kkmajor = KKNOCODE;
        }else if( kkmx!=KKERRORSYMBOL ){
          KKMINORTYPE u2;
          u2.KKERRSYMDT = 0;
          kk_shift(kkpParser,kkact,KKERRORSYMBOL,&u2);
        }
      }
      kkpParser->kkerrcnt = 3;
      kkerrorhit = 1;
#else  /* KKERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( kkpParser->kkerrcnt<=0 ){
        kk_syntax_error(kkpParser,kkmajor,kkminorunion);
      }
      kkpParser->kkerrcnt = 3;
      kk_destructor(kkmajor,&kkminorunion);
      if( kkendofinput ){
        kk_parse_failed(kkpParser);
      }
      kkmajor = KKNOCODE;
#endif
    }else{
      kk_accept(kkpParser);
      kkmajor = KKNOCODE;
    }
  }while( kkmajor!=KKNOCODE && kkpParser->kkidx>=0 );
  return;
}


const phvolt_token_names phvolt_tokens[] =
{
  { PHVOLT_T_INTEGER,       	"INTEGER" },
  { PHVOLT_T_DOUBLE,        	"DOUBLE" },
  { PHVOLT_T_STRING,        	"STRING" },
  { PHVOLT_T_IDENTIFIER,    	"IDENTIFIER" },
  { PHVOLT_T_MINUS,         	"MINUS" },
  { PHVOLT_T_ADD,           	"+" },
  { PHVOLT_T_SUB,           	"-" },
  { PHVOLT_T_MUL,           	"*" },
  { PHVOLT_T_DIV,           	"/" },
  { PHVOLT_T_MOD,           	"%%" },
  { PHVOLT_T_NOT,           	"!" },
  { PHVOLT_T_AND,           	"AND" },
  { PHVOLT_T_OR,            	"OR" },
  { PHVOLT_T_DOT,           	"DOT" },
  { PHVOLT_T_COMMA,         	"COMMA" },
  { PHVOLT_T_EQUALS,        	"EQUALS" },
  { PHVOLT_T_NOTEQUALS,     	"NOT EQUALS" },
  { PHVOLT_T_IDENTICAL,     	"IDENTICAL" },
  { PHVOLT_T_NOTIDENTICAL,  	"NOT IDENTICAL" },
  { PHVOLT_T_NOT,           	"NOT" },
  { PHVOLT_T_RANGE,           	"RANGE" },
  { PHVOLT_T_LESS,          	"<" },
  { PHVOLT_T_LESSEQUAL,     	"<=" },
  { PHVOLT_T_GREATER,       	">" },
  { PHVOLT_T_GREATEREQUAL,  	">=" },
  { PHVOLT_T_BRACKET_OPEN,  	"(" },
  { PHVOLT_T_BRACKET_CLOSE, 	")" },
  { PHVOLT_T_OPEN_DELIMITER, 	"{%" },
  { PHVOLT_T_CLOSE_DELIMITER, 	"%}" },
  { PHVOLT_T_OPEN_EDELIMITER, 	"{{" },
  { PHVOLT_T_CLOSE_EDELIMITER, 	"}}" },
  { PHVOLT_T_IF,           		"IF" },
  { PHVOLT_T_ELSE,           	"ELSE" },
  { PHVOLT_T_ENDIF,           	"ENDIF" },
  { PHVOLT_T_FOR,           	"FOR" },
  { PHVOLT_T_IN, 	          	"IN" },
  { PHVOLT_T_ENDFOR,           	"ENDFOR" },
  { PHVOLT_T_SET,           	"SET" },
  { PHVOLT_T_ASSIGN,           	"ASSIGN" },
  { PHVOLT_T_BLOCK,           	"BLOCK" },
  { PHVOLT_T_ENDBLOCK,          "ENDBLOCK" },
  { PHVOLT_T_EXTENDS,			"EXTENDS" },
  { PHVOLT_T_IS,				"IS" },
  { PHVOLT_T_DEFINED,			"DEFINED" },
  { PHVOLT_T_INCLUDE,			"INCLUDE" },
  {  0, NULL }
};

static void *phvolt_wrapper_alloc(size_t bytes){
	return emalloc(bytes);
}

static void phvolt_wrapper_free(void *pointer){
	efree(pointer);
}

static void phvolt_parse_with_token(void* phvolt_parser, int opcode, int parsercode, phvolt_scanner_token *token, phvolt_parser_status *parser_status){
	phvolt_parser_token *pToken;
	pToken = emalloc(sizeof(phvolt_parser_token));
	pToken->opcode = opcode;
	pToken->token = token->value;
	pToken->token_len = token->len;
	phvolt_(phvolt_parser, parsercode, pToken, parser_status);
}

static void phvolt_create_error_msg(phvolt_parser_status *parser_status, char *message){
	char *str = emalloc(sizeof(char) * 128);
	sprintf(str, "%s on line %d", message, parser_status->scanner_state->active_line);
	parser_status->syntax_error = estrndup(str, strlen(str));
	efree(str);
}

int phvolt_parse_view(zval *result, zval *view_code TSRMLS_DC){

	zval *error_msg = NULL;

	ZVAL_NULL(result);

	if (Z_TYPE_P(view_code) != IS_STRING) {
		phalcon_throw_exception_string(phalcon_mvc_view_exception_ce, Z_STRVAL_P(error_msg), Z_STRLEN_P(error_msg) TSRMLS_CC);
		return FAILURE;
	}

	if(phvolt_internal_parse_view(&result, Z_STRVAL_P(view_code), Z_STRLEN_P(view_code), &error_msg TSRMLS_CC) == FAILURE){
		phalcon_throw_exception_string(phalcon_mvc_view_exception_ce, Z_STRVAL_P(error_msg), Z_STRLEN_P(error_msg) TSRMLS_CC);
		return FAILURE;
	}

	return SUCCESS;
}

int phvolt_is_blank_string(phvolt_scanner_token *token){
	int i;
	char ch, *marker = token->value;
	for (i = 0; i < token->len; i++) {
		ch = *marker;
		if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r' && ch != 11) {
			return 0;
		}
		marker++;
	}
	return 1;
}

int phvolt_internal_parse_view(zval **result, char *view_code, unsigned int view_length, zval **error_msg TSRMLS_DC) {

	char *error;
	phvolt_scanner_state *state;
	phvolt_scanner_token *token;
	int scanner_status, status = SUCCESS;
	phvolt_parser_status *parser_status = NULL;
	void* phvolt_parser;

	if (!view_code) {
		PHALCON_INIT_VAR(*error_msg);
		ZVAL_STRING(*error_msg, "View code cannot be null", 1);
		return FAILURE;
	}

	if (!view_length) {
		array_init(*result);
		return SUCCESS;
	}

	phvolt_parser = phvolt_Alloc(phvolt_wrapper_alloc);

	parser_status = emalloc(sizeof(phvolt_parser_status));
	state = emalloc(sizeof(phvolt_scanner_state));
	token = emalloc(sizeof(phvolt_scanner_token));

	parser_status->status = PHVOLT_PARSING_OK;
	parser_status->scanner_state = state;
	parser_status->ret = NULL;
	parser_status->syntax_error = NULL;

	/** Initialize the scanner state */
	state->active_token = 0;
	state->start = view_code;
	state->mode = PHVOLT_MODE_RAW;
	state->raw_buffer = emalloc(sizeof(char) * PHVOLT_RAW_BUFFER_SIZE);
	state->raw_buffer_size = PHVOLT_RAW_BUFFER_SIZE;
	state->raw_buffer_cursor = 0;
	state->active_line = 1;
	state->statement_position = 0;
	state->extends_mode = 0;
	state->block_level = 0;

	state->end = state->start;

	while(0 <= (scanner_status = phvolt_get_token(state, token))) {

		state->active_token = token->opcode;

		switch(token->opcode){

			case PHVOLT_T_IGNORE:
				break;

			case PHVOLT_T_ADD:
				phvolt_(phvolt_parser, PHVOLT_PLUS, NULL, parser_status);
				break;
			case PHVOLT_T_SUB:
				phvolt_(phvolt_parser, PHVOLT_MINUS, NULL, parser_status);
				break;
			case PHVOLT_T_MUL:
				phvolt_(phvolt_parser, PHVOLT_TIMES, NULL, parser_status);
				break;
			case PHVOLT_T_DIV:
				phvolt_(phvolt_parser, PHVOLT_DIVIDE, NULL, parser_status);
				break;
			case PHVOLT_T_MOD:
				phvolt_(phvolt_parser, PHVOLT_MOD, NULL, parser_status);
				break;
			case PHVOLT_T_AND:
				phvolt_(phvolt_parser, PHVOLT_AND, NULL, parser_status);
				break;
			case PHVOLT_T_OR:
				phvolt_(phvolt_parser, PHVOLT_OR, NULL, parser_status);
				break;
			case PHVOLT_T_IS:
				phvolt_(phvolt_parser, PHVOLT_IS, NULL, parser_status);
				break;
			case PHVOLT_T_EQUALS:
				phvolt_(phvolt_parser, PHVOLT_EQUALS, NULL, parser_status);
				break;
			case PHVOLT_T_NOTEQUALS:
				phvolt_(phvolt_parser, PHVOLT_NOTEQUALS, NULL, parser_status);
				break;
			case PHVOLT_T_LESS:
				phvolt_(phvolt_parser, PHVOLT_LESS, NULL, parser_status);
				break;
			case PHVOLT_T_GREATER:
				phvolt_(phvolt_parser, PHVOLT_GREATER, NULL, parser_status);
				break;
			case PHVOLT_T_GREATEREQUAL:
				phvolt_(phvolt_parser, PHVOLT_GREATEREQUAL, NULL, parser_status);
				break;
			case PHVOLT_T_LESSEQUAL:
				phvolt_(phvolt_parser, PHVOLT_LESSEQUAL, NULL, parser_status);
				break;
			case PHVOLT_T_IDENTICAL:
				phvolt_(phvolt_parser, PHVOLT_IDENTICAL, NULL, parser_status);
				break;
			case PHVOLT_T_NOTIDENTICAL:
				phvolt_(phvolt_parser, PHVOLT_NOTIDENTICAL, NULL, parser_status);
				break;
			case PHVOLT_T_NOT:
				phvolt_(phvolt_parser, PHVOLT_NOT, NULL, parser_status);
				break;
			case PHVOLT_T_DOT:
				phvolt_(phvolt_parser, PHVOLT_DOT, NULL, parser_status);
				break;
			case PHVOLT_T_CONCAT:
				phvolt_(phvolt_parser, PHVOLT_CONCAT, NULL, parser_status);
				break;
			case PHVOLT_T_RANGE:
				phvolt_(phvolt_parser, PHVOLT_RANGE, NULL, parser_status);
				break;
			case PHVOLT_T_PIPE:
				phvolt_(phvolt_parser, PHVOLT_PIPE, NULL, parser_status);
				break;
			case PHVOLT_T_COMMA:
				phvolt_(phvolt_parser, PHVOLT_COMMA, NULL, parser_status);
				break;
			case PHVOLT_T_DOUBLECOLON:
				phvolt_(phvolt_parser, PHVOLT_DOUBLECOLON, NULL, parser_status);
				break;

			case PHVOLT_T_BRACKET_OPEN:
				phvolt_(phvolt_parser, PHVOLT_BRACKET_OPEN, NULL, parser_status);
				break;
			case PHVOLT_T_BRACKET_CLOSE:
				phvolt_(phvolt_parser, PHVOLT_BRACKET_CLOSE, NULL, parser_status);
				break;
			case PHVOLT_T_SBRACKET_OPEN:
				phvolt_(phvolt_parser, PHVOLT_SBRACKET_OPEN, NULL, parser_status);
				break;
			case PHVOLT_T_SBRACKET_CLOSE:
				phvolt_(phvolt_parser, PHVOLT_SBRACKET_CLOSE, NULL, parser_status);
				break;

			case PHVOLT_T_OPEN_DELIMITER:
				phvolt_(phvolt_parser, PHVOLT_OPEN_DELIMITER, NULL, parser_status);
				break;
			case PHVOLT_T_CLOSE_DELIMITER:
				phvolt_(phvolt_parser, PHVOLT_CLOSE_DELIMITER, NULL, parser_status);
				break;

			case PHVOLT_T_OPEN_EDELIMITER:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				}
				phvolt_(phvolt_parser, PHVOLT_OPEN_EDELIMITER, NULL, parser_status);
				break;
			case PHVOLT_T_CLOSE_EDELIMITER:
				phvolt_(phvolt_parser, PHVOLT_CLOSE_EDELIMITER, NULL, parser_status);
				break;

			case PHVOLT_T_NULL:
				phvolt_(phvolt_parser, PHVOLT_NULL, NULL, parser_status);
				break;
			case PHVOLT_T_TRUE:
				phvolt_(phvolt_parser, PHVOLT_TRUE, NULL, parser_status);
				break;
			case PHVOLT_T_FALSE:
				phvolt_(phvolt_parser, PHVOLT_FALSE, NULL, parser_status);
				break;

			case PHVOLT_T_INTEGER:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_INTEGER, PHVOLT_INTEGER, token, parser_status);
				break;
			case PHVOLT_T_DOUBLE:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_DOUBLE, PHVOLT_DOUBLE, token, parser_status);
				break;
			case PHVOLT_T_STRING:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_STRING, PHVOLT_STRING, token, parser_status);
				break;
			case PHVOLT_T_IDENTIFIER:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_IDENTIFIER, PHVOLT_IDENTIFIER, token, parser_status);
				break;

			case PHVOLT_T_IF:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_IF, NULL, parser_status);
				break;
			case PHVOLT_T_ELSE:
				phvolt_(phvolt_parser, PHVOLT_ELSE, NULL, parser_status);
				break;
			case PHVOLT_T_ENDIF:
				state->block_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDIF, NULL, parser_status);
				break;

			case PHVOLT_T_FOR:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_FOR, NULL, parser_status);
				break;
			case PHVOLT_T_IN:
				phvolt_(phvolt_parser, PHVOLT_IN, NULL, parser_status);
				break;
			case PHVOLT_T_ENDFOR:
				state->block_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDFOR, NULL, parser_status);
				break;

			case PHVOLT_T_RAW_FRAGMENT:
				if (state->extends_mode == 1 && state->block_level == 0){
					if(!phvolt_is_blank_string(token)){
						phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
						parser_status->status = PHVOLT_PARSING_FAILED;
					} else {
						efree(token->value);
					}
					break;
				}
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_RAW_FRAGMENT, PHVOLT_RAW_FRAGMENT, token, parser_status);
				break;

			case PHVOLT_T_SET:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				}
				phvolt_(phvolt_parser, PHVOLT_SET, NULL, parser_status);
				break;
			case PHVOLT_T_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_ASSIGN, NULL, parser_status);
				break;

			case PHVOLT_T_BLOCK:
				if(state->block_level > 0){
					phvolt_create_error_msg(parser_status, "Embedding blocks into other blocks is not supported");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_BLOCK, NULL, parser_status);
				break;
			case PHVOLT_T_ENDBLOCK:
				state->block_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDBLOCK, NULL, parser_status);
				break;

			case PHVOLT_T_INCLUDE:
				phvolt_(phvolt_parser, PHVOLT_INCLUDE, NULL, parser_status);
				break;

			case PHVOLT_T_DEFINED:
				phvolt_(phvolt_parser, PHVOLT_DEFINED, NULL, parser_status);
				break;

			case PHVOLT_T_EXTENDS:
				if (state->statement_position != 1) {
					phvolt_create_error_msg(parser_status, "Extends statement must be placed at the first line in the template");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->extends_mode = 1;
				}
				phvolt_(phvolt_parser, PHVOLT_EXTENDS, NULL, parser_status);
				break;

			default:
				parser_status->status = PHVOLT_PARSING_FAILED;
				error = emalloc(sizeof(char) * 32);
				sprintf(error, "Scanner: unknown opcode %c", token->opcode);
				PHALCON_INIT_VAR(*error_msg);
				ZVAL_STRING(*error_msg, error, 1);
				efree(error);
				break;
		}

		if (parser_status->status != PHVOLT_PARSING_OK) {
			status = FAILURE;
			break;
		}

		state->end = state->start;
	}

	state->active_token = 0;
	state->start = NULL;
	efree(state->raw_buffer);

	if (status != FAILURE) {
		switch (scanner_status) {
			case PHVOLT_SCANNER_RETCODE_ERR:
			case PHVOLT_SCANNER_RETCODE_IMPOSSIBLE:
				if (!*error_msg) {
					PHALCON_INIT_VAR(*error_msg);
					if (state->start) {
						error = emalloc(sizeof(char) *(48 + strlen(state->start)));
						sprintf(error, "Parsing error near to %s (%d)", state->start, status);
						ZVAL_STRING(*error_msg, error, 1);
						efree(error);
					} else {
						ZVAL_STRING(*error_msg, "Parsing error near to EOF", 1);
					}
				}
				status = FAILURE;
				break;
			default:
				phvolt_(phvolt_parser, 0, NULL, parser_status);
		}
	}

	if (parser_status->status != PHVOLT_PARSING_OK) {
		status = FAILURE;
		if (parser_status->syntax_error) {
			if (!*error_msg) {
				PHALCON_INIT_VAR(*error_msg);
				ZVAL_STRING(*error_msg, parser_status->syntax_error, 1);
			}
			efree(parser_status->syntax_error);
		}
	}

	phvolt_Free(phvolt_parser, phvolt_wrapper_free);

	if (status != FAILURE) {
		if (parser_status->status == PHVOLT_PARSING_OK) {
			if (parser_status->ret) {
				ZVAL_ZVAL(*result, parser_status->ret, 0, 0);
				ZVAL_NULL(parser_status->ret);
				zval_ptr_dtor(&parser_status->ret);
			} else {
				array_init(*result);
			}
		}
	}

	efree(parser_status);
	efree(state);
	efree(token);

	return status;
}


/* Generated by re2c 0.13.5 on Sat Nov 10 23:11:03 2012 */
// 1 "scanner.re"


#ifdef HAVE_CONFIG_H
#endif



#define KKCTYPE char
#define KKCURSOR (s->start)
#define KKLIMIT (s->end)
#define KKMARKER q

int phvolt_get_token(phvolt_scanner_state *s, phvolt_scanner_token *token) {

	char next, *q = KKCURSOR, *start = KKCURSOR;
	int status = PHVOLT_SCANNER_RETCODE_IMPOSSIBLE;

	while (PHVOLT_SCANNER_RETCODE_IMPOSSIBLE == status) {

		if (s->mode == PHVOLT_MODE_RAW || s->mode == PHVOLT_MODE_COMMENT) {

			if (*KKCURSOR == '\n') {
				s->active_line++;
			}

			next = *(KKCURSOR+1);
			if (*KKCURSOR == '\0' || (*KKCURSOR == '{' && (next == '%' || next == '{' || next == '#'))) {

				if (next != '#') {

					s->mode = PHVOLT_MODE_CODE;

					if (s->raw_buffer_cursor > 0) {
						token->opcode = PHVOLT_T_RAW_FRAGMENT;
						token->value = emalloc(sizeof(char) * s->raw_buffer_cursor+1);
						memcpy(token->value, s->raw_buffer, s->raw_buffer_cursor);
						token->value[s->raw_buffer_cursor] = 0;
						token->len = s->raw_buffer_cursor;
						s->raw_buffer_cursor = 0;
						q = KKCURSOR;
					} else {
						token->opcode = PHVOLT_T_IGNORE;
					}

				} else {

					while ((next = *(++KKCURSOR))) {
						if (next == '#' && *(KKCURSOR+1) == '}') {
							KKCURSOR+=2;
							token->opcode = PHVOLT_T_IGNORE;
							return 0;
						} else {
							if (next == '\n') {
								s->active_line++;
							}
						}
					}

					return PHVOLT_SCANNER_RETCODE_EOF;

				}

				return 0;

			} else {

				if (s->raw_buffer_cursor == s->raw_buffer_size) {
					s->raw_buffer_size += PHVOLT_RAW_BUFFER_SIZE;
					s->raw_buffer = erealloc(s->raw_buffer, s->raw_buffer_size);
				}

				memcpy(s->raw_buffer+s->raw_buffer_cursor, KKCURSOR, 1);
				s->raw_buffer_cursor++;

				++KKCURSOR;
			}

		} else {

		
// 105 "scanner.c"
		{
			KKCTYPE kkch;
			unsigned int kkaccept = 0;

			kkch = *KKCURSOR;
			switch (kkch) {
			case 0x00:	goto kk61;
			case '\t':
			case '\r':
			case ' ':	goto kk57;
			case '\n':	goto kk59;
			case '!':	goto kk51;
			case '"':	goto kk20;
			case '%':	goto kk17;
			case '\'':	goto kk21;
			case '(':	goto kk37;
			case ')':	goto kk39;
			case '*':	goto kk27;
			case '+':	goto kk23;
			case ',':	goto kk35;
			case '-':	goto kk25;
			case '.':	goto kk33;
			case '/':	goto kk29;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto kk2;
			case ':':	goto kk55;
			case '<':	goto kk45;
			case '=':	goto kk47;
			case '>':	goto kk49;
			case 'A':
			case 'a':	goto kk11;
			case 'B':
			case 'b':	goto kk13;
			case 'C':
			case 'G':
			case 'H':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'P':
			case 'Q':
			case 'R':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case 'c':
			case 'g':
			case 'h':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'p':
			case 'q':
			case 'r':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk22;
			case 'D':
			case 'd':	goto kk14;
			case 'E':
			case 'e':	goto kk6;
			case 'F':
			case 'f':	goto kk7;
			case 'I':
			case 'i':	goto kk4;
			case 'N':
			case 'n':	goto kk9;
			case 'O':
			case 'o':	goto kk12;
			case 'S':
			case 's':	goto kk8;
			case 'T':
			case 't':	goto kk10;
			case '[':	goto kk41;
			case ']':	goto kk43;
			case '{':	goto kk15;
			case '|':	goto kk53;
			case '}':	goto kk19;
			case '~':	goto kk31;
			default:	goto kk63;
			}
kk2:
			kkaccept = 0;
			kkch = *(KKMARKER = ++KKCURSOR);
			goto kk180;
kk3:
// 106 "scanner.re"
			{
			token->opcode = PHVOLT_T_INTEGER;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
// 216 "scanner.c"
kk4:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case 'F':
			case 'f':	goto kk166;
			case 'N':
			case 'n':	goto kk168;
			case 'S':
			case 's':	goto kk170;
			default:	goto kk83;
			}
kk5:
// 259 "scanner.re"
			{
			token->opcode = PHVOLT_T_IDENTIFIER;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
// 237 "scanner.c"
kk6:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk140;
			case 'N':
			case 'n':	goto kk141;
			case 'X':
			case 'x':	goto kk142;
			default:	goto kk83;
			}
kk7:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'A':
			case 'a':	goto kk132;
			case 'O':
			case 'o':	goto kk133;
			default:	goto kk83;
			}
kk8:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk129;
			default:	goto kk83;
			}
kk9:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'O':
			case 'o':	goto kk122;
			case 'U':
			case 'u':	goto kk123;
			default:	goto kk83;
			}
kk10:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'R':
			case 'r':	goto kk118;
			default:	goto kk83;
			}
kk11:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'N':
			case 'n':	goto kk115;
			default:	goto kk83;
			}
kk12:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'R':
			case 'r':	goto kk113;
			default:	goto kk83;
			}
kk13:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk108;
			default:	goto kk83;
			}
kk14:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk101;
			default:	goto kk83;
			}
kk15:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '%':	goto kk99;
			case '{':	goto kk97;
			default:	goto kk16;
			}
kk16:
// 413 "scanner.re"
			{
			status = PHVOLT_SCANNER_RETCODE_ERR;
			break;
		}
// 322 "scanner.c"
kk17:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '}':	goto kk95;
			default:	goto kk18;
			}
kk18:
// 287 "scanner.re"
			{
			token->opcode = PHVOLT_T_MOD;
			return 0;
		}
// 335 "scanner.c"
kk19:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case '}':	goto kk93;
			default:	goto kk16;
			}
kk20:
			kkaccept = 1;
			kkch = *(KKMARKER = ++KKCURSOR);
			if (kkch <= 0x00) goto kk16;
			goto kk91;
kk21:
			kkaccept = 1;
			kkch = *(KKMARKER = ++KKCURSOR);
			if (kkch <= 0x00) goto kk16;
			goto kk85;
kk22:
			kkch = *++KKCURSOR;
			goto kk83;
kk23:
			++KKCURSOR;
// 267 "scanner.re"
			{
			token->opcode = PHVOLT_T_ADD;
			return 0;
		}
// 362 "scanner.c"
kk25:
			++KKCURSOR;
// 272 "scanner.re"
			{
			token->opcode = PHVOLT_T_SUB;
			return 0;
		}
// 370 "scanner.c"
kk27:
			++KKCURSOR;
// 277 "scanner.re"
			{
			token->opcode = PHVOLT_T_MUL;
			return 0;
		}
// 378 "scanner.c"
kk29:
			++KKCURSOR;
// 282 "scanner.re"
			{
			token->opcode = PHVOLT_T_DIV;
			return 0;
		}
// 386 "scanner.c"
kk31:
			++KKCURSOR;
// 292 "scanner.re"
			{
			token->opcode = PHVOLT_T_CONCAT;
			return 0;
		}
// 394 "scanner.c"
kk33:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '.':	goto kk80;
			default:	goto kk34;
			}
kk34:
// 302 "scanner.re"
			{
			token->opcode = PHVOLT_T_DOT;
			return 0;
		}
// 407 "scanner.c"
kk35:
			++KKCURSOR;
// 307 "scanner.re"
			{
			token->opcode = PHVOLT_T_COMMA;
			return 0;
		}
// 415 "scanner.c"
kk37:
			++KKCURSOR;
// 312 "scanner.re"
			{
			token->opcode = PHVOLT_T_BRACKET_OPEN;
			return 0;
		}
// 423 "scanner.c"
kk39:
			++KKCURSOR;
// 317 "scanner.re"
			{
			token->opcode = PHVOLT_T_BRACKET_CLOSE;
			return 0;
		}
// 431 "scanner.c"
kk41:
			++KKCURSOR;
// 322 "scanner.re"
			{
			token->opcode = PHVOLT_T_SBRACKET_OPEN;
			return 0;
		}
// 439 "scanner.c"
kk43:
			++KKCURSOR;
// 327 "scanner.re"
			{
			token->opcode = PHVOLT_T_SBRACKET_CLOSE;
			return 0;
		}
// 447 "scanner.c"
kk45:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk78;
			case '>':	goto kk76;
			default:	goto kk46;
			}
kk46:
// 377 "scanner.re"
			{
			token->opcode = PHVOLT_T_LESS;
			return 0;
		}
// 461 "scanner.c"
kk47:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk72;
			default:	goto kk48;
			}
kk48:
// 337 "scanner.re"
			{
			token->opcode = PHVOLT_T_ASSIGN;
			return 0;
		}
// 474 "scanner.c"
kk49:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk70;
			default:	goto kk50;
			}
kk50:
// 382 "scanner.re"
			{
			token->opcode = PHVOLT_T_GREATER;
			return 0;
		}
// 487 "scanner.c"
kk51:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk66;
			default:	goto kk52;
			}
kk52:
// 372 "scanner.re"
			{
			token->opcode = PHVOLT_T_NOT;
			return 0;
		}
// 500 "scanner.c"
kk53:
			++KKCURSOR;
// 387 "scanner.re"
			{
			token->opcode = PHVOLT_T_PIPE;
			return 0;
		}
// 508 "scanner.c"
kk55:
			++KKCURSOR;
// 392 "scanner.re"
			{
			token->opcode = PHVOLT_T_DOUBLECOLON;
			return 0;
		}
// 516 "scanner.c"
kk57:
			++KKCURSOR;
			kkch = *KKCURSOR;
			goto kk65;
kk58:
// 397 "scanner.re"
			{
			token->opcode = PHVOLT_T_IGNORE;
			return 0;
		}
// 527 "scanner.c"
kk59:
			++KKCURSOR;
// 402 "scanner.re"
			{
			s->active_line++;
			token->opcode = PHVOLT_T_IGNORE;
			return 0;
		}
// 536 "scanner.c"
kk61:
			++KKCURSOR;
// 408 "scanner.re"
			{
			status = PHVOLT_SCANNER_RETCODE_EOF;
			break;
		}
// 544 "scanner.c"
kk63:
			kkch = *++KKCURSOR;
			goto kk16;
kk64:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk65:
			switch (kkch) {
			case '\t':
			case '\r':
			case ' ':	goto kk64;
			default:	goto kk58;
			}
kk66:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk68;
			default:	goto kk67;
			}
kk67:
// 352 "scanner.re"
			{
			token->opcode = PHVOLT_T_NOTEQUALS;
			return 0;
		}
// 570 "scanner.c"
kk68:
			++KKCURSOR;
// 367 "scanner.re"
			{
			token->opcode = PHVOLT_T_NOTIDENTICAL;
			return 0;
		}
// 578 "scanner.c"
kk70:
			++KKCURSOR;
// 342 "scanner.re"
			{
			token->opcode = PHVOLT_T_GREATEREQUAL;
			return 0;
		}
// 586 "scanner.c"
kk72:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '=':	goto kk74;
			default:	goto kk73;
			}
kk73:
// 347 "scanner.re"
			{
			token->opcode = PHVOLT_T_EQUALS;
			return 0;
		}
// 599 "scanner.c"
kk74:
			++KKCURSOR;
// 362 "scanner.re"
			{
			token->opcode = PHVOLT_T_IDENTICAL;
			return 0;
		}
// 607 "scanner.c"
kk76:
			++KKCURSOR;
// 357 "scanner.re"
			{
			token->opcode = PHVOLT_T_NOTEQUALS;
			return 0;
		}
// 615 "scanner.c"
kk78:
			++KKCURSOR;
// 332 "scanner.re"
			{
			token->opcode = PHVOLT_T_LESSEQUAL;
			return 0;
		}
// 623 "scanner.c"
kk80:
			++KKCURSOR;
// 297 "scanner.re"
			{
			token->opcode = PHVOLT_T_RANGE;
			return 0;
		}
// 631 "scanner.c"
kk82:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk83:
			switch (kkch) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk5;
			}
kk84:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk85:
			switch (kkch) {
			case 0x00:	goto kk86;
			case '\'':	goto kk88;
			case '\\':	goto kk87;
			default:	goto kk84;
			}
kk86:
			KKCURSOR = KKMARKER;
			switch (kkaccept) {
			case 0: 	goto kk3;
			case 1: 	goto kk16;
			}
kk87:
			++KKCURSOR;
			kkch = *KKCURSOR;
			switch (kkch) {
			case '\n':	goto kk86;
			default:	goto kk84;
			}
kk88:
			++KKCURSOR;
// 250 "scanner.re"
			{
			token->opcode = PHVOLT_T_STRING;
			token->value = estrndup(q, KKCURSOR - q - 1);
			token->len = KKCURSOR - q - 1;
			q = KKCURSOR;
			return 0;
		}
// 736 "scanner.c"
kk90:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk91:
			switch (kkch) {
			case 0x00:	goto kk86;
			case '"':	goto kk88;
			case '\\':	goto kk92;
			default:	goto kk90;
			}
kk92:
			++KKCURSOR;
			kkch = *KKCURSOR;
			switch (kkch) {
			case '\n':	goto kk86;
			default:	goto kk90;
			}
kk93:
			++KKCURSOR;
// 243 "scanner.re"
			{
			s->mode = PHVOLT_MODE_RAW;
			token->opcode = PHVOLT_T_CLOSE_EDELIMITER;
			return 0;
		}
// 762 "scanner.c"
kk95:
			++KKCURSOR;
// 231 "scanner.re"
			{
			s->mode = PHVOLT_MODE_RAW;
			token->opcode = PHVOLT_T_CLOSE_DELIMITER;
			return 0;
		}
// 771 "scanner.c"
kk97:
			++KKCURSOR;
// 237 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_OPEN_EDELIMITER;
			return 0;
		}
// 780 "scanner.c"
kk99:
			++KKCURSOR;
// 226 "scanner.re"
			{
			token->opcode = PHVOLT_T_OPEN_DELIMITER;
			return 0;
		}
// 788 "scanner.c"
kk101:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'F':
			case 'f':	goto kk102;
			default:	goto kk83;
			}
kk102:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'I':
			case 'i':	goto kk103;
			default:	goto kk83;
			}
kk103:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'N':
			case 'n':	goto kk104;
			default:	goto kk83;
			}
kk104:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk105;
			default:	goto kk83;
			}
kk105:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'D':
			case 'd':	goto kk106;
			default:	goto kk83;
			}
kk106:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk107;
			}
kk107:
// 214 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_DEFINED;
			return 0;
		}
// 900 "scanner.c"
kk108:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'O':
			case 'o':	goto kk109;
			default:	goto kk83;
			}
kk109:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'C':
			case 'c':	goto kk110;
			default:	goto kk83;
			}
kk110:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'K':
			case 'k':	goto kk111;
			default:	goto kk83;
			}
kk111:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk112;
			}
kk112:
// 185 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_BLOCK;
			return 0;
		}
// 998 "scanner.c"
kk113:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk114;
			}
kk114:
// 180 "scanner.re"
			{
			token->opcode = PHVOLT_T_OR;
			return 0;
		}
// 1074 "scanner.c"
kk115:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'D':
			case 'd':	goto kk116;
			default:	goto kk83;
			}
kk116:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk117;
			}
kk117:
// 175 "scanner.re"
			{
			token->opcode = PHVOLT_T_AND;
			return 0;
		}
// 1157 "scanner.c"
kk118:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'U':
			case 'u':	goto kk119;
			default:	goto kk83;
			}
kk119:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk120;
			default:	goto kk83;
			}
kk120:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk121;
			}
kk121:
// 170 "scanner.re"
			{
			token->opcode = PHVOLT_T_TRUE;
			return 0;
		}
// 1247 "scanner.c"
kk122:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'T':
			case 't':	goto kk127;
			default:	goto kk83;
			}
kk123:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk124;
			default:	goto kk83;
			}
kk124:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk125;
			default:	goto kk83;
			}
kk125:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk126;
			}
kk126:
// 160 "scanner.re"
			{
			token->opcode = PHVOLT_T_NULL;
			return 0;
		}
// 1344 "scanner.c"
kk127:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk128;
			}
kk128:
// 208 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_NOT;
			return 0;
		}
// 1421 "scanner.c"
kk129:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'T':
			case 't':	goto kk130;
			default:	goto kk83;
			}
kk130:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk131;
			}
kk131:
// 155 "scanner.re"
			{
			token->opcode = PHVOLT_T_SET;
			return 0;
		}
// 1504 "scanner.c"
kk132:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk136;
			default:	goto kk83;
			}
kk133:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'R':
			case 'r':	goto kk134;
			default:	goto kk83;
			}
kk134:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk135;
			}
kk135:
// 139 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_FOR;
			return 0;
		}
// 1595 "scanner.c"
kk136:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'S':
			case 's':	goto kk137;
			default:	goto kk83;
			}
kk137:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk138;
			default:	goto kk83;
			}
kk138:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk139;
			}
kk139:
// 165 "scanner.re"
			{
			token->opcode = PHVOLT_T_FALSE;
			return 0;
		}
// 1685 "scanner.c"
kk140:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'S':
			case 's':	goto kk163;
			default:	goto kk83;
			}
kk141:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'D':
			case 'd':	goto kk149;
			default:	goto kk83;
			}
kk142:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'T':
			case 't':	goto kk143;
			default:	goto kk83;
			}
kk143:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk144;
			default:	goto kk83;
			}
kk144:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'N':
			case 'n':	goto kk145;
			default:	goto kk83;
			}
kk145:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'D':
			case 'd':	goto kk146;
			default:	goto kk83;
			}
kk146:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'S':
			case 's':	goto kk147;
			default:	goto kk83;
			}
kk147:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk148;
			}
kk148:
// 196 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_EXTENDS;
			return 0;
		}
// 1811 "scanner.c"
kk149:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'B':
			case 'b':	goto kk150;
			case 'F':
			case 'f':	goto kk151;
			case 'I':
			case 'i':	goto kk152;
			default:	goto kk83;
			}
kk150:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk158;
			default:	goto kk83;
			}
kk151:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'O':
			case 'o':	goto kk155;
			default:	goto kk83;
			}
kk152:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'F':
			case 'f':	goto kk153;
			default:	goto kk83;
			}
kk153:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk154;
			}
kk154:
// 134 "scanner.re"
			{
			token->opcode = PHVOLT_T_ENDIF;
			return 0;
		}
// 1919 "scanner.c"
kk155:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'R':
			case 'r':	goto kk156;
			default:	goto kk83;
			}
kk156:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk157;
			}
kk157:
// 145 "scanner.re"
			{
			token->opcode = PHVOLT_T_ENDFOR;
			return 0;
		}
// 2002 "scanner.c"
kk158:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'O':
			case 'o':	goto kk159;
			default:	goto kk83;
			}
kk159:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'C':
			case 'c':	goto kk160;
			default:	goto kk83;
			}
kk160:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'K':
			case 'k':	goto kk161;
			default:	goto kk83;
			}
kk161:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk162;
			}
kk162:
// 191 "scanner.re"
			{
			token->opcode = PHVOLT_T_ENDBLOCK;
			return 0;
		}
// 2099 "scanner.c"
kk163:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk164;
			default:	goto kk83;
			}
kk164:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk165;
			}
kk165:
// 129 "scanner.re"
			{
			token->opcode = PHVOLT_T_ELSE;
			return 0;
		}
// 2182 "scanner.c"
kk166:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk167;
			}
kk167:
// 123 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_IF;
			return 0;
		}
// 2259 "scanner.c"
kk168:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			case 'C':
			case 'c':	goto kk172;
			default:	goto kk169;
			}
kk169:
// 150 "scanner.re"
			{
			token->opcode = PHVOLT_T_IN;
			return 0;
		}
// 2335 "scanner.c"
kk170:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk171;
			}
kk171:
// 202 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_IS;
			return 0;
		}
// 2412 "scanner.c"
kk172:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'L':
			case 'l':	goto kk173;
			default:	goto kk83;
			}
kk173:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'U':
			case 'u':	goto kk174;
			default:	goto kk83;
			}
kk174:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'D':
			case 'd':	goto kk175;
			default:	goto kk83;
			}
kk175:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'E':
			case 'e':	goto kk176;
			default:	goto kk83;
			}
kk176:
			++KKCURSOR;
			switch ((kkch = *KKCURSOR)) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'N':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'T':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '\\':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto kk82;
			default:	goto kk177;
			}
kk177:
// 220 "scanner.re"
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_INCLUDE;
			return 0;
		}
// 2517 "scanner.c"
kk178:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto kk181;
			default:	goto kk86;
			}
kk179:
			kkaccept = 0;
			KKMARKER = ++KKCURSOR;
			kkch = *KKCURSOR;
kk180:
			switch (kkch) {
			case '.':	goto kk178;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto kk179;
			default:	goto kk3;
			}
kk181:
			++KKCURSOR;
			kkch = *KKCURSOR;
			switch (kkch) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto kk181;
			default:	goto kk183;
			}
kk183:
// 115 "scanner.re"
			{
			token->opcode = PHVOLT_T_DOUBLE;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
// 2577 "scanner.c"
		}
// 418 "scanner.re"


		}
	}

	return status;
}




#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View, Engine, mvc_view_engine, "phalcon\\di\\injectable", phalcon_mvc_view_engine_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_view_engine_ce, SL("_view"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_View_Engine, __construct){

	zval *view, *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &view, &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_view"), view TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View_Engine, getContent){

	zval *view, *content;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(view);
	phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(content);
	PHALCON_CALL_METHOD(content, view, "getcontent", PH_NO_CHECK);
	
	RETURN_CCTOR(content);
}

PHP_METHOD(Phalcon_Mvc_View_Engine, partial){

	zval *partial_path, *view, *content;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &partial_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(view);
	phalcon_read_property(&view, this_ptr, SL("_view"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(content);
	PHALCON_CALL_METHOD_PARAMS_1(content, view, "partial", partial_path, PH_NO_CHECK);
	
	RETURN_CCTOR(content);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_View_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View, Exception, mvc_view_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_View){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, View, mvc_view, "phalcon\\di\\injectable", phalcon_mvc_view_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_basePath"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_content"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_ce, SL("_renderLevel"), 5, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_viewParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_layoutsDir"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_viewsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_templatesBefore"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_templatesAfter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_ce, SL("_engines"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_registeredEngines"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_mainView"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_controllerName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_actionName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_pickView"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_ce, SL("_cacheLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_activeRenderPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_ce, SL("_disabled"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_MAIN_LAYOUT"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_AFTER_TEMPLATE"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_LAYOUT"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_BEFORE_TEMPLATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_ACTION_VIEW"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_NO_RENDER"), 0 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_ce TSRMLS_CC, 1, phalcon_mvc_viewinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_View, __construct){

	zval *options = NULL;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_mvc_view_ce, this_ptr, SL("_viewParams") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_view_ce, this_ptr, SL("_registeredEngines") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_view_ce, this_ptr, SL("_params") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, setViewsDir){

	zval *views_dir;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &views_dir) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_viewsDir"), views_dir TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, getViewsDir){


	RETURN_MEMBER(this_ptr, "_viewsDir");
}

PHP_METHOD(Phalcon_Mvc_View, setBasePath){

	zval *base_path;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &base_path) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_basePath"), base_path TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, setRenderLevel){

	zval *level;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &level) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_renderLevel"), level TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, setMainView){

	zval *view_path;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &view_path) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_mainView"), view_path TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, setTemplateBefore){

	zval *template_before, *array_template;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &template_before) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(template_before) != IS_ARRAY) { 
		PHALCON_INIT_VAR(array_template);
		array_init(array_template);
		phalcon_array_append(&array_template, template_before, PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_templatesBefore"), array_template TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_templatesBefore"), template_before TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, cleanTemplateBefore){


	phalcon_update_property_null(this_ptr, SL("_templatesBefore") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, setTemplateAfter){

	zval *template_after, *array_template;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &template_after) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(template_after) != IS_ARRAY) { 
		PHALCON_INIT_VAR(array_template);
		array_init(array_template);
		phalcon_array_append(&array_template, template_after, PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_templatesAfter"), array_template TSRMLS_CC);
	} else {
		phalcon_update_property_zval(this_ptr, SL("_templatesAfter"), template_after TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, cleanTemplateAfter){


	phalcon_update_property_null(this_ptr, SL("_templatesAfter") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, setParamToView){

	zval *key, *value;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, key, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_viewParams"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, setVar){

	zval *key, *value;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &key, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, key, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_viewParams"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, getParamsToView){


	RETURN_MEMBER(this_ptr, "_viewParams");
}

PHP_METHOD(Phalcon_Mvc_View, getControllerName){


	RETURN_MEMBER(this_ptr, "_controllerName");
}

PHP_METHOD(Phalcon_Mvc_View, getActionName){


	RETURN_MEMBER(this_ptr, "_actionName");
}

PHP_METHOD(Phalcon_Mvc_View, getParams){


	RETURN_MEMBER(this_ptr, "_params");
}

PHP_METHOD(Phalcon_Mvc_View, start){


	PHALCON_MM_GROW();

	phalcon_update_property_null(this_ptr, SL("_content") TSRMLS_CC);
	PHALCON_CALL_FUNC_NORETURN("ob_start");
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, _loadTemplateEngines){

	zval *engines = NULL, *dependency_injector, *registered_engines;
	zval *number_engines, *php_engine, *arguments;
	zval *engine_service = NULL, *extension = NULL, *engine_object = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(engines);
	phalcon_read_property(&engines, this_ptr, SL("_engines"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(engines)) {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(engines);
		array_init(engines);
	
		PHALCON_INIT_VAR(registered_engines);
		phalcon_read_property(&registered_engines, this_ptr, SL("_registeredEngines"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(number_engines);
		phalcon_fast_count(number_engines, registered_engines TSRMLS_CC);
		if (phalcon_compare_strict_long(number_engines, 0 TSRMLS_CC)) {
			PHALCON_INIT_VAR(php_engine);
			object_init_ex(php_engine, phalcon_mvc_view_engine_php_ce);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(php_engine, "__construct", this_ptr, dependency_injector, PH_CHECK);
			phalcon_array_update_string(&engines, SL(".phtml"), &php_engine, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the application services");
				return;
			}
	
			PHALCON_INIT_VAR(arguments);
			array_init(arguments);
			phalcon_array_append(&arguments, this_ptr, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&arguments, dependency_injector, PH_SEPARATE TSRMLS_CC);
	
			if (!phalcon_valid_foreach(registered_engines TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(registered_engines);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_KEY(extension, ah0, hp0);
				PHALCON_GET_FOREACH_VALUE(engine_service);
	
				PHALCON_INIT_NVAR(engine_object);
				PHALCON_CALL_METHOD_PARAMS_2(engine_object, dependency_injector, "getshared", engine_service, arguments, PH_NO_CHECK);
				phalcon_array_update_zval(&engines, extension, &engine_object, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
			if(0){}
	
		}
	
		phalcon_update_property_zval(this_ptr, SL("_engines"), engines TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(engines);
		phalcon_read_property(&engines, this_ptr, SL("_engines"), PH_NOISY_CC);
	}
	
	
	RETURN_CCTOR(engines);
}

PHP_METHOD(Phalcon_Mvc_View, _engineRender){

	zval *engines, *view_path, *silence, *must_clean;
	zval *cache, *not_exists = NULL, *view_params, *views_dir;
	zval *base_path, *views_dir_path, *events_manager;
	zval *render_level, *cache_level, *enter_cache;
	zval *is_started, *key = NULL, *view_options, *cache_options;
	zval *cached_view, *is_fresh, *engine = NULL, *extension = NULL;
	zval *view_engine_path = NULL, *event_name = NULL, *status = NULL;
	zval *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzzz", &engines, &view_path, &silence, &must_clean, &cache) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(not_exists);
	ZVAL_BOOL(not_exists, 1);
	
	PHALCON_INIT_VAR(view_params);
	phalcon_read_property(&view_params, this_ptr, SL("_viewParams"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(views_dir);
	phalcon_read_property(&views_dir, this_ptr, SL("_viewsDir"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(base_path);
	phalcon_read_property(&base_path, this_ptr, SL("_basePath"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(views_dir_path);
	PHALCON_CONCAT_VVV(views_dir_path, base_path, views_dir, view_path);
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(cache) == IS_OBJECT) {
		PHALCON_INIT_VAR(render_level);
		phalcon_read_property(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(cache_level);
		phalcon_read_property(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(enter_cache);
		is_smaller_or_equal_function(enter_cache, cache_level, render_level TSRMLS_CC);
		if (zend_is_true(enter_cache)) {
			PHALCON_INIT_VAR(is_started);
			PHALCON_CALL_METHOD(is_started, cache, "isstarted", PH_NO_CHECK);
			if (PHALCON_IS_FALSE(is_started)) {
				PHALCON_INIT_VAR(key);
	
				PHALCON_INIT_VAR(view_options);
				phalcon_read_property(&view_options, this_ptr, SL("_options"), PH_NOISY_CC);
				if (Z_TYPE_P(view_options) == IS_ARRAY) { 
					eval_int = phalcon_array_isset_string(view_options, SS("cache"));
					if (eval_int) {
						PHALCON_INIT_VAR(cache_options);
						phalcon_array_fetch_string(&cache_options, view_options, SL("cache"), PH_NOISY_CC);
						if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
							eval_int = phalcon_array_isset_string(cache_options, SS("key"));
							if (eval_int) {
								phalcon_array_fetch_string(&key, cache_options, SL("key"), PH_NOISY_CC);
							}
						}
					}
				}
	
				if (Z_TYPE_P(key) == IS_NULL) {
					PHALCON_INIT_NVAR(key);
					PHALCON_CALL_FUNC_PARAMS_1(key, "md5", view_path);
				}
	
				PHALCON_INIT_VAR(cached_view);
				PHALCON_CALL_METHOD_PARAMS_1(cached_view, cache, "start", key, PH_NO_CHECK);
				if (Z_TYPE_P(cached_view) != IS_NULL) {
					phalcon_update_property_zval(this_ptr, SL("_content"), cached_view TSRMLS_CC);
					PHALCON_MM_RESTORE();
					RETURN_NULL();
				}
			}
	
			PHALCON_INIT_VAR(is_fresh);
			PHALCON_CALL_METHOD(is_fresh, cache, "isfresh", PH_NO_CHECK);
			if (!zend_is_true(is_fresh)) {
				PHALCON_MM_RESTORE();
				RETURN_NULL();
			}
		}
	}
	
	
	if (!phalcon_valid_foreach(engines TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(engines);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(extension, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(engine);
	
		PHALCON_INIT_NVAR(view_engine_path);
		PHALCON_CONCAT_VV(view_engine_path, views_dir_path, extension);
		if (phalcon_file_exists(view_engine_path TSRMLS_CC) == SUCCESS) {
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				phalcon_update_property_zval(this_ptr, SL("_activeRenderPath"), view_engine_path TSRMLS_CC);
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:beforeRenderView", 1);
	
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, view_engine_path, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
				}
			}
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(engine, "render", view_engine_path, view_params, must_clean, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(not_exists);
			ZVAL_BOOL(not_exists, 0);
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				phalcon_update_property_zval(this_ptr, SL("_activeRenderPath"), view_engine_path TSRMLS_CC);
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:afterRenderView", 1);
	
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
				}
			}
	
			goto ph_cycle_end_0;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (PHALCON_IS_TRUE(not_exists)) {
		if (!zend_is_true(silence)) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "View '", views_dir_path, "' was not found in the views directory");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, registerEngines){

	zval *engines;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &engines) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(engines) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Engines to register must be an array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_registeredEngines"), engines TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, render){

	zval *controller_name, *action_name, *params = NULL;
	zval *disabled, *layouts_dir = NULL, *engines, *pick_view;
	zval *render_view = NULL, *render_controller = NULL, *pick_view_action;
	zval *cache = NULL, *cache_level, *events_manager, *event_name = NULL;
	zval *status, *contents, *must_clean, *silence = NULL;
	zval *render_level, *enter_level = NULL, *templates_before;
	zval *template_before = NULL, *view_temp_path = NULL, *templates_after;
	zval *template_after = NULL, *main_view, *is_started;
	zval *is_fresh;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &controller_name, &action_name, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!params) {
		PHALCON_INIT_NVAR(params);
		array_init(params);
	}
	
	PHALCON_INIT_VAR(disabled);
	phalcon_read_property(&disabled, this_ptr, SL("_disabled"), PH_NOISY_CC);
	if (PHALCON_IS_NOT_FALSE(disabled)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(layouts_dir);
	phalcon_read_property(&layouts_dir, this_ptr, SL("_layoutsDir"), PH_NOISY_CC);
	if (!zend_is_true(layouts_dir)) {
		PHALCON_INIT_NVAR(layouts_dir);
		ZVAL_STRING(layouts_dir, "layouts/", 1);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_controllerName"), controller_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	
	PHALCON_INIT_VAR(engines);
	PHALCON_CALL_METHOD(engines, this_ptr, "_loadtemplateengines", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(pick_view);
	phalcon_read_property(&pick_view, this_ptr, SL("_pickView"), PH_NOISY_CC);
	if (Z_TYPE_P(pick_view) == IS_NULL) {
		PHALCON_INIT_VAR(render_view);
		PHALCON_CONCAT_VSV(render_view, controller_name, "/", action_name);
		PHALCON_CPY_WRT(render_controller, controller_name);
	} else {
		PHALCON_INIT_NVAR(render_view);
		phalcon_array_fetch_long(&render_view, pick_view, 0, PH_NOISY_CC);
		eval_int = phalcon_array_isset_long(pick_view, 1);
		if (eval_int) {
			PHALCON_INIT_VAR(pick_view_action);
			phalcon_array_fetch_long(&pick_view_action, pick_view, 1, PH_NOISY_CC);
			PHALCON_CPY_WRT(render_controller, pick_view_action);
		} else {
			PHALCON_CPY_WRT(render_controller, controller_name);
		}
	}
	
	PHALCON_INIT_VAR(cache);
	
	PHALCON_INIT_VAR(cache_level);
	phalcon_read_property(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY_CC);
	if (zend_is_true(cache_level)) {
		PHALCON_CALL_METHOD(cache, this_ptr, "getcache", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "view:beforeRender", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(contents);
	PHALCON_CALL_FUNC(contents, "ob_get_contents");
	phalcon_update_property_zval(this_ptr, SL("_content"), contents TSRMLS_CC);
	
	PHALCON_INIT_VAR(must_clean);
	ZVAL_BOOL(must_clean, 1);
	
	PHALCON_INIT_VAR(silence);
	ZVAL_BOOL(silence, 1);
	
	PHALCON_INIT_VAR(render_level);
	phalcon_read_property(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY_CC);
	if (zend_is_true(render_level)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 1);
		PHALCON_INIT_VAR(enter_level);
		is_smaller_or_equal_function(enter_level, t0, render_level TSRMLS_CC);
		if (PHALCON_IS_TRUE(enter_level)) {
			PHALCON_CALL_METHOD_PARAMS_5_NORETURN(this_ptr, "_enginerender", engines, render_view, silence, must_clean, cache, PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(t1);
		ZVAL_LONG(t1, 2);
	
		PHALCON_INIT_NVAR(enter_level);
		is_smaller_or_equal_function(enter_level, t1, render_level TSRMLS_CC);
		if (PHALCON_IS_TRUE(enter_level)) {
			PHALCON_INIT_VAR(templates_before);
			phalcon_read_property(&templates_before, this_ptr, SL("_templatesBefore"), PH_NOISY_CC);
			if (Z_TYPE_P(templates_before) == IS_ARRAY) { 
				ZVAL_BOOL(silence, 0);
	
				if (!phalcon_valid_foreach(templates_before TSRMLS_CC)) {
					return;
				}
	
				ah0 = Z_ARRVAL_P(templates_before);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
				ph_cycle_start_0:
	
					if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
						goto ph_cycle_end_0;
					}
	
					PHALCON_GET_FOREACH_VALUE(template_before);
	
					PHALCON_INIT_NVAR(view_temp_path);
					PHALCON_CONCAT_VV(view_temp_path, layouts_dir, template_before);
					PHALCON_CALL_METHOD_PARAMS_5_NORETURN(this_ptr, "_enginerender", engines, view_temp_path, silence, must_clean, cache, PH_NO_CHECK);
	
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
	
				ph_cycle_end_0:
	
				ZVAL_BOOL(silence, 1);
			}
		}
	
		PHALCON_INIT_VAR(t2);
		ZVAL_LONG(t2, 3);
	
		PHALCON_INIT_NVAR(enter_level);
		is_smaller_or_equal_function(enter_level, t2, render_level TSRMLS_CC);
		if (PHALCON_IS_TRUE(enter_level)) {
			PHALCON_INIT_NVAR(view_temp_path);
			PHALCON_CONCAT_VV(view_temp_path, layouts_dir, render_controller);
			PHALCON_CALL_METHOD_PARAMS_5_NORETURN(this_ptr, "_enginerender", engines, view_temp_path, silence, must_clean, cache, PH_NO_CHECK);
		}
	
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 4);
	
		PHALCON_INIT_NVAR(enter_level);
		is_smaller_or_equal_function(enter_level, t3, render_level TSRMLS_CC);
		if (PHALCON_IS_TRUE(enter_level)) {
			PHALCON_INIT_VAR(templates_after);
			phalcon_read_property(&templates_after, this_ptr, SL("_templatesAfter"), PH_NOISY_CC);
			if (Z_TYPE_P(templates_after) == IS_ARRAY) { 
				ZVAL_BOOL(silence, 0);
	
				if (!phalcon_valid_foreach(templates_after TSRMLS_CC)) {
					return;
				}
	
				ah1 = Z_ARRVAL_P(templates_after);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
				ph_cycle_start_1:
	
					if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
						goto ph_cycle_end_1;
					}
	
					PHALCON_GET_FOREACH_VALUE(template_after);
	
					PHALCON_INIT_NVAR(view_temp_path);
					PHALCON_CONCAT_VV(view_temp_path, layouts_dir, template_after);
					PHALCON_CALL_METHOD_PARAMS_5_NORETURN(this_ptr, "_enginerender", engines, view_temp_path, silence, must_clean, cache, PH_NO_CHECK);
	
					zend_hash_move_forward_ex(ah1, &hp1);
					goto ph_cycle_start_1;
	
				ph_cycle_end_1:
	
				ZVAL_BOOL(silence, 1);
			}
		}
	
		PHALCON_INIT_VAR(t4);
		ZVAL_LONG(t4, 5);
	
		PHALCON_INIT_NVAR(enter_level);
		is_smaller_or_equal_function(enter_level, t4, render_level TSRMLS_CC);
		if (PHALCON_IS_TRUE(enter_level)) {
			PHALCON_INIT_VAR(main_view);
			phalcon_read_property(&main_view, this_ptr, SL("_mainView"), PH_NOISY_CC);
			PHALCON_CALL_METHOD_PARAMS_5_NORETURN(this_ptr, "_enginerender", engines, main_view, silence, must_clean, cache, PH_NO_CHECK);
		}
	
		if (Z_TYPE_P(cache) == IS_OBJECT) {
			PHALCON_INIT_VAR(is_started);
			PHALCON_CALL_METHOD(is_started, cache, "isstarted", PH_NO_CHECK);
			if (PHALCON_IS_TRUE(is_started)) {
				PHALCON_INIT_VAR(is_fresh);
				PHALCON_CALL_METHOD(is_fresh, cache, "isfresh", PH_NO_CHECK);
				if (PHALCON_IS_TRUE(is_fresh)) {
					PHALCON_CALL_METHOD_NORETURN(cache, "save", PH_NO_CHECK);
				} else {
					PHALCON_CALL_METHOD_NORETURN(cache, "stop", PH_NO_CHECK);
				}
			} else {
				PHALCON_CALL_METHOD_NORETURN(cache, "stop", PH_NO_CHECK);
			}
		}
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "view:afterRender", 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, pick){

	zval *render_view, *separator, *pick_view = NULL, *layout = NULL;
	zval *parts;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &render_view) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(separator);
	ZVAL_STRING(separator, "/", 1);
	if (Z_TYPE_P(render_view) == IS_ARRAY) { 
		PHALCON_CPY_WRT(pick_view, render_view);
	} else {
		PHALCON_INIT_VAR(layout);
		if (phalcon_memnstr(render_view, separator TSRMLS_CC)) {
			PHALCON_INIT_VAR(parts);
			phalcon_fast_explode(parts, separator, render_view TSRMLS_CC);
	
			phalcon_array_fetch_long(&layout, parts, 0, PH_NOISY_CC);
		}
	
		PHALCON_INIT_VAR(pick_view);
		array_init(pick_view);
		phalcon_array_append(&pick_view, render_view, PH_SEPARATE TSRMLS_CC);
		if (Z_TYPE_P(layout) != IS_NULL) {
			phalcon_array_append(&pick_view, layout, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	phalcon_update_property_zval(this_ptr, SL("_pickView"), pick_view TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, partial){

	zval *partial_path, *zfalse, *engines, *content;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &partial_path) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(zfalse);
	ZVAL_BOOL(zfalse, 0);
	
	PHALCON_INIT_VAR(engines);
	PHALCON_CALL_METHOD(engines, this_ptr, "_loadtemplateengines", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(content);
	PHALCON_CALL_METHOD_PARAMS_5(content, this_ptr, "_enginerender", engines, partial_path, zfalse, zfalse, zfalse, PH_NO_CHECK);
	
	RETURN_CCTOR(content);
}

PHP_METHOD(Phalcon_Mvc_View, finish){


	PHALCON_MM_GROW();

	PHALCON_CALL_FUNC_NORETURN("ob_end_clean");
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, _createCache){

	zval *dependency_injector, *cache_service = NULL;
	zval *view_options, *cache_options, *view_cache;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the view cache services");
		return;
	}
	
	PHALCON_INIT_VAR(cache_service);
	ZVAL_STRING(cache_service, "viewCache", 1);
	
	PHALCON_INIT_VAR(view_options);
	phalcon_read_property(&view_options, this_ptr, SL("_options"), PH_NOISY_CC);
	if (Z_TYPE_P(view_options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(view_options, SS("cache"));
		if (eval_int) {
			PHALCON_INIT_VAR(cache_options);
			phalcon_array_fetch_string(&cache_options, view_options, SL("cache"), PH_NOISY_CC);
			if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
				eval_int = phalcon_array_isset_string(cache_options, SS("service"));
				if (eval_int) {
					PHALCON_INIT_NVAR(cache_service);
					phalcon_array_fetch_string(&cache_service, cache_options, SL("service"), PH_NOISY_CC);
				}
			}
		}
	}
	
	PHALCON_INIT_VAR(view_cache);
	PHALCON_CALL_METHOD_PARAMS_1(view_cache, dependency_injector, "getshared", cache_service, PH_NO_CHECK);
	
	RETURN_CCTOR(view_cache);
}

PHP_METHOD(Phalcon_Mvc_View, getCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(cache);
	phalcon_read_property(&cache, this_ptr, SL("_cache"), PH_NOISY_CC);
	if (zend_is_true(cache)) {
		if (Z_TYPE_P(cache) != IS_OBJECT) {
			PHALCON_INIT_NVAR(cache);
			PHALCON_CALL_METHOD(cache, this_ptr, "_createcache", PH_NO_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
		}
	} else {
		PHALCON_INIT_NVAR(cache);
		PHALCON_CALL_METHOD(cache, this_ptr, "_createcache", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_cache"), cache TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(cache);
}

PHP_METHOD(Phalcon_Mvc_View, cache){

	zval *options = NULL, *view_options = NULL, *cache_options = NULL;
	zval *value = NULL, *key = NULL, *cache_level;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
		ZVAL_BOOL(options, 1);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_INIT_VAR(view_options);
		phalcon_read_property(&view_options, this_ptr, SL("_options"), PH_NOISY_CC);
		if (Z_TYPE_P(view_options) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(view_options);
			array_init(view_options);
		}
	
		eval_int = phalcon_array_isset_string(view_options, SS("cache"));
		if (eval_int) {
			PHALCON_INIT_VAR(cache_options);
			phalcon_array_fetch_string(&cache_options, view_options, SL("cache"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(cache_options);
			array_init(cache_options);
		}
	
	
		if (!phalcon_valid_foreach(options TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(options);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			phalcon_array_update_zval(&cache_options, key, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		eval_int = phalcon_array_isset_string(cache_options, SS("level"));
		if (eval_int) {
			PHALCON_INIT_VAR(cache_level);
			phalcon_array_fetch_string(&cache_level, cache_options, SL("level"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_cacheLevel"), cache_level TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		}
	
		phalcon_array_update_string(&view_options, SL("cache"), &cache_options, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_options"), view_options TSRMLS_CC);
	} else {
		if (zend_is_true(options)) {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 0 TSRMLS_CC);
		}
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, setContent){

	zval *content;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &content) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(content) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Content must be a string");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_content"), content TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_View, getContent){


	RETURN_MEMBER(this_ptr, "_content");
}

PHP_METHOD(Phalcon_Mvc_View, getActiveRenderPath){


	RETURN_MEMBER(this_ptr, "_activeRenderPath");
}

PHP_METHOD(Phalcon_Mvc_View, disable){


	phalcon_update_property_bool(this_ptr, SL("_disabled"), 1 TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, enable){


	phalcon_update_property_bool(this_ptr, SL("_disabled"), 0 TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_View, reset){


	phalcon_update_property_bool(this_ptr, SL("_disabled"), 0 TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_engines"), 0 TSRMLS_CC);
	phalcon_update_property_null(this_ptr, SL("_cache") TSRMLS_CC);
	phalcon_update_property_long(this_ptr, SL("_renderLevel"), 5 TSRMLS_CC);
	phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 0 TSRMLS_CC);
	phalcon_update_property_null(this_ptr, SL("_content") TSRMLS_CC);
	
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Router){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Router, mvc_router, phalcon_mvc_router_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_module"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_controller"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_routes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_matchedRoute"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_matches"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_router_ce, SL("_wasMatched"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultModule"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultController"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultAction"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultParams"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_router_ce TSRMLS_CC, 2, phalcon_mvc_routerinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Router, __construct){

	zval *default_routes = NULL, *routes, *paths = NULL, *action_pattern;
	zval *route = NULL, *params_pattern;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_mvc_router_ce, this_ptr, SL("_params") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_mvc_router_ce, this_ptr, SL("_defaultParams") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &default_routes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!default_routes) {
		PHALCON_INIT_NVAR(default_routes);
		ZVAL_BOOL(default_routes, 1);
	}
	
	PHALCON_INIT_VAR(routes);
	array_init(routes);
	if (PHALCON_IS_TRUE(default_routes)) {
		PHALCON_INIT_VAR(paths);
		array_init(paths);
		add_assoc_long_ex(paths, SS("controller"), 1);
	
		PHALCON_INIT_VAR(action_pattern);
		ZVAL_STRING(action_pattern, "#^/([a-zA-Z0-9\\_]+)[/]{0,1}$#", 1);
	
		PHALCON_INIT_VAR(route);
		object_init_ex(route, phalcon_mvc_router_route_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(route, "__construct", action_pattern, paths, PH_CHECK);
		phalcon_array_append(&routes, route, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(paths);
		array_init(paths);
		add_assoc_long_ex(paths, SS("controller"), 1);
		add_assoc_long_ex(paths, SS("action"), 2);
		add_assoc_long_ex(paths, SS("params"), 3);
	
		PHALCON_INIT_VAR(params_pattern);
		ZVAL_STRING(params_pattern, "#^/([a-zA-Z0-9\\_]+)/([a-zA-Z0-9\\_]+)(/.*)*$#", 1);
	
		PHALCON_INIT_NVAR(route);
		object_init_ex(route, phalcon_mvc_router_route_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(route, "__construct", params_pattern, paths, PH_CHECK);
		phalcon_array_append(&routes, route, PH_SEPARATE TSRMLS_CC);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_routes"), routes TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Router, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Router, _getRewriteUri){

	zval *get = NULL, *url;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_get_global(&g0, SL("_GET")+1 TSRMLS_CC);
	PHALCON_CPY_WRT(get, g0);
	eval_int = phalcon_array_isset_string(get, SS("_url"));
	if (eval_int) {
		PHALCON_INIT_VAR(url);
		phalcon_array_fetch_string(&url, get, SL("_url"), PH_NOISY_CC);
	
		RETURN_CCTOR(url);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Router, setDefaultModule){

	zval *module_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &module_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultModule"), module_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Router, setDefaultController){

	zval *controller_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultController"), controller_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Router, setDefaultAction){

	zval *action_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAction"), action_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Router, setDefaults){

	zval *defaults, *module_name, *controller_name;
	zval *action_name, *params;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &defaults) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(defaults) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "Defaults must be an array");
		return;
	}
	eval_int = phalcon_array_isset_string(defaults, SS("module"));
	if (eval_int) {
		PHALCON_INIT_VAR(module_name);
		phalcon_array_fetch_string(&module_name, defaults, SL("module"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_defaultModule"), module_name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(defaults, SS("controller"));
	if (eval_int) {
		PHALCON_INIT_VAR(controller_name);
		phalcon_array_fetch_string(&controller_name, defaults, SL("controller"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_defaultController"), controller_name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(defaults, SS("action"));
	if (eval_int) {
		PHALCON_INIT_VAR(action_name);
		phalcon_array_fetch_string(&action_name, defaults, SL("action"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_defaultAction"), action_name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(defaults, SS("params"));
	if (eval_int) {
		PHALCON_INIT_VAR(params);
		phalcon_array_fetch_string(&params, defaults, SL("params"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_defaultParams"), params TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router, handle){

	zval *uri = NULL, *real_uri = NULL, *request = NULL, *route_found = NULL, *parts = NULL;
	zval *params = NULL, *matches, *routes, *reversed_routes;
	zval *route = NULL, *methods = NULL, *dependency_injector = NULL;
	zval *service = NULL, *match_method = NULL, *pattern = NULL, *paths = NULL;
	zval *position = NULL, *part = NULL, *match_position = NULL, *module;
	zval *default_module = NULL, *controller, *default_controller = NULL;
	zval *action, *default_action = NULL, *params_str, *one;
	zval *str_params, *slash, *params_merge, *default_params;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &uri) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!uri) {
		PHALCON_INIT_NVAR(uri);
	}
	
	if (!zend_is_true(uri)) {
		PHALCON_INIT_VAR(real_uri);
		PHALCON_CALL_METHOD(real_uri, this_ptr, "_getrewriteuri", PH_NO_CHECK);
	} else {
		PHALCON_CPY_WRT(real_uri, uri);
	}
	
	PHALCON_INIT_VAR(request);
	
	PHALCON_INIT_VAR(route_found);
	ZVAL_BOOL(route_found, 0);
	
	PHALCON_INIT_VAR(parts);
	array_init(parts);
	
	PHALCON_INIT_VAR(params);
	array_init(params);
	
	PHALCON_INIT_VAR(matches);
	phalcon_update_property_bool(this_ptr, SL("_wasMatched"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(routes);
	phalcon_read_property(&routes, this_ptr, SL("_routes"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(reversed_routes);
	PHALCON_CALL_FUNC_PARAMS_1(reversed_routes, "array_reverse", routes);
	
	if (!phalcon_valid_foreach(reversed_routes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(reversed_routes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(route);
	
		PHALCON_INIT_NVAR(methods);
		PHALCON_CALL_METHOD(methods, route, "gethttpmethods", PH_NO_CHECK);
		if (Z_TYPE_P(methods) != IS_NULL) {
			if (Z_TYPE_P(request) == IS_NULL) {
				PHALCON_INIT_NVAR(dependency_injector);
				phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_dispatcher_exception_ce, "A dependency injection container is required to access the 'request' service");
					return;
				}
	
				PHALCON_INIT_NVAR(service);
				ZVAL_STRING(service, "request", 1);
	
				PHALCON_INIT_NVAR(request);
				PHALCON_CALL_METHOD_PARAMS_1(request, dependency_injector, "getshared", service, PH_NO_CHECK);
			}
	
			PHALCON_INIT_NVAR(match_method);
			PHALCON_CALL_METHOD_PARAMS_1(match_method, request, "ismethod", methods, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(match_method)) {
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
			}
		}
	
		PHALCON_INIT_NVAR(pattern);
		PHALCON_CALL_METHOD(pattern, route, "getcompiledpattern", PH_NO_CHECK);
		if (phalcon_memnstr_str(pattern, SL("(") TSRMLS_CC)) {
			Z_SET_ISREF_P(matches);
			PHALCON_INIT_NVAR(route_found);
			PHALCON_CALL_FUNC_PARAMS_3(route_found, "preg_match", pattern, real_uri, matches);
			Z_UNSET_ISREF_P(matches);
		} else {
			PHALCON_INIT_NVAR(route_found);
			is_equal_function(route_found, pattern, real_uri TSRMLS_CC);
		}
	
		if (zend_is_true(route_found)) {
			PHALCON_INIT_NVAR(paths);
			PHALCON_CALL_METHOD(paths, route, "getpaths", PH_NO_CHECK);
			PHALCON_CPY_WRT(parts, paths);
			if (Z_TYPE_P(matches) == IS_ARRAY) { 
	
				if (!phalcon_valid_foreach(paths TSRMLS_CC)) {
					return;
				}
	
				ah1 = Z_ARRVAL_P(paths);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
				ph_cycle_start_1:
	
					if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
						goto ph_cycle_end_1;
					}
	
					PHALCON_GET_FOREACH_KEY(part, ah1, hp1);
					PHALCON_GET_FOREACH_VALUE(position);
	
					eval_int = phalcon_array_isset(matches, position);
					if (eval_int) {
						PHALCON_INIT_NVAR(match_position);
						phalcon_array_fetch(&match_position, matches, position, PH_NOISY_CC);
						phalcon_array_update_zval(&parts, part, &match_position, PH_COPY | PH_SEPARATE TSRMLS_CC);
					}
	
					zend_hash_move_forward_ex(ah1, &hp1);
					goto ph_cycle_start_1;
	
				ph_cycle_end_1:
	
				phalcon_update_property_zval(this_ptr, SL("_matches"), matches TSRMLS_CC);
			}
	
			phalcon_update_property_zval(this_ptr, SL("_matchedRoute"), route TSRMLS_CC);
			goto ph_cycle_end_0;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (zend_is_true(route_found)) {
		eval_int = phalcon_array_isset_string(parts, SS("module"));
		if (eval_int) {
			PHALCON_INIT_VAR(module);
			phalcon_array_fetch_string(&module, parts, SL("module"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_module"), module TSRMLS_CC);
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SS("module"));
		} else {
			PHALCON_INIT_VAR(default_module);
			phalcon_read_property(&default_module, this_ptr, SL("_defaultModule"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_module"), default_module TSRMLS_CC);
		}
		eval_int = phalcon_array_isset_string(parts, SS("controller"));
		if (eval_int) {
			PHALCON_INIT_VAR(controller);
			phalcon_array_fetch_string(&controller, parts, SL("controller"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_controller"), controller TSRMLS_CC);
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SS("controller"));
		} else {
			PHALCON_INIT_VAR(default_controller);
			phalcon_read_property(&default_controller, this_ptr, SL("_defaultController"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_controller"), default_controller TSRMLS_CC);
		}
	
		eval_int = phalcon_array_isset_string(parts, SS("action"));
		if (eval_int) {
			PHALCON_INIT_VAR(action);
			phalcon_array_fetch_string(&action, parts, SL("action"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_action"), action TSRMLS_CC);
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SS("action"));
		} else {
			PHALCON_INIT_VAR(default_action);
			phalcon_read_property(&default_action, this_ptr, SL("_defaultAction"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_action"), default_action TSRMLS_CC);
		}
	
		eval_int = phalcon_array_isset_string(parts, SS("params"));
		if (eval_int) {
			PHALCON_INIT_VAR(params_str);
			phalcon_array_fetch_string(&params_str, parts, SL("params"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(one);
			ZVAL_LONG(one, 1);
	
			PHALCON_INIT_VAR(str_params);
			PHALCON_CALL_FUNC_PARAMS_2(str_params, "substr", params_str, one);
			if (zend_is_true(str_params)) {
				PHALCON_INIT_VAR(slash);
				ZVAL_STRING(slash, "/", 1);
	
				PHALCON_INIT_NVAR(params);
				phalcon_fast_explode(params, slash, str_params TSRMLS_CC);
			}
	
			PHALCON_SEPARATE(parts);
			phalcon_array_unset_string(parts, SS("params"));
		}
	
		PHALCON_INIT_VAR(params_merge);
		PHALCON_CALL_FUNC_PARAMS_2(params_merge, "array_merge", params, parts);
		phalcon_update_property_zval(this_ptr, SL("_params"), params_merge TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_wasMatched"), 1 TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(default_module);
		phalcon_read_property(&default_module, this_ptr, SL("_defaultModule"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_module"), default_module TSRMLS_CC);
	
		PHALCON_INIT_NVAR(default_controller);
		phalcon_read_property(&default_controller, this_ptr, SL("_defaultController"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_controller"), default_controller TSRMLS_CC);
	
		PHALCON_INIT_NVAR(default_action);
		phalcon_read_property(&default_action, this_ptr, SL("_defaultAction"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_action"), default_action TSRMLS_CC);
	
		PHALCON_INIT_VAR(default_params);
		phalcon_read_property(&default_params, this_ptr, SL("_defaultParams"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_params"), default_params TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_wasMatched"), 0 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router, add){

	zval *pattern, *paths = NULL, *http_methods = NULL, *route;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|zz", &pattern, &paths, &http_methods) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	if (!http_methods) {
		PHALCON_INIT_NVAR(http_methods);
	}
	
	PHALCON_INIT_VAR(route);
	object_init_ex(route, phalcon_mvc_router_route_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(route, "__construct", pattern, paths, http_methods, PH_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_routes"), PH_NOISY_CC);
	phalcon_array_append(&t0, route, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_routes"), t0 TSRMLS_CC);
	
	RETURN_CTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addGet){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "GET", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addPost){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "POST", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addPut){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "PUT", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addDelete){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "DELETE", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addOptions){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "OPTIONS", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, addHead){

	zval *pattern, *paths = NULL, *method, *route;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &pattern, &paths) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!paths) {
		PHALCON_INIT_NVAR(paths);
	}
	
	PHALCON_INIT_VAR(method);
	ZVAL_STRING(method, "HEAD", 1);
	
	PHALCON_INIT_VAR(route);
	PHALCON_CALL_METHOD_PARAMS_3(route, this_ptr, "add", pattern, paths, method, PH_NO_CHECK);
	
	RETURN_CCTOR(route);
}

PHP_METHOD(Phalcon_Mvc_Router, clear){

	zval *empty_routes;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_routes);
	array_init(empty_routes);
	phalcon_update_property_zval(this_ptr, SL("_routes"), empty_routes TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Router, getModuleName){


	RETURN_MEMBER(this_ptr, "_module");
}

PHP_METHOD(Phalcon_Mvc_Router, getControllerName){


	RETURN_MEMBER(this_ptr, "_controller");
}

PHP_METHOD(Phalcon_Mvc_Router, getActionName){


	RETURN_MEMBER(this_ptr, "_action");
}

PHP_METHOD(Phalcon_Mvc_Router, getParams){


	RETURN_MEMBER(this_ptr, "_params");
}

PHP_METHOD(Phalcon_Mvc_Router, getMatchedRoute){


	RETURN_MEMBER(this_ptr, "_matchedRoute");
}

PHP_METHOD(Phalcon_Mvc_Router, getMatches){


	RETURN_MEMBER(this_ptr, "_matches");
}

PHP_METHOD(Phalcon_Mvc_Router, wasMatched){


	RETURN_MEMBER(this_ptr, "_wasMatched");
}

PHP_METHOD(Phalcon_Mvc_Router, getRoutes){


	RETURN_MEMBER(this_ptr, "_routes");
}

PHP_METHOD(Phalcon_Mvc_Router, getRouteById){

	zval *id, *routes, *route = NULL, *route_id = NULL, *is_equal = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &id) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(routes);
	phalcon_read_property(&routes, this_ptr, SL("_routes"), PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(routes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(routes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(route);
	
		PHALCON_INIT_NVAR(route_id);
		PHALCON_CALL_METHOD(route_id, route, "getrouteid", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_equal);
		is_equal_function(is_equal, route_id, id TSRMLS_CC);
		if (PHALCON_IS_TRUE(is_equal)) {
	
			RETURN_CCTOR(route);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Router, getRouteByName){

	zval *name, *routes, *route = NULL, *route_name = NULL, *is_equal = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(routes);
	phalcon_read_property(&routes, this_ptr, SL("_routes"), PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(routes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(routes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(route);
	
		PHALCON_INIT_NVAR(route_name);
		PHALCON_CALL_METHOD(route_name, route, "getname", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_equal);
		is_equal_function(is_equal, route_name, name TSRMLS_CC);
		if (PHALCON_IS_TRUE(is_equal)) {
	
			RETURN_CCTOR(route);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Application){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Application, mvc_application, "phalcon\\di\\injectable", phalcon_mvc_application_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_application_ce, SL("_modules"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_application_ce, SL("_moduleObject"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Application, registerModules){

	zval *modules;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &modules) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "Modules must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_modules"), modules TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Application, getModules){


	RETURN_MEMBER(this_ptr, "_modules");
}

PHP_METHOD(Phalcon_Mvc_Application, handle){

	zval *dependency_injector, *events_manager;
	zval *service = NULL, *router, *module_name, *event_name = NULL;
	zval *status = NULL, *modules, *exception_msg = NULL, *module;
	zval *path, *class_name = NULL, *module_object, *view;
	zval *controller_name = NULL, *action_name = NULL, *params = NULL;
	zval *dispatcher, *controller, *response, *content;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "A dependency injection object is required to access internal services");
		return;
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "router", 1);
	
	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD_PARAMS_1(router, dependency_injector, "getshared", service, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(router, "handle", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(module_name);
	PHALCON_CALL_METHOD(module_name, router, "getmodulename", PH_NO_CHECK);
	if (zend_is_true(module_name)) {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "application:beforeStartModule", 1);
	
			PHALCON_INIT_VAR(status);
			PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, module_name, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	
		PHALCON_INIT_VAR(modules);
		phalcon_read_property(&modules, this_ptr, SL("_modules"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(modules, module_name);
		if (!eval_int) {
			PHALCON_INIT_VAR(exception_msg);
			PHALCON_CONCAT_SVS(exception_msg, "Module '", module_name, "' isn't registered in the application container");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_application_exception_ce, exception_msg);
			return;
		}
	
		PHALCON_INIT_VAR(module);
		phalcon_array_fetch(&module, modules, module_name, PH_NOISY_CC);
		if (Z_TYPE_P(module) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "Invalid module definition path");
			return;
		}
	
		eval_int = phalcon_array_isset_string(module, SS("path"));
		if (eval_int) {
			PHALCON_INIT_VAR(path);
			phalcon_array_fetch_string(&path, module, SL("path"), PH_NOISY_CC);
			if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
				if (phalcon_require(path TSRMLS_CC) == FAILURE) {
					return;
				}
			} else {
				PHALCON_INIT_NVAR(exception_msg);
				PHALCON_CONCAT_SVS(exception_msg, "Module definition path '", path, "\" doesn't exists");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_application_exception_ce, exception_msg);
				return;
			}
		}
	
		eval_int = phalcon_array_isset_string(module, SS("className"));
		if (eval_int) {
			PHALCON_INIT_VAR(class_name);
			phalcon_array_fetch_string(&class_name, module, SL("className"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(class_name);
			ZVAL_STRING(class_name, "Module", 1);
		}
	
		PHALCON_INIT_VAR(module_object);
		PHALCON_CALL_METHOD_PARAMS_1(module_object, dependency_injector, "get", class_name, PH_NO_CHECK);
		PHALCON_CALL_METHOD_NORETURN(module_object, "registerautoloaders", PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(module_object, "registerservices", dependency_injector, PH_NO_CHECK);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			phalcon_update_property_zval(this_ptr, SL("_moduleObject"), module_object TSRMLS_CC);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "application:afterStartModule", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, module_name, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	
	PHALCON_INIT_NVAR(service);
	ZVAL_STRING(service, "view", 1);
	
	PHALCON_INIT_VAR(view);
	PHALCON_CALL_METHOD_PARAMS_1(view, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(controller_name);
	PHALCON_CALL_METHOD(controller_name, router, "getcontrollername", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(action_name);
	PHALCON_CALL_METHOD(action_name, router, "getactionname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(params);
	PHALCON_CALL_METHOD(params, router, "getparams", PH_NO_CHECK);
	
	PHALCON_INIT_NVAR(service);
	ZVAL_STRING(service, "dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	PHALCON_CALL_METHOD_PARAMS_1(dispatcher, dependency_injector, "getshared", service, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setcontrollername", controller_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setactionname", action_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setparams", params, PH_NO_CHECK);
	PHALCON_CALL_METHOD_NORETURN(view, "start", PH_NO_CHECK);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "application:beforeHandleRequest", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, dispatcher, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(controller);
	PHALCON_CALL_METHOD(controller, dispatcher, "dispatch", PH_NO_CHECK);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "application:afterHandleRequest", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, controller, PH_NO_CHECK);
	}
	
	if (Z_TYPE_P(controller) == IS_OBJECT) {
		PHALCON_INIT_NVAR(controller_name);
		PHALCON_CALL_METHOD(controller_name, dispatcher, "getcontrollername", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(action_name);
		PHALCON_CALL_METHOD(action_name, dispatcher, "getactionname", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(params);
		PHALCON_CALL_METHOD(params, dispatcher, "getparams", PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(view, "render", controller_name, action_name, params, PH_NO_CHECK);
	}
	
	PHALCON_CALL_METHOD_NORETURN(view, "finish", PH_NO_CHECK);
	
	PHALCON_INIT_NVAR(service);
	ZVAL_STRING(service, "response", 1);
	
	PHALCON_INIT_VAR(response);
	PHALCON_CALL_METHOD_PARAMS_1(response, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(content);
	PHALCON_CALL_METHOD(content, view, "getcontent", PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(response, "setcontent", content, PH_NO_CHECK);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "application:beforeSendResponse", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, response, PH_NO_CHECK);
	}
	
	PHALCON_CALL_METHOD_NORETURN(response, "sendheaders", PH_NO_CHECK);
	
	RETURN_CCTOR(response);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_DispatcherInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, DispatcherInterface, mvc_dispatcherinterface, phalcon_mvc_dispatcherinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, setControllerSuffix);

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, setDefaultController);

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, setControllerName);

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, getControllerName);

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, getLastController);

PHALCON_DOC_METHOD(Phalcon_Mvc_DispatcherInterface, getActiveController);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Collection){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Collection, mvc_collection, phalcon_mvc_collection_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_source"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_collection_ce, SL("_operationMade"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_collection_ce, SL("_connectionService"), "mongo", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_reserved"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_collection_ce, SL("_disableEvents"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_NONE"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_CREATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_UPDATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_DELETE"), 3 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_collection_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Collection, __construct){

	zval *dependency_injector = NULL, *service_name;
	zval *manager;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!dependency_injector) {
		PHALCON_INIT_NVAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(dependency_injector);
		PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
	}
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A dependency injector container is required to obtain the services related to the ODM");
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_INIT_VAR(service_name);
	ZVAL_STRING(service_name, "collectionManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(manager, "initialize", this_ptr, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Collection, setId){

	zval *id, *mongo_id = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &id) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(id) != IS_OBJECT) {
		ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		PHALCON_INIT_VAR(mongo_id);
		object_init_ex(mongo_id, ce0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(mongo_id, "__construct", id, PH_CHECK);
	} else {
		PHALCON_CPY_WRT(mongo_id, id);
	}
	phalcon_update_property_zval(this_ptr, SL("_id"), mongo_id TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Collection, getId){


	RETURN_MEMBER(this_ptr, "_id");
}

PHP_METHOD(Phalcon_Mvc_Collection, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Collection, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Collection, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Collection, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Mvc_Collection, getReservedAttributes){

	zval *reserved = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(reserved);
	phalcon_read_static_property(&reserved, SL("phalcon\\mvc\\collection"), SL("_reserved") TSRMLS_CC);
	if (Z_TYPE_P(reserved) == IS_NULL) {
		PHALCON_INIT_NVAR(reserved);
		array_init(reserved);
		add_assoc_bool_ex(reserved, SS("_connectionService"), 1);
		add_assoc_bool_ex(reserved, SS("_connection"), 1);
		add_assoc_bool_ex(reserved, SS("_dependencyInjector"), 1);
		add_assoc_bool_ex(reserved, SS("_eventsManager"), 1);
		add_assoc_bool_ex(reserved, SS("_source"), 1);
		add_assoc_bool_ex(reserved, SS("_operationMade"), 1);
		add_assoc_bool_ex(reserved, SS("_errorMessages"), 1);
		phalcon_update_static_property(SL("phalcon\\mvc\\collection"), SL("_reserved"), reserved TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(reserved);
}

PHP_METHOD(Phalcon_Mvc_Collection, setSource){

	zval *source;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &source) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Collection, getSource){

	zval *source = NULL, *class_name;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(source);
	phalcon_read_property(&source, this_ptr, SL("_source"), PH_NOISY_CC);
	if (!zend_is_true(source)) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, this_ptr TSRMLS_CC);
	
		PHALCON_INIT_NVAR(source);
		phalcon_uncamelize(source, class_name TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(source);
}

PHP_METHOD(Phalcon_Mvc_Collection, setConnectionService){

	zval *connection_service;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection_service) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_connectionService"), connection_service TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Collection, getConnection){

	zval *connection = NULL, *dependency_injector, *connection_service;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A dependency injector container is required to obtain the services related to the ODM");
			return;
		}
	
		PHALCON_INIT_VAR(connection_service);
		phalcon_read_property(&connection_service, this_ptr, SL("_connectionService"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(connection);
		PHALCON_CALL_METHOD_PARAMS_1(connection, dependency_injector, "getshared", connection_service, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(connection);
}

PHP_METHOD(Phalcon_Mvc_Collection, readAttribute){

	zval *attribute, *attribute_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attribute) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(attribute_value);
		phalcon_read_property_zval(&attribute_value, this_ptr, attribute, PH_NOISY_CC);
	
		RETURN_CCTOR(attribute_value);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Collection, writeAttribute){

	zval *attribute, *value;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &attribute, &value) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Collection, dumpResult){

	zval *collection, *document, *cloned_collection;
	zval *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &collection, &document) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(collection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid collection");
		return;
	}
	if (Z_TYPE_P(document) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid document");
		return;
	}
	
	PHALCON_INIT_VAR(cloned_collection);
	if (phalcon_clone(cloned_collection, collection TSRMLS_CC) == FAILURE) {
		return;
	}
	
	if (!phalcon_valid_foreach(document TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(document);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(cloned_collection, "writeattribute", key, value, PH_NO_CHECK);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CCTOR(cloned_collection);
}

PHP_METHOD(Phalcon_Mvc_Collection, _getResultset){

	zval *params, *collection, *connection, *unique;
	zval *source, *mongo_collection, *conditions = NULL;
	zval *documents_cursor, *limit, *sort = NULL, *document = NULL;
	zval *collection_cloned = NULL, *collections, *documents_array;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &params, &collection, &connection, &unique) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, collection, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(mongo_collection);
	PHALCON_CALL_METHOD_PARAMS_1(mongo_collection, connection, "selectcollection", source, PH_NO_CHECK);
	eval_int = phalcon_array_isset_long(params, 0);
	if (eval_int) {
		PHALCON_INIT_VAR(conditions);
		phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("conditions"));
		if (eval_int) {
			PHALCON_INIT_NVAR(conditions);
			phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(conditions);
			array_init(conditions);
		}
	}
	
	PHALCON_INIT_VAR(documents_cursor);
	PHALCON_CALL_METHOD_PARAMS_1(documents_cursor, mongo_collection, "find", conditions, PH_NO_CHECK);
	eval_int = phalcon_array_isset_string(params, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, params, SL("limit"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(documents_cursor, "limit", limit, PH_NO_CHECK);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("sort"));
	if (eval_int) {
		PHALCON_INIT_VAR(sort);
		phalcon_array_fetch_string(&sort, params, SL("sort"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(documents_cursor, "sort", sort, PH_NO_CHECK);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("skip"));
	if (eval_int) {
		PHALCON_INIT_NVAR(sort);
		phalcon_array_fetch_string(&sort, params, SL("skip"), PH_NOISY_CC);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(documents_cursor, "skip", sort, PH_NO_CHECK);
	}
	
	if (PHALCON_IS_TRUE(unique)) {
		PHALCON_CALL_METHOD_NORETURN(documents_cursor, "rewind", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(document);
		PHALCON_CALL_METHOD(document, documents_cursor, "current", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(collection_cloned);
		PHALCON_CALL_SELF_PARAMS_2(collection_cloned, this_ptr, "dumpresult", collection, document);
	
		RETURN_CCTOR(collection_cloned);
	}
	
	PHALCON_INIT_VAR(collections);
	array_init(collections);
	
	PHALCON_INIT_VAR(documents_array);
	PHALCON_CALL_FUNC_PARAMS_1(documents_array, "iterator_to_array", documents_cursor);
	
	if (!phalcon_valid_foreach(documents_array TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(documents_array);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(document);
	
		PHALCON_INIT_NVAR(collection_cloned);
		PHALCON_CALL_SELF_PARAMS_2(collection_cloned, this_ptr, "dumpresult", collection, document);
		phalcon_array_append(&collections, collection_cloned, PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(collections);
}

PHP_METHOD(Phalcon_Mvc_Collection, _preSave){

	zval *dependency_injector, *disable_events;
	zval *exists, *event_name = NULL, *status = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &dependency_injector, &disable_events, &exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeValidation", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnUpdate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "validation", 1);
	
	PHALCON_INIT_NVAR(status);
	PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	if (!zend_is_true(disable_events)) {
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnUpdate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterValidation", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "beforeSave", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeCreate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "validation", 1);
	
	PHALCON_INIT_NVAR(status);
	PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	if (!zend_is_true(disable_events)) {
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnUpdate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterValidation", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "beforeSave", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeCreate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Collection, _postSave){

	zval *disable_events, *success, *exists, *event_name = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &disable_events, &success, &exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (PHALCON_IS_TRUE(success)) {
		if (!zend_is_true(disable_events)) {
			if (PHALCON_IS_TRUE(exists)) {
				PHALCON_INIT_VAR(event_name);
				ZVAL_STRING(event_name, "afterUpdate", 1);
			} else {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "afterCreate", 1);
			}
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
	
		RETURN_CCTOR(success);
	} else {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "notSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_canceloperation", disable_events, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Collection, validate){

	zval *validator, *status, *messages, *message = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &validator) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(validator) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Validator must be an Object");
		return;
	}
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_1(status, validator, "validate", this_ptr, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_INIT_VAR(messages);
		PHALCON_CALL_METHOD(messages, validator, "getmessages", PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(messages TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(messages);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(message);
	
			PHALCON_INIT_NVAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
			phalcon_array_append(&t0, message, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t0 TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Collection, validationHasFailed){

	zval *error_messages;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(error_messages);
	phalcon_read_property(&error_messages, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	if (Z_TYPE_P(error_messages) == IS_ARRAY) { 
		if (phalcon_fast_count_ev(error_messages TSRMLS_CC)) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Collection, _callEvent){

	zval *event_name, *events_manager, *fire_event_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_method_exists(this_ptr, event_name TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, Z_STRVAL_P(event_name), PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "collection:", event_name);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", fire_event_name, this_ptr, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Collection, _callEventCancel){

	zval *event_name, *status = NULL, *events_manager, *fire_event_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_method_exists(this_ptr, event_name TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD(status, this_ptr, Z_STRVAL_P(event_name), PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "collection:", event_name);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", fire_event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Collection, _cancelOperation){

	zval *disable_events, *operation_made, *event_name = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &disable_events) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(operation_made);
		phalcon_read_property(&operation_made, this_ptr, SL("_operationMade"), PH_NOISY_CC);
		if (phalcon_compare_strict_long(operation_made, 3 TSRMLS_CC)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "notDeleted", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "notSaved", 1);
		}
	
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Collection, _exists){

	zval *collection, *id, *mongo_id = NULL, *parameters, *document_count;
	zval *zero, *exist;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &collection) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_isset_property(this_ptr, SS("_id") TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(id);
		phalcon_read_property(&id, this_ptr, SL("_id"), PH_NOISY_CC);
		if (Z_TYPE_P(id) == IS_OBJECT) {
			PHALCON_CPY_WRT(mongo_id, id);
		} else {
			ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_VAR(mongo_id);
			object_init_ex(mongo_id, ce0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(mongo_id, "__construct", id, PH_CHECK);
			phalcon_update_property_zval(this_ptr, SL("_id"), mongo_id TSRMLS_CC);
		}
	
		PHALCON_INIT_VAR(parameters);
		array_init(parameters);
		phalcon_array_update_string(&parameters, SL("_id"), &mongo_id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(document_count);
		PHALCON_CALL_METHOD_PARAMS_1(document_count, collection, "count", parameters, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(zero);
		ZVAL_LONG(zero, 0);
	
		PHALCON_INIT_VAR(exist);
		is_smaller_function(exist, zero, document_count TSRMLS_CC);
	
		RETURN_NCTOR(exist);
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Collection, save){

	zval *dependency_injector, *source, *connection;
	zval *collection, *exists, *empty_array, *disable_events = NULL;
	zval *status = NULL, *data, *reserved, *properties, *value = NULL;
	zval *key = NULL, *success = NULL, *options, *ok, *id, *post_success;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(collection);
	PHALCON_CALL_METHOD_PARAMS_1(collection, connection, "selectcollection", source, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_1(exists, this_ptr, "_exists", collection, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(exists)) {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 1 TSRMLS_CC);
	} else {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 2 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), empty_array TSRMLS_CC);
	PHALCON_OBSERVE_VAR(disable_events);
	phalcon_read_static_property(&disable_events, SL("phalcon\\mvc\\collection"), SL("_disableEvents") TSRMLS_CC);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_3(status, this_ptr, "_presave", dependency_injector, disable_events, exists, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	
	PHALCON_INIT_VAR(reserved);
	PHALCON_CALL_METHOD(reserved, this_ptr, "getreservedattributes", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(properties);
	PHALCON_CALL_FUNC_PARAMS_1(properties, "get_object_vars", this_ptr);
	
	if (!phalcon_valid_foreach(properties TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(properties);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(value);
	
		if (PHALCON_COMPARE_STRING(key, "_id")) {
			if (Z_TYPE_P(value) != IS_NULL) {
				phalcon_array_update_zval(&data, key, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
		} else {
			eval_int = phalcon_array_isset(reserved, key);
			if (!eval_int) {
				phalcon_array_update_zval(&data, key, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(success);
	ZVAL_BOOL(success, 0);
	
	PHALCON_INIT_VAR(options);
	array_init(options);
	add_assoc_bool_ex(options, SS("safe"), 1);
	
	PHALCON_INIT_NVAR(status);
	PHALCON_CALL_METHOD_PARAMS_2(status, collection, "save", data, options, PH_NO_CHECK);
	if (Z_TYPE_P(status) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(status, SS("ok"));
		if (eval_int) {
			PHALCON_INIT_VAR(ok);
			phalcon_array_fetch_string(&ok, status, SL("ok"), PH_NOISY_CC);
			if (zend_is_true(ok)) {
				ZVAL_BOOL(success, 1);
				if (PHALCON_IS_FALSE(exists)) {
					eval_int = phalcon_array_isset_string(data, SS("_id"));
					if (eval_int) {
						PHALCON_INIT_VAR(id);
						phalcon_array_fetch_string(&id, data, SL("_id"), PH_NOISY_CC);
						phalcon_update_property_zval(this_ptr, SL("_id"), id TSRMLS_CC);
					}
				}
			}
		}
	} else {
		ZVAL_BOOL(success, 0);
	}
	
	PHALCON_INIT_VAR(post_success);
	PHALCON_CALL_METHOD_PARAMS_3(post_success, this_ptr, "_postsave", disable_events, success, exists, PH_NO_CHECK);
	
	RETURN_CCTOR(post_success);
}

PHP_METHOD(Phalcon_Mvc_Collection, findById){

	zval *id, *mongo_id = NULL, *conditions, *parameters, *result;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &id) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(id) != IS_OBJECT) {
		ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
		PHALCON_INIT_VAR(mongo_id);
		object_init_ex(mongo_id, ce0);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(mongo_id, "__construct", id, PH_CHECK);
	} else {
		PHALCON_CPY_WRT(mongo_id, id);
	}
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	phalcon_array_update_string(&conditions, SL("_id"), &mongo_id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(parameters);
	array_init(parameters);
	phalcon_array_append(&parameters, conditions, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_SELF_PARAMS_1(result, this_ptr, "findfirst", parameters);
	
	RETURN_CCTOR(result);
}

PHP_METHOD(Phalcon_Mvc_Collection, findFirst){

	zval *parameters = NULL, *class_name, *collection, *connection;
	zval *unique, *resultset;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for findFirst");
			return;
		}
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	PHALCON_CALL_METHOD_NORETURN(collection, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, collection, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(unique);
	ZVAL_BOOL(unique, 1);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_SELF_PARAMS_4(resultset, this_ptr, "_getresultset", parameters, collection, connection, unique);
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Collection, find){

	zval *parameters = NULL, *class_name, *collection, *connection;
	zval *unique, *resultset;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for find");
			return;
		}
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	PHALCON_CALL_METHOD_NORETURN(collection, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, collection, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(unique);
	ZVAL_BOOL(unique, 0);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_SELF_PARAMS_4(resultset, this_ptr, "_getresultset", parameters, collection, connection, unique);
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Collection, count){

	zval *parameters = NULL, *class_name, *collection, *connection;
	zval *unique, *resultset;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for count");
			return;
		}
	}
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	PHALCON_CALL_METHOD_NORETURN(collection, "__construct", PH_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, collection, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(unique);
	ZVAL_BOOL(unique, 0);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_SELF_PARAMS_4(resultset, this_ptr, "_getresultset", parameters, collection, connection, unique);
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Collection, delete){

	zval *disable_events = NULL, *event_name = NULL, *status = NULL, *id;
	zval *connection, *source, *collection, *mongo_id = NULL;
	zval *id_condition, *success = NULL, *options, *ok;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	eval_int = phalcon_isset_property(this_ptr, SS("_id") TSRMLS_CC);
	if (eval_int) {
		PHALCON_OBSERVE_VAR(disable_events);
		phalcon_read_static_property(&disable_events, SL("phalcon\\mvc\\collection"), SL("_disableEvents") TSRMLS_CC);
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "beforeDelete", 1);
	
			PHALCON_INIT_VAR(status);
			PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	
		PHALCON_INIT_VAR(id);
		phalcon_read_property(&id, this_ptr, SL("_id"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(source);
		PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(collection);
		PHALCON_CALL_METHOD_PARAMS_1(collection, connection, "selectcollection", source, PH_NO_CHECK);
		if (Z_TYPE_P(id) == IS_OBJECT) {
			PHALCON_CPY_WRT(mongo_id, id);
		} else {
			ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_VAR(mongo_id);
			object_init_ex(mongo_id, ce0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(mongo_id, "__construct", id, PH_CHECK);
		}
	
		PHALCON_INIT_VAR(id_condition);
		array_init(id_condition);
		phalcon_array_update_string(&id_condition, SL("_id"), &mongo_id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(success);
		ZVAL_BOOL(success, 0);
	
		PHALCON_INIT_VAR(options);
		array_init(options);
		add_assoc_bool_ex(options, SS("safe"), 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, collection, "remove", id_condition, options, PH_NO_CHECK);
		if (Z_TYPE_P(status) == IS_ARRAY) { 
			eval_int = phalcon_array_isset_string(status, SS("ok"));
			if (eval_int) {
				PHALCON_INIT_VAR(ok);
				phalcon_array_fetch_string(&ok, status, SL("ok"), PH_NOISY_CC);
				if (zend_is_true(ok)) {
					ZVAL_BOOL(success, 1);
					if (!zend_is_true(disable_events)) {
						PHALCON_INIT_NVAR(event_name);
						ZVAL_STRING(event_name, "afterDelete", 1);
						PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
					}
				}
			}
		} else {
			ZVAL_BOOL(success, 0);
		}
	
	
		RETURN_NCTOR(success);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "The document cannot be deleted because it doesn't exist");
	return;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Dispatcher_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Dispatcher, Exception, mvc_dispatcher_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Micro, Exception, mvc_micro_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Model){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Model, mvc_model, phalcon_mvc_model_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_uniqueKey"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_schema"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_source"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_ce, SL("_operationMade"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_ce, SL("_forceExists"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_model_ce, SL("_connectionService"), "db", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_ce, SL("_disableEvents"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_NONE"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_CREATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_UPDATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_DELETE"), 3 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_ce TSRMLS_CC, 4, phalcon_mvc_modelinterface_ce, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce, zend_ce_serializable);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Model, __construct){

	zval *dependency_injector = NULL, *manager_service = NULL;
	zval *db_service = NULL, *service_name, *manager;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zzz", &dependency_injector, &manager_service, &db_service) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!dependency_injector) {
		PHALCON_INIT_NVAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	if (!manager_service) {
		PHALCON_INIT_NVAR(manager_service);
	}
	
	if (!db_service) {
		PHALCON_INIT_NVAR(db_service);
	}
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(dependency_injector);
		PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
	}
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_INIT_VAR(service_name);
	ZVAL_STRING(service_name, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(manager, "initialize", this_ptr, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Mvc_Model, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Mvc_Model, _createSQLSelect){

	zval *dependency_injector, *model, *connection;
	zval *params, *service_name, *meta_data, *source;
	zval *schema, *select, *bound_params = NULL, *bind_types = NULL;
	zval *attributes, *table, *conditions = NULL, *no_primary = NULL;
	zval *primary_keys, *first_primary_key, *primary_key_condition;
	zval *bind_params, *converted_params, *converted_sql;
	zval *group_clause, *order_clause, *limit_clause;
	zval *for_update, *shared_lock, *dialect, *sql;
	zval *statement;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &dependency_injector, &model, &connection, &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(service_name);
	ZVAL_STRING(service_name, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service_name, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(select);
	array_init(select);
	
	PHALCON_INIT_VAR(bound_params);
	
	PHALCON_INIT_VAR(bind_types);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", model, PH_NO_CHECK);
	phalcon_array_update_string(&select, SL("columns"), &attributes, PH_COPY | PH_SEPARATE TSRMLS_CC);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
		phalcon_array_update_string(&select, SL("tables"), &table, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		phalcon_array_update_string(&select, SL("tables"), &source, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(conditions);
	eval_int = phalcon_array_isset_string(params, SS("conditions"));
	if (eval_int) {
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(no_primary);
			ZVAL_BOOL(no_primary, 0);
	
			PHALCON_INIT_NVAR(conditions);
			phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY_CC);
			if (Z_TYPE_P(conditions) == IS_LONG) {
				PHALCON_INIT_VAR(primary_keys);
				PHALCON_CALL_METHOD_PARAMS_1(primary_keys, meta_data, "getprimarykeyattributes", model, PH_NO_CHECK);
				eval_int = phalcon_array_isset_long(primary_keys, 0);
				if (eval_int) {
					PHALCON_INIT_VAR(first_primary_key);
					phalcon_array_fetch_long(&first_primary_key, primary_keys, 0, PH_NOISY_CC);
	
					PHALCON_INIT_VAR(primary_key_condition);
					PHALCON_CONCAT_VSV(primary_key_condition, first_primary_key, " = ", conditions);
					PHALCON_CPY_WRT(conditions, primary_key_condition);
				} else {
					ZVAL_BOOL(no_primary, 1);
				}
	
				if (PHALCON_IS_TRUE(no_primary)) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Source related to this model does not have a primary key defined");
					return;
				}
			}
		}
	}
	
	if (zend_is_true(conditions)) {
		eval_int = phalcon_array_isset_string(params, SS("bind"));
		if (eval_int) {
			PHALCON_INIT_VAR(bind_params);
			phalcon_array_fetch_string(&bind_params, params, SL("bind"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(converted_params);
			PHALCON_CALL_METHOD_PARAMS_2(converted_params, connection, "convertboundparams", conditions, bind_params, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(converted_sql);
			phalcon_array_fetch_string(&converted_sql, converted_params, SL("sql"), PH_NOISY_CC);
			phalcon_array_update_string(&select, SL("where"), &converted_sql, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			phalcon_array_fetch_string(&bound_params, converted_params, SL("params"), PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(params, SS("bindTypes"));
			if (eval_int) {
				phalcon_array_fetch_string(&bind_types, params, SL("bindTypes"), PH_NOISY_CC);
			}
		} else {
			phalcon_array_update_string(&select, SL("where"), &conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("group"));
	if (eval_int) {
		PHALCON_INIT_VAR(group_clause);
		phalcon_array_fetch_string(&group_clause, params, SL("group"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("group"), &group_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("order"));
	if (eval_int) {
		PHALCON_INIT_VAR(order_clause);
		phalcon_array_fetch_string(&order_clause, params, SL("order"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("order"), &order_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit_clause);
		phalcon_array_fetch_string(&limit_clause, params, SL("limit"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("limit"), &limit_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("for_update"));
	if (eval_int) {
		PHALCON_INIT_VAR(for_update);
		phalcon_array_fetch_string(&for_update, params, SL("for_update"), PH_NOISY_CC);
		if (zend_is_true(for_update)) {
			phalcon_array_update_string_bool(&select, SL("for_update"), 1, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("shared_lock"));
	if (eval_int) {
		PHALCON_INIT_VAR(shared_lock);
		phalcon_array_fetch_string(&shared_lock, params, SL("shared_lock"), PH_NOISY_CC);
		if (zend_is_true(shared_lock)) {
			phalcon_array_update_string_bool(&select, SL("shared_lock"), 1, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(dialect);
	PHALCON_CALL_METHOD(dialect, connection, "getdialect", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_1(sql, dialect, "select", select, PH_NO_CHECK);
	if (Z_TYPE_P(bound_params) != IS_NULL) {
		PHALCON_INIT_VAR(statement);
		array_init(statement);
		phalcon_array_update_string(&statement, SL("sql"), &sql, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&statement, SL("params"), &bound_params, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&statement, SL("types"), &bind_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		RETURN_CTOR(statement);
	}
	
	
	RETURN_CCTOR(sql);
}

PHP_METHOD(Phalcon_Mvc_Model, _getOrCreateResultset){

	zval *model_name, *params, *unique, *dependency_injector = NULL;
	zval *cache = NULL, *cache_options, *key, *lifetime = NULL, *cache_service = NULL;
	zval *model, *connection, *resultset = NULL, *is_fresh;
	zval *bind_params = NULL, *bind_types = NULL, *select, *sql = NULL, *result;
	zval *count, *fetch_assoc, *row, *fetch_both, *dumped_result;
	zval *result_data = NULL;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &model_name, &params, &unique) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_array_isset_string(params, SS("di"));
	if (eval_int) {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_array_fetch_string(&dependency_injector, params, SL("di"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(dependency_injector);
		PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
	}
	
	PHALCON_INIT_VAR(cache);
	eval_int = phalcon_array_isset_string(params, SS("cache"));
	if (eval_int) {
		PHALCON_INIT_VAR(cache_options);
		phalcon_array_fetch_string(&cache_options, params, SL("cache"), PH_NOISY_CC);
		if (Z_TYPE_P(cache_options) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid caching options");
			return;
		}
	
		eval_int = phalcon_array_isset_string(cache_options, SS("key"));
		if (eval_int) {
			PHALCON_INIT_VAR(key);
			phalcon_array_fetch_string(&key, cache_options, SL("key"), PH_NOISY_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A cache key must be provided to identify the cached resultset in the cache backend");
			return;
		}
	
		eval_int = phalcon_array_isset_string(cache_options, SS("lifetime"));
		if (eval_int) {
			PHALCON_INIT_VAR(lifetime);
			phalcon_array_fetch_string(&lifetime, cache_options, SL("lifetime"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(lifetime);
			ZVAL_LONG(lifetime, 3600);
		}
	
		eval_int = phalcon_array_isset_string(cache_options, SS("service"));
		if (eval_int) {
			PHALCON_INIT_VAR(cache_service);
			phalcon_array_fetch_string(&cache_service, cache_options, SL("service"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(cache_service);
			ZVAL_STRING(cache_service, "modelsCache", 1);
		}
	
		PHALCON_CALL_METHOD_PARAMS_1(cache, dependency_injector, "getshared", cache_service, PH_NO_CHECK);
	}
	
	ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(model);
	object_init_ex(model, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "__construct", dependency_injector, PH_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
	if (Z_TYPE_P(cache) != IS_NULL) {
		PHALCON_INIT_VAR(resultset);
		PHALCON_CALL_METHOD_PARAMS_2(resultset, cache, "get", key, lifetime, PH_NO_CHECK);
		if (Z_TYPE_P(resultset) != IS_NULL) {
			if (Z_TYPE_P(resultset) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The cache didn't return a valid resultset");
				return;
			}
	
			PHALCON_INIT_VAR(is_fresh);
			ZVAL_BOOL(is_fresh, 0);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(resultset, "setisfresh", is_fresh, PH_NO_CHECK);
	
			RETURN_CCTOR(resultset);
		}
	}
	
	PHALCON_INIT_VAR(bind_params);
	
	PHALCON_INIT_VAR(bind_types);
	
	PHALCON_INIT_VAR(select);
	PHALCON_CALL_SELF_PARAMS_4(select, this_ptr, "_createsqlselect", dependency_injector, model, connection, params);
	if (Z_TYPE_P(select) == IS_ARRAY) { 
		PHALCON_INIT_VAR(sql);
		phalcon_array_fetch_string(&sql, select, SL("sql"), PH_NOISY_CC);
	
		phalcon_array_fetch_string(&bind_params, select, SL("params"), PH_NOISY_CC);
	
		phalcon_array_fetch_string(&bind_types, select, SL("types"), PH_NOISY_CC);
	} else {
		PHALCON_CPY_WRT(sql, select);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_3(result, connection, "query", sql, bind_params, bind_types, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(count);
	PHALCON_CALL_METHOD_PARAMS_1(count, result, "numrows", result, PH_NO_CHECK);
	if (PHALCON_IS_TRUE(unique)) {
		if (!zend_is_true(count)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		} else {
			PHALCON_INIT_VAR(fetch_assoc);
			ZVAL_LONG(fetch_assoc, 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_assoc, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(row);
			PHALCON_CALL_METHOD_PARAMS_1(row, result, "fetcharray", result, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(fetch_both);
			ZVAL_LONG(fetch_both, 2);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(result, "setfetchmode", fetch_both, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(dumped_result);
			PHALCON_CALL_SELF_PARAMS_2(dumped_result, this_ptr, "dumpresult", model, row);
	
			RETURN_CCTOR(dumped_result);
		}
	}
	
	if (zend_is_true(count)) {
		PHALCON_CPY_WRT(result_data, result);
	} else {
		PHALCON_INIT_VAR(result_data);
		ZVAL_BOOL(result_data, 0);
	}
	
	PHALCON_INIT_NVAR(resultset);
	object_init_ex(resultset, phalcon_mvc_model_resultset_simple_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(resultset, "__construct", model, result_data, cache, PH_CHECK);
	if (Z_TYPE_P(cache) != IS_NULL) {
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(cache, "save", key, resultset, lifetime, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Model, setTransaction){

	zval *transaction, *connection;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &transaction) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(transaction) == IS_OBJECT) {
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, transaction, "getconnection", PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Transaction should be an object");
		return;
	}
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model, setSource){

	zval *source;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &source) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model, getSource){

	zval *source = NULL, *class_name;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(source);
	phalcon_read_property(&source, this_ptr, SL("_source"), PH_NOISY_CC);
	if (!zend_is_true(source)) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, this_ptr TSRMLS_CC);
	
		PHALCON_INIT_NVAR(source);
		phalcon_uncamelize(source, class_name TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_source"), source TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(source);
}

PHP_METHOD(Phalcon_Mvc_Model, setSchema){

	zval *schema;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &schema) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_schema"), schema TSRMLS_CC);
	
	RETURN_CTORW(this_ptr);
}

PHP_METHOD(Phalcon_Mvc_Model, getSchema){


	RETURN_MEMBER(this_ptr, "_schema");
}

PHP_METHOD(Phalcon_Mvc_Model, setConnectionService){

	zval *connection_service;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &connection_service) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_connectionService"), connection_service TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model, getConnectionService){


	RETURN_MEMBER(this_ptr, "_connectionService");
}

PHP_METHOD(Phalcon_Mvc_Model, setForceExists){

	zval *force_exists, *force_exists_bool = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &force_exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(force_exists);
	
	PHALCON_INIT_VAR(r0);
	phalcon_cast(r0, force_exists, IS_BOOL);
	PHALCON_CPY_WRT(force_exists_bool, r0);
	phalcon_update_property_zval(this_ptr, SL("_forceExists"), force_exists TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, getConnection){

	zval *connection = NULL, *connection_service, *dependency_injector;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY_CC);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_INIT_VAR(connection_service);
		phalcon_read_property(&connection_service, this_ptr, SL("_connectionService"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(connection);
		PHALCON_CALL_METHOD_PARAMS_1(connection, dependency_injector, "getshared", connection_service, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("_connection"), connection TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(connection);
}

PHP_METHOD(Phalcon_Mvc_Model, dumpResult){

	zval *base, *result, *object, *force_exists, *value = NULL;
	zval *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &base, &result) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(result) == IS_ARRAY) { 
		PHALCON_INIT_VAR(object);
		if (phalcon_clone(object, base TSRMLS_CC) == FAILURE) {
			return;
		}
	
		PHALCON_INIT_VAR(force_exists);
		ZVAL_BOOL(force_exists, 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "setforceexists", force_exists, PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(result TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(result);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(value);
	
			phalcon_update_property_zval_zval(object, key, value TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
	
		RETURN_CCTOR(object);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data to dump in the object must be an Array");
	return;
}

PHP_METHOD(Phalcon_Mvc_Model, find){

	zval *parameters = NULL, *model_name, *params = NULL, *one_row;
	zval *resultset;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(model_name);
	PHALCON_CALL_FUNC(model_name, "get_called_class");
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(one_row);
	ZVAL_BOOL(one_row, 0);
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_SELF_PARAMS_3(resultset, this_ptr, "_getorcreateresultset", model_name, params, one_row);
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Model, findFirst){

	zval *parameters = NULL, *model_name, *params = NULL, *one_row;
	zval *model;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(model_name);
	PHALCON_CALL_FUNC(model_name, "get_called_class");
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("limit"));
	if (!eval_int) {
		phalcon_array_update_string_string(&params, SL("limit"), SL("1"), PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(one_row);
	ZVAL_BOOL(one_row, 1);
	
	PHALCON_INIT_VAR(model);
	PHALCON_CALL_SELF_PARAMS_3(model, this_ptr, "_getorcreateresultset", model_name, params, one_row);
	
	RETURN_CCTOR(model);
}

PHP_METHOD(Phalcon_Mvc_Model, query){

	zval *dependency_injector = NULL, *model_name, *criteria;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!dependency_injector) {
		PHALCON_INIT_NVAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	PHALCON_INIT_VAR(model_name);
	PHALCON_CALL_FUNC(model_name, "get_called_class");
	if (Z_TYPE_P(dependency_injector) == IS_NULL) {
		PHALCON_INIT_NVAR(dependency_injector);
		PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
	}
	
	PHALCON_INIT_VAR(criteria);
	object_init_ex(criteria, phalcon_mvc_model_criteria_ce);
	PHALCON_CALL_METHOD_NORETURN(criteria, "__construct", PH_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(criteria, "setdi", dependency_injector, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(criteria, "setmodelname", model_name, PH_NO_CHECK);
	
	RETURN_CTOR(criteria);
}

PHP_METHOD(Phalcon_Mvc_Model, _exists){

	zval *meta_data, *connection = NULL, *table = NULL, *unique_key = NULL;
	zval *primary_keys, *where_pk, *field = NULL, *value = NULL, *sanitized_value = NULL;
	zval *pk_condition = NULL, *join_where, *force_exists;
	zval *schema, *source, *select, *num, *row_count;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &meta_data, &connection, &table) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(connection);
	
	if (!table) {
		PHALCON_INIT_NVAR(table);
	} else {
		PHALCON_SEPARATE_PARAM(table);
	}
	
	PHALCON_INIT_VAR(unique_key);
	phalcon_read_property(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY_CC);
	if (Z_TYPE_P(unique_key) == IS_NULL) {
		PHALCON_INIT_VAR(primary_keys);
		PHALCON_CALL_METHOD_PARAMS_1(primary_keys, meta_data, "getprimarykeyattributes", this_ptr, PH_NO_CHECK);
		if (phalcon_fast_count_ev(primary_keys TSRMLS_CC)) {
			PHALCON_INIT_VAR(where_pk);
			array_init(where_pk);
	
			PHALCON_INIT_NVAR(connection);
			PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
			if (!phalcon_valid_foreach(primary_keys TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(primary_keys);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_VALUE(field);
	
				eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
				if (eval_int) {
					PHALCON_INIT_NVAR(value);
					phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
					if (PHALCON_IS_NOT_EMPTY(value)) {
						if (Z_TYPE_P(value) != IS_LONG) {
							PHALCON_INIT_NVAR(sanitized_value);
							PHALCON_CALL_METHOD_PARAMS_1(sanitized_value, connection, "escapestring", value, PH_NO_CHECK);
						} else {
							PHALCON_CPY_WRT(sanitized_value, value);
						}
	
						PHALCON_INIT_NVAR(pk_condition);
						PHALCON_CONCAT_VSV(pk_condition, field, " = ", sanitized_value);
						phalcon_array_append(&where_pk, pk_condition, PH_SEPARATE TSRMLS_CC);
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
	
			if (phalcon_fast_count_ev(where_pk TSRMLS_CC)) {
				PHALCON_INIT_VAR(join_where);
				phalcon_fast_join_str(join_where, SL(" AND "), where_pk TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_uniqueKey"), join_where TSRMLS_CC);
				PHALCON_CPY_WRT(unique_key, join_where);
			} else {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		} else {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(force_exists);
	phalcon_read_property(&force_exists, this_ptr, SL("_forceExists"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(force_exists)) {
		if (Z_TYPE_P(table) == IS_NULL) {
			PHALCON_INIT_VAR(schema);
			PHALCON_CALL_METHOD(schema, this_ptr, "getschema", PH_NO_CHECK);
	
			PHALCON_INIT_VAR(source);
			PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
			if (zend_is_true(schema)) {
				PHALCON_INIT_NVAR(table);
				PHALCON_CONCAT_VSV(table, schema, ".", source);
			} else {
				PHALCON_CPY_WRT(table, source);
			}
		}
	
		PHALCON_INIT_VAR(select);
		PHALCON_CONCAT_SVSV(select, "SELECT COUNT(*) AS rowcount FROM ", table, " WHERE ", unique_key);
	
		PHALCON_INIT_VAR(num);
		PHALCON_CALL_METHOD_PARAMS_1(num, connection, "fetchone", select, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(row_count);
		phalcon_array_fetch_string(&row_count, num, SL("rowcount"), PH_NOISY_CC);
		if (zend_is_true(row_count)) {
			phalcon_update_property_bool(this_ptr, SL("_forceExists"), 1 TSRMLS_CC);
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		} else {
			phalcon_update_property_bool(this_ptr, SL("_forceExists"), 0 TSRMLS_CC);
		}
	} else {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model, _prepareGroupResult){

	zval *function, *alias, *parameters, *params = NULL, *group_column = NULL;
	zval *dependency_injector, *class_name, *model;
	zval *connection, *schema, *source, *table = NULL, *bound_params = NULL;
	zval *bind_types = NULL, *select, *distinct_column;
	zval *columns = NULL, *group_columns, *conditions = NULL, *bind_params;
	zval *converted_params, *converted_sql, *group_clause;
	zval *having_clause, *order_clause, *limit_clause;
	zval *dialect, *sql, *statement = NULL, *resultset;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &function, &alias, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		if (Z_TYPE_P(parameters) != IS_NULL) {
			PHALCON_INIT_VAR(params);
			array_init(params);
			phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(params);
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	eval_int = phalcon_array_isset_string(params, SS("column"));
	if (eval_int) {
		PHALCON_INIT_VAR(group_column);
		phalcon_array_fetch_string(&group_column, params, SL("column"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(group_column);
		ZVAL_STRING(group_column, "*", 1);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	PHALCON_CALL_STATIC(dependency_injector, "phalcon\\di", "getdefault");
	
	PHALCON_INIT_VAR(class_name);
	PHALCON_CALL_FUNC(class_name, "get_called_class");
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(model);
	object_init_ex(model, ce0);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(model, "__construct", dependency_injector, PH_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, model, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, model, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, model, "getsource", PH_NO_CHECK);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_INIT_VAR(bound_params);
	
	PHALCON_INIT_VAR(bind_types);
	
	PHALCON_INIT_VAR(select);
	array_init(select);
	phalcon_array_update_string(&select, SL("tables"), &table, PH_COPY | PH_SEPARATE TSRMLS_CC);
	eval_int = phalcon_array_isset_string(params, SS("distinct"));
	if (eval_int) {
		PHALCON_INIT_VAR(distinct_column);
		phalcon_array_fetch_string(&distinct_column, params, SL("distinct"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(columns);
		PHALCON_CONCAT_VSVSV(columns, function, "(DISTINCT ", distinct_column, ") AS ", alias);
	} else {
		eval_int = phalcon_array_isset_string(params, SS("group"));
		if (eval_int) {
			PHALCON_INIT_VAR(group_columns);
			phalcon_array_fetch_string(&group_columns, params, SL("group"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(columns);
			PHALCON_CONCAT_VSVSVSV(columns, group_columns, ", ", function, "(", group_column, ") AS ", alias);
		} else {
			PHALCON_INIT_NVAR(columns);
			PHALCON_CONCAT_VSVSV(columns, function, "(", group_column, ") AS ", alias);
		}
	}
	
	phalcon_array_update_string(&select, SL("columns"), &columns, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	eval_int = phalcon_array_isset_string(params, SS("conditions"));
	if (eval_int) {
		phalcon_array_fetch_string(&conditions, params, SL("conditions"), PH_NOISY_CC);
	} else {
		eval_int = phalcon_array_isset_long(params, 0);
		if (eval_int) {
			PHALCON_INIT_NVAR(conditions);
			phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY_CC);
		}
	}
	
	if (zend_is_true(conditions)) {
		eval_int = phalcon_array_isset_string(params, SS("bind"));
		if (eval_int) {
			PHALCON_INIT_VAR(bind_params);
			phalcon_array_fetch_string(&bind_params, params, SL("bind"), PH_NOISY_CC);
	
			PHALCON_INIT_VAR(converted_params);
			PHALCON_CALL_METHOD_PARAMS_2(converted_params, connection, "convertboundparams", conditions, bind_params, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(converted_sql);
			phalcon_array_fetch_string(&converted_sql, converted_params, SL("sql"), PH_NOISY_CC);
			phalcon_array_update_string(&select, SL("where"), &converted_sql, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
			phalcon_array_fetch_string(&bound_params, converted_params, SL("params"), PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(params, SS("bindTypes"));
			if (eval_int) {
				phalcon_array_fetch_string(&bind_types, params, SL("bindTypes"), PH_NOISY_CC);
			}
		} else {
			phalcon_array_update_string(&select, SL("where"), &conditions, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("group"));
	if (eval_int) {
		PHALCON_INIT_VAR(group_clause);
		phalcon_array_fetch_string(&group_clause, params, SL("group"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("group"), &group_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("having"));
	if (eval_int) {
		PHALCON_INIT_VAR(having_clause);
		phalcon_array_fetch_string(&having_clause, params, SL("having"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("having"), &having_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("order"));
	if (eval_int) {
		PHALCON_INIT_VAR(order_clause);
		phalcon_array_fetch_string(&order_clause, params, SL("order"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("order"), &order_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit_clause);
		phalcon_array_fetch_string(&limit_clause, params, SL("limit"), PH_NOISY_CC);
		phalcon_array_update_string(&select, SL("limit"), &limit_clause, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(dialect);
	PHALCON_CALL_METHOD(dialect, connection, "getdialect", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CALL_METHOD_PARAMS_1(sql, dialect, "select", select, PH_NO_CHECK);
	if (Z_TYPE_P(bound_params) != IS_NULL) {
		PHALCON_INIT_VAR(statement);
		array_init(statement);
		phalcon_array_update_string(&statement, SL("sql"), &sql, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&statement, SL("params"), &bound_params, PH_COPY | PH_SEPARATE TSRMLS_CC);
		phalcon_array_update_string(&statement, SL("types"), &bind_types, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(statement, sql);
	}
	
	PHALCON_INIT_VAR(resultset);
	PHALCON_CALL_SELF_PARAMS_4(resultset, this_ptr, "_getgroupresult", connection, params, statement, alias);
	
	RETURN_CCTOR(resultset);
}

PHP_METHOD(Phalcon_Mvc_Model, _getGroupResult){

	zval *connection, *params, *select, *alias, *sql = NULL, *bind_params = NULL;
	zval *bind_types = NULL, *result = NULL, *count, *row_object = NULL;
	zval *cache, *resultset, *num, *group_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &connection, &params, &select, &alias) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(select) == IS_ARRAY) { 
		PHALCON_INIT_VAR(sql);
		phalcon_array_fetch_string(&sql, select, SL("sql"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(bind_params);
		phalcon_array_fetch_string(&bind_params, select, SL("params"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(bind_types);
		phalcon_array_fetch_string(&bind_types, select, SL("types"), PH_NOISY_CC);
	} else {
		PHALCON_CPY_WRT(sql, select);
	
		PHALCON_INIT_NVAR(bind_params);
	
		PHALCON_INIT_NVAR(bind_types);
	}
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_METHOD_PARAMS_3(result, connection, "query", sql, bind_params, bind_types, PH_NO_CHECK);
	eval_int = phalcon_array_isset_string(params, SS("group"));
	if (eval_int) {
		PHALCON_INIT_VAR(count);
		PHALCON_CALL_METHOD(count, result, "numrows", PH_NO_CHECK);
		if (zend_is_true(count)) {
			PHALCON_INIT_VAR(row_object);
			object_init_ex(row_object, phalcon_mvc_model_row_ce);
		} else {
			PHALCON_INIT_NVAR(row_object);
			object_init(row_object);
	
			PHALCON_INIT_NVAR(result);
			ZVAL_BOOL(result, 0);
		}
	
		PHALCON_INIT_VAR(cache);
	
		PHALCON_INIT_VAR(resultset);
		object_init_ex(resultset, phalcon_mvc_model_resultset_simple_ce);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(resultset, "__construct", row_object, result, cache, PH_CHECK);
	
		RETURN_CTOR(resultset);
	}
	
	PHALCON_INIT_VAR(num);
	PHALCON_CALL_METHOD(num, result, "fetcharray", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(group_value);
	phalcon_array_fetch(&group_value, num, alias, PH_NOISY_CC);
	
	RETURN_CCTOR(group_value);
}

PHP_METHOD(Phalcon_Mvc_Model, count){

	zval *parameters = NULL, *function, *alias, *group;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "COUNT", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "rowcount", 1);
	
	PHALCON_INIT_VAR(group);
	PHALCON_CALL_SELF_PARAMS_3(group, this_ptr, "_preparegroupresult", function, alias, parameters);
	
	RETURN_CCTOR(group);
}

PHP_METHOD(Phalcon_Mvc_Model, sum){

	zval *parameters = NULL, *function, *alias, *group;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "SUM", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "sumatory", 1);
	
	PHALCON_INIT_VAR(group);
	PHALCON_CALL_SELF_PARAMS_3(group, this_ptr, "_preparegroupresult", function, alias, parameters);
	
	RETURN_CCTOR(group);
}

PHP_METHOD(Phalcon_Mvc_Model, maximum){

	zval *parameters = NULL, *function, *alias, *group;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "MAX", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "maximum", 1);
	
	PHALCON_INIT_VAR(group);
	PHALCON_CALL_SELF_PARAMS_3(group, this_ptr, "_preparegroupresult", function, alias, parameters);
	
	RETURN_CCTOR(group);
}

PHP_METHOD(Phalcon_Mvc_Model, minimum){

	zval *parameters = NULL, *function, *alias, *group;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "MIN", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "minimum", 1);
	
	PHALCON_INIT_VAR(group);
	PHALCON_CALL_SELF_PARAMS_3(group, this_ptr, "_preparegroupresult", function, alias, parameters);
	
	RETURN_CCTOR(group);
}

PHP_METHOD(Phalcon_Mvc_Model, average){

	zval *parameters = NULL, *function, *alias, *group;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "AVG", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "average", 1);
	
	PHALCON_INIT_VAR(group);
	PHALCON_CALL_SELF_PARAMS_3(group, this_ptr, "_preparegroupresult", function, alias, parameters);
	
	RETURN_CCTOR(group);
}

PHP_METHOD(Phalcon_Mvc_Model, _callEvent){

	zval *event_name, *events_manager, *fire_event_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_method_exists(this_ptr, event_name TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, Z_STRVAL_P(event_name), PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "model:", event_name);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", fire_event_name, this_ptr, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, _callEventCancel){

	zval *event_name, *status = NULL, *events_manager, *fire_event_name;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &event_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (phalcon_method_exists(this_ptr, event_name TSRMLS_CC) == SUCCESS) {
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD(status, this_ptr, Z_STRVAL_P(event_name), PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "model:", event_name);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", fire_event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Model, _cancelOperation){

	zval *disable_events, *operation_made, *event_name = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &disable_events) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(operation_made);
		phalcon_read_property(&operation_made, this_ptr, SL("_operationMade"), PH_NOISY_CC);
		if (phalcon_compare_strict_long(operation_made, 3 TSRMLS_CC)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "notDeleted", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "notSaved", 1);
		}
	
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
	}
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model, appendMessage){

	zval *message, *type, *exception_message;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(message) != IS_OBJECT) {
		PHALCON_INIT_VAR(type);
		PHALCON_CALL_FUNC_PARAMS_1(type, "gettype", message);
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid message format '", type, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	phalcon_array_append(&t0, message, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, validate){

	zval *validator, *status, *messages, *message = NULL;
	zval *t0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &validator) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(validator) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Validator must be an Object");
		return;
	}
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_1(status, validator, "validate", this_ptr, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_INIT_VAR(messages);
		PHALCON_CALL_METHOD(messages, validator, "getmessages", PH_NO_CHECK);
	
		if (!phalcon_valid_foreach(messages TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(messages);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(message);
	
			PHALCON_INIT_NVAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
			phalcon_array_append(&t0, message, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t0 TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, validationHasFailed){

	zval *error_messages;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(error_messages);
	phalcon_read_property(&error_messages, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
	if (Z_TYPE_P(error_messages) == IS_ARRAY) { 
		if (phalcon_fast_count_ev(error_messages TSRMLS_CC)) {
			PHALCON_MM_RESTORE();
			RETURN_TRUE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Mvc_Model, getMessages){


	RETURN_MEMBER(this_ptr, "_errorMessages");
}

PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeys){

	zval *dependency_injector, *disable_events;
	zval *service, *manager, *belongs_to, *error = NULL, *relation = NULL;
	zval *options = NULL, *foreign_key = NULL, *conditions = NULL, *relation_class = NULL;
	zval *referenced_model = NULL, *fields = NULL, *referenced_fields = NULL;
	zval *field = NULL, *n = NULL, *value = NULL, *referenced_field = NULL, *condition = NULL;
	zval *extra_conditions = NULL, *connection_service = NULL;
	zval *join_conditions = NULL, *rowcount = NULL, *user_message = NULL;
	zval *joined_fields = NULL, *type = NULL, *message = NULL, *event_name;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &dependency_injector, &disable_events) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(belongs_to);
	PHALCON_CALL_METHOD_PARAMS_1(belongs_to, manager, "getbelongsto", this_ptr, PH_NO_CHECK);
	if (phalcon_fast_count_ev(belongs_to TSRMLS_CC)) {
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
	
		if (!phalcon_valid_foreach(belongs_to TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(belongs_to);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(relation);
	
			eval_int = phalcon_array_isset_string(relation, SS("op"));
			if (eval_int) {
				PHALCON_INIT_NVAR(options);
				phalcon_array_fetch_string(&options, relation, SL("op"), PH_NOISY_CC);
				if (Z_TYPE_P(options) == IS_ARRAY) { 
					eval_int = phalcon_array_isset_string(options, SS("foreignKey"));
					if (eval_int) {
						PHALCON_INIT_NVAR(foreign_key);
						phalcon_array_fetch_string(&foreign_key, options, SL("foreignKey"), PH_NOISY_CC);
						if (zend_is_true(foreign_key)) {
							PHALCON_INIT_NVAR(conditions);
							array_init(conditions);
	
							PHALCON_INIT_NVAR(relation_class);
							phalcon_array_fetch_string(&relation_class, relation, SL("rt"), PH_NOISY_CC);
							ce0 = phalcon_fetch_class(relation_class TSRMLS_CC);
	
							PHALCON_INIT_NVAR(referenced_model);
							object_init_ex(referenced_model, ce0);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "__construct", dependency_injector, PH_CHECK);
	
							PHALCON_INIT_NVAR(fields);
							phalcon_array_fetch_string(&fields, relation, SL("fi"), PH_NOISY_CC);
							if (Z_TYPE_P(fields) == IS_ARRAY) { 
								PHALCON_INIT_NVAR(referenced_fields);
								phalcon_array_fetch_string(&referenced_fields, relation, SL("rf"), PH_NOISY_CC);
	
								if (!phalcon_valid_foreach(fields TSRMLS_CC)) {
									return;
								}
	
								ah1 = Z_ARRVAL_P(fields);
								zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
								ph_cycle_start_1:
	
									if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
										goto ph_cycle_end_1;
									}
	
									PHALCON_GET_FOREACH_KEY(n, ah1, hp1);
									PHALCON_GET_FOREACH_VALUE(field);
	
									PHALCON_INIT_NVAR(value);
									phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
	
									PHALCON_INIT_NVAR(referenced_field);
									phalcon_array_fetch(&referenced_field, referenced_fields, n, PH_NOISY_CC);
	
									PHALCON_INIT_NVAR(condition);
									PHALCON_CONCAT_VSVS(condition, referenced_field, " = '", value, "'");
									phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
	
									zend_hash_move_forward_ex(ah1, &hp1);
									goto ph_cycle_start_1;
	
								ph_cycle_end_1:
								if(0){}
	
							} else {
								PHALCON_INIT_NVAR(value);
								phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY_CC);
								if (PHALCON_IS_EMPTY(value)) {
									goto ph_cycle_start_0;
								}
	
								PHALCON_INIT_NVAR(referenced_field);
								phalcon_array_fetch_string(&referenced_field, relation, SL("rf"), PH_NOISY_CC);
	
								PHALCON_INIT_NVAR(condition);
								PHALCON_CONCAT_VSVS(condition, referenced_field, " = '", value, "'");
								phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
							}
	
							eval_int = phalcon_array_isset_string(foreign_key, SS("conditions"));
							if (eval_int) {
								PHALCON_INIT_NVAR(extra_conditions);
								phalcon_array_fetch_string(&extra_conditions, foreign_key, SL("conditions"), PH_NOISY_CC);
								phalcon_array_append(&conditions, extra_conditions, PH_SEPARATE TSRMLS_CC);
							}
	
							PHALCON_INIT_NVAR(connection_service);
							PHALCON_CALL_METHOD(connection_service, this_ptr, "getconnectionservice", PH_NO_CHECK);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "setconnectionservice", connection_service, PH_NO_CHECK);
	
							PHALCON_INIT_NVAR(join_conditions);
							phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
							PHALCON_INIT_NVAR(rowcount);
							PHALCON_CALL_METHOD_PARAMS_1(rowcount, referenced_model, "count", join_conditions, PH_NO_CHECK);
							if (!zend_is_true(rowcount)) {
								eval_int = phalcon_array_isset_string(foreign_key, SS("message"));
								if (eval_int) {
									PHALCON_INIT_NVAR(user_message);
									phalcon_array_fetch_string(&user_message, foreign_key, SL("message"), PH_NOISY_CC);
								} else {
									if (Z_TYPE_P(fields) == IS_ARRAY) { 
										PHALCON_INIT_NVAR(joined_fields);
										phalcon_fast_join_str(joined_fields, SL(", "), fields TSRMLS_CC);
	
										PHALCON_INIT_NVAR(user_message);
										PHALCON_CONCAT_SVS(user_message, "Value of fields \"", joined_fields, "\" does not exist on referenced table");
									} else {
										PHALCON_INIT_NVAR(user_message);
										PHALCON_CONCAT_SVS(user_message, "Value of field \"", fields, "\" does not exist on referenced table");
									}
								}
	
								PHALCON_INIT_NVAR(type);
								ZVAL_STRING(type, "ConstraintViolation", 1);
	
								PHALCON_INIT_NVAR(message);
								object_init_ex(message, phalcon_mvc_model_message_ce);
								PHALCON_CALL_METHOD_PARAMS_3_NORETURN(message, "__construct", user_message, fields, type, PH_CHECK);
								PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "appendmessage", message, PH_NO_CHECK);
	
								PHALCON_INIT_NVAR(error);
								ZVAL_BOOL(error, 1);
								goto ph_cycle_end_0;
							}
						}
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		if (PHALCON_IS_TRUE(error)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_canceloperation", disable_events, PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysReverse){

	zval *dependency_injector, *disable_events;
	zval *service, *manager, *relations, *error = NULL, *relation = NULL;
	zval *options = NULL, *foreign_key = NULL, *fields = NULL, *referenced_name = NULL;
	zval *referenced_fields = NULL, *referenced_model = NULL;
	zval *conditions = NULL, *field = NULL, *n = NULL, *value = NULL, *referenced_field = NULL;
	zval *condition = NULL, *extra_conditions = NULL, *connection_service = NULL;
	zval *join_conditions = NULL, *rowcount = NULL, *user_message = NULL;
	zval *type = NULL, *message = NULL, *event_name;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &dependency_injector, &disable_events) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(relations);
	PHALCON_CALL_METHOD_PARAMS_1(relations, manager, "gethasoneandhasmany", this_ptr, PH_NO_CHECK);
	if (phalcon_fast_count_ev(relations TSRMLS_CC)) {
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
	
		if (!phalcon_valid_foreach(relations TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(relations);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(relation);
	
			eval_int = phalcon_array_isset_string(relation, SS("op"));
			if (eval_int) {
				PHALCON_INIT_NVAR(options);
				phalcon_array_fetch_string(&options, relation, SL("op"), PH_NOISY_CC);
				if (Z_TYPE_P(options) == IS_ARRAY) { 
					eval_int = phalcon_array_isset_string(options, SS("foreignKey"));
					if (eval_int) {
						PHALCON_INIT_NVAR(foreign_key);
						phalcon_array_fetch_string(&foreign_key, options, SL("foreignKey"), PH_NOISY_CC);
						if (zend_is_true(foreign_key)) {
							PHALCON_INIT_NVAR(fields);
							phalcon_array_fetch_string(&fields, relation, SL("fi"), PH_NOISY_CC);
	
							PHALCON_INIT_NVAR(referenced_name);
							phalcon_array_fetch_string(&referenced_name, relation, SL("rt"), PH_NOISY_CC);
	
							PHALCON_INIT_NVAR(referenced_fields);
							phalcon_array_fetch_string(&referenced_fields, relation, SL("rf"), PH_NOISY_CC);
							ce0 = phalcon_fetch_class(referenced_name TSRMLS_CC);
	
							PHALCON_INIT_NVAR(referenced_model);
							object_init_ex(referenced_model, ce0);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "__construct", dependency_injector, PH_CHECK);
	
							PHALCON_INIT_NVAR(conditions);
							array_init(conditions);
							if (Z_TYPE_P(fields) == IS_ARRAY) { 
	
								if (!phalcon_valid_foreach(fields TSRMLS_CC)) {
									return;
								}
	
								ah1 = Z_ARRVAL_P(fields);
								zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
								ph_cycle_start_1:
	
									if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
										goto ph_cycle_end_1;
									}
	
									PHALCON_GET_FOREACH_KEY(n, ah1, hp1);
									PHALCON_GET_FOREACH_VALUE(field);
	
									eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
									if (eval_int) {
										PHALCON_INIT_NVAR(value);
										phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
									} else {
										PHALCON_INIT_NVAR(value);
									}
	
									PHALCON_INIT_NVAR(referenced_field);
									phalcon_array_fetch(&referenced_field, referenced_fields, n, PH_NOISY_CC);
	
									PHALCON_INIT_NVAR(condition);
									PHALCON_CONCAT_VSVS(condition, referenced_field, " = '", value, "'");
									phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
	
									zend_hash_move_forward_ex(ah1, &hp1);
									goto ph_cycle_start_1;
	
								ph_cycle_end_1:
								if(0){}
	
							} else {
								eval_int = phalcon_isset_property_zval(this_ptr, fields TSRMLS_CC);
								if (eval_int) {
									PHALCON_INIT_NVAR(value);
									phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY_CC);
								} else {
									PHALCON_INIT_NVAR(value);
								}
	
								PHALCON_INIT_NVAR(condition);
								PHALCON_CONCAT_VSVS(condition, referenced_fields, " = '", value, "'");
								phalcon_array_append(&conditions, condition, PH_SEPARATE TSRMLS_CC);
							}
	
							eval_int = phalcon_array_isset_string(foreign_key, SS("conditions"));
							if (eval_int) {
								PHALCON_INIT_NVAR(extra_conditions);
								phalcon_array_fetch_string(&extra_conditions, foreign_key, SL("conditions"), PH_NOISY_CC);
								phalcon_array_append(&conditions, extra_conditions, PH_SEPARATE TSRMLS_CC);
							}
	
							PHALCON_INIT_NVAR(connection_service);
							PHALCON_CALL_METHOD(connection_service, this_ptr, "getconnectionservice", PH_NO_CHECK);
							PHALCON_CALL_METHOD_PARAMS_1_NORETURN(referenced_model, "setconnectionservice", connection_service, PH_NO_CHECK);
	
							PHALCON_INIT_NVAR(join_conditions);
							phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
							PHALCON_INIT_NVAR(rowcount);
							PHALCON_CALL_METHOD_PARAMS_1(rowcount, referenced_model, "count", join_conditions, PH_NO_CHECK);
							if (zend_is_true(rowcount)) {
								eval_int = phalcon_array_isset_string(foreign_key, SS("message"));
								if (eval_int) {
									PHALCON_INIT_NVAR(user_message);
									phalcon_array_fetch_string(&user_message, foreign_key, SL("message"), PH_NOISY_CC);
								} else {
									PHALCON_INIT_NVAR(user_message);
									PHALCON_CONCAT_SV(user_message, "Record is referenced by model ", referenced_name);
								}
	
								PHALCON_INIT_NVAR(type);
								ZVAL_STRING(type, "ConstraintViolation", 1);
	
								PHALCON_INIT_NVAR(message);
								object_init_ex(message, phalcon_mvc_model_message_ce);
								PHALCON_CALL_METHOD_PARAMS_3_NORETURN(message, "__construct", user_message, fields, type, PH_CHECK);
								PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "appendmessage", message, PH_NO_CHECK);
	
								PHALCON_INIT_NVAR(error);
								ZVAL_BOOL(error, 1);
								goto ph_cycle_end_0;
							}
						}
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
		if (PHALCON_IS_TRUE(error)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_canceloperation", disable_events, PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Model, _preSave){

	zval *dependency_injector, *meta_data, *disable_events;
	zval *exists, *identity_field, *event_name = NULL, *status = NULL;
	zval *not_null, *data_type_numeric, *error = NULL, *num_fields;
	zval *null_value, *empty_str, *i, *is_null = NULL, *field = NULL;
	zval *value = NULL, *is_numeric = NULL, *is_identity_field = NULL;
	zval *message = NULL, *type = NULL, *model_message = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzzz", &dependency_injector, &meta_data, &disable_events, &exists, &identity_field) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeValidation", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnUpdate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_NVAR(status);
	PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "_checkforeignkeys", dependency_injector, disable_events, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(not_null);
	PHALCON_CALL_METHOD_PARAMS_1(not_null, meta_data, "getnotnullattributes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(data_type_numeric);
	PHALCON_CALL_METHOD_PARAMS_1(data_type_numeric, meta_data, "getdatatypesnumeric", this_ptr, PH_NO_CHECK);
	if (Z_TYPE_P(not_null) == IS_ARRAY) { 
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
	
		PHALCON_INIT_VAR(num_fields);
		phalcon_fast_count(num_fields, not_null TSRMLS_CC);
	
		PHALCON_INIT_VAR(null_value);
	
		PHALCON_INIT_VAR(empty_str);
		ZVAL_STRING(empty_str, "", 1);
	
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 0);
		ph_cycle_start_0:
	
			PHALCON_INIT_NVAR(r0);
			is_smaller_function(r0, i, num_fields TSRMLS_CC);
			if (!zend_is_true(r0)) {
				goto ph_cycle_end_0;
			}
			PHALCON_INIT_NVAR(is_null);
			ZVAL_BOOL(is_null, 0);
	
			PHALCON_INIT_NVAR(field);
			phalcon_array_fetch(&field, not_null, i, PH_NOISY_CC);
			eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
			if (eval_int) {
				PHALCON_INIT_NVAR(value);
				phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
				eval_int = phalcon_array_isset(data_type_numeric, field);
				if (!eval_int) {
					if (PHALCON_IS_EMPTY(value)) {
						PHALCON_INIT_NVAR(is_null);
						ZVAL_BOOL(is_null, 1);
					}
				} else {
					PHALCON_INIT_NVAR(is_numeric);
					PHALCON_CALL_FUNC_PARAMS_1(is_numeric, "is_numeric", value);
					if (PHALCON_IS_FALSE(is_numeric)) {
						PHALCON_INIT_NVAR(is_null);
						ZVAL_BOOL(is_null, 1);
					}
				}
			} else {
				PHALCON_INIT_NVAR(is_null);
				ZVAL_BOOL(is_null, 1);
			}
	
			if (PHALCON_IS_TRUE(is_null)) {
				if (PHALCON_IS_FALSE(exists)) {
					PHALCON_INIT_NVAR(is_identity_field);
					is_equal_function(is_identity_field, field, identity_field TSRMLS_CC);
					if (PHALCON_IS_TRUE(is_identity_field)) {
						goto ph_cycle_incr_0;
					}
				}
	
				PHALCON_INIT_NVAR(message);
				PHALCON_CONCAT_VS(message, field, " is required");
	
				PHALCON_INIT_NVAR(type);
				ZVAL_STRING(type, "PresenceOf", 1);
	
				PHALCON_INIT_NVAR(model_message);
				object_init_ex(model_message, phalcon_mvc_model_message_ce);
				PHALCON_CALL_METHOD_PARAMS_3_NORETURN(model_message, "__construct", message, field, type, PH_CHECK);
	
				PHALCON_INIT_NVAR(t0);
				phalcon_read_property(&t0, this_ptr, SL("_errorMessages"), PH_NOISY_CC);
				phalcon_array_append(&t0, model_message, 0 TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_errorMessages"), t0 TSRMLS_CC);
	
				PHALCON_INIT_NVAR(error);
				ZVAL_BOOL(error, 1);
			}
			ph_cycle_incr_0:
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto ph_cycle_start_0;
		ph_cycle_end_0:
		if (PHALCON_IS_TRUE(error)) {
			if (!zend_is_true(disable_events)) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "onValidationFails", 1);
				PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
			}
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_canceloperation", disable_events, PH_NO_CHECK);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "validation", 1);
	
	PHALCON_INIT_NVAR(status);
	PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	if (!zend_is_true(disable_events)) {
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnUpdate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterValidation", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "beforeSave", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	
		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeCreate", 1);
		}
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Model, _postSave){

	zval *disable_events, *success, *exists, *event_name = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &disable_events, &success, &exists) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (PHALCON_IS_TRUE(success)) {
		if (!zend_is_true(disable_events)) {
			if (PHALCON_IS_TRUE(exists)) {
				PHALCON_INIT_VAR(event_name);
				ZVAL_STRING(event_name, "afterUpdate", 1);
			} else {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "afterCreate", 1);
			}
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
	
		RETURN_CCTOR(success);
	} else {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "notSave", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_canceloperation", disable_events, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Mvc_Model, _doLowInsert){

	zval *meta_data, *connection, *table, *identity_field;
	zval *null_value, *bind_skip, *fields, *values;
	zval *bind_types, *attributes, *bind_data_types;
	zval *automatic_attributes, *field = NULL, *is_identity_field = NULL;
	zval *exception_message = NULL, *value = NULL, *bind_type = NULL;
	zval *default_value, *id, *success, *sequence_name = NULL;
	zval *support_sequences, *source, *last_insert_id;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &meta_data, &connection, &table, &identity_field) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(bind_skip);
	ZVAL_LONG(bind_skip, 1024);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(bind_data_types);
	PHALCON_CALL_METHOD_PARAMS_1(bind_data_types, meta_data, "getbindtypes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(automatic_attributes);
	PHALCON_CALL_METHOD_PARAMS_1(automatic_attributes, meta_data, "getautomaticcreateattributes", this_ptr, PH_NO_CHECK);
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(field);
	
		eval_int = phalcon_array_isset(automatic_attributes, field);
		if (!eval_int) {
			PHALCON_INIT_NVAR(is_identity_field);
			is_not_equal_function(is_identity_field, field, identity_field TSRMLS_CC);
			if (PHALCON_IS_TRUE(is_identity_field)) {
				phalcon_array_append(&fields, field, PH_SEPARATE TSRMLS_CC);
				eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
				if (eval_int) {
					eval_int = phalcon_array_isset(bind_data_types, field);
					if (!eval_int) {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SVS(exception_message, "Column '", field, "\" isn't part of the table columns");
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
	
					PHALCON_INIT_NVAR(value);
					phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
					phalcon_array_append(&values, value, PH_SEPARATE TSRMLS_CC);
	
					PHALCON_INIT_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY_CC);
					phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
				} else {
					phalcon_array_append(&values, null_value, PH_SEPARATE TSRMLS_CC);
					phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE TSRMLS_CC);
				}
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (PHALCON_IS_NOT_FALSE(identity_field)) {
		PHALCON_INIT_VAR(default_value);
		PHALCON_CALL_METHOD(default_value, connection, "getdefaultidvalue", PH_NO_CHECK);
		phalcon_array_append(&fields, identity_field, PH_SEPARATE TSRMLS_CC);
		eval_int = phalcon_isset_property_zval(this_ptr, identity_field TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_VAR(id);
			phalcon_read_property_zval(&id, this_ptr, identity_field, PH_NOISY_CC);
			if (PHALCON_IS_EMPTY(id)) {
				phalcon_array_append(&values, default_value, PH_SEPARATE TSRMLS_CC);
				phalcon_array_append(&bind_data_types, bind_skip, PH_SEPARATE TSRMLS_CC);
			} else {
				eval_int = phalcon_array_isset(bind_data_types, identity_field);
				if (!eval_int) {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Identity column '", identity_field, "\" isn't part of the table columns");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
				phalcon_array_append(&values, id, PH_SEPARATE TSRMLS_CC);
	
				PHALCON_INIT_NVAR(bind_type);
				phalcon_array_fetch(&bind_type, bind_data_types, identity_field, PH_NOISY_CC);
				phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
			}
		} else {
			phalcon_array_append(&values, default_value, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE TSRMLS_CC);
		}
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_4(success, connection, "insert", table, values, fields, bind_types, PH_NO_CHECK);
	if (PHALCON_IS_NOT_FALSE(identity_field)) {
		PHALCON_INIT_VAR(sequence_name);
	
		PHALCON_INIT_VAR(support_sequences);
		PHALCON_CALL_METHOD(support_sequences, connection, "supportsequences", PH_NO_CHECK);
		if (PHALCON_IS_TRUE(support_sequences)) {
			if (phalcon_method_exists_ex(this_ptr, SS("getsequencename") TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD(sequence_name, this_ptr, "getsequencename", PH_NO_CHECK);
			} else {
				PHALCON_INIT_VAR(source);
				PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	
				PHALCON_INIT_NVAR(sequence_name);
				PHALCON_CONCAT_VSVS(sequence_name, source, "_", identity_field, "_seq");
			}
		}
	
		PHALCON_INIT_VAR(last_insert_id);
		PHALCON_CALL_METHOD_PARAMS_1(last_insert_id, connection, "lastinsertid", sequence_name, PH_NO_CHECK);
		phalcon_update_property_zval_zval(this_ptr, identity_field, last_insert_id TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model, _doLowUpdate){

	zval *meta_data, *connection, *table, *null_value;
	zval *bind_skip, *fields, *values, *bind_types;
	zval *bind_data_types, *non_primary, *automatic_attributes;
	zval *field = NULL, *exception_message = NULL, *value = NULL, *bind_type = NULL;
	zval *unique_key, *success;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &meta_data, &connection, &table) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(bind_skip);
	ZVAL_LONG(bind_skip, 1024);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_INIT_VAR(bind_data_types);
	PHALCON_CALL_METHOD_PARAMS_1(bind_data_types, meta_data, "getbindtypes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(non_primary);
	PHALCON_CALL_METHOD_PARAMS_1(non_primary, meta_data, "getnonprimarykeyattributes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(automatic_attributes);
	PHALCON_CALL_METHOD_PARAMS_1(automatic_attributes, meta_data, "getautomaticcreateattributes", this_ptr, PH_NO_CHECK);
	
	if (!phalcon_valid_foreach(non_primary TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(non_primary);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(field);
	
		eval_int = phalcon_array_isset(automatic_attributes, field);
		if (!eval_int) {
			eval_int = phalcon_array_isset(bind_data_types, field);
			if (!eval_int) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", field, "\" isn't part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
			phalcon_array_append(&fields, field, PH_SEPARATE TSRMLS_CC);
			eval_int = phalcon_isset_property_zval(this_ptr, field TSRMLS_CC);
			if (eval_int) {
				PHALCON_INIT_NVAR(value);
				phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY_CC);
				phalcon_array_append(&values, value, PH_SEPARATE TSRMLS_CC);
	
				PHALCON_INIT_NVAR(bind_type);
				phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY_CC);
				phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
			} else {
				phalcon_array_append(&values, null_value, PH_SEPARATE TSRMLS_CC);
				phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(unique_key);
	phalcon_read_property(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_5(success, connection, "update", table, fields, values, unique_key, bind_types, PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model, save){

	zval *dependency_injector, *service, *meta_data;
	zval *schema, *source, *table = NULL, *connection, *exists;
	zval *empty_array, *disable_events = NULL, *identity_field;
	zval *status, *success = NULL, *post_success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, this_ptr, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_3(exists, this_ptr, "_exists", meta_data, connection, table, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(exists)) {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 1 TSRMLS_CC);
	} else {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 2 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), empty_array TSRMLS_CC);
	PHALCON_OBSERVE_VAR(disable_events);
	phalcon_read_static_property(&disable_events, SL("phalcon\\mvc\\model"), SL("_disableEvents") TSRMLS_CC);
	
	PHALCON_INIT_VAR(identity_field);
	PHALCON_CALL_METHOD_PARAMS_1(identity_field, meta_data, "getidentityfield", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_5(status, this_ptr, "_presave", dependency_injector, meta_data, disable_events, exists, identity_field, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	if (PHALCON_IS_TRUE(exists)) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_3(success, this_ptr, "_dolowupdate", meta_data, connection, table, PH_NO_CHECK);
	} else {
		PHALCON_INIT_NVAR(success);
		PHALCON_CALL_METHOD_PARAMS_4(success, this_ptr, "_dolowinsert", meta_data, connection, table, identity_field, PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(post_success);
	PHALCON_CALL_METHOD_PARAMS_3(post_success, this_ptr, "_postsave", disable_events, success, exists, PH_NO_CHECK);
	
	RETURN_CCTOR(post_success);
}

PHP_METHOD(Phalcon_Mvc_Model, create){

	zval *dependency_injector, *service, *meta_data;
	zval *connection, *exists, *field, *type, *message;
	zval *model_message, *messages, *success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_2(exists, this_ptr, "_exists", meta_data, connection, PH_NO_CHECK);
	if (zend_is_true(exists)) {
		PHALCON_INIT_VAR(field);
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "InvalidCreateAttempt", 1);
	
		PHALCON_INIT_VAR(message);
		ZVAL_STRING(message, "Record cannot be created because it already exists", 1);
	
		PHALCON_INIT_VAR(model_message);
		object_init_ex(model_message, phalcon_mvc_model_message_ce);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(model_message, "__construct", message, field, type, PH_CHECK);
	
		PHALCON_INIT_VAR(messages);
		array_init(messages);
		phalcon_array_append(&messages, model_message, PH_SEPARATE TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_errorMessages"), messages TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, this_ptr, "save", PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model, update){

	zval *force_exists, *dependency_injector;
	zval *service, *meta_data, *connection, *exists;
	zval *field, *type, *message, *model_message, *messages;
	zval *success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(force_exists);
	phalcon_read_property(&force_exists, this_ptr, SL("_forceExists"), PH_NOISY_CC);
	if (!zend_is_true(force_exists)) {
		PHALCON_INIT_VAR(dependency_injector);
		phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "modelsMetadata", 1);
	
		PHALCON_INIT_VAR(meta_data);
		PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(connection);
		PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	
		PHALCON_INIT_VAR(exists);
		PHALCON_CALL_METHOD_PARAMS_2(exists, this_ptr, "_exists", meta_data, connection, PH_NO_CHECK);
		if (!zend_is_true(exists)) {
			PHALCON_INIT_VAR(field);
	
			PHALCON_INIT_VAR(type);
			ZVAL_STRING(type, "InvalidUpdateAttempt", 1);
	
			PHALCON_INIT_VAR(message);
			ZVAL_STRING(message, "Record cannot be updated because it does not exists", 1);
	
			PHALCON_INIT_VAR(model_message);
			object_init_ex(model_message, phalcon_mvc_model_message_ce);
			PHALCON_CALL_METHOD_PARAMS_3_NORETURN(model_message, "__construct", message, field, type, PH_CHECK);
	
			PHALCON_INIT_VAR(messages);
			array_init(messages);
			phalcon_array_append(&messages, model_message, PH_SEPARATE TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_errorMessages"), messages TSRMLS_CC);
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD(success, this_ptr, "save", PH_NO_CHECK);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model, delete){

	zval *dependency_injector, *service, *meta_data;
	zval *connection, *disable_events = NULL, *check_foreign_keys;
	zval *values, *bind_types, *conditions = NULL, *primary_keys;
	zval *bind_data_types, *primary_key = NULL, *exception_message = NULL;
	zval *value = NULL, *primary_condition = NULL, *bind_type = NULL;
	zval *event_name = NULL, *status, *schema, *source, *table = NULL;
	zval *success;
	zval *a0 = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(connection);
	PHALCON_CALL_METHOD(connection, this_ptr, "getconnection", PH_NO_CHECK);
	phalcon_update_property_long(this_ptr, SL("_operationMade"), 3 TSRMLS_CC);
	
	PHALCON_INIT_VAR(a0);
	array_init(a0);
	phalcon_update_property_zval(this_ptr, SL("_errorMessages"), a0 TSRMLS_CC);
	PHALCON_OBSERVE_VAR(disable_events);
	phalcon_read_static_property(&disable_events, SL("phalcon\\mvc\\model"), SL("_disableEvents") TSRMLS_CC);
	
	PHALCON_INIT_VAR(check_foreign_keys);
	PHALCON_CALL_METHOD_PARAMS_2(check_foreign_keys, this_ptr, "_checkforeignkeysreverse", dependency_injector, disable_events, PH_NO_CHECK);
	if (PHALCON_IS_FALSE(check_foreign_keys)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	
	PHALCON_INIT_VAR(primary_keys);
	PHALCON_CALL_METHOD_PARAMS_1(primary_keys, meta_data, "getprimarykeyattributes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(bind_data_types);
	PHALCON_CALL_METHOD_PARAMS_1(bind_data_types, meta_data, "getbindtypes", this_ptr, PH_NO_CHECK);
	
	if (!phalcon_valid_foreach(primary_keys TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(primary_keys);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(primary_key);
	
		eval_int = phalcon_array_isset(bind_data_types, primary_key);
		if (!eval_int) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Column '", primary_key, "\" isn't part of the table columns");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
		eval_int = phalcon_isset_property_zval(this_ptr, primary_key TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, primary_key, PH_NOISY_CC);
			phalcon_array_append(&values, value, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(primary_condition);
			PHALCON_CONCAT_VS(primary_condition, primary_key, " = ?");
			phalcon_array_append(&conditions, primary_condition, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(bind_type);
			phalcon_array_fetch(&bind_type, bind_data_types, primary_key, PH_NOISY_CC);
			phalcon_array_append(&bind_types, bind_type, PH_SEPARATE TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cannot delete the record because one of the primary key attributes isn't set");
			return;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(r0);
	phalcon_fast_join_str(r0, SL(" AND "), conditions TSRMLS_CC);
	PHALCON_CPY_WRT(conditions, r0);
	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeDelete", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_1(status, this_ptr, "_calleventcancel", event_name, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(schema);
	PHALCON_CALL_METHOD(schema, this_ptr, "getschema", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(source);
	PHALCON_CALL_METHOD(source, this_ptr, "getsource", PH_NO_CHECK);
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema, ".", source);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_METHOD_PARAMS_4(success, connection, "delete", table, conditions, values, bind_types, PH_NO_CHECK);
	if (zend_is_true(success)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterDelete", 1);
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_callevent", event_name, PH_NO_CHECK);
		}
	}
	
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Mvc_Model, getOperationMade){


	RETURN_MEMBER(this_ptr, "_operationMade");
}

PHP_METHOD(Phalcon_Mvc_Model, readAttribute){

	zval *attribute, *attribute_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attribute) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	eval_int = phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC);
	if (eval_int) {
		PHALCON_INIT_VAR(attribute_value);
		phalcon_read_property_zval(&attribute_value, this_ptr, attribute, PH_NOISY_CC);
	
		RETURN_CCTOR(attribute_value);
	}
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model, writeAttribute){

	zval *attribute, *value;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &attribute, &value) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Model, skipAttributes){

	zval *attributes, *dependency_injector, *null_value;
	zval *keys_attributes, *attribute = NULL, *service;
	zval *meta_data;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attributes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(meta_data) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(meta_data, "setautomaticcreateattributes", keys_attributes, PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(meta_data, "setautomaticupdateattributes", keys_attributes, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnCreate){

	zval *attributes, *dependency_injector, *null_value;
	zval *keys_attributes, *attribute = NULL, *service;
	zval *meta_data;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attributes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(meta_data) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(meta_data, "setautomaticcreateattributes", keys_attributes, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnUpdate){

	zval *attributes, *dependency_injector, *null_value;
	zval *keys_attributes, *attribute = NULL, *service;
	zval *meta_data;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &attributes) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(meta_data) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(meta_data, "setautomaticupdateattributes", keys_attributes, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, hasOne){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *dependency_injector, *service;
	zval *manager;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_5_NORETURN(manager, "addhasone", this_ptr, fields, reference_model, referenced_fields, options, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, belongsTo){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *dependency_injector, *service;
	zval *manager;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_5_NORETURN(manager, "addbelongsto", this_ptr, fields, reference_model, referenced_fields, options, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, hasMany){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *dependency_injector, *service;
	zval *manager;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz|z", &fields, &reference_model, &referenced_fields, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_CALL_METHOD_PARAMS_5_NORETURN(manager, "addhasmany", this_ptr, fields, reference_model, referenced_fields, options, PH_NO_CHECK);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Mvc_Model, getRelated){

	zval *model_name, *arguments = NULL, *dependency_injector;
	zval *service, *manager, *class_name, *exists = NULL, *manager_method = NULL;
	zval *query_method = NULL, *exception_message, *call_object;
	zval *model_args, *result;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &model_name, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_INIT_NVAR(arguments);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, this_ptr TSRMLS_CC);
	
	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existsbelongsto", class_name, model_name, PH_NO_CHECK);
	if (zend_is_true(exists)) {
		PHALCON_INIT_VAR(manager_method);
		ZVAL_STRING(manager_method, "getBelongsToRecords", 1);
	
		PHALCON_INIT_VAR(query_method);
		ZVAL_STRING(query_method, "findFirst", 1);
	} else {
		PHALCON_INIT_NVAR(exists);
		PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasmany", class_name, model_name, PH_NO_CHECK);
		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(manager_method);
			ZVAL_STRING(manager_method, "getHasManyRecords", 1);
	
			PHALCON_INIT_NVAR(query_method);
			ZVAL_STRING(query_method, "find", 1);
		} else {
			PHALCON_INIT_NVAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasone", class_name, model_name, PH_NO_CHECK);
			if (zend_is_true(exists)) {
				PHALCON_INIT_NVAR(manager_method);
				ZVAL_STRING(manager_method, "getHasOneRecords", 1);
	
				PHALCON_INIT_NVAR(query_method);
				ZVAL_STRING(query_method, "findFirst", 1);
			} else {
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "There is not defined relations between '", class_name, "\" and \"", model_name, "'");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		}
	}
	
	PHALCON_INIT_VAR(call_object);
	array_init(call_object);
	phalcon_array_append(&call_object, manager, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&call_object, manager_method, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(model_args);
	array_init(model_args);
	phalcon_array_append(&model_args, query_method, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&model_args, class_name, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&model_args, model_name, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&model_args, this_ptr, PH_SEPARATE TSRMLS_CC);
	phalcon_array_append(&model_args, arguments, PH_SEPARATE TSRMLS_CC);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CALL_USER_FUNC_ARRAY(result, call_object, model_args);
	
	RETURN_CCTOR(result);
}

PHP_METHOD(Phalcon_Mvc_Model, __getRelatedRecords){

	zval *model_name, *method, *arguments, *dependency_injector;
	zval *service, *manager, *manager_method = NULL, *three;
	zval *requested_relation = NULL, *exists = NULL, *query_method = NULL;
	zval *five, *extra_args = NULL, *call_args, *call_object;
	zval *result;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &model_name, &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsManager", 1);
	
	PHALCON_INIT_VAR(manager);
	PHALCON_CALL_METHOD_PARAMS_1(manager, dependency_injector, "getshared", service, PH_NO_CHECK);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "There is not models manager related to this model");
		return;
	}
	
	PHALCON_INIT_VAR(manager_method);
	ZVAL_BOOL(manager_method, 0);
	if (phalcon_start_with_str(method, SL("get"))) {
		PHALCON_INIT_VAR(three);
		ZVAL_LONG(three, 3);
	
		PHALCON_INIT_VAR(requested_relation);
		PHALCON_CALL_FUNC_PARAMS_2(requested_relation, "substr", method, three);
	
		PHALCON_INIT_VAR(exists);
		PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existsbelongsto", model_name, requested_relation, PH_NO_CHECK);
		if (zend_is_true(exists)) {
			ZVAL_STRING(manager_method, "getBelongsToRecords", 1);
	
			PHALCON_INIT_VAR(query_method);
			ZVAL_STRING(query_method, "findFirst", 1);
		} else {
			PHALCON_INIT_NVAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasmany", model_name, requested_relation, PH_NO_CHECK);
			if (zend_is_true(exists)) {
				PHALCON_INIT_NVAR(manager_method);
				ZVAL_STRING(manager_method, "getHasManyRecords", 1);
	
				PHALCON_INIT_NVAR(query_method);
				ZVAL_STRING(query_method, "find", 1);
			} else {
				PHALCON_INIT_NVAR(exists);
				PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasone", model_name, requested_relation, PH_NO_CHECK);
				if (zend_is_true(exists)) {
					PHALCON_INIT_NVAR(manager_method);
					ZVAL_STRING(manager_method, "getHasOneRecords", 1);
	
					PHALCON_INIT_NVAR(query_method);
					ZVAL_STRING(query_method, "findFirst", 1);
				}
			}
		}
	}
	
	if (PHALCON_IS_FALSE(manager_method)) {
		if (phalcon_start_with_str(method, SL("count"))) {
			PHALCON_INIT_VAR(five);
			ZVAL_LONG(five, 5);
	
			PHALCON_INIT_NVAR(query_method);
			ZVAL_STRING(query_method, "count", 1);
	
			PHALCON_INIT_NVAR(requested_relation);
			PHALCON_CALL_FUNC_PARAMS_2(requested_relation, "substr", method, five);
	
			PHALCON_INIT_NVAR(exists);
			PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existsbelongsto", model_name, requested_relation, PH_NO_CHECK);
			if (zend_is_true(exists)) {
				PHALCON_INIT_NVAR(manager_method);
				ZVAL_STRING(manager_method, "getBelongsToRecords", 1);
			} else {
				PHALCON_INIT_NVAR(exists);
				PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasmany", model_name, requested_relation, PH_NO_CHECK);
				if (zend_is_true(exists)) {
					PHALCON_INIT_NVAR(manager_method);
					ZVAL_STRING(manager_method, "getHasManyRecords", 1);
				} else {
					PHALCON_INIT_NVAR(exists);
					PHALCON_CALL_METHOD_PARAMS_2(exists, manager, "existshasone", model_name, requested_relation, PH_NO_CHECK);
					if (zend_is_true(exists)) {
						PHALCON_INIT_NVAR(manager_method);
						ZVAL_STRING(manager_method, "getHasOneRecords", 1);
					}
				}
			}
		}
	}
	
	if (PHALCON_IS_NOT_FALSE(manager_method)) {
		eval_int = phalcon_array_isset_long(arguments, 0);
		if (eval_int) {
			PHALCON_INIT_VAR(extra_args);
			phalcon_array_fetch_long(&extra_args, arguments, 0, PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(extra_args);
		}
	
		PHALCON_INIT_VAR(call_args);
		array_init(call_args);
		phalcon_array_append(&call_args, query_method, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&call_args, model_name, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&call_args, requested_relation, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&call_args, this_ptr, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&call_args, extra_args, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(call_object);
		array_init(call_object);
		phalcon_array_append(&call_object, manager, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&call_object, manager_method, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_VAR(result);
		PHALCON_CALL_USER_FUNC_ARRAY(result, call_object, call_args);
	
		RETURN_CCTOR(result);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Mvc_Model, __call){

	zval *method, *arguments = NULL, *model_name, *records;
	zval *exception_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_INIT_NVAR(arguments);
		array_init(arguments);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, this_ptr TSRMLS_CC);
	
	PHALCON_INIT_VAR(records);
	PHALCON_CALL_METHOD_PARAMS_3(records, this_ptr, "__getrelatedrecords", model_name, method, arguments, PH_NO_CHECK);
	if (Z_TYPE_P(records) != IS_NULL) {
	
		RETURN_CCTOR(records);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVSVS(exception_message, "The method \"", method, "\" doesn't exist on model \"", model_name, "\"");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_Mvc_Model, serialize){

	zval *dependency_injector, *service, *meta_data;
	zval *attributes, *null_value, *data, *attribute = NULL;
	zval *value = NULL, *serialize;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_INIT_VAR(meta_data);
	PHALCON_CALL_METHOD_PARAMS_1(meta_data, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(attributes);
	PHALCON_CALL_METHOD_PARAMS_1(attributes, meta_data, "getattributes", this_ptr, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	
	if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(attributes);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(attribute);
	
		eval_int = phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC);
		if (eval_int) {
			PHALCON_INIT_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, attribute, PH_NOISY_CC);
			phalcon_array_update_zval(&data, attribute, &value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		} else {
			phalcon_array_update_zval(&data, attribute, &null_value, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	PHALCON_INIT_VAR(serialize);
	PHALCON_CALL_FUNC_PARAMS_1(serialize, "serialize", data);
	
	RETURN_CCTOR(serialize);
}

PHP_METHOD(Phalcon_Mvc_Model, unserialize){

	zval *data, *attributes, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(data) == IS_STRING) {
		PHALCON_INIT_VAR(attributes);
		PHALCON_CALL_FUNC_PARAMS_1(attributes, "unserialize", data);
		if (Z_TYPE_P(attributes) == IS_ARRAY) { 
	
			if (!phalcon_valid_foreach(attributes TSRMLS_CC)) {
				return;
			}
	
			ah0 = Z_ARRVAL_P(attributes);
			zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
			ph_cycle_start_0:
	
				if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
					goto ph_cycle_end_0;
				}
	
				PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
				PHALCON_GET_FOREACH_VALUE(value);
	
				phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
	
				zend_hash_move_forward_ex(ah0, &hp0);
				goto ph_cycle_start_0;
	
			ph_cycle_end_0:
	
			PHALCON_MM_RESTORE();
			RETURN_NULL();
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
	return;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Controller){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Controller, mvc_controller, "phalcon\\di\\injectable", phalcon_mvc_controller_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Controller, __construct){


	
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Mvc_ViewInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ViewInterface, mvc_viewinterface, phalcon_mvc_viewinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setViewsDir);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getViewsDir);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setBasePath);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setRenderLevel);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setMainView);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setTemplateBefore);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, cleanTemplateBefore);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setTemplateAfter);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, cleanTemplateAfter);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setParamToView);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setVar);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getParamsToView);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getControllerName);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getActionName);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getParams);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, start);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, registerEngines);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, render);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, pick);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, partial);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, finish);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getCache);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, cache);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, setContent);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getContent);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, getActiveRenderPath);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, disable);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, enable);

PHALCON_DOC_METHOD(Phalcon_Mvc_ViewInterface, reset);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Mvc_Dispatcher){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Dispatcher, mvc_dispatcher, "phalcon\\dispatcher", phalcon_mvc_dispatcher_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_handlerSuffix"), "Controller", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_defaultHandler"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_defaultAction"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_dispatcher_ce TSRMLS_CC, 1, phalcon_mvc_dispatcherinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerSuffix){

	zval *controller_suffix;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_suffix) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_handlerSuffix"), controller_suffix TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, setDefaultController){

	zval *controller_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultHandler"), controller_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerName){

	zval *controller_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &controller_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_handlerName"), controller_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, getControllerName){


	RETURN_MEMBER(this_ptr, "_handlerName");
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, _throwDispatchException){

	zval *message, *exception_code = NULL, *dependency_injector;
	zval *exception_message, *exception = NULL, *service;
	zval *response, *status_code, *status_message;
	zval *events_manager, *event_name, *status;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &exception_code) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!exception_code) {
		PHALCON_INIT_NVAR(exception_code);
		ZVAL_LONG(exception_code, 0);
	} else {
		PHALCON_SEPARATE_PARAM(exception_code);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(exception_code);
		ZVAL_LONG(exception_code, 0);
	
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "A dependency injection container is required to access the 'response' service", 1);
	
		PHALCON_INIT_VAR(exception);
		object_init_ex(exception, phalcon_mvc_dispatcher_exception_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(exception, "__construct", exception_message, exception_code, PH_CHECK);
		phalcon_throw_exception(exception TSRMLS_CC);
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "response", 1);
	
	PHALCON_INIT_VAR(response);
	PHALCON_CALL_METHOD_PARAMS_1(response, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(status_code);
	ZVAL_LONG(status_code, 404);
	
	PHALCON_INIT_VAR(status_message);
	ZVAL_STRING(status_message, "Not Found", 1);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(response, "setstatuscode", status_code, status_message, PH_NO_CHECK);
	
	PHALCON_INIT_NVAR(exception);
	object_init_ex(exception, phalcon_mvc_dispatcher_exception_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(exception, "__construct", message, exception_code, PH_CHECK);
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, exception, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	phalcon_throw_exception(exception TSRMLS_CC);
	return;
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, getLastController){


	RETURN_MEMBER(this_ptr, "_lastHandler");
}

PHP_METHOD(Phalcon_Mvc_Dispatcher, getActiveController){


	RETURN_MEMBER(this_ptr, "_activeHandler");
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Mvc_Url_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Url, Exception, mvc_url_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Version){

	PHALCON_REGISTER_CLASS(Phalcon, Version, version, phalcon_version_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Version, _getVersion){

	zval *version;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(version);
	array_init(version);
	add_next_index_long(version, 0);
	add_next_index_long(version, 7);
	add_next_index_long(version, 0);
	add_next_index_long(version, 1);
	add_next_index_long(version, 1);
	
	RETURN_CTOR(version);
}

PHP_METHOD(Phalcon_Version, get){

	zval *version, *major, *medium, *minor, *special, *special_number;
	zval *result, *suffix = NULL, *final_version;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(version);
	PHALCON_CALL_SELF(version, this_ptr, "_getversion");
	
	PHALCON_INIT_VAR(major);
	phalcon_array_fetch_long(&major, version, 0, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(medium);
	phalcon_array_fetch_long(&medium, version, 1, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(minor);
	phalcon_array_fetch_long(&minor, version, 2, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special);
	phalcon_array_fetch_long(&special, version, 3, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_number);
	phalcon_array_fetch_long(&special_number, version, 4, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(result);
	PHALCON_CONCAT_VSVSVS(result, major, ".", medium, ".", minor, " ");
	
	if (phalcon_compare_strict_long(special, 1 TSRMLS_CC)) {
		PHALCON_INIT_VAR(suffix);
		PHALCON_CONCAT_SV(suffix, "ALPHA ", special_number);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(special, 2 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(suffix);
		PHALCON_CONCAT_SV(suffix, "BETA ", special_number);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(special, 1 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(suffix);
		PHALCON_CONCAT_SV(suffix, "RC ", special_number);
		goto ph_end_0;
	}
	
	PHALCON_INIT_NVAR(suffix);
	ZVAL_STRING(suffix, "", 1);
	goto ph_end_0;
	
	ph_end_0:
	phalcon_concat_self(result, suffix TSRMLS_CC);
	
	PHALCON_INIT_VAR(final_version);
	PHALCON_CALL_FUNC_PARAMS_1(final_version, "trim", result);
	
	RETURN_CCTOR(final_version);
}

PHP_METHOD(Phalcon_Version, getId){

	zval *version = NULL, *major, *medium, *minor, *special, *special_number;
	zval *format, *real_medium, *real_minor;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(version);
	PHALCON_CALL_SELF(version, this_ptr, "_getversion");
	
	PHALCON_INIT_VAR(major);
	phalcon_array_fetch_long(&major, version, 0, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(medium);
	phalcon_array_fetch_long(&medium, version, 1, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(minor);
	phalcon_array_fetch_long(&minor, version, 2, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special);
	phalcon_array_fetch_long(&special, version, 3, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(special_number);
	phalcon_array_fetch_long(&special_number, version, 4, PH_NOISY_CC);
	
	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "%02s", 1);
	
	PHALCON_INIT_VAR(real_medium);
	PHALCON_CALL_FUNC_PARAMS_2(real_medium, "sprintf", format, medium);
	
	PHALCON_INIT_VAR(real_minor);
	PHALCON_CALL_FUNC_PARAMS_2(real_minor, "sprintf", format, minor);
	
	PHALCON_INIT_NVAR(version);
	PHALCON_CONCAT_VVVVV(version, major, real_medium, real_minor, special, special_number);
	
	RETURN_CCTOR(version);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Acl_ResourceInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, ResourceInterface, acl_resourceinterface, phalcon_acl_resourceinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Acl_ResourceInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Acl_ResourceInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Acl_ResourceInterface, getDescription);

PHALCON_DOC_METHOD(Phalcon_Acl_ResourceInterface, __toString);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Acl_Adapter_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Acl\\Adapter, Memory, acl_adapter_memory, "phalcon\\acl", phalcon_acl_adapter_memory_method_entry, 0);

	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_rolesNames"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roles"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resources"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_access"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roleInherits"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resourcesNames"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_accessList"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_activeRole"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_activeResource"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_activeAccess"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_acl_adapter_memory_ce, SL("_accessGranted"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_acl_adapter_memory_ce, SL("_defaultAccess"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_adapter_memory_ce TSRMLS_CC, 1, phalcon_acl_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, __construct){

	zval *a0 = NULL, *a1 = NULL, *a2 = NULL;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_acl_adapter_memory_ce, this_ptr, SL("_rolesNames") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_acl_adapter_memory_ce, this_ptr, SL("_roles") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_acl_adapter_memory_ce, this_ptr, SL("_resources") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_acl_adapter_memory_ce, this_ptr, SL("_access") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_acl_adapter_memory_ce, this_ptr, SL("_roleInherits") TSRMLS_CC);
	
	PHALCON_INIT_VAR(a0);
	array_init(a0);
	add_assoc_bool_ex(a0, SS("*"), 1);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_resourcesNames"), a0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(a1);
	array_init(a1);
	
	PHALCON_INIT_VAR(a2);
	array_init(a2);
	add_assoc_bool_ex(a2, SS("*"), 1);
	phalcon_array_update_string(&a1, SL("*"), &a2, PH_COPY | PH_SEPARATE TSRMLS_CC);
	zend_update_property(phalcon_acl_adapter_memory_ce, this_ptr, SL("_accessList"), a1 TSRMLS_CC);
	

	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, setDefaultAction){

	zval *default_access;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &default_access) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAccess"), default_access TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, getDefaultAction){


	RETURN_MEMBER(this_ptr, "_defaultAccess");
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, addRole){

	zval *role_object, *access_inherits = NULL, *role_name = NULL;
	zval *object = NULL, *roles_names, *default_access;
	zval *success;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &role_object, &access_inherits) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!access_inherits) {
		PHALCON_INIT_NVAR(access_inherits);
	}
	
	if (Z_TYPE_P(role_object) == IS_OBJECT) {
		PHALCON_INIT_VAR(role_name);
		PHALCON_CALL_METHOD(role_name, role_object, "getname", PH_NO_CHECK);
		PHALCON_CPY_WRT(object, role_object);
	} else {
		PHALCON_CPY_WRT(role_name, role_object);
	
		PHALCON_INIT_VAR(object);
		object_init_ex(object, phalcon_acl_role_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", role_name, PH_CHECK);
	}
	
	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_names, role_name);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_roles"), PH_NOISY_CC);
	phalcon_array_append(&t0, object, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_roles"), t0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t1);
	phalcon_read_property(&t1, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	phalcon_array_update_zval_bool(&t1, role_name, 1, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_rolesNames"), t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(default_access);
	phalcon_read_property(&default_access, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t2);
	phalcon_read_property(&t2, this_ptr, SL("_access"), PH_NOISY_CC);
	phalcon_array_update_zval_string_string_multi_3(&t2, role_name, SL("*"), SL("*"), &default_access, 0 TSRMLS_CC);
	if (Z_TYPE_P(access_inherits) != IS_NULL) {
		PHALCON_INIT_VAR(success);
		PHALCON_CALL_METHOD_PARAMS_2(success, this_ptr, "addinherit", role_name, access_inherits, PH_NO_CHECK);
	
		RETURN_CCTOR(success);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, addInherit){

	zval *role_name, *role_to_inherit, *roles_names;
	zval *exception_message = NULL, *is_the_same, *roles_inherits;
	zval *empty_arr;
	zval *t0 = NULL, *t1 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &role_name, &role_to_inherit) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_names, role_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role '", role_name, "' does not exist in the role list");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	eval_int = phalcon_array_isset(roles_names, role_to_inherit);
	if (!eval_int) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role '", role_to_inherit, "' does not exist in the role list");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(is_the_same);
	is_equal_function(is_the_same, role_to_inherit, role_name TSRMLS_CC);
	if (PHALCON_IS_TRUE(is_the_same)) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(roles_inherits);
	phalcon_read_property(&roles_inherits, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_inherits, role_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(empty_arr);
		array_init(empty_arr);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
		phalcon_array_update_zval(&t0, role_name, &empty_arr, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_roleInherits"), t0 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(t1);
	phalcon_read_property(&t1, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
	phalcon_array_update_append_multi_2(&t1, role_name, role_to_inherit, 0 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_roleInherits"), t1 TSRMLS_CC);
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, isRole){

	zval *role_name, *roles_names, *is_role = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &role_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_names, role_name);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(is_role, r0);
	
	RETURN_NCTOR(is_role);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, isResource){

	zval *resource_name, *resources_names, *is_resource = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &resource_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(resources_names);
	phalcon_read_property(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(resources_names, resource_name);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(is_resource, r0);
	
	RETURN_NCTOR(is_resource);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResource){

	zval *resource, *access_list = NULL, *resource_name = NULL;
	zval *object = NULL, *resources_names, *status;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &resource, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!access_list) {
		PHALCON_INIT_NVAR(access_list);
		array_init(access_list);
	}
	
	if (Z_TYPE_P(resource) == IS_OBJECT) {
		PHALCON_INIT_VAR(resource_name);
		PHALCON_CALL_METHOD(resource_name, resource, "getname", PH_NO_CHECK);
		PHALCON_CPY_WRT(object, resource);
	} else {
		PHALCON_CPY_WRT(resource_name, resource);
	
		PHALCON_INIT_VAR(object);
		object_init_ex(object, phalcon_acl_resource_ce);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(object, "__construct", resource_name, PH_CHECK);
	}
	
	PHALCON_INIT_VAR(resources_names);
	phalcon_read_property(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(resources_names, resource_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_resources"), PH_NOISY_CC);
		phalcon_array_append(&t0, object, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_resources"), t0 TSRMLS_CC);
	
		PHALCON_INIT_VAR(a0);
		array_init(a0);
	
		PHALCON_INIT_VAR(t1);
		phalcon_read_property(&t1, this_ptr, SL("_accessList"), PH_NOISY_CC);
		phalcon_array_update_zval(&t1, resource_name, &a0, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_accessList"), t1 TSRMLS_CC);
	
		PHALCON_INIT_VAR(t2);
		phalcon_read_property(&t2, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
		phalcon_array_update_zval_bool(&t2, resource_name, 1, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_resourcesNames"), t2 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "addresourceaccess", resource_name, access_list, PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResourceAccess){

	zval *resource_name, *access_list, *exception_message;
	zval *access_name = NULL, *internal_access_list = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &resource_name, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(t0, resource_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Resource '", resource_name, "' does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(access_list TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(access_list);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(access_name);
	
			PHALCON_INIT_NVAR(internal_access_list);
			phalcon_read_property(&internal_access_list, this_ptr, SL("_accessList"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(r0);
			phalcon_array_fetch(&r0, internal_access_list, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r0, access_name);
			if (!eval_int) {
				PHALCON_INIT_NVAR(t1);
				phalcon_read_property(&t1, this_ptr, SL("_accessList"), PH_NOISY_CC);
				PHALCON_INIT_NVAR(t2);
				ZVAL_LONG(t2, 1);
				phalcon_array_update_multi_2(&t1, resource_name, access_name, &t2, 0 TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_accessList"), t1 TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	} else {
		PHALCON_INIT_VAR(t3);
		phalcon_read_property(&t3, this_ptr, SL("_accessList"), PH_NOISY_CC);
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch(&r1, t3, resource_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r1, access_list);
		if (!eval_int) {
			PHALCON_INIT_VAR(t4);
			phalcon_read_property(&t4, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_VAR(t5);
			ZVAL_LONG(t5, 1);
			phalcon_array_update_multi_2(&t4, resource_name, access_list, &t5, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_accessList"), t4 TSRMLS_CC);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_TRUE;
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, dropResourceAccess){

	zval *resource_name, *access_list, *access_name = NULL;
	zval *t0 = NULL, *t1 = NULL;
	zval *r0 = NULL, *r1 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &resource_name, &access_list) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(access_list TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(access_list);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(access_name);
	
			PHALCON_INIT_NVAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_NVAR(r0);
			phalcon_array_fetch(&r0, t0, resource_name, PH_NOISY_CC);
			PHALCON_SEPARATE_NMO(r0);
			phalcon_array_unset(r0, access_name);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	} else {
		PHALCON_INIT_VAR(t1);
		phalcon_read_property(&t1, this_ptr, SL("_accessList"), PH_NOISY_CC);
		PHALCON_INIT_VAR(r1);
		phalcon_array_fetch(&r1, t1, resource_name, PH_NOISY_CC);
		PHALCON_SEPARATE_NMO(r1);
		phalcon_array_unset(r1, access_list);
	}
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, _allowOrDeny){

	zval *role_name, *resource_name, *access, *action;
	zval *roles_names, *exception_message = NULL, *resources_names;
	zval *default_access, *access_list, *access_name = NULL;
	zval *empty_arr = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL, *t8 = NULL, *t9 = NULL, *t10 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &role_name, &resource_name, &access, &action) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_names, role_name);
	if (!eval_int) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role \"", role_name, "\" does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(resources_names);
	phalcon_read_property(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(resources_names, resource_name);
	if (!eval_int) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Resource \"", resource_name, "\" does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(default_access);
	phalcon_read_property(&default_access, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
	if (Z_TYPE_P(access) == IS_ARRAY) { 
		PHALCON_INIT_VAR(access_list);
		phalcon_read_property(&access_list, this_ptr, SL("_accessList"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(access TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(access);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_VALUE(access_name);
	
			PHALCON_INIT_NVAR(r0);
			phalcon_array_fetch(&r0, access_list, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r0, access_name);
			if (!eval_int) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "Acccess '", access_name, "' does not exist in resource '", resource_name, "' in ACL");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
				return;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
	
	
		if (!phalcon_valid_foreach(access TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(access);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_VALUE(access_name);
	
			PHALCON_INIT_NVAR(t0);
			phalcon_read_property(&t0, this_ptr, SL("_access"), PH_NOISY_CC);
			PHALCON_INIT_NVAR(r1);
			phalcon_array_fetch(&r1, t0, role_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r1, resource_name);
			if (!eval_int) {
				PHALCON_INIT_NVAR(empty_arr);
				array_init(empty_arr);
	
				PHALCON_INIT_NVAR(t1);
				phalcon_read_property(&t1, this_ptr, SL("_access"), PH_NOISY_CC);
				phalcon_array_update_multi_2(&t1, role_name, resource_name, &empty_arr, 0 TSRMLS_CC);
				phalcon_update_property_zval(this_ptr, SL("_access"), t1 TSRMLS_CC);
			}
	
			PHALCON_INIT_NVAR(t2);
			phalcon_read_property(&t2, this_ptr, SL("_access"), PH_NOISY_CC);
			phalcon_array_update_zval_zval_zval_multi_3(&t2, role_name, resource_name, access_name, &action, 0 TSRMLS_CC);
	
			PHALCON_INIT_NVAR(t3);
			phalcon_read_property(&t3, this_ptr, SL("_access"), PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(r2);
			phalcon_array_fetch(&r2, t3, role_name, PH_NOISY_CC);
	
			PHALCON_INIT_NVAR(r3);
			phalcon_array_fetch(&r3, r2, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset_string(r3, SS("*"));
			if (!eval_int) {
				PHALCON_INIT_NVAR(t4);
				phalcon_read_property(&t4, this_ptr, SL("_access"), PH_NOISY_CC);
				phalcon_array_update_string_zval_zval_multi_3(&t4, role_name, resource_name, SL("*"), &default_access, 0 TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		if(0){}
	
	} else {
		if (!PHALCON_COMPARE_STRING(access, "*")) {
			PHALCON_INIT_VAR(t5);
			phalcon_read_property(&t5, this_ptr, SL("_accessList"), PH_NOISY_CC);
			PHALCON_INIT_VAR(r4);
			phalcon_array_fetch(&r4, t5, resource_name, PH_NOISY_CC);
			eval_int = phalcon_array_isset(r4, access);
			if (!eval_int) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "Acccess '", access, "' does not exist in resource '", resource_name, "' in ACL");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
				return;
			}
		}
	
		PHALCON_INIT_VAR(t6);
		phalcon_read_property(&t6, this_ptr, SL("_access"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r5);
		phalcon_array_fetch(&r5, t6, role_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset(r5, resource_name);
		if (!eval_int) {
			PHALCON_INIT_NVAR(empty_arr);
			array_init(empty_arr);
	
			PHALCON_INIT_VAR(t7);
			phalcon_read_property(&t7, this_ptr, SL("_access"), PH_NOISY_CC);
			phalcon_array_update_multi_2(&t7, role_name, resource_name, &empty_arr, 0 TSRMLS_CC);
			phalcon_update_property_zval(this_ptr, SL("_access"), t7 TSRMLS_CC);
		}
	
		PHALCON_INIT_VAR(t8);
		phalcon_read_property(&t8, this_ptr, SL("_access"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r6);
		phalcon_array_fetch(&r6, t8, role_name, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(r7);
		phalcon_array_fetch(&r7, r6, resource_name, PH_NOISY_CC);
		eval_int = phalcon_array_isset_string(r7, SS("*"));
		if (!eval_int) {
			PHALCON_INIT_VAR(t9);
			phalcon_read_property(&t9, this_ptr, SL("_access"), PH_NOISY_CC);
			phalcon_array_update_string_zval_zval_multi_3(&t9, role_name, resource_name, SL("*"), &default_access, 0 TSRMLS_CC);
		}
	
		PHALCON_INIT_VAR(t10);
		phalcon_read_property(&t10, this_ptr, SL("_access"), PH_NOISY_CC);
		phalcon_array_update_zval_zval_zval_multi_3(&t10, role_name, resource_name, access, &action, 0 TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD_NORETURN(this_ptr, "_rebuildaccesslist", PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, allow){

	zval *role_name, *resource_name, *access, *action;
	zval *status;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role_name, &resource_name, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(action);
	ZVAL_LONG(action, 1);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_4(status, this_ptr, "_allowordeny", role_name, resource_name, access, action, PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, deny){

	zval *role_name, *resource_name, *access, *action;
	zval *status;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role_name, &resource_name, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(action);
	ZVAL_LONG(action, 0);
	
	PHALCON_INIT_VAR(status);
	PHALCON_CALL_METHOD_PARAMS_4(status, this_ptr, "_allowordeny", role_name, resource_name, access, action, PH_NO_CHECK);
	
	RETURN_CCTOR(status);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, isAllowed){

	zval *role, *resource, *access, *default_access;
	zval *events_manager, *event_name = NULL, *status, *resources_names;
	zval *roles_names, *have_access = NULL, *access_roles;
	zval *resource_access = NULL, *resource_name = NULL, *same_resource = NULL;
	zval *t0 = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &role, &resource, &access) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_activeRole"), role TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_activeResource"), resource TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_activeAccess"), access TSRMLS_CC);
	
	PHALCON_INIT_VAR(default_access);
	phalcon_read_property(&default_access, this_ptr, SL("_defaultAccess"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "acl:beforeCheckAccess", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
	
			RETURN_CCTOR(status);
		}
	}
	
	PHALCON_INIT_VAR(resources_names);
	phalcon_read_property(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(resources_names, resource);
	if (!eval_int) {
	
		RETURN_CCTOR(default_access);
	}
	
	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(roles_names, role);
	if (!eval_int) {
	
		RETURN_CCTOR(default_access);
	}
	
	PHALCON_INIT_VAR(have_access);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_access"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(access_roles);
	phalcon_array_fetch(&access_roles, t0, role, PH_NOISY_CC);
	
	if (!phalcon_valid_foreach(access_roles TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(access_roles);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(resource_name, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(resource_access);
	
		PHALCON_INIT_NVAR(same_resource);
		is_equal_function(same_resource, resource_name, resource TSRMLS_CC);
		if (PHALCON_IS_TRUE(same_resource)) {
			eval_int = phalcon_array_isset(resource_access, access);
			if (eval_int) {
				PHALCON_INIT_NVAR(have_access);
				phalcon_array_fetch(&have_access, resource_access, access, PH_NOISY_CC);
				goto ph_cycle_end_0;
			}
	
			PHALCON_INIT_NVAR(have_access);
			phalcon_array_fetch_string(&have_access, resource_access, SL("*"), PH_NOISY_CC);
			goto ph_cycle_end_0;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	if (Z_TYPE_P(have_access) == IS_NULL) {
	
		if (!phalcon_valid_foreach(access_roles TSRMLS_CC)) {
			return;
		}
	
		ah1 = Z_ARRVAL_P(access_roles);
		zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_KEY(resource_name, ah1, hp1);
			PHALCON_GET_FOREACH_VALUE(resource_access);
	
			eval_int = phalcon_array_isset_string(resource_access, SS("*"));
			if (eval_int) {
				eval_int = phalcon_array_isset(resource_access, access);
				if (eval_int) {
					PHALCON_INIT_NVAR(have_access);
					phalcon_array_fetch(&have_access, resource_access, access, PH_NOISY_CC);
					goto ph_cycle_end_1;
				}
	
				PHALCON_INIT_NVAR(have_access);
				phalcon_array_fetch_string(&have_access, resource_access, SL("*"), PH_NOISY_CC);
				goto ph_cycle_end_1;
			}
	
			zend_hash_move_forward_ex(ah1, &hp1);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		if(0){}
	
	}
	
	phalcon_update_property_zval(this_ptr, SL("_accessGranted"), have_access TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "acl:afterCheckAccess", 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
	}
	
	if (Z_TYPE_P(have_access) == IS_NULL) {
		PHALCON_MM_RESTORE();
		RETURN_LONG(0);
	}
	
	
	RETURN_CCTOR(have_access);
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, getActiveRole){


	RETURN_MEMBER(this_ptr, "_activeRole");
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, getActiveResource){


	RETURN_MEMBER(this_ptr, "_activeResource");
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, getActiveAccess){


	RETURN_MEMBER(this_ptr, "_activeAccess");
}

PHP_METHOD(Phalcon_Acl_Adapter_Memory, _rebuildAccessList){

	zval *roles, *number_roles, *pow_roles, *two, *middle_roles;
	zval *middle, *roles_names, *roles_inherits;
	zval *i, *internal_access = NULL, *one = NULL, *role_name = NULL, *role_inherit = NULL;
	zval *inherit_internal = NULL, *access = NULL, *resource_name = NULL;
	zval *value = NULL, *name = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL;
	zval *t0 = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3;
	HashPosition hp0, hp1, hp2, hp3;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(roles);
	phalcon_read_property(&roles, this_ptr, SL("_roles"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(number_roles);
	phalcon_fast_count(number_roles, roles TSRMLS_CC);
	
	PHALCON_INIT_VAR(pow_roles);
	mul_function(pow_roles, number_roles, number_roles TSRMLS_CC);
	
	PHALCON_INIT_VAR(two);
	ZVAL_LONG(two, 2);
	
	PHALCON_INIT_VAR(middle_roles);
	div_function(middle_roles, pow_roles, two TSRMLS_CC);
	
	PHALCON_INIT_VAR(middle);
	PHALCON_CALL_FUNC_PARAMS_1(middle, "ceil", middle_roles);
	
	PHALCON_INIT_VAR(roles_names);
	phalcon_read_property(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(roles_inherits);
	phalcon_read_property(&roles_inherits, this_ptr, SL("_roleInherits"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(i);
	ZVAL_LONG(i, 0);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		is_smaller_or_equal_function(r0, i, middle TSRMLS_CC);
		if (!zend_is_true(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(internal_access);
		phalcon_read_property(&internal_access, this_ptr, SL("_access"), PH_NOISY_CC);
	
		if (!phalcon_valid_foreach(roles_names TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(roles_names);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_1:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_1;
			}
	
			PHALCON_GET_FOREACH_KEY(role_name, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(one);
	
			eval_int = phalcon_array_isset(roles_inherits, role_name);
			if (eval_int) {
				PHALCON_INIT_NVAR(r1);
				phalcon_array_fetch(&r1, roles_inherits, role_name, PH_NOISY_CC);
	
				if (!phalcon_valid_foreach(r1 TSRMLS_CC)) {
					return;
				}
	
				ah1 = Z_ARRVAL_P(r1);
				zend_hash_internal_pointer_reset_ex(ah1, &hp1);
	
				ph_cycle_start_2:
	
					if (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) != SUCCESS) {
						goto ph_cycle_end_2;
					}
	
					PHALCON_GET_FOREACH_VALUE(role_inherit);
	
					eval_int = phalcon_array_isset(internal_access, role_inherit);
					if (eval_int) {
						PHALCON_INIT_NVAR(inherit_internal);
						phalcon_array_fetch(&inherit_internal, internal_access, role_inherit, PH_NOISY_CC);
	
						if (!phalcon_valid_foreach(inherit_internal TSRMLS_CC)) {
							return;
						}
	
						ah2 = Z_ARRVAL_P(inherit_internal);
						zend_hash_internal_pointer_reset_ex(ah2, &hp2);
	
						ph_cycle_start_3:
	
							if (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) != SUCCESS) {
								goto ph_cycle_end_3;
							}
	
							PHALCON_GET_FOREACH_KEY(resource_name, ah2, hp2);
							PHALCON_GET_FOREACH_VALUE(access);
	
	
							if (!phalcon_valid_foreach(access TSRMLS_CC)) {
								return;
							}
	
							ah3 = Z_ARRVAL_P(access);
							zend_hash_internal_pointer_reset_ex(ah3, &hp3);
	
							ph_cycle_start_4:
	
								if (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) != SUCCESS) {
									goto ph_cycle_end_4;
								}
	
								PHALCON_GET_FOREACH_KEY(name, ah3, hp3);
								PHALCON_GET_FOREACH_VALUE(value);
	
								eval_int = phalcon_array_isset(internal_access, role_name);
								if (eval_int) {
									PHALCON_INIT_NVAR(r2);
									phalcon_array_fetch(&r2, internal_access, role_name, PH_NOISY_CC);
									eval_int = phalcon_array_isset(r2, resource_name);
									if (eval_int) {
										PHALCON_INIT_NVAR(r3);
										phalcon_array_fetch(&r3, internal_access, role_name, PH_NOISY_CC);
										PHALCON_INIT_NVAR(r4);
										phalcon_array_fetch(&r4, r3, resource_name, PH_NOISY_CC);
										eval_int = phalcon_array_isset(r4, name);
										if (eval_int) {
											zend_hash_move_forward_ex(ah3, &hp3);
											goto ph_cycle_start_4;
										}
									}
								}
	
								PHALCON_INIT_NVAR(t0);
								phalcon_read_property(&t0, this_ptr, SL("_access"), PH_NOISY_CC);
								phalcon_array_update_zval_zval_zval_multi_3(&t0, role_name, resource_name, name, &value, 0 TSRMLS_CC);
	
								zend_hash_move_forward_ex(ah3, &hp3);
								goto ph_cycle_start_4;
	
							ph_cycle_end_4:
	
	
							zend_hash_move_forward_ex(ah2, &hp2);
							goto ph_cycle_start_3;
	
						ph_cycle_end_3:
						if(0){}
	
					}
	
					zend_hash_move_forward_ex(ah1, &hp1);
					goto ph_cycle_start_2;
	
				ph_cycle_end_2:
				if(0){}
	
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_1;
	
		ph_cycle_end_1:
		if(0){}
	
		PHALCON_SEPARATE(i);
		increment_function(i);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	if(0){}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Acl_Role){

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Role, acl_role, phalcon_acl_role_method_entry, 0);

	zend_declare_property_null(phalcon_acl_role_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_role_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_role_ce TSRMLS_CC, 1, phalcon_acl_roleinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Acl_Role, __construct){

	zval *name, *description = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &description) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!description) {
		PHALCON_INIT_NVAR(description);
	}
	
	if (PHALCON_COMPARE_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_acl_exception_ce, "Role name cannot be \"*\"");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	if (Z_TYPE_P(description) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_description"), description TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Role, getName){


	RETURN_MEMBER(this_ptr, "_name");
}

PHP_METHOD(Phalcon_Acl_Role, getDescription){


	RETURN_MEMBER(this_ptr, "_description");
}

PHP_METHOD(Phalcon_Acl_Role, __toString){


	RETURN_MEMBER(this_ptr, "_name");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Acl_Resource){

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Resource, acl_resource, phalcon_acl_resource_method_entry, 0);

	zend_declare_property_null(phalcon_acl_resource_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_resource_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_resource_ce TSRMLS_CC, 1, phalcon_acl_resourceinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Acl_Resource, __construct){

	zval *name, *description = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &description) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!description) {
		PHALCON_INIT_NVAR(description);
	}
	
	if (PHALCON_COMPARE_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_acl_exception_ce, "Resource name cannot be \"*\"");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	if (Z_TYPE_P(description) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_description"), description TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Acl_Resource, getName){


	RETURN_MEMBER(this_ptr, "_name");
}

PHP_METHOD(Phalcon_Acl_Resource, getDescription){


	RETURN_MEMBER(this_ptr, "_description");
}

PHP_METHOD(Phalcon_Acl_Resource, __toString){


	RETURN_MEMBER(this_ptr, "_name");
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Acl_RoleInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, RoleInterface, acl_roleinterface, phalcon_acl_roleinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Acl_RoleInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Acl_RoleInterface, getName);

PHALCON_DOC_METHOD(Phalcon_Acl_RoleInterface, getDescription);

PHALCON_DOC_METHOD(Phalcon_Acl_RoleInterface, __toString);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Acl_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, AdapterInterface, acl_adapterinterface, phalcon_acl_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, setDefaultAction);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, getDefaultAction);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, addRole);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, addInherit);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, isRole);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, isResource);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, addResource);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, addResourceAccess);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, dropResourceAccess);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, allow);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, deny);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, isAllowed);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, getActiveRole);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, getActiveResource);

PHALCON_DOC_METHOD(Phalcon_Acl_AdapterInterface, getActiveAccess);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Acl_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Acl, Exception, acl_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Session_Adapter_Files){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session\\Adapter, Files, session_adapter_files, "phalcon\\session\\adapter", NULL, 0);

	zend_class_implements(phalcon_session_adapter_files_ce TSRMLS_CC, 1, phalcon_session_adapterinterface_ce);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Session_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Session, Adapter, session_adapter, phalcon_session_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_session_adapter_ce, SL("_uniqueId"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_session_adapter_ce, SL("_started"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_adapter_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Session_Adapter, __construct){

	zval *options = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "setoptions", options, PH_NO_CHECK);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Adapter, start){

	zval *headers_sent;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(headers_sent);
	PHALCON_CALL_FUNC(headers_sent, "headers_sent");
	if (PHALCON_IS_FALSE(headers_sent)) {
		PHALCON_CALL_FUNC_NORETURN("session_start");
		phalcon_update_property_bool(this_ptr, SL("_started"), 1 TSRMLS_CC);
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Session_Adapter, setOptions){

	zval *options, *unique_id;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(options) == IS_ARRAY) { 
		eval_int = phalcon_array_isset_string(options, SS("uniqueId"));
		if (eval_int) {
			PHALCON_INIT_VAR(unique_id);
			phalcon_array_fetch_string(&unique_id, options, SL("uniqueId"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_uniqueId"), unique_id TSRMLS_CC);
		}
		phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "Options must be an Array");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Adapter, getOptions){

	zval *options;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	
	RETURN_CCTOR(options);
}

PHP_METHOD(Phalcon_Session_Adapter, get){

	zval *index, *unique_id, *key, *value;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unique_id);
	phalcon_read_property(&unique_id, this_ptr, SL("_uniqueId"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, unique_id, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, key);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, g0, key, PH_NOISY_CC);
	
		RETURN_CCTOR(value);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Session_Adapter, set){

	zval *index, *value, *unique_id, *key;
	zval *g0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &index, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unique_id);
	phalcon_read_property(&unique_id, this_ptr, SL("_uniqueId"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, unique_id, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	phalcon_array_update_zval(&g0, key, &value, PH_COPY TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Adapter, has){

	zval *index, *unique_id, *key;
	zval *g0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unique_id);
	phalcon_read_property(&unique_id, this_ptr, SL("_uniqueId"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, unique_id, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	eval_int = phalcon_array_isset(g0, key);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}

PHP_METHOD(Phalcon_Session_Adapter, remove){

	zval *index, *unique_id, *key;
	zval *g0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(unique_id);
	phalcon_read_property(&unique_id, this_ptr, SL("_uniqueId"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, unique_id, index);
	phalcon_get_global(&g0, SL("_SESSION")+1 TSRMLS_CC);
	phalcon_array_unset(g0, key);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Adapter, getId){

	zval *session_id;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(session_id);
	PHALCON_CALL_FUNC(session_id, "session_id");
	
	RETURN_CCTOR(session_id);
}

PHP_METHOD(Phalcon_Session_Adapter, isStarted){

	zval *started;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(started);
	phalcon_read_property(&started, this_ptr, SL("_started"), PH_NOISY_CC);
	
	RETURN_CCTOR(started);
}

PHP_METHOD(Phalcon_Session_Adapter, destroy){

	zval *destroyed;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(destroyed);
	PHALCON_CALL_FUNC(destroyed, "session_destroy");
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	RETURN_CCTOR(destroyed);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Session_Bag){

	PHALCON_REGISTER_CLASS(Phalcon\\Session, Bag, session_bag, phalcon_session_bag_method_entry, 0);

	zend_declare_property_null(phalcon_session_bag_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_session_bag_ce, SL("_initalized"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_session"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_session_bag_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_session_baginterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Session_Bag, __construct){

	zval *name;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_session_bag_ce, this_ptr, SL("_data") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(name) == IS_STRING) {
		phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "The dependency injector must be an Object");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Bag, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "The dependency injector must be an Object");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Bag, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Session_Bag, initialize){

	zval *dependency_injector, *service, *session;
	zval *name, *data = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "A dependency injection object is required to access the 'session' service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "session", 1);
	
	PHALCON_INIT_VAR(session);
	PHALCON_CALL_METHOD_PARAMS_1(session, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(name);
	phalcon_read_property(&name, this_ptr, SL("_name"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(data);
	PHALCON_CALL_METHOD_PARAMS_1(data, session, "get", name, PH_NO_CHECK);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(data);
		array_init(data);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_data"), data TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_session"), session TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_initalized"), 1 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Bag, destroy){

	zval *initalized, *name, *session;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(initalized);
	phalcon_read_property(&initalized, this_ptr, SL("_initalized"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(initalized)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "initialize", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(name);
	phalcon_read_property(&name, this_ptr, SL("_name"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(session);
	phalcon_read_property(&session, this_ptr, SL("_session"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(session, "remove", name, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Bag, __set){

	zval *property, *value, *initalized, *name, *data;
	zval *session;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &property, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initalized);
	phalcon_read_property(&initalized, this_ptr, SL("_initalized"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(initalized)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "initialize", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_data"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, property, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_data"), t0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(name);
	phalcon_read_property(&name, this_ptr, SL("_name"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(data);
	phalcon_read_property(&data, this_ptr, SL("_data"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(session);
	phalcon_read_property(&session, this_ptr, SL("_session"), PH_NOISY_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(session, "set", name, data, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Session_Bag, __get){

	zval *property, *initalized, *data, *value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initalized);
	phalcon_read_property(&initalized, this_ptr, SL("_initalized"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(initalized)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "initialize", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(data);
	phalcon_read_property(&data, this_ptr, SL("_data"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(data, property);
	if (eval_int) {
		PHALCON_INIT_VAR(value);
		phalcon_array_fetch(&value, data, property, PH_NOISY_CC);
	
		RETURN_CCTOR(value);
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Session_Bag, __isset){

	zval *property, *initalized, *data;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(initalized);
	phalcon_read_property(&initalized, this_ptr, SL("_initalized"), PH_NOISY_CC);
	if (PHALCON_IS_FALSE(initalized)) {
		PHALCON_CALL_METHOD_NORETURN(this_ptr, "initialize", PH_NO_CHECK);
	}
	
	PHALCON_INIT_VAR(data);
	phalcon_read_property(&data, this_ptr, SL("_data"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(data, property);
	if (eval_int) {
		PHALCON_MM_RESTORE();
		RETURN_TRUE;
	}
	
	PHALCON_MM_RESTORE();
	RETURN_FALSE;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Session_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Session, AdapterInterface, session_adapterinterface, phalcon_session_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, start);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, setOptions);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, getOptions);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, get);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, set);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, has);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, remove);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, getId);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, isStarted);

PHALCON_DOC_METHOD(Phalcon_Session_AdapterInterface, destroy);





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Session_BagInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Session, BagInterface, session_baginterface, phalcon_session_baginterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Session_BagInterface, initialize);

PHALCON_DOC_METHOD(Phalcon_Session_BagInterface, destroy);

PHALCON_DOC_METHOD(Phalcon_Session_BagInterface, __set);

PHALCON_DOC_METHOD(Phalcon_Session_BagInterface, __get);

PHALCON_DOC_METHOD(Phalcon_Session_BagInterface, __isset);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Session_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session, Exception, session_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Flash_Direct){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Direct, flash_direct, "phalcon\\flash", phalcon_flash_direct_method_entry, 0);

	zend_class_implements(phalcon_flash_direct_ce TSRMLS_CC, 1, phalcon_flashinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Flash_Direct, message){

	zval *type, *message, *flash_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &type, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(flash_message);
	PHALCON_CALL_METHOD_PARAMS_2(flash_message, this_ptr, "outputmessage", type, message, PH_NO_CHECK);
	
	RETURN_CCTOR(flash_message);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Flash_Session){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Session, flash_session, "phalcon\\flash", phalcon_flash_session_method_entry, 0);

	zend_declare_property_null(phalcon_flash_session_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_flash_session_ce TSRMLS_CC, 2, phalcon_flashinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Flash_Session, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Flash_Session, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Flash_Session, _getSessionMessages){

	zval *remove, *dependency_injector, *service;
	zval *session, *index_name, *messages;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &remove) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_flash_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "session", 1);
	
	PHALCON_INIT_VAR(session);
	PHALCON_CALL_METHOD_PARAMS_1(session, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(index_name);
	ZVAL_STRING(index_name, "_flashMessages", 1);
	
	PHALCON_INIT_VAR(messages);
	PHALCON_CALL_METHOD_PARAMS_1(messages, session, "get", index_name, PH_NO_CHECK);
	if (PHALCON_IS_TRUE(remove)) {
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(session, "remove", index_name, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(messages);
}

PHP_METHOD(Phalcon_Flash_Session, _setSessionMessages){

	zval *messages = NULL, *dependency_injector, *service;
	zval *session, *index_name;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &messages) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_SEPARATE_PARAM(messages);
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_flash_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "session", 1);
	
	PHALCON_INIT_VAR(session);
	PHALCON_CALL_METHOD_PARAMS_1(session, dependency_injector, "getshared", service, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(index_name);
	ZVAL_STRING(index_name, "_flashMessages", 1);
	
	PHALCON_INIT_VAR(r0);
	PHALCON_CALL_METHOD_PARAMS_2(r0, session, "set", index_name, messages, PH_NO_CHECK);
	PHALCON_CPY_WRT(messages, r0);
	
	RETURN_CCTOR(messages);
}

PHP_METHOD(Phalcon_Flash_Session, message){

	zval *type, *message, *remove, *messages = NULL;
	zval *a0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &type, &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(remove);
	ZVAL_BOOL(remove, 0);
	
	PHALCON_INIT_VAR(messages);
	PHALCON_CALL_METHOD_PARAMS_1(messages, this_ptr, "_getsessionmessages", remove, PH_NO_CHECK);
	if (Z_TYPE_P(messages) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(messages);
		array_init(messages);
	}
	
	eval_int = phalcon_array_isset(messages, type);
	if (!eval_int) {
		PHALCON_INIT_VAR(a0);
		array_init(a0);
		phalcon_array_update_zval(&messages, type, &a0, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	phalcon_array_update_append_multi_2(&messages, type, message, 0 TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_setsessionmessages", messages, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Flash_Session, getMessages){

	zval *type = NULL, *remove = NULL, *messages, *return_messages;
	zval *empty_arr;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|zz", &type, &remove) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!type) {
		PHALCON_INIT_NVAR(type);
	}
	
	if (!remove) {
		PHALCON_INIT_NVAR(remove);
		ZVAL_BOOL(remove, 1);
	}
	
	PHALCON_INIT_VAR(messages);
	PHALCON_CALL_METHOD_PARAMS_1(messages, this_ptr, "_getsessionmessages", remove, PH_NO_CHECK);
	if (Z_TYPE_P(messages) == IS_ARRAY) { 
		if (Z_TYPE_P(type) == IS_STRING) {
			eval_int = phalcon_array_isset(messages, type);
			if (eval_int) {
				PHALCON_INIT_VAR(return_messages);
				phalcon_array_fetch(&return_messages, messages, type, PH_NOISY_CC);
	
				RETURN_CCTOR(return_messages);
			}
		}
	
		RETURN_CCTOR(messages);
	}
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);
	
	RETURN_CTOR(empty_arr);
}

PHP_METHOD(Phalcon_Flash_Session, output){

	zval *remove = NULL, *messages, *message = NULL, *type = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &remove) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!remove) {
		PHALCON_INIT_NVAR(remove);
		ZVAL_BOOL(remove, 1);
	}
	
	PHALCON_INIT_VAR(messages);
	PHALCON_CALL_METHOD_PARAMS_1(messages, this_ptr, "_getsessionmessages", remove, PH_NO_CHECK);
	if (Z_TYPE_P(messages) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(messages TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(messages);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(type, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(message);
	
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "outputmessage", type, message, PH_NO_CHECK);
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Flash_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Exception, flash_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Loader_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Loader, Exception, loader_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Tag_Select){

	PHALCON_REGISTER_CLASS(Phalcon\\Tag, Select, tag_select, phalcon_tag_select_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Tag_Select, selectField){

	zval *parameters, *data = NULL, *params = NULL, *eol, *id = NULL, *name, *value = NULL;
	zval *dummy_value = NULL, *dummy_text = NULL, *code, *avalue = NULL;
	zval *key = NULL, *close_option, *options = NULL, *using, *resultset_options;
	zval *array_options;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &parameters, &data) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!data) {
		PHALCON_INIT_NVAR(data);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init(params);
		phalcon_array_append(&params, parameters, PH_SEPARATE TSRMLS_CC);
		phalcon_array_append(&params, data, PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	eval_int = phalcon_array_isset_long(params, 0);
	if (!eval_int) {
		PHALCON_INIT_VAR(id);
		phalcon_array_fetch_string(&id, params, SL("id"), PH_NOISY_CC);
		phalcon_array_update_long(&params, 0, &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	PHALCON_INIT_NVAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(params, SS("name"));
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(name);
		phalcon_array_fetch_string(&name, params, SL("name"), PH_NOISY_CC);
		if (!zend_is_true(name)) {
			phalcon_array_update_string(&params, SL("name"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(params, SS("id"));
	if (!eval_int) {
		phalcon_array_update_string(&params, SL("id"), &id, PH_COPY | PH_SEPARATE TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(params, SS("value"));
	if (!eval_int) {
		PHALCON_INIT_VAR(value);
		PHALCON_CALL_STATIC_PARAMS_1(value, "phalcon\\tag", "getvalue", id);
	} else {
		PHALCON_INIT_NVAR(value);
		phalcon_array_fetch_string(&value, params, SL("value"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SS("value"));
	}
	
	eval_int = phalcon_array_isset_string(params, SS("dummyValue"));
	if (!eval_int) {
		PHALCON_INIT_VAR(dummy_value);
		ZVAL_STRING(dummy_value, "", 1);
	} else {
		PHALCON_INIT_NVAR(dummy_value);
		phalcon_array_fetch_string(&dummy_value, params, SL("dummyValue"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SS("dummyValue"));
	}
	
	eval_int = phalcon_array_isset_string(params, SS("dummyText"));
	if (!eval_int) {
		PHALCON_INIT_VAR(dummy_text);
		ZVAL_STRING(dummy_text, "Choose...", 1);
	} else {
		PHALCON_INIT_NVAR(dummy_text);
		phalcon_array_fetch_string(&dummy_text, params, SL("dummyText"), PH_NOISY_CC);
		PHALCON_SEPARATE(params);
		phalcon_array_unset_string(params, SS("dummyText"));
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<select", 1);
	if (Z_TYPE_P(params) == IS_ARRAY) { 
	
		if (!phalcon_valid_foreach(params TSRMLS_CC)) {
			return;
		}
	
		ah0 = Z_ARRVAL_P(params);
		zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
		ph_cycle_start_0:
	
			if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
			PHALCON_GET_FOREACH_VALUE(avalue);
	
			if (Z_TYPE_P(key) != IS_LONG) {
				if (Z_TYPE_P(avalue) != IS_ARRAY) { 
					PHALCON_SCONCAT_SVSVS(code, " ", key, "=\"", avalue, "\"");
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			goto ph_cycle_start_0;
	
		ph_cycle_end_0:
		if(0){}
	
	}
	
	PHALCON_SCONCAT_SV(code, ">", eol);
	
	PHALCON_INIT_VAR(close_option);
	PHALCON_CONCAT_SV(close_option, "</option>", eol);
	eval_int = phalcon_array_isset_string(params, SS("useDummy"));
	if (eval_int) {
		PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", dummy_value, "\">", dummy_text, close_option);
	}
	
	eval_int = phalcon_array_isset_long(params, 1);
	if (eval_int) {
		PHALCON_INIT_VAR(options);
		phalcon_array_fetch_long(&options, params, 1, PH_NOISY_CC);
	} else {
		PHALCON_CPY_WRT(options, data);
	}
	
	if (Z_TYPE_P(options) == IS_OBJECT) {
		eval_int = phalcon_array_isset_string(params, SS("using"));
		if (!eval_int) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter is required");
			return;
		} else {
			PHALCON_INIT_VAR(using);
			phalcon_array_fetch_string(&using, params, SL("using"), PH_NOISY_CC);
			if (Z_TYPE_P(using) != IS_ARRAY) { 
				PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter should be an Array");
				return;
			}
		}
	
		PHALCON_INIT_VAR(resultset_options);
		PHALCON_CALL_SELF_PARAMS_4(resultset_options, this_ptr, "_optionsfromresultset", options, using, value, close_option);
		phalcon_concat_self(code, resultset_options TSRMLS_CC);
	} else {
		if (Z_TYPE_P(options) == IS_ARRAY) { 
			PHALCON_INIT_VAR(array_options);
			PHALCON_CALL_SELF_PARAMS_3(array_options, this_ptr, "_optionsfromarray", options, value, close_option);
			phalcon_concat_self(code, array_options TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Invalid data provided to SELECT helper");
			return;
		}
	}
	
	phalcon_concat_self_str(code, SL("</select>") TSRMLS_CC);
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag_Select, _optionsFromResultset){

	zval *resultset, *using, *value, *close_option;
	zval *code, *using_zero = NULL, *using_one = NULL, *option = NULL, *option_value = NULL;
	zval *option_text = NULL, *is_equals = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzzz", &resultset, &using, &value, &close_option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "", 1);
	PHALCON_CALL_METHOD_NORETURN(resultset, "rewind", PH_NO_CHECK);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(r0);
		PHALCON_CALL_METHOD(r0, resultset, "valid", PH_NO_CHECK);
		if (PHALCON_IS_NOT_TRUE(r0)) {
			goto ph_cycle_end_0;
		}
		PHALCON_INIT_NVAR(using_zero);
		phalcon_array_fetch_long(&using_zero, using, 0, PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(using_one);
		phalcon_array_fetch_long(&using_one, using, 1, PH_NOISY_CC);
	
		PHALCON_INIT_NVAR(option);
		PHALCON_CALL_METHOD(option, resultset, "current", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(option_value);
		PHALCON_CALL_METHOD_PARAMS_1(option_value, option, "readattribute", using_zero, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(option_text);
		PHALCON_CALL_METHOD_PARAMS_1(option_text, option, "readattribute", using_one, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(is_equals);
		is_equal_function(is_equals, value, option_value TSRMLS_CC);
		if (PHALCON_IS_TRUE(is_equals)) {
			PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", option_value, "\">", option_text, close_option);
		} else {
			PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", option_value, "\">", option_text, close_option);
		}
	
		PHALCON_CALL_METHOD_NORETURN(resultset, "next", PH_NO_CHECK);
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	
	RETURN_CTOR(code);
}

PHP_METHOD(Phalcon_Tag_Select, _optionsFromArray){

	zval *data, *value, *close_option, *code, *option_text = NULL;
	zval *option_value = NULL, *is_equals = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &data, &value, &close_option) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "", 1);
	
	if (!phalcon_valid_foreach(data TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(data);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_KEY(option_value, ah0, hp0);
		PHALCON_GET_FOREACH_VALUE(option_text);
	
		PHALCON_INIT_NVAR(is_equals);
		is_equal_function(is_equals, value, option_value TSRMLS_CC);
		if (PHALCON_IS_TRUE(is_equals)) {
			PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", option_value, "\">", option_text, close_option);
		} else {
			PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", option_value, "\">", option_text, close_option);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	
	
	RETURN_CTOR(code);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Tag_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Tag, Exception, tag_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_CLI_Task){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI, Task, cli_task, "phalcon\\di\\injectable", phalcon_cli_task_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_CLI_Task, __construct){


	
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_CLI_Console_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Console, Exception, cli_console_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_CLI_Router_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Router, Exception, cli_router_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_CLI_Router){

	PHALCON_REGISTER_CLASS(Phalcon\\CLI, Router, cli_router, phalcon_cli_router_method_entry, 0);

	zend_declare_property_null(phalcon_cli_router_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_module"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_task"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultModule"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultTask"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultAction"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultParams"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cli_router_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_CLI_Router, __construct){


	phalcon_update_property_empty_array(phalcon_cli_router_ce, this_ptr, SL("_params") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_cli_router_ce, this_ptr, SL("_defaultParams") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Router, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Router, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_CLI_Router, setDefaultModule){

	zval *module_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &module_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultModule"), module_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Router, setDefaultTask){

	zval *task_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &task_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultTask"), task_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Router, setDefaultAction){

	zval *action_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAction"), action_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Router, handle){

	int i;
	zval *arguments = NULL, *arguments_count, *params, *arg = NULL;
	zval *module_name, *default_module;
	zval *task_name, *default_task, *task_name_tmp, *task_name_parts;
	zval *delimiter, *status;
	zval *action_name, *default_action;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
	}

	if (Z_TYPE_P(arguments) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_router_exception_ce, "Arguments must be an Array");
		return;
	}

	// initial and set default to null
	PHALCON_INIT_VAR(module_name);
	PHALCON_INIT_VAR(task_name);
	PHALCON_INIT_VAR(task_name_tmp);
	PHALCON_INIT_VAR(action_name);
	PHALCON_INIT_VAR(params);
	PHALCON_INIT_VAR(delimiter);

	array_init(params);

	phalcon_update_property_zval(this_ptr, SL("_module"), module_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_task"), task_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_action"), action_name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);

	ZVAL_STRING(delimiter, ":", 1);

	PHALCON_INIT_VAR(arguments_count);
	phalcon_fast_count(arguments_count, arguments TSRMLS_CC);

	if (Z_LVAL_P(arguments_count) > 3) {
		// script, task, action, params.....
		phalcon_array_fetch_long(&task_name_tmp, arguments, 1, PH_NOISY_CC);
		phalcon_array_fetch_long(&action_name, arguments, 2, PH_NOISY_CC);

		// process params
		for (i = 3; i < Z_LVAL_P(arguments_count); i++) {
			PHALCON_INIT_NVAR(arg);
			phalcon_array_fetch_long(&arg, arguments, i, PH_NOISY_CC);
			phalcon_array_append(&params, arg, PH_SEPARATE TSRMLS_CC);
		}
	} else {
		if (Z_LVAL_P(arguments_count) > 2) {
			// script, task, action
			phalcon_array_fetch_long(&task_name_tmp, arguments, 1, PH_NOISY_CC);
			phalcon_array_fetch_long(&action_name, arguments, 2, PH_NOISY_CC);
		} else {
			if (Z_LVAL_P(arguments_count) > 1) {
				// script, task
				phalcon_array_fetch_long(&task_name_tmp, arguments, 1, PH_NOISY_CC);
			}
		}
	}

	// if task_name settings, parse task_name for module_name
	if (Z_TYPE_P(task_name_tmp) != IS_NULL) {

		PHALCON_INIT_VAR(task_name_parts);
		phalcon_fast_explode(task_name_parts, delimiter, task_name_tmp TSRMLS_CC);

		PHALCON_INIT_VAR(status);
		phalcon_fast_count(status, task_name_parts TSRMLS_CC);
		if (Z_LVAL_P(status) == 2) {
			PHALCON_INIT_NVAR(module_name);
			PHALCON_INIT_NVAR(task_name);
			phalcon_array_fetch_long(&module_name, task_name_parts, 0, PH_NOISY_CC);
			phalcon_array_fetch_long(&task_name, task_name_parts, 1, PH_NOISY_CC);
		}else {
			PHALCON_INIT_NVAR(task_name);
			phalcon_array_fetch_long(&task_name, task_name_parts, 0, PH_NOISY_CC);
		}
	}

	// update properties
	if (Z_TYPE_P(module_name) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_module"), module_name TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(default_module);
		phalcon_read_property(&default_module, this_ptr, SL("_defaultModule"), PH_NOISY_CC);
		if (Z_TYPE_P(default_module) != IS_NULL) {
			phalcon_update_property_zval(this_ptr, SL("_module"), default_module TSRMLS_CC);
		}
	}

	PHALCON_INIT_NVAR(module_name);
	phalcon_read_property(&module_name, this_ptr, SL("_module"), PH_NOISY_CC);

	if (Z_TYPE_P(task_name) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_task"), task_name TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(default_task);
		phalcon_read_property(&default_task, this_ptr, SL("_defaultTask"), PH_NOISY_CC);
		if (Z_TYPE_P(default_task) != IS_NULL) {
			phalcon_update_property_zval(this_ptr, SL("_task"), default_task TSRMLS_CC);
		}
	}

	PHALCON_INIT_NVAR(task_name);
	phalcon_read_property(&task_name, this_ptr, SL("_task"), PH_NOISY_CC);

	if (Z_TYPE_P(action_name) != IS_NULL) {
		phalcon_update_property_zval(this_ptr, SL("_action"), action_name TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(default_action);
		phalcon_read_property(&default_action, this_ptr, SL("_defaultAction"), PH_NOISY_CC);
		if (Z_TYPE_P(default_action) != IS_NULL) {
			phalcon_update_property_zval(this_ptr, SL("_action"), default_action TSRMLS_CC);
		}
	}

	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_CLI_Router, getModuleName){


	RETURN_MEMBER(this_ptr, "_module");
}

PHP_METHOD(Phalcon_CLI_Router, getTaskName){


	RETURN_MEMBER(this_ptr, "_task");
}

PHP_METHOD(Phalcon_CLI_Router, getActionName){


	RETURN_MEMBER(this_ptr, "_action");
}

PHP_METHOD(Phalcon_CLI_Router, getParams){


	RETURN_MEMBER(this_ptr, "_params");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_CLI_Console){

	PHALCON_REGISTER_CLASS(Phalcon\\CLI, Console, cli_console, phalcon_cli_console_method_entry, 0);

	zend_declare_property_null(phalcon_cli_console_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_modules"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_moduleObject"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cli_console_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_CLI_Console, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Dependency Injector is invalid");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_CLI_Console, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_CLI_Console, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Console, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_CLI_Console, registerModules){

	zval *modules;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &modules) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Modules must be an Array");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_modules"), modules TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_CLI_Console, addModules){

	zval *modules, *original_modules, *register_modules;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &modules) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Modules must be an Array");
		return;
	}
	
	PHALCON_INIT_VAR(original_modules);
	phalcon_read_property(&original_modules, this_ptr, SL("_modules"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(register_modules);
	PHALCON_CALL_FUNC_PARAMS_2(register_modules, "array_merge", modules, original_modules);
	phalcon_update_property_zval(this_ptr, SL("_modules"), register_modules TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_CLI_Console, getModules){


	RETURN_MEMBER(this_ptr, "_modules");
}

PHP_METHOD(Phalcon_CLI_Console, handle){

	zval *arguments = NULL, *dependency_injector, *events_manager;
	zval *service = NULL, *router, *module_name, *event_name = NULL;
	zval *status = NULL, *modules, *exception_msg = NULL, *module;
	zval *path, *class_name = NULL, *module_object, *task_name;
	zval *action_name, *params, *dispatcher, *task;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_INIT_NVAR(arguments);
		array_init(arguments);
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "A dependency injection object is required to access internal services");
		return;
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "router", 1);
	
	PHALCON_INIT_VAR(router);
	PHALCON_CALL_METHOD_PARAMS_1(router, dependency_injector, "getshared", service, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(router, "handle", arguments, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(module_name);
	PHALCON_CALL_METHOD(module_name, router, "getmodulename", PH_NO_CHECK);
	if (zend_is_true(module_name)) {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "console:beforeStartModule", 1);
	
			PHALCON_INIT_VAR(status);
			PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, module_name, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	
		PHALCON_INIT_VAR(modules);
		phalcon_read_property(&modules, this_ptr, SL("_modules"), PH_NOISY_CC);
		eval_int = phalcon_array_isset(modules, module_name);
		if (!eval_int) {
			PHALCON_INIT_VAR(exception_msg);
			PHALCON_CONCAT_SVS(exception_msg, "Module '", module_name, "' isn't registered in the console container");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_cli_console_exception_ce, exception_msg);
			return;
		}
	
		PHALCON_INIT_VAR(module);
		phalcon_array_fetch(&module, modules, module_name, PH_NOISY_CC);
		if (Z_TYPE_P(module) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Invalid module definition path");
			return;
		}
	
		eval_int = phalcon_array_isset_string(module, SS("path"));
		if (eval_int) {
			PHALCON_INIT_VAR(path);
			phalcon_array_fetch_string(&path, module, SL("path"), PH_NOISY_CC);
			if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
				if (phalcon_require(path TSRMLS_CC) == FAILURE) {
					return;
				}
			} else {
				PHALCON_INIT_NVAR(exception_msg);
				PHALCON_CONCAT_SVS(exception_msg, "Module definition path '", path, "\" doesn't exists");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_cli_console_exception_ce, exception_msg);
				return;
			}
		}
	
		eval_int = phalcon_array_isset_string(module, SS("className"));
		if (eval_int) {
			PHALCON_INIT_VAR(class_name);
			phalcon_array_fetch_string(&class_name, module, SL("className"), PH_NOISY_CC);
		} else {
			PHALCON_INIT_NVAR(class_name);
			ZVAL_STRING(class_name, "Module", 1);
		}
	
		PHALCON_INIT_VAR(module_object);
		PHALCON_CALL_METHOD_PARAMS_1(module_object, dependency_injector, "get", class_name, PH_NO_CHECK);
		PHALCON_CALL_METHOD_NORETURN(module_object, "registerautoloaders", PH_NO_CHECK);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(module_object, "registerservices", dependency_injector, PH_NO_CHECK);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			phalcon_update_property_zval(this_ptr, SL("_moduleObject"), module_object TSRMLS_CC);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "console:afterStartModule", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, module_name, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_MM_RESTORE();
				RETURN_FALSE;
			}
		}
	}
	
	PHALCON_INIT_VAR(task_name);
	PHALCON_CALL_METHOD(task_name, router, "gettaskname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(action_name);
	PHALCON_CALL_METHOD(action_name, router, "getactionname", PH_NO_CHECK);
	
	PHALCON_INIT_VAR(params);
	PHALCON_CALL_METHOD(params, router, "getparams", PH_NO_CHECK);
	
	PHALCON_INIT_NVAR(service);
	ZVAL_STRING(service, "dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	PHALCON_CALL_METHOD_PARAMS_1(dispatcher, dependency_injector, "getshared", service, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "settaskname", task_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setactionname", action_name, PH_NO_CHECK);
	PHALCON_CALL_METHOD_PARAMS_1_NORETURN(dispatcher, "setparams", params, PH_NO_CHECK);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "console:beforeHandleTask", 1);
	
		PHALCON_INIT_NVAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, dispatcher, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(task);
	PHALCON_CALL_METHOD(task, dispatcher, "dispatch", PH_NO_CHECK);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "console:afterHandleTask", 1);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "fire", event_name, this_ptr, task, PH_NO_CHECK);
	}
	
	
	RETURN_CCTOR(task);
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_CLI_Dispatcher_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Dispatcher, Exception, cli_dispatcher_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_CLI_Dispatcher){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI, Dispatcher, cli_dispatcher, "phalcon\\dispatcher", phalcon_cli_dispatcher_method_entry, 0);

	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_handlerSuffix"), "Task", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_defaultHandler"), "main", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_defaultAction"), "main", ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskSuffix){

	zval *task_suffix;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &task_suffix) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_handlerSuffix"), task_suffix TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Dispatcher, setDefaultTask){

	zval *task_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &task_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultHandler"), task_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskName){

	zval *task_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &task_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_handlerName"), task_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_CLI_Dispatcher, getTaskName){


	RETURN_MEMBER(this_ptr, "_handlerName");
}

PHP_METHOD(Phalcon_CLI_Dispatcher, _throwDispatchException){

	zval *message, *exception_code = NULL, *exception, *events_manager;
	zval *event_name, *status;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &exception_code) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!exception_code) {
		PHALCON_INIT_NVAR(exception_code);
		ZVAL_LONG(exception_code, 0);
	}
	
	PHALCON_INIT_VAR(exception);
	object_init_ex(exception, phalcon_cli_dispatcher_exception_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(exception, "__construct", message, exception_code, PH_CHECK);
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, exception, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	phalcon_throw_exception(exception TSRMLS_CC);
	return;
}

PHP_METHOD(Phalcon_CLI_Dispatcher, getLastTask){


	RETURN_MEMBER(this_ptr, "_lastHandler");
}

PHP_METHOD(Phalcon_CLI_Dispatcher, getActiveTask){


	RETURN_MEMBER(this_ptr, "_activeHandler");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Logger_Adapter_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Adapter, File, logger_adapter_file, "phalcon\\logger\\adapter", phalcon_logger_adapter_file_method_entry, 0);

	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_fileHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_logger_adapter_file_ce, SL("_transaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_path"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_quenue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_logger_adapter_file_ce, SL("_dateFormat"), "D, d M y H:i:s O", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_logger_adapter_file_ce, SL("_format"), "[%date%][%type%] %message%", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_adapter_file_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Logger_Adapter_File, __construct){

	zval *name, *options = NULL, *mode = NULL, *handler, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_logger_adapter_file_ce, this_ptr, SL("_quenue") TSRMLS_CC);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!options) {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}
	
	eval_int = phalcon_array_isset_string(options, SS("mode"));
	if (eval_int) {
		PHALCON_INIT_VAR(mode);
		phalcon_array_fetch_string(&mode, options, SL("mode"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}
	if (phalcon_memnstr_str(mode, SL("r") TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "Logger must be opened in append or write mode");
		return;
	}
	
	PHALCON_INIT_VAR(handler);
	PHALCON_CALL_FUNC_PARAMS_2(handler, "fopen", name, mode);
	if (!zend_is_true(handler)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Can't open log file at '", name, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_logger_exception_ce, exception_message);
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_path"), name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_options"), options TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_fileHandler"), handler TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter_File, setFormat){

	zval *format;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &format) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_format"), format TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Logger_Adapter_File, getFormat){


	RETURN_MEMBER(this_ptr, "_format");
}

PHP_METHOD(Phalcon_Logger_Adapter_File, _applyFormat){

	zval *message, *type, *time = NULL, *format = NULL, *date_format;
	zval *date, *date_wildcard, *new_format = NULL, *type_string;
	zval *type_wildcard, *message_wildcard;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &message, &type, &time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!time) {
		PHALCON_INIT_NVAR(time);
		ZVAL_LONG(time, 0);
	} else {
		PHALCON_SEPARATE_PARAM(time);
	}
	
	if (!zend_is_true(time)) {
		PHALCON_INIT_NVAR(time);
		PHALCON_CALL_FUNC(time, "time");
	}
	
	PHALCON_INIT_VAR(format);
	phalcon_read_property(&format, this_ptr, SL("_format"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(date_format);
	phalcon_read_property(&date_format, this_ptr, SL("_dateFormat"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(date);
	PHALCON_CALL_FUNC_PARAMS_2(date, "date", date_format, time);
	
	PHALCON_INIT_VAR(date_wildcard);
	ZVAL_STRING(date_wildcard, "%date%", 1);
	
	PHALCON_INIT_VAR(new_format);
	phalcon_fast_str_replace(new_format, date_wildcard, date, format TSRMLS_CC);
	
	PHALCON_INIT_VAR(type_string);
	PHALCON_CALL_METHOD_PARAMS_1(type_string, this_ptr, "gettypestring", type, PH_NO_CHECK);
	
	PHALCON_INIT_VAR(type_wildcard);
	ZVAL_STRING(type_wildcard, "%type%", 1);
	
	PHALCON_INIT_NVAR(format);
	phalcon_fast_str_replace(format, type_wildcard, type_string, new_format TSRMLS_CC);
	
	PHALCON_INIT_VAR(message_wildcard);
	ZVAL_STRING(message_wildcard, "%message%", 1);
	
	PHALCON_INIT_NVAR(new_format);
	phalcon_fast_str_replace(new_format, message_wildcard, message, format TSRMLS_CC);
	
	RETURN_CTOR(new_format);
}

PHP_METHOD(Phalcon_Logger_Adapter_File, setDateFormat){

	zval *date;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &date) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dateFormat"), date TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Logger_Adapter_File, getDateFormat){


	RETURN_MEMBER(this_ptr, "_dateFormat");
}

PHP_METHOD(Phalcon_Logger_Adapter_File, log){

	zval *message, *type = NULL, *file_handler, *transaction;
	zval *time, *quenue_item, *applied_format, *eol;
	zval *applied_eol;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!type) {
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 7);
	}
	
	PHALCON_INIT_VAR(file_handler);
	phalcon_read_property(&file_handler, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	if (!zend_is_true(file_handler)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "Cannot send message to the log because it is invalid");
		return;
	}
	
	PHALCON_INIT_VAR(transaction);
	phalcon_read_property(&transaction, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (zend_is_true(transaction)) {
		PHALCON_INIT_VAR(time);
		PHALCON_CALL_FUNC(time, "time");
	
		PHALCON_INIT_VAR(quenue_item);
		object_init_ex(quenue_item, phalcon_logger_item_ce);
		PHALCON_CALL_METHOD_PARAMS_3_NORETURN(quenue_item, "__construct", message, type, time, PH_CHECK);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_quenue"), PH_NOISY_CC);
		phalcon_array_append(&t0, quenue_item, 0 TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_quenue"), t0 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(applied_format);
		PHALCON_CALL_METHOD_PARAMS_2(applied_format, this_ptr, "_applyformat", message, type, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(eol);
		zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	
		PHALCON_INIT_VAR(applied_eol);
		PHALCON_CONCAT_VV(applied_eol, applied_format, eol);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("fwrite", file_handler, applied_eol);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter_File, begin){


	phalcon_update_property_bool(this_ptr, SL("_transaction"), 1 TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Logger_Adapter_File, commit){

	zval *transaction, *file_handler, *quenue, *eol;
	zval *message = NULL, *message_str = NULL, *type = NULL, *time = NULL, *applied_format = NULL;
	zval *applied_eol = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(transaction);
	phalcon_read_property(&transaction, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (!zend_is_true(transaction)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(file_handler);
	phalcon_read_property(&file_handler, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(quenue);
	phalcon_read_property(&quenue, this_ptr, SL("_quenue"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(eol);
	zend_get_constant(SL("PHP_EOL"), eol TSRMLS_CC);
	
	if (!phalcon_valid_foreach(quenue TSRMLS_CC)) {
		return;
	}
	
	ah0 = Z_ARRVAL_P(quenue);
	zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
	ph_cycle_start_0:
	
		if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
			goto ph_cycle_end_0;
		}
	
		PHALCON_GET_FOREACH_VALUE(message);
	
		PHALCON_INIT_NVAR(message_str);
		PHALCON_CALL_METHOD(message_str, message, "getmessage", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(type);
		PHALCON_CALL_METHOD(type, message, "gettype", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(time);
		PHALCON_CALL_METHOD(time, message, "gettime", PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(applied_format);
		PHALCON_CALL_METHOD_PARAMS_3(applied_format, this_ptr, "_applyformat", message_str, type, time, PH_NO_CHECK);
	
		PHALCON_INIT_NVAR(applied_eol);
		PHALCON_CONCAT_VV(applied_eol, applied_format, eol);
		PHALCON_CALL_FUNC_PARAMS_2_NORETURN("fwrite", file_handler, applied_eol);
	
		zend_hash_move_forward_ex(ah0, &hp0);
		goto ph_cycle_start_0;
	
	ph_cycle_end_0:
	if(0){}
	
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter_File, rollback){

	zval *transaction, *quenue;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(transaction);
	phalcon_read_property(&transaction, this_ptr, SL("_transaction"), PH_NOISY_CC);
	if (!zend_is_true(transaction)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(quenue);
	array_init(quenue);
	phalcon_update_property_zval(this_ptr, SL("_quenue"), quenue TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter_File, close){

	zval *file_handler, *success;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(file_handler);
	phalcon_read_property(&file_handler, this_ptr, SL("_fileHandler"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(success);
	PHALCON_CALL_FUNC_PARAMS_1(success, "fclose", file_handler);
	
	RETURN_CCTOR(success);
}

PHP_METHOD(Phalcon_Logger_Adapter_File, __wakeup){

	zval *path, *options, *mode = NULL, *file_handler;
	int eval_int;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(path);
	phalcon_read_property(&path, this_ptr, SL("_path"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(options);
	phalcon_read_property(&options, this_ptr, SL("_options"), PH_NOISY_CC);
	eval_int = phalcon_array_isset_string(options, SS("mode"));
	if (eval_int) {
		PHALCON_INIT_VAR(mode);
		phalcon_array_fetch_string(&mode, options, SL("mode"), PH_NOISY_CC);
	} else {
		PHALCON_INIT_NVAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}
	
	PHALCON_INIT_VAR(file_handler);
	PHALCON_CALL_FUNC_PARAMS_2(file_handler, "fopen", path, mode);
	phalcon_update_property_zval(this_ptr, SL("_fileHandler"), file_handler TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Logger_Item){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Item, logger_item, phalcon_logger_item_method_entry, 0);

	zend_declare_property_null(phalcon_logger_item_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_time"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Logger_Item, __construct){

	zval *message, *type, *time = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &message, &type, &time) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!time) {
		PHALCON_INIT_NVAR(time);
		ZVAL_LONG(time, 0);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_message"), message TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_type"), type TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_time"), time TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Item, getMessage){


	RETURN_MEMBER(this_ptr, "_message");
}

PHP_METHOD(Phalcon_Logger_Item, getType){


	RETURN_MEMBER(this_ptr, "_type");
}

PHP_METHOD(Phalcon_Logger_Item, getTime){


	RETURN_MEMBER(this_ptr, "_time");
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Logger_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Adapter, logger_adapter, phalcon_logger_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Logger_Adapter, getTypeString){

	zval *type, *type_str = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	
	if (phalcon_compare_strict_long(type, 7 TSRMLS_CC)) {
		PHALCON_INIT_VAR(type_str);
		ZVAL_STRING(type_str, "DEBUG", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 3 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "ERROR", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 4 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "WARNING", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 1 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "CRITICAL", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 8 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "CUSTOM", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 2 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "ALERT", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 5 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "NOTICE", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 6 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "INFO", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 0 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "EMERGENCE", 1);
		goto ph_end_0;
	}
	
	if (phalcon_compare_strict_long(type, 9 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(type_str);
		ZVAL_STRING(type_str, "SPECIAL", 1);
		goto ph_end_0;
	}
	
	PHALCON_INIT_NVAR(type_str);
	ZVAL_STRING(type_str, "CUSTOM", 1);
	
	ph_end_0:
	
	RETURN_CTOR(type_str);
}

PHP_METHOD(Phalcon_Logger_Adapter, debug){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("DEBUG") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, error){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("ERROR") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, info){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("INFO") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, notice){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("NOTICE") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, warning){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("WARNING") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, alert){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &message) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(type);
	phalcon_get_class_constant(type, phalcon_logger_ce, SS("ALERT") TSRMLS_CC);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "log", message, type, PH_NO_CHECK);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Logger_Adapter, log){

	zval *message, *type;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &message, &type) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "This method must be implemented by an adapter");
	return;
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Logger_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Logger, AdapterInterface, logger_adapterinterface, phalcon_logger_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, setFormat);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, getFormat);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, getTypeString);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, setDateFormat);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, getDateFormat);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, log);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, begin);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, commit);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, rollback);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, close);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, debug);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, error);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, info);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, notice);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, warning);

PHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, alert);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Logger_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger, Exception, logger_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_DI){

	PHALCON_REGISTER_CLASS(Phalcon, DI, di, phalcon_di_method_entry, 0);

	zend_declare_property_null(phalcon_di_ce, SL("_services"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_ce, SL("_sharedInstances"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_di_ce, SL("_freshInstance"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_ce, SL("_default"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_class_implements(phalcon_di_ce TSRMLS_CC, 1, phalcon_diinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_DI, __construct){

	zval *default_di = NULL;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(phalcon_di_ce, this_ptr, SL("_services") TSRMLS_CC);
	
	phalcon_update_property_empty_array(phalcon_di_ce, this_ptr, SL("_sharedInstances") TSRMLS_CC);
	
	PHALCON_OBSERVE_VAR(default_di);
	phalcon_read_static_property(&default_di, SL("phalcon\\di"), SL("_default") TSRMLS_CC);
	if (!zend_is_true(default_di)) {
		phalcon_update_static_property(SL("phalcon\\di"), SL("_default"), this_ptr TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_DI, set){

	zval *name, *config, *shared = NULL, *service;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &name, &config, &shared) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!shared) {
		PHALCON_INIT_NVAR(shared);
		ZVAL_BOOL(shared, 0);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	object_init_ex(service, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(service, "__construct", name, config, shared, PH_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_services"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, name, &service, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_services"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_DI, setShared){

	zval *name, *config, *shared, *service;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &name, &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(shared);
	ZVAL_BOOL(shared, 1);
	
	PHALCON_INIT_VAR(service);
	object_init_ex(service, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(service, "__construct", name, config, shared, PH_CHECK);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_services"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, name, &service, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_services"), t0 TSRMLS_CC);
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_DI, remove){

	zval *name;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_services"), PH_NOISY_CC);
	PHALCON_SEPARATE_NMO(t0);
	phalcon_array_unset(t0, name);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_DI, attempt){

	zval *name, *config, *shared = NULL, *services, *service;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &name, &config, &shared) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!shared) {
		PHALCON_INIT_NVAR(shared);
		ZVAL_BOOL(shared, 0);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(services);
	phalcon_read_property(&services, this_ptr, SL("_services"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(services, name);
	if (!eval_int) {
		PHALCON_INIT_VAR(service);
		object_init_ex(service, phalcon_di_service_ce);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(service, "__construct", name, config, PH_CHECK);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_services"), PH_NOISY_CC);
		phalcon_array_update_zval(&t0, name, &service, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_services"), t0 TSRMLS_CC);
	}
	
	
	RETURN_CTOR(this_ptr);
}

PHP_METHOD(Phalcon_DI, getRaw){

	zval *name, *services, *service, *definition, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(services);
	phalcon_read_property(&services, this_ptr, SL("_services"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(services, name);
	if (eval_int) {
		PHALCON_INIT_VAR(service);
		phalcon_array_fetch(&service, services, name, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(definition);
		PHALCON_CALL_METHOD(definition, service, "getdefinition", PH_NO_CHECK);
	
		RETURN_CCTOR(definition);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Service '", name, "' wasn't found in the dependency injection container");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_DI, get){

	zval *name, *parameters = NULL, *services, *service, *instance = NULL;
	zval *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service alias must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(services);
	phalcon_read_property(&services, this_ptr, SL("_services"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(services, name);
	if (eval_int) {
		PHALCON_INIT_VAR(service);
		phalcon_array_fetch(&service, services, name, PH_NOISY_CC);
	
		PHALCON_INIT_VAR(instance);
		PHALCON_CALL_METHOD_PARAMS_1(instance, service, "resolve", parameters, PH_NO_CHECK);
	} else {
		if (phalcon_class_exists(name TSRMLS_CC)) {
			if (Z_TYPE_P(parameters) == IS_ARRAY) { 
				if (phalcon_fast_count_ev(parameters TSRMLS_CC)) {
					PHALCON_INIT_NVAR(instance);
					if (phalcon_create_instance_params(instance, name, parameters TSRMLS_CC) == FAILURE) {
						return;
					}
				} else {
					PHALCON_INIT_NVAR(instance);
					if (phalcon_create_instance(instance, name TSRMLS_CC) == FAILURE) {
						return;
					}
				}
			} else {
				PHALCON_INIT_NVAR(instance);
				if (phalcon_create_instance(instance, name TSRMLS_CC) == FAILURE) {
					return;
				}
			}
		} else {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Service '", name, "' wasn't found in the dependency injection container");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
			return;
		}
	}
	
	if (Z_TYPE_P(instance) == IS_OBJECT) {
		if (phalcon_method_exists_ex(instance, SS("setdi") TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(instance, "setdi", this_ptr, PH_NO_CHECK);
		}
	}
	
	
	RETURN_CCTOR(instance);
}

PHP_METHOD(Phalcon_DI, getShared){

	zval *name, *parameters = NULL, *shared_instances, *instance = NULL;
	zval *t0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &name, &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service alias must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(shared_instances);
	phalcon_read_property(&shared_instances, this_ptr, SL("_sharedInstances"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(shared_instances, name);
	if (eval_int) {
		PHALCON_INIT_VAR(instance);
		phalcon_array_fetch(&instance, shared_instances, name, PH_NOISY_CC);
		phalcon_update_property_bool(this_ptr, SL("_freshInstance"), 0 TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(instance);
		PHALCON_CALL_METHOD_PARAMS_2(instance, this_ptr, "get", name, parameters, PH_NO_CHECK);
	
		PHALCON_INIT_VAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_sharedInstances"), PH_NOISY_CC);
		phalcon_array_update_zval(&t0, name, &instance, PH_COPY TSRMLS_CC);
		phalcon_update_property_zval(this_ptr, SL("_sharedInstances"), t0 TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_freshInstance"), 1 TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(instance);
}

PHP_METHOD(Phalcon_DI, has){

	zval *name, *services, *is_set_service = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(services);
	phalcon_read_property(&services, this_ptr, SL("_services"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(services, name);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(is_set_service, r0);
	
	RETURN_NCTOR(is_set_service);
}

PHP_METHOD(Phalcon_DI, wasFreshInstance){


	RETURN_MEMBER(this_ptr, "_freshInstance");
}

PHP_METHOD(Phalcon_DI, __call){

	zval *method, *arguments = NULL, *three, *services, *service_name = NULL;
	zval *possible_service = NULL, *instance = NULL, *handler;
	zval *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &method, &arguments) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!arguments) {
		PHALCON_INIT_NVAR(arguments);
		array_init(arguments);
	}
	
	PHALCON_INIT_VAR(three);
	ZVAL_LONG(three, 3);
	if (phalcon_start_with_str(method, SL("get"))) {
		PHALCON_INIT_VAR(services);
		phalcon_read_property(&services, this_ptr, SL("_services"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(service_name);
		PHALCON_CALL_FUNC_PARAMS_2(service_name, "substr", method, three);
	
		PHALCON_INIT_VAR(possible_service);
		PHALCON_CALL_FUNC_PARAMS_1(possible_service, "lcfirst", service_name);
		eval_int = phalcon_array_isset(services, possible_service);
		if (eval_int) {
			if (phalcon_fast_count_ev(arguments TSRMLS_CC)) {
				PHALCON_INIT_VAR(instance);
				PHALCON_CALL_METHOD_PARAMS_2(instance, this_ptr, "get", possible_service, arguments, PH_NO_CHECK);
			} else {
				PHALCON_INIT_NVAR(instance);
				PHALCON_CALL_METHOD_PARAMS_1(instance, this_ptr, "get", possible_service, PH_NO_CHECK);
			}
	
			RETURN_CCTOR(instance);
		}
	} else {
		if (phalcon_start_with_str(method, SL("set"))) {
			eval_int = phalcon_array_isset_long(arguments, 0);
			if (eval_int) {
				PHALCON_INIT_NVAR(service_name);
				PHALCON_CALL_FUNC_PARAMS_2(service_name, "substr", method, three);
	
				PHALCON_INIT_NVAR(possible_service);
				PHALCON_CALL_FUNC_PARAMS_1(possible_service, "lcfirst", service_name);
	
				PHALCON_INIT_VAR(handler);
				phalcon_array_fetch_long(&handler, arguments, 0, PH_NOISY_CC);
				PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "set", possible_service, handler, PH_NO_CHECK);
				PHALCON_MM_RESTORE();
				RETURN_NULL();
			}
		}
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Call to undefined method or service '", method, "'");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
	return;
}

PHP_METHOD(Phalcon_DI, setDefault){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_static_property(SL("phalcon\\di"), SL("_default"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_DI, getDefault){

	zval *default_di = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBSERVE_VAR(default_di);
	phalcon_read_static_property(&default_di, SL("phalcon\\di"), SL("_default") TSRMLS_CC);
	
	RETURN_CCTOR(default_di);
}

PHP_METHOD(Phalcon_DI, reset){

	zval *null_value;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(null_value);
	phalcon_update_static_property(SL("phalcon\\di"), SL("_default"), null_value TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Paginator_Adapter_Model){

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, Model, paginator_adapter_model, phalcon_paginator_adapter_model_method_entry, 0);

	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_config"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_paginator_adapter_model_ce TSRMLS_CC, 1, phalcon_paginator_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Paginator_Adapter_Model, __construct){

	zval *config, *limit, *page;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_config"), config TSRMLS_CC);
	eval_int = phalcon_array_isset_string(config, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, config, SL("limit"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_limitRows"), limit TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(config, SS("page"));
	if (eval_int) {
		PHALCON_INIT_VAR(page);
		phalcon_array_fetch_string(&page, config, SL("page"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Paginator_Adapter_Model, setCurrentPage){

	zval *page;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &page) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Paginator_Adapter_Model, getPaginate){

	zval *show, *config, *items, *page_number = NULL, *zero, *one;
	zval *smaller, *n, *page, *last_show_page, *start;
	zval *last_page, *possible_pages = NULL, *total_pages;
	zval *compare = NULL, *page_items, *i, *valid = NULL, *current = NULL, *maximum_pages;
	zval *next = NULL, *additional_page, *before = NULL, *remainder;
	zval *pages_total = NULL;
	zval *r0 = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(show);
	phalcon_read_property(&show, this_ptr, SL("_limitRows"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(config);
	phalcon_read_property(&config, this_ptr, SL("_config"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(items);
	phalcon_array_fetch_string(&items, config, SL("data"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(page_number);
	phalcon_read_property(&page_number, this_ptr, SL("_page"), PH_NOISY_CC);
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_NVAR(page_number);
		ZVAL_LONG(page_number, 1);
	}
	
	PHALCON_INIT_VAR(zero);
	ZVAL_LONG(zero, 0);
	
	PHALCON_INIT_VAR(one);
	ZVAL_LONG(one, 1);
	
	PHALCON_INIT_VAR(smaller);
	is_smaller_function(smaller, show, zero TSRMLS_CC);
	if (PHALCON_IS_TRUE(smaller)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "The start page number is zero or less");
		return;
	}
	
	PHALCON_INIT_VAR(n);
	phalcon_fast_count(n, items TSRMLS_CC);
	
	PHALCON_INIT_VAR(page);
	object_init(page);
	
	PHALCON_INIT_VAR(last_show_page);
	sub_function(last_show_page, page_number, one TSRMLS_CC);
	
	PHALCON_INIT_VAR(start);
	mul_function(start, show, last_show_page TSRMLS_CC);
	
	PHALCON_INIT_VAR(last_page);
	sub_function(last_page, n, one TSRMLS_CC);
	
	PHALCON_INIT_VAR(possible_pages);
	div_function(possible_pages, last_page, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(total_pages);
	PHALCON_CALL_FUNC_PARAMS_1(total_pages, "ceil", possible_pages);
	if (Z_TYPE_P(items) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}
	
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_NVAR(page_number);
		ZVAL_LONG(page_number, 0);
	}
	
	PHALCON_INIT_VAR(compare);
	is_smaller_function(compare, start, zero TSRMLS_CC);
	if (PHALCON_IS_TRUE(compare)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "The start page number is zero or less");
		return;
	}
	
	PHALCON_INIT_VAR(page_items);
	array_init(page_items);
	
	is_smaller_function(compare, zero, n TSRMLS_CC);
	if (PHALCON_IS_TRUE(compare)) {
		is_smaller_or_equal_function(compare, start, n TSRMLS_CC);
		if (PHALCON_IS_TRUE(compare)) {
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(items, "seek", start, PH_NO_CHECK);
		} else {
			PHALCON_CALL_METHOD_PARAMS_1_NORETURN(items, "seek", one, PH_NO_CHECK);
	
			PHALCON_INIT_NVAR(page_number);
			ZVAL_LONG(page_number, 1);
		}
	
		PHALCON_INIT_VAR(i);
		ZVAL_LONG(i, 1);
		ph_cycle_start_0:
	
			PHALCON_INIT_NVAR(r0);
			PHALCON_CALL_METHOD(r0, items, "valid", PH_NO_CHECK);
			PHALCON_CPY_WRT(valid, r0);
			if (PHALCON_IS_NOT_TRUE(valid)) {
				goto ph_cycle_end_0;
			}
			PHALCON_INIT_NVAR(current);
			PHALCON_CALL_METHOD(current, items, "current", PH_NO_CHECK);
			phalcon_array_append(&page_items, current, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(compare);
			is_smaller_or_equal_function(compare, show, i TSRMLS_CC);
			if (PHALCON_IS_TRUE(compare)) {
				goto ph_cycle_end_0;
			}
	
			PHALCON_SEPARATE(i);
			increment_function(i);
			goto ph_cycle_start_0;
		ph_cycle_end_0:
		if(0){}
	}
	
	phalcon_update_property_zval(page, SL("items"), page_items TSRMLS_CC);
	phalcon_update_property_long(page, SL("first"), 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(maximum_pages);
	phalcon_add_function(maximum_pages, start, show TSRMLS_CC);
	
	is_smaller_function(compare, maximum_pages, n TSRMLS_CC);
	if (PHALCON_IS_TRUE(compare)) {
		PHALCON_INIT_VAR(t0);
		ZVAL_LONG(t0, 1);
		PHALCON_INIT_VAR(next);
		phalcon_add_function(next, page_number, t0 TSRMLS_CC);
	} else {
		is_equal_function(compare, maximum_pages, n TSRMLS_CC);
		if (PHALCON_IS_TRUE(compare)) {
			PHALCON_CPY_WRT(next, n);
		} else {
			div_function(possible_pages, n, show TSRMLS_CC);
	
			PHALCON_INIT_VAR(additional_page);
			phalcon_add_function(additional_page, possible_pages, one TSRMLS_CC);
	
			PHALCON_INIT_NVAR(next);
			PHALCON_CALL_FUNC_PARAMS_1(next, "intval", additional_page);
		}
	}
	
	is_smaller_function(compare, total_pages, next TSRMLS_CC);
	if (PHALCON_IS_TRUE(compare)) {
		PHALCON_CPY_WRT(next, total_pages);
	}
	
	phalcon_update_property_zval(page, SL("next"), next TSRMLS_CC);
	
	is_smaller_function(compare, one, page_number TSRMLS_CC);
	if (PHALCON_IS_TRUE(compare)) {
		PHALCON_INIT_VAR(before);
		sub_function(before, page_number, one TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(before);
		ZVAL_LONG(before, 1);
	}
	
	phalcon_update_property_zval(page, SL("before"), before TSRMLS_CC);
	phalcon_update_property_zval(page, SL("current"), page_number TSRMLS_CC);
	
	PHALCON_INIT_VAR(remainder);
	mod_function(remainder, n, show TSRMLS_CC);
	
	div_function(possible_pages, n, show TSRMLS_CC);
	if (!phalcon_compare_strict_long(remainder, 0 TSRMLS_CC)) {
		PHALCON_INIT_NVAR(next);
		phalcon_add_function(next, possible_pages, one TSRMLS_CC);
	
		PHALCON_INIT_VAR(pages_total);
		PHALCON_CALL_FUNC_PARAMS_1(pages_total, "intval", possible_pages);
	} else {
		PHALCON_CPY_WRT(pages_total, possible_pages);
	}
	
	phalcon_update_property_zval(page, SL("last"), pages_total TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_pages"), pages_total TSRMLS_CC);
	
	RETURN_CTOR(page);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Paginator_Adapter_NativeArray){

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, NativeArray, paginator_adapter_nativearray, phalcon_paginator_adapter_nativearray_method_entry, 0);

	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_config"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_paginator_adapter_nativearray_ce TSRMLS_CC, 1, phalcon_paginator_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, __construct){

	zval *config, *limit, *page;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &config) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_config"), config TSRMLS_CC);
	eval_int = phalcon_array_isset_string(config, SS("limit"));
	if (eval_int) {
		PHALCON_INIT_VAR(limit);
		phalcon_array_fetch_string(&limit, config, SL("limit"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_limitRows"), limit TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(config, SS("page"));
	if (eval_int) {
		PHALCON_INIT_VAR(page);
		phalcon_array_fetch_string(&page, config, SL("page"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, setCurrentPage){

	zval *page;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &page) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_page"), page TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, getPaginate){

	zval *show, *items, *page_number = NULL, *n, *page, *start, *total_pages = NULL;
	zval *next = NULL, *before = NULL, *res, *div, *t_pages = NULL;
	zval *t0 = NULL, *t1 = NULL, *t2 = NULL, *t3 = NULL, *t4 = NULL, *t5 = NULL, *t6 = NULL;
	zval *t7 = NULL;
	zval *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *r4 = NULL, *r5 = NULL, *r6 = NULL;
	zval *r7 = NULL, *r8 = NULL, *r9 = NULL, *r10 = NULL, *r11 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(show);
	phalcon_read_property(&show, this_ptr, SL("_limitRows"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_config"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(items);
	phalcon_array_fetch_string(&items, t0, SL("data"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(page_number);
	phalcon_read_property(&page_number, this_ptr, SL("_page"), PH_NOISY_CC);
	if (Z_TYPE_P(page_number) == IS_NULL) {
		PHALCON_INIT_NVAR(page_number);
		ZVAL_LONG(page_number, 1);
	}
	
	PHALCON_INIT_VAR(n);
	phalcon_fast_count(n, items TSRMLS_CC);
	
	PHALCON_INIT_VAR(page);
	object_init(page);
	
	PHALCON_INIT_VAR(t1);
	ZVAL_LONG(t1, 1);
	
	PHALCON_INIT_VAR(r0);
	sub_function(r0, page_number, t1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(start);
	mul_function(start, show, r0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(t2);
	ZVAL_LONG(t2, 1);
	
	PHALCON_INIT_VAR(r1);
	sub_function(r1, n, t2 TSRMLS_CC);
	
	PHALCON_INIT_VAR(r2);
	div_function(r2, r1, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(total_pages);
	PHALCON_CALL_FUNC_PARAMS_1(total_pages, "round", r2);
	if (Z_TYPE_P(items) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}
	
	PHALCON_INIT_VAR(r3);
	PHALCON_CALL_FUNC_PARAMS_3(r3, "array_slice", items, start, show);
	phalcon_update_property_zval(page, SL("items"), r3 TSRMLS_CC);
	phalcon_update_property_long(page, SL("first"), 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(r4);
	phalcon_add_function(r4, start, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(r5);
	is_smaller_function(r5, r4, n TSRMLS_CC);
	if (zend_is_true(r5)) {
		PHALCON_INIT_VAR(t3);
		ZVAL_LONG(t3, 1);
		PHALCON_INIT_VAR(next);
		phalcon_add_function(next, page_number, t3 TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(r6);
		phalcon_add_function(r6, start, show TSRMLS_CC);
		PHALCON_INIT_VAR(r7);
		is_equal_function(r7, r6, n TSRMLS_CC);
		if (zend_is_true(r7)) {
			PHALCON_CPY_WRT(next, n);
		} else {
			PHALCON_INIT_VAR(r8);
			div_function(r8, n, show TSRMLS_CC);
			PHALCON_INIT_VAR(t4);
			ZVAL_LONG(t4, 1);
			PHALCON_INIT_NVAR(next);
			phalcon_add_function(next, r8, t4 TSRMLS_CC);
		}
	
		PHALCON_INIT_VAR(r9);
		PHALCON_CALL_FUNC_PARAMS_1(r9, "intval", next);
		PHALCON_CPY_WRT(next, r9);
	}
	
	PHALCON_INIT_VAR(r10);
	is_smaller_function(r10, total_pages, next TSRMLS_CC);
	if (zend_is_true(r10)) {
		PHALCON_CPY_WRT(next, total_pages);
	}
	
	phalcon_update_property_zval(page, SL("next"), next TSRMLS_CC);
	
	PHALCON_INIT_VAR(t5);
	ZVAL_LONG(t5, 1);
	
	PHALCON_INIT_VAR(r11);
	is_smaller_function(r11, t5, page_number TSRMLS_CC);
	if (zend_is_true(r11)) {
		PHALCON_INIT_VAR(t6);
		ZVAL_LONG(t6, 1);
		PHALCON_INIT_VAR(before);
		sub_function(before, page_number, t6 TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(before);
		ZVAL_LONG(before, 1);
	}
	
	phalcon_update_property_zval(page, SL("before"), before TSRMLS_CC);
	phalcon_update_property_zval(page, SL("current"), page_number TSRMLS_CC);
	
	PHALCON_INIT_VAR(res);
	mod_function(res, n, show TSRMLS_CC);
	
	PHALCON_INIT_VAR(div);
	div_function(div, n, show TSRMLS_CC);
	if (zend_is_true(res)) {
		PHALCON_INIT_VAR(t7);
		ZVAL_LONG(t7, 1);
		PHALCON_INIT_VAR(t_pages);
		phalcon_add_function(t_pages, div, t7 TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(t_pages, div);
	}
	
	PHALCON_INIT_NVAR(total_pages);
	PHALCON_CALL_FUNC_PARAMS_1(total_pages, "intval", t_pages);
	phalcon_update_property_zval(page, SL("last"), total_pages TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_pages"), total_pages TSRMLS_CC);
	
	RETURN_CTOR(page);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Paginator_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Paginator, AdapterInterface, paginator_adapterinterface, phalcon_paginator_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Paginator_AdapterInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Paginator_AdapterInterface, setCurrentPage);

PHALCON_DOC_METHOD(Phalcon_Paginator_AdapterInterface, getPaginate);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Paginator_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Paginator, Exception, paginator_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Translate_Adapter_NativeArray){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate\\Adapter, NativeArray, translate_adapter_nativearray, "phalcon\\translate\\adapter", phalcon_translate_adapter_nativearray_method_entry, 0);

	zend_declare_property_null(phalcon_translate_adapter_nativearray_ce, SL("_translate"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_translate_adapter_nativearray_ce TSRMLS_CC, 1, phalcon_translate_adapterinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, __construct){

	zval *options, *data;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &options) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Invalid options");
		return;
	}
	eval_int = phalcon_array_isset_string(options, SS("content"));
	if (eval_int) {
		PHALCON_INIT_VAR(data);
		phalcon_array_fetch_string(&data, options, SL("content"), PH_NOISY_CC);
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translation data must be an array");
			return;
		}
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translation content was not provided");
		return;
	}
	
	phalcon_update_property_zval(this_ptr, SL("_translate"), data TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, query){

	zval *index, *placeholders = NULL, *translate, *translation = NULL;
	zval *value = NULL, *key = NULL, *key_placeholder = NULL, *replaced = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	char *hash_index;
	uint hash_index_len;
	ulong hash_num;
	int hash_type;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &index, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	PHALCON_INIT_VAR(translate);
	phalcon_read_property(&translate, this_ptr, SL("_translate"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(translate, index);
	if (eval_int) {
		PHALCON_INIT_VAR(translation);
		phalcon_array_fetch(&translation, translate, index, PH_NOISY_CC);
		if (Z_TYPE_P(placeholders) == IS_ARRAY) { 
			if (phalcon_fast_count_ev(placeholders TSRMLS_CC)) {
	
				if (!phalcon_valid_foreach(placeholders TSRMLS_CC)) {
					return;
				}
	
				ah0 = Z_ARRVAL_P(placeholders);
				zend_hash_internal_pointer_reset_ex(ah0, &hp0);
	
				ph_cycle_start_0:
	
					if (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) != SUCCESS) {
						goto ph_cycle_end_0;
					}
	
					PHALCON_GET_FOREACH_KEY(key, ah0, hp0);
					PHALCON_GET_FOREACH_VALUE(value);
	
					PHALCON_INIT_NVAR(key_placeholder);
					PHALCON_CONCAT_SVS(key_placeholder, "%", key, "%");
	
					PHALCON_INIT_NVAR(replaced);
					phalcon_fast_str_replace(replaced, key_placeholder, value, translation TSRMLS_CC);
					PHALCON_CPY_WRT(translation, replaced);
	
					zend_hash_move_forward_ex(ah0, &hp0);
					goto ph_cycle_start_0;
	
				ph_cycle_end_0:
				if(0){}
	
			}
		}
	
	
		RETURN_CCTOR(translation);
	}
	
	
	RETURN_CCTOR(index);
}

PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, exists){

	zval *index, *translate, *exists = NULL;
	zval *r0 = NULL;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &index) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(translate);
	phalcon_read_property(&translate, this_ptr, SL("_translate"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(translate, index);
	
	PHALCON_INIT_VAR(r0);
	ZVAL_BOOL(r0, eval_int);
	PHALCON_CPY_WRT(exists, r0);
	
	RETURN_NCTOR(exists);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Translate_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Translate, Adapter, translate_adapter, phalcon_translate_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_class_implements(phalcon_translate_adapter_ce TSRMLS_CC, 1, zend_ce_arrayaccess);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Translate_Adapter, _){

	zval *translate_key, *placeholders = NULL, *translation;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &translate_key, &placeholders) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!placeholders) {
		PHALCON_INIT_NVAR(placeholders);
	}
	
	PHALCON_INIT_VAR(translation);
	PHALCON_CALL_METHOD_PARAMS_2(translation, this_ptr, "query", translate_key, placeholders, PH_NO_CHECK);
	
	RETURN_CCTOR(translation);
}

PHP_METHOD(Phalcon_Translate_Adapter, offsetSet){

	zval *offset, *value;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &offset, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translate is an immutable ArrayAccess object");
	return;
}

PHP_METHOD(Phalcon_Translate_Adapter, offsetExists){

	zval *translate_key, *exists;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &translate_key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(exists);
	PHALCON_CALL_METHOD_PARAMS_1(exists, this_ptr, "exists", translate_key, PH_NO_CHECK);
	
	RETURN_CCTOR(exists);
}

PHP_METHOD(Phalcon_Translate_Adapter, offsetUnset){

	zval *offset;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &offset) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_THROW_EXCEPTION_STR(phalcon_translate_exception_ce, "Translate is an immutable ArrayAccess object");
	return;
}

PHP_METHOD(Phalcon_Translate_Adapter, offsetGet){

	zval *traslate_key, *null_value, *translation;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &traslate_key) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(translation);
	PHALCON_CALL_METHOD_PARAMS_2(translation, this_ptr, "query", traslate_key, null_value, PH_NO_CHECK);
	
	RETURN_CCTOR(translation);
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_Translate_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Translate, AdapterInterface, translate_adapterinterface, phalcon_translate_adapterinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_Translate_AdapterInterface, __construct);

PHALCON_DOC_METHOD(Phalcon_Translate_AdapterInterface, _);

PHALCON_DOC_METHOD(Phalcon_Translate_AdapterInterface, query);

PHALCON_DOC_METHOD(Phalcon_Translate_AdapterInterface, exists);





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Translate_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate, Exception, translate_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Db){

	PHALCON_REGISTER_CLASS(Phalcon, Db, db, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_ASSOC"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_BOTH"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_NUM"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_OBJ"), 4 TSRMLS_CC);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon, Exception, exception, "exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_DI_FactoryDefault_CLI){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI\\FactoryDefault, CLI, di_factorydefault_cli, "phalcon\\di\\factorydefault", phalcon_di_factorydefault_cli_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_DI_FactoryDefault_CLI, __construct){

	zval *shared, *name = NULL, *definition = NULL, *router, *dispatcher;
	zval *models_manager, *models_metadata, *filter;
	zval *escaper, *flash, *flash_session, *events_manager;
	zval *transaction_manager, *services;

	PHALCON_MM_GROW();

	PHALCON_CALL_PARENT_NORETURN(this_ptr, "Phalcon\\DI\\FactoryDefault\\CLI", "__construct");
	
	PHALCON_INIT_VAR(shared);
	ZVAL_BOOL(shared, 1);
	
	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "router", 1);
	
	PHALCON_INIT_VAR(definition);
	ZVAL_STRING(definition, "Phalcon\\CLI\\Router", 1);
	
	PHALCON_INIT_VAR(router);
	object_init_ex(router, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(router, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "dispatcher", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\CLI\\Dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	object_init_ex(dispatcher, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(dispatcher, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "modelsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Manager", 1);
	
	PHALCON_INIT_VAR(models_manager);
	object_init_ex(models_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(models_manager, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "modelsMetadata", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Metadata\\Memory", 1);
	
	PHALCON_INIT_VAR(models_metadata);
	object_init_ex(models_metadata, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(models_metadata, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "filter", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Filter", 1);
	
	PHALCON_INIT_VAR(filter);
	object_init_ex(filter, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(filter, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "escaper", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Escaper", 1);
	
	PHALCON_INIT_VAR(escaper);
	object_init_ex(escaper, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(escaper, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flash", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Direct", 1);
	
	PHALCON_INIT_VAR(flash);
	object_init_ex(flash, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(flash, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flashSession", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Session", 1);
	
	PHALCON_INIT_VAR(flash_session);
	object_init_ex(flash_session, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(flash_session, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "eventsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Events\\Manager", 1);
	
	PHALCON_INIT_VAR(events_manager);
	object_init_ex(events_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Transaction\\Manager", 1);
	
	PHALCON_INIT_VAR(transaction_manager);
	object_init_ex(transaction_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(transaction_manager, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_VAR(services);
	array_init(services);
	phalcon_array_update_string(&services, SL("router"), &router, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("dispatcher"), &dispatcher, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("modelsManager"), &models_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("modelsMetadata"), &models_metadata, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("filter"), &filter, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("escaper"), &escaper, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("flash"), &flash, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("flashSession"), &flash_session, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("eventsManager"), &events_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("transactionManager"), &transaction_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_services"), services TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif



PHALCON_INIT_CLASS(Phalcon_DI_InjectionAwareInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\DI, InjectionAwareInterface, di_injectionawareinterface, phalcon_di_injectionawareinterface_method_entry);

	return SUCCESS;
}

PHALCON_DOC_METHOD(Phalcon_DI_InjectionAwareInterface, setDI);

PHALCON_DOC_METHOD(Phalcon_DI_InjectionAwareInterface, getDI);





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_DI_FactoryDefault){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI, FactoryDefault, di_factorydefault, "phalcon\\di", phalcon_di_factorydefault_method_entry, 0);

	return SUCCESS;
}

PHP_METHOD(Phalcon_DI_FactoryDefault, __construct){

	zval *shared, *name = NULL, *definition = NULL, *router, *dispatcher;
	zval *url, *models_manager, *models_metadata;
	zval *response, *request, *filter, *escaper, *flash;
	zval *flash_session, *session, *session_bag;
	zval *events_manager, *transaction_manager;
	zval *services;

	PHALCON_MM_GROW();

	PHALCON_CALL_PARENT_NORETURN(this_ptr, "Phalcon\\DI\\FactoryDefault", "__construct");
	
	PHALCON_INIT_VAR(shared);
	ZVAL_BOOL(shared, 1);
	
	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "router", 1);
	
	PHALCON_INIT_VAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Router", 1);
	
	PHALCON_INIT_VAR(router);
	object_init_ex(router, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(router, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "dispatcher", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	object_init_ex(dispatcher, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(dispatcher, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "url", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Url", 1);
	
	PHALCON_INIT_VAR(url);
	object_init_ex(url, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(url, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "modelsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Manager", 1);
	
	PHALCON_INIT_VAR(models_manager);
	object_init_ex(models_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(models_manager, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "modelsMetadata", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Metadata\\Memory", 1);
	
	PHALCON_INIT_VAR(models_metadata);
	object_init_ex(models_metadata, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(models_metadata, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "response", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Http\\Response", 1);
	
	PHALCON_INIT_VAR(response);
	object_init_ex(response, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(response, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "request", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Http\\Request", 1);
	
	PHALCON_INIT_VAR(request);
	object_init_ex(request, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(request, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "filter", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Filter", 1);
	
	PHALCON_INIT_VAR(filter);
	object_init_ex(filter, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(filter, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "escaper", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Escaper", 1);
	
	PHALCON_INIT_VAR(escaper);
	object_init_ex(escaper, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(escaper, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flash", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Direct", 1);
	
	PHALCON_INIT_VAR(flash);
	object_init_ex(flash, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(flash, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flashSession", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Session", 1);
	
	PHALCON_INIT_VAR(flash_session);
	object_init_ex(flash_session, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(flash_session, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "session", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Session\\Adapter\\Files", 1);
	
	PHALCON_INIT_VAR(session);
	object_init_ex(session, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(session, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "sessionBag", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Session\\Bag", 1);
	
	PHALCON_INIT_VAR(session_bag);
	object_init_ex(session_bag, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(session_bag, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "eventsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Events\\Manager", 1);
	
	PHALCON_INIT_VAR(events_manager);
	object_init_ex(events_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_3_NORETURN(events_manager, "__construct", name, definition, shared, PH_CHECK);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Transaction\\Manager", 1);
	
	PHALCON_INIT_VAR(transaction_manager);
	object_init_ex(transaction_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD_PARAMS_2_NORETURN(transaction_manager, "__construct", name, definition, PH_CHECK);
	
	PHALCON_INIT_VAR(services);
	array_init(services);
	phalcon_array_update_string(&services, SL("router"), &router, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("dispatcher"), &dispatcher, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("url"), &url, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("modelsManager"), &models_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("modelsMetadata"), &models_metadata, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("response"), &response, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("request"), &request, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("filter"), &filter, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("escaper"), &escaper, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("flash"), &flash, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("flashSession"), &flash_session, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("session"), &session, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("sessionBag"), &session_bag, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("eventsManager"), &events_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_array_update_string(&services, SL("transactionManager"), &transaction_manager, PH_COPY | PH_SEPARATE TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_services"), services TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_DI_Service){

	PHALCON_REGISTER_CLASS(Phalcon\\DI, Service, di_service, phalcon_di_service_method_entry, 0);

	zend_declare_property_null(phalcon_di_service_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_service_ce, SL("_definition"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_service_ce, SL("_shared"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_service_ce, SL("_sharedInstance"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

PHP_METHOD(Phalcon_DI_Service, __construct){

	zval *name, *definition, *shared = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z", &name, &definition, &shared) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!shared) {
		PHALCON_INIT_NVAR(shared);
		ZVAL_BOOL(shared, 0);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_name"), name TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_definition"), definition TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_shared"), shared TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_DI_Service, getName){


	RETURN_MEMBER(this_ptr, "_name");
}

PHP_METHOD(Phalcon_DI_Service, setShared){

	zval *shared;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &shared) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_shared"), shared TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_DI_Service, getShared){


	RETURN_MEMBER(this_ptr, "_shared");
}

PHP_METHOD(Phalcon_DI_Service, setDefinition){

	zval *definition;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_definition"), definition TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_DI_Service, getDefitinion){


	RETURN_MEMBER(this_ptr, "_definition");
}

PHP_METHOD(Phalcon_DI_Service, resolve){

	zval *parameters = NULL, *shared, *shared_instance;
	zval *found = NULL, *instance = NULL, *definition, *class_name;
	zval *name, *exception_message;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &parameters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!parameters) {
		PHALCON_INIT_NVAR(parameters);
	}
	
	PHALCON_INIT_VAR(shared);
	phalcon_read_property(&shared, this_ptr, SL("_shared"), PH_NOISY_CC);
	if (zend_is_true(shared)) {
		PHALCON_INIT_VAR(shared_instance);
		phalcon_read_property(&shared_instance, this_ptr, SL("_sharedInstance"), PH_NOISY_CC);
		if (Z_TYPE_P(shared_instance) != IS_NULL) {
	
			RETURN_CCTOR(shared_instance);
		}
	}
	
	PHALCON_INIT_VAR(found);
	ZVAL_BOOL(found, 1);
	
	PHALCON_INIT_VAR(instance);
	
	PHALCON_INIT_VAR(definition);
	phalcon_read_property(&definition, this_ptr, SL("_definition"), PH_NOISY_CC);
	if (Z_TYPE_P(definition) == IS_STRING) {
		if (phalcon_class_exists(definition TSRMLS_CC)) {
			if (Z_TYPE_P(parameters) == IS_ARRAY) { 
				if (phalcon_fast_count_ev(parameters TSRMLS_CC)) {
					if (phalcon_create_instance_params(instance, definition, parameters TSRMLS_CC) == FAILURE) {
						return;
					}
				} else {
					PHALCON_INIT_NVAR(instance);
					if (phalcon_create_instance(instance, definition TSRMLS_CC) == FAILURE) {
						return;
					}
				}
			} else {
				PHALCON_INIT_NVAR(instance);
				if (phalcon_create_instance(instance, definition TSRMLS_CC) == FAILURE) {
					return;
				}
			}
		} else {
			ZVAL_BOOL(found, 0);
		}
	} else {
		if (Z_TYPE_P(definition) == IS_OBJECT) {
			if (phalcon_is_instance_of(definition, SL("Closure") TSRMLS_CC)) {
				if (Z_TYPE_P(parameters) == IS_ARRAY) { 
					PHALCON_INIT_NVAR(instance);
					PHALCON_CALL_USER_FUNC_ARRAY(instance, definition, parameters);
				} else {
					PHALCON_INIT_NVAR(instance);
					PHALCON_CALL_USER_FUNC(instance, definition);
				}
			} else {
				PHALCON_CPY_WRT(instance, definition);
			}
		} else {
			if (Z_TYPE_P(definition) == IS_ARRAY) { 
				eval_int = phalcon_array_isset_string(definition, SS("className"));
				if (!eval_int) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Invalid service definition. Missing 'className' parameter");
					return;
				}
	
				PHALCON_INIT_VAR(class_name);
				phalcon_array_fetch_string(&class_name, definition, SL("className"), PH_NOISY_CC);
				if (Z_TYPE_P(parameters) == IS_ARRAY) { 
					if (phalcon_fast_count_ev(parameters TSRMLS_CC)) {
						PHALCON_INIT_NVAR(instance);
						if (phalcon_create_instance_params(instance, class_name, parameters TSRMLS_CC) == FAILURE) {
							return;
						}
					} else {
						PHALCON_INIT_NVAR(instance);
						if (phalcon_create_instance(instance, class_name TSRMLS_CC) == FAILURE) {
							return;
						}
					}
				} else {
					PHALCON_INIT_NVAR(instance);
					if (phalcon_create_instance(instance, class_name TSRMLS_CC) == FAILURE) {
						return;
					}
				}
	
	
				RETURN_CCTOR(instance);
			} else {
				ZVAL_BOOL(found, 0);
			}
		}
	}
	
	if (PHALCON_IS_FALSE(found)) {
		PHALCON_INIT_VAR(name);
		phalcon_read_property(&name, this_ptr, SL("_name"), PH_NOISY_CC);
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Service '", name, "' cannot be resolved");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
		return;
	}
	
	if (zend_is_true(shared)) {
		phalcon_update_property_zval(this_ptr, SL("_sharedInstance"), instance TSRMLS_CC);
	}
	
	
	RETURN_CCTOR(instance);
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_DI_Injectable){

	PHALCON_REGISTER_CLASS(Phalcon\\DI, Injectable, di_injectable, phalcon_di_injectable_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_di_injectable_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_injectable_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_di_injectable_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_DI_Injectable, setDI){

	zval *dependency_injector;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Dependency Injector is invalid");
		return;
	}
	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_DI_Injectable, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_DI_Injectable, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_DI_Injectable, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_DI_Injectable, __get){

	zval *property_name, *dependency_injector;
	zval *has_service, *service = NULL, *class_name, *arguments;
	zval *persistent, *error_msg;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &property_name) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "A dependency injection object is required to access the application services");
		return;
	}
	
	PHALCON_INIT_VAR(has_service);
	PHALCON_CALL_METHOD_PARAMS_1(has_service, dependency_injector, "has", property_name, PH_NO_CHECK);
	if (zend_is_true(has_service)) {
		PHALCON_INIT_VAR(service);
		PHALCON_CALL_METHOD_PARAMS_1(service, dependency_injector, "getshared", property_name, PH_NO_CHECK);
		phalcon_update_property_zval_zval(this_ptr, property_name, service TSRMLS_CC);
	
		RETURN_CCTOR(service);
	}
	
	if (PHALCON_COMPARE_STRING(property_name, "di")) {
		phalcon_update_property_zval(this_ptr, SL("di"), dependency_injector TSRMLS_CC);
	
		RETURN_CCTOR(dependency_injector);
	}
	
	if (PHALCON_COMPARE_STRING(property_name, "persistent")) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, this_ptr TSRMLS_CC);
	
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
		phalcon_array_append(&arguments, class_name, PH_SEPARATE TSRMLS_CC);
	
		PHALCON_INIT_NVAR(service);
		ZVAL_STRING(service, "sessionBag", 1);
	
		PHALCON_INIT_VAR(persistent);
		PHALCON_CALL_METHOD_PARAMS_2(persistent, dependency_injector, "get", service, arguments, PH_NO_CHECK);
		phalcon_update_property_zval(this_ptr, SL("persistent"), persistent TSRMLS_CC);
	
		RETURN_CCTOR(persistent);
	}
	
	PHALCON_INIT_VAR(error_msg);
	PHALCON_CONCAT_SV(error_msg, "Access to undefined property ", property_name);
	PHALCON_CALL_FUNC_PARAMS_1_NORETURN("trigger_error", error_msg);
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}





#ifdef HAVE_CONFIG_H
#endif






PHALCON_INIT_CLASS(Phalcon_DI_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI, Exception, di_exception, "phalcon\\exception", NULL, 0);

	return SUCCESS;
}





#ifdef HAVE_CONFIG_H
#endif







PHALCON_INIT_CLASS(Phalcon_Dispatcher){

	PHALCON_REGISTER_CLASS(Phalcon, Dispatcher, dispatcher, phalcon_dispatcher_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_dispatcher_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_activeHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_finished"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_handlerName"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_actionName"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_returnedValue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_lastHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultNamespace"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultHandler"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultAction"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_handlerSuffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_actionSuffix"), "Action", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_NO_DI"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_CYCLIC_ROUTING"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_HANDLER_NOT_FOUND"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_INVALID_HANDLER"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_INVALID_PARAMS"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_ACTION_NOT_FOUND"), 5 TSRMLS_CC);

	zend_class_implements(phalcon_dispatcher_ce TSRMLS_CC, 3, phalcon_dispatcherinterface_ce, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

PHP_METHOD(Phalcon_Dispatcher, __construct){


	phalcon_update_property_empty_array(phalcon_dispatcher_ce, this_ptr, SL("_params") TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, setDI){

	zval *dependency_injector;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &dependency_injector) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, getDI){


	RETURN_MEMBER(this_ptr, "_dependencyInjector");
}

PHP_METHOD(Phalcon_Dispatcher, setEventsManager){

	zval *events_manager;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &events_manager) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_eventsManager"), events_manager TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, getEventsManager){


	RETURN_MEMBER(this_ptr, "_eventsManager");
}

PHP_METHOD(Phalcon_Dispatcher, setActionSuffix){

	zval *action_suffix;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_suffix) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_actionSuffix"), action_suffix TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, setDefaultNamespace){

	zval *namespace;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &namespace) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultNamespace"), namespace TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, getDefaultNamespace){


	RETURN_MEMBER(this_ptr, "_defaultNamespace");
}

PHP_METHOD(Phalcon_Dispatcher, setDefaultAction){

	zval *action_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_defaultAction"), action_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, setActionName){

	zval *action_name;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &action_name) == FAILURE) {
		RETURN_NULL();
	}

	phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
	
}

PHP_METHOD(Phalcon_Dispatcher, getActionName){


	RETURN_MEMBER(this_ptr, "_actionName");
}

PHP_METHOD(Phalcon_Dispatcher, setParams){

	zval *params, *exception_message;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &params) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(params) != IS_ARRAY) { 
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "Parameters must be an Array", 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_throwdispatchexception", exception_message, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Dispatcher, getParams){


	RETURN_MEMBER(this_ptr, "_params");
}

PHP_METHOD(Phalcon_Dispatcher, setParam){

	zval *param, *value;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &param, &value) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	PHALCON_INIT_VAR(t0);
	phalcon_read_property(&t0, this_ptr, SL("_params"), PH_NOISY_CC);
	phalcon_array_update_zval(&t0, param, &value, PH_COPY TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_params"), t0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

PHP_METHOD(Phalcon_Dispatcher, getParam){

	zval *param, *filters = NULL, *params, *param_value, *dependency_injector;
	zval *exception_code, *exception_message;
	zval *service, *filter, *sanitized_value;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &param, &filters) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (!filters) {
		PHALCON_INIT_NVAR(filters);
	}
	
	PHALCON_INIT_VAR(params);
	phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
	eval_int = phalcon_array_isset(params, param);
	if (eval_int) {
		PHALCON_INIT_VAR(param_value);
		phalcon_array_fetch(&param_value, params, param, PH_NOISY_CC);
		if (Z_TYPE_P(filters) != IS_NULL) {
			PHALCON_INIT_VAR(dependency_injector);
			phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_INIT_VAR(exception_code);
				ZVAL_LONG(exception_code, 0);
	
				PHALCON_INIT_VAR(exception_message);
				ZVAL_STRING(exception_message, "A dependency injection object is required to access the 'filter' service", 1);
				PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			}
	
			PHALCON_INIT_VAR(service);
			ZVAL_STRING(service, "filter", 1);
	
			PHALCON_INIT_VAR(filter);
			PHALCON_CALL_METHOD_PARAMS_1(filter, dependency_injector, "getshared", service, PH_NO_CHECK);
	
			PHALCON_INIT_VAR(sanitized_value);
			PHALCON_CALL_METHOD_PARAMS_2(sanitized_value, filter, "sanitize", param_value, filters, PH_NO_CHECK);
	
			RETURN_CCTOR(sanitized_value);
		} else {
	
			RETURN_CCTOR(param_value);
		}
	}
	
	PHALCON_MM_RESTORE();
	RETURN_NULL();
}

PHP_METHOD(Phalcon_Dispatcher, isFinished){


	RETURN_MEMBER(this_ptr, "_finished");
}

PHP_METHOD(Phalcon_Dispatcher, getReturnedValue){


	RETURN_MEMBER(this_ptr, "_returnedValue");
}

PHP_METHOD(Phalcon_Dispatcher, dispatch){

	zval *dependency_injector, *exception_code = NULL;
	zval *exception_message = NULL, *events_manager;
	zval *event_name = NULL, *status = NULL, *value = NULL, *handler = NULL, *number_dispatches;
	zval *handler_suffix, *action_suffix, *default_namespace;
	zval *finished = NULL, *handler_name = NULL, *action_name = NULL;
	zval *camelized_class = NULL, *handler_class = NULL, *has_service = NULL;
	zval *was_fresh = NULL, *params = NULL, *action_method = NULL, *call_object = NULL;
	zval *t0 = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(dependency_injector);
	phalcon_read_property(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(exception_code);
		ZVAL_LONG(exception_code, 0);
	
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "A dependency injection container is required to access related dispatching services", 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}
	
	PHALCON_INIT_VAR(events_manager);
	phalcon_read_property(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeDispatchLoop", 1);
	
		PHALCON_INIT_VAR(status);
		PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_MM_RESTORE();
			RETURN_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(value);
	
	PHALCON_INIT_VAR(handler);
	
	PHALCON_INIT_VAR(number_dispatches);
	ZVAL_LONG(number_dispatches, 0);
	
	PHALCON_INIT_VAR(handler_suffix);
	phalcon_read_property(&handler_suffix, this_ptr, SL("_handlerSuffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(action_suffix);
	phalcon_read_property(&action_suffix, this_ptr, SL("_actionSuffix"), PH_NOISY_CC);
	
	PHALCON_INIT_VAR(default_namespace);
	phalcon_read_property(&default_namespace, this_ptr, SL("_defaultNamespace"), PH_NOISY_CC);
	phalcon_update_property_bool(this_ptr, SL("_finished"), 0 TSRMLS_CC);
	ph_cycle_start_0:
	
		PHALCON_INIT_NVAR(t0);
		phalcon_read_property(&t0, this_ptr, SL("_finished"), PH_NOISY_CC);
		PHALCON_CPY_WRT(finished, t0);
		if (zend_is_true(finished)) {
			goto ph_cycle_end_0;
		}
		PHALCON_SEPARATE(number_dispatches);
		increment_function(number_dispatches);
		if (phalcon_compare_strict_long(number_dispatches, 256 TSRMLS_CC)) {
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 1);
	
			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Dispatcher has detected a cyclic routing causing stability problems", 1);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			goto ph_cycle_end_0;
		}
	
		phalcon_update_property_bool(this_ptr, SL("_finished"), 1 TSRMLS_CC);
	
		PHALCON_INIT_NVAR(handler_name);
		phalcon_read_property(&handler_name, this_ptr, SL("_handlerName"), PH_NOISY_CC);
		if (!zend_is_true(handler_name)) {
			PHALCON_INIT_NVAR(handler_name);
			phalcon_read_property(&handler_name, this_ptr, SL("_defaultHandler"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_handlerName"), handler_name TSRMLS_CC);
		}
	
		PHALCON_INIT_NVAR(action_name);
		phalcon_read_property(&action_name, this_ptr, SL("_actionName"), PH_NOISY_CC);
		if (!zend_is_true(action_name)) {
			PHALCON_INIT_NVAR(action_name);
			phalcon_read_property(&action_name, this_ptr, SL("_defaultAction"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
		}
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "dispatch:beforeDispatch", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				goto ph_cycle_start_0;
			}
	
			PHALCON_INIT_NVAR(finished);
			phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
			if (PHALCON_IS_FALSE(finished)) {
				goto ph_cycle_start_0;
			}
		}
	
		if (!phalcon_memnstr_str(handler_name, SL("\\") TSRMLS_CC)) {
			PHALCON_INIT_NVAR(camelized_class);
			phalcon_camelize(camelized_class, handler_name TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(camelized_class, handler_name);
		}
	
		PHALCON_INIT_NVAR(handler_class);
		PHALCON_CONCAT_VVV(handler_class, default_namespace, camelized_class, handler_suffix);
	
		PHALCON_INIT_NVAR(has_service);
		PHALCON_CALL_METHOD_PARAMS_1(has_service, dependency_injector, "has", handler_class, PH_NO_CHECK);
		if (!zend_is_true(has_service)) {
			PHALCON_INIT_NVAR(has_service);
			PHALCON_CALL_FUNC_PARAMS_1(has_service, "class_exists", handler_class);
		}
	
		if (!zend_is_true(has_service)) {
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 2);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_VS(exception_message, handler_class, " handler class cannot be loaded");
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			goto ph_cycle_end_0;
		}
	
		PHALCON_INIT_NVAR(handler);
		PHALCON_CALL_METHOD_PARAMS_1(handler, dependency_injector, "getshared", handler_class, PH_NO_CHECK);
		if (Z_TYPE_P(handler) != IS_OBJECT) {
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 3);
	
			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Invalid handler returned from the services container", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			goto ph_cycle_end_0;
		}
	
		phalcon_update_property_zval(this_ptr, SL("_activeHandler"), handler TSRMLS_CC);
	
		PHALCON_INIT_NVAR(was_fresh);
		PHALCON_CALL_METHOD(was_fresh, dependency_injector, "wasfreshinstance", PH_NO_CHECK);
		if (PHALCON_IS_TRUE(was_fresh)) {
			if (phalcon_method_exists_ex(handler, SS("initialize") TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD_NORETURN(handler, "initialize", PH_NO_CHECK);
			}
		}
	
		PHALCON_INIT_NVAR(params);
		phalcon_read_property(&params, this_ptr, SL("_params"), PH_NOISY_CC);
		if (Z_TYPE_P(params) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 4);
	
			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Action parameters must be an Array", 1);
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			goto ph_cycle_end_0;
		}
	
		PHALCON_INIT_NVAR(action_method);
		PHALCON_CONCAT_VV(action_method, action_name, action_suffix);
		if (phalcon_method_exists(handler, action_method TSRMLS_CC) == SUCCESS) {
			if (phalcon_method_exists_ex(handler, SS("beforeexecuteroute") TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_1(status, handler, "beforeexecuteroute", this_ptr, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					goto ph_cycle_start_0;
				}
	
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "dispatch:beforeExecuteRoute", 1);
	
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					goto ph_cycle_start_0;
				}
	
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			PHALCON_INIT_NVAR(call_object);
			array_init(call_object);
			phalcon_array_append(&call_object, handler, PH_SEPARATE TSRMLS_CC);
			phalcon_array_append(&call_object, action_method, PH_SEPARATE TSRMLS_CC);
	
			PHALCON_INIT_NVAR(value);
			PHALCON_CALL_USER_FUNC_ARRAY(value, call_object, params);
	
			if (phalcon_method_exists_ex(handler, SS("afterexecuteroute") TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_2(status, handler, "afterexecuteroute", this_ptr, value, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					goto ph_cycle_start_0;
				}
	
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "dispatch:afterExecuteRoute", 1);
	
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_3(status, events_manager, "fire", event_name, this_ptr, value, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					goto ph_cycle_start_0;
				}
	
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
		} else {
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "dispatch:beforeNotFoundAction", 1);
	
				PHALCON_INIT_NVAR(status);
				PHALCON_CALL_METHOD_PARAMS_2(status, events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
				if (PHALCON_IS_FALSE(status)) {
					goto ph_cycle_start_0;
				}
	
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 5);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSVS(exception_message, "Action '", action_name, "' was not found on handler '", handler_name, "'");
	
			PHALCON_INIT_NVAR(status);
			PHALCON_CALL_METHOD_PARAMS_2(status, this_ptr, "_throwdispatchexception", exception_message, exception_code, PH_NO_CHECK);
			if (PHALCON_IS_FALSE(status)) {
				PHALCON_INIT_NVAR(finished);
				phalcon_read_property(&finished, this_ptr, SL("_finished"), PH_NOISY_CC);
				if (PHALCON_IS_FALSE(finished)) {
					goto ph_cycle_start_0;
				}
			}
	
			goto ph_cycle_end_0;
		}
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "dispatch:afterDispatch", 1);
			PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
		}
		goto ph_cycle_start_0;
	ph_cycle_end_0:
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "dispatch:afterDispatchLoop", 1);
		PHALCON_CALL_METHOD_PARAMS_2_NORETURN(events_manager, "fire", event_name, this_ptr, PH_NO_CHECK);
	}
	
	phalcon_update_property_zval(this_ptr, SL("_returnedValue"), value TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_lastHandler"), handler TSRMLS_CC);
	
	RETURN_CCTOR(handler);
}

PHP_METHOD(Phalcon_Dispatcher, forward){

	zval *forward, *exception_message, *controller_name;
	zval *task_name, *action_name, *params;
	int eval_int;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &forward) == FAILURE) {
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}

	if (Z_TYPE_P(forward) != IS_ARRAY) { 
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "Forward parameter must be an Array", 1);
		PHALCON_CALL_METHOD_PARAMS_1_NORETURN(this_ptr, "_throwdispatchexception", exception_message, PH_NO_CHECK);
		PHALCON_MM_RESTORE();
		RETURN_NULL();
	}
	eval_int = phalcon_array_isset_string(forward, SS("controller"));
	if (eval_int) {
		PHALCON_INIT_VAR(controller_name);
		phalcon_array_fetch_string(&controller_name, forward, SL("controller"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_handlerName"), controller_name TSRMLS_CC);
	} else {
		eval_int = phalcon_array_isset_string(forward, SS("task"));
		if (eval_int) {
			PHALCON_INIT_VAR(task_name);
			phalcon_array_fetch_string(&task_name, forward, SL("task"), PH_NOISY_CC);
			phalcon_update_property_zval(this_ptr, SL("_handlerName"), task_name TSRMLS_CC);
		}
	}
	
	eval_int = phalcon_array_isset_string(forward, SS("action"));
	if (eval_int) {
		PHALCON_INIT_VAR(action_name);
		phalcon_array_fetch_string(&action_name, forward, SL("action"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_actionName"), action_name TSRMLS_CC);
	}
	
	eval_int = phalcon_array_isset_string(forward, SS("params"));
	if (eval_int) {
		PHALCON_INIT_VAR(params);
		phalcon_array_fetch_string(&params, forward, SL("params"), PH_NOISY_CC);
		phalcon_update_property_zval(this_ptr, SL("_params"), params TSRMLS_CC);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_finished"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





#ifdef HAVE_CONFIG_H
#endif





zend_class_entry *phalcon_db_ce;
zend_class_entry *phalcon_tag_ce;
zend_class_entry *phalcon_acl_ce;
zend_class_entry *phalcon_text_ce;
zend_class_entry *phalcon_di_ce;
zend_class_entry *phalcon_cache_backend_ce;
zend_class_entry *phalcon_cache_exception_ce;
zend_class_entry *phalcon_cache_frontend_data_ce;
zend_class_entry *phalcon_cache_backend_apc_ce;
zend_class_entry *phalcon_cache_frontend_none_ce;
zend_class_entry *phalcon_cache_backend_file_ce;
zend_class_entry *phalcon_cache_backend_mongo_ce;
zend_class_entry *phalcon_cache_backendinterface_ce;
zend_class_entry *phalcon_cache_backend_memcache_ce;
zend_class_entry *phalcon_cache_frontend_base64_ce;
zend_class_entry *phalcon_cache_frontendinterface_ce;
zend_class_entry *phalcon_cache_frontend_output_ce;
zend_class_entry *phalcon_tag_select_ce;
zend_class_entry *phalcon_tag_exception_ce;
zend_class_entry *phalcon_paginator_exception_ce;
zend_class_entry *phalcon_paginator_adapter_model_ce;
zend_class_entry *phalcon_paginator_adapterinterface_ce;
zend_class_entry *phalcon_paginator_adapter_nativearray_ce;
zend_class_entry *phalcon_db_index_ce;
zend_class_entry *phalcon_db_adapter_ce;
zend_class_entry *phalcon_db_exception_ce;
zend_class_entry *phalcon_db_column_ce;
zend_class_entry *phalcon_db_profiler_ce;
zend_class_entry *phalcon_db_dialect_ce;
zend_class_entry *phalcon_db_reference_ce;
zend_class_entry *phalcon_db_rawvalue_ce;
zend_class_entry *phalcon_db_adapter_pdo_ce;
zend_class_entry *phalcon_db_adapterinterface_ce;
zend_class_entry *phalcon_db_adapter_pdo_mysql_ce;
zend_class_entry *phalcon_db_adapter_pdo_sqlite_ce;
zend_class_entry *phalcon_db_adapter_pdo_postgresql_ce;
zend_class_entry *phalcon_db_columninterface_ce;
zend_class_entry *phalcon_db_dialect_mysql_ce;
zend_class_entry *phalcon_db_dialectinterface_ce;
zend_class_entry *phalcon_db_dialect_sqlite_ce;
zend_class_entry *phalcon_db_dialect_postgresql_ce;
zend_class_entry *phalcon_db_indexinterface_ce;
zend_class_entry *phalcon_db_profiler_item_ce;
zend_class_entry *phalcon_db_result_pdo_ce;
zend_class_entry *phalcon_db_resultinterface_ce;
zend_class_entry *phalcon_db_referenceinterface_ce;
zend_class_entry *phalcon_acl_role_ce;
zend_class_entry *phalcon_acl_resource_ce;
zend_class_entry *phalcon_acl_exception_ce;
zend_class_entry *phalcon_acl_adapter_memory_ce;
zend_class_entry *phalcon_acl_adapterinterface_ce;
zend_class_entry *phalcon_acl_roleinterface_ce;
zend_class_entry *phalcon_acl_resourceinterface_ce;
zend_class_entry *phalcon_session_ce;
zend_class_entry *phalcon_version_ce;
zend_class_entry *phalcon_session_bag_ce;
zend_class_entry *phalcon_session_adapter_ce;
zend_class_entry *phalcon_session_baginterface_ce;
zend_class_entry *phalcon_session_exception_ce;
zend_class_entry *phalcon_session_adapterinterface_ce;
zend_class_entry *phalcon_session_adapter_files_ce;
zend_class_entry *phalcon_filter_ce;
zend_class_entry *phalcon_di_service_ce;
zend_class_entry *phalcon_di_exception_ce;
zend_class_entry *phalcon_di_factorydefault_ce;
zend_class_entry *phalcon_di_factorydefault_cli_ce;
zend_class_entry *phalcon_di_injectable_ce;
zend_class_entry *phalcon_di_injectionawareinterface_ce;
zend_class_entry *phalcon_diinterface_ce;
zend_class_entry *phalcon_filter_exception_ce;
zend_class_entry *phalcon_filterinterface_ce;
zend_class_entry *phalcon_dispatcher_ce;
zend_class_entry *phalcon_dispatcherinterface_ce;
zend_class_entry *phalcon_flash_ce;
zend_class_entry *phalcon_cli_task_ce;
zend_class_entry *phalcon_flash_direct_ce;
zend_class_entry *phalcon_flashinterface_ce;
zend_class_entry *phalcon_flash_session_ce;
zend_class_entry *phalcon_flash_exception_ce;
zend_class_entry *phalcon_cli_router_ce;
zend_class_entry *phalcon_cli_console_ce;
zend_class_entry *phalcon_cli_dispatcher_ce;
zend_class_entry *phalcon_cli_console_exception_ce;
zend_class_entry *phalcon_cli_dispatcher_exception_ce;
zend_class_entry *phalcon_cli_router_exception_ce;
zend_class_entry *phalcon_loader_ce;
zend_class_entry *phalcon_logger_ce;
zend_class_entry *phalcon_config_ce;
zend_class_entry *phalcon_loader_exception_ce;
zend_class_entry *phalcon_logger_item_ce;
zend_class_entry *phalcon_logger_exception_ce;
zend_class_entry *phalcon_logger_adapter_ce;
zend_class_entry *phalcon_logger_adapter_file_ce;
zend_class_entry *phalcon_logger_adapterinterface_ce;
zend_class_entry *phalcon_config_exception_ce;
zend_class_entry *phalcon_config_adapter_ini_ce;
zend_class_entry *phalcon_translate_ce;
zend_class_entry *phalcon_translate_adapter_ce;
zend_class_entry *phalcon_translate_exception_ce;
zend_class_entry *phalcon_translate_adapterinterface_ce;
zend_class_entry *phalcon_translate_adapter_nativearray_ce;
zend_class_entry *phalcon_escaper_ce;
zend_class_entry *phalcon_escaperinterface_ce;
zend_class_entry *phalcon_escaper_exception_ce;
zend_class_entry *phalcon_http_cookie_ce;
zend_class_entry *phalcon_http_request_ce;
zend_class_entry *phalcon_http_response_ce;
zend_class_entry *phalcon_http_request_file_ce;
zend_class_entry *phalcon_http_requestinterface_ce;
zend_class_entry *phalcon_http_response_cookies_ce;
zend_class_entry *phalcon_http_response_headers_ce;
zend_class_entry *phalcon_http_request_exception_ce;
zend_class_entry *phalcon_http_responseinterface_ce;
zend_class_entry *phalcon_http_response_exception_ce;
zend_class_entry *phalcon_http_request_fileinterface_ce;
zend_class_entry *phalcon_mvc_url_ce;
zend_class_entry *phalcon_mvc_view_ce;
zend_class_entry *phalcon_mvc_micro_ce;
zend_class_entry *phalcon_mvc_router_ce;
zend_class_entry *phalcon_mvc_model_ce;
zend_class_entry *phalcon_mvc_view_engine_ce;
zend_class_entry *phalcon_mvc_dispatcher_ce;
zend_class_entry *phalcon_mvc_urlinterface_ce;
zend_class_entry *phalcon_mvc_user_plugin_ce;
zend_class_entry *phalcon_mvc_user_module_ce;
zend_class_entry *phalcon_mvc_controller_ce;
zend_class_entry *phalcon_mvc_model_query_ce;
zend_class_entry *phalcon_mvc_collection_ce;
zend_class_entry *phalcon_mvc_model_row_ce;
zend_class_entry *phalcon_mvc_router_route_ce;
zend_class_entry *phalcon_mvc_application_ce;
zend_class_entry *phalcon_mvc_application_exception_ce;
zend_class_entry *phalcon_mvc_collection_manager_ce;
zend_class_entry *phalcon_mvc_collection_exception_ce;
zend_class_entry *phalcon_mvc_dispatcherinterface_ce;
zend_class_entry *phalcon_mvc_dispatcher_exception_ce;
zend_class_entry *phalcon_mvc_modelinterface_ce;
zend_class_entry *phalcon_mvc_model_metadata_ce;
zend_class_entry *phalcon_mvc_model_criteria_ce;
zend_class_entry *phalcon_mvc_micro_exception_ce;
zend_class_entry *phalcon_mvc_model_resultset_ce;
zend_class_entry *phalcon_mvc_model_query_lang_ce;
zend_class_entry *phalcon_mvc_model_message_ce;
zend_class_entry *phalcon_mvc_model_exception_ce;
zend_class_entry *phalcon_mvc_model_validator_ce;
zend_class_entry *phalcon_mvc_model_manager_ce;
zend_class_entry *phalcon_mvc_model_transaction_ce;
zend_class_entry *phalcon_mvc_model_queryinterface_ce;
zend_class_entry *phalcon_mvc_model_metadata_files_ce;
zend_class_entry *phalcon_mvc_model_metadata_apc_ce;
zend_class_entry *phalcon_mvc_model_query_status_ce;
zend_class_entry *phalcon_mvc_model_resultset_simple_ce;
zend_class_entry *phalcon_mvc_model_resultset_complex_ce;
zend_class_entry *phalcon_mvc_model_managerinterface_ce;
zend_class_entry *phalcon_mvc_model_validator_email_ce;
zend_class_entry *phalcon_mvc_model_validator_regex_ce;
zend_class_entry *phalcon_mvc_model_metadata_memory_ce;
zend_class_entry *phalcon_mvc_model_validatorinterface_ce;
zend_class_entry *phalcon_mvc_model_resultsetinterface_ce;
zend_class_entry *phalcon_mvc_model_transaction_failed_ce;
zend_class_entry *phalcon_mvc_model_metadata_session_ce;
zend_class_entry *phalcon_mvc_model_criteriainterface_ce;
zend_class_entry *phalcon_mvc_model_messageinterface_ce;
zend_class_entry *phalcon_mvc_model_metadatainterface_ce;
zend_class_entry *phalcon_mvc_model_transaction_exception_ce;
zend_class_entry *phalcon_mvc_model_validator_numericality_ce;
zend_class_entry *phalcon_mvc_model_validator_inclusionin_ce;
zend_class_entry *phalcon_mvc_model_query_statusinterface_ce;
zend_class_entry *phalcon_mvc_model_validator_uniqueness_ce;
zend_class_entry *phalcon_mvc_model_validator_exclusionin_ce;
zend_class_entry *phalcon_mvc_model_validator_stringlength_ce;
zend_class_entry *phalcon_mvc_model_transaction_manager_ce;
zend_class_entry *phalcon_mvc_model_transactioninterface_ce;
zend_class_entry *phalcon_mvc_model_validator_presenceof_ce;
zend_class_entry *phalcon_mvc_model_transaction_managerinterface_ce;
zend_class_entry *phalcon_mvc_router_exception_ce;
zend_class_entry *phalcon_mvc_routerinterface_ce;
zend_class_entry *phalcon_mvc_router_routeinterface_ce;
zend_class_entry *phalcon_mvc_user_component_ce;
zend_class_entry *phalcon_mvc_url_exception_ce;
zend_class_entry *phalcon_mvc_view_exception_ce;
zend_class_entry *phalcon_mvc_view_engine_volt_ce;
zend_class_entry *phalcon_mvc_viewinterface_ce;
zend_class_entry *phalcon_mvc_view_engine_php_ce;
zend_class_entry *phalcon_mvc_view_engineinterface_ce;
zend_class_entry *phalcon_mvc_view_engine_volt_compiler_ce;
zend_class_entry *phalcon_events_event_ce;
zend_class_entry *phalcon_events_exception_ce;
zend_class_entry *phalcon_events_manager_ce;
zend_class_entry *phalcon_events_managerinterface_ce;
zend_class_entry *phalcon_events_eventsawareinterface_ce;
zend_class_entry *phalcon_exception_ce;

ZEND_DECLARE_MODULE_GLOBALS(phalcon)

PHP_MINIT_FUNCTION(phalcon){

	if(!zend_ce_serializable){
		fprintf(stderr, "Phalcon Error: Interface Serializable was not found");
		return FAILURE;
	}
	if(!zend_ce_iterator){
		fprintf(stderr, "Phalcon Error: Interface Iterator was not found");
		return FAILURE;
	}
	if(!spl_ce_SeekableIterator){
		fprintf(stderr, "Phalcon Error: Interface SeekableIterator was not found");
		return FAILURE;
	}
	if(!spl_ce_Countable){
		fprintf(stderr, "Phalcon Error: Interface Countable was not found");
		return FAILURE;
	}
	if(!zend_ce_arrayaccess){
		fprintf(stderr, "Phalcon Error: Interface ArrayAccess was not found");
		return FAILURE;
	}

	/** Init globals */
	ZEND_INIT_MODULE_GLOBALS(phalcon, php_phalcon_init_globals, NULL);

	PHALCON_INIT(Phalcon_DI_InjectionAwareInterface);
	PHALCON_INIT(Phalcon_Events_EventsAwareInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ValidatorInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaDataInterface);
	PHALCON_INIT(Phalcon_Cache_BackendInterface);
	PHALCON_INIT(Phalcon_Cache_FrontendInterface);
	PHALCON_INIT(Phalcon_Db_DialectInterface);
	PHALCON_INIT(Phalcon_Db_AdapterInterface);
	PHALCON_INIT(Phalcon_FlashInterface);
	PHALCON_INIT(Phalcon_Paginator_AdapterInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ResultsetInterface);
	PHALCON_INIT(Phalcon_Mvc_View_EngineInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_ManagerInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_MessageInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_CriteriaInterface);
	PHALCON_INIT(Phalcon_Session_AdapterInterface);
	PHALCON_INIT(Phalcon_DiInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ManagerInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_StatusInterface);
	PHALCON_INIT(Phalcon_Mvc_ViewInterface);
	PHALCON_INIT(Phalcon_Mvc_DispatcherInterface);
	PHALCON_INIT(Phalcon_Mvc_UrlInterface);
	PHALCON_INIT(Phalcon_Mvc_RouterInterface);
	PHALCON_INIT(Phalcon_Mvc_ModelInterface);
	PHALCON_INIT(Phalcon_Session_BagInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_QueryInterface);
	PHALCON_INIT(Phalcon_Mvc_Router_RouteInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_TransactionInterface);
	PHALCON_INIT(Phalcon_Translate_AdapterInterface);
	PHALCON_INIT(Phalcon_Events_ManagerInterface);
	PHALCON_INIT(Phalcon_Http_ResponseInterface);
	PHALCON_INIT(Phalcon_Db_ColumnInterface);
	PHALCON_INIT(Phalcon_Db_IndexInterface);
	PHALCON_INIT(Phalcon_Http_RequestInterface);
	PHALCON_INIT(Phalcon_Http_Request_FileInterface);
	PHALCON_INIT(Phalcon_FilterInterface);
	PHALCON_INIT(Phalcon_Db_ReferenceInterface);
	PHALCON_INIT(Phalcon_Acl_RoleInterface);
	PHALCON_INIT(Phalcon_DispatcherInterface);
	PHALCON_INIT(Phalcon_Logger_AdapterInterface);
	PHALCON_INIT(Phalcon_Acl_AdapterInterface);
	PHALCON_INIT(Phalcon_EscaperInterface);
	PHALCON_INIT(Phalcon_Acl_ResourceInterface);
	PHALCON_INIT(Phalcon_Exception);
	PHALCON_INIT(Phalcon_DI_Injectable);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator);
	PHALCON_INIT(Phalcon_Db_Adapter);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData);
	PHALCON_INIT(Phalcon_Cache_Backend);
	PHALCON_INIT(Phalcon_Db_Dialect);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo);
	PHALCON_INIT(Phalcon_Dispatcher);
	PHALCON_INIT(Phalcon_Flash);
	PHALCON_INIT(Phalcon_DI);
	PHALCON_INIT(Phalcon_Mvc_View_Engine);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset);
	PHALCON_INIT(Phalcon_Logger_Adapter);
	PHALCON_INIT(Phalcon_Session_Adapter);
	PHALCON_INIT(Phalcon_Config);
	PHALCON_INIT(Phalcon_Translate_Adapter);
	PHALCON_INIT(Phalcon_Mvc_Model_Exception);
	PHALCON_INIT(Phalcon_Acl);
	PHALCON_INIT(Phalcon_DI_FactoryDefault);
	PHALCON_INIT(Phalcon_Db);
	PHALCON_INIT(Phalcon_Tag);
	PHALCON_INIT(Phalcon_Cache_Exception);
	PHALCON_INIT(Phalcon_Cache_Backend_File);
	PHALCON_INIT(Phalcon_Cache_Backend_Apc);
	PHALCON_INIT(Phalcon_Cache_Backend_Mongo);
	PHALCON_INIT(Phalcon_Cache_Backend_Memcache);
	PHALCON_INIT(Phalcon_Cache_Frontend_None);
	PHALCON_INIT(Phalcon_Cache_Frontend_Base64);
	PHALCON_INIT(Phalcon_Cache_Frontend_Output);
	PHALCON_INIT(Phalcon_Cache_Frontend_Data);
	PHALCON_INIT(Phalcon_Tag_Select);
	PHALCON_INIT(Phalcon_Tag_Exception);
	PHALCON_INIT(Phalcon_Paginator_Exception);
	PHALCON_INIT(Phalcon_Paginator_Adapter_Model);
	PHALCON_INIT(Phalcon_Paginator_Adapter_NativeArray);
	PHALCON_INIT(Phalcon_Db_Index);
	PHALCON_INIT(Phalcon_Db_Column);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Mysql);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Sqlite);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Postgresql);
	PHALCON_INIT(Phalcon_Db_Dialect_Mysql);
	PHALCON_INIT(Phalcon_Db_Dialect_Sqlite);
	PHALCON_INIT(Phalcon_Db_Dialect_Postgresql);
	PHALCON_INIT(Phalcon_Db_Exception);
	PHALCON_INIT(Phalcon_Db_Profiler);
	PHALCON_INIT(Phalcon_Db_Profiler_Item);
	PHALCON_INIT(Phalcon_Db_RawValue);
	PHALCON_INIT(Phalcon_Db_Reference);
	PHALCON_INIT(Phalcon_Db_Result_Pdo);
	PHALCON_INIT(Phalcon_Db_ResultInterface);
	PHALCON_INIT(Phalcon_Acl_Role);
	PHALCON_INIT(Phalcon_Acl_Resource);
	PHALCON_INIT(Phalcon_Acl_Adapter_Memory);
	PHALCON_INIT(Phalcon_Acl_Exception);
	PHALCON_INIT(Phalcon_Text);
	PHALCON_INIT(Phalcon_Version);
	PHALCON_INIT(Phalcon_Session);
	PHALCON_INIT(Phalcon_Session_Bag);
	PHALCON_INIT(Phalcon_Session_Exception);
	PHALCON_INIT(Phalcon_Session_Adapter_Files);
	PHALCON_INIT(Phalcon_Filter);
	PHALCON_INIT(Phalcon_DI_Exception);
	PHALCON_INIT(Phalcon_DI_FactoryDefault_CLI);
	PHALCON_INIT(Phalcon_DI_Service);
	PHALCON_INIT(Phalcon_Filter_Exception);
	PHALCON_INIT(Phalcon_Flash_Direct);
	PHALCON_INIT(Phalcon_Flash_Exception);
	PHALCON_INIT(Phalcon_Flash_Session);
	PHALCON_INIT(Phalcon_CLI_Task);
	PHALCON_INIT(Phalcon_CLI_Console);
	PHALCON_INIT(Phalcon_CLI_Router);
	PHALCON_INIT(Phalcon_CLI_Console_Exception);
	PHALCON_INIT(Phalcon_CLI_Dispatcher);
	PHALCON_INIT(Phalcon_CLI_Dispatcher_Exception);
	PHALCON_INIT(Phalcon_CLI_Router_Exception);
	PHALCON_INIT(Phalcon_Loader);
	PHALCON_INIT(Phalcon_Logger);
	PHALCON_INIT(Phalcon_Loader_Exception);
	PHALCON_INIT(Phalcon_Logger_Item);
	PHALCON_INIT(Phalcon_Logger_Exception);
	PHALCON_INIT(Phalcon_Logger_Adapter_File);
	PHALCON_INIT(Phalcon_Config_Exception);
	PHALCON_INIT(Phalcon_Config_Adapter_Ini);
	PHALCON_INIT(Phalcon_Translate);
	PHALCON_INIT(Phalcon_Translate_Exception);
	PHALCON_INIT(Phalcon_Translate_Adapter_NativeArray);
	PHALCON_INIT(Phalcon_Escaper);
	PHALCON_INIT(Phalcon_Escaper_Exception);
	PHALCON_INIT(Phalcon_Http_Request);
	PHALCON_INIT(Phalcon_Http_Cookie);
	PHALCON_INIT(Phalcon_Http_Response);
	PHALCON_INIT(Phalcon_Http_Request_File);
	PHALCON_INIT(Phalcon_Http_Response_Cookies);
	PHALCON_INIT(Phalcon_Http_Response_Headers);
	PHALCON_INIT(Phalcon_Http_Request_Exception);
	PHALCON_INIT(Phalcon_Http_Response_Exception);
	PHALCON_INIT(Phalcon_Mvc_Micro);
	PHALCON_INIT(Phalcon_Mvc_Model);
	PHALCON_INIT(Phalcon_Mvc_View);
	PHALCON_INIT(Phalcon_Mvc_Url);
	PHALCON_INIT(Phalcon_Mvc_Router);
	PHALCON_INIT(Phalcon_Mvc_Application);
	PHALCON_INIT(Phalcon_Mvc_Application_Exception);
	PHALCON_INIT(Phalcon_Mvc_Collection);
	PHALCON_INIT(Phalcon_Mvc_Controller);
	PHALCON_INIT(Phalcon_Mvc_Collection_Exception);
	PHALCON_INIT(Phalcon_Mvc_Collection_Manager);
	PHALCON_INIT(Phalcon_Mvc_Dispatcher);
	PHALCON_INIT(Phalcon_Mvc_Dispatcher_Exception);
	PHALCON_INIT(Phalcon_Mvc_Model_Row);
	PHALCON_INIT(Phalcon_Mvc_Model_Query);
	PHALCON_INIT(Phalcon_Mvc_Micro_Exception);
	PHALCON_INIT(Phalcon_Mvc_Model_Criteria);
	PHALCON_INIT(Phalcon_Mvc_Model_Manager);
	PHALCON_INIT(Phalcon_Mvc_Model_Message);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_Lang);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_Status);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Apc);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Files);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Email);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Regex);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset_Complex);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset_Simple);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Memory);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Session);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Manager);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Failed);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_PresenceOf);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Uniqueness);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Exception);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Numericality);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Inclusionin);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Exclusionin);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_StringLength);
	PHALCON_INIT(Phalcon_Mvc_Router_Route);
	PHALCON_INIT(Phalcon_Mvc_Router_Exception);
	PHALCON_INIT(Phalcon_Mvc_User_Module);
	PHALCON_INIT(Phalcon_Mvc_User_Plugin);
	PHALCON_INIT(Phalcon_Mvc_Url_Exception);
	PHALCON_INIT(Phalcon_Mvc_User_Component);
	PHALCON_INIT(Phalcon_Mvc_View_Exception);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Volt);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Php);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Volt_Compiler);
	PHALCON_INIT(Phalcon_Events_Event);
	PHALCON_INIT(Phalcon_Events_Manager);
	PHALCON_INIT(Phalcon_Events_Exception);

	return SUCCESS;
}


PHP_MSHUTDOWN_FUNCTION(phalcon){
	if (PHALCON_GLOBAL(active_memory) != NULL) {
		phalcon_clean_shutdown_stack(TSRMLS_C);
	}
	return SUCCESS;
}

PHP_RINIT_FUNCTION(phalcon){
	return SUCCESS;
}

PHP_RSHUTDOWN_FUNCTION(phalcon){
	if (PHALCON_GLOBAL(active_memory) != NULL) {
		phalcon_clean_shutdown_stack(TSRMLS_C);
	}
	return SUCCESS;
}

zend_module_entry phalcon_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
	STANDARD_MODULE_HEADER,
#endif
	PHP_PHALCON_EXTNAME,
	NULL,
	PHP_MINIT(phalcon),
	PHP_MSHUTDOWN(phalcon),
	PHP_RINIT(phalcon),
	PHP_RSHUTDOWN(phalcon),
	NULL,
#if ZEND_MODULE_API_NO >= 20010901
	PHP_PHALCON_VERSION,
#endif
	STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_PHALCON
ZEND_GET_MODULE(phalcon)
#endif



