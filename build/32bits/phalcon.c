/**

New BSD License

Copyright (c) 2011-2014, Phalcon Framework Team
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--------------------------------------------------------------------
                The Zend Engine License, Version 2.00
Copyright (c) 1999-2006 Zend Technologies Ltd. All rights reserved.
--------------------------------------------------------------------

Redistribution and use in source and binary forms, with or without
modification, is permitted provided that the following conditions
are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following
     disclaimer in the documentation and/or other materials provided
     with the distribution.

  3. The names "Zend" and "Zend Engine" must not be used to endorse
     or promote products derived from this software without prior
     permission from Zend Technologies Ltd. For written permission,
     please contact license@zend.com.

  4. Zend Technologies Ltd. may publish revised and/or new versions
     of the license from time to time. Each version will be given a
     distinguishing version number.
     Once covered code has been published under a particular version
     of the license, you may always continue to use it under the
     terms of that version. You may also choose to use such covered
     code under the terms of any subsequent version of the license
     published by Zend Technologies Ltd. No one other than Zend
     Technologies Ltd. has the right to modify the terms applicable
     to covered code created under this License.

  5. Redistributions of any form whatsoever must retain the following
     acknowledgment:
     "This product includes the Zend Engine, freely available at
     http://www.zend.com"

  6. All advertising materials mentioning features or use of this
     software must display the following acknowledgment:
     "The Zend Engine is freely available at http://www.zend.com"

THIS SOFTWARE IS PROVIDED BY ZEND TECHNOLOGIES LTD. ``AS IS'' AND
ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ZEND
TECHNOLOGIES LTD.  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

--------------------------------------------------------------------

--------------------------------------------------------------------
                  The PHP License, version 3.01
Copyright (c) 1999 - 2010 The PHP Group. All rights reserved.
--------------------------------------------------------------------

Redistribution and use in source and binary forms, with or without
modification, is permitted provided that the following conditions
are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

  3. The name "PHP" must not be used to endorse or promote products
     derived from this software without prior written permission. For
     written permission, please contact group@php.net.

  4. Products derived from this software may not be called "PHP", nor
     may "PHP" appear in their name, without prior written permission
     from group@php.net.  You may indicate that your software works in
     conjunction with PHP by saying "Foo for PHP" instead of calling
     it "PHP Foo" or "phpfoo"

  5. The PHP Group may publish revised and/or new versions of the
     license from time to time. Each version will be given a
     distinguishing version number.
     Once covered code has been published under a particular version
     of the license, you may always continue to use it under the terms
     of that version. You may also choose to use such covered code
     under the terms of any subsequent version of the license
     published by the PHP Group. No one other than the PHP Group has
     the right to modify the terms applicable to covered code created
     under this License.

  6. Redistributions of any form whatsoever must retain the following
     acknowledgment:
     "This product includes PHP software, freely available from
     <http://www.php.net/software/>".

THIS SOFTWARE IS PROVIDED BY THE PHP DEVELOPMENT TEAM ``AS IS'' AND
ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE PHP
DEVELOPMENT TEAM OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.

--------------------------------------------------------------------

This software consists of voluntary contributions made by many
individuals on behalf of the PHP Group.

The PHP Group can be contacted via Email at group@php.net.

For more information on the PHP Group and the PHP project,
please see <http://www.php.net>.

PHP includes the Zend Engine, freely available at
<http://www.zend.com>.
*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>
#include <ctype.h>
#include <stdlib.h>

#include <main/php.h>

#define PHALCON_RELEASE 1

#include "php_phalcon.h"
#include "phalcon.h"

#include <main/php_main.h>
#include <main/php_variables.h>
#include <main/php_streams.h>
#include <main/php_output.h>
#include <main/php_ini.h>
#include <main/SAPI.h>
#include <ext/standard/php_string.h>
#include <ext/standard/php_smart_str.h>
#include <ext/standard/info.h>
#include <ext/pdo/php_pdo_driver.h>
#include <ext/standard/file.h>
#include <ext/standard/php_filestat.h>
#include <ext/standard/php_rand.h>
#include <ext/standard/php_lcg.h>
#include <ext/standard/php_math.h>
#include <ext/standard/php_array.h>
#include <ext/standard/php_var.h>
#include <ext/standard/php_http.h>
#include <ext/standard/php_versioning.h>
#include <ext/standard/html.h>
#include <ext/standard/base64.h>
#include <ext/standard/md5.h>
#include <ext/standard/head.h>
#include <ext/standard/url.h>
#include <ext/hash/php_hash.h>
#include <ext/spl/spl_heap.h>
#include <ext/spl/spl_exceptions.h>
#include <ext/spl/spl_directory.h>
#include <ext/spl/spl_iterators.h>
#include <ext/date/php_date.h>

#ifdef PHALCON_USE_PHP_PCRE
#include <ext/pcre/php_pcre.h>
#endif

#ifdef PHALCON_USE_PHP_JSON
#include <ext/json/php_json.h>
#endif

#ifdef PHALCON_USE_PHP_SESSION
#include <ext/session/php_session.h>
#endif

#ifdef PHALCON_USE_PHP_MBSTRING
#include <ext/mbstring/mbstring.h>
#include <ext/mbstring/php_unicode.h>
#endif

#include <Zend/zend_API.h>
#include <Zend/zend_operators.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>
#include <Zend/zend_execute.h>
#include <Zend/zend_extensions.h>
#include <Zend/zend_builtin_functions.h>
#include <Zend/zend_closures.h>

/* placeholder for non-free jsminifier.h */

#ifndef PHALCON_ASSETS_FILTERS_JSMINIFIER_H
#define PHALCON_ASSETS_FILTERS_JSMINIFIER_H

#include <Zend/zend.h>

static int phalcon_jsmin(zval *return_value, zval *script TSRMLS_DC);

#endif /* PHALCON_ASSETS_FILTERS_JSMINIFIER_H */



/* placeholder for non-free csssminifier.h */

#ifndef PHALCON_ASSETS_FILTERS_CSSMINIFIER_H
#define PHALCON_ASSETS_FILTERS_CSSMINIFIER_H

#include <Zend/zend.h>

static int phalcon_cssmin(zval *return_value, zval *style TSRMLS_DC);

#endif /* PHALCON_ASSETS_FILTERS_CSSMINIFIER_H */


#define PHQL_AGAINST                         1
#define PHQL_BETWEEN                         2
#define PHQL_EQUALS                          3
#define PHQL_NOTEQUALS                       4
#define PHQL_LESS                            5
#define PHQL_GREATER                         6
#define PHQL_GREATEREQUAL                    7
#define PHQL_LESSEQUAL                       8
#define PHQL_AND                             9
#define PHQL_OR                             10
#define PHQL_LIKE                           11
#define PHQL_ILIKE                          12
#define PHQL_BITWISE_AND                    13
#define PHQL_BITWISE_OR                     14
#define PHQL_BITWISE_XOR                    15
#define PHQL_DIVIDE                         16
#define PHQL_TIMES                          17
#define PHQL_MOD                            18
#define PHQL_PLUS                           19
#define PHQL_MINUS                          20
#define PHQL_IS                             21
#define PHQL_IN                             22
#define PHQL_NOT                            23
#define PHQL_BITWISE_NOT                    24
#define PHQL_COMMA                          25
#define PHQL_SELECT                         26
#define PHQL_FROM                           27
#define PHQL_DISTINCT                       28
#define PHQL_ALL                            29
#define PHQL_IDENTIFIER                     30
#define PHQL_DOT                            31
#define PHQL_AS                             32
#define PHQL_INNER                          33
#define PHQL_JOIN                           34
#define PHQL_CROSS                          35
#define PHQL_LEFT                           36
#define PHQL_OUTER                          37
#define PHQL_RIGHT                          38
#define PHQL_FULL                           39
#define PHQL_ON                             40
#define PHQL_INSERT                         41
#define PHQL_INTO                           42
#define PHQL_VALUES                         43
#define PHQL_PARENTHESES_OPEN               44
#define PHQL_PARENTHESES_CLOSE              45
#define PHQL_UPDATE                         46
#define PHQL_SET                            47
#define PHQL_DELETE                         48
#define PHQL_WHERE                          49
#define PHQL_ORDER                          50
#define PHQL_BY                             51
#define PHQL_ASC                            52
#define PHQL_DESC                           53
#define PHQL_GROUP                          54
#define PHQL_HAVING                         55
#define PHQL_LIMIT                          56
#define PHQL_OFFSET                         57
#define PHQL_INTEGER                        58
#define PHQL_NPLACEHOLDER                   59
#define PHQL_SPLACEHOLDER                   60
#define PHQL_CAST                           61
#define PHQL_CONVERT                        62
#define PHQL_USING                          63
#define PHQL_NULL                           64
#define PHQL_STRING                         65
#define PHQL_DOUBLE                         66
#define PHQL_TRUE                           67
#define PHQL_FALSE                          68
#define PHQL_COLON                          69




#ifndef PHALCON_MVC_MODEL_QUERY_SCANNER_H
#define PHALCON_MVC_MODEL_QUERY_SCANNER_H

#define PHQL_SCANNER_RETCODE_EOF -1
#define PHQL_SCANNER_RETCODE_ERR -2
#define PHQL_SCANNER_RETCODE_IMPOSSIBLE -3

#define PHQL_T_IGNORE 257

/* Literals & Identifiers */
#define PHQL_T_INTEGER 258
#define PHQL_T_DOUBLE 259
#define PHQL_T_STRING 260
#define PHQL_T_IDENTIFIER 265

/* Operators */
#define PHQL_T_ADD '+'
#define PHQL_T_SUB '-'
#define PHQL_T_MUL '*'
#define PHQL_T_DIV '/'
#define PHQL_T_MOD '%'
#define PHQL_T_BITWISE_AND '&'
#define PHQL_T_BITWISE_OR '|'
#define PHQL_T_BITWISE_XOR '^'
#define PHQL_T_BITWISE_NOT '~'
#define PHQL_T_AND 266
#define PHQL_T_OR 267
#define PHQL_T_LIKE 268
#define PHQL_T_ILIKE 275
#define PHQL_T_AGAINST 276

#define PHQL_T_DOT '.'
#define PHQL_T_COMMA 269
#define PHQL_T_COLON ':'

#define PHQL_T_EQUALS '='
#define PHQL_T_NOTEQUALS 270
#define PHQL_T_NOT '!'
#define PHQL_T_LESS '<'
#define PHQL_T_LESSEQUAL 271
#define PHQL_T_GREATER '>'
#define PHQL_T_GREATEREQUAL 272

#define PHQL_T_PARENTHESES_OPEN '('
#define PHQL_T_PARENTHESES_CLOSE ')'

/** Placeholders */
#define PHQL_T_NPLACEHOLDER 273
#define PHQL_T_SPLACEHOLDER 274

/** Reserved words */
#define PHQL_T_UPDATE 300
#define PHQL_T_SET 301
#define PHQL_T_WHERE 302
#define PHQL_T_DELETE 303
#define PHQL_T_FROM 304
#define PHQL_T_AS 305
#define PHQL_T_INSERT 306
#define PHQL_T_INTO 307
#define PHQL_T_VALUES 308
#define PHQL_T_SELECT 309
#define PHQL_T_ORDER 310
#define PHQL_T_BY 311
#define PHQL_T_LIMIT 312
#define PHQL_T_GROUP 313
#define PHQL_T_HAVING 314
#define PHQL_T_IN 315
#define PHQL_T_ON 316
#define PHQL_T_INNER 317
#define PHQL_T_JOIN 318
#define PHQL_T_LEFT 319
#define PHQL_T_RIGHT 320
#define PHQL_T_IS 321
#define PHQL_T_NULL 322
#define PHQL_T_NOTIN 323
#define PHQL_T_CROSS 324
#define PHQL_T_FULL 325
#define PHQL_T_OUTER 326
#define PHQL_T_ASC 327
#define PHQL_T_DESC 328
#define PHQL_T_OFFSET 329
#define PHQL_T_DISTINCT 330
#define PHQL_T_BETWEEN 331
#define PHQL_T_CAST 332
#define PHQL_T_TRUE 333
#define PHQL_T_FALSE 334
#define PHQL_T_CONVERT 335
#define PHQL_T_USING 336
#define PHQL_T_ALL 337

/** Special Tokens */
#define PHQL_T_FCALL 350
#define PHQL_T_NLIKE 351
#define PHQL_T_STARALL 352
#define PHQL_T_DOMAINALL 353
#define PHQL_T_EXPR 354
#define PHQL_T_QUALIFIED 355
#define PHQL_T_ENCLOSED 356
#define PHQL_T_NILIKE 357
#define PHQL_T_RAW_QUALIFIED 358

#define PHQL_T_INNERJOIN 360
#define PHQL_T_LEFTJOIN 361
#define PHQL_T_RIGHTJOIN 362
#define PHQL_T_CROSSJOIN 363
#define PHQL_T_FULLJOIN 364
#define PHQL_T_ISNULL 365
#define PHQL_T_ISNOTNULL 366
#define PHQL_T_MINUS 367

/* list of tokens and their names */
typedef struct _phql_token_names {
	char *name;
	unsigned int length;
	unsigned int code;
} phql_token_names;

/* active token state */
typedef struct _phql_scanner_state {
	int active_token;
	unsigned int start_length;
	char* start;
	char* end;
} phql_scanner_state;

/* extra information tokens */
typedef struct _phql_scanner_token {
	char *value;
	int opcode;
	unsigned int len;
} phql_scanner_token;

static int phql_get_token(phql_scanner_state *s, phql_scanner_token *token);

const phql_token_names phql_tokens[];

#endif /* PHALCON_MVC_MODEL_QUERY_SCANNER_H */




#ifndef PHALCON_MVC_MODEL_QUERY_PHQL_H
#define PHALCON_MVC_MODEL_QUERY_PHQL_H


typedef struct _phql_parser_token {
	char *token;
	int opcode;
	unsigned int token_len;
	int free_flag;
} phql_parser_token;

typedef struct _phql_parser_status {
	zval *ret;
	char* phql;
	unsigned int phql_length;
	int status;
	phql_scanner_state *scanner_state;
	phql_scanner_token *token;
	char *syntax_error;
	zend_uint syntax_error_len;
	zend_bool enable_literals;
} phql_parser_status;

#define PHQL_PARSING_OK 1
#define PHQL_PARSING_FAILED 0

static int phql_parse_phql(zval *result, zval *phql TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phql_internal_parse_phql(zval **result, char *phql, unsigned int phql_length, zval **error_msg TSRMLS_DC) PHALCON_ATTR_NONNULL2(1, 4);

#endif /* PHALCON_MVC_MODEL_QUERY_PHQL_H */


#ifndef PHALCON_MVC_VIEW_ENGINE_VOLT_PARSER_H
#define PHALCON_MVC_VIEW_ENGINE_VOLT_PARSER_H

#define PHVOLT_OPEN_DELIMITER                  1
#define PHVOLT_COMMA                           2
#define PHVOLT_IN                              3
#define PHVOLT_QUESTION                        4
#define PHVOLT_COLON                           5
#define PHVOLT_RANGE                           6
#define PHVOLT_AND                             7
#define PHVOLT_OR                              8
#define PHVOLT_IS                              9
#define PHVOLT_EQUALS                         10
#define PHVOLT_NOTEQUALS                      11
#define PHVOLT_LESS                           12
#define PHVOLT_GREATER                        13
#define PHVOLT_GREATEREQUAL                   14
#define PHVOLT_LESSEQUAL                      15
#define PHVOLT_IDENTICAL                      16
#define PHVOLT_NOTIDENTICAL                   17
#define PHVOLT_DIVIDE                         18
#define PHVOLT_TIMES                          19
#define PHVOLT_MOD                            20
#define PHVOLT_PLUS                           21
#define PHVOLT_MINUS                          22
#define PHVOLT_CONCAT                         23
#define PHVOLT_SBRACKET_OPEN                  24
#define PHVOLT_PIPE                           25
#define PHVOLT_NOT                            26
#define PHVOLT_INCR                           27
#define PHVOLT_DECR                           28
#define PHVOLT_PARENTHESES_OPEN               29
#define PHVOLT_DOT                            30
#define PHVOLT_IF                             31
#define PHVOLT_CLOSE_DELIMITER                32
#define PHVOLT_ENDIF                          33
#define PHVOLT_ELSE                           34
#define PHVOLT_ELSEIF                         35
#define PHVOLT_ELSEFOR                        36
#define PHVOLT_FOR                            37
#define PHVOLT_IDENTIFIER                     38
#define PHVOLT_ENDFOR                         39
#define PHVOLT_SET                            40
#define PHVOLT_ASSIGN                         41
#define PHVOLT_ADD_ASSIGN                     42
#define PHVOLT_SUB_ASSIGN                     43
#define PHVOLT_MUL_ASSIGN                     44
#define PHVOLT_DIV_ASSIGN                     45
#define PHVOLT_MACRO                          46
#define PHVOLT_PARENTHESES_CLOSE              47
#define PHVOLT_ENDMACRO                       48
#define PHVOLT_INTEGER                        49
#define PHVOLT_STRING                         50
#define PHVOLT_DOUBLE                         51
#define PHVOLT_NULL                           52
#define PHVOLT_FALSE                          53
#define PHVOLT_TRUE                           54
#define PHVOLT_CALL                           55
#define PHVOLT_ENDCALL                        56
#define PHVOLT_OPEN_EDELIMITER                57
#define PHVOLT_CLOSE_EDELIMITER               58
#define PHVOLT_BLOCK                          59
#define PHVOLT_ENDBLOCK                       60
#define PHVOLT_CACHE                          61
#define PHVOLT_ENDCACHE                       62
#define PHVOLT_EXTENDS                        63
#define PHVOLT_INCLUDE                        64
#define PHVOLT_WITH                           65
#define PHVOLT_DO                             66
#define PHVOLT_RETURN                         67
#define PHVOLT_AUTOESCAPE                     68
#define PHVOLT_ENDAUTOESCAPE                  69
#define PHVOLT_BREAK                          70
#define PHVOLT_CONTINUE                       71
#define PHVOLT_RAW_FRAGMENT                   72
#define PHVOLT_DEFINED                        73
#define PHVOLT_SBRACKET_CLOSE                 74
#define PHVOLT_CBRACKET_OPEN                  75
#define PHVOLT_CBRACKET_CLOSE                 76

#endif /* PHALCON_MVC_VIEW_ENGINE_VOLT_PARSER_H */




#ifndef PHALCON_MVC_VIEW_ENGINE_VOLT_SCANNER_H
#define PHALCON_MVC_VIEW_ENGINE_VOLT_SCANNER_H


#define PHVOLT_RAW_BUFFER_SIZE 256

#define PHVOLT_SCANNER_RETCODE_EOF -1
#define PHVOLT_SCANNER_RETCODE_ERR -2
#define PHVOLT_SCANNER_RETCODE_IMPOSSIBLE -3

/** Modes */
#define PHVOLT_MODE_RAW 0
#define PHVOLT_MODE_CODE 1
#define PHVOLT_MODE_COMMENT 2

#define PHVOLT_T_IGNORE 257

/* Literals & Identifiers */
#define PHVOLT_T_INTEGER 258
#define PHVOLT_T_DOUBLE 259
#define PHVOLT_T_STRING 260
#define PHVOLT_T_NULL 261
#define PHVOLT_T_FALSE 262
#define PHVOLT_T_TRUE 263
#define PHVOLT_T_IDENTIFIER 265

/* Operators */
#define PHVOLT_T_ADD '+'
#define PHVOLT_T_SUB '-'
#define PHVOLT_T_MUL '*'
#define PHVOLT_T_DIV '/'
#define PHVOLT_T_MOD '%'
#define PHVOLT_T_AND 266
#define PHVOLT_T_OR 267
#define PHVOLT_T_CONCAT '~'
#define PHVOLT_T_PIPE '|'

#define PHVOLT_T_DOT '.'
#define PHVOLT_T_COMMA 269

#define PHVOLT_T_NOT '!'
#define PHVOLT_T_LESS '<'
#define PHVOLT_T_LESSEQUAL 270
#define PHVOLT_T_GREATER '>'
#define PHVOLT_T_GREATEREQUAL 271
#define PHVOLT_T_EQUALS 272
#define PHVOLT_T_NOTEQUALS 273
#define PHVOLT_T_IDENTICAL 274
#define PHVOLT_T_NOTIDENTICAL 275
#define PHVOLT_T_RANGE 276
#define PHVOLT_T_ASSIGN '='
#define PHVOLT_T_COLON 277
#define PHVOLT_T_QUESTION '?'
#define PHVOLT_T_POW 278
#define PHVOLT_T_INCR 279
#define PHVOLT_T_DECR 280
#define PHVOLT_T_ADD_ASSIGN 281
#define PHVOLT_T_SUB_ASSIGN 282
#define PHVOLT_T_MUL_ASSIGN 283
#define PHVOLT_T_DIV_ASSIGN 284

#define PHVOLT_T_PARENTHESES_OPEN '('
#define PHVOLT_T_PARENTHESES_CLOSE ')'
#define PHVOLT_T_SBRACKET_OPEN '['
#define PHVOLT_T_SBRACKET_CLOSE ']'
#define PHVOLT_T_CBRACKET_OPEN '{'
#define PHVOLT_T_CBRACKET_CLOSE '}'

/** Reserved words */
#define PHVOLT_T_IF 300
#define PHVOLT_T_ELSE 301
#define PHVOLT_T_ELSEIF 302
#define PHVOLT_T_ENDIF 303
#define PHVOLT_T_FOR 304
#define PHVOLT_T_ENDFOR 305
#define PHVOLT_T_SET 306
#define PHVOLT_T_BLOCK 307
#define PHVOLT_T_ENDBLOCK 308
#define PHVOLT_T_IN 309
#define PHVOLT_T_EXTENDS 310
#define PHVOLT_T_IS 311
#define PHVOLT_T_DEFINED 312
#define PHVOLT_T_INCLUDE 313
#define PHVOLT_T_CACHE 314
#define PHVOLT_T_ENDCACHE 315
#define PHVOLT_T_DO 316
#define PHVOLT_T_AUTOESCAPE 317
#define PHVOLT_T_ENDAUTOESCAPE 318
#define PHVOLT_T_CONTINUE 319
#define PHVOLT_T_BREAK 320
#define PHVOLT_T_ELSEFOR 321
#define PHVOLT_T_MACRO 322
#define PHVOLT_T_ENDMACRO 323
#define PHVOLT_T_WITH 324
#define PHVOLT_T_CALL 325
#define PHVOLT_T_ENDCALL 326
#define PHVOLT_T_RETURN 327

/** Delimiters */
#define PHVOLT_T_OPEN_DELIMITER  330
#define PHVOLT_T_CLOSE_DELIMITER  331
#define PHVOLT_T_OPEN_EDELIMITER  332
#define PHVOLT_T_CLOSE_EDELIMITER  333

/** Special Tokens */
#define PHVOLT_T_FCALL 350
#define PHVOLT_T_EXPR 354
#define PHVOLT_T_QUALIFIED 355
#define PHVOLT_T_ENCLOSED 356
#define PHVOLT_T_RAW_FRAGMENT 357
#define PHVOLT_T_EMPTY 358
#define PHVOLT_T_ECHO 359
#define PHVOLT_T_ARRAY 360
#define PHVOLT_T_ARRAYACCESS 361
#define PHVOLT_T_NOT_ISSET 362
#define PHVOLT_T_ISSET 363
#define PHVOLT_T_RESOLVED_EXPR 364
#define PHVOLT_T_SLICE 365
#define PHVOLT_T_TERNARY 366
#define PHVOLT_T_NOT_IN 369

#define PHVOLT_T_MINUS 367
#define PHVOLT_T_PLUS 368

/* List of tokens and their names */
typedef struct _phvolt_token_names {
	char *name;
	int len;
	unsigned int code;
} phvolt_token_names;

/* Active token state */
typedef struct _phvolt_scanner_state {
	int active_token;
	int mode;
	char* start;
	char* end;
	unsigned int start_length;
	unsigned int active_line;
	zval *active_file;
	unsigned int statement_position;
	unsigned int extends_mode;
	unsigned int block_level;
	unsigned int macro_level;
	char *raw_buffer;
	unsigned int raw_buffer_cursor;
	unsigned int raw_buffer_size;
	unsigned int old_if_level;
	unsigned int if_level;
	unsigned int for_level;
	int whitespace_control;
} phvolt_scanner_state;

/* Extra information tokens */
typedef struct _phvolt_scanner_token {
	int opcode;
	int len;
	char *value;
} phvolt_scanner_token;

static int phvolt_get_token(phvolt_scanner_state *s, phvolt_scanner_token *token);

const phvolt_token_names phvolt_tokens[];

#endif  /* PHALCON_MVC_VIEW_ENGINE_VOLT_SCANNER_H */





#ifndef PHALCON_MVC_VIEW_ENGINE_VOLT_VOLT_H
#define PHALCON_MVC_VIEW_ENGINE_VOLT_VOLT_H


typedef struct _phvolt_parser_token {
	char *token;
	int opcode;
	int token_len;
	int free_flag;
} phvolt_parser_token;

typedef struct _phvolt_parser_status {
	zval *ret;
	phvolt_scanner_state *scanner_state;
	int status;
	zend_uint syntax_error_len;
	char *syntax_error;
	phvolt_scanner_token *token;
} phvolt_parser_status;

#define PHVOLT_PARSING_OK 1
#define PHVOLT_PARSING_FAILED 0

static int phvolt_parse_view(zval *result, zval *view_code, zval *template_path TSRMLS_DC);
static int phvolt_internal_parse_view(zval **result, zval *view_code, zval *template_path, zval **error_msg TSRMLS_DC);

#endif /* PHALCON_MVC_VIEW_ENGINE_VOLT_VOLT_H */


#define PHANNOT_COMMA                           1
#define PHANNOT_AT                              2
#define PHANNOT_IDENTIFIER                      3
#define PHANNOT_PARENTHESES_OPEN                4
#define PHANNOT_PARENTHESES_CLOSE               5
#define PHANNOT_STRING                          6
#define PHANNOT_EQUALS                          7
#define PHANNOT_COLON                           8
#define PHANNOT_INTEGER                         9
#define PHANNOT_DOUBLE                         10
#define PHANNOT_NULL                           11
#define PHANNOT_FALSE                          12
#define PHANNOT_TRUE                           13
#define PHANNOT_BRACKET_OPEN                   14
#define PHANNOT_BRACKET_CLOSE                  15
#define PHANNOT_SBRACKET_OPEN                  16
#define PHANNOT_SBRACKET_CLOSE                 17




#ifndef PHALCON_ANNOTATIONS_SCANNER_H
#define PHALCON_ANNOTATIONS_SCANNER_H

#define PHANNOT_SCANNER_RETCODE_EOF -1
#define PHANNOT_SCANNER_RETCODE_ERR -2
#define PHANNOT_SCANNER_RETCODE_IMPOSSIBLE -3

/** Modes */
#define PHANNOT_MODE_RAW 0
#define PHANNOT_MODE_ANNOTATION 1

#define PHANNOT_T_IGNORE 297

#define PHANNOT_T_DOCBLOCK_ANNOTATION 299
#define PHANNOT_T_ANNOTATION 300

/* Literals & Identifiers */
#define PHANNOT_T_INTEGER 301
#define PHANNOT_T_DOUBLE 302
#define PHANNOT_T_STRING 303
#define PHANNOT_T_NULL 304
#define PHANNOT_T_FALSE 305
#define PHANNOT_T_TRUE 306
#define PHANNOT_T_IDENTIFIER 307
#define PHANNOT_T_ARRAY 308
#define PHANNOT_T_ARBITRARY_TEXT 309

/* Operators */
#define PHANNOT_T_AT '@'
#define PHANNOT_T_DOT '.'
#define PHANNOT_T_COMMA ','
#define PHANNOT_T_EQUALS '='
#define PHANNOT_T_COLON ':'
#define PHANNOT_T_BRACKET_OPEN '{'
#define PHANNOT_T_BRACKET_CLOSE '}'
#define PHANNOT_T_SBRACKET_OPEN '['
#define PHANNOT_T_SBRACKET_CLOSE ']'
#define PHANNOT_T_PARENTHESES_OPEN '('
#define PHANNOT_T_PARENTHESES_CLOSE ')'

/* List of tokens and their names */
typedef struct _phannot_token_names {
	char *name;
	unsigned int code;
} phannot_token_names;

/* Active token state */
typedef struct _phannot_scanner_state {
	char* start;
	char* end;
	int active_token;
	unsigned int start_length;
	int mode;
	unsigned int active_line;
	const char *active_file;
} phannot_scanner_state;

/* Extra information tokens */
typedef struct _phannot_scanner_token {
	char *value;
	int opcode;
	int len;
} phannot_scanner_token;

static int phannot_get_token(phannot_scanner_state *s, phannot_scanner_token *token);

const phannot_token_names phannot_tokens[];

#endif /* PHALCON_ANNOTATIONS_SCANNER_H */




#ifndef PHALCON_ANNOTATIONS_ANNOT_H
#define PHALCON_ANNOTATIONS_ANNOT_H

#include <Zend/zend.h>

typedef struct _phannot_parser_token {
	char *token;
	int opcode;
	int token_len;
	int free_flag;
} phannot_parser_token;

typedef struct _phannot_parser_status {
	zval *ret;
	phannot_scanner_state *scanner_state;
	phannot_scanner_token *token;
	char *syntax_error;
	int status;
} phannot_parser_status;

#define PHANNOT_PARSING_OK 1
#define PHANNOT_PARSING_FAILED 0

static int phannot_parse_annotations(zval *result, const char *comment, zend_uint comment_len, const char *file_path, zend_uint line TSRMLS_DC);
static int phannot_internal_parse_annotations(zval **result, const char *comment, zend_uint comment_len, const char *file_path, zend_uint line, char **error_msg TSRMLS_DC);

#endif /* PHALCON_ANNOTATIONS_ANNOT_H */




#ifndef PHALCON_KERNEL_MAIN_H
#define PHALCON_KERNEL_MAIN_H


#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>

#include <ext/spl/spl_exceptions.h>
#include <ext/spl/spl_iterators.h>


/** Main macros */
#define PH_DEBUG 0

#define PH_NOISY 0
#define PH_SILENT 1

#define PH_SEPARATE 256
#define PH_COPY 1024

#define SL(str)   ZEND_STRL(str)
#define SS(str)   ZEND_STRS(str)
#define ISL(str)  (phalcon_interned_##str), (sizeof(#str)-1)
#define ISS(str)  (phalcon_interned_##str), (sizeof(#str))

/* str_erealloc is PHP 5.6 only */
#ifndef str_erealloc
#define str_erealloc erealloc
#endif

/* Startup functions */
void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC);
zend_class_entry *phalcon_register_internal_interface_ex(zend_class_entry *orig_ce, zend_class_entry *parent_ce TSRMLS_DC);

/* Globals functions */
zval* phalcon_get_global(const char *global, unsigned int global_length TSRMLS_DC);

static int phalcon_is_callable(zval *var TSRMLS_DC);
static int phalcon_function_quick_exists_ex(const char *func_name, unsigned int func_len, unsigned long key TSRMLS_DC);

PHALCON_ATTR_NONNULL static inline int phalcon_function_exists_ex(const char *function_name, unsigned int function_len TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(function_name) && __builtin_constant_p(function_len)) {
		return phalcon_function_quick_exists_ex(function_name, function_len, zend_inline_hash_func(function_name, function_len) TSRMLS_CC);
	}
#endif

	return phalcon_function_quick_exists_ex(function_name, function_len, zend_hash_func(function_name, function_len) TSRMLS_CC);
}

PHALCON_ATTR_NONNULL static inline int phalcon_fetch_function(zend_function **function, const char *function_name, unsigned int function_len TSRMLS_DC)
{
	return zend_hash_find(EG(function_table), function_name, function_len+1, (void**)function);
}

/* Count */
long int phalcon_fast_count_int(zval *value TSRMLS_DC);
static void phalcon_fast_count(zval *result, zval *array TSRMLS_DC);
static int phalcon_fast_count_ev(zval *array TSRMLS_DC);

/* Utils functions */
static int phalcon_is_iterable_ex(zval *arr, HashTable **arr_hash, HashPosition *hash_position, int duplicate, int reverse);

static inline void phalcon_safe_zval_ptr_dtor(zval *pzval)
{
	if (pzval) {
		zval_ptr_dtor(&pzval);
	}
}

static inline int is_phalcon_class(const zend_class_entry *ce)
{
#if PHP_VERSION_ID >= 50400
	return
			ce->type == ZEND_INTERNAL_CLASS
		 && ce->info.internal.module->module_number == phalcon_module_entry.module_number
	;
#else
	return
			ce->type == ZEND_INTERNAL_CLASS
		 && ce->module->module_number == phalcon_module_entry.module_number
	;
#endif
}

/* Fetch Parameters */
static int phalcon_fetch_parameters(int num_args TSRMLS_DC, int required_args, int optional_args, ...);
static int phalcon_fetch_parameters_ex(int dummy TSRMLS_DC, int n_req, int n_opt, ...);

/* Compatibility macros for PHP 5.3 */
#ifndef INIT_PZVAL_COPY
 #define INIT_PZVAL_COPY(z, v) ZVAL_COPY_VALUE(z, v);\
  Z_SET_REFCOUNT_P(z, 1);\
  Z_UNSET_ISREF_P(z);
#endif

#ifndef ZVAL_COPY_VALUE
 #define ZVAL_COPY_VALUE(z, v)\
  (z)->value = (v)->value;\
  Z_TYPE_P(z) = Z_TYPE_P(v);
#endif

#define RETURN_CCTOR(var) { \
		*(return_value) = *(var); \
		if (Z_TYPE_P(var) > IS_BOOL) { \
			phalcon_copy_ctor(return_value, var); \
		} \
		INIT_PZVAL(return_value) \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_CCTORW(var) { \
		*(return_value) = *(var); \
		if (Z_TYPE_P(var) > IS_BOOL) { \
			phalcon_copy_ctor(return_value, var); \
		} \
		INIT_PZVAL(return_value) \
	} \
	return;

#define RETURN_CTOR(var) { \
		RETVAL_ZVAL(var, 1, 0); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_CTORW(var) { \
		RETVAL_ZVAL(var, 1, 0); \
	} \
	return;

#define RETURN_THIS() { \
		RETVAL_ZVAL(this_ptr, 1, 0); \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_THISW() \
	RETURN_ZVAL(this_ptr, 1, 0);

#define RETURN_NCTOR(var) { \
		*(return_value) = *(var); \
		INIT_PZVAL(return_value) \
	} \
	PHALCON_MM_RESTORE(); \
	return;

#define RETURN_MEMBER(object, member_name) \
	phalcon_return_property_quick(return_value, NULL, object, SL(member_name), zend_inline_hash_func(SS(member_name)) TSRMLS_CC); \
	return;

#define RETURN_MEMBER_QUICK(object, member_name, key) \
	phalcon_return_property_quick(return_value, NULL, object, SL(member_name), key TSRMLS_CC); \
	return;

#define RETURN_ON_FAILURE(what) \
	if (FAILURE == what) { \
		return;            \
	}

#define RETURN_MM_ON_FAILURE(what) \
	if (FAILURE == what) {    \
		PHALCON_MM_RESTORE(); \
		return;               \
	}

/** Return without change return_value */
#define RETURN_MM() PHALCON_MM_RESTORE(); return;

/** Return null restoring memory frame */
#define RETURN_MM_NULL() PHALCON_MM_RESTORE(); RETURN_NULL();

/** Return bool restoring memory frame */
#define RETURN_MM_FALSE PHALCON_MM_RESTORE(); RETURN_FALSE;
#define RETURN_MM_TRUE PHALCON_MM_RESTORE(); RETURN_TRUE;

/** Return string restoring memory frame */
#define RETURN_MM_STRING(str, copy) PHALCON_MM_RESTORE(); RETURN_STRING(str, copy);
#define RETURN_MM_EMPTY_STRING() PHALCON_MM_RESTORE(); RETURN_EMPTY_STRING();

/** Return empty array */
#define RETURN_EMPTY_ARRAY() array_init(return_value); return;
#define RETURN_MM_EMPTY_ARRAY() PHALCON_MM_RESTORE(); RETURN_EMPTY_ARRAY();

#ifndef IS_INTERNED
#define IS_INTERNED(key) 0
#define INTERNED_HASH(key) 0
#endif

/** Get the current hash key without copying the hash key */
#define PHALCON_GET_HKEY(var, hash, hash_position) \
	do { \
		PHALCON_INIT_NVAR_PNULL(var); \
		phalcon_get_current_key(&var, hash, &hash_position TSRMLS_CC); \
	} while (0)

/** Check if an array is iterable or not */
#define phalcon_is_iterable(var, array_hash, hash_pointer, duplicate, reverse) \
	if (!phalcon_is_iterable_ex(var, array_hash, hash_pointer, duplicate, reverse)) { \
		zend_error(E_ERROR, "The argument is not iterable()"); \
		PHALCON_MM_RESTORE(); \
		return; \
	}

#define PHALCON_GET_HVALUE(var) \
	PHALCON_OBS_NVAR(var); \
	var = *hd; \
	Z_ADDREF_P(var);

/** class/interface registering */
#define PHALCON_REGISTER_CLASS(ns, class_name, name, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #class_name, methods); \
		phalcon_ ##name## _ce = zend_register_internal_class(&ce TSRMLS_CC); \
		phalcon_ ##name## _ce->ce_flags |= flags;  \
	}

#define PHALCON_REGISTER_CLASS_EX(ns, class_name, lcname, parent_ce, methods, flags) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #class_name, methods); \
		phalcon_ ##lcname## _ce = zend_register_internal_class_ex(&ce, parent_ce, NULL TSRMLS_CC); \
		if (!phalcon_ ##lcname## _ce) { \
			fprintf(stderr, "Phalcon Error: Class to extend '%s' was not found when registering class '%s'\n", (parent_ce ? parent_ce->name : "(null)"), ZEND_NS_NAME(#ns, #class_name)); \
			return FAILURE; \
		} \
		phalcon_ ##lcname## _ce->ce_flags |= flags;  \
	}

#define PHALCON_REGISTER_INTERFACE(ns, classname, name, methods) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #classname, methods); \
		phalcon_ ##name## _ce = zend_register_internal_interface(&ce TSRMLS_CC); \
	}

#define PHALCON_REGISTER_INTERFACE_EX(ns, classname, lcname, parent_ce, methods) \
	{ \
		zend_class_entry ce; \
		memset(&ce, 0, sizeof(zend_class_entry)); \
		INIT_NS_CLASS_ENTRY(ce, #ns, #classname, methods); \
		phalcon_ ##lcname## _ce = phalcon_register_internal_interface_ex(&ce, parent_ce TSRMLS_CC); \
		if (!phalcon_ ##lcname## _ce) { \
			fprintf(stderr, "Can't register interface %s with parent %s\n", ZEND_NS_NAME(#ns, #classname), (parent_ce ? parent_ce->name : "(null)")); \
			return FAILURE; \
		} \
	}

/** Method declaration for API generation */
#define PHALCON_DOC_METHOD(class_name, method)

/** Low overhead parse/fetch parameters */
#ifndef PHALCON_RELEASE

#define phalcon_fetch_params(memory_grow, required_params, optional_params, ...) \
	if (memory_grow) { \
		zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL; \
		ASSUME(phalcon_globals_ptr != NULL); \
		if (unlikely(phalcon_globals_ptr->active_memory == NULL)) { \
			fprintf(stderr, "phalcon_fetch_params is called with memory_grow=1 but there is no active memory frame!\n"); \
			phalcon_print_backtrace(); \
		} \
		else if (unlikely(phalcon_globals_ptr->active_memory->func != __func__)) { \
			fprintf(stderr, "phalcon_fetch_params is called with memory_grow=1 but the memory frame was not created!\n"); \
			fprintf(stderr, "The frame was created by %s\n", phalcon_globals_ptr->active_memory->func); \
			fprintf(stderr, "Calling function: %s\n", __func__); \
			phalcon_print_backtrace(); \
		} \
	} \
	if (phalcon_fetch_parameters(ZEND_NUM_ARGS() TSRMLS_CC, required_params, optional_params, __VA_ARGS__) == FAILURE) { \
		if (memory_grow) { \
			RETURN_MM_NULL(); \
		} \
		RETURN_NULL(); \
	} \

#else

#define phalcon_fetch_params(memory_grow, required_params, optional_params, ...) \
	if (phalcon_fetch_parameters(ZEND_NUM_ARGS() TSRMLS_CC, required_params, optional_params, __VA_ARGS__) == FAILURE) { \
		if (memory_grow) { \
			RETURN_MM_NULL(); \
		} \
		RETURN_NULL(); \
	}
#endif

#define phalcon_fetch_params_ex(required_params, optional_params, ...) \
	if (phalcon_fetch_parameters_ex(0 TSRMLS_CC, required_params, optional_params, __VA_ARGS__) == FAILURE) { \
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Wrong number of parameters"); \
		return; \
	}

#define PHALCON_VERIFY_INTERFACE_EX(instance, interface_ce, exception_ce, restore_stack) \
	if (Z_TYPE_P(instance) != IS_OBJECT) { \
		zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object implementing %s, %s given", interface_ce->name, zend_zval_type_name(instance)); \
		if (restore_stack) { \
			PHALCON_MM_RESTORE(); \
		} \
		return; \
	} else { \
		if (!instanceof_function_ex(Z_OBJCE_P(instance), interface_ce, 1 TSRMLS_CC)) { \
			if (Z_TYPE_P(instance) != IS_OBJECT) { \
				zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object implementing %s, %s given", interface_ce->name, zend_zval_type_name(instance)); \
			} \
			else { \
				zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object implementing %s, object of type %s given", interface_ce->name, Z_OBJCE_P(instance)->name); \
			} \
			if (restore_stack) { \
				PHALCON_MM_RESTORE(); \
			} \
			return; \
		} \
	}

#define PHALCON_VERIFY_INTERFACE_OR_NULL_EX(pzv, interface_ce, exception_ce, restore_stack) \
	if (Z_TYPE_P(pzv) != IS_NULL && (Z_TYPE_P(pzv) != IS_OBJECT || !instanceof_function_ex(Z_OBJCE_P(pzv), interface_ce, 1 TSRMLS_CC))) { \
		if (Z_TYPE_P(pzv) != IS_OBJECT) { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object implementing %s or NULL, %s given", interface_ce->name, zend_zval_type_name(pzv)); \
		} \
		else { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object implementing %s or NULL, object of type %s given", interface_ce->name, Z_OBJCE_P(pzv)->name); \
		} \
		if (restore_stack) { \
			PHALCON_MM_RESTORE(); \
		} \
		return; \
	}

#define PHALCON_VERIFY_CLASS_EX(instance, class_ce, exception_ce, restore_stack) \
	if (Z_TYPE_P(instance) != IS_OBJECT || !instanceof_function_ex(Z_OBJCE_P(instance), class_ce, 0 TSRMLS_CC)) { \
		if (Z_TYPE_P(instance) != IS_OBJECT) { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type %s, %s given", class_ce->name, zend_zval_type_name(instance)); \
		} \
		else { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type %s, object of type %s given", class_ce->name, Z_OBJCE_P(instance)->name); \
		} \
		if (restore_stack) { \
			PHALCON_MM_RESTORE(); \
		} \
		return; \
	}

#define PHALCON_VERIFY_CLASS_OR_NULL_EX(pzv, class_ce, exception_ce, restore_stack) \
	if (Z_TYPE_P(pzv) != IS_NULL && (Z_TYPE_P(pzv) != IS_OBJECT || !instanceof_function_ex(Z_OBJCE_P(pzv), class_ce, 0 TSRMLS_CC))) { \
		if (Z_TYPE_P(pzv) != IS_OBJECT) { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type %s, %s given", class_ce->name, zend_zval_type_name(pzv)); \
		} \
		else { \
			zend_throw_exception_ex(exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type %s, object of type %s given", class_ce->name, Z_OBJCE_P(pzv)->name); \
		} \
		if (restore_stack) { \
			PHALCON_MM_RESTORE(); \
		} \
		return; \
	}

#define PHALCON_VERIFY_INTERFACE(instance, interface_ce)      PHALCON_VERIFY_INTERFACE_EX(instance, interface_ce, spl_ce_LogicException, 1)
#define PHALCON_VERIFY_INTERFACE_OR_NULL(pzv, interface_ce)   PHALCON_VERIFY_INTERFACE_OR_NULL_EX(pzv, interface_ce, spl_ce_LogicException, 1)
#define PHALCON_VERIFY_CLASS(instance, class_ce)              PHALCON_VERIFY_CLASS_EX(instance, class_ce, spl_ce_LogicException, 1)
#define PHALCON_VERIFY_CLASS_OR_NULL(pzv, class_ce)           PHALCON_VERIFY_CLASS_OR_NULL_EX(pzv, class_ce, spl_ce_LogicException, 1)

#define phalcon_convert_to_explicit_type_mm_ex(ppzv, str_type) \
	if (Z_TYPE_PP(ppzv) != str_type) { \
		if (!Z_ISREF_PP(ppzv)) { \
			PHALCON_SEPARATE(*ppzv); \
		} \
		convert_to_explicit_type(*ppzv, str_type); \
	}

#define PHALCON_ENSURE_IS_STRING(ppzv)    convert_to_explicit_type_ex(ppzv, IS_STRING)
#define PHALCON_ENSURE_IS_LONG(ppzv)      convert_to_explicit_type_ex(ppzv, IS_LONG)
#define PHALCON_ENSURE_IS_DOUBLE(ppzv)    convert_to_explicit_type_ex(ppzv, IS_DOUBLE)
#define PHALCON_ENSURE_IS_BOOL(ppzv)      convert_to_explicit_type_ex(ppzv, IS_BOOL)
#define PHALCON_ENSURE_IS_ARRAY(ppzv)     convert_to_explicit_type_ex(ppzv, IS_ARRAY)

#endif /* PHALCON_KERNEL_MAIN_H */




#ifndef PHALCON_KERNEL_MEMORY_H
#define PHALCON_KERNEL_MEMORY_H


static void phalcon_initialize_memory(zend_phalcon_globals *phalcon_globals_ptr TSRMLS_DC);
static void phalcon_deinitialize_memory(TSRMLS_D);

/* Memory Frames */
#ifndef PHALCON_RELEASE
static void phalcon_dump_memory_frame(phalcon_memory_entry *active_memory TSRMLS_DC);
static void phalcon_dump_current_frame(TSRMLS_D);
static void phalcon_dump_all_frames(TSRMLS_D);

static void phalcon_memory_grow_stack(const char *func TSRMLS_DC);
static int phalcon_memory_restore_stack(const char *func TSRMLS_DC);

#define PHALCON_MM_GROW()       phalcon_memory_grow_stack(__func__ TSRMLS_CC)
#define PHALCON_MM_RESTORE()    phalcon_memory_restore_stack(__func__ TSRMLS_CC)

static void phalcon_memory_observe(zval **var, const char *func TSRMLS_DC) /* PHALCON_ATTR_NONNULL */;
static void phalcon_memory_alloc(zval **var, const char *func TSRMLS_DC);
static void phalcon_memory_alloc_pnull(zval **var, const char *func TSRMLS_DC);

#define PHALCON_MEMORY_ALLOC(z) \
	phalcon_memory_alloc((z), __func__ TSRMLS_CC)

#define PHALCON_MEMORY_ALLOC_PNULL(z) \
	phalcon_memory_alloc_pnull((z), __func__ TSRMLS_CC)

#define PHALCON_MEMORY_OBSERVE(z) \
	phalcon_memory_observe((z), __func__ TSRMLS_CC)

#else
static void phalcon_memory_grow_stack(TSRMLS_D);
static int phalcon_memory_restore_stack(TSRMLS_D);

#define PHALCON_MM_GROW()       phalcon_memory_grow_stack(TSRMLS_C)
#define PHALCON_MM_RESTORE()    phalcon_memory_restore_stack(TSRMLS_C)

static void phalcon_memory_observe(zval **var TSRMLS_DC) /* PHALCON_ATTR_NONNULL */;
static void phalcon_memory_alloc(zval **var TSRMLS_DC);
static void phalcon_memory_alloc_pnull(zval **var TSRMLS_DC);

#define PHALCON_MEMORY_ALLOC(z) \
	phalcon_memory_alloc((z) TSRMLS_CC)

#define PHALCON_MEMORY_ALLOC_PNULL(z) \
	phalcon_memory_alloc_pnull((z) TSRMLS_CC)

#define PHALCON_MEMORY_OBSERVE(z) \
	phalcon_memory_observe((z) TSRMLS_CC)

#endif

static void phalcon_memory_remove(zval **var TSRMLS_DC) PHALCON_ATTR_NONNULL;

static int phalcon_clean_restore_stack(TSRMLS_D);

/* Virtual symbol tables */
static void phalcon_create_symbol_table(TSRMLS_D);
static void phalcon_clean_symbol_tables(TSRMLS_D);

/** Export symbols to active symbol table */
static int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC);
static int phalcon_set_symbol_str(char *key_name, unsigned int key_length, zval *value TSRMLS_DC);

static void phalcon_copy_ctor(zval *destiny, zval *origin) PHALCON_ATTR_NONNULL;

/* Memory macros */
#define PHALCON_ALLOC_GHOST_ZVAL(z)                   \
	do {                                              \
		MAKE_STD_ZVAL(z);                             \
		Z_SET_REFCOUNT_P(z, 0);                       \
	} while (0)

#define PHALCON_INIT_VAR(z) \
	PHALCON_MEMORY_ALLOC(&z)

#define PHALCON_INIT_NVAR(z)                          \
	do {                                              \
		if (z) {                                      \
			if (Z_REFCOUNT_P(z) > 1) {                \
				Z_DELREF_P(z);                        \
				ALLOC_ZVAL(z);                        \
				Z_SET_REFCOUNT_P(z, 1);               \
				Z_UNSET_ISREF_P(z);                   \
			}                                         \
			else {                                    \
				zval_dtor(z)   ;                      \
			}                                         \
			ZVAL_NULL(z);                             \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_ALLOC(&z);                 \
		}                                             \
	} while (0)

#define PHALCON_INIT_NVAR_PNULL(z)\
	do {                                              \
		if (z) {                                      \
			if (Z_REFCOUNT_P(z) > 1) {                \
				Z_DELREF_P(z);                        \
				if (Z_REFCOUNT_P(z) >= 1) {           \
					zval_copy_ctor(z);                \
				}                                     \
				ALLOC_ZVAL(z);                        \
				Z_SET_REFCOUNT_P(z, 1);               \
				Z_UNSET_ISREF_P(z);                   \
			}                                         \
			ZVAL_NULL(z);                             \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_ALLOC_PNULL(&z);           \
		}                                             \
	} while (0)

#define PHALCON_CPY_WRT(d, v)                         \
	do {                                              \
		if (d) {                                      \
			if (Z_REFCOUNT_P(d) > 0) {                \
				zval_ptr_dtor(&d);                    \
			}                                         \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_OBSERVE(&d);               \
		}                                             \
		Z_ADDREF_P(v);                                \
		d = v;                                        \
	} while (0)

#define PHALCON_CPY_WRT_CTOR(d, v)                    \
	do {                                              \
		if (d) {                                      \
			if (Z_REFCOUNT_P(d) > 0) {                \
				zval_ptr_dtor(&d);                    \
			}                                         \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_OBSERVE(&d);               \
		}                                             \
		ALLOC_ZVAL(d);                                \
		*d = *v;                                      \
		zval_copy_ctor(d);                            \
		Z_SET_REFCOUNT_P(d, 1);                       \
		Z_UNSET_ISREF_P(d);                           \
	} while (0)

/* */
#define PHALCON_OBS_VAR(z) \
	PHALCON_MEMORY_OBSERVE(&z)

#define PHALCON_OBS_NVAR(z)                           \
	do {                                              \
		if (z) {                                      \
			if (Z_REFCOUNT_P(z) > 1) {                \
				Z_DELREF_P(z);                        \
			}                                         \
			else {                                    \
				zval_ptr_dtor(&z);                    \
				z = NULL;                             \
			}                                         \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_OBSERVE(&z);               \
		}                                             \
	} while (0)

#define PHALCON_OBSERVE_OR_NULLIFY_PPZV(ppzv)              \
	do {                                                   \
		zval **tmp_ = (ppzv);                              \
		if (tmp_ != NULL) {                                \
			if (*tmp_) {                                   \
				zval_ptr_dtor(tmp_);                       \
				*tmp_ = NULL;                              \
			}                                              \
			else {                                         \
				PHALCON_MEMORY_OBSERVE((ppzv));            \
			}                                              \
		}                                                  \
	} while (0)

#define PHALCON_OBSERVE_OR_NULLIFY_VAR(z)             \
	do {                                              \
		if (z) {                                      \
			zval_ptr_dtor(&z);                        \
			z = NULL;                                 \
		}                                             \
		else {                                        \
			PHALCON_MEMORY_OBSERVE(&z);               \
		}                                             \
	} while (0)


#define PHALCON_SEPARATE_ARRAY(a)                     \
	do {                                              \
		if (Z_REFCOUNT_P(a) > 1) {                    \
			zval *new_zv;                             \
			Z_DELREF_P(a);                            \
			ALLOC_ZVAL(new_zv);                       \
			INIT_PZVAL_COPY(new_zv, a);               \
			a = new_zv;                               \
			zval_copy_ctor(new_zv);                   \
		}                                             \
	} while (0)

#define PHALCON_SEPARATE_PARAM(z)                     \
	do {                                              \
		zval *orig_ptr = z;                           \
		PHALCON_MEMORY_OBSERVE(&z);                   \
		ALLOC_ZVAL(z);                                \
		*z = *orig_ptr;                               \
		zval_copy_ctor(z);                            \
		Z_SET_REFCOUNT_P(z, 1);                       \
		Z_UNSET_ISREF_P(z);                           \
	} while (0)

static inline int phalcon_maybe_separate_zval(zval** z)
{
	if (Z_REFCOUNT_PP(z) > 1 && !Z_ISREF_PP(z)) {
		zval *new_zv;

		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, *z);
		*z = new_zv;
		zval_copy_ctor(new_zv);

		return 1;
	}

	return 0;
}

#endif /* PHALCON_KERNEL_MEMORY_H */




#ifndef PHALCON_KERNEL_BACKTRACE_H
#define PHALCON_KERNEL_BACKTRACE_H


static void phalcon_print_backtrace(void);

#endif /* PHALCON_KERNEL_BACKTRACE_H */




#ifndef PHALCON_KERNEL_FCALL_H
#define PHALCON_KERNEL_FCALL_H


#include <Zend/zend_hash.h>
#include <Zend/zend.h>

typedef enum _phalcon_call_type {
	phalcon_fcall_parent,
	phalcon_fcall_self,
	phalcon_fcall_static,
	phalcon_fcall_ce,
	phalcon_fcall_method,
	phalcon_fcall_function
} phalcon_call_type;

#ifndef PHALCON_RELEASE

typedef struct _phalcon_fcall_cache_entry {
	zend_function *f;
	zend_uint times;
} phalcon_fcall_cache_entry;

#else

typedef zend_function phalcon_fcall_cache_entry;

#endif


#if !defined(_MSC_VER)
#define PHALCON_CALL_FUNCTIONW(return_value_ptr, func_name, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(func_name)) { \
			RETURN_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, sizeof(func_name)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, strlen(func_name), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_FUNCTION(return_value_ptr, func_name, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(func_name)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, sizeof(func_name)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, strlen(func_name), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_FUNCTIONW(func_name, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(func_name)) { \
			RETURN_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, sizeof(func_name)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, strlen(func_name), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_FUNCTION(func_name, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(func_name)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, sizeof(func_name)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, strlen(func_name), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)


#define PHALCON_CALL_METHODW(return_value_ptr, object, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_METHOD(return_value_ptr, object, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_METHODW(object, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_METHOD(object, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)


#define PHALCON_CALL_PARENTW(return_value_ptr, class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_PARENT(return_value_ptr, class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_PARENTW(class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_PARENT(class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)


#define PHALCON_CALL_SELFW(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_SELF(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_SELFW(method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_SELF(method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)


#define PHALCON_CALL_STATICW(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_STATIC(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_STATICW(method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_STATIC(method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_CALL_CE_STATICW(return_value_ptr, class_entry, method, ...) \
	do { \
		zval *params[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, sizeof(method)-1, sizeof(params)/sizeof(zval*), params TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), sizeof(params)/sizeof(zval*), params TSRMLS_CC)); \
		} \
	} while (0)


#define PHALCON_CALL_CE_STATIC(return_value_ptr, class_entry, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_CE_STATICW(class_entry, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#define PHALCON_RETURN_CALL_CE_STATIC(class_entry, method, ...) \
	do { \
		zval *params_[] = {__VA_ARGS__}; \
		if (__builtin_constant_p(method)) { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, sizeof(method)-1, sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
		else { \
			RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), sizeof(params_)/sizeof(zval*), params_ TSRMLS_CC)); \
		} \
	} while (0)

#else

#define NELEMSM1(x) ((sizeof(x) - sizeof(x[0]))/sizeof(x[0]))

#define PHALCON_CALL_FUNCTIONW(return_value_ptr, func_name, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, strlen(func_name), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_FUNCTION(return_value_ptr, func_name, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_func_aparams(return_value_ptr, func_name, strlen(func_name), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_FUNCTIONW(func_name, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, strlen(func_name), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_FUNCTION(func_name, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_function(return_value, return_value_ptr, func_name, strlen(func_name), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_METHODW(return_value_ptr, object, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_METHOD(return_value_ptr, object, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_METHODW(object, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_METHOD(object, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)


#define PHALCON_CALL_PARENTW(return_value_ptr, class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_PARENT(return_value_ptr, class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_PARENTW(class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_PARENT(class_entry, this_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_parent, this_ptr, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)


#define PHALCON_CALL_SELFW(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_SELF(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_SELFW(method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_SELF(method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)


#define PHALCON_CALL_STATICW(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_STATIC(return_value_ptr, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_STATICW(method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_STATIC(method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_CE_STATICW(return_value_ptr, class_entry, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)


#define PHALCON_CALL_CE_STATIC(return_value_ptr, class_entry, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		PHALCON_OBSERVE_OR_NULLIFY_PPZV(return_value_ptr); \
		RETURN_MM_ON_FAILURE(phalcon_call_class_method_aparams(return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_CE_STATICW(class_entry, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#define PHALCON_RETURN_CALL_CE_STATIC(class_entry, method, ...) \
	do { \
		zval *params_[] = {NULL, __VA_ARGS__}; \
		RETURN_MM_ON_FAILURE(phalcon_return_call_class_method(return_value, return_value_ptr, class_entry, phalcon_fcall_ce, NULL, method, strlen(method), NELEMSM1(params_), params_ + 1 TSRMLS_CC)); \
	} while (0)

#endif

/** Use these functions to call functions in the PHP userland using an arbitrary zval as callable */
#define PHALCON_CALL_USER_FUNC(return_value, handler) PHALCON_CALL_USER_FUNC_ARRAY(return_value, handler, NULL)
#define PHALCON_CALL_USER_FUNC_ARRAY(return_value, handler, params) \
	do { \
		RETURN_MM_ON_FAILURE(phalcon_call_user_func_array(return_value, handler, params TSRMLS_CC)); \
	} while (0)

#define PHALCON_CALL_USER_FUNC_ARRAY_NOEX(return_value, handler, params) \
	do { \
		RETURN_MM_ON_FAILURE(phalcon_call_user_func_array_noex(return_value, handler, params TSRMLS_CC)); \
	} while (0)

static int phalcon_call_func_aparams(zval **return_value_ptr, const char *func_name, uint func_length, uint param_count, zval **params TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;

PHALCON_ATTR_WARN_UNUSED_RESULT static inline int phalcon_return_call_function(zval *return_value, zval **return_value_ptr, const char *func, uint func_len, uint param_count, zval **params TSRMLS_DC)
{
	zval *rv = NULL, **rvp = return_value_ptr ? return_value_ptr : &rv;
	int status;

	if (return_value_ptr) {
		zval_ptr_dtor(return_value_ptr);
		*return_value_ptr = NULL;
	}

	status = phalcon_call_func_aparams(rvp, func, func_len, param_count, params TSRMLS_CC);

	if (status == FAILURE) {
		if (return_value_ptr && EG(exception)) {
			ALLOC_INIT_ZVAL(*return_value_ptr);
		}

		return FAILURE;
	}

	if (!return_value_ptr) {
		COPY_PZVAL_TO_ZVAL(*return_value, rv);
	}

	return SUCCESS;
}

static int phalcon_call_class_method_aparams(zval **return_value_ptr, zend_class_entry *ce, phalcon_call_type type, zval *object, const char *method_name, uint method_len, uint param_count, zval **params TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;

PHALCON_ATTR_WARN_UNUSED_RESULT static inline int phalcon_return_call_class_method(zval *return_value, zval **return_value_ptr, zend_class_entry *ce, phalcon_call_type type, zval *object, const char *method_name, uint method_len, uint param_count, zval **params TSRMLS_DC)
{
	zval *rv = NULL, **rvp = return_value_ptr ? return_value_ptr : &rv;
	int status;

	if (return_value_ptr) {
		zval_ptr_dtor(return_value_ptr);
		*return_value_ptr = NULL;
	}

	status = phalcon_call_class_method_aparams(rvp, ce, type, object, method_name, method_len, param_count, params TSRMLS_CC);

	if (status == FAILURE) {
		if (return_value_ptr && EG(exception)) {
			ALLOC_INIT_ZVAL(*return_value_ptr);
		}

		return FAILURE;
	}

	if (!return_value_ptr) {
		COPY_PZVAL_TO_ZVAL(*return_value, rv);
	}

	return SUCCESS;
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL2(2, 3)
static inline int phalcon_call_method(zval **return_value_ptr, zval *object, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_call_class_method_aparams(return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL3(1, 3, 4)
static inline int phalcon_return_call_method(zval *return_value, zval **return_value_ptr, zval *object, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_return_call_class_method(return_value, return_value_ptr, Z_OBJCE_P(object), phalcon_fcall_method, object, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL1(2)
static inline int phalcon_call_static(zval **return_value_ptr, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL2(1, 3)
static inline int phalcon_return_call_static(zval *return_value, zval **return_value_ptr, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_static, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL1(2)
static inline int phalcon_call_self(zval **return_value_ptr, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_call_class_method_aparams(return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL2(1, 3)
static inline int phalcon_return_call_self(zval *return_value, zval **return_value_ptr, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_return_call_class_method(return_value, return_value_ptr, NULL, phalcon_fcall_self, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL1(3)
static inline int phalcon_call_parent(zval **return_value_ptr, zval *object, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_call_class_method_aparams(return_value_ptr, (object ? Z_OBJCE_P(object) : NULL), phalcon_fcall_parent, object, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL2(1, 4)
static inline int phalcon_return_call_parent(zval *return_value, zval **return_value_ptr, zval *object, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_return_call_class_method(return_value, return_value_ptr, (object ? Z_OBJCE_P(object) : NULL), phalcon_fcall_parent, object, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL2(2, 3)
static inline int phalcon_call_ce(zval **return_value_ptr, zend_class_entry *ce, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_call_class_method_aparams(return_value_ptr, ce, phalcon_fcall_ce, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL3(1, 3, 4)
static inline int phalcon_return_call_ce(zval *return_value, zval **return_value_ptr, zend_class_entry *ce, const char *method, uint nparams, zval **params TSRMLS_DC)
{
	return phalcon_return_call_class_method(return_value, return_value_ptr, ce, phalcon_fcall_ce, NULL, method, strlen(method), nparams, params TSRMLS_CC);
}

/** Fast call_user_func_array/call_user_func */
static int phalcon_call_user_func_array_noex(zval *return_value, zval *handler, zval *params TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;

PHALCON_ATTR_WARN_UNUSED_RESULT static inline int phalcon_call_user_func_array(zval *return_value, zval *handler, zval *params TSRMLS_DC)
{
	int status = phalcon_call_user_func_array_noex(return_value, handler, params TSRMLS_CC);
	return (EG(exception)) ? FAILURE : status;
}

#ifndef PHALCON_RELEASE
static void phalcon_fcall_cache_dtor(void *pData);
#endif

static int phalcon_cleanup_fcache(void *pDest TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key);

static int phalcon_has_constructor_ce(const zend_class_entry *ce) PHALCON_ATTR_PURE PHALCON_ATTR_NONNULL;

PHALCON_ATTR_WARN_UNUSED_RESULT PHALCON_ATTR_NONNULL static inline int phalcon_has_constructor(const zval *object TSRMLS_DC)
{
	return Z_TYPE_P(object) == IS_OBJECT ? phalcon_has_constructor_ce(Z_OBJCE_P(object)) : 0;
}

/** PHP < 5.3.9 has problems with closures */
#if PHP_VERSION_ID <= 50309
static int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC);
#define PHALCON_ZEND_CALL_FUNCTION_WRAPPER phalcon_call_function
#else
#define PHALCON_ZEND_CALL_FUNCTION_WRAPPER zend_call_function
#endif

#ifndef zend_error_noreturn
#define zend_error_noreturn zend_error
#endif

#endif /* PHALCON_KERNEL_FCALL_H */




#ifndef PHALCON_KERNEL_ARRAY_H
#define PHALCON_KERNEL_ARRAY_H


static int phalcon_array_isset_fetch(zval **fetched, const zval *arr, const zval *index) PHALCON_ATTR_NONNULL;

static int phalcon_array_isset_quick_string_fetch(zval **fetched, const zval *arr, const char *index, uint index_length, ulong key) PHALCON_ATTR_NONNULL;

static int phalcon_array_isset_long_fetch(zval **fetched, const zval *arr, ulong index) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_isset_string_fetch(zval **fetched, const zval *arr, const char *index, uint index_length)
{
#ifdef __GNUC__
	if (__builtin_constant_p(index) && __builtin_constant_p(index_length)) {
		return phalcon_array_isset_quick_string_fetch(fetched, arr, index, index_length, zend_inline_hash_func(index, index_length));
	}
#endif

	return phalcon_array_isset_quick_string_fetch(fetched, arr, index, index_length, zend_hash_func(index, index_length));
}


static int phalcon_array_isset(const zval *arr, const zval *index) PHALCON_ATTR_NONNULL;

static int phalcon_array_isset_long(const zval *arr, ulong index) PHALCON_ATTR_NONNULL;

static int phalcon_array_isset_quick_string(const zval *arr, const char *index, uint index_length, ulong key) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_isset_string(const zval *arr, const char *index, uint index_length)
{
#ifdef __GNUC__
	if (__builtin_constant_p(index) && __builtin_constant_p(index_length)) {
		return phalcon_array_isset_quick_string(arr, index, index_length, zend_inline_hash_func(index, index_length));
	}
#endif

	return phalcon_array_isset_quick_string(arr, index, index_length, zend_hash_func(index, index_length));
}

static int phalcon_array_unset(zval **arr, const zval *index, int flags) PHALCON_ATTR_NONNULL;

static int phalcon_array_unset_long(zval **arr, ulong index, int flags) PHALCON_ATTR_NONNULL;

static int phalcon_array_unset_string(zval **arr, const char *index, uint index_length, int flags) PHALCON_ATTR_NONNULL;

static int phalcon_array_append(zval **arr, zval *value, int flags) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_append_long(zval **arr, long value, int flags)
{
	zval *zvalue;

	PHALCON_ALLOC_GHOST_ZVAL(zvalue);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_append(arr, zvalue, flags);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_append_string(zval **arr, const char *value, uint value_length, int separate)
{
	zval *zvalue;

	PHALCON_ALLOC_GHOST_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_append(arr, zvalue, separate);
}

static int phalcon_array_update_zval(zval **arr, const zval *index, zval *value, int flags) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_zval_bool(zval **arr, zval *index, int value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_zval(arr, index, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_zval_long(zval **arr, zval *index, long value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_update_zval(arr, index, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_zval_string(zval **arr, zval *index, char *value, uint value_length, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_zval(arr, index, zvalue, flags & PH_SEPARATE);
}

static int phalcon_array_update_quick_string(zval **arr, const char *index, uint index_length, ulong key, zval *value, int flags) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_string(zval **arr, const char *index, uint index_length, zval *value, int flags)
{
#ifdef __GNUC__
	if (__builtin_constant_p(index) && __builtin_constant_p(index_length)) {
		return phalcon_array_update_quick_string(arr, index, index_length + 1, zend_inline_hash_func(index, index_length + 1), value, flags);
	}
#endif

	return phalcon_array_update_quick_string(arr, index, index_length + 1, zend_hash_func(index, index_length + 1), value, flags);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_string_bool(zval **arr, const char *index, uint index_length, int value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_string(arr, index, index_length, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_string_long(zval **arr, const char *index, uint index_length, long value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_update_string(arr, index, index_length, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_string_string(zval **arr, const char *index, uint index_length, char *value, uint value_length, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_string(arr, index, index_length, zvalue, flags & PH_SEPARATE);
}

static int phalcon_array_update_long(zval **arr, ulong index, zval *value, int flags) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_long_string(zval **arr, ulong index, char *value, uint value_length, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_STRINGL(zvalue, value, value_length, 1);

	return phalcon_array_update_long(arr, index, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_long_long(zval **arr, ulong index, long value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_LONG(zvalue, value);

	return phalcon_array_update_long(arr, index, zvalue, flags & PH_SEPARATE);
}

PHALCON_ATTR_NONNULL static inline int phalcon_array_update_long_bool(zval **arr, ulong index, int value, int flags)
{
	zval *zvalue;

	MAKE_STD_ZVAL(zvalue);
	ZVAL_BOOL(zvalue, value);

	return phalcon_array_update_long(arr, index, zvalue, flags & PH_SEPARATE);
}

static void phalcon_array_append_multi_2(zval **arr, const zval *index, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_multi_2(zval **arr, const zval *index1, const zval *index2, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_string_multi_2(zval **arr, const zval *index1, const char *index2, uint index2_length, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_long_long_multi_2(zval **arr, ulong index1, ulong index2, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_long_string_multi_2(zval **arr, ulong index1, const char *index2, uint index2_length, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_zval_string_append_multi_3(zval **arr, const zval *index1, const char *index2, uint index2_length, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_zval_zval_zval_multi_3(zval **arr, const zval *index1, const zval *index2, const zval *index3, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_string_zval_zval_multi_3(zval **arr, const zval *index1, const zval *index2, const char *index3, uint index3_length, zval *value, int flags) PHALCON_ATTR_NONNULL;

static void phalcon_array_update_zval_string_string_multi_3(zval **arr, const zval *index1, const char *index2, uint index2_length, const char *index3, uint index3_length, zval *value, int flags) PHALCON_ATTR_NONNULL;

static int phalcon_array_fetch(zval **return_value, const zval *arr, const zval *index, int silent) PHALCON_ATTR_NONNULL;

static int phalcon_array_fetch_long(zval **return_value, const zval *arr, ulong index, int silent) PHALCON_ATTR_NONNULL;

static int phalcon_array_fetch_quick_string(zval **return_value, const zval *arr, const char *index, uint index_length, ulong key, int silent) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_array_fetch_string(zval **return_value, zval *arr, const char *index, uint index_length, int silent)
{
#ifdef __GNUC__
	if (__builtin_constant_p(index) && __builtin_constant_p(index_length)) {
		return phalcon_array_fetch_quick_string(return_value, arr, index, index_length + 1, zend_inline_hash_func(index, index_length + 1), silent);
	}
#endif

	return phalcon_array_fetch_quick_string(return_value, arr, index, index_length + 1, zend_hash_func(index, index_length + 1), silent);
}


static void phalcon_merge_append(zval *left, zval *values) PHALCON_ATTR_NONNULL;

static void phalcon_array_get_current(zval *return_value, zval *array) PHALCON_ATTR_NONNULL;

static int phalcon_fast_in_array(zval *needle, zval *haystack TSRMLS_DC) PHALCON_ATTR_NONNULL;

static void phalcon_fast_array_merge(zval *return_value, zval **array1, zval **array2 TSRMLS_DC) PHALCON_ATTR_NONNULL;

static void phalcon_array_merge_recursive_n(zval **a1, zval *a2) PHALCON_ATTR_NONNULL;

HashTable* phalcon_array_splice(HashTable *in_hash, int offset, int length, zval ***list, int list_count, HashTable **removed TSRMLS_DC);

static void phalcon_array_unshift(zval *arr, zval *arg TSRMLS_DC) PHALCON_ATTR_NONNULL;

static void phalcon_array_keys(zval *return_value, zval *arr) PHALCON_ATTR_NONNULL;

static void phalcon_array_values(zval *return_value, zval *arr) PHALCON_ATTR_NONNULL;

static int phalcon_array_key_exists(zval *arr, zval *key TSRMLS_DC) PHALCON_ATTR_NONNULL;

#endif /* PHALCON_KERNEL_ARRAY_H */




#ifndef PHALCON_KERNEL_HASH_H
#define PHALCON_KERNEL_HASH_H

#include <Zend/zend.h>

static int phalcon_hash_exists(const HashTable *ht, const char *arKey, uint nKeyLength);
static int phalcon_hash_quick_exists(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h);
static int phalcon_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData);
static int phalcon_hash_quick_find(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void **pData);
static void phalcon_get_current_key(zval **key, const HashTable *hash_table, HashPosition *hash_position TSRMLS_DC);
zval phalcon_get_current_key_w(const HashTable *hash_table, HashPosition *hash_position);
static int phalcon_has_numeric_keys(const zval *data);
static int phalcon_hash_update_or_insert(HashTable *ht, const zval *offset, zval *value);

#if PHP_VERSION_ID >= 50400
zval** phalcon_hash_fast_get(HashTable *ht, int type, const zend_literal *key) PHALCON_ATTR_NONNULL;
static int phalcon_hash_quick_update_or_insert(HashTable *ht, zval *value, const zend_literal *key) PHALCON_ATTR_NONNULL;
static int phalcon_hash_fast_unset(HashTable *ht, const zend_literal *key) PHALCON_ATTR_NONNULL;
#endif

zval** phalcon_hash_get(HashTable *ht, const zval *key, int type);
static int phalcon_hash_unset(HashTable *ht, const zval *offset);

#endif /* PHALCON_KERNEL_HASH_H */




#ifndef PHALCON_KERNEL_OBJECT_H
#define PHALCON_KERNEL_OBJECT_H


/** Class Retrieving/Checking */
static int phalcon_class_exists(const char *class_name, zend_uint class_len, int autoload TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_class_exists_ex(zend_class_entry **zce, const zval *class_name, int autoload TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_get_class(zval *result, const zval *object, int lower TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_get_class_ns(zval *result, const zval *object, int lower TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_get_ns_class(zval *result, const zval *object, int lower TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_get_called_class(zval *return_value TSRMLS_DC) PHALCON_ATTR_NONNULL;
zend_class_entry* phalcon_fetch_class(const zval *class_name TSRMLS_DC) PHALCON_ATTR_NONNULL;
zend_class_entry* phalcon_fetch_self_class(TSRMLS_D);
zend_class_entry* phalcon_fetch_parent_class(TSRMLS_D);
zend_class_entry* phalcon_fetch_static_class(TSRMLS_D);

/** Class constants */
static int phalcon_get_class_constant(zval *return_value, const zend_class_entry *ce, const char *constant_name, zend_uint constant_length TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Cloning */
static int phalcon_clone(zval *destination, zval *obj TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Method exists */
static int phalcon_method_exists(const zval *object, const zval *method_name TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_method_exists_ex(const zval *object, const char *method_name, zend_uint method_len TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_method_quick_exists_ex(const zval *object, const char *method_name, zend_uint method_len, ulong hash TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Isset properties */
static int phalcon_isset_property_quick(zval *object, const char *property_name, zend_uint property_length, ulong hash TSRMLS_DC) PHALCON_ATTR_NONNULL;

PHALCON_ATTR_NONNULL static inline int phalcon_isset_property(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_isset_property_quick(object, property_name, property_length, zend_inline_hash_func(property_name, property_length) TSRMLS_CC);
	}
#endif

	return phalcon_isset_property_quick(object, property_name, property_length, zend_hash_func(property_name, property_length) TSRMLS_CC);
}

PHALCON_ATTR_NONNULL static inline int phalcon_isset_property_zval(zval *object, const zval *property TSRMLS_DC)
{
	if (Z_TYPE_P(property) == IS_STRING) {
		ulong hash = zend_hash_func(Z_STRVAL_P(property), Z_STRLEN_P(property) + 1);
		return phalcon_isset_property_quick(object, Z_STRVAL_P(property), Z_STRLEN_P(property) + 1, hash TSRMLS_CC);
	}

	return 0;
}

/** Reading properties */
zval* phalcon_fetch_property_this_quick(zval *object, const char *property_name, zend_uint property_length, ulong key, int silent TSRMLS_DC);
static int phalcon_read_property(zval **result, zval *object, const char *property_name, zend_uint property_length, int silent TSRMLS_DC);
static int phalcon_read_property_zval(zval **result, zval *object, const zval *property, int silent TSRMLS_DC);
static int phalcon_return_property_quick(zval *return_value, zval **return_value_ptr, zval *object, const char *property_name, zend_uint property_length, ulong key TSRMLS_DC);

PHALCON_ATTR_NONNULL static inline int phalcon_read_property_this_quick(zval **result, zval *object, const char *property_name, zend_uint property_length, ulong key, int silent TSRMLS_DC)
{
	zval *tmp = phalcon_fetch_property_this_quick(object, property_name, property_length, key, silent TSRMLS_CC);
	if (EXPECTED(tmp != NULL)) {
		*result = tmp;
		Z_ADDREF_PP(result);
		return SUCCESS;
	}

	ALLOC_INIT_ZVAL(*result);
	return FAILURE;
}

PHALCON_ATTR_NONNULL static inline int phalcon_read_property_this(zval **result, zval *object, const char *property_name, zend_uint property_length, int silent TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_read_property_this_quick(result, object, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
	}
#endif

	return phalcon_read_property_this_quick(result, object, property_name, property_length, zend_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
}

PHALCON_ATTR_NONNULL static inline zval* phalcon_fetch_nproperty_this_quick(zval *object, const char *property_name, zend_uint property_length, ulong key, int silent TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		zval *result = phalcon_fetch_property_this_quick(object, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
		return result ? result : EG(uninitialized_zval_ptr);
	}
#endif

	zval *result = phalcon_fetch_property_this_quick(object, property_name, property_length, zend_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
	return result ? result : EG(uninitialized_zval_ptr);
}

PHALCON_ATTR_NONNULL static inline zval* phalcon_fetch_nproperty_this(zval *object, const char *property_name, zend_uint property_length, int silent TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_fetch_nproperty_this_quick(object, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
	}
#endif

	return phalcon_fetch_nproperty_this_quick(object, property_name, property_length, zend_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
}

PHALCON_ATTR_NONNULL static inline zval* phalcon_fetch_property_this(zval *object, const char *property_name, zend_uint property_length, int silent TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_fetch_property_this_quick(object, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
	}
#endif

	return phalcon_fetch_property_this_quick(object, property_name, property_length, zend_hash_func(property_name, property_length + 1), silent TSRMLS_CC);
}

PHALCON_ATTR_NONNULL3(1,3,4) static inline int phalcon_return_property(zval *return_value, zval **return_value_ptr, zval *object, const char *property_name, zend_uint property_length TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_return_property_quick(return_value, return_value_ptr, object, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1) TSRMLS_CC);
	}
#endif

	return phalcon_return_property_quick(return_value, return_value_ptr, object, property_name, property_length, zend_hash_func(property_name, property_length + 1) TSRMLS_CC);
}


/** Updating properties */
static int phalcon_update_property_long(zval *obj, const char *property_name, zend_uint property_length, long value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_string(zval *object, const char *property_name, zend_uint property_length, const char *str, zend_uint str_length TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_bool(zval *obj, const char *property_name, zend_uint property_length, int value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_null(zval *obj, const char *property_name, zend_uint property_length TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_zval(zval *obj, const char *property_name, zend_uint property_length, zval *value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_zval_zval(zval *obj, const zval *property, zval *value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_empty_array(zval *object, const char *property, zend_uint property_length TSRMLS_DC) PHALCON_ATTR_NONNULL;

static int phalcon_update_property_this_quick(zval *object, const char *property_name, zend_uint property_length, zval *value, ulong key TSRMLS_DC);

PHALCON_ATTR_NONNULL static inline int phalcon_update_property_this(zval *object, const char *property_name, zend_uint property_length, zval *value TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(property_name) && __builtin_constant_p(property_length)) {
		return phalcon_update_property_this_quick(object, property_name, property_length, value, zend_inline_hash_func(property_name, property_length + 1) TSRMLS_CC);
	}
#endif

	return phalcon_update_property_this_quick(object, property_name, property_length, value, zend_hash_func(property_name, property_length + 1) TSRMLS_CC);
}


/** Updating array properties */
static int phalcon_update_property_array(zval *object, const char *property, zend_uint property_length, const zval *index, zval *value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_array_string(zval *object, const char *property, zend_uint property_length, const char *index, zend_uint index_length, zval *value TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_property_array_append(zval *object, const char *property, zend_uint property_length, zval *value TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Increment/Decrement properties */
static int phalcon_property_incr(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_property_decr(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Unset Array properties */
static int phalcon_unset_property_array(zval *object, const char *property, zend_uint property_length, const zval *index TSRMLS_DC) PHALCON_ATTR_NONNULL;

/** Static properties */
static int phalcon_read_static_property(zval **result, const char *class_name, zend_uint class_length, const char *property_name, zend_uint property_length TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_read_class_property(zval **result, int type, const char *property, zend_uint len TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_update_static_property_array_multi_ce(zend_class_entry *ce, const char *property, zend_uint property_length, zval *value TSRMLS_DC, const char *types, int types_length, int types_count, ...);

PHALCON_ATTR_NONNULL static inline zval* phalcon_fetch_static_property_ce(zend_class_entry *ce, const char *property, zend_uint len TSRMLS_DC)
{
#if PHP_VERSION_ID < 50400
	return zend_read_static_property(ce, (char*)property, len, (zend_bool)ZEND_FETCH_CLASS_SILENT TSRMLS_CC);
#else
	return zend_read_static_property(ce, property, len, (zend_bool)ZEND_FETCH_CLASS_SILENT TSRMLS_CC);
#endif
}

PHALCON_ATTR_NONNULL static inline int phalcon_read_static_property_ce(zval **result, zend_class_entry *ce, const char *property, zend_uint len TSRMLS_DC)
{
	*result = phalcon_fetch_static_property_ce(ce, property, len TSRMLS_CC);
	if (*result) {
		Z_ADDREF_PP(result);
		return SUCCESS;
	}

	return FAILURE;
}

PHALCON_ATTR_NONNULL static inline int phalcon_update_static_property_ce(zend_class_entry *ce, const char *name, zend_uint len, zval *value TSRMLS_DC)
{
#if PHP_VERSION_ID < 50400
	return zend_update_static_property(ce, (char*)name, len, value TSRMLS_CC);
#else
	return zend_update_static_property(ce, name, len, value TSRMLS_CC);
#endif
}

PHALCON_ATTR_NONNULL static inline int phalcon_update_static_property(const char *class_name, zend_uint class_length, const char *name, zend_uint name_length, zval *value TSRMLS_DC)
{
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		return phalcon_update_static_property_ce(*ce, name, name_length, value TSRMLS_CC);
	}

	return FAILURE;
}


/** Create instances */
static int phalcon_create_instance_params_ce(zval *return_value, zend_class_entry *ce, zval *params TSRMLS_DC) PHALCON_ATTR_NONNULL2(1, 2);
static int phalcon_create_instance(zval *return_value, const zval *class_name TSRMLS_DC) PHALCON_ATTR_NONNULL;
static int phalcon_create_instance_params(zval *return_value, const zval *class_name, zval *params TSRMLS_DC) PHALCON_ATTR_NONNULL2(1, 2);

#if PHP_VERSION_ID < 50400
void object_properties_init(zend_object *object, zend_class_entry *class_type);
#endif

#endif /* PHALCON_KERNEL_OBJECT_H */




#ifndef PHALCON_KERNEL_STRING_H
#define PHALCON_KERNEL_STRING_H


#define PHALCON_TRIM_LEFT  1
#define PHALCON_TRIM_RIGHT 2
#define PHALCON_TRIM_BOTH  3

/** Fast char position */
static int phalcon_memnstr(const zval *haystack, const zval *needle);
static int phalcon_memnstr_str(const zval *haystack, char *needle, unsigned int needle_length);

/** Function replacement */
static void phalcon_fast_strlen(zval *return_value, zval *str);
static void phalcon_fast_strtolower(zval *return_value, zval *str);
static void phalcon_strtolower_inplace(zval *s);
static void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC);
static void phalcon_fast_join_str(zval *result, char *glue, unsigned int glue_length, zval *pieces TSRMLS_DC);
static void phalcon_fast_explode(zval *result, zval *delimiter, zval *str);
static void phalcon_fast_explode_str(zval *result, const char *delimiter, int delimiter_length, zval *str);
static void phalcon_fast_strpos(zval *return_value, const zval *haystack, const zval *needle);
static void phalcon_fast_strpos_str(zval *return_value, const zval *haystack, char *needle, unsigned int needle_length);
static void phalcon_fast_stripos_str(zval *return_value, zval *haystack, char *needle, unsigned int needle_length);
static void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject);
static void phalcon_fast_trim(zval *return_value, zval *str, int where TSRMLS_DC);
static void phalcon_fast_strip_tags(zval *return_value, zval *str);
static void phalcon_fast_strtoupper(zval *return_value, zval *str);

/** Camelize/Uncamelize */
static void phalcon_camelize(zval *return_value, const zval *str);
static void phalcon_uncamelize(zval *return_value, const zval *str);

/** Starts/Ends with */
static int phalcon_start_with(const zval *str, const zval *compared, zval *case_sensitive);
static int phalcon_start_with_str(const zval *str, char *compared, unsigned int compared_length);
static int phalcon_start_with_str_str(char *str, unsigned int str_length, char *compared, unsigned int compared_length);
static int phalcon_end_with(const zval *str, const zval *compared, zval *case_sensitive);
static int phalcon_end_with_str(const zval *str, char *compared, unsigned int compared_length);

/** Random string */
static void phalcon_random_string(zval *return_value, const zval *type, const zval *length TSRMLS_DC);

/* Strips extra slashes */
static void phalcon_remove_extra_slashes(zval *return_value, const zval *str);

/** Generates a unique key for an array/object */
static void phalcon_unique_key(zval *return_value, zval *prefix, zval *value TSRMLS_DC);

/** spprintf */
static int phalcon_spprintf(char **message, int max_len, char *format, ...);

/* Substr */
static void phalcon_substr(zval *return_value, zval *str, unsigned long from, unsigned long length);

/** Preg-Match */
static int phalcon_preg_match(zval *return_value, zval *regex, zval *subject, zval *matches TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;

/** Base64 */
static void phalcon_base64_encode(zval *return_value, zval *data);
static void phalcon_base64_decode(zval *return_value, zval *data);

/** Hash */
static void phalcon_md5(zval *return_value, zval *str);

/** JSON */
static int phalcon_json_encode(zval *return_value, zval *v, int opts TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;
static int phalcon_json_decode(zval *return_value, zval *v, zend_bool assoc TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;

/***/
static void phalcon_lcfirst(zval *return_value, zval *s);
static void phalcon_ucfirst(zval *return_value, zval *s);
static int phalcon_http_build_query(zval *return_value, zval *params, char *sep TSRMLS_DC);
static void phalcon_htmlspecialchars(zval *return_value, zval *string, zval *quoting, zval *charset TSRMLS_DC);
static void phalcon_htmlentities(zval *return_value, zval *string, zval *quoting, zval *charset TSRMLS_DC);
static void phalcon_strval(zval *return_value, zval *v);
static void phalcon_date(zval *return_value, zval *format, zval *timestamp TSRMLS_DC);
static void phalcon_addslashes(zval *return_value, zval *str TSRMLS_DC);
static void phalcon_add_trailing_slash(zval** v);

#endif /* PHALCON_KERNEL_STRING_H */



#ifndef PHALCON_KERNEL_MBSTRING_H
#define PHALCON_KERNEL_MBSTRING_H

#if 0

#include <ext/mbstring/mbstring.h>

#ifdef ZTS
ts_rsrc_id mbstring_globals_id;
#else
struct zend_mbstring_globals;
zend_mbstring_globals *mbstring_globals;
#endif

static int phalcon_mb_strlen(char *str, uint len, int *ret_len TSRMLS_DC);
static int phalcon_mb_strtolower(char *str, uint len, char **ret, int *ret_len TSRMLS_DC);
static int phalcon_mb_strtoupper(char *str, uint len, char **ret, int *ret_len TSRMLS_DC);
static int phalcon_mb_strpos(char *haystack, size_t haystack_len, char *needle, size_t needle_len, int offset, int *ret TSRMLS_DC);
static int phalcon_mb_substr(char *str, size_t str_len, int from, int len, char **res, int *res_len TSRMLS_DC);
static int phalcon_mb_detect_encoding(char *str, size_t str_len, char *encoding, int strict, char **res TSRMLS_DC);

#endif

#endif	/* PHALCON_KERNEL_MBSTRING_H */




#ifndef PHALCON_KERNEL_FILTER_H
#define PHALCON_KERNEL_FILTER_H


static void phalcon_escape_multi(zval *return_value, zval *param, const char *escape_char, unsigned int escape_length, char escape_extra, int use_whitelist);


/** Low level filters */
static void phalcon_filter_alphanum(zval *return_value, zval *param) PHALCON_ATTR_NONNULL;
static void phalcon_filter_identifier(zval *return_value, zval *param) PHALCON_ATTR_NONNULL;

/** Encoding */
static void phalcon_is_basic_charset(zval *return_value, const zval *param) PHALCON_ATTR_NONNULL;

/** Escaping */

PHALCON_ATTR_NONNULL static inline void phalcon_escape_css(zval *return_value, zval *param)
{
	phalcon_escape_multi(return_value, param, ZEND_STRL("\\"), ' ', 0);
}

PHALCON_ATTR_NONNULL static inline void phalcon_escape_js(zval *return_value, zval *param)
{
	phalcon_escape_multi(return_value, param, ZEND_STRL("\\x"), '\0', 1);
}

PHALCON_ATTR_NONNULL static inline void phalcon_escape_htmlattr(zval *return_value, zval *param)
{
	phalcon_escape_multi(return_value, param, ZEND_STRL("&#x"), ';', 1);
}

static void phalcon_escape_html(zval *return_value, zval *str, const zval *quote_style, const zval *charset TSRMLS_DC) PHALCON_ATTR_NONNULL;

#endif /* PHALCON_KERNEL_FILTER_H */



#ifndef PHALCON_KERNEL_FILE_H
#define PHALCON_KERNEL_FILE_H


static int phalcon_file_exists(zval *filename TSRMLS_DC);
static int phalcon_compare_mtime(zval *filename1, zval *filename2 TSRMLS_DC);
static void phalcon_fix_path(zval **return_value, zval *path, zval *directory_separator TSRMLS_DC);
static void phalcon_prepare_virtual_path(zval *return_value, zval *path, zval *virtual_separator TSRMLS_DC);
static void phalcon_unique_path_key(zval *return_value, zval *path TSRMLS_DC);
static void phalcon_realpath(zval *return_value, zval *filename TSRMLS_DC);
static void phalcon_file_get_contents(zval *return_value, zval *filename TSRMLS_DC);
static void phalcon_file_put_contents(zval *return_value, zval *filename, zval *data TSRMLS_DC);
static void phalcon_possible_autoload_filepath(zval *return_value, zval *prefix, zval *class_name, zval *virtual_separator, zval *separator TSRMLS_DC);

static void phalcon_is_dir(zval *return_value, zval *path TSRMLS_DC);
static void phalcon_unlink(zval *return_value, zval *path TSRMLS_DC);
static void phalcon_filemtime(zval *return_value, zval *path TSRMLS_DC);
static void phalcon_basename(zval *return_value, zval *path TSRMLS_DC);

static void phalcon_prepare_virtual_path_ex(zval *return_value, const char *path, size_t path_len, char virtual_separator TSRMLS_DC);

#endif /* PHALCON_KERNEL_FILE_H */




#ifndef PHALCON_KERNEL_OUTPUT_H
#define PHALCON_KERNEL_OUTPUT_H


static void phalcon_ob_start(TSRMLS_D);
static void phalcon_ob_get_contents(zval *result TSRMLS_DC);
static int phalcon_ob_end_flush(TSRMLS_D);
static int phalcon_ob_end_clean(TSRMLS_D);
static int phalcon_ob_flush(TSRMLS_D);
static int phalcon_ob_clean(TSRMLS_D);
static int phalcon_ob_get_level(TSRMLS_D);

#endif /* PHALCON_KERNEL_OUTPUT_H */




#ifndef PHALCON_KERNEL_OPERATORS_H
#define PHALCON_KERNEL_OPERATORS_H


/** Strict comparing */
#define PHALCON_IS_LONG(op1, op2)   phalcon_compare_strict_long(op1, op2 TSRMLS_CC)
#define PHALCON_IS_STRING(op1, op2) phalcon_compare_strict_string(op1, op2, strlen(op2))

/** strict boolean comparison */
#define PHALCON_IS_FALSE(var)       (Z_TYPE_P(var) == IS_BOOL && !Z_BVAL_P(var))
#define PHALCON_IS_TRUE(var)        (Z_TYPE_P(var) == IS_BOOL && Z_BVAL_P(var))

#define PHALCON_IS_NOT_FALSE(var)   (Z_TYPE_P(var) != IS_BOOL || (Z_TYPE_P(var) == IS_BOOL && Z_BVAL_P(var)))
#define PHALCON_IS_NOT_TRUE(var)    (Z_TYPE_P(var) != IS_BOOL || (Z_TYPE_P(var) == IS_BOOL && !Z_BVAL_P(var)))

/** SQL null empty **/
#define PHALCON_IS_EMPTY(var)       (Z_TYPE_P(var) == IS_NULL || (Z_TYPE_P(var) == IS_STRING && !Z_STRLEN_P(var)))
#define PHALCON_IS_NOT_EMPTY(var)   (!(Z_TYPE_P(var) == IS_NULL || (Z_TYPE_P(var) == IS_STRING && !Z_STRLEN_P(var))))

/** Is scalar */
#define PHALCON_IS_SCALAR(var)      (!(Z_TYPE_P(var) == IS_NULL || Z_TYPE_P(var) == IS_ARRAY || Z_TYPE_P(var) == IS_OBJECT || Z_TYPE_P(var) == IS_RESOURCE))
#define PHALCON_IS_NOT_SCALAR(var)  (Z_TYPE_P(var) == IS_NULL || Z_TYPE_P(var) == IS_ARRAY || Z_TYPE_P(var) == IS_OBJECT || Z_TYPE_P(var) == IS_RESOURCE)

/** Equals/Identical */
#define PHALCON_IS_EQUAL(op1, op2)      phalcon_is_equal(op1, op2 TSRMLS_CC)
#define PHALCON_IS_IDENTICAL(op1, op2)  phalcon_is_identical(op1, op2 TSRMLS_CC)

/** Greater/Smaller equals */
#define PHALCON_LE(op1, op2)       phalcon_less_equal(op1, op2 TSRMLS_CC)
#define PHALCON_LE_LONG(op1, op2)  phalcon_less_equal_long(op1, op2 TSRMLS_CC)
#define PHALCON_GE(op1, op2)       phalcon_greater_equal(op1, op2 TSRMLS_CC)
#define PHALCON_GE_LONG(op1, op2)  phalcon_greater_equal_long(op1, op2 TSRMLS_CC)
#define PHALCON_LT(op1, op2)       phalcon_less(op1, op2 TSRMLS_CC)
#define PHALCON_LT_LONG(op1, op2)  phalcon_less_long(op1, op2 TSRMLS_CC)
#define PHALCON_GT(op1, op2)       phalcon_greater(op1, op2 TSRMLS_CC)
#define PHALCON_GT_LONG(op1, op2)  phalcon_greater_long(op1, op2 TSRMLS_CC)

#if PHP_VERSION_ID < 50400
#define phalcon_increment(var) increment_function(var)
#else
#define phalcon_increment(var) fast_increment_function(var)
#endif

#if PHP_VERSION_ID < 50400
#define phalcon_decrement(var) decrement_function(var)
#else
#define phalcon_decrement(var) fast_decrement_function(var)
#endif

/** Operator functions */
static int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_and_function(zval *result, zval *left, zval *right);

static void phalcon_concat_self(zval **left, zval *right TSRMLS_DC);
static void phalcon_concat_self_str(zval **left, const char *right, int right_length TSRMLS_DC);

/** Strict comparing */
static int phalcon_compare_strict_string(zval *op1, const char *op2, int op2_length);
static int phalcon_compare_strict_long(zval *op1, long op2 TSRMLS_DC);

static void phalcon_cast(zval *result, zval *var, zend_uint type);
long phalcon_get_intval(const zval *op);
static int phalcon_is_numeric(const zval *op);

static int phalcon_is_equal(zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_is_identical(zval *op1, zval *op2 TSRMLS_DC);

static int phalcon_less(zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_less_long(zval *op1, long op2 TSRMLS_DC);

static int phalcon_greater(zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_greater_long(zval *op1, long op2 TSRMLS_DC);

static int phalcon_less_equal(zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_less_equal_long(zval *op1, long op2 TSRMLS_DC);

static int phalcon_greater_equal(zval *op1, zval *op2 TSRMLS_DC);
static int phalcon_greater_equal_long(zval *op1, long op2 TSRMLS_DC);

#endif /* PHALCON_KERNEL_OPERATORS_H */




#ifndef PHALCON_KERNEL_CONCAT_H
#define PHALCON_KERNEL_CONCAT_H


#define PHALCON_CONCAT_SV(result, op1, op2) \
	 phalcon_concat_sv(&result, op1, sizeof(op1)-1, op2, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SV(result, op1, op2) \
	 phalcon_concat_sv(&result, op1, sizeof(op1)-1, op2, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVS(result, op1, op2, op3) \
	 phalcon_concat_svs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVS(result, op1, op2, op3) \
	 phalcon_concat_svs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_svsv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_svsv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVS(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVS(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVSV(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_svsvsv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVSV(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_svsvsv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVSVS(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_svsvsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, op7, sizeof(op7)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVSVS(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_svsvsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, op7, sizeof(op7)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVSVSVS(result, op1, op2, op3, op4, op5, op6, op7, op8, op9) \
	 phalcon_concat_svsvsvsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, op7, sizeof(op7)-1, op8, op9, sizeof(op9)-1, 0 TSRMLS_CC);

#define PHALCON_SCONCAT_SVSVSVSVS(result, op1, op2, op3, op4, op5, op6, op7, op8, op9) \
	 phalcon_concat_svsvsvsvs(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, sizeof(op5)-1, op6, op7, sizeof(op7)-1, op8, op9, sizeof(op9)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVSVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVSVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_svsvv(&result, op1, sizeof(op1)-1, op2, op3, sizeof(op3)-1, op4, op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVV(result, op1, op2, op3) \
	 phalcon_concat_svv(&result, op1, sizeof(op1)-1, op2, op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVV(result, op1, op2, op3) \
	 phalcon_concat_svv(&result, op1, sizeof(op1)-1, op2, op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_SVVS(result, op1, op2, op3, op4) \
	 phalcon_concat_svvs(&result, op1, sizeof(op1)-1, op2, op3, op4, sizeof(op4)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_SVVS(result, op1, op2, op3, op4) \
	 phalcon_concat_svvs(&result, op1, sizeof(op1)-1, op2, op3, op4, sizeof(op4)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VS(result, op1, op2) \
	 phalcon_concat_vs(&result, op1, op2, sizeof(op2)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VS(result, op1, op2) \
	 phalcon_concat_vs(&result, op1, op2, sizeof(op2)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSV(result, op1, op2, op3) \
	 phalcon_concat_vsv(&result, op1, op2, sizeof(op2)-1, op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSV(result, op1, op2, op3) \
	 phalcon_concat_vsv(&result, op1, op2, sizeof(op2)-1, op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvs(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVS(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvs(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvsv(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvsv(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSVS(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_vsvsvs(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, op6, sizeof(op6)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSVS(result, op1, op2, op3, op4, op5, op6) \
	 phalcon_concat_vsvsvs(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, op6, sizeof(op6)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVSVSV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vsvsvsv(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, op6, sizeof(op6)-1, op7, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVSVSV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vsvsvsv(&result, op1, op2, sizeof(op2)-1, op3, op4, sizeof(op4)-1, op5, op6, sizeof(op6)-1, op7, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvv(&result, op1, op2, sizeof(op2)-1, op3, op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vsvv(&result, op1, op2, sizeof(op2)-1, op3, op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VSVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvvv(&result, op1, op2, sizeof(op2)-1, op3, op4, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VSVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vsvvv(&result, op1, op2, sizeof(op2)-1, op3, op4, op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VV(result, op1, op2) \
	 phalcon_concat_vv(&result, op1, op2, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VV(result, op1, op2) \
	 phalcon_concat_vv(&result, op1, op2, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVS(result, op1, op2, op3) \
	 phalcon_concat_vvs(&result, op1, op2, op3, sizeof(op3)-1, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVS(result, op1, op2, op3) \
	 phalcon_concat_vvs(&result, op1, op2, op3, sizeof(op3)-1, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvsv(&result, op1, op2, op3, sizeof(op3)-1, op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVSV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvsv(&result, op1, op2, op3, sizeof(op3)-1, op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVV(result, op1, op2, op3) \
	 phalcon_concat_vvv(&result, op1, op2, op3, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVV(result, op1, op2, op3) \
	 phalcon_concat_vvv(&result, op1, op2, op3, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvsv(&result, op1, op2, op3, op4, sizeof(op4)-1, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVSV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvsv(&result, op1, op2, op3, op4, sizeof(op4)-1, op5, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvvv(&result, op1, op2, op3, op4, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVV(result, op1, op2, op3, op4) \
	 phalcon_concat_vvvv(&result, op1, op2, op3, op4, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVVSVV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vvvvsvv(&result, op1, op2, op3, op4, op5, sizeof(op5)-1, op6, op7, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVVSVV(result, op1, op2, op3, op4, op5, op6, op7) \
	 phalcon_concat_vvvvsvv(&result, op1, op2, op3, op4, op5, sizeof(op5)-1, op6, op7, 1 TSRMLS_CC);

#define PHALCON_CONCAT_VVVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvvv(&result, op1, op2, op3, op4, op5, 0 TSRMLS_CC);
#define PHALCON_SCONCAT_VVVVV(result, op1, op2, op3, op4, op5) \
	 phalcon_concat_vvvvv(&result, op1, op2, op3, op4, op5, 1 TSRMLS_CC);


static void phalcon_concat_sv(zval **result, const char *op1, zend_uint op1_len, zval *op2, int self_var TSRMLS_DC);
static void phalcon_concat_svs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, int self_var TSRMLS_DC);
static void phalcon_concat_svsv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC);
static void phalcon_concat_svsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, int self_var TSRMLS_DC);
static void phalcon_concat_svsvsv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, int self_var TSRMLS_DC);
static void phalcon_concat_svsvsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, const char *op7, zend_uint op7_len, int self_var TSRMLS_DC);
static void phalcon_concat_svsvsvsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, const char *op7, zend_uint op7_len, zval *op8, const char *op9, zend_uint op9_len, int self_var TSRMLS_DC);

static void phalcon_concat_svsvv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, zval *op5, int self_var TSRMLS_DC);
static void phalcon_concat_svv(zval **result, const char *op1, zend_uint op1_len, zval *op2, zval *op3, int self_var TSRMLS_DC);
static void phalcon_concat_svvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, zval *op3, const char *op4, zend_uint op4_len, int self_var TSRMLS_DC);
static void phalcon_concat_vs(zval **result, zval *op1, const char *op2, zend_uint op2_len, int self_var TSRMLS_DC);
static void phalcon_concat_vsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, int self_var TSRMLS_DC);
static void phalcon_concat_vsvs(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, int self_var TSRMLS_DC);
static void phalcon_concat_vsvsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC);
static void phalcon_concat_vsvsvs(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, const char *op6, zend_uint op6_len, int self_var TSRMLS_DC);
static void phalcon_concat_vsvsvsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, const char *op6, zend_uint op6_len, zval *op7, int self_var TSRMLS_DC);
static void phalcon_concat_vsvv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, zval *op4, int self_var TSRMLS_DC);
static void phalcon_concat_vsvvv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC);
static void phalcon_concat_vv(zval **result, zval *op1, zval *op2, int self_var TSRMLS_DC);
static void phalcon_concat_vvs(zval **result, zval *op1, zval *op2, const char *op3, zend_uint op3_len, int self_var TSRMLS_DC);
static void phalcon_concat_vvsv(zval **result, zval *op1, zval *op2, const char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC);
static void phalcon_concat_vvv(zval **result, zval *op1, zval *op2, zval *op3, int self_var TSRMLS_DC);
static void phalcon_concat_vvvsv(zval **result, zval *op1, zval *op2, zval *op3, const char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC);
static void phalcon_concat_vvvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, int self_var TSRMLS_DC);
static void phalcon_concat_vvvvsvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, const char *op5, zend_uint op5_len, zval *op6, zval *op7, int self_var TSRMLS_DC);
static void phalcon_concat_vvvvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC);

#endif /* PHALCON_KERNEL_CONCAT_H */




#ifndef PHALCON_KERNEL_EXCEPTION_H
#define PHALCON_KERNEL_EXCEPTION_H


/** Exceptions */
#define PHALCON_THROW_EXCEPTION_STR(class_entry, message) \
	do { \
		phalcon_throw_exception_string(class_entry, message TSRMLS_CC); \
		PHALCON_MM_RESTORE(); \
	} while (0)

#define PHALCON_THROW_EXCEPTION_ZVAL(class_entry, message) \
	do { \
		phalcon_throw_exception_zval(class_entry, message TSRMLS_CC); \
		PHALCON_MM_RESTORE(); \
	} while (0)

#define PHALCON_THROW_EXCEPTION_STRW(class_entry, message)  phalcon_throw_exception_string(class_entry, message TSRMLS_CC)
#define PHALCON_THROW_EXCEPTION_ZVALW(class_entry, message) phalcon_throw_exception_zval(class_entry, message TSRMLS_CC)

/** Throw Exceptions */
static void phalcon_throw_exception(zval *object TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_throw_exception_string(zend_class_entry *ce, const char *message TSRMLS_DC) PHALCON_ATTR_NONNULL;
static void phalcon_throw_exception_zval(zend_class_entry *ce, zval *message TSRMLS_DC) PHALCON_ATTR_NONNULL;

#endif /* PHALCON_KERNEL_EXCEPTION_H */




#ifndef PHALCON_KERNEL_REQUIRE_H
#define PHALCON_KERNEL_REQUIRE_H


static int phalcon_require_ret(zval **return_value_ptr, const char *require_path TSRMLS_DC) PHALCON_ATTR_NONNULL1(2);

PHALCON_ATTR_NONNULL static inline int phalcon_require(const char *require_path TSRMLS_DC)
{
	return phalcon_require_ret(NULL, require_path TSRMLS_CC);
}

#endif /* PHALCON_KERNEL_REQUIRE_H */




#ifndef PHALCON_KERNEL_VARIABLES_H
#define PHALCON_KERNEL_VARIABLES_H


static void phalcon_serialize(zval *return_value, zval **var  TSRMLS_DC);
static void phalcon_unserialize(zval *return_value, zval *var TSRMLS_DC);

#endif /* PHALCON_KERNEL_VARIABLES_H */



#ifndef PHALCON_KERNEL_SESSION_H
#define PHALCON_KERNEL_SESSION_H


static int phalcon_session_start(TSRMLS_D) PHALCON_ATTR_WARN_UNUSED_RESULT;
static int phalcon_session_destroy(TSRMLS_D) PHALCON_ATTR_WARN_UNUSED_RESULT;
static int phalcon_get_session_id(zval *return_value, zval **return_value_ptr TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;
static int phalcon_set_session_id(zval *sid TSRMLS_DC) PHALCON_ATTR_WARN_UNUSED_RESULT;
static int phalcon_session_write_close(TSRMLS_D) PHALCON_ATTR_WARN_UNUSED_RESULT;

#endif /* PHALCON_KERNEL_SESSION_H */


#ifndef PHALCON_KERNEL_REFLECTION_H
#define PHALCON_KERNEL_REFLECTION_H


PHALCON_ATTR_NONNULL static inline const char* phalcon_get_class_doc_comment(const zend_class_entry *ce, const char **comment, zend_uint *len)
{
	if (ce->type == ZEND_USER_CLASS) {
#if PHP_VERSION_ID >= 50400
		*comment = ce->info.user.doc_comment;
		*len     = ce->info.user.doc_comment_len;
		return ce->info.user.doc_comment;
#else
		*comment = ce->doc_comment;
		*len     = ce->doc_comment_len;
		return ce->doc_comment;
#endif
	}

	*comment = NULL;
	*len     = 0;
	return NULL;
}

PHALCON_ATTR_NONNULL static inline const char* phalcon_get_class_filename(const zend_class_entry *ce)
{
	if (ce->type == ZEND_USER_CLASS) {
#if PHP_VERSION_ID >= 50400
		return ce->info.user.filename;
#else
		return ce->filename;
#endif
	}

	return NULL;
}

PHALCON_ATTR_NONNULL static inline zend_uint phalcon_get_class_startline(const zend_class_entry *ce)
{
	if (ce->type == ZEND_USER_CLASS) {
#if PHP_VERSION_ID >= 50400
		return ce->info.user.line_start;
#else
		return ce->line_start;
#endif
	}

	return 0;
}

static inline const char* phalcon_get_property_doc_comment(const zend_property_info *prop, const char **comment, zend_uint *len)
{
	*comment = prop->doc_comment;
	*len     = prop->doc_comment_len;
	return prop->doc_comment;
}

static inline const char* phalcon_get_function_doc_comment(const zend_function *func, const char **comment, zend_uint *len)
{
	if (func->type == ZEND_USER_FUNCTION) {
		*comment = func->op_array.doc_comment;
		*len     = func->op_array.doc_comment_len;
		return func->op_array.doc_comment;
	}

	return NULL;
}

static inline zend_uint phalcon_get_function_startline(const zend_function *func)
{
	if (func->type == ZEND_USER_FUNCTION) {
		return func->op_array.line_start;
	}

	return 0;
}

#endif /* PHALCON_KERNEL_REFLECTION_H */




static void phalcon_orm_destroy_cache(TSRMLS_D);
static void phalcon_orm_get_prepared_ast(zval **return_value, zval *unique_id TSRMLS_DC);
static void phalcon_orm_set_prepared_ast(zval *unique_id, zval *prepared_ast TSRMLS_DC);
static void phalcon_orm_singlequotes(zval *return_value, zval *str TSRMLS_DC);



#ifndef PHALCON_KERNEL_FRAMEWORK_ROUTER_H
#define PHALCON_KERNEL_FRAMEWORK_ROUTER_H

#include <Zend/zend.h>

/* Extract named parameters */
static void phalcon_extract_named_params(zval *return_value, zval *str, zval *matches);
static void phalcon_replace_paths(zval *return_value, zval *pattern, zval *paths, zval *uri TSRMLS_DC);

#endif /* PHALCON_KERNEL_FRAMEWORK_ROUTER_H */




/** Get the possible URI based on a script path */
static void phalcon_get_uri(zval *return_value, zval *path);
static void phalcon_raw_url_encode(zval *return_value, zval *url);



#ifndef PHALCON_INTERNED_STRINGS_H
#define PHALCON_INTERNED_STRINGS_H

#include <TSRM/TSRM.h>

const char *phalcon_interned_DELETE;
const char *phalcon_interned_GET;
const char *phalcon_interned_HEAD;
const char *phalcon_interned_OPTIONS;
const char *phalcon_interned_PATCH;
const char *phalcon_interned_POST;
const char *phalcon_interned_PUT;
const char *phalcon_interned_action;
const char *phalcon_interned_alias;
const char *phalcon_interned_all;
const char *phalcon_interned_allowEmpty;
const char *phalcon_interned_arguments;
const char *phalcon_interned_balias;
const char *phalcon_interned_binary_op;
const char *phalcon_interned_code;
const char *phalcon_interned_column;
const char *phalcon_interned_columns;
const char *phalcon_interned_conditions;
const char *phalcon_interned_controller;
const char *phalcon_interned_delete;
const char *phalcon_interned_dispatcher;
const char *phalcon_interned_distinct;
const char *phalcon_interned_domain;
const char *phalcon_interned_escaper;
const char *phalcon_interned_expr;
const char *phalcon_interned_fields;
const char *phalcon_interned_file;
const char *phalcon_interned_filter;
const char *phalcon_interned_functionCall;
const char *phalcon_interned_group;
const char *phalcon_interned_groupBy;
const char *phalcon_interned_having;
const char *phalcon_interned_items;
const char *phalcon_interned_joins;
const char *phalcon_interned_label;
const char *phalcon_interned_left;
const char *phalcon_interned_limit;
const char *phalcon_interned_line;
const char *phalcon_interned_message;
const char *phalcon_interned_model;
const char *phalcon_interned_models;
const char *phalcon_interned_modelsCache;
const char *phalcon_interned_modelsManager;
const char *phalcon_interned_modelsMetadata;
const char *phalcon_interned_module;
const char *phalcon_interned_name;
const char *phalcon_interned_namespace;
const char *phalcon_interned_ns_alias;
const char *phalcon_interned_number;
const char *phalcon_interned_offset;
const char *phalcon_interned_op;
const char *phalcon_interned_order;
const char *phalcon_interned_orderBy;
const char *phalcon_interned_params;
const char *phalcon_interned_parent;
const char *phalcon_interned_paths;
const char *phalcon_interned_qualified;
const char *phalcon_interned_qualifiedName;
const char *phalcon_interned_request;
const char *phalcon_interned_response;
const char *phalcon_interned_right;
const char *phalcon_interned_router;
const char *phalcon_interned_select;
const char *phalcon_interned_self;
const char *phalcon_interned_session;
const char *phalcon_interned_sort;
const char *phalcon_interned_source;
const char *phalcon_interned_sqlAlias;
const char *phalcon_interned_static;
const char *phalcon_interned_table;
const char *phalcon_interned_tables;
const char *phalcon_interned_type;
const char *phalcon_interned_update;
const char *phalcon_interned_url;
const char *phalcon_interned_value;
const char *phalcon_interned_values;
const char *phalcon_interned_where;

static void phalcon_init_interned_strings(TSRMLS_D);

#if PHP_VERSION_ID < 50400

static inline const char* zend_new_interned_string(const char *arKey, int nKeyLength, int free_src TSRMLS_DC)
{
	return arKey;
}

#define PHALCON_ZVAL_MAYBE_INTERNED_STRING(pz, string)  ZVAL_STRING(pz, string, 1);

#else

#define PHALCON_ZVAL_MAYBE_INTERNED_STRING(pz, string)            \
	do {                                                          \
		if (IS_INTERNED(string)) {                                \
			ZVAL_STRINGL(pz, string, INTERNED_LEN(string)-1, 0);  \
		}                                                         \
		else {                                                    \
			ZVAL_STRING(pz, string, 1);                           \
		}                                                         \
	} while (0)

#endif /* PHP_VERSION_ID < 50400 */

#endif /* PHALCON_INTERNED_STRINGS_H */





#include <ext/spl/spl_exceptions.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>



void php_phalcon_init_globals(zend_phalcon_globals *phalcon_globals TSRMLS_DC) {

	HashTable *constants = EG(zend_constants);

	phalcon_globals->initialized = 0;

	/* Memory options */
	phalcon_globals->active_memory = NULL;

	/* Virtual Symbol Tables */
	phalcon_globals->active_symbol_table = NULL;

	/* Recursive Lock */
	phalcon_globals->recursive_lock = 0;

	/* PSR-3 classes */
	phalcon_globals->register_psr3_classes = 0;

	/* ORM options*/
	phalcon_globals->orm.events = 1;
	phalcon_globals->orm.virtual_foreign_keys = 1;
	phalcon_globals->orm.column_renaming = 1;
	phalcon_globals->orm.not_null_validations = 1;
	phalcon_globals->orm.exception_on_failed_save = 0;
	phalcon_globals->orm.enable_literals = 1;
	phalcon_globals->orm.cache_level = 3;
	phalcon_globals->orm.unique_cache_id = 0;
	phalcon_globals->orm.parser_cache = NULL;
	phalcon_globals->orm.ast_cache = NULL;

	/* Security options */
	phalcon_globals->security.crypt_std_des_supported  = zend_hash_quick_exists(constants, SS("CRYPT_STD_DES"),  3134198876UL);
	phalcon_globals->security.crypt_ext_des_supported  = zend_hash_quick_exists(constants, SS("CRYPT_EXT_DES"),  678554914UL);
	phalcon_globals->security.crypt_md5_supported      = zend_hash_quick_exists(constants, SS("CRYPT_MD5"),      2419579324UL);
	phalcon_globals->security.crypt_blowfish_supported = zend_hash_quick_exists(constants, SS("CRYPT_BLOWFISH"), 851327700UL);
	phalcon_globals->security.crypt_sha256_supported   = zend_hash_quick_exists(constants, SS("CRYPT_SHA256"),   140761263UL);
	phalcon_globals->security.crypt_sha512_supported   = zend_hash_quick_exists(constants, SS("CRYPT_SHA512"),   140864586UL);

	if (PHP_VERSION_ID >= 50307) {
		phalcon_globals->security.crypt_blowfish_y_supported = phalcon_globals->security.crypt_blowfish_supported;
	}
	else {
		phalcon_globals->security.crypt_blowfish_y_supported = 0;
	}

	/* DB options */
	phalcon_globals->db.escape_identifiers = 1;
}

zend_class_entry *phalcon_register_internal_interface_ex(zend_class_entry *orig_ce, zend_class_entry *parent_ce TSRMLS_DC) {

	zend_class_entry *ce;

	ce = zend_register_internal_interface(orig_ce TSRMLS_CC);
	if (parent_ce) {
		zend_do_inheritance(ce, parent_ce TSRMLS_CC);
	}

	return ce;
}

zval* phalcon_get_global(const char *global, unsigned int global_length TSRMLS_DC) {

	zend_bool jit_initialization = PG(auto_globals_jit);
	if (jit_initialization) {
#if defined(__GNUC__) && PHP_VERSION_ID >= 50400
		if (__builtin_constant_p(global) && __builtin_constant_p(global_length)) {
			zend_is_auto_global_quick(global, global_length - 1, zend_inline_hash_func(global, global_length) TSRMLS_CC);
		}
		else
#endif
		{
			zend_is_auto_global(global, global_length - 1 TSRMLS_CC);
		}
	}

	if (&EG(symbol_table)) {
		zval **gv;
		if (zend_hash_find(&EG(symbol_table), global, global_length, (void **) &gv) == SUCCESS) {
			if (gv && *gv && Z_TYPE_PP(gv) == IS_ARRAY) {
				return *gv;
			}
		}
	}

	return PHALCON_GLOBAL(z_null);
}

long int phalcon_fast_count_int(zval *value TSRMLS_DC) {

	if (Z_TYPE_P(value) == IS_ARRAY) {
		return zend_hash_num_elements(Z_ARRVAL_P(value));
	}

	if (Z_TYPE_P(value) == IS_OBJECT) {
		if (Z_OBJ_HT_P(value)->count_elements) {
			long int result;
			if (SUCCESS == Z_OBJ_HT(*value)->count_elements(value, &result TSRMLS_CC)) {
				return result;
			}
		}

		if (Z_OBJ_HT_P(value)->get_class_entry && instanceof_function_ex(Z_OBJCE_P(value), spl_ce_Countable, 1 TSRMLS_CC)) {
			zval *retval    = NULL;
			long int result = 0;

			zend_call_method_with_0_params(&value, Z_OBJCE_P(value), NULL, "count", &retval);
			if (retval) {
				convert_to_long_ex(&retval);
				result = Z_LVAL_P(retval);
				zval_ptr_dtor(&retval);
			}

			return result;
		}

		return 0;
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		return 0;
	}

	return 1;
}

static void phalcon_fast_count(zval *result, zval *value TSRMLS_DC) {

	if (Z_TYPE_P(value) == IS_ARRAY) {
		ZVAL_LONG(result, zend_hash_num_elements(Z_ARRVAL_P(value)));
		return;
	}

	if (Z_TYPE_P(value) == IS_OBJECT) {

		#ifdef HAVE_SPL
		zval *retval = NULL;
		#endif

		if (Z_OBJ_HT_P(value)->count_elements) {
			ZVAL_LONG(result, 1);
			if (SUCCESS == Z_OBJ_HT(*value)->count_elements(value, &Z_LVAL_P(result) TSRMLS_CC)) {
				return;
			}
		}

		#ifdef HAVE_SPL
		if (Z_OBJ_HT_P(value)->get_class_entry && instanceof_function(Z_OBJCE_P(value), spl_ce_Countable TSRMLS_CC)) {
			zend_call_method_with_0_params(&value, NULL, NULL, "count", &retval);
			if (retval) {
				convert_to_long_ex(&retval);
				ZVAL_LONG(result, Z_LVAL_P(retval));
				zval_ptr_dtor(&retval);
			}
			return;
		}
		#endif

		ZVAL_LONG(result, 0);
		return;
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(result, 0);
		return;
	}

	ZVAL_LONG(result, 1);
}

static int phalcon_fast_count_ev(zval *value TSRMLS_DC) {

	long count = 0;

	if (Z_TYPE_P(value) == IS_ARRAY) {
		return (int) zend_hash_num_elements(Z_ARRVAL_P(value)) > 0;
	}

	if (Z_TYPE_P(value) == IS_OBJECT) {

		#ifdef HAVE_SPL
		zval *retval = NULL;
		#endif

		if (Z_OBJ_HT_P(value)->count_elements) {
			Z_OBJ_HT(*value)->count_elements(value, &count TSRMLS_CC);
			return (int) count > 0;
		}

		#ifdef HAVE_SPL
		if (Z_OBJ_HT_P(value)->get_class_entry && instanceof_function(Z_OBJCE_P(value), spl_ce_Countable TSRMLS_CC)) {
			zend_call_method_with_0_params(&value, NULL, NULL, "count", &retval);
			if (retval) {
				convert_to_long_ex(&retval);
				count = Z_LVAL_P(retval);
				zval_ptr_dtor(&retval);
				return (int) count > 0;
			}
			return 0;
		}
		#endif

		return 0;
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		return 0;
	}

	return 1;
}

static int phalcon_function_quick_exists_ex(const char *method_name, unsigned int method_len, unsigned long key TSRMLS_DC) {

	return (zend_hash_quick_exists(CG(function_table), method_name, method_len, key)) ? SUCCESS : FAILURE;
}

static int phalcon_is_callable(zval *var TSRMLS_DC) {

	char *error = NULL;
	zend_bool retval;

	retval = zend_is_callable_ex(var, NULL, 0, NULL, NULL, NULL, &error TSRMLS_CC);
	if (error) {
		efree(error);
	}

	return (int) retval;
}

static int phalcon_is_iterable_ex(zval *arr, HashTable **arr_hash, HashPosition *hash_position, int duplicate, int reverse) {

	if (unlikely(Z_TYPE_P(arr) != IS_ARRAY)) {
		return 0;
	}

	if (duplicate) {
		ALLOC_HASHTABLE(*arr_hash);
		zend_hash_init(*arr_hash, 0, NULL, NULL, 0);
		zend_hash_copy(*arr_hash, Z_ARRVAL_P(arr), NULL, NULL, sizeof(zval*));
	} else {
		*arr_hash = Z_ARRVAL_P(arr);
	}

	if (reverse) {
		zend_hash_internal_pointer_end_ex(*arr_hash, hash_position);
	} else {
		zend_hash_internal_pointer_reset_ex(*arr_hash, hash_position);
	}

	return 1;
}

static int phalcon_fetch_parameters(int num_args TSRMLS_DC, int required_args, int optional_args, ...)
{
	va_list va;
	int arg_count = (int) (zend_uintptr_t) *(zend_vm_stack_top(TSRMLS_C) - 1);
	zval **arg, **p;
	int i;

	if (num_args < required_args || (num_args > (required_args + optional_args))) {
		phalcon_throw_exception_string(spl_ce_BadMethodCallException, "Wrong number of parameters" TSRMLS_CC);
		return FAILURE;
	}

	if (num_args > arg_count) {
		phalcon_throw_exception_string(spl_ce_BadMethodCallException, "Could not obtain parameters for parsing" TSRMLS_CC);
		return FAILURE;
	}

	if (!num_args) {
		return SUCCESS;
	}

	va_start(va, optional_args);

	i = 0;
	while (num_args-- > 0) {

		arg = (zval **) (zend_vm_stack_top(TSRMLS_C) - 1 - (arg_count - i));

		p = va_arg(va, zval **);
		*p = *arg;

		i++;
	}

	va_end(va);

	return SUCCESS;
}

static int phalcon_fetch_parameters_ex(int dummy TSRMLS_DC, int n_req, int n_opt, ...)
{
	void **p;
	int arg_count, param_count;
	va_list ptr;

	p           = zend_vm_stack_top(TSRMLS_C) - 1;
	arg_count   = (int)(zend_uintptr_t)*p;
	param_count = n_req + n_opt;

	if (param_count < arg_count || n_req > arg_count) {
		return FAILURE;
	}

	va_start(ptr, n_opt);
	while (arg_count > 0) {
		zval ***param = va_arg(ptr, zval ***);
		*param = (zval**)p - arg_count;
		--arg_count;
	}

	va_end(ptr);
	return SUCCESS;
}





#include <Zend/zend_alloc.h>



static void phalcon_initialize_memory(zend_phalcon_globals *phalcon_globals_ptr TSRMLS_DC)
{
	phalcon_memory_entry *start;
	size_t i;

	start = (phalcon_memory_entry *) pecalloc(PHALCON_NUM_PREALLOCATED_FRAMES, sizeof(phalcon_memory_entry), 1);
/* pecalloc() will take care of these members for every frame
	start->pointer      = 0;
	start->hash_pointer = 0;
	start->prev = NULL;
	start->next = NULL;
*/
	for (i = 0; i < PHALCON_NUM_PREALLOCATED_FRAMES; ++i) {
		start[i].addresses       = pecalloc(24, sizeof(zval*), 1);
		start[i].capacity        = 24;
		start[i].hash_addresses  = pecalloc(8, sizeof(zval*), 1);
		start[i].hash_capacity   = 8;

#ifndef PHALCON_RELEASE
		start[i].permanent = 1;
#endif
	}

	start[0].next = &start[1];
	start[PHALCON_NUM_PREALLOCATED_FRAMES - 1].prev = &start[PHALCON_NUM_PREALLOCATED_FRAMES - 2];

	for (i = 1; i < PHALCON_NUM_PREALLOCATED_FRAMES - 1; ++i) {
		start[i].next = &start[i + 1];
		start[i].prev = &start[i - 1];
	}

	phalcon_globals_ptr->start_memory = start;
	phalcon_globals_ptr->end_memory   = start + PHALCON_NUM_PREALLOCATED_FRAMES;

	phalcon_globals_ptr->fcache = emalloc(sizeof(HashTable));
#ifndef PHALCON_RELEASE
	zend_hash_init(phalcon_globals_ptr->fcache, 128, NULL, phalcon_fcall_cache_dtor, 0);
#else
	zend_hash_init(phalcon_globals_ptr->fcache, 128, NULL, NULL, 0);
#endif

	/* 'Allocator sizeof operand mismatch' warning can be safely ignored */
	ALLOC_INIT_ZVAL(phalcon_globals_ptr->z_null);
	Z_SET_REFCOUNT_P(phalcon_globals_ptr->z_null, 2);

	/* 'Allocator sizeof operand mismatch' warning can be safely ignored */
	ALLOC_INIT_ZVAL(phalcon_globals_ptr->z_false);
	Z_SET_REFCOUNT_P(phalcon_globals_ptr->z_false, 2);
	ZVAL_FALSE(phalcon_globals_ptr->z_false);

	/* 'Allocator sizeof operand mismatch' warning can be safely ignored */
	ALLOC_INIT_ZVAL(phalcon_globals_ptr->z_true);
	Z_SET_REFCOUNT_P(phalcon_globals_ptr->z_true, 2);
	ZVAL_TRUE(phalcon_globals_ptr->z_true);

	/* 'Allocator sizeof operand mismatch' warning can be safely ignored */
	ALLOC_INIT_ZVAL(phalcon_globals_ptr->z_zero);
	Z_SET_REFCOUNT_P(phalcon_globals_ptr->z_zero, 2);
	ZVAL_LONG(phalcon_globals_ptr->z_zero, 0);

	/* 'Allocator sizeof operand mismatch' warning can be safely ignored */
	ALLOC_INIT_ZVAL(phalcon_globals_ptr->z_one);
	Z_SET_REFCOUNT_P(phalcon_globals_ptr->z_one, 2);
	ZVAL_LONG(phalcon_globals_ptr->z_one, 1);

	phalcon_globals_ptr->initialized = 1;
}

static void phalcon_deinitialize_memory(TSRMLS_D)
{
	size_t i;
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	if (phalcon_globals_ptr->initialized != 1) {
		phalcon_globals_ptr->initialized = 0;
		return;
	}

	if (phalcon_globals_ptr->start_memory != NULL) {
		phalcon_clean_restore_stack(TSRMLS_C);
	}

	phalcon_orm_destroy_cache(TSRMLS_C);

	zend_hash_apply_with_arguments(phalcon_globals_ptr->fcache TSRMLS_CC, phalcon_cleanup_fcache, 0);

#ifndef PHALCON_RELEASE
	assert(phalcon_globals_ptr->start_memory != NULL);
#endif

	for (i = 0; i < PHALCON_NUM_PREALLOCATED_FRAMES; ++i) {
		pefree(phalcon_globals_ptr->start_memory[i].hash_addresses, 1);
		pefree(phalcon_globals_ptr->start_memory[i].addresses, 1);
	}

	pefree(phalcon_globals_ptr->start_memory, 1);
	phalcon_globals_ptr->start_memory = NULL;

	zend_hash_destroy(phalcon_globals_ptr->fcache);
	efree(phalcon_globals_ptr->fcache);
	phalcon_globals_ptr->fcache = NULL;

	for (i = 0; i < 2; i++) {
		zval_ptr_dtor(&phalcon_globals_ptr->z_null);
		zval_ptr_dtor(&phalcon_globals_ptr->z_false);
		zval_ptr_dtor(&phalcon_globals_ptr->z_true);
		zval_ptr_dtor(&phalcon_globals_ptr->z_zero);
		zval_ptr_dtor(&phalcon_globals_ptr->z_one);
	}

	phalcon_globals_ptr->initialized = 0;
}

static phalcon_memory_entry* phalcon_memory_grow_stack_common(zend_phalcon_globals *g)
{
	assert(g->start_memory != NULL);
	if (!g->active_memory) {
		g->active_memory = g->start_memory;
#ifndef PHALCON_RELEASE
		assert(g->active_memory->permanent == 1);
#endif
	}
	else if (!g->active_memory->next) {
		phalcon_memory_entry *entry;

		assert(g->active_memory >= g->end_memory - 1 || g->active_memory < g->start_memory);
		entry = (phalcon_memory_entry *) ecalloc(1, sizeof(phalcon_memory_entry));
	/* ecalloc() will take care of these members
		entry->pointer   = 0;
		entry->capacity  = 0;
		entry->addresses = NULL;
		entry->hash_pointer   = 0;
		entry->hash_capacity  = 0;
		entry->hash_addresses = NULL;
		entry->next = NULL;
	*/
#ifndef PHALCON_RELEASE
		entry->permanent  = 0;
		entry->func       = NULL;
#endif
		entry->prev       = g->active_memory;
		entry->prev->next = entry;
		g->active_memory  = entry;
	}
	else {
#ifndef PHALCON_RELEASE
		assert(g->active_memory->permanent == 1);
#endif
		assert(g->active_memory < g->end_memory && g->active_memory >= g->start_memory);
		g->active_memory = g->active_memory->next;
	}

	assert(g->active_memory->pointer == 0);
	assert(g->active_memory->hash_pointer == 0);

	return g->active_memory;
}

static void phalcon_memory_restore_stack_common(zend_phalcon_globals *g TSRMLS_DC)
{
	size_t i;
	phalcon_memory_entry *prev, *active_memory;
	phalcon_symbol_table *active_symbol_table;

	active_memory = g->active_memory;
	assert(active_memory != NULL);

	if (EXPECTED(!CG(unclean_shutdown))) {
		/* Clean active symbol table */
		if (g->active_symbol_table) {
			active_symbol_table = g->active_symbol_table;
			if (active_symbol_table->scope == active_memory) {
				zend_hash_destroy(EG(active_symbol_table));
				FREE_HASHTABLE(EG(active_symbol_table));
				EG(active_symbol_table) = active_symbol_table->symbol_table;
				g->active_symbol_table = active_symbol_table->prev;
				efree(active_symbol_table);
			}
		}

		/* Check for non freed hash key zvals, mark as null to avoid string freeing */
		for (i = 0; i < active_memory->hash_pointer; ++i) {
			assert(active_memory->hash_addresses[i] != NULL && *(active_memory->hash_addresses[i]) != NULL);
			if (Z_REFCOUNT_PP(active_memory->hash_addresses[i]) <= 1) {
				ZVAL_NULL(*active_memory->hash_addresses[i]);
			} else {
				zval_copy_ctor(*active_memory->hash_addresses[i]);
			}
		}

#ifndef PHALCON_RELEASE
		for (i = 0; i < active_memory->pointer; ++i) {
			if (active_memory->addresses[i] != NULL && *(active_memory->addresses[i]) != NULL) {
				zval **var = active_memory->addresses[i];
#if PHP_VERSION_ID < 50400
				if (Z_TYPE_PP(var) > IS_CONSTANT_ARRAY) {
					fprintf(stderr, "%s: observed variable #%d (%p) has invalid type %u [%s]\n", __func__, (int)i, *var, Z_TYPE_PP(var), active_memory->func);
				}
#else
				if (Z_TYPE_PP(var) > IS_CALLABLE) {
					fprintf(stderr, "%s: observed variable #%d (%p) has invalid type %u [%s]\n", __func__, (int)i, *var, Z_TYPE_PP(var), active_memory->func);
				}
#endif

				if (Z_REFCOUNT_PP(var) == 0) {
					fprintf(stderr, "%s: observed variable #%d (%p) has 0 references, type=%d [%s]\n", __func__, (int)i, *var, Z_TYPE_PP(var), active_memory->func);
				}
				else if (Z_REFCOUNT_PP(var) >= 1000000) {
					fprintf(stderr, "%s: observed variable #%d (%p) has too many references (%u), type=%d  [%s]\n", __func__, (int)i, *var, Z_REFCOUNT_PP(var), Z_TYPE_PP(var), active_memory->func);
				}
#if 0
				/* Skip this check, PDO does return variables with is_ref = 1 and refcount = 1*/
				else if (Z_REFCOUNT_PP(var) == 1 && Z_ISREF_PP(var)) {
					fprintf(stderr, "%s: observed variable #%d (%p) is a reference with reference count = 1, type=%d  [%s]\n", __func__, (int)i, *var, Z_TYPE_PP(var), active_memory->func);
				}
#endif
			}
		}
#endif

		/* Traverse all zvals allocated, reduce the reference counting or free them */
		for (i = 0; i < active_memory->pointer; ++i) {
			if (EXPECTED(active_memory->addresses[i] != NULL && *(active_memory->addresses[i]) != NULL)) {
				if (Z_REFCOUNT_PP(active_memory->addresses[i]) == 1) {
					zval_ptr_dtor(active_memory->addresses[i]);
				} else {
					Z_DELREF_PP(active_memory->addresses[i]);
				}
			}
		}
	}

#ifndef PHALCON_RELEASE
	active_memory->func = NULL;
#endif

	prev = active_memory->prev;

	if (active_memory >= g->end_memory || active_memory < g->start_memory) {
#ifndef PHALCON_RELEASE
		assert(g->active_memory->permanent == 0);
#endif
		assert(prev != NULL);

		if (active_memory->hash_addresses != NULL) {
			efree(active_memory->hash_addresses);
		}

		if (active_memory->addresses != NULL) {
			efree(active_memory->addresses);
		}

		efree(g->active_memory);
		g->active_memory = prev;
		prev->next = NULL;
	}
	else {
#ifndef PHALCON_RELEASE
		assert(g->active_memory->permanent == 1);
#endif

		active_memory->pointer      = 0;
		active_memory->hash_pointer = 0;
		g->active_memory = prev;
	}

#ifndef PHALCON_RELEASE
	if (g->active_memory) {
		phalcon_memory_entry *f = g->active_memory;
		if (f >= g->start_memory && f < g->end_memory - 1) {
			assert(f->permanent == 1);
			assert(f->next != NULL);

			if (f > g->start_memory) {
				assert(f->prev != NULL);
			}
		}
	}
#endif
}

#ifndef PHALCON_RELEASE

static void phalcon_dump_memory_frame(phalcon_memory_entry *active_memory TSRMLS_DC)
{
	size_t i;

	assert(active_memory != NULL);

	fprintf(stderr, "Dump of the memory frame %p (%s)\n", active_memory, active_memory->func);

	if (active_memory->hash_pointer) {
		for (i = 0; i < active_memory->hash_pointer; ++i) {
			assert(active_memory->hash_addresses[i] != NULL && *(active_memory->hash_addresses[i]) != NULL);
			fprintf(stderr, "Hash ptr %lu (%p => %p), type=%u, refcnt=%u\n", (ulong)i, active_memory->hash_addresses[i], *active_memory->hash_addresses[i], Z_TYPE_PP(active_memory->hash_addresses[i]), Z_REFCOUNT_PP(active_memory->hash_addresses[i]));
		}
	}

	for (i = 0; i < active_memory->pointer; ++i) {
		if (EXPECTED(active_memory->addresses[i] != NULL && *(active_memory->addresses[i]) != NULL)) {
			zval **var = active_memory->addresses[i];
			fprintf(stderr, "Obs var %lu (%p => %p), type=%u, refcnt=%u; ", (ulong)i, var, *var, Z_TYPE_PP(var), Z_REFCOUNT_PP(var));
			switch (Z_TYPE_PP(var)) {
				case IS_NULL:     fprintf(stderr, "value=NULL\n"); break;
				case IS_LONG:     fprintf(stderr, "value=%ld\n", Z_LVAL_PP(var)); break;
				case IS_DOUBLE:   fprintf(stderr, "value=%E\n", Z_DVAL_PP(var)); break;
				case IS_BOOL:     fprintf(stderr, "value=(bool)%d\n", Z_BVAL_PP(var)); break;
				case IS_ARRAY:    fprintf(stderr, "value=array(%p), %d elements\n", Z_ARRVAL_PP(var), zend_hash_num_elements(Z_ARRVAL_PP(var))); break;
				case IS_OBJECT:   fprintf(stderr, "value=object(%u), %s\n", Z_OBJ_HANDLE_PP(var), Z_OBJCE_PP(var)->name); break;
				case IS_STRING:   fprintf(stderr, "value=%*s (%p)\n", Z_STRLEN_PP(var), Z_STRVAL_PP(var), Z_STRVAL_PP(var)); break;
				case IS_RESOURCE: fprintf(stderr, "value=(resource)%ld\n", Z_LVAL_PP(var)); break;
				default:          fprintf(stderr, "\n"); break;
			}
		}
	}

	fprintf(stderr, "End of the dump of the memory frame %p\n", active_memory);
}

static void phalcon_dump_current_frame(TSRMLS_D)
{
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	if (UNEXPECTED(phalcon_globals_ptr->active_memory == NULL)) {
		fprintf(stderr, "WARNING: calling %s() without an active memory frame!\n", __func__);
		phalcon_print_backtrace();
		return;
	}

	phalcon_dump_memory_frame(phalcon_globals_ptr->active_memory TSRMLS_CC);
}

static void phalcon_dump_all_frames(TSRMLS_D)
{
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;
	phalcon_memory_entry *active_memory       = phalcon_globals_ptr->active_memory;

	fprintf(stderr, "*** DUMP START ***\n");
	while (active_memory != NULL) {
		phalcon_dump_memory_frame(active_memory TSRMLS_CC);
		active_memory = active_memory->prev;
	}

	fprintf(stderr, "*** DUMP END ***\n");
}

static int phalcon_memory_restore_stack(const char *func TSRMLS_DC)
{
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	if (UNEXPECTED(phalcon_globals_ptr->active_memory == NULL)) {
		fprintf(stderr, "WARNING: calling phalcon_memory_restore_stack() without an active memory frame!\n");
		phalcon_print_backtrace();
		return FAILURE;
	}

	if (UNEXPECTED(phalcon_globals_ptr->active_memory->func != func)) {
		fprintf(stderr, "Trying to free someone else's memory frame!\n");
		fprintf(stderr, "The frame was created by %s\n", phalcon_globals_ptr->active_memory->func);
		fprintf(stderr, "Calling function: %s\n", func);
		phalcon_print_backtrace();
	}

	phalcon_memory_restore_stack_common(phalcon_globals_ptr TSRMLS_CC);
	return SUCCESS;
}

static void phalcon_memory_grow_stack(const char *func TSRMLS_DC)
{
	zend_phalcon_globals *g = PHALCON_VGLOBAL;
	if (g->start_memory == NULL) {
		phalcon_initialize_memory(g TSRMLS_CC);
	}
	phalcon_memory_entry *entry = phalcon_memory_grow_stack_common(g);
	entry->func = func;
}

#else

static void phalcon_memory_grow_stack(TSRMLS_D)
{
	zend_phalcon_globals *g = PHALCON_VGLOBAL;
	if (g->start_memory == NULL) {
		zend_error(E_ERROR, "Cannot use the memory manager when the request is shutting down");
		return;
	}
	phalcon_memory_grow_stack_common(g);
}

static int phalcon_memory_restore_stack(TSRMLS_D)
{
	phalcon_memory_restore_stack_common(PHALCON_VGLOBAL TSRMLS_CC);
	return SUCCESS;
}
#endif

PHALCON_ATTR_NONNULL static void phalcon_reallocate_memory(const zend_phalcon_globals *g)
{
	phalcon_memory_entry *frame = g->active_memory;
	int persistent = (frame >= g->start_memory && frame < g->end_memory);
	void *buf = perealloc(frame->addresses, sizeof(zval **) * (frame->capacity + 16), persistent);
	if (EXPECTED(buf != NULL)) {
		frame->capacity += 16;
		frame->addresses = buf;
	}
	else {
		zend_error(E_CORE_ERROR, "Memory allocation failed");
	}

#ifndef PHALCON_RELEASE
	assert(frame->permanent == persistent);
#endif
}

PHALCON_ATTR_NONNULL static void phalcon_reallocate_hmemory(const zend_phalcon_globals *g)
{
	phalcon_memory_entry *frame = g->active_memory;
	int persistent = (frame >= g->start_memory && frame < g->end_memory);
	void *buf = perealloc(frame->hash_addresses, sizeof(zval **) * (frame->hash_capacity + 4), persistent);
	if (EXPECTED(buf != NULL)) {
		frame->hash_capacity += 4;
		frame->hash_addresses = buf;
	}
	else {
		zend_error(E_CORE_ERROR, "Memory allocation failed");
	}

#ifndef PHALCON_RELEASE
	assert(frame->permanent == persistent);
#endif
}

PHALCON_ATTR_NONNULL1(2) static inline void phalcon_do_memory_observe(zval **var, const zend_phalcon_globals *g)
{
	phalcon_memory_entry *frame = g->active_memory;

	if (UNEXPECTED(frame->pointer == frame->capacity)) {
		phalcon_reallocate_memory(g);
	}

	frame->addresses[frame->pointer] = var;
	++frame->pointer;
}

#ifndef PHALCON_RELEASE

static void phalcon_verify_frame(const phalcon_memory_entry *frame, const char *func, zval **var)
{
	size_t i;

	if (UNEXPECTED(frame == NULL)) {
		fprintf(stderr, "PHALCON_MM_GROW() must be called before using any of MM functions or macros!");
		phalcon_print_backtrace();
		abort();
	}

	if (strcmp(frame->func, func)) {
		fprintf(stderr, "Memory frames do not match: function: %s, frame creator: %s\n", func, frame->func);
		phalcon_print_backtrace();
		abort();
	}

	for (i=0; i<frame->pointer; ++i) {
		if (frame->addresses[i] == var) {
			fprintf(stderr, "Variable %p is already observed", var);
			phalcon_print_backtrace();
			abort();
		}
	}
}

static void phalcon_memory_observe(zval **var, const char *func TSRMLS_DC)
{
	zend_phalcon_globals *g     = PHALCON_VGLOBAL;
	phalcon_memory_entry *frame = g->active_memory;

	phalcon_verify_frame(frame, func, var);

	phalcon_do_memory_observe(var, g);
	*var = NULL; /* In case an exception or error happens BEFORE the observed variable gets initialized */
}

static void phalcon_memory_alloc(zval **var, const char *func TSRMLS_DC)
{
	zend_phalcon_globals *g     = PHALCON_VGLOBAL;
	phalcon_memory_entry *frame = g->active_memory;

	phalcon_verify_frame(frame, func, var);

	phalcon_do_memory_observe(var, g);
	ALLOC_INIT_ZVAL(*var);
}

static void phalcon_memory_alloc_pnull(zval **var, const char *func TSRMLS_DC)
{
	zend_phalcon_globals *g     = PHALCON_VGLOBAL;
	phalcon_memory_entry *frame = g->active_memory;

	phalcon_verify_frame(frame, func, var);

	phalcon_do_memory_observe(var, g);
	ALLOC_INIT_ZVAL(*var);

	if (frame->hash_pointer == frame->hash_capacity) {
		phalcon_reallocate_hmemory(g);
	}

	frame->hash_addresses[frame->hash_pointer] = var;
	++frame->hash_pointer;
}

#else

static void phalcon_memory_observe(zval **var TSRMLS_DC)
{
	zend_phalcon_globals *g = PHALCON_VGLOBAL;
	phalcon_do_memory_observe(var, g);
	*var = NULL; /* In case an exception or error happens BEFORE the observed variable gets initialized */
}

static void phalcon_memory_alloc(zval **var TSRMLS_DC)
{
	zend_phalcon_globals *g = PHALCON_VGLOBAL;
	phalcon_do_memory_observe(var, g);
	ALLOC_INIT_ZVAL(*var);
}

static void phalcon_memory_alloc_pnull(zval **var TSRMLS_DC)
{
	zend_phalcon_globals *g = PHALCON_VGLOBAL;
	phalcon_memory_entry *active_memory = g->active_memory;

	phalcon_do_memory_observe(var, g);
	ALLOC_INIT_ZVAL(*var);

	if (active_memory->hash_pointer == active_memory->hash_capacity) {
		phalcon_reallocate_hmemory(g);
	}

	active_memory->hash_addresses[active_memory->hash_pointer] = var;
	++active_memory->hash_pointer;
}
#endif

static void phalcon_memory_remove(zval **var TSRMLS_DC) {
	zval_ptr_dtor(var);
	*var = NULL;
}

static int phalcon_clean_restore_stack(TSRMLS_D) {

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	while (phalcon_globals_ptr->active_memory != NULL) {
		phalcon_memory_restore_stack_common(phalcon_globals_ptr TSRMLS_CC);
	}

	return SUCCESS;
}

static void phalcon_copy_ctor(zval *destination, zval *origin) {
	if (Z_REFCOUNT_P(origin) > 1) {
		zval_copy_ctor(destination);
	} else {
		ZVAL_NULL(origin);
	}
}

static void phalcon_create_symbol_table(TSRMLS_D) {

	phalcon_symbol_table *entry;
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;
	HashTable *symbol_table;

#ifndef PHALCON_RELEASE
	if (!phalcon_globals_ptr->active_memory) {
		fprintf(stderr, "ERROR: Trying to create a virtual symbol table without a memory frame");
		phalcon_print_backtrace();
		return;
	}
#endif

	entry = (phalcon_symbol_table *) emalloc(sizeof(phalcon_symbol_table));
	entry->scope = phalcon_globals_ptr->active_memory;
	entry->symbol_table = EG(active_symbol_table);
	entry->prev = phalcon_globals_ptr->active_symbol_table;
	phalcon_globals_ptr->active_symbol_table = entry;

	ALLOC_HASHTABLE(symbol_table);
	zend_hash_init(symbol_table, 0, NULL, ZVAL_PTR_DTOR, 0);
	EG(active_symbol_table) = symbol_table;
}

static void phalcon_clean_symbol_tables(TSRMLS_D) {

	/*unsigned int i;

	if (PHALCON_GLOBAL(symbol_tables)) {
		for (i = PHALCON_GLOBAL(number_symbol_tables); i > 0; i--) {
			EG(active_symbol_table) = PHALCON_GLOBAL(symbol_tables)[i - 1];
		}
		efree(PHALCON_GLOBAL(symbol_tables));
		PHALCON_GLOBAL(symbol_tables) = NULL;
	}*/
}

static int phalcon_set_symbol(zval *key_name, zval *value TSRMLS_DC) {

	if (!EG(active_symbol_table)) {
		zend_rebuild_symbol_table(TSRMLS_C);
	}

	if (EG(active_symbol_table)) {
		if (Z_TYPE_P(key_name) == IS_STRING) {
			Z_ADDREF_P(value);
			zend_hash_update(EG(active_symbol_table), Z_STRVAL_P(key_name), Z_STRLEN_P(key_name) + 1, &value, sizeof(zval *), NULL);
			if (EG(exception)) {
				return FAILURE;
			}
		}
	}

	return SUCCESS;
}

static int phalcon_set_symbol_str(char *key_name, unsigned int key_length, zval *value TSRMLS_DC) {

	if (!EG(active_symbol_table)) {
		zend_rebuild_symbol_table(TSRMLS_C);
	}

	if (&EG(symbol_table)) {
		Z_ADDREF_P(value);
		zend_hash_update(&EG(symbol_table), key_name, key_length, &value, sizeof(zval *), NULL);
		if (EG(exception)) {
			return FAILURE;
		}
	}

	return SUCCESS;
}





#ifndef PHALCON_RELEASE
#if defined(linux)

#include <execinfo.h>
#include <Zend/zend.h>
#include <ext/standard/php_smart_str.h>

void *backtrace_buf[4096];

static void phalcon_print_backtrace(void)
{
	int i;
	int stack_size       = backtrace(backtrace_buf, sizeof(backtrace_buf) / sizeof(void*));
	char **stack_symbols = backtrace_symbols(backtrace_buf, stack_size);
	char buf[50];
	smart_str s;

	s.c = NULL;

	for (i = 0; i < stack_size; ++i) {
		snprintf(buf, sizeof(buf), "#%d  %p [", i, backtrace_buf[i]);
		smart_str_appends(&s, buf);
		smart_str_appends(&s, stack_symbols[i]);
		smart_str_appends(&s, "]\n");
	}

	smart_str_0(&s);

	fprintf(stderr, "%s\n", s.c);
	smart_str_free(&s);
}

#else

static void phalcon_print_backtrace(void)
{
}

#endif /* defined(linux) */

#else

/* Release mode */
static void phalcon_print_backtrace(void)
{
}

#endif /* PHALCON_RELEASE */





#include <Zend/zend_API.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_execute.h>



#if PHP_VERSION_ID >= 50500
static const unsigned char tolower_map[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
#endif

#ifndef PHALCON_RELEASE
static void phalcon_fcall_cache_dtor(void *pData)
{
	phalcon_fcall_cache_entry **entry = (phalcon_fcall_cache_entry**)pData;
	free(*entry);
}
#endif

static int phalcon_cleanup_fcache(void *pDest TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)
{
	phalcon_fcall_cache_entry **entry = (phalcon_fcall_cache_entry**)pDest;
	zend_class_entry *scope;
	uint len = hash_key->nKeyLength;

	assert(hash_key->arKey != NULL);
	assert(hash_key->nKeyLength > 2 * sizeof(zend_class_entry**));

	memcpy(&scope, &hash_key->arKey[len - 2 * sizeof(zend_class_entry**)], sizeof(zend_class_entry*));


#ifndef PHALCON_RELEASE
	if ((*entry)->f->type != ZEND_INTERNAL_FUNCTION || (scope && scope->type != ZEND_INTERNAL_CLASS)) {
		return ZEND_HASH_APPLY_REMOVE;
	}
#else
	if ((*entry)->type != ZEND_INTERNAL_FUNCTION || (scope && scope->type != ZEND_INTERNAL_CLASS)) {
		return ZEND_HASH_APPLY_REMOVE;
	}
#endif

#if PHP_VERSION_ID >= 50400
	if (scope && scope->type == ZEND_INTERNAL_CLASS && scope->info.internal.module->type != MODULE_PERSISTENT) {
		return ZEND_HASH_APPLY_REMOVE;
	}
#else
	if (scope && scope->type == ZEND_INTERNAL_CLASS && scope->module->type != MODULE_PERSISTENT) {
		return ZEND_HASH_APPLY_REMOVE;
	}
#endif

	return ZEND_HASH_APPLY_KEEP;
}

static int phalcon_has_constructor_ce(const zend_class_entry *ce)
{
	while (ce) {
		if (ce->constructor) {
			return 1;
		}

		ce = ce->parent;
	}

	return 0;
}

#if 0
static inline ulong phalcon_update_hash(const char *arKey, uint nKeyLength, ulong hash)
{
	for (; nKeyLength >= 8; nKeyLength -= 8) {
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
	}

	switch (nKeyLength) {
		case 7:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 6:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 5:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 4:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 3:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 2:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 1:  hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		default: break;
	}

	return hash;
}
#endif

static ulong phalcon_make_fcall_key(char **result, size_t *length, const zend_class_entry *obj_ce, phalcon_call_type type, zval *function_name TSRMLS_DC)
{
	const zend_class_entry *calling_scope = EG(scope);
	char *buf = NULL, *c;
	size_t l = 0, len = 0;
	const size_t ppzce_size = sizeof(zend_class_entry**);
	ulong hash = 5381;

	*result = NULL;
	*length = 0;

	if (calling_scope && type == phalcon_fcall_parent) {
		calling_scope = calling_scope->parent;
		if (UNEXPECTED(!calling_scope)) {
			return 0;
		}
	}
	else if (type == phalcon_fcall_static) {
		calling_scope = EG(called_scope);
		if (UNEXPECTED(!calling_scope)) {
			return 0;
		}
	}

	if (
		    calling_scope
		 && obj_ce
		 && calling_scope != obj_ce
		 && !instanceof_function(obj_ce, calling_scope TSRMLS_CC)
		 && !instanceof_function(calling_scope, obj_ce TSRMLS_CC)
	) {
		calling_scope = NULL;
	}

	if (Z_TYPE_P(function_name) == IS_STRING) {
		l   = (size_t)(Z_STRLEN_P(function_name)) + 1;
		c   = Z_STRVAL_P(function_name);
		len = 2 * ppzce_size + l;
		buf = emalloc(len);

		memcpy(buf,                  c,               l);
		memcpy(buf + l,              &calling_scope,  ppzce_size);
		memcpy(buf + l + ppzce_size, &obj_ce,         ppzce_size);
	}
	else if (Z_TYPE_P(function_name) == IS_ARRAY) {
		zval **method;
		if (
			    zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2
			 && zend_hash_index_find(Z_ARRVAL_P(function_name), 1, (void**)&method) == SUCCESS
			 && Z_TYPE_PP(method) == IS_STRING
		) {
			l   = (size_t)(Z_STRLEN_PP(method)) + 1;
			c   = Z_STRVAL_PP(method);
			len = 2 * ppzce_size + l;
			buf = emalloc(len);

			memcpy(buf,                  c,               l);
			memcpy(buf + l,              &calling_scope,  ppzce_size);
			memcpy(buf + l + ppzce_size, &obj_ce,         ppzce_size);
		}
	}
	else if (Z_TYPE_P(function_name) == IS_OBJECT) {
		if (Z_OBJ_HANDLER_P(function_name, get_closure)) {
			l   = sizeof("__invoke");
			len = 2 * ppzce_size + l;
			buf = emalloc(len);

			memcpy(buf,                  "__invoke",     l);
			memcpy(buf + l,              &calling_scope, ppzce_size);
			memcpy(buf + l + ppzce_size, &obj_ce,        ppzce_size);
		}
	}

	if (EXPECTED(buf != NULL)) {
		size_t i;

		for (i=0; i<l; ++i) {
			char c = buf[i];
#if PHP_VERSION_ID >= 50500
			c = tolower_map[(unsigned char)c];
#else
			c = tolower(c);
#endif
			buf[i] = c;
			hash   = (hash << 5) + hash + c;
		}

		for (i=l; i<len; ++i) {
			char c = buf[i];
			hash = (hash << 5) + hash + c;
		}
	}

	*result = buf;
	*length = len;
	return hash;
}

PHALCON_ATTR_NONNULL static void phalcon_fcall_populate_fci_cache(zend_fcall_info_cache *fcic, zend_fcall_info *fci, phalcon_call_type type TSRMLS_DC)
{
	switch (type) {
		case phalcon_fcall_parent:
			if (EG(scope) && EG(scope)->parent) {
				fcic->calling_scope = EG(scope)->parent;
				fcic->called_scope  = EG(called_scope);
				fcic->object_ptr    = fci->object_ptr ? fci->object_ptr : EG(This);
				fcic->initialized   = 1;
			}

			break;

		case phalcon_fcall_self:
			if (EG(scope)) {
				fcic->calling_scope = EG(scope);
				fcic->called_scope  = EG(called_scope);
				fcic->object_ptr    = fci->object_ptr ? fci->object_ptr : EG(This);
				fcic->initialized   = 1;
			}

			break;

		case phalcon_fcall_static:
			if (EG(called_scope)) {
				fcic->calling_scope = EG(called_scope);
				fcic->called_scope  = EG(called_scope);
				fcic->object_ptr    = fci->object_ptr ? fci->object_ptr : EG(This);
				fcic->initialized   = 1;
			}

			break;

		case phalcon_fcall_function:
			fcic->calling_scope = NULL;
			fcic->called_scope  = NULL;
			fcic->object_ptr    = NULL;
			fcic->initialized   = 1;
			break;

		case phalcon_fcall_ce: {
			zend_class_entry *scope = EG(active_op_array) ? EG(active_op_array)->scope : NULL;

			fcic->initialized      = 1;
			fcic->calling_scope    = EG(scope);
			fcic->object_ptr       = NULL;

			if (scope && EG(This) && instanceof_function(Z_OBJCE_P(EG(This)), scope TSRMLS_CC) && instanceof_function(scope, fcic->calling_scope TSRMLS_CC)) {
				fcic->object_ptr   = EG(This);
				fcic->called_scope = Z_OBJCE_P(fcic->object_ptr);
			}
			else {
				fcic->called_scope = fcic->calling_scope;
			}

			break;
		}

		case phalcon_fcall_method:
			fcic->initialized      = 1;
			fcic->calling_scope    = EG(scope);
			fcic->object_ptr       = fci->object_ptr;
			if (fci->object_ptr) {
				fcic->called_scope = Z_OBJCE_P(fci->object_ptr);
			}
			else if (EG(scope) && !(EG(called_scope) && instanceof_function(EG(called_scope), EG(scope) TSRMLS_CC))) {
				fcic->called_scope = EG(scope);
			}
			else {
				fcic->called_scope = EG(called_scope);
			}

			break;

		default:
#ifndef PHALCON_RELEASE
			fprintf(stderr, "%s: unknown call type (%d)\n", __func__, (int)type);
			abort();
#endif
			fcic->initialized = 0; /* not strictly necessary but just to be safe */
			break;
	}

}

static int phalcon_call_user_function(zval **object_pp, zend_class_entry *obj_ce, phalcon_call_type type, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval *params[] TSRMLS_DC)
{
	zval ***params_ptr, ***params_array = NULL;
	zval **static_params_array[10];
	zval *local_retval_ptr = NULL;
	int status;
	zend_fcall_info fci;
	zend_fcall_info_cache fcic /* , clone */;
	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;
	char *fcall_key;
	size_t fcall_key_len;
	ulong fcall_key_hash;
	phalcon_fcall_cache_entry **cache_entry = NULL;
	zend_class_entry *old_scope = EG(scope);

	assert(obj_ce || !object_pp);

	if (retval_ptr_ptr && *retval_ptr_ptr) {
		zval_ptr_dtor(retval_ptr_ptr);
		*retval_ptr_ptr = NULL;
	}

	++phalcon_globals_ptr->recursive_lock;

	if (UNEXPECTED(phalcon_globals_ptr->recursive_lock > 2048)) {
		zend_error(E_ERROR, "Maximum recursion depth exceeded");
		return FAILURE;
	}

	if (param_count) {
		zend_uint i;

		if (UNEXPECTED(param_count > 10)) {
			params_array = (zval***)emalloc(param_count * sizeof(zval**));
			params_ptr   = params_array;
			for (i=0; i<param_count; ++i) {
				params_array[i] = &params[i];
			}
		} else {
			params_ptr = static_params_array;
			for (i=0; i<param_count; ++i) {
				static_params_array[i] = &params[i];
			}
		}
	}
	else {
		params_ptr = NULL;
	}

	if (type != phalcon_fcall_function && !object_pp) {
		object_pp = EG(This) ? &EG(This) : NULL;
		if (!obj_ce && object_pp) {
			obj_ce = Z_OBJCE_PP(object_pp);
		}
	}

	if (obj_ce) {
		EG(scope) = obj_ce;
	}

	fcall_key_hash = phalcon_make_fcall_key(&fcall_key, &fcall_key_len, (object_pp ? Z_OBJCE_PP(object_pp) : obj_ce), type, function_name TSRMLS_CC);

	fci.size           = sizeof(fci);
	fci.function_table = obj_ce ? &obj_ce->function_table : EG(function_table);
	fci.object_ptr     = object_pp ? *object_pp : NULL;
	fci.function_name  = function_name;
	fci.retval_ptr_ptr = retval_ptr_ptr ? retval_ptr_ptr : &local_retval_ptr;
	fci.param_count    = param_count;
	fci.params         = params_ptr;
	fci.no_separation  = 1;
	fci.symbol_table   = NULL;

	fcic.initialized = 0;
	if (fcall_key && zend_hash_quick_find(phalcon_globals_ptr->fcache, fcall_key, fcall_key_len, fcall_key_hash, (void**)&cache_entry) != FAILURE) {
		phalcon_fcall_populate_fci_cache(&fcic, &fci, type TSRMLS_CC);

#ifndef PHALCON_RELEASE
		fcic.function_handler = (*cache_entry)->f;
		++(*cache_entry)->times;
#else
		fcic.function_handler = *cache_entry;
#endif
		/*memcpy(&clone, &fcic, sizeof(clone));*/
	}

	fcic.initialized = 0;
	status = PHALCON_ZEND_CALL_FUNCTION_WRAPPER(&fci, /*&fcic*/NULL TSRMLS_CC);

	EG(scope) = old_scope;

	if (EXPECTED(status != FAILURE) && fcall_key && !cache_entry && fcic.initialized) {
#ifndef PHALCON_RELEASE
		phalcon_fcall_cache_entry *cache_entry = malloc(sizeof(phalcon_fcall_cache_entry));
		cache_entry->f     = fcic.function_handler;
		cache_entry->times = 0;
#else
		phalcon_fcall_cache_entry *cache_entry = fcic.function_handler;
#endif
		if (FAILURE == zend_hash_quick_add(phalcon_globals_ptr->fcache, fcall_key, fcall_key_len, fcall_key_hash, &cache_entry, sizeof(phalcon_fcall_cache_entry*), NULL)) {
#ifndef PHALCON_RELEASE
			free(cache_entry);
#endif
		}
	}

	if (fcall_key) {
		efree(fcall_key);
	}

	if (UNEXPECTED(params_array != NULL)) {
		efree(params_array);
	}

	if (!retval_ptr_ptr) {
		if (local_retval_ptr) {
			zval_ptr_dtor(&local_retval_ptr);
		}
	}

	--phalcon_globals_ptr->recursive_lock;
	return status;
}

static int phalcon_call_func_aparams(zval **return_value_ptr, const char *func_name, uint func_length, uint param_count, zval **params TSRMLS_DC)
{
	int status;
	zval *rv = NULL, **rvp = return_value_ptr ? return_value_ptr : &rv;
	zval func = zval_used_for_init;

#ifndef PHALCON_RELEASE
	if (return_value_ptr && *return_value_ptr) {
		fprintf(stderr, "%s: *return_value_ptr must be NULL\n", __func__);
		phalcon_print_backtrace();
		abort();
	}
#endif

	ZVAL_STRINGL(&func, func_name, func_length, 0);
	status = phalcon_call_user_function(NULL, NULL, phalcon_fcall_function, &func, rvp, param_count, params TSRMLS_CC);

	if (status == FAILURE && !EG(exception)) {
		zend_error(E_ERROR, "Call to undefined function %s()", func_name);
	}
	else if (EG(exception)) {
		status = FAILURE;
		if (return_value_ptr) {
			*return_value_ptr = NULL;
		}
	}

	if (rv) {
		zval_ptr_dtor(&rv);
	}

	return status;
}

static int phalcon_call_class_method_aparams(zval **return_value_ptr, zend_class_entry *ce, phalcon_call_type type, zval *object, const char *method_name, uint method_len, uint param_count, zval **params TSRMLS_DC)
{
	zval *rv = NULL, **rvp = return_value_ptr ? return_value_ptr : &rv;
	zval fn = zval_used_for_init;
	int status;

#ifndef PHALCON_RELEASE
	if (return_value_ptr && *return_value_ptr) {
		fprintf(stderr, "%s: *return_value_ptr must be NULL\n", __func__);
		phalcon_print_backtrace();
		abort();
	}
#endif

	array_init_size(&fn, 2);
	switch (type) {
		case phalcon_fcall_parent: add_next_index_stringl(&fn, ISL(parent), !IS_INTERNED(phalcon_interned_parent)); break;
		case phalcon_fcall_self:   assert(!ce); add_next_index_stringl(&fn, ISL(self), !IS_INTERNED(phalcon_interned_self)); break;
		case phalcon_fcall_static: assert(!ce); add_next_index_stringl(&fn, ISL(static), !IS_INTERNED(phalcon_interned_static)); break;

		case phalcon_fcall_ce:
			assert(ce != NULL);
			add_next_index_stringl(&fn, ce->name, ce->name_length, !IS_INTERNED(ce->name));
			break;

		case phalcon_fcall_method:
		default:
			assert(object != NULL);
			Z_ADDREF_P(object);
			add_next_index_zval(&fn, object);
			break;
	}

	add_next_index_stringl(&fn, method_name, method_len, 1);

	status = phalcon_call_user_function(object ? &object : NULL, ce, type, &fn, rvp, param_count, params TSRMLS_CC);

	if (status == FAILURE && !EG(exception)) {
		switch (type) {
			case phalcon_fcall_parent: zend_error(E_ERROR, "Call to undefined function parent::%s()", method_name); break;
			case phalcon_fcall_self:   zend_error(E_ERROR, "Call to undefined function self::%s()", method_name); break;
			case phalcon_fcall_static: zend_error(E_ERROR, "Call to undefined function static::%s()", method_name); break;
			case phalcon_fcall_ce:     zend_error(E_ERROR, "Call to undefined function %s::%s()", ce->name, method_name); break;
			case phalcon_fcall_method: zend_error(E_ERROR, "Call to undefined function %s::%s()", Z_OBJCE_P(object)->name, method_name); break;
			default:                   zend_error(E_ERROR, "Call to undefined function ?::%s()", method_name);
		}
	}
	else if (EG(exception)) {
		status = FAILURE;
		if (return_value_ptr) {
			*return_value_ptr = NULL;
		}
	}

	if (rv) {
		zval_ptr_dtor(&rv);
	}

	zval_dtor(&fn);
	return status;
}

static int phalcon_call_user_func_array_noex(zval *return_value, zval *handler, zval *params TSRMLS_DC){

	zval *retval_ptr = NULL;
	zend_fcall_info fci;
	zend_fcall_info_cache fci_cache;
	char *is_callable_error = NULL;
	int status = FAILURE;

	if (params && Z_TYPE_P(params) != IS_ARRAY) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for phalcon_call_user_func_array_noex()");
		return FAILURE;
	}

	if (zend_fcall_info_init(handler, 0, &fci, &fci_cache, NULL, &is_callable_error TSRMLS_CC) == SUCCESS) {
		if (is_callable_error) {
			zend_error(E_STRICT, "%s", is_callable_error);
			efree(is_callable_error);
		}
		status = SUCCESS;
	} else {
		if (is_callable_error) {
			zend_error(E_WARNING, "%s", is_callable_error);
			efree(is_callable_error);
		} else {
			status = SUCCESS;
		}
	}

	if (status == SUCCESS) {

		zend_fcall_info_args(&fci, params TSRMLS_CC);
		fci.retval_ptr_ptr = &retval_ptr;

		if (zend_call_function(&fci, &fci_cache TSRMLS_CC) == SUCCESS && fci.retval_ptr_ptr && *fci.retval_ptr_ptr) {
			COPY_PZVAL_TO_ZVAL(*return_value, *fci.retval_ptr_ptr);
		}

		if (fci.params) {
			efree(fci.params);
		}
	}

	if (EG(exception)) {
		status = SUCCESS;
	}

	return status;
}

#if PHP_VERSION_ID <= 50309

static void phalcon_throw_exception_internal(zval *exception TSRMLS_DC)
{
	if (exception != NULL) {
		zval *previous = EG(exception);
		zend_exception_set_previous(exception, EG(exception) TSRMLS_CC);
		EG(exception) = exception;
		if (previous) {
			return;
		}
	}

	if (!EG(current_execute_data)) {
		if (EG(exception)) {
			zend_exception_error(EG(exception), E_ERROR TSRMLS_CC);
		}
		zend_error(E_ERROR, "Exception thrown without a stack frame");
	}

	if (zend_throw_exception_hook) {
		zend_throw_exception_hook(exception TSRMLS_CC);
	}

	if (EG(current_execute_data)->opline == NULL ||
		(EG(current_execute_data)->opline + 1)->opcode == ZEND_HANDLE_EXCEPTION) {
		/* no need to rethrow the exception */
		return;
	}

	EG(opline_before_exception) = EG(current_execute_data)->opline;
	EG(current_execute_data)->opline = EG(exception_op);
}

static int phalcon_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache TSRMLS_DC) {

	zend_uint i;
	zval **original_return_value;
	HashTable *calling_symbol_table;
	zend_op_array *original_op_array;
	zend_op **original_opline_ptr;
	zend_class_entry *current_scope;
	zend_class_entry *current_called_scope;
	zend_class_entry *calling_scope = NULL;
	zend_class_entry *called_scope = NULL;
	zval *current_this;
	zend_execute_data execute_data;

	*fci->retval_ptr_ptr = NULL;

	if (!EG(active)) {
		return FAILURE; /* executor is already inactive */
	}

	if (EG(exception)) {
		return FAILURE; /* we would result in an instable executor otherwise */
	}

	switch (fci->size) {
		case sizeof(zend_fcall_info):
			break; /* nothing to do currently */
		default:
			zend_error(E_ERROR, "Corrupted fcall_info provided to phalcon_call_function()");
			break;
	}

	/* Initialize execute_data */
	if (EG(current_execute_data)) {
		execute_data = *EG(current_execute_data);
		EX(op_array) = NULL;
		EX(opline) = NULL;
		EX(object) = NULL;
	} else {
		/* This only happens when we're called outside any execute()'s
		 * It shouldn't be strictly necessary to NULL execute_data out,
		 * but it may make bugs easier to spot
		 */
		memset(&execute_data, 0, sizeof(zend_execute_data));
	}

	if (!fci_cache || !fci_cache->initialized) {

		zend_fcall_info_cache fci_cache_local;
		char *callable_name;
		char *error = NULL;

		if (!fci_cache) {
			fci_cache = &fci_cache_local;
		}

		if (!zend_is_callable_ex(fci->function_name, fci->object_ptr, IS_CALLABLE_CHECK_SILENT, &callable_name, NULL, fci_cache, &error TSRMLS_CC)) {
			if (error) {
				zend_error(E_WARNING, "Invalid callback %s, %s", callable_name, error);
				efree(error);
			}
			if (callable_name) {
				efree(callable_name);
			}
			return FAILURE;
		} else {
			if (error) {
				/* Capitalize the first latter of the error message */
				if (error[0] >= 'a' && error[0] <= 'z') {
					error[0] += ('A' - 'a');
				}
				zend_error(E_STRICT, "%s", error);
				efree(error);
			}
		}
		efree(callable_name);
	}

	EX(function_state).function = fci_cache->function_handler;
	calling_scope = fci_cache->calling_scope;
	called_scope = fci_cache->called_scope;
	fci->object_ptr = fci_cache->object_ptr;
	EX(object) = fci->object_ptr;
	if (fci->object_ptr && Z_TYPE_P(fci->object_ptr) == IS_OBJECT &&
		(!EG(objects_store).object_buckets || !EG(objects_store).object_buckets[Z_OBJ_HANDLE_P(fci->object_ptr)].valid)) {
		return FAILURE;
	}

	if (EX(function_state).function->common.fn_flags & ZEND_ACC_ABSTRACT) {
		zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EX(function_state).function->common.scope->name, EX(function_state).function->common.function_name);
		return FAILURE;
	}

	ZEND_VM_STACK_GROW_IF_NEEDED(fci->param_count + 1);

	for (i = 0; i < fci->param_count; i++) {
		zval *param;

		if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION
			&& (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) == 0
			&& !ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& PZVAL_IS_REF(*fci->params[i])) {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
			zval_copy_ctor(param);
		} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(function_state).function, i + 1)
			&& !PZVAL_IS_REF(*fci->params[i])) {

			if (Z_REFCOUNT_PP(fci->params[i]) > 1) {
				zval *new_zval;

				if (fci->no_separation &&
					!ARG_MAY_BE_SENT_BY_REF(EX(function_state).function, i + 1)) {
					if (i || UNEXPECTED(ZEND_VM_STACK_ELEMETS(EG(argument_stack)) == EG(argument_stack)->top)) {
						/* hack to clean up the stack */
						zend_vm_stack_push_nocheck((void *) (zend_uintptr_t)i TSRMLS_CC);
						#if PHP_VERSION_ID <= 50500
						zend_vm_stack_clear_multiple(TSRMLS_C);
						#else
						zend_vm_stack_clear_multiple(0 TSRMLS_C);
						#endif
					}

					zend_error(E_WARNING, "Parameter %d to %s%s%s() expected to be a reference, value given",
						i+1,
						EX(function_state).function->common.scope ? EX(function_state).function->common.scope->name : "",
						EX(function_state).function->common.scope ? "::" : "",
						EX(function_state).function->common.function_name);
					return FAILURE;
				}

				ALLOC_ZVAL(new_zval);
				*new_zval = **fci->params[i];
				zval_copy_ctor(new_zval);
				Z_SET_REFCOUNT_P(new_zval, 1);
				Z_DELREF_PP(fci->params[i]);
				*fci->params[i] = new_zval;
			}
			Z_ADDREF_PP(fci->params[i]);
			Z_SET_ISREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else if (*fci->params[i] != &EG(uninitialized_zval)) {
			Z_ADDREF_PP(fci->params[i]);
			param = *fci->params[i];
		} else {
			ALLOC_ZVAL(param);
			*param = **(fci->params[i]);
			INIT_PZVAL(param);
		}
		zend_vm_stack_push_nocheck(param TSRMLS_CC);
	}

	EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
	zend_vm_stack_push_nocheck((void*)(zend_uintptr_t)fci->param_count TSRMLS_CC);

	current_scope = EG(scope);
	EG(scope) = calling_scope;

	current_this = EG(This);

	current_called_scope = EG(called_scope);
	if (called_scope) {
		EG(called_scope) = called_scope;
	} else {
		if (EX(function_state).function->type != ZEND_INTERNAL_FUNCTION) {
			EG(called_scope) = NULL;
		}
	}

	if (fci->object_ptr) {
		if ((EX(function_state).function->common.fn_flags & ZEND_ACC_STATIC)) {
			EG(This) = NULL;
		} else {
			EG(This) = fci->object_ptr;

			if (!PZVAL_IS_REF(EG(This))) {
				Z_ADDREF_P(EG(This)); /* For $this pointer */
			} else {
				zval *this_ptr;

				ALLOC_ZVAL(this_ptr);
				*this_ptr = *EG(This);
				INIT_PZVAL(this_ptr);
				zval_copy_ctor(this_ptr);
				EG(This) = this_ptr;
			}
		}
	} else {
		EG(This) = NULL;
	}

	EX(prev_execute_data) = EG(current_execute_data);
	EG(current_execute_data) = &execute_data;

	if (EX(function_state).function->type == ZEND_USER_FUNCTION) {
		calling_symbol_table = EG(active_symbol_table);
		EG(scope) = EX(function_state).function->common.scope;
		if (fci->symbol_table) {
			EG(active_symbol_table) = fci->symbol_table;
		} else {
			EG(active_symbol_table) = NULL;
		}

		original_return_value = EG(return_value_ptr_ptr);
		original_op_array = EG(active_op_array);
		EG(return_value_ptr_ptr) = fci->retval_ptr_ptr;
		EG(active_op_array) = (zend_op_array *) EX(function_state).function;
		original_opline_ptr = EG(opline_ptr);
		zend_execute(EG(active_op_array) TSRMLS_CC);
		if (!fci->symbol_table && EG(active_symbol_table)) {
			if (EG(symtable_cache_ptr)>=EG(symtable_cache_limit)) {
				zend_hash_destroy(EG(active_symbol_table));
				FREE_HASHTABLE(EG(active_symbol_table));
			} else {
				/* clean before putting into the cache, since clean
				   could call dtors, which could use cached hash */
				zend_hash_clean(EG(active_symbol_table));
				*(++EG(symtable_cache_ptr)) = EG(active_symbol_table);
			}
		}
		EG(active_symbol_table) = calling_symbol_table;
		EG(active_op_array) = original_op_array;
		EG(return_value_ptr_ptr)=original_return_value;
		EG(opline_ptr) = original_opline_ptr;
	} else if (EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		int call_via_handler = (EX(function_state).function->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER) != 0;
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);
		if (EX(function_state).function->common.scope) {
			EG(scope) = EX(function_state).function->common.scope;
		}
		((zend_internal_function *) EX(function_state).function)->handler(fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		/*  We shouldn't fix bad extensions here,
			because it can break proper ones (Bug #34045)
		if (!EX(function_state).function->common.return_reference)
		{
			INIT_PZVAL(*fci->retval_ptr_ptr);
		}*/
		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}

		if (call_via_handler) {
			/* We must re-initialize function again */
			fci_cache->initialized = 0;
		}
	} else {
		ALLOC_INIT_ZVAL(*fci->retval_ptr_ptr);

		if (fci->object_ptr) {
			Z_OBJ_HT_P(fci->object_ptr)->call_method(EX(function_state).function->common.function_name, fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, 1 TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
			return FAILURE;
		}

		if (EX(function_state).function->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			efree(EX(function_state).function->common.function_name);
		}
		efree(EX(function_state).function);

		if (EG(exception) && fci->retval_ptr_ptr) {
			zval_ptr_dtor(fci->retval_ptr_ptr);
			*fci->retval_ptr_ptr = NULL;
		}
	}
	#if PHP_VERSION_ID <= 50500
	zend_vm_stack_clear_multiple(TSRMLS_C);
	#else
	zend_vm_stack_clear_multiple(0 TSRMLS_C);
	#endif

	if (EG(This)) {
		zval_ptr_dtor(&EG(This));
	}
	EG(called_scope) = current_called_scope;
	EG(scope) = current_scope;
	EG(This) = current_this;
	EG(current_execute_data) = EX(prev_execute_data);

	if (EG(exception)) {
		phalcon_throw_exception_internal(NULL TSRMLS_CC);
	}
	return SUCCESS;
}

#endif





#include <ext/standard/php_array.h>


static int phalcon_array_isset_fetch(zval **fetched, const zval *arr, const zval *index) {

	HashTable *h;
	zval **val;
	int result;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}

	h = Z_ARRVAL_P(arr);
	switch (Z_TYPE_P(index)) {
		case IS_NULL:
			result = phalcon_hash_find(h, ZEND_STRS(""), (void**)&val);
			break;

		case IS_DOUBLE:
			result = zend_hash_index_find(h, (ulong)Z_DVAL_P(index), (void**)&val);
			break;

		case IS_LONG:
		case IS_BOOL:
		case IS_RESOURCE:
			result = zend_hash_index_find(h, Z_LVAL_P(index), (void**)&val);
			break;

		case IS_STRING:
			result = zend_symtable_find(h, (Z_STRLEN_P(index) ? Z_STRVAL_P(index) : ""), Z_STRLEN_P(index)+1, (void**)&val);
			break;

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return 0;
	}

	if (result == SUCCESS) {
		*fetched = *val;
		return 1;
	}

	return 0;
}

static int phalcon_array_isset_quick_string_fetch(zval **fetched, const zval *arr, const char *index, uint index_length, ulong key) {

	zval **zv;

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		if (phalcon_hash_quick_find(Z_ARRVAL_P(arr), index, index_length, key, (void**) &zv) == SUCCESS) {
			*fetched = *zv;
			return 1;
		}
	}

	return 0;
}

static int phalcon_array_isset_long_fetch(zval **fetched, const zval *arr, ulong index) {

	zval **zv;

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		if (zend_hash_index_find(Z_ARRVAL_P(arr), index, (void**)&zv) == SUCCESS) {
			*fetched = *zv;
			return 1;
		}
	}

	return 0;
}

static int phalcon_array_isset(const zval *arr, const zval *index) {

	HashTable *h;

	if (Z_TYPE_P(arr) != IS_ARRAY) {
		return 0;
	}

	h = Z_ARRVAL_P(arr);
	switch (Z_TYPE_P(index)) {
		case IS_NULL:
			return phalcon_hash_exists(h, ZEND_STRS(""));

		case IS_DOUBLE:
			return zend_hash_index_exists(h, (ulong)Z_DVAL_P(index));

		case IS_BOOL:
		case IS_LONG:
		case IS_RESOURCE:
			return zend_hash_index_exists(h, Z_LVAL_P(index));

		case IS_STRING:
			return zend_symtable_exists(h, Z_STRVAL_P(index), Z_STRLEN_P(index)+1);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return 0;
	}
}

static int phalcon_array_isset_quick_string(const zval *arr, const char *index, uint index_length, ulong key) {

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		return zend_hash_quick_exists(Z_ARRVAL_P(arr), index, index_length, key);
	}

	return 0;
}

static int phalcon_array_isset_long(const zval *arr, ulong index) {

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		return zend_hash_index_exists(Z_ARRVAL_P(arr), index);
	}

	return 0;
}

static int phalcon_array_unset(zval **arr, const zval *index, int flags) {

	HashTable *ht;

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	ht = Z_ARRVAL_PP(arr);

	switch (Z_TYPE_P(index)) {
		case IS_NULL:
			return (zend_hash_del(ht, "", 1) == SUCCESS);

		case IS_DOUBLE:
			return (zend_hash_index_del(ht, (ulong)Z_DVAL_P(index)) == SUCCESS);

		case IS_LONG:
		case IS_BOOL:
		case IS_RESOURCE:
			return (zend_hash_index_del(ht, Z_LVAL_P(index)) == SUCCESS);

		case IS_STRING:
			return (zend_symtable_del(ht, Z_STRVAL_P(index), Z_STRLEN_P(index)+1) == SUCCESS);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return 0;
	}
}

static int phalcon_array_unset_string(zval **arr, const char *index, uint index_length, int flags) {

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	return zend_hash_del(Z_ARRVAL_PP(arr), index, index_length);
}

static int phalcon_array_unset_long(zval **arr, ulong index, int flags) {

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	return zend_hash_index_del(Z_ARRVAL_PP(arr), index);
}

static int phalcon_array_append(zval **arr, zval *value, int flags) {

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		zend_error(E_WARNING, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	Z_ADDREF_P(value);
	return add_next_index_zval(*arr, value);
}

static int phalcon_array_update_zval(zval **arr, const zval *index, zval *value, int flags)
{
	HashTable *ht;
	int status;

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		zend_error(E_WARNING, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	if (flags & PH_COPY) {
		Z_ADDREF_P(value);
	}

	ht = Z_ARRVAL_PP(arr);

	switch (Z_TYPE_P(index)) {
		case IS_NULL:
			status = zend_symtable_update(ht, "", 1, (void*)&value, sizeof(zval*), NULL);
			break;

		case IS_DOUBLE:
			status = zend_hash_index_update(ht, (ulong)Z_DVAL_P(index), (void*)&value, sizeof(zval*), NULL);
			break;

		case IS_LONG:
		case IS_BOOL:
		case IS_RESOURCE:
			status = zend_hash_index_update(ht, Z_LVAL_P(index), (void*)&value, sizeof(zval*), NULL);
			break;

		case IS_STRING:
			status = zend_symtable_update(ht, Z_STRVAL_P(index), Z_STRLEN_P(index)+1, (void*)&value, sizeof(zval*), NULL);
			break;

		default:
			zend_error(E_WARNING, "Illegal offset type");
			status = FAILURE;
			break;
	}

	if (status == FAILURE && (flags & PH_COPY)) {
		Z_DELREF_P(value);
	}

	return status;
}

static int phalcon_array_update_quick_string(zval **arr, const char *index, uint index_length, ulong key, zval *value, int flags){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		zend_error(E_WARNING, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	if (flags & PH_COPY) {
		Z_ADDREF_P(value);
	}

	return zend_hash_quick_update(Z_ARRVAL_PP(arr), index, index_length, key, (void*)&value, sizeof(zval *), NULL);
}

static int phalcon_array_update_long(zval **arr, ulong index, zval *value, int flags){

	if (Z_TYPE_PP(arr) != IS_ARRAY) {
		zend_error(E_WARNING, "Cannot use a scalar value as an array");
		return FAILURE;
	}

	if (flags & PH_SEPARATE) {
		SEPARATE_ZVAL_IF_NOT_REF(arr);
	}

	if (flags & PH_COPY) {
		Z_ADDREF_P(value);
	}

	return zend_hash_index_update(Z_ARRVAL_PP(arr), index, (void*)&value, sizeof(zval *), NULL);
}

static int phalcon_array_fetch(zval **return_value, const zval *arr, const zval *index, int silent){

	zval **zv;
	HashTable *ht;
	int result;
	ulong uidx = 0;
	char *sidx = NULL;

	if (Z_TYPE_P(arr) == IS_ARRAY) {
		ht = Z_ARRVAL_P(arr);
		switch (Z_TYPE_P(index)) {
			case IS_NULL:
				result = phalcon_hash_find(ht, ZEND_STRS(""), (void**) &zv);
				sidx   = "";
				break;

			case IS_DOUBLE:
				uidx   = (ulong)Z_DVAL_P(index);
				result = zend_hash_index_find(ht, uidx, (void**) &zv);
				break;

			case IS_LONG:
			case IS_BOOL:
			case IS_RESOURCE:
				uidx   = Z_LVAL_P(index);
				result = zend_hash_index_find(ht, uidx, (void**) &zv);
				break;

			case IS_STRING:
				sidx   = Z_STRLEN_P(index) ? Z_STRVAL_P(index) : "";
				result = zend_symtable_find(ht, Z_STRVAL_P(index), Z_STRLEN_P(index)+1, (void**) &zv);
				break;

			default:
				if (silent == PH_NOISY) {
					zend_error(E_WARNING, "Illegal offset type");
				}

				result = FAILURE;
				break;
		}

		if (result != FAILURE) {
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}

		if (silent == PH_NOISY) {
			if (sidx == NULL) {
				zend_error(E_NOTICE, "Undefined index: %ld", uidx);
			} else {
				zend_error(E_NOTICE, "Undefined index: %s", sidx);
			}
		}
	}

	ALLOC_INIT_ZVAL(*return_value);
	return FAILURE;
}

static int phalcon_array_fetch_quick_string(zval **return_value, const zval *arr, const char *index, uint index_length, ulong key, int silent){

	zval **zv;

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		if (phalcon_hash_quick_find(Z_ARRVAL_P(arr), index, index_length, key, (void**) &zv) == SUCCESS) {
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}

		if (silent == PH_NOISY) {
			zend_error(E_NOTICE, "Undefined index: %s", index);
		}
	}
	else {
		if (silent == PH_NOISY) {
			zend_error(E_NOTICE, "Cannot use a scalar value as an array");
		}
	}

	ALLOC_INIT_ZVAL(*return_value);
	return FAILURE;
}

static int phalcon_array_fetch_long(zval **return_value, const zval *arr, ulong index, int silent){

	zval **zv;

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		if (zend_hash_index_find(Z_ARRVAL_P(arr), index, (void**)&zv) == SUCCESS) {
			*return_value = *zv;
			Z_ADDREF_PP(return_value);
			return SUCCESS;
		}

		if (silent == PH_NOISY) {
			zend_error(E_NOTICE, "Undefined index: %lu", index);
		}
	}
	else {
		if (silent == PH_NOISY) {
			zend_error(E_NOTICE, "Cannot use a scalar value as an array");
		}
	}

	ALLOC_INIT_ZVAL(*return_value);
	return FAILURE;
}

static void phalcon_array_append_multi_2(zval **arr, const zval *index, zval *value, int flags){

	zval *temp;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp);
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
		}

		phalcon_array_update_zval(arr, index, temp, 0);
		phalcon_array_append(&temp, value, flags);
	}
}

static void phalcon_array_update_multi_2(zval **arr, const zval *index1, const zval *index2, zval *value, int flags){

	zval *temp;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp);
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
		}

		phalcon_array_update_zval(arr, index1, temp, 0);
		phalcon_array_update_zval(&temp, index2, value, flags | PH_COPY);
	}

}

static void phalcon_array_update_string_multi_2(zval **arr, const zval *index1, const char *index2, uint index2_length, zval *value, int flags){

	zval *temp;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp);
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
		}

		phalcon_array_update_zval(arr, index1, temp, 0);
		phalcon_array_update_string(&temp, index2, index2_length, value, flags | PH_COPY);
	}
}

static void phalcon_array_update_long_long_multi_2(zval **arr, ulong index1, ulong index2, zval *value, int flags){

	zval *temp;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp);
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
		}

		phalcon_array_update_long(arr, index1, temp, 0);
		phalcon_array_update_long(&temp, index2, value, flags | PH_COPY);
	}
}

static void phalcon_array_update_long_string_multi_2(zval **arr, ulong index1, const char *index2, uint index2_length, zval *value, int flags){

	zval *temp;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch_long(&temp, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp);
		if (Z_TYPE_P(temp) != IS_ARRAY) {
			convert_to_array(temp);
		}

		phalcon_array_update_long(arr, index1, temp, 0);
		phalcon_array_update_string(&temp, index2, index2_length, value, flags | PH_COPY);
	}
}

static void phalcon_array_update_zval_string_append_multi_3(zval **arr, const zval *index1, const char *index2, uint index2_length, zval *value, int flags){

	zval *temp1, *temp2;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {
		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp1);
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
		}

		phalcon_array_update_zval(arr, index1, temp1, 0);

		phalcon_array_fetch_string(&temp2, temp1, index2, index2_length, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp2);
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
		}

		phalcon_array_update_string(&temp1, index2, index2_length, temp2, 0);
		phalcon_array_append(&temp2, value, flags);
	}
}

static void phalcon_array_update_zval_zval_zval_multi_3(zval **arr, const zval *index1, const zval *index2, const zval *index3, zval *value, int flags){

	zval *temp1, *temp2;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp1);
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
		}

		phalcon_array_update_zval(arr, index1, temp1, 0);

		phalcon_array_fetch(&temp2, temp1, index2, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp2);
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
		}

		phalcon_array_update_zval(&temp1, index2, temp2, 0);
		phalcon_array_update_zval(&temp2, index3, value, PH_COPY);
	}
}

static void phalcon_array_update_string_zval_zval_multi_3(zval **arr, const zval *index1, const zval *index2, const char *index3, uint index3_length, zval *value, int flags){

	zval *temp1, *temp2;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp1);
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
		}

		phalcon_array_update_zval(arr, index1, temp1, 0);

		phalcon_array_fetch(&temp2, temp1, index2, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp2);
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
		}

		phalcon_array_update_zval(&temp1, index2, temp2, 0);
		phalcon_array_update_string(&temp2, index3, index3_length, value, PH_COPY);
	}
}

static void phalcon_array_update_zval_string_string_multi_3(zval **arr, const zval *index1, const char *index2, uint index2_length, const char *index3, uint index3_length, zval *value, int flags){

	zval *temp1, *temp2;

	if (Z_TYPE_PP(arr) == IS_ARRAY) {

		phalcon_array_fetch(&temp1, *arr, index1, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp1);
		if (Z_TYPE_P(temp1) != IS_ARRAY) {
			convert_to_array(temp1);
		}

		phalcon_array_update_zval(arr, index1, temp1, 0);

		phalcon_array_fetch_string(&temp2, temp1, index2, index2_length, PH_SILENT);

		SEPARATE_ZVAL_IF_NOT_REF(&temp2);
		if (Z_TYPE_P(temp2) != IS_ARRAY) {
			convert_to_array(temp2);
		}

		phalcon_array_update_string(&temp1, index2, index2_length, temp2, 0);
		phalcon_array_update_string(&temp2, index3, index3_length, value, PH_COPY);
	}
}


static void phalcon_merge_append(zval *left, zval *values){

	if (Z_TYPE_P(left) != IS_ARRAY) {
		zend_error(E_NOTICE, "The first parameter of phalcon_merge_append must be an array");
		return;
	}

	if (Z_TYPE_P(values) == IS_ARRAY) {
		HashPosition pos;
		zval **tmp;
		HashTable *arr_values = Z_ARRVAL_P(values);

		for (
			zend_hash_internal_pointer_reset_ex(arr_values, &pos);
			zend_hash_get_current_data_ex(arr_values, (void**)&tmp, &pos) == SUCCESS;
			zend_hash_move_forward_ex(arr_values, &pos)
		) {
			Z_ADDREF_PP(tmp);
			add_next_index_zval(left, *tmp);
		}
	} else {
		Z_ADDREF_P(values);
		add_next_index_zval(left, values);
	}
}

static void phalcon_array_get_current(zval *return_value, zval *array){

	zval **entry;

	if (Z_TYPE_P(array) == IS_ARRAY) {
		if (zend_hash_get_current_data(Z_ARRVAL_P(array), (void **) &entry) == FAILURE) {
			RETURN_FALSE;
		}
		RETURN_ZVAL(*entry, 1, 0);
	}

	RETURN_FALSE;
}

static int phalcon_fast_in_array(zval *needle, zval *haystack TSRMLS_DC) {

	zval         **tmp;
	HashTable      *arr;
	HashPosition   pos;
	unsigned int   numelems;

	if (Z_TYPE_P(haystack) != IS_ARRAY) {
		return 0;
	}

	arr = Z_ARRVAL_P(haystack);
	numelems = zend_hash_num_elements(arr);

	if (numelems == 0) {
		return 0;
	}

	zend_hash_internal_pointer_reset_ex(arr, &pos);

	while (zend_hash_get_current_data_ex(arr, (void **) &tmp, &pos) == SUCCESS) {
		if (phalcon_is_equal(needle, *tmp TSRMLS_CC)) {
			return 1;
		}
		zend_hash_move_forward_ex(arr, &pos);
	}

	return 0;
}

static void phalcon_fast_array_merge(zval *return_value, zval **array1, zval **array2 TSRMLS_DC) {

	int init_size, num;

	if (Z_TYPE_PP(array1) != IS_ARRAY) {
		zend_error(E_WARNING, "First argument is not an array");
		RETURN_NULL();
	}

	if (Z_TYPE_PP(array2) != IS_ARRAY) {
		zend_error(E_WARNING, "Second argument is not an array");
		RETURN_NULL();
	}

	init_size = zend_hash_num_elements(Z_ARRVAL_PP(array1));
	num = zend_hash_num_elements(Z_ARRVAL_PP(array2));
	if (num > init_size) {
		init_size = num;
	}

	array_init_size(return_value, init_size);

	php_array_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(array1), 0 TSRMLS_CC);

	php_array_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(array2), 0 TSRMLS_CC);

}

static void phalcon_array_merge_recursive_n(zval **a1, zval *a2)
{
	HashPosition hp;
	zval **value, key, *tmp1, *tmp2;

	assert(Z_TYPE_PP(a1) == IS_ARRAY);
	assert(Z_TYPE_P(a2)  == IS_ARRAY);

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(a2), &hp);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(a2), (void**) &value, &hp) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(a2), &hp)
	) {
		key = phalcon_get_current_key_w(Z_ARRVAL_P(a2), &hp);

		if (!phalcon_array_isset(*a1, &key) || Z_TYPE_PP(value) != IS_ARRAY) {
			phalcon_array_update_zval(a1, &key, *value, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_fetch(&tmp1, *a1, &key, PH_NOISY);
			phalcon_array_fetch(&tmp2, a2, &key, PH_NOISY);
			phalcon_array_merge_recursive_n(&tmp1, tmp2);
			zval_ptr_dtor(&tmp1);
			zval_ptr_dtor(&tmp2);
		}
	}
}

HashTable* phalcon_array_splice(HashTable *in_hash, int offset, int length, zval ***list, int list_count, HashTable **removed TSRMLS_DC) /* {{{ */
{
	HashTable 	*out_hash = NULL;	/* Output hashtable */
	int			 num_in,			/* Number of entries in the input hashtable */
				 pos,				/* Current position in the hashtable */
				 i;					/* Loop counter */
	Bucket		*p;					/* Pointer to hash bucket */
	zval		*entry;				/* Hash entry */

	/* If input hash doesn't exist, we have nothing to do */
	if (!in_hash) {
		return NULL;
	}

	/* Get number of entries in the input hash */
	num_in = zend_hash_num_elements(in_hash);

	/* Clamp the offset.. */
	if (offset > num_in) {
		offset = num_in;
	} else if (offset < 0 && (offset = (num_in + offset)) < 0) {
		offset = 0;
	}

	/* ..and the length */
	if (length < 0) {
		length = num_in - offset + length;
	} else if (((unsigned)offset + (unsigned)length) > (unsigned)num_in) {
		length = num_in - offset;
	}

	/* Create and initialize output hash */
	ALLOC_HASHTABLE(out_hash);
	zend_hash_init(out_hash, (length > 0 ? num_in - length : 0) + list_count, NULL, ZVAL_PTR_DTOR, 0);

	/* Start at the beginning of the input hash and copy entries to output hash until offset is reached */
	for (pos = 0, p = in_hash->pListHead; pos < offset && p ; pos++, p = p->pListNext) {
		/* Get entry and increase reference count */
		entry = *((zval **)p->pData);
		Z_ADDREF_P(entry);

		/* Update output hash depending on key type */
		if (p->nKeyLength == 0) {
			zend_hash_next_index_insert(out_hash, &entry, sizeof(zval *), NULL);
		} else {
			zend_hash_quick_update(out_hash, p->arKey, p->nKeyLength, p->h, &entry, sizeof(zval *), NULL);
		}
	}

	/* If hash for removed entries exists, go until offset+length and copy the entries to it */
	if (removed != NULL) {
		for ( ; pos < offset + length && p; pos++, p = p->pListNext) {
			entry = *((zval **)p->pData);
			Z_ADDREF_P(entry);
			if (p->nKeyLength == 0) {
				zend_hash_next_index_insert(*removed, &entry, sizeof(zval *), NULL);
			} else {
				zend_hash_quick_update(*removed, p->arKey, p->nKeyLength, p->h, &entry, sizeof(zval *), NULL);
			}
		}
	} else { /* otherwise just skip those entries */
		for ( ; pos < offset + length && p; pos++, p = p->pListNext);
	}

	/* If there are entries to insert.. */
	if (list != NULL) {
		/* ..for each one, create a new zval, copy entry into it and copy it into the output hash */
		for (i = 0; i < list_count; i++) {
			entry = *list[i];
			Z_ADDREF_P(entry);
			zend_hash_next_index_insert(out_hash, &entry, sizeof(zval *), NULL);
		}
	}

	/* Copy the remaining input hash entries to the output hash */
	for ( ; p ; p = p->pListNext) {
		entry = *((zval **)p->pData);
		Z_ADDREF_P(entry);
		if (p->nKeyLength == 0) {
			zend_hash_next_index_insert(out_hash, &entry, sizeof(zval *), NULL);
		} else {
			zend_hash_quick_update(out_hash, p->arKey, p->nKeyLength, p->h, &entry, sizeof(zval *), NULL);
		}
	}

	zend_hash_internal_pointer_reset(out_hash);
	return out_hash;
}
/* }}} */

static void phalcon_array_unshift(zval *arr, zval *arg TSRMLS_DC)
{
	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		zval** args[1]      = { &arg };

		HashTable *newhash = phalcon_array_splice(Z_ARRVAL_P(arr), 0, 0, args, 1, NULL TSRMLS_CC);

		HashTable  oldhash = *Z_ARRVAL_P(arr);
		*Z_ARRVAL_P(arr)   = *newhash;

		FREE_HASHTABLE(newhash);
		zend_hash_destroy(&oldhash);
	}
}

static void phalcon_array_keys(zval *return_value, zval *arr) {

	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		HashPosition pos;
		zval **entry, *new_val;
		char *skey;
		uint skey_len;
		ulong nkey;

		array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(arr)));

		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(arr), &pos);
		while (zend_hash_get_current_data_ex(Z_ARRVAL_P(arr), (void**)&entry, &pos) == SUCCESS) {
			MAKE_STD_ZVAL(new_val);

			switch (zend_hash_get_current_key_ex(Z_ARRVAL_P(arr), &skey, &skey_len, &nkey, 1, &pos)) {
				case HASH_KEY_IS_STRING:
					ZVAL_STRINGL(new_val, skey, skey_len - 1, 0);
					zend_hash_next_index_insert(Z_ARRVAL_P(arr), &new_val, sizeof(zval*), NULL);
					break;

				case HASH_KEY_IS_LONG:
					ZVAL_LONG(new_val, nkey);
					zend_hash_next_index_insert(Z_ARRVAL_P(arr), &new_val, sizeof(zval*), NULL);
					break;
			}

			zend_hash_move_forward_ex(Z_ARRVAL_P(arr), &pos);
		}
	}
}

static void phalcon_array_values(zval *return_value, zval *arr)
{
	if (likely(Z_TYPE_P(arr) == IS_ARRAY)) {
		zval **entry;
		HashPosition pos;

		array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(arr)));
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(arr), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(arr), (void **)&entry, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(arr), &pos)
		) {
			Z_ADDREF_PP(entry);
			zend_hash_next_index_insert(Z_ARRVAL_P(return_value), entry, sizeof(zval*), NULL);
		}
	}
}

static int phalcon_array_key_exists(zval *arr, zval *key TSRMLS_DC)
{
	HashTable *h = HASH_OF(arr);
	if (h) {
		switch (Z_TYPE_P(key)) {
			case IS_STRING:
				return zend_symtable_exists(h, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1);

			case IS_LONG:
				return zend_hash_index_exists(h, Z_LVAL_P(key));

			case IS_NULL:
				return zend_hash_exists(h, "", 1);

			default:
				zend_error(E_WARNING, "The key should be either a string or an integer");
				return 0;
		}
	}

	return 0;
}





static int phalcon_hash_exists(const HashTable *ht, const char *arKey, uint nKeyLength)
{
	ulong h;
	uint nIndex;
	Bucket *p;

	h = zend_inline_hash_func(arKey, nKeyLength);
	nIndex = h & ht->nTableMask;

	p = ht->arBuckets[nIndex];
	while (p != NULL) {
		if (p->arKey == arKey || ((p->h == h) && (p->nKeyLength == nKeyLength))) {
			if (!memcmp(p->arKey, arKey, nKeyLength)) {
				return 1;
			}
		}
		p = p->pNext;
	}
	return 0;
}

static int phalcon_hash_quick_exists(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h)
{
	uint nIndex;
	Bucket *p;

	if (nKeyLength == 0) {
		return zend_hash_index_exists(ht, h);
	}

	nIndex = h & ht->nTableMask;

	p = ht->arBuckets[nIndex];
	while (p != NULL) {
		if (p->arKey == arKey || ((p->h == h) && (p->nKeyLength == nKeyLength))) {
			if (!memcmp(p->arKey, arKey, nKeyLength)) {
				return 1;
			}
		}
		p = p->pNext;
	}
	return 0;
}

static int phalcon_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)
{
	ulong h;
	uint nIndex;
	Bucket *p;

	h = zend_inline_hash_func(arKey, nKeyLength);
	nIndex = h & ht->nTableMask;

	p = ht->arBuckets[nIndex];
	while (p != NULL) {
		if (p->arKey == arKey || ((p->h == h) && (p->nKeyLength == nKeyLength))) {
			if (!memcmp(p->arKey, arKey, nKeyLength)) {
				*pData = p->pData;
				return SUCCESS;
			}
		}
		p = p->pNext;
	}
	return FAILURE;
}

static int phalcon_hash_quick_find(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void **pData)
{
	uint nIndex;
	Bucket *p;

	if (nKeyLength == 0) {
		return zend_hash_index_find(ht, h, pData);
	}

	nIndex = h & ht->nTableMask;

	p = ht->arBuckets[nIndex];
	while (p != NULL) {
		if (p->arKey == arKey || ((p->h == h) && (p->nKeyLength == nKeyLength))) {
			if (!memcmp(p->arKey, arKey, nKeyLength)) {
				*pData = p->pData;
				return SUCCESS;
			}
		}
		p = p->pNext;
	}
	return FAILURE;
}

static void phalcon_get_current_key(zval **key, const HashTable *hash_table, HashPosition *hash_position TSRMLS_DC)
{
	Bucket *p;

	p = hash_position ? (*hash_position) : hash_table->pInternalPointer;

	if (p) {
		if (p->nKeyLength) {
			ZVAL_STRINGL(*key, (char *) p->arKey, p->nKeyLength - 1, 0);
		} else {
			ZVAL_LONG(*key, p->h);
		}
	}

}

zval phalcon_get_current_key_w(const HashTable *hash_table, HashPosition *hash_position)
{
	Bucket *p;
	zval result;

	INIT_ZVAL(result);
	p = hash_position ? (*hash_position) : hash_table->pInternalPointer;

	if (p) {
		if (p->nKeyLength) {
			ZVAL_STRINGL(&result, (char *) p->arKey, p->nKeyLength - 1, 0);
		} else {
			ZVAL_LONG(&result, p->h);
		}
	}

	return result;
}

static int phalcon_has_numeric_keys(const zval *data)
{
	HashTable *ht;

	if (Z_TYPE_P(data) == IS_ARRAY) {

		ht = Z_ARRVAL_P(data);

		ht->pInternalPointer = ht->pListHead;
		while (ht->pInternalPointer) {
			if (!ht->pInternalPointer->nKeyLength) {
				return 1;
			}
			ht->pInternalPointer = ht->pInternalPointer->pListNext;
		}

	}

	return 0;
}

static int phalcon_hash_update_or_insert(HashTable *ht, const zval *key, zval *value)
{
	if (!key || Z_TYPE_P(key) == IS_NULL) {
		return zend_hash_next_index_insert(ht, (void**)&value, sizeof(zval*), NULL);
	}

	switch (Z_TYPE_P(key)) {
		case IS_STRING:
			return zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key)+1, (void**)&value, sizeof(zval*), NULL);

		case IS_RESOURCE:
		case IS_DOUBLE:
		case IS_BOOL:
		case IS_LONG:
			return zend_hash_index_update(ht, ((Z_TYPE_P(key) == IS_DOUBLE) ? (ulong)Z_DVAL_P(key) : (ulong)Z_LVAL_P(key)), (void*)&value, sizeof(zval*), NULL);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return FAILURE;
	}
}

zval** phalcon_hash_get(HashTable *ht, const zval *key, int type)
{
	zval **ret = NULL;

	switch (Z_TYPE_P(key)) {
		case IS_RESOURCE:
			zend_error(E_STRICT, "Resource ID#%ld used as offset, casting to integer (%ld)", Z_LVAL_P(key), Z_LVAL_P(key));
			/* no break */
		case IS_LONG:
		case IS_DOUBLE:
		case IS_BOOL: {
			ulong index = (Z_TYPE_P(key) == IS_DOUBLE) ? ((long int)Z_DVAL_P(key)) : Z_LVAL_P(key);
			if (FAILURE == zend_hash_index_find(ht, index, (void**)&ret)) {
				switch (type) {
					case BP_VAR_R:
						zend_error(E_NOTICE, "Undefined offset: %ld", index);
						/* no break */
					case BP_VAR_UNSET:
					case BP_VAR_IS: {
						TSRMLS_FETCH();
						ret = &EG(uninitialized_zval_ptr);
						break;
					}

					case BP_VAR_RW:
						zend_error(E_NOTICE, "Undefined offset: %ld", index);
						/* no break */
					case BP_VAR_W: {
						zval *value;
						ALLOC_INIT_ZVAL(value);
						zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void**)&ret);
						break;
					}
				}
			}

			return ret;
		}

		case IS_STRING:
			if (FAILURE == zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key)+1, (void**)&ret)) {
				switch (type) {
					case BP_VAR_R:
						zend_error(E_NOTICE, "Undefined offset: %s", Z_STRVAL_P(key));
						/* no break */
					case BP_VAR_UNSET:
					case BP_VAR_IS: {
						TSRMLS_FETCH();
						ret = &EG(uninitialized_zval_ptr);
						break;
					}

					case BP_VAR_RW:
						zend_error(E_NOTICE, "Undefined offset: %s", Z_STRVAL_P(key));
						/* no break */
					case BP_VAR_W: {
						zval *value;
						ALLOC_INIT_ZVAL(value);
						zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key)+1, (void**)&value, sizeof(void*), (void**)&ret);
						break;
					}
				}
			}

			return ret;

		default: {
			TSRMLS_FETCH();
			zend_error(E_WARNING, "Illegal offset type");
			return (type == BP_VAR_W || type == BP_VAR_RW) ? &EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);
		}
	}
}

static int phalcon_hash_unset(HashTable *ht, const zval *key)
{
	switch (Z_TYPE_P(key)) {
		case IS_LONG:
		case IS_DOUBLE:
		case IS_BOOL:
		case IS_RESOURCE:
			return (zend_hash_index_del(ht, (Z_TYPE_P(key) == IS_DOUBLE) ? ((long int)Z_DVAL_P(key)) : Z_LVAL_P(key)) == SUCCESS);

		case IS_STRING:
			return (zend_symtable_del(ht, Z_STRVAL_P(key), Z_STRLEN_P(key)+1) == SUCCESS);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return 0;
	}
}

#if PHP_VERSION_ID >= 50400
zval** phalcon_hash_fast_get(HashTable *ht, int type, const zend_literal* key)
{
	zval **ret = NULL;

	switch (Z_TYPE(key->constant)) {
		case IS_RESOURCE:
			zend_error(E_STRICT, "Resource ID#%ld used as offset, casting to integer (%ld)", Z_LVAL(key->constant), Z_LVAL(key->constant));
			/* no break */
		case IS_LONG:
		case IS_DOUBLE:
		case IS_BOOL: {
			ulong index = (Z_TYPE(key->constant) == IS_DOUBLE) ? ((long int)Z_DVAL(key->constant)) : Z_LVAL(key->constant);
			if (FAILURE == zend_hash_index_find(ht, index, (void**)&ret)) {
				switch (type) {
					case BP_VAR_R:
						zend_error(E_NOTICE, "Undefined offset: %ld", index);
						/* no break */
					case BP_VAR_UNSET:
					case BP_VAR_IS: {
						TSRMLS_FETCH();
						ret = &EG(uninitialized_zval_ptr);
						break;
					}

					case BP_VAR_RW:
						zend_error(E_NOTICE, "Undefined offset: %ld", index);
						/* no break */
					case BP_VAR_W: {
						zval *value;
						ALLOC_INIT_ZVAL(value);
						zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void**)&ret);
						break;
					}
				}
			}

			return ret;
		}

		case IS_STRING:
			if (*(Z_STRVAL(key->constant)) >= '0' && *(Z_STRVAL(key->constant)) <= '9') {
				return phalcon_hash_get(ht, &key->constant, type);
			}

			if (FAILURE == zend_hash_quick_find(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1, key->hash_value, (void**)&ret)) {
				switch (type) {
					case BP_VAR_R:
						zend_error(E_NOTICE, "Undefined offset: %s", Z_STRVAL(key->constant));
						/* no break */
					case BP_VAR_UNSET:
					case BP_VAR_IS: {
						TSRMLS_FETCH();
						ret = &EG(uninitialized_zval_ptr);
						break;
					}

					case BP_VAR_RW:
						zend_error(E_NOTICE, "Undefined offset: %s", Z_STRVAL(key->constant));
						/* no break */
					case BP_VAR_W: {
						zval *value;
						ALLOC_INIT_ZVAL(value);
						zend_hash_quick_update(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1, key->hash_value, (void**)&value, sizeof(void*), (void**)&ret);
						break;
					}
				}
			}

			return ret;

		default: {
			TSRMLS_FETCH();
			zend_error(E_WARNING, "Illegal offset type");
			return (type == BP_VAR_W || type == BP_VAR_RW) ? &EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);
		}
	}
}

static int phalcon_hash_quick_update_or_insert(HashTable *ht, zval *value, const zend_literal *key)
{
	if (Z_TYPE(key->constant) == IS_NULL) {
		return zend_hash_next_index_insert(ht, (void**)&value, sizeof(zval*), NULL);
	}

	switch (Z_TYPE(key->constant)) {
		case IS_STRING:
			if (*(Z_STRVAL(key->constant)) >= '0' && *(Z_STRVAL(key->constant)) <= '9') {
				return zend_symtable_update(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1, (void**)&value, sizeof(zval*), NULL);
			}

			return zend_hash_quick_update(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1, key->hash_value, (void**)&value, sizeof(zval*), NULL);

		case IS_RESOURCE:
		case IS_DOUBLE:
		case IS_BOOL:
		case IS_LONG:
			return zend_hash_index_update(ht, ((Z_TYPE(key->constant) == IS_DOUBLE) ? (ulong)Z_DVAL(key->constant) : (ulong)Z_LVAL(key->constant)), (void*)&value, sizeof(zval*), NULL);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return FAILURE;
	}
}

static int phalcon_hash_fast_unset(HashTable *ht, const zend_literal *key)
{
	switch (Z_TYPE(key->constant)) {
		case IS_LONG:
		case IS_DOUBLE:
		case IS_BOOL:
		case IS_RESOURCE:
			return (zend_hash_index_del(ht, (Z_TYPE(key->constant) == IS_DOUBLE) ? ((ulong)Z_DVAL(key->constant)) : (ulong)Z_LVAL(key->constant)) == SUCCESS);

		case IS_STRING:
			if (*(Z_STRVAL(key->constant)) >= '0' && *(Z_STRVAL(key->constant)) <= '9') {
				return (zend_symtable_del(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1) == SUCCESS);
			}

			return (zend_hash_quick_del(ht, Z_STRVAL(key->constant), Z_STRLEN(key->constant)+1, key->hash_value) == SUCCESS);

		default:
			zend_error(E_WARNING, "Illegal offset type");
			return 0;
	}
}

#endif






static int phalcon_get_class_constant(zval *return_value, const zend_class_entry *ce, const char *constant_name, zend_uint constant_length TSRMLS_DC) {

	zval **result_ptr;

	if (phalcon_hash_find(&ce->constants_table, constant_name, constant_length, (void **) &result_ptr) != SUCCESS) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Undefined class constant '%s::%s'", ce->name, constant_name);
		return FAILURE;
	}

	ZVAL_ZVAL(return_value, *result_ptr, 1, 0);
	return SUCCESS;
}

static int phalcon_update_static_property_array_multi_ce(zend_class_entry *ce, const char *property, zend_uint property_length, zval *value TSRMLS_DC, const char *types, int types_length, int types_count, ...) {

	int i, l, ll; char *s;
	va_list ap;
	zval *fetched, *tmp_arr, *tmp, *p, *item;
	int separated = 0;

	phalcon_read_static_property_ce(&tmp_arr, ce, property, property_length TSRMLS_CC);

	Z_DELREF_P(tmp_arr);

	/** Separation only when refcount > 1 */
	if (Z_REFCOUNT_P(tmp_arr) > 1) {
		zval *new_zv;
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, tmp_arr);
		tmp_arr = new_zv;
		zval_copy_ctor(new_zv);
		Z_SET_REFCOUNT_P(tmp_arr, 0);
		separated = 1;
	}

	/** Convert the value to array if not is an array */
	if (Z_TYPE_P(tmp_arr) != IS_ARRAY) {
		if (separated) {
			convert_to_array(tmp_arr);
		} else {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp_arr);
			tmp_arr = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp_arr, 0);
			array_init(tmp_arr);
			separated = 1;
		}
	}

	va_start(ap, types_count);

	p = tmp_arr;
	for (i = 0; i < types_length; ++i) {
		switch (types[i]) {

			case 's':
				s = va_arg(ap, char*);
				l = va_arg(ap, int);
				if (phalcon_array_isset_string_fetch(&fetched, p, s, l + 1)) {
					if (Z_TYPE_P(fetched) == IS_ARRAY) {
						if (i == (types_length - 1)) {
							phalcon_array_update_string(&fetched, s, l, value, PH_COPY | PH_SEPARATE);
						} else {
							p = fetched;
						}
						continue;
					}
				}
				if (i == (types_length - 1)) {
					phalcon_array_update_string(&p, s, l, value, PH_COPY | PH_SEPARATE);
				} else {
					MAKE_STD_ZVAL(tmp);
					array_init(tmp);
					phalcon_array_update_string(&p, s, l, tmp, PH_SEPARATE);
					p = tmp;
				}
				break;

			case 'l':
				ll = va_arg(ap, long);
				if (phalcon_array_isset_long_fetch(&fetched, p, ll)) {
					if (Z_TYPE_P(fetched) == IS_ARRAY) {
						if (i == (types_length - 1)) {
							phalcon_array_update_long(&fetched, ll, value, PH_COPY | PH_SEPARATE);
						} else {
							p = fetched;
						}
						continue;
					}
				}
				if (i == (types_length - 1)) {
					phalcon_array_update_long(&p, ll, value, PH_COPY | PH_SEPARATE);
				} else {
					MAKE_STD_ZVAL(tmp);
					array_init(tmp);
					phalcon_array_update_long(&p, ll, tmp, PH_SEPARATE);
					p = tmp;
				}
				break;

			case 'z':
				item = va_arg(ap, zval*);
				if (phalcon_array_isset_fetch(&fetched, p, item)) {
					if (Z_TYPE_P(fetched) == IS_ARRAY) {
						if (i == (types_length - 1)) {
							phalcon_array_update_zval(&fetched, item, value, PH_COPY | PH_SEPARATE);
						} else {
							p = fetched;
						}
						continue;
					}
				}
				if (i == (types_length - 1)) {
					phalcon_array_update_zval(&p, item, value, PH_COPY | PH_SEPARATE);
				} else {
					MAKE_STD_ZVAL(tmp);
					array_init(tmp);
					phalcon_array_update_zval(&p, item, tmp, PH_SEPARATE);
					p = tmp;
				}
				break;

			case 'a':
				phalcon_array_append(&p, value, PH_SEPARATE);
				break;
		}
	}

	va_end(ap);

	if (separated) {
		phalcon_update_static_property_ce(ce, property, property_length, tmp_arr TSRMLS_CC);
	}

	return SUCCESS;
}

static void phalcon_get_class(zval *result, const zval *object, int lower TSRMLS_DC) {

	if (Z_TYPE_P(object) == IS_OBJECT) {
		const zend_class_entry *ce = Z_OBJCE_P(object);
		ZVAL_STRINGL(result, ce->name, ce->name_length, !IS_INTERNED(ce->name) || lower);

		if (lower) {
			zend_str_tolower(Z_STRVAL_P(result), Z_STRLEN_P(result));
		}

	} else {
		ZVAL_NULL(result);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "phalcon_get_class expects an object");
	}
}

static void phalcon_get_class_ns(zval *result, const zval *object, int lower TSRMLS_DC) {

	int found = 0;
	zend_class_entry *ce;
	zend_uint i, class_length;
	const char *cursor, *class_name;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		if (Z_TYPE_P(object) != IS_STRING) {
			ZVAL_NULL(result);
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "phalcon_get_class_ns expects an object");
			return;
		}
	}

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
		class_name = ce->name;
		class_length = ce->name_length;
	} else {
		class_name = Z_STRVAL_P(object);
		class_length = Z_STRLEN_P(object);
	}

	if (!class_length) {
		ZVAL_NULL(result);
		return;
	}

	i = class_length;
	cursor = (char *) (class_name + class_length - 1);

	while (i > 0) {
		if ((*cursor) == '\\') {
			found = 1;
			break;
		}
		cursor--;
		i--;
	}

	if (found) {
		Z_STRLEN_P(result) = class_length - i;
		Z_STRVAL_P(result) = (char *) emalloc(class_length - i + 1);
		memcpy(Z_STRVAL_P(result), class_name + i, class_length - i);
		Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
		Z_TYPE_P(result) = IS_STRING;
	} else {
		ZVAL_STRINGL(result, class_name, class_length, 1);
	}

	if (lower) {
		zend_str_tolower(Z_STRVAL_P(result), Z_STRLEN_P(result));
	}

}

static void phalcon_get_ns_class(zval *result, const zval *object, int lower TSRMLS_DC) {

	zend_class_entry *ce;
	int found = 0;
	zend_uint i, j, class_length;
	const char *cursor, *class_name;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		if (Z_TYPE_P(object) != IS_STRING) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "phalcon_get_ns_class expects an object");
			ZVAL_NULL(result);
			return;
		}
	}

	if (Z_TYPE_P(object) == IS_OBJECT) {
		ce = Z_OBJCE_P(object);
		class_name = ce->name;
		class_length = ce->name_length;
	} else {
		class_name = Z_STRVAL_P(object);
		class_length = Z_STRLEN_P(object);
	}

	if (!class_length) {
		ZVAL_NULL(result);
		return;
	}

	j = 0;
	i = class_length;
	cursor = (char *) (class_name + class_length - 1);

	while (i > 0) {
		if ((*cursor) == '\\') {
			found = 1;
			break;
		}
		cursor--;
		i--;
		j++;
	}

	if (j > 0) {

		if (found) {
			Z_STRLEN_P(result) = class_length - j - 1;
			Z_STRVAL_P(result) = (char *) emalloc(class_length - j);
			memcpy(Z_STRVAL_P(result), class_name, class_length - j - 1);
			Z_STRVAL_P(result)[Z_STRLEN_P(result)] = 0;
			Z_TYPE_P(result) = IS_STRING;
		} else {
			ZVAL_EMPTY_STRING(result);
		}

		if (lower) {
			zend_str_tolower(Z_STRVAL_P(result), Z_STRLEN_P(result));
		}
	} else {
		ZVAL_NULL(result);
	}

}

static void phalcon_get_called_class(zval *return_value TSRMLS_DC)
{
	zend_class_entry *called_scope = EG(called_scope);
	if (called_scope) {
		RETURN_STRINGL(called_scope->name, called_scope->name_length, !IS_INTERNED(called_scope->name));
	}

	if (!EG(scope))  {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "phalcon_get_called_class() called from outside a class");
	}

}

zend_class_entry *phalcon_fetch_class(const zval *class_name TSRMLS_DC) {

	if (Z_TYPE_P(class_name) == IS_STRING) {
		return zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, "class name must be a string");
	return zend_fetch_class("stdclass", strlen("stdclass"), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
}

zend_class_entry* phalcon_fetch_self_class(TSRMLS_D) {
	return zend_fetch_class(NULL, 0, ZEND_FETCH_CLASS_SELF TSRMLS_CC);
}

zend_class_entry* phalcon_fetch_parent_class(TSRMLS_D) {
	return zend_fetch_class(NULL, 0, ZEND_FETCH_CLASS_PARENT TSRMLS_CC);
}

zend_class_entry* phalcon_fetch_static_class(TSRMLS_D) {
	return zend_fetch_class(NULL, 0, ZEND_FETCH_CLASS_STATIC TSRMLS_CC);
}

static int phalcon_class_exists(const char *class_name, zend_uint class_len, int autoload TSRMLS_DC) {

	zend_class_entry **ce;

	if (zend_lookup_class(class_name, class_len, &ce TSRMLS_CC) == SUCCESS) {
#if PHP_VERSION_ID < 50400
		return (((*ce)->ce_flags & ZEND_ACC_INTERFACE) == 0);
#else
		return ((*ce)->ce_flags & (ZEND_ACC_INTERFACE | (ZEND_ACC_TRAIT - ZEND_ACC_EXPLICIT_ABSTRACT_CLASS))) == 0;
#endif
	}

	return 0;
}

static int phalcon_class_exists_ex(zend_class_entry **zce, const zval *class_name, int autoload TSRMLS_DC) {

	zend_class_entry **ce;

	if (Z_TYPE_P(class_name) == IS_STRING) {
		if (zend_lookup_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), &ce TSRMLS_CC) == SUCCESS) {
			*zce = *ce;
#if PHP_VERSION_ID < 50400
			return (((*ce)->ce_flags & ZEND_ACC_INTERFACE) == 0);
#else
			return ((*ce)->ce_flags & (ZEND_ACC_INTERFACE | (ZEND_ACC_TRAIT - ZEND_ACC_EXPLICIT_ABSTRACT_CLASS))) == 0;
#endif
		}
		return 0;
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, "class name must be a string");
	return 0;
}

static int phalcon_clone(zval *destination, zval *obj TSRMLS_DC) {

	int status = SUCCESS;
	zend_class_entry *ce;
	zend_object_clone_obj_t clone_call;

	if (Z_TYPE_P(obj) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_ERROR, "__clone method called on non-object");
		status = FAILURE;
	} else {
		ce = Z_OBJCE_P(obj);
		clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
		if (!clone_call) {
			if (ce) {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name);
			} else {
				php_error_docref(NULL TSRMLS_CC, E_ERROR, "Trying to clone an uncloneable object");
			}
			status = FAILURE;
		} else {
			if (!EG(exception)) {
				Z_OBJVAL_P(destination) = clone_call(obj TSRMLS_CC);
				Z_TYPE_P(destination) = IS_OBJECT;
				Z_SET_REFCOUNT_P(destination, 1);
				Z_UNSET_ISREF_P(destination);
				if (EG(exception)) {
					zval_dtor(destination);
					ZVAL_NULL(destination);
				}
			}
		}
	}

	return status;
}

static int phalcon_isset_property_quick(zval *object, const char *property_name, zend_uint property_length, ulong hash TSRMLS_DC)
{
	if (Z_TYPE_P(object) == IS_OBJECT) {
		if (likely(phalcon_hash_quick_exists(&Z_OBJCE_P(object)->properties_info, property_name, property_length, hash))) {
			return 1;
		}

		return phalcon_hash_quick_exists(Z_OBJ_HT_P(object)->get_properties(object TSRMLS_CC), property_name, property_length, hash);
	}

	return 0;
}

static inline zend_class_entry *phalcon_lookup_class_ce_quick(zend_class_entry *ce, const char *property_name, zend_uint property_length, ulong hash TSRMLS_DC) {

	zend_class_entry *original_ce = ce;

	while (ce) {
		if (phalcon_hash_quick_exists(&ce->properties_info, property_name, property_length + 1, hash)) {
			return ce;
		}
		ce = ce->parent;
	}
	return original_ce;
}

static inline zend_class_entry *phalcon_lookup_class_ce(zend_class_entry *ce, const char *property_name, zend_uint property_length TSRMLS_DC) {

	return phalcon_lookup_class_ce_quick(ce, property_name, property_length, zend_inline_hash_func(property_name, property_length + 1) TSRMLS_CC);
}

static int phalcon_read_property(zval **result, zval *object, const char *property_name, zend_uint property_length, int silent TSRMLS_DC) {

	zval *property;
	zend_class_entry *ce, *old_scope;

	if (Z_TYPE_P(object) != IS_OBJECT) {

		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
		}

		ALLOC_INIT_ZVAL(*result);
		return FAILURE;
	}

	ce = Z_OBJCE_P(object);
	if (ce->parent) {
		ce = phalcon_lookup_class_ce(ce, property_name, property_length TSRMLS_CC);
	}

	old_scope = EG(scope);
	EG(scope) = ce;

	if (!Z_OBJ_HT_P(object)->read_property) {
#if PHP_VERSION_ID < 50400
		char *class_name;
#else
		const char *class_name;
#endif
		zend_uint class_name_len;

		zend_get_object_classname(object, &class_name, &class_name_len TSRMLS_CC);
		zend_error(E_CORE_ERROR, "Property %s of class %s cannot be read", property_name, class_name);
	}

	MAKE_STD_ZVAL(property);
	ZVAL_STRINGL(property, property_name, property_length, 0);

#if PHP_VERSION_ID < 50400
	*result = Z_OBJ_HT_P(object)->read_property(object, property, silent ? BP_VAR_IS : BP_VAR_R TSRMLS_CC);
#else
	*result = Z_OBJ_HT_P(object)->read_property(object, property, silent ? BP_VAR_IS : BP_VAR_R, 0 TSRMLS_CC);
#endif

	Z_ADDREF_PP(result);

	if (Z_REFCOUNT_P(property) > 1) {
		ZVAL_STRINGL(property, property_name, property_length, 1);
	} else {
		ZVAL_NULL(property);
	}

	zval_ptr_dtor(&property);

	EG(scope) = old_scope;
	return SUCCESS;
}

zval* phalcon_fetch_property_this_quick(zval *object, const char *property_name, zend_uint property_length, ulong key, int silent TSRMLS_DC) {

	zval **zv = NULL;
	zend_object *zobj;
	zend_property_info *property_info;
	zend_class_entry *ce, *old_scope;

	if (likely(Z_TYPE_P(object) == IS_OBJECT)) {

		ce = Z_OBJCE_P(object);
		if (ce->parent) {
			ce = phalcon_lookup_class_ce_quick(ce, property_name, property_length, key TSRMLS_CC);
		}

		old_scope = EG(scope);
		EG(scope) = ce;

		zobj = zend_objects_get_address(object TSRMLS_CC);

		if (phalcon_hash_quick_find(&ce->properties_info, property_name, property_length + 1, key, (void **) &property_info) == SUCCESS) {

			#if PHP_VERSION_ID < 50400

			if (phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length + 1, property_info->h, (void **) &zv) == SUCCESS) {
				EG(scope) = old_scope;
				return *zv;
			}

			#else

			int flag;
			if (EXPECTED((property_info->flags & ZEND_ACC_STATIC) == 0) && property_info->offset >= 0) {
				if (zobj->properties) {
					zv   = (zval**) zobj->properties_table[property_info->offset];
					flag = (zv == NULL) ? 1 : 0;
				} else {
					zv   = &zobj->properties_table[property_info->offset];
					flag = (*zv == NULL) ? 1 : 0;
				}
			} else if (UNEXPECTED(!zobj->properties)) {
				flag = 1;
			} else if (UNEXPECTED(phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length+1, property_info->h, (void **) &zv) == FAILURE)) {
				flag = 2;
			} else {
				flag = 0;
			}

			if (unlikely(flag) && zobj->properties) {
				if (
					(flag == 2 || phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length+1, property_info->h, (void **) &zv) == FAILURE)
					&& zv && *zv
				) {
					flag = 0;
				}
			}

			if (likely(!flag)) {
				EG(scope) = old_scope;
				return *zv;
			}

			#endif

		}

		EG(scope) = old_scope;

	} else {
		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
		}
	}

	return NULL;
}

static int phalcon_return_property_quick(zval *return_value, zval **return_value_ptr, zval *object, const char *property_name, zend_uint property_length, ulong key TSRMLS_DC) {

	zval **zv;
	zend_object *zobj;
	zend_property_info *property_info;
	zend_class_entry *ce, *old_scope;

	if (likely(Z_TYPE_P(object) == IS_OBJECT)) {

		ce = Z_OBJCE_P(object);
		if (ce->parent) {
			ce = phalcon_lookup_class_ce_quick(ce, property_name, property_length, key TSRMLS_CC);
		}

		old_scope = EG(scope);
		EG(scope) = ce;

		zobj = zend_objects_get_address(object TSRMLS_CC);

		if (phalcon_hash_quick_find(&ce->properties_info, property_name, property_length + 1, key, (void **) &property_info) == SUCCESS) {

			#if PHP_VERSION_ID < 50400

			if (phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length+1, property_info->h, (void **) &zv) == SUCCESS) {

				EG(scope) = old_scope;

				if (return_value_ptr) {
					zval_ptr_dtor(return_value_ptr);
					Z_ADDREF_PP(zv);
					*return_value_ptr = *zv;
				}
				else {
					ZVAL_ZVAL(return_value, *zv, 1, 0);
				}

				return SUCCESS;
			}

			#else

			int flag;
			if (EXPECTED((property_info->flags & ZEND_ACC_STATIC) == 0) && property_info->offset >= 0) {
				if (zobj->properties) {
					zv   = (zval**) zobj->properties_table[property_info->offset];
					flag = (zv == NULL) ? 1 : 0;
				} else {
					zv   = &zobj->properties_table[property_info->offset];
					flag = (*zv == NULL) ? 1 : 0;
				}
			} else if (UNEXPECTED(!zobj->properties)) {
				flag = 1;
			} else if (UNEXPECTED(phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length+1, property_info->h, (void **) &zv) == FAILURE)) {
				flag = 2;
			} else {
				flag = 0;
			}

			if (unlikely(flag) && zobj->properties) {
				if (
					(flag == 2 || phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length+1, property_info->h, (void **) &zv) == FAILURE)
					&& zv && *zv
				) {
					flag = 0;
				}
			}

			if (likely(!flag)) {
				EG(scope) = old_scope;

				if (return_value_ptr) {
					zval_ptr_dtor(return_value_ptr);
					Z_ADDREF_PP(zv);
					*return_value_ptr = *zv;
				}
				else {
					ZVAL_ZVAL(return_value, *zv, 1, 0);
				}

				return SUCCESS;
			}

			#endif

		}

		EG(scope) = old_scope;

	} else {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Trying to get property of non-object");
	}

	ZVAL_NULL(return_value);
	return FAILURE;
}

static int phalcon_read_property_zval(zval **result, zval *object, const zval *property, int silent TSRMLS_DC) {

	if (unlikely(Z_TYPE_P(property) != IS_STRING)) {

		if (silent == PH_NOISY) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Cannot access empty property %d", Z_TYPE_P(property));
		}

		ALLOC_INIT_ZVAL(*result);
		return FAILURE;
	}

	return phalcon_read_property(result, object, Z_STRVAL_P(property), Z_STRLEN_P(property), silent TSRMLS_CC);
}

static int phalcon_update_property_long(zval *object, const char *property_name, zend_uint property_length, long value TSRMLS_DC) {

	zval *v;

	PHALCON_ALLOC_GHOST_ZVAL(v);
	ZVAL_LONG(v, value);

	return phalcon_update_property_zval(object, property_name, property_length, v TSRMLS_CC);
}

static int phalcon_update_property_string(zval *object, const char *property_name, zend_uint property_length, const char *str, zend_uint str_length TSRMLS_DC)
{
	zval *value;

	PHALCON_ALLOC_GHOST_ZVAL(value);
	ZVAL_STRINGL(value, str, str_length, 1);

	return phalcon_update_property_zval(object, property_name, property_length, value TSRMLS_CC);
}

static int phalcon_update_property_bool(zval *object, const char *property_name, zend_uint property_length, int value TSRMLS_DC) {

	zval *v = value ? PHALCON_GLOBAL(z_true) : PHALCON_GLOBAL(z_false);
	return phalcon_update_property_zval(object, property_name, property_length, v TSRMLS_CC);
}

static int phalcon_update_property_null(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC) {

	zval *v = PHALCON_GLOBAL(z_null);
	return phalcon_update_property_zval(object, property_name, property_length, v TSRMLS_CC);
}

static int phalcon_update_property_zval(zval *object, const char *property_name, zend_uint property_length, zval *value TSRMLS_DC){

	zend_class_entry *ce, *old_scope;
	zval *property;

	old_scope = EG(scope);
	if (Z_TYPE_P(object) != IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = Z_OBJCE_P(object);
	if (ce->parent) {
		ce = phalcon_lookup_class_ce(ce, property_name, property_length TSRMLS_CC);
	}

	EG(scope) = ce;

	if (!Z_OBJ_HT_P(object)->write_property) {
#if PHP_VERSION_ID < 50400
		char *class_name;
#else
		const char *class_name;
#endif
		zend_uint class_name_len;

		zend_get_object_classname(object, &class_name, &class_name_len TSRMLS_CC);
		zend_error(E_CORE_ERROR, "Property %s of class %s cannot be updated", property_name, class_name);
	}

	MAKE_STD_ZVAL(property);
	ZVAL_STRINGL(property, property_name, property_length, 0);

#if PHP_VERSION_ID < 50400
	Z_OBJ_HT_P(object)->write_property(object, property, value TSRMLS_CC);
#else
	Z_OBJ_HT_P(object)->write_property(object, property, value, 0 TSRMLS_CC);
#endif

	if (Z_REFCOUNT_P(property) > 1) {
		ZVAL_STRINGL(property, property_name, property_length, 1);
	} else {
		ZVAL_NULL(property);
	}

	zval_ptr_dtor(&property);

	EG(scope) = old_scope;
	return SUCCESS;
}

static int phalcon_update_property_this_quick(zval *object, const char *property_name, zend_uint property_length, zval *value, ulong key TSRMLS_DC){

	zend_class_entry *ce, *old_scope;

	if (unlikely(Z_TYPE_P(object) != IS_OBJECT)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	ce = Z_OBJCE_P(object);
	if (ce->parent) {
		ce = phalcon_lookup_class_ce_quick(ce, property_name, property_length, key TSRMLS_CC);
	}

	old_scope = EG(scope);
	EG(scope) = ce;

	#if PHP_VERSION_ID < 50400

	{
		zval *property;

		if (!Z_OBJ_HT_P(object)->write_property) {
			EG(scope) = old_scope;
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Property %s of class %s cannot be updated", property_name, ce->name);
			return FAILURE;
		}

		MAKE_STD_ZVAL(property);
		ZVAL_STRINGL(property, property_name, property_length, 0);

		Z_OBJ_HT_P(object)->write_property(object, property, value TSRMLS_CC);

		if (Z_REFCOUNT_P(property) > 1) {
			ZVAL_STRINGL(property, property_name, property_length, 1);
		} else {
			ZVAL_NULL(property);
		}

		zval_ptr_dtor(&property);
	}

	#else

	{
		zend_object *zobj;
		zval **variable_ptr;
		zend_property_info *property_info;

		zobj = zend_objects_get_address(object TSRMLS_CC);

		if (phalcon_hash_quick_find(&ce->properties_info, property_name, property_length + 1, key, (void **) &property_info) == SUCCESS) {
			assert(property_info != NULL);

			/** This is as zend_std_write_property, but we're not interesed in validate properties visibility */
			if (property_info->offset >= 0 ? (zobj->properties ? ((variable_ptr = (zval**) zobj->properties_table[property_info->offset]) != NULL) : (*(variable_ptr = &zobj->properties_table[property_info->offset]) != NULL)) : (EXPECTED(zobj->properties != NULL) && EXPECTED(phalcon_hash_quick_find(zobj->properties, property_info->name, property_info->name_length + 1, property_info->h, (void **) &variable_ptr) == SUCCESS))) {

				if (EXPECTED(*variable_ptr != value)) {

					/* if we are assigning reference, we shouldn't move it, but instead assign variable to the same pointer */
					if (PZVAL_IS_REF(*variable_ptr)) {

						zval garbage = **variable_ptr; /* old value should be destroyed */

						/* To check: can't *variable_ptr be some system variable like error_zval here? */
						Z_TYPE_PP(variable_ptr) = Z_TYPE_P(value);
						(*variable_ptr)->value = value->value;
						if (Z_REFCOUNT_P(value) > 0) {
							zval_copy_ctor(*variable_ptr);
						} else {
							efree(value);
						}
						zval_dtor(&garbage);

					} else {
						zval *garbage = *variable_ptr;

						/* if we assign referenced variable, we should separate it */
						Z_ADDREF_P(value);
						if (PZVAL_IS_REF(value)) {
							SEPARATE_ZVAL(&value);
						}
						*variable_ptr = value;
						zval_ptr_dtor(&garbage);
					}
				}

			}
		}
	}

	#endif

	EG(scope) = old_scope;

	return SUCCESS;
}

static int phalcon_update_property_zval_zval(zval *object, const zval *property, zval *value TSRMLS_DC){

	if (Z_TYPE_P(property) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Property should be string");
		return FAILURE;
	}

	return phalcon_update_property_zval(object, Z_STRVAL_P(property), Z_STRLEN_P(property), value TSRMLS_CC);
}

static int phalcon_update_property_array(zval *object, const char *property, zend_uint property_length, const zval *index, zval *value TSRMLS_DC) {

	zval *tmp;
	int separated = 0;

	if (Z_TYPE_P(object) == IS_OBJECT) {

		phalcon_read_property(&tmp, object, property, property_length, PH_NOISY TSRMLS_CC);

		Z_DELREF_P(tmp);

		/** Separation only when refcount > 1 */
		if (Z_REFCOUNT_P(tmp) > 1) {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			separated = 1;
		}

		/** Convert the value to array if not is an array */
		if (Z_TYPE_P(tmp) != IS_ARRAY) {
			if (separated) {
				convert_to_array(tmp);
			} else {
				zval *new_zv;
				ALLOC_ZVAL(new_zv);
				INIT_PZVAL_COPY(new_zv, tmp);
				tmp = new_zv;
				zval_copy_ctor(new_zv);
				Z_SET_REFCOUNT_P(tmp, 0);
				array_init(tmp);
				separated = 1;
			}
		}

		Z_ADDREF_P(value);

		if (Z_TYPE_P(index) == IS_STRING) {
			zend_symtable_update(Z_ARRVAL_P(tmp), Z_STRVAL_P(index), Z_STRLEN_P(index) + 1, &value, sizeof(zval*), NULL);
		} else if (Z_TYPE_P(index) == IS_LONG) {
			zend_hash_index_update(Z_ARRVAL_P(tmp), Z_LVAL_P(index), &value, sizeof(zval *), NULL);
		} else if (Z_TYPE_P(index) == IS_NULL) {
			zend_hash_next_index_insert(Z_ARRVAL_P(tmp), (void**)&value, sizeof(zval*), NULL);
		}

		if (separated) {
			phalcon_update_property_zval(object, property, property_length, tmp TSRMLS_CC);
		}
	}

	return SUCCESS;
}

static int phalcon_update_property_array_string(zval *object, const char *property, zend_uint property_length, const char *index, zend_uint index_length, zval *value TSRMLS_DC) {

	zval *tmp;
	int separated = 0;

	if (likely(Z_TYPE_P(object) == IS_OBJECT)) {

		phalcon_read_property(&tmp, object, property, property_length, PH_NOISY TSRMLS_CC);

		Z_DELREF_P(tmp);

		/** Separation only when refcount > 1 */
		if (Z_REFCOUNT_P(tmp) > 1) {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			separated = 1;
		}

		/** Convert the value to array if not is an array */
		if (Z_TYPE_P(tmp) != IS_ARRAY) {
			if (separated) {
				convert_to_array(tmp);
			} else {
				zval *new_zv;
				ALLOC_ZVAL(new_zv);
				INIT_PZVAL_COPY(new_zv, tmp);
				tmp = new_zv;
				zval_copy_ctor(new_zv);
				Z_SET_REFCOUNT_P(tmp, 0);
				array_init(tmp);
				separated = 1;
			}
		}

		Z_ADDREF_P(value);

		zend_hash_update(Z_ARRVAL_P(tmp), index, index_length, &value, sizeof(zval *), NULL);

		if (separated) {
			phalcon_update_property_zval(object, property, property_length, tmp TSRMLS_CC);
		}

	}

	return SUCCESS;
}

static int phalcon_update_property_array_append(zval *object, const char *property, zend_uint property_length, zval *value TSRMLS_DC) {

	zval *tmp;
	int separated = 0;

	if (Z_TYPE_P(object) != IS_OBJECT) {
		return SUCCESS;
	}

	phalcon_read_property(&tmp, object, property, property_length, PH_NOISY TSRMLS_CC);

	Z_DELREF_P(tmp);

	/** Separation only when refcount > 1 */
	if (Z_REFCOUNT_P(tmp) > 1) {
		zval *new_zv;
		ALLOC_ZVAL(new_zv);
		INIT_PZVAL_COPY(new_zv, tmp);
		tmp = new_zv;
		zval_copy_ctor(new_zv);
		Z_SET_REFCOUNT_P(tmp, 0);
		separated = 1;
	}

	/** Convert the value to array if not is an array */
	if (Z_TYPE_P(tmp) != IS_ARRAY) {
		if (separated) {
			convert_to_array(tmp);
		} else {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			array_init(tmp);
			separated = 1;
		}
	}

	Z_ADDREF_P(value);
	add_next_index_zval(tmp, value);

	if (separated) {
		phalcon_update_property_zval(object, property, property_length, tmp TSRMLS_CC);
	}

	return SUCCESS;
}

static int phalcon_update_property_empty_array(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC) {

	zval *empty_array;

	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);

	return phalcon_update_property_zval(object, property_name, property_length, empty_array TSRMLS_CC);
}

static int phalcon_unset_property_array(zval *object, const char *property, zend_uint property_length, const zval *index TSRMLS_DC) {

	zval *tmp;
	int separated = 0;

	if (Z_TYPE_P(object) == IS_OBJECT) {

		phalcon_read_property(&tmp, object, property, property_length, PH_NOISY TSRMLS_CC);
		Z_DELREF_P(tmp);

		/** Separation only when refcount > 1 */
		if (Z_REFCOUNT_P(tmp) > 1) {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			separated = 1;
		}

		phalcon_array_unset(&tmp, index, 0);

		if (separated) {
			phalcon_update_property_zval(object, property, property_length, tmp TSRMLS_CC);
		}
	}

	return SUCCESS;
}

static int phalcon_method_exists(const zval *object, const zval *method_name TSRMLS_DC){

	char *lcname = zend_str_tolower_dup(Z_STRVAL_P(method_name), Z_STRLEN_P(method_name));
	int res = phalcon_method_exists_ex(object, lcname, Z_STRLEN_P(method_name)+1 TSRMLS_CC);
	efree(lcname);
	return res;
}

static int phalcon_method_exists_ex(const zval *object, const char *method_name, zend_uint method_len TSRMLS_DC)
{
#ifdef __GNUC__
	if (__builtin_constant_p(method_name) && __builtin_constant_p(method_len)) {
		return phalcon_method_quick_exists_ex(object, method_name, method_len, zend_inline_hash_func(method_name, method_len) TSRMLS_CC);
	}
#endif

	return phalcon_method_quick_exists_ex(object, method_name, method_len, zend_hash_func(method_name, method_len) TSRMLS_CC);
}

static int phalcon_method_quick_exists_ex(const zval *object, const char *method_name, zend_uint method_len, ulong hash TSRMLS_DC){

	zend_class_entry *ce;

	if (likely(Z_TYPE_P(object) == IS_OBJECT)) {
		ce = Z_OBJCE_P(object);
	} else if (Z_TYPE_P(object) == IS_STRING) {
		ce = zend_fetch_class(Z_STRVAL_P(object), Z_STRLEN_P(object), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	} else {
		return FAILURE;
	}

	return (ce && phalcon_hash_quick_exists(&ce->function_table, method_name, method_len, hash)) ? SUCCESS : FAILURE;
}

static int phalcon_read_static_property(zval **result, const char *class_name, zend_uint class_length, const char *property_name, zend_uint property_length TSRMLS_DC){
	zend_class_entry **ce;
	if (zend_lookup_class(class_name, class_length, &ce TSRMLS_CC) == SUCCESS) {
		return phalcon_read_static_property_ce(result, *ce, property_name, property_length TSRMLS_CC);
	}

	return FAILURE;
}

static int phalcon_read_class_property(zval **result, int type, const char *property, zend_uint len TSRMLS_DC) {
	zend_class_entry *ce;

	type |= (ZEND_FETCH_CLASS_SILENT | ZEND_FETCH_CLASS_NO_AUTOLOAD);
	type &= ZEND_FETCH_CLASS_MASK;
	ce    = zend_fetch_class(NULL, 0, type TSRMLS_CC);

	if (likely(ce != NULL)) {
		return phalcon_read_static_property_ce(result, ce, property, len TSRMLS_CC);
	}

	return FAILURE;
}

static int phalcon_create_instance_params_ce(zval *return_value, zend_class_entry *ce, zval *params TSRMLS_DC)
{
	int outcome = SUCCESS;

	object_init_ex(return_value, ce);

	if (phalcon_has_constructor_ce(ce)) {
		int param_count = (Z_TYPE_P(params) == IS_ARRAY) ? zend_hash_num_elements(Z_ARRVAL_P(params)) : 0;
		zval *static_params[10];
		zval **params_ptr, **params_arr = NULL;

		if (param_count > 0) {
			HashPosition pos;
			zval **item;
			int i = 0;

			if (likely(param_count) <= 10) {
				params_ptr = static_params;
			}
			else {
				params_arr = emalloc(param_count * sizeof(zval*));
				params_ptr = &params;
			}

			for (
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(params), &pos);
				zend_hash_get_current_data_ex(Z_ARRVAL_P(params), (void**)&item, &pos) == SUCCESS;
				zend_hash_move_forward_ex(Z_ARRVAL_P(params), &pos), ++i
			) {
				params_ptr[i] = *item;
			}
		}
		else {
			params_ptr = NULL;
		}

		outcome = phalcon_call_method(NULL, return_value, "__construct", param_count, params_ptr TSRMLS_CC);

		if (unlikely(params_arr != NULL)) {
			efree(params_arr);
		}
	}

	return outcome;
}

static int phalcon_create_instance(zval *return_value, const zval *class_name TSRMLS_DC){

	zend_class_entry *ce;

	if (unlikely(Z_TYPE_P(class_name) != IS_STRING)) {
		phalcon_throw_exception_string(phalcon_exception_ce, "Invalid class name" TSRMLS_CC);
		return FAILURE;
	}

	ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	if (!ce) {
		return FAILURE;
	}

	return phalcon_create_instance_params_ce(return_value, ce, PHALCON_GLOBAL(z_null) TSRMLS_CC);
}

static int phalcon_create_instance_params(zval *return_value, const zval *class_name, zval *params TSRMLS_DC){

	zend_class_entry *ce;

	if (unlikely(Z_TYPE_P(class_name) != IS_STRING)) {
		phalcon_throw_exception_string(phalcon_exception_ce, "Invalid class name" TSRMLS_CC);
		return FAILURE;
	}

	ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_DEFAULT TSRMLS_CC);
	if (!ce) {
		return FAILURE;
	}

	return phalcon_create_instance_params_ce(return_value, ce, params TSRMLS_CC);
}

static int phalcon_property_incr(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC){

	zval *tmp = NULL;
	int separated = 0;

	if (unlikely(Z_TYPE_P(object) != IS_OBJECT)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	phalcon_read_property(&tmp, object, property_name, property_length, 0 TSRMLS_CC);
	if (tmp) {

		Z_DELREF_P(tmp);

		/** Separation only when refcount > 1 */
		if (Z_REFCOUNT_P(tmp) > 1) {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			separated = 1;
		}

		phalcon_increment(tmp);

		if (separated) {
			phalcon_update_property_zval(object, property_name, property_length, tmp TSRMLS_CC);
		}
	}

	return SUCCESS;
}

static int phalcon_property_decr(zval *object, const char *property_name, zend_uint property_length TSRMLS_DC){

	zval *tmp = NULL;
	int separated = 0;

	if (unlikely(Z_TYPE_P(object) != IS_OBJECT)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to assign property of non-object");
		return FAILURE;
	}

	phalcon_read_property(&tmp, object, property_name, property_length, 0 TSRMLS_CC);
	if (tmp) {

		Z_DELREF_P(tmp);

		/** Separation only when refcount > 1 */
		if (Z_REFCOUNT_P(tmp) > 1) {
			zval *new_zv;
			ALLOC_ZVAL(new_zv);
			INIT_PZVAL_COPY(new_zv, tmp);
			tmp = new_zv;
			zval_copy_ctor(new_zv);
			Z_SET_REFCOUNT_P(tmp, 0);
			separated = 1;
		}

		phalcon_decrement(tmp);

		if (separated) {
			phalcon_update_property_zval(object, property_name, property_length, tmp TSRMLS_CC);
		}
	}

	return SUCCESS;
}

#if PHP_VERSION_ID < 50400

void object_properties_init(zend_object *object, zend_class_entry *class_type)
{
	zval *tmp;

	if (UNEXPECTED(!object->properties)) {
		ALLOC_HASHTABLE(object->properties);
		zend_hash_init(object->properties, zend_hash_num_elements(&class_type->default_properties), NULL, ZVAL_PTR_DTOR, 0);
	}

#if PHP_VERSION_ID < 50304
	zend_hash_copy(object->properties, &class_type->default_properties, (copy_ctor_func_t)zval_add_ref, (void*)&tmp, sizeof(zval*));
#else
	zend_hash_copy(object->properties, &class_type->default_properties, zval_copy_property_ctor(class_type), (void*)&tmp, sizeof(zval*));
#endif
}

#endif





#include <ctype.h>
#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_string.h>
#include <ext/standard/php_rand.h>
#include <ext/standard/php_lcg.h>
#include <ext/standard/php_http.h>
#include <ext/standard/base64.h>
#include <ext/standard/md5.h>
#include <ext/standard/url.h>
#include <ext/standard/html.h>
#include <ext/date/php_date.h>

#ifdef PHALCON_USE_PHP_PCRE
#include <ext/pcre/php_pcre.h>
#endif

#ifdef PHALCON_USE_PHP_JSON
#include <ext/json/php_json.h>
#endif


#define PH_RANDOM_ALNUM 0
#define PH_RANDOM_ALPHA 1
#define PH_RANDOM_HEXDEC 2
#define PH_RANDOM_NUMERIC 3
#define PH_RANDOM_NOZERO 4

static void phalcon_fast_strlen(zval *return_value, zval *str){

	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	ZVAL_LONG(return_value, Z_STRLEN_P(str));

	if (use_copy) {
		zval_dtor(str);
	}
}

static void phalcon_fast_strtolower(zval *return_value, zval *str){

	zval copy;
	int use_copy = 0;
	char *lower_str;
	unsigned int length;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	length = Z_STRLEN_P(str);
	lower_str = estrndup(Z_STRVAL_P(str), length);
	php_strtolower(lower_str, length);

	if (use_copy) {
		zval_dtor(str);
	}

	ZVAL_STRINGL(return_value, lower_str, length, 0);
}

static void phalcon_strtolower_inplace(zval *s) {
	if (likely(Z_TYPE_P(s) == IS_STRING)) {
		php_strtolower(Z_STRVAL_P(s), Z_STRLEN_P(s));
	}
}

static void phalcon_fast_join(zval *result, zval *glue, zval *pieces TSRMLS_DC){

	if (Z_TYPE_P(glue) != IS_STRING || Z_TYPE_P(pieces) != IS_ARRAY) {
		ZVAL_NULL(result);
		zend_error(E_WARNING, "Invalid arguments supplied for join()");
		return;
	}

	php_implode(glue, pieces, result TSRMLS_CC);
}

static void phalcon_append_printable_zval(smart_str *implstr, zval **tmp TSRMLS_DC) {

	zval tmp_val;
	unsigned int str_len;

	switch (Z_TYPE_PP(tmp)) {
		case IS_STRING:
			smart_str_appendl(implstr, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));
			break;

		case IS_LONG:
			smart_str_append_long(implstr, Z_LVAL_PP(tmp));
			break;

		case IS_BOOL:
			if (Z_LVAL_PP(tmp) == 1) {
				smart_str_appendl(implstr, "1", sizeof("1") - 1);
			}
			break;

		case IS_NULL:
			break;

		case IS_DOUBLE: {
			char *stmp;
			str_len = spprintf(&stmp, 0, "%.*G", (int) EG(precision), Z_DVAL_PP(tmp));
			smart_str_appendl(implstr, stmp, str_len);
			efree(stmp);
		}
			break;

		case IS_OBJECT: {
			int copy;
			zval expr;
			zend_make_printable_zval(*tmp, &expr, &copy);
			smart_str_appendl(implstr, Z_STRVAL(expr), Z_STRLEN(expr));
			if (copy) {
				zval_dtor(&expr);
			}
		}
			break;

		default:
			tmp_val = **tmp;
			zval_copy_ctor(&tmp_val);
			convert_to_string(&tmp_val);
			smart_str_appendl(implstr, Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));
			zval_dtor(&tmp_val);
			break;
	}
}

static void phalcon_fast_join_str(zval *return_value, char *glue, unsigned int glue_length, zval *pieces TSRMLS_DC){

	zval         **tmp;
	HashTable      *arr;
	HashPosition   pos;
	smart_str      implstr = {0};
	unsigned int   numelems, i = 0;

	if (Z_TYPE_P(pieces) != IS_ARRAY) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for fast_join()");
		return;
	}

	arr = Z_ARRVAL_P(pieces);
	numelems = zend_hash_num_elements(arr);

	if (numelems == 0) {
		RETURN_EMPTY_STRING();
	}

	zend_hash_internal_pointer_reset_ex(arr, &pos);

	while (zend_hash_get_current_data_ex(arr, (void **) &tmp, &pos) == SUCCESS) {
		phalcon_append_printable_zval(&implstr, tmp TSRMLS_CC);
		if (++i != numelems) {
			smart_str_appendl(&implstr, glue, glue_length);
		}
		zend_hash_move_forward_ex(arr, &pos);
	}
	smart_str_0(&implstr);

	if (implstr.len) {
		RETURN_STRINGL(implstr.c, implstr.len, 0);
	} else {
		smart_str_free(&implstr);
		RETURN_EMPTY_STRING();
	}
}

static void phalcon_camelize(zval *return_value, const zval *str){

	int i, len;
	smart_str camelize_str = {0};
	char *marker, ch;

	if (unlikely(Z_TYPE_P(str) != IS_STRING)) {
		zend_error(E_WARNING, "Invalid arguments supplied for camelize()");
		RETURN_EMPTY_STRING();
		return;
	}

	marker = Z_STRVAL_P(str);
	len    = Z_STRLEN_P(str);

	for (i = 0; i < len; i++) {
		ch = *marker;
		if (i == 0 || ch == '-' || ch == '_') {
			if (ch == '-' || ch == '_') {
				i++;
				marker++;
			}

			smart_str_appendc(&camelize_str, toupper(*marker));
		}
		else {
			smart_str_appendc(&camelize_str, tolower(*marker));
		}

		marker++;
	}

	if (likely(i == len - 1)) {
		smart_str_appendc(&camelize_str, *marker);
	}

	smart_str_0(&camelize_str);

	if (camelize_str.c) {
		RETURN_STRINGL(camelize_str.c, camelize_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}

}

static void phalcon_uncamelize(zval *return_value, const zval *str){

	int i;
	smart_str uncamelize_str = {0};
	char *marker, ch;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_error(E_WARNING, "Invalid arguments supplied for camelize()");
		return;
	}

	marker = Z_STRVAL_P(str);
	for (i = 0; i < Z_STRLEN_P(str); i++) {
		ch = *marker;
		if (ch == '\0') {
			break;
		}
		if (ch >= 'A' && ch <= 'Z') {
			if (i > 0) {
				smart_str_appendc(&uncamelize_str, '_');
			}
			smart_str_appendc(&uncamelize_str, (*marker) + 32);
		} else {
			smart_str_appendc(&uncamelize_str, (*marker));
		}
		marker++;
	}
	smart_str_0(&uncamelize_str);

	if (uncamelize_str.c) {
		RETURN_STRINGL(uncamelize_str.c, uncamelize_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}
}

static void phalcon_fast_explode(zval *result, zval *delimiter, zval *str){

	if (unlikely(Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(delimiter) != IS_STRING)) {
		ZVAL_NULL(result);
		zend_error(E_WARNING, "Invalid arguments supplied for explode()");
		return;
	}

	array_init(result);
	php_explode(delimiter, str, result, LONG_MAX);
}

static void phalcon_fast_explode_str(zval *result, const char *delimiter, int delimiter_length, zval *str){

	zval delimiter_zval = zval_used_for_init;

	if (unlikely(Z_TYPE_P(str) != IS_STRING)) {
		ZVAL_NULL(result);
		zend_error(E_WARNING, "Invalid arguments supplied for explode()");
		return;
	}

	ZVAL_STRINGL(&delimiter_zval, delimiter, delimiter_length, 0);

	array_init(result);
	php_explode(&delimiter_zval, str, result, LONG_MAX);
}

static int phalcon_memnstr(const zval *haystack, const zval *needle) {

	if (Z_TYPE_P(haystack) != IS_STRING || Z_TYPE_P(needle) != IS_STRING) {
		zend_error(E_WARNING, "Invalid arguments supplied for memnstr()");
		return 0;
	}

	if (Z_STRLEN_P(haystack) >= Z_STRLEN_P(needle)) {
		return php_memnstr(Z_STRVAL_P(haystack), Z_STRVAL_P(needle), Z_STRLEN_P(needle), Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack)) ? 1 : 0;
	}

	return 0;
}

static int phalcon_memnstr_str(const zval *haystack, char *needle, unsigned int needle_length) {

	if (Z_TYPE_P(haystack) != IS_STRING) {
		zend_error(E_WARNING, "Invalid arguments supplied for memnstr()");
		return 0;
	}

	if ((uint)(Z_STRLEN_P(haystack)) >= needle_length) {
		return php_memnstr(Z_STRVAL_P(haystack), needle, needle_length, Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack)) ? 1 : 0;
	}

	return 0;
}

static void phalcon_fast_strpos(zval *return_value, const zval *haystack, const zval *needle) {

#if PHP_VERSION_ID >= 50600
	const
#endif
	char *found = NULL;

	if (unlikely(Z_TYPE_P(haystack) != IS_STRING || Z_TYPE_P(needle) != IS_STRING)) {
		ZVAL_NULL(return_value);
		zend_error(E_WARNING, "Invalid arguments supplied for strpos()");
		return;
	}

	if (!Z_STRLEN_P(needle)) {
		ZVAL_NULL(return_value);
		zend_error(E_WARNING, "Empty delimiter");
		return;
	}

	found = php_memnstr(Z_STRVAL_P(haystack), Z_STRVAL_P(needle), Z_STRLEN_P(needle), Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_FALSE(return_value);
	}

}

static void phalcon_fast_strpos_str(zval *return_value, const zval *haystack, char *needle, unsigned int needle_length) {

#if PHP_VERSION_ID >= 50600
	const
#endif
	char *found = NULL;

	if (unlikely(Z_TYPE_P(haystack) != IS_STRING)) {
		ZVAL_NULL(return_value);
		zend_error(E_WARNING, "Invalid arguments supplied for strpos()");
		return;
	}

	found = php_memnstr(Z_STRVAL_P(haystack), needle, needle_length, Z_STRVAL_P(haystack) + Z_STRLEN_P(haystack));

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_FALSE(return_value);
	}

}

static void phalcon_fast_stripos_str(zval *return_value, zval *haystack, char *needle, unsigned int needle_length) {

#if PHP_VERSION_ID >= 50600
	const
#endif
	char *found = NULL;
	char *needle_dup, *haystack_dup;

	if (unlikely(Z_TYPE_P(haystack) != IS_STRING)) {
		ZVAL_NULL(return_value);
		zend_error(E_WARNING, "Invalid arguments supplied for stripos()");
		return;
	}

	haystack_dup = estrndup(Z_STRVAL_P(haystack), Z_STRLEN_P(haystack));
	php_strtolower(haystack_dup, Z_STRLEN_P(haystack));

	needle_dup = estrndup(needle, needle_length);
	php_strtolower(needle_dup, needle_length);

	found = php_memnstr(haystack_dup, needle, needle_length, haystack_dup + Z_STRLEN_P(haystack));

	efree(haystack_dup);
	efree(needle_dup);

	if (found) {
		ZVAL_LONG(return_value, found-Z_STRVAL_P(haystack));
	} else {
		ZVAL_FALSE(return_value);
	}

}


static void phalcon_fast_str_replace(zval *return_value, zval *search, zval *replace, zval *subject) {

	zval replace_copy, search_copy;
	int copy_replace = 0, copy_search = 0;

	if (Z_TYPE_P(subject) != IS_STRING) {
		ZVAL_NULL(return_value);
		zend_error(E_WARNING, "Invalid arguments supplied for str_replace()");
		return;
	}

	if (Z_TYPE_P(replace) != IS_STRING) {
		zend_make_printable_zval(replace, &replace_copy, &copy_replace);
		if (copy_replace) {
			replace = &replace_copy;
		}
	}

	if (Z_TYPE_P(search) != IS_STRING) {
		zend_make_printable_zval(search, &search_copy, &copy_search);
		if (copy_search) {
			search = &search_copy;
		}
	}

	Z_TYPE_P(return_value) = IS_STRING;
	if (Z_STRLEN_P(subject) == 0) {
		ZVAL_STRINGL(return_value, "", 0, 1);
		return;
	}

	if (Z_STRLEN_P(search) == 1) {
		php_char_to_str_ex(Z_STRVAL_P(subject),
			Z_STRLEN_P(subject),
			Z_STRVAL_P(search)[0],
			Z_STRVAL_P(replace),
			Z_STRLEN_P(replace),
			return_value,
			1,
			NULL);
	} else {
		if (Z_STRLEN_P(search) > 1) {
			Z_STRVAL_P(return_value) = php_str_to_str_ex(Z_STRVAL_P(subject), Z_STRLEN_P(subject),
				Z_STRVAL_P(search), Z_STRLEN_P(search),
				Z_STRVAL_P(replace), Z_STRLEN_P(replace), &Z_STRLEN_P(return_value), 1, NULL);
		} else {
			MAKE_COPY_ZVAL(&subject, return_value);
		}
	}

	if (copy_replace) {
		zval_dtor(replace);
	}

	if (copy_search) {
		zval_dtor(search);
	}

}

static void phalcon_fast_trim(zval *return_value, zval *str, int where TSRMLS_DC) {

	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	php_trim(Z_STRVAL_P(str), Z_STRLEN_P(str), NULL, 0, return_value, where TSRMLS_CC);

	if (use_copy) {
		zval_dtor(&copy);
	}
}

static void phalcon_fast_strip_tags(zval *return_value, zval *str) {

	zval copy;
	int use_copy = 0;
	char *stripped;
	size_t len;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	stripped = estrndup(Z_STRVAL_P(str), Z_STRLEN_P(str));
	len = php_strip_tags(stripped, Z_STRLEN_P(str), NULL, NULL, 0);

	if (use_copy) {
		zval_dtor(&copy);
	}

	ZVAL_STRINGL(return_value, stripped, len, 0);
}

static void phalcon_fast_strtoupper(zval *return_value, zval *str) {

	zval copy;
	int use_copy = 0;
	char *lower_str;
	unsigned int length;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	length = Z_STRLEN_P(str);
	lower_str = estrndup(Z_STRVAL_P(str), length);
	php_strtoupper(lower_str, length);

	if (use_copy) {
		zval_dtor(str);
	}

	ZVAL_STRINGL(return_value, lower_str, length, 0);
}

static int phalcon_start_with(const zval *str, const zval *compared, zval *case_sensitive){

	int sensitive = 0;
	int i;
	char *op1_cursor, *op2_cursor;

	if (Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(compared) != IS_STRING) {
		return 0;
	}

	if (!Z_STRLEN_P(compared) || !Z_STRLEN_P(str) || Z_STRLEN_P(compared) > Z_STRLEN_P(str)) {
		return 0;
	}

	if (case_sensitive) {
		sensitive = zend_is_true(case_sensitive);
	}

	if (!sensitive) {
		return !memcmp(Z_STRVAL_P(str), Z_STRVAL_P(compared), Z_STRLEN_P(compared));
	}

	op1_cursor = Z_STRVAL_P(str);
	op2_cursor = Z_STRVAL_P(compared);
	for (i = 0; i < Z_STRLEN_P(compared); i++) {
		if (tolower(*op1_cursor) != tolower(*op2_cursor)) {
			return 0;
		}

		op1_cursor++;
		op2_cursor++;
	}

	return 1;
}

static int phalcon_start_with_str(const zval *str, char *compared, unsigned int compared_length){

	if (Z_TYPE_P(str) != IS_STRING || compared_length > (uint)(Z_STRLEN_P(str))) {
		return 0;
	}

	return !memcmp(Z_STRVAL_P(str), compared, compared_length);
}

static int phalcon_start_with_str_str(char *str, unsigned int str_length, char *compared, unsigned int compared_length){

	if (compared_length > str_length) {
		return 0;
	}

	return !memcmp(str, compared, compared_length);
}

static int phalcon_end_with(const zval *str, const zval *compared, zval *case_sensitive){

	int sensitive = 0;
	int i;
	char *op1_cursor, *op2_cursor;

	if (Z_TYPE_P(str) != IS_STRING || Z_TYPE_P(compared) != IS_STRING) {
		return 0;
	}

	if (!Z_STRLEN_P(compared) || !Z_STRLEN_P(str) || Z_STRLEN_P(compared) > Z_STRLEN_P(str)) {
		return 0;
	}

	if (case_sensitive) {
		sensitive = zend_is_true(case_sensitive);
	}

	if (!sensitive) {
		return !memcmp(Z_STRVAL_P(str) + Z_STRLEN_P(str) - Z_STRLEN_P(compared), Z_STRVAL_P(compared), Z_STRLEN_P(compared));
	}

	op1_cursor = Z_STRVAL_P(str) + Z_STRLEN_P(str) - Z_STRLEN_P(compared);
	op2_cursor = Z_STRVAL_P(compared);

	for (i = 0; i < Z_STRLEN_P(compared); ++i) {
		if (tolower(*op1_cursor) != tolower(*op2_cursor)) {
			return 0;
		}

		++op1_cursor;
		++op2_cursor;
	}

	return 1;
}

static int phalcon_end_with_str(const zval *str, char *compared, unsigned int compared_length){

	if (Z_TYPE_P(str) != IS_STRING) {
		return 0;
	}

	if (!compared_length || !Z_STRLEN_P(str) || compared_length > (uint)(Z_STRLEN_P(str))) {
		return 0;
	}

	return !memcmp(Z_STRVAL_P(str) + Z_STRLEN_P(str) - compared_length, compared, compared_length);
}

static void phalcon_random_string(zval *return_value, const zval *type, const zval *length TSRMLS_DC) {

	long i, rand_type, ch;
	smart_str random_str = {0};

	if (Z_TYPE_P(type) != IS_LONG) {
		return;
	}

	if (Z_LVAL_P(type) > PH_RANDOM_NOZERO) {
		return;
	}

	if (Z_TYPE_P(length) != IS_LONG) {
		return;
	}

	/** Generate seed */
	if (!BG(mt_rand_is_seeded)) {
		php_mt_srand(GENERATE_SEED() TSRMLS_CC);
	}

	for (i = 0; i < Z_LVAL_P(length); i++) {

		switch (Z_LVAL_P(type)) {
			case PH_RANDOM_ALNUM:
				rand_type = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(rand_type, 0, 3, PHP_MT_RAND_MAX);
				break;
			case PH_RANDOM_ALPHA:
				rand_type = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(rand_type, 1, 2, PHP_MT_RAND_MAX);
				break;
			case PH_RANDOM_HEXDEC:
				rand_type = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(rand_type, 0, 1, PHP_MT_RAND_MAX);
				break;
			case PH_RANDOM_NUMERIC:
				rand_type = 0;
				break;
			case PH_RANDOM_NOZERO:
				rand_type = 5;
				break;
			default:
				continue;
		}

		switch (rand_type) {
			case 0:
				ch = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(ch, '0', '9', PHP_MT_RAND_MAX);
				break;
			case 1:
				ch = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(ch, 'a', 'f', PHP_MT_RAND_MAX);
				break;
			case 2:
				ch = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(ch, 'a', 'z', PHP_MT_RAND_MAX);
				break;
			case 3:
				ch = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(ch, 'A', 'Z', PHP_MT_RAND_MAX);
				break;
			case 5:
				ch = (long) (php_mt_rand(TSRMLS_C) >> 1);
				RAND_RANGE(ch, '1', '9', PHP_MT_RAND_MAX);
				break;
			default:
				continue;
		}

		smart_str_appendc(&random_str, (unsigned int) ch);
	}


	smart_str_0(&random_str);

	if (random_str.len) {
		RETURN_STRINGL(random_str.c, random_str.len, 0);
	} else {
		smart_str_free(&random_str);
		RETURN_EMPTY_STRING();
	}

}

static void phalcon_remove_extra_slashes(zval *return_value, const zval *str) {

	char *cursor, *removed_str;
	unsigned int i;

	if (Z_TYPE_P(str) != IS_STRING) {
		RETURN_EMPTY_STRING();
	}

	if (Z_STRLEN_P(str) > 1) {
		cursor = Z_STRVAL_P(str);
		cursor += (Z_STRLEN_P(str) - 1);
		for (i = Z_STRLEN_P(str); i > 0; i--) {
			if ((*cursor) == '/') {
				cursor--;
				continue;
			}
			break;
		}
	} else {
		i = Z_STRLEN_P(str);
	}

    if (i <= Z_STRLEN_P(str)) {

    	removed_str = emalloc(i + 1);
    	memcpy(removed_str, Z_STRVAL_P(str), i);
    	removed_str[i] = '\0';

    	RETURN_STRINGL(removed_str, i, 0);
    }

    RETURN_EMPTY_STRING();
}

static int phalcon_spprintf(char **message, int max_len, char *format, ...)
{
    va_list arg;
    int len;

    va_start(arg, format);
    len = vspprintf(message, max_len, format, arg);
    va_end(arg);
    return len;
}

static void phalcon_substr(zval *return_value, zval *str, unsigned long from, unsigned long length) {

	uint str_len = (uint)(Z_STRLEN_P(str));
	if (Z_TYPE_P(str) != IS_STRING) {

		if (Z_TYPE_P(str) == IS_NULL || Z_TYPE_P(str) == IS_BOOL) {
			RETURN_FALSE;
		}

		if (Z_TYPE_P(str) == IS_LONG) {
			RETURN_EMPTY_STRING();
		}

		zend_error(E_WARNING, "Invalid arguments supplied for phalcon_substr()");
		RETURN_FALSE;
	}

	if (str_len < from){
		RETURN_FALSE;
	}

	if (!length || (str_len < length + from)) {
		length = str_len - from;
	}

	if (!length){
		RETURN_EMPTY_STRING();
	}

	RETURN_STRINGL(Z_STRVAL_P(str) + from, (int)length, 1);
}

static void phalcon_append_printable_array(smart_str *implstr, zval *value TSRMLS_DC) {

	zval         **tmp;
	HashTable      *arr;
	HashPosition   pos;
	unsigned int numelems, i = 0, str_len;

	arr = Z_ARRVAL_P(value);
	numelems = zend_hash_num_elements(arr);

	smart_str_appendc(implstr, '[');

	if (numelems > 0) {
		zend_hash_internal_pointer_reset_ex(arr, &pos);
		while (zend_hash_get_current_data_ex(arr, (void **) &tmp, &pos) == SUCCESS) {

			if (Z_TYPE_PP(tmp) == IS_OBJECT) {
				smart_str_appendc(implstr, 'O');
				{
					char stmp[MAX_LENGTH_OF_LONG + 1];
					str_len = slprintf(stmp, sizeof(stmp), "%ld", Z_OBJVAL_PP(tmp).handle);
					smart_str_appendl(implstr, stmp, str_len);
				}
			} else {
				if (Z_TYPE_PP(tmp) == IS_ARRAY) {
					phalcon_append_printable_array(implstr, *tmp TSRMLS_CC);
				} else {
					phalcon_append_printable_zval(implstr, tmp TSRMLS_CC);
				}
			}

			if (++i != numelems) {
				smart_str_appendc(implstr, ',');
			}

			zend_hash_move_forward_ex(arr, &pos);
		}
	}

	smart_str_appendc(implstr, ']');
}

static void phalcon_unique_key(zval *return_value, zval *prefix, zval *value TSRMLS_DC) {

	smart_str implstr = {0};

	if (Z_TYPE_P(prefix) == IS_STRING) {
		smart_str_appendl(&implstr, Z_STRVAL_P(prefix), Z_STRLEN_P(prefix));
	}

	if (Z_TYPE_P(value) == IS_ARRAY) {
		phalcon_append_printable_array(&implstr, value TSRMLS_CC);
	} else {
		phalcon_append_printable_zval(&implstr, &value TSRMLS_CC);
	}

	smart_str_0(&implstr);

	if (implstr.len) {
		RETURN_STRINGL(implstr.c, implstr.len, 0);
	} else {
		smart_str_free(&implstr);
		RETURN_NULL();
	}

}

static void phalcon_base64_encode(zval *return_value, zval *data) {

	zval copy;
	char *encoded;
	int use_copy = 0, length;

	if (Z_TYPE_P(data) != IS_STRING) {
		zend_make_printable_zval(data, &copy, &use_copy);
		if (use_copy) {
			data = &copy;
		}
	}

	encoded = (char *) php_base64_encode((unsigned char *)(Z_STRVAL_P(data)), Z_STRLEN_P(data), &length);

	if (use_copy) {
		zval_dtor(data);
	}

	if (encoded) {
		RETURN_STRINGL(encoded, length, 0);
	} else {
		RETURN_NULL();
	}
}

static void phalcon_base64_decode(zval *return_value, zval *data) {

	zval copy;
	char *decoded;
	int use_copy = 0, length;

	if (Z_TYPE_P(data) != IS_STRING) {
		zend_make_printable_zval(data, &copy, &use_copy);
		if (use_copy) {
			data = &copy;
		}
	}

	decoded = (char *) php_base64_decode((unsigned char *)(Z_STRVAL_P(data)), Z_STRLEN_P(data), &length);

	if (use_copy) {
		zval_dtor(data);
	}

	if (decoded) {
		RETURN_STRINGL(decoded, length, 0);
	} else {
		RETURN_NULL();
	}
}

static void phalcon_md5(zval *return_value, zval *str) {

	PHP_MD5_CTX ctx;
	unsigned char digest[16];
	char hexdigest[33];
	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(str) != IS_STRING) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	PHP_MD5Init(&ctx);
	PHP_MD5Update(&ctx, Z_STRVAL_P(str), Z_STRLEN_P(str));
	PHP_MD5Final(digest, &ctx);

	make_digest(hexdigest, digest);

	ZVAL_STRINGL(return_value, hexdigest, 32, 1);
}

#if PHALCON_USE_PHP_PCRE

static int phalcon_preg_match(zval *return_value, zval *regex, zval *subject, zval *matches TSRMLS_DC)
{
	zval copy;
	int use_copy = 0;
	pcre_cache_entry *pce;

	if (Z_TYPE_P(regex) != IS_STRING) {
		zend_error(E_WARNING, "Invalid arguments supplied for phalcon_preg_match()");
		ZVAL_FALSE(return_value);
		return SUCCESS;
	}

	if (Z_TYPE_P(subject) != IS_STRING) {
		zend_make_printable_zval(subject, &copy, &use_copy);
		if (use_copy) {
			subject = &copy;
		}
	}

	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(Z_STRVAL_P(regex), Z_STRLEN_P(regex) TSRMLS_CC)) == NULL) {

		if (use_copy) {
			zval_dtor(subject);
		}

		ZVAL_FALSE(return_value);
		return SUCCESS;
	}

	php_pcre_match_impl(pce, Z_STRVAL_P(subject), Z_STRLEN_P(subject), return_value, matches, 0, 0, 0, 0 TSRMLS_CC);

	if (use_copy) {
		zval_dtor(&copy);
	}

	return SUCCESS;
}

#else

static int phalcon_preg_match(zval *return_value, zval *regex, zval *subject, zval *matches TSRMLS_DC)
{
	zval *params[] = { regex, subject, matches };
	int result;

	if (matches) {
		Z_SET_ISREF_P(matches);
	}

	result = phalcon_return_call_function(return_value, NULL, SL("preg_match"), (matches ? 3 : 2), params TSRMLS_CC);

	if (matches) {
		Z_UNSET_ISREF_P(matches);
	}

	return result;
}

#endif /* PHALCON_USE_PHP_PCRE */

#ifdef PHALCON_USE_PHP_JSON

static int phalcon_json_encode(zval *return_value, zval *v, int opts TSRMLS_DC)
{
	smart_str buf = { NULL, 0, 0 };

	php_json_encode(&buf, v, opts TSRMLS_CC);
	smart_str_0(&buf);
	ZVAL_STRINGL(return_value, buf.c, buf.len, 0);
	return SUCCESS;
}

static int phalcon_json_decode(zval *return_value, zval *v, zend_bool assoc TSRMLS_DC)
{
	zval copy;
	int use_copy = 0;

	if (unlikely(Z_TYPE_P(v) != IS_STRING)) {
		zend_make_printable_zval(v, &copy, &use_copy);
		if (use_copy) {
			v = &copy;
		}
	}

	php_json_decode(return_value, Z_STRVAL_P(v), Z_STRLEN_P(v), assoc, 512 /* JSON_PARSER_DEFAULT_DEPTH */ TSRMLS_CC);

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}

	return SUCCESS;
}

#else

static int phalcon_json_encode(zval *return_value, zval *v, int opts TSRMLS_DC)
{
	zval *zopts;
	zval *params[2];
	int result;

	MAKE_STD_ZVAL(zopts);
	ZVAL_LONG(zopts, opts);

	params[0] = v;
	params[1] = zopts;
	result = phalcon_return_call_function(return_value, NULL, ZEND_STRL("json_encode"), 2, params TSRMLS_CC);

	zval_ptr_dtor(&zopts);
	return result;
}

static int phalcon_json_decode(zval *return_value, zval *v, zend_bool assoc TSRMLS_DC)
{
	zval *zassoc = assoc ? PHALCON_GLOBAL(z_true) : PHALCON_GLOBAL(z_false);
	zval *params[] = { v, zassoc };

	return phalcon_return_call_function(return_value, NULL, ZEND_STRL("json_decode"), 2, params TSRMLS_CC);
}

#endif /* PHALCON_USE_PHP_JSON */

static void phalcon_lcfirst(zval *return_value, zval *s)
{
	zval copy;
	char *c;
	int use_copy = 0;

	if (unlikely(Z_TYPE_P(s) != IS_STRING)) {
		zend_make_printable_zval(s, &copy, &use_copy);
		if (use_copy) {
			s = &copy;
		}
	}

	if (!Z_STRLEN_P(s)) {
		ZVAL_EMPTY_STRING(return_value);
	}
	else {
		ZVAL_STRINGL(return_value, Z_STRVAL_P(s), Z_STRLEN_P(s), 1);
		c = Z_STRVAL_P(return_value);
		*c = tolower((unsigned char)*c);
	}

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static void phalcon_ucfirst(zval *return_value, zval *s)
{
	zval copy;
	char *c;
	int use_copy = 0;

	if (unlikely(Z_TYPE_P(s) != IS_STRING)) {
		zend_make_printable_zval(s, &copy, &use_copy);
		if (use_copy) {
			s = &copy;
		}
	}

	if (!Z_STRLEN_P(s)) {
		ZVAL_EMPTY_STRING(return_value);
	}
	else {
		ZVAL_STRINGL(return_value, Z_STRVAL_P(s), Z_STRLEN_P(s), 1);
		c = Z_STRVAL_P(return_value);
		*c = toupper((unsigned char)*c);
	}

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static int phalcon_http_build_query(zval *return_value, zval *params, char *sep TSRMLS_DC)
{
	if (Z_TYPE_P(params) == IS_ARRAY || Z_TYPE_P(params) == IS_OBJECT) {
		smart_str formstr = { NULL, 0, 0 };
		int res;

#if PHP_VERSION_ID < 50400
		res = php_url_encode_hash_ex(HASH_OF(params), &formstr, NULL, 0, NULL, 0, NULL, 0, (Z_TYPE_P(params) == IS_OBJECT ? params : NULL), sep TSRMLS_CC);
#else
		res = php_url_encode_hash_ex(HASH_OF(params), &formstr, NULL, 0, NULL, 0, NULL, 0, (Z_TYPE_P(params) == IS_OBJECT ? params : NULL), sep, PHP_QUERY_RFC1738 TSRMLS_CC);
#endif

		if (res == SUCCESS) {
			if (!formstr.c) {
				ZVAL_EMPTY_STRING(return_value);
			}
			else {
				smart_str_0(&formstr);
				ZVAL_STRINGL(return_value, formstr.c, formstr.len, 0);
			}

			return SUCCESS;
		}

		smart_str_free(&formstr);
		ZVAL_FALSE(return_value);
	}
	else {
		ZVAL_NULL(return_value);
	}

	return FAILURE;
}

static void phalcon_htmlspecialchars(zval *return_value, zval *string, zval *quoting, zval *charset TSRMLS_DC)
{
	zval copy;
	char *escaped, *cs;
	int qs, use_copy = 0;
#if PHP_VERSION_ID < 50400
	int escaped_len;
#else
	size_t escaped_len;
#endif

	if (unlikely(Z_TYPE_P(string) != IS_STRING)) {
		zend_make_printable_zval(string, &copy, &use_copy);
		if (use_copy) {
			string = &copy;
		}
	}

	cs = (charset && Z_TYPE_P(charset) == IS_STRING) ? Z_STRVAL_P(charset) : NULL;
	qs = (quoting && Z_TYPE_P(quoting) == IS_LONG)   ? Z_LVAL_P(quoting)   : ENT_COMPAT;

	escaped = php_escape_html_entities_ex((unsigned char *)(Z_STRVAL_P(string)), Z_STRLEN_P(string), &escaped_len, 0, qs, cs, 1 TSRMLS_CC);
	ZVAL_STRINGL(return_value, escaped, escaped_len, 0);

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static void phalcon_htmlentities(zval *return_value, zval *string, zval *quoting, zval *charset TSRMLS_DC)
{
	zval copy;
	char *escaped, *cs;
	int qs, use_copy = 0;
#if PHP_VERSION_ID < 50400
	int escaped_len;
#else
	size_t escaped_len;
#endif

	if (unlikely(Z_TYPE_P(string) != IS_STRING)) {
		zend_make_printable_zval(string, &copy, &use_copy);
		if (use_copy) {
			string = &copy;
		}
	}

	cs = (charset && Z_TYPE_P(charset) == IS_STRING) ? Z_STRVAL_P(charset) : NULL;
	qs = (quoting && Z_TYPE_P(quoting) == IS_LONG)   ? Z_LVAL_P(quoting)   : ENT_COMPAT;

	escaped = php_escape_html_entities_ex((unsigned char *)(Z_STRVAL_P(string)), Z_STRLEN_P(string), &escaped_len, 1, qs, cs, 1 TSRMLS_CC);
	ZVAL_STRINGL(return_value, escaped, escaped_len, 0);

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static void phalcon_strval(zval *return_value, zval *v)
{
	zval copy;
	int use_copy = 0;

	zend_make_printable_zval(v, &copy, &use_copy);
	if (use_copy) {
		zval *tmp = &copy;
		ZVAL_ZVAL(return_value, tmp, 0, 0);
	}
	else {
		ZVAL_ZVAL(return_value, v, 1, 0);
	}
}

static void phalcon_date(zval *return_value, zval *format, zval *timestamp TSRMLS_DC)
{
	long int ts;
	zval copy;
	int use_copy = 0;
	char *formatted;

	if (unlikely(Z_TYPE_P(format) != IS_STRING)) {
		zend_make_printable_zval(format, &copy, &use_copy);
		if (use_copy) {
			format = &copy;
		}
	}

	ts = (timestamp) ? phalcon_get_intval(timestamp) : time(NULL);

	formatted = php_format_date(Z_STRVAL_P(format), Z_STRLEN_P(format), ts, 1 TSRMLS_CC);
	ZVAL_STRING(return_value, formatted, 0);

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static void phalcon_addslashes(zval *return_value, zval *str TSRMLS_DC)
{
	zval copy;
	int use_copy = 0;

	if (unlikely(Z_TYPE_P(str) != IS_STRING)) {
		zend_make_printable_zval(str, &copy, &use_copy);
		if (use_copy) {
			str = &copy;
		}
	}

	ZVAL_STRING(return_value, php_addslashes(Z_STRVAL_P(str), Z_STRLEN_P(str), &Z_STRLEN_P(return_value), 0 TSRMLS_CC), 0);

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}
}

static void phalcon_add_trailing_slash(zval** v)
{
	PHALCON_ENSURE_IS_STRING(v);
	if (Z_STRLEN_PP(v)) {
		int len = Z_STRLEN_PP(v);
		char *c = Z_STRVAL_PP(v);

#ifdef PHP_WIN32
		if (c[len - 1] != '/' && c[len - 1] != '\\')
#else
		if (c[len - 1] != PHP_DIR_SEPARATOR)
#endif
		{            
			SEPARATE_ZVAL(v);
			c = Z_STRVAL_PP(v);

			if (!IS_INTERNED(c)) {
				c = erealloc(c, len+2);
			}
			else {
				c = emalloc(len + 2);
				if (c != NULL) {
					memcpy(c, Z_STRVAL_PP(v), Z_STRLEN_PP(v));
				}
			}

			if (c != NULL) {
				c[len]   = PHP_DIR_SEPARATOR;
				c[len + 1] = 0;

				ZVAL_STRINGL(*v, c, len+1, 0);
			}
		}
	}
}



#if 0


#include <ext/mbstring/mbstring.h>

#ifdef ZTS
ts_rsrc_id mbstring_globals_id;
#define MBSTR_G(v) MBSTRG(v)
#else
zend_mbstring_globals *mbstring_globals;
#define MBSTR_G(v) (mbstring_globals->v)
#endif

#define PHP_UNICODE_CASE_UPPER    0
#define PHP_UNICODE_CASE_LOWER    1
#define PHP_UNICODE_CASE_TITLE    2

char *php_unicode_convert_case(int case_mode, const char *srcstr, size_t srclen, size_t *retlen, const char *src_encoding TSRMLS_DC);

static int phalcon_mb_strlen(char *str, uint len, int *ret_len TSRMLS_DC)
{
	mbfl_string string;

	string.val = (unsigned char*)str;
	string.len = len;
	string.no_language = MBSTR_G(language);
	string.no_encoding = MBSTR_G(current_internal_encoding)->no_encoding;

	*ret_len = (int)mbfl_strlen(&string);
	return SUCCESS;
}

static int phalcon_mb_strtolower(char *str, uint len, char **ret, int *ret_len TSRMLS_DC)
{
	const char *from_encoding = MBSTR_G(current_internal_encoding)->mime_name;
	char *newstr;

	newstr = php_unicode_convert_case(PHP_UNICODE_CASE_LOWER, str, (size_t)len, (size_t*)&ret_len, from_encoding TSRMLS_CC);
	if (newstr) {
		*ret = newstr;
		return SUCCESS;
	}

	return FAILURE;
}

static int phalcon_mb_strtoupper(char *str, uint len, char **ret, int *ret_len TSRMLS_DC)
{
	const char *from_encoding = MBSTR_G(current_internal_encoding)->mime_name;
	char *newstr;

	newstr = php_unicode_convert_case(PHP_UNICODE_CASE_UPPER, str, (size_t)len, (size_t*)&ret_len, from_encoding TSRMLS_CC);
	if (newstr) {
		*ret = newstr;
		return SUCCESS;
	}

	return FAILURE;
}

static int phalcon_mb_strpos(char *haystack, size_t haystack_len, char *needle, size_t needle_len, int offset, int *ret TSRMLS_DC)
{
	mbfl_string h, n;

	mbfl_string_init(&h);
	mbfl_string_init(&n);

	h.no_language = MBSTR_G(language);
	n.no_language = MBSTR_G(language);
	h.no_encoding = MBSTR_G(current_internal_encoding)->no_encoding;
	n.no_encoding = MBSTR_G(current_internal_encoding)->no_encoding;

	if (!haystack_len || !needle_len) {
		*ret = -1;
		return SUCCESS;
	}

	h.len = haystack_len;
	h.val = (unsigned char*)haystack;
	n.len = needle_len;
	n.val = (unsigned char*)needle;

	if (offset) {
		int hlen = mbfl_strlen(&h);

		if ((offset > 0 && offset > hlen) || (offset < 0 && -offset > hlen)) {
			*ret = -1;
			return SUCCESS;
		}
	}

	*ret = mbfl_strpos(&h, &n, offset, 1);
	return SUCCESS;
}

static int phalcon_mb_substr(char *str, size_t str_len, int from, int len, char **res, int *res_len TSRMLS_DC)
{
	mbfl_string string, result, *ret;
	int mblen;

	mbfl_string_init(&string);
	string.no_language = MBSTR_G(language);
	string.no_encoding = MBSTR_G(current_internal_encoding)->no_encoding;
	string.val = (unsigned char*)str;
	string.len = str_len;

	if (!len) {
		len = str_len;
	}

	if (from < 0 || len < 0) {
		mblen = mbfl_strlen(&string);
	}

	if (from < 0) {
		from = mblen + from;
		if (from < 0) {
			from = 0;
		}
	}

	if (len < 0) {
		len = (mblen - from) +len;
		if (len < 0) {
			len = 0;
		}
	}

	ret = mbfl_substr(&string, &result, from, len);
	if (ret) {
		*res     = (char*)(ret->val);
		*res_len = (int)(ret->len);
	}
	else {
		*res = NULL;
		*res_len = -1;
	}

	return SUCCESS;
}

static int phalcon_mb_detect_encoding(char *str, size_t str_len, char *encoding, int strict, char **res TSRMLS_DC)
{
	mbfl_string string;
	const mbfl_encoding *enc;
	const mbfl_encoding *ret;
	zend_bool f_strict = (-1 == strict) ? MBSTR_G(strict_detection) : !!strict;

	mbfl_string_init(&string);
	string.no_language = MBSTR_G(language);
	string.val         = (unsigned char*)str;
	string.len         = str_len;

	if (encoding) {
		enc = mbfl_name2encoding(encoding);
		ret = mbfl_identify_encoding2(&string, 1, &enc, f_strict);
	}
	else {
		ret = mbfl_identify_encoding2(&string, MBSTR_G(current_detect_order_list_size), MBSTR_G(current_detect_order_list), f_strict);
	}
	if (ret) {
		*res = (char*)ret->name;
	}
	else {
		*res = NULL;
	}

	return SUCCESS;
}

static int phalcon_mb_convert_encoding(const char *str, size_t str_len, const char *efrom, const char *eto, char **res, size_t *res_len TSRMLS_DC)
{
	*res = php_mb_convert_encoding(str, str_len, eto, efrom, res_len);
}

#endif





#include <ctype.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>
#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_math.h>
#include <ext/standard/html.h>


static void phalcon_filter_alphanum(zval *return_value, zval *param){

	int i;
	char ch;
	smart_str filtered_str = {0};
	zval copy;
	int use_copy = 0;

	if (Z_TYPE_P(param) != IS_STRING) {
		zend_make_printable_zval(param, &copy, &use_copy);
		if (use_copy) {
			param = &copy;
		}
	}

	for (i = 0; i < Z_STRLEN_P(param); i++) {
		ch = Z_STRVAL_P(param)[i];
		if (ch == '\0') {
			break;
		}
		if (isalnum(ch)) {
			smart_str_appendc(&filtered_str, ch);
		}
	}

	if (use_copy) {
		zval_dtor(param);
	}

	smart_str_0(&filtered_str);

	if (filtered_str.c) {
		RETURN_STRINGL(filtered_str.c, filtered_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}
}

static void phalcon_filter_identifier(zval *return_value, zval *param){

	int i;
	char ch;
	zval copy;
	smart_str filtered_str = {0};
	int use_copy = 0;

	if (Z_TYPE_P(param) != IS_STRING) {
		zend_make_printable_zval(param, &copy, &use_copy);
		if (use_copy) {
			param = &copy;
		}
	}

	for (i = 0; i < Z_STRLEN_P(param); i++) {
		ch = Z_STRVAL_P(param)[i];
		if (ch == '\0') {
			break;
		}
		if (isalnum(ch) || ch == '_') {
			smart_str_appendc(&filtered_str, ch);
		}
	}

	if (use_copy) {
		zval_dtor(param);
	}

	smart_str_0(&filtered_str);

	if (filtered_str.c) {
		RETURN_STRINGL(filtered_str.c, filtered_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}

}

static void phalcon_is_basic_charset(zval *return_value, const zval *param){

	int i;
	unsigned char ch;
	int iso88591 = 0;

	for (i = 0; i < Z_STRLEN_P(param); i++) {
		ch = (unsigned char)(Z_STRVAL_P(param)[i]);
		if (ch != '\0') {
			if (ch == 172 || (ch >= 128 && ch <= 159)) {
				continue;
			}
			if (ch >= 160) {
				iso88591 = 1;
				continue;
			}
		}
		RETURN_FALSE;
	}

	if (!iso88591) {
		RETURN_STRING("ASCII", 1);
	}

	RETURN_STRING("ISO-8859-1", 1);
}

static long phalcon_unpack(char *data, int size, int issigned, int *map)
{
	long result;
	char *cresult = (char *) &result;
	int i;

	result = issigned ? -1 : 0;

	for (i = 0; i < size; i++) {
		cresult[map[i]] = *data++;
	}

	return result;
}

static inline char *phalcon_longtohex(unsigned long value) {

	static char digits[] = "0123456789abcdef";
	char buf[(sizeof(unsigned long) << 1) + 1];
	char *ptr, *end;

	end = ptr = buf + sizeof(buf) - 1;
	*ptr = '\0';
	do {
		*--ptr = digits[value & 0x0F];
		value >>= 4;
	} while (ptr > buf && value);

	return estrndup(ptr, end - ptr);
}

static void phalcon_escape_multi(zval *return_value, zval *param, const char *escape_char, unsigned int escape_length, char escape_extra, int use_whitelist) {

	int i;
	zval copy;
	smart_str escaped_str = {0};
	char *hex;
	int big_endian_long_map[4];
	int use_copy = 0;
	int issigned = 0;
	long int value;

	if (Z_TYPE_P(param) != IS_STRING) {
		zend_make_printable_zval(param, &copy, &use_copy);
		if (use_copy) {
			param = &copy;
		}
	}

	if (Z_STRLEN_P(param) <= 0) {
		RETURN_FALSE;
	}

#ifndef WORDS_BIGENDIAN
	big_endian_long_map[0] = 3;
	big_endian_long_map[1] = 2;
	big_endian_long_map[2] = 1;
	big_endian_long_map[3] = 0;
#else
	big_endian_long_map[0] = 0;
	big_endian_long_map[1] = 1;
	big_endian_long_map[2] = 2;
	big_endian_long_map[3] = 3;
#endif

	if ((Z_STRLEN_P(param) % 4) != 0) {
		RETURN_FALSE;
	}

	for (i = 0; i < Z_STRLEN_P(param); i += 4) {

		issigned = Z_STRVAL_P(param)[i] & 0x80;

		value = 0;
		if (sizeof(long) > 4 && issigned) {
			value = ~INT_MAX;
		}

		value |= phalcon_unpack(&Z_STRVAL_P(param)[i], 4, issigned, big_endian_long_map);
		if (sizeof(long) > 4) {
			value = (unsigned int) value;
		}

		if (value == '\0') {
			RETURN_FALSE;
		}

		if (value > 32 && value < 127 && isalnum(value)) {
			smart_str_appendc(&escaped_str, (unsigned char) value);
			continue;
		}

		if (use_whitelist) {
			switch (value) {
				case ' ':
				case '/':
				case '*':
				case '+':
				case '-':
				case '\t':
				case '\n':
				case '^':
				case '$':
				case '!':
				case '?':
				case '\\':
				case '#':
				case '}':
				case '{':
				case ')':
				case '(':
				case ']':
				case '[':
				case '.':
				case ',':
				case ':':
				case ';':
				case '_':
				case '|':
				case '~':
				case '`':
					smart_str_appendc(&escaped_str, (unsigned char) value);
					continue;
			}
		}

		hex = phalcon_longtohex(value);

		smart_str_appendl(&escaped_str, escape_char, escape_length);
		smart_str_appendl(&escaped_str, hex, strlen(hex));
		if (escape_extra != '\0') {
			smart_str_appendc(&escaped_str, escape_extra);
		}

		efree(hex);
	}

	if (use_copy) {
		zval_dtor(param);
	}

	smart_str_0(&escaped_str);

	if (escaped_str.c) {
		RETURN_STRINGL(escaped_str.c, escaped_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}

}

static void phalcon_escape_html(zval *return_value, zval *str, const zval *quote_style, const zval *charset TSRMLS_DC) {

#if PHP_VERSION_ID < 50400
	int length;
#else
	size_t length;
#endif

	char *escaped;

	if (Z_TYPE_P(str) != IS_STRING) {
		/* Nothing to escape */
		RETURN_ZVAL(str, 1, 0);
	}

	if (Z_TYPE_P(quote_style) != IS_LONG) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid quote_style supplied for phalcon_escape_html()");
		RETURN_ZVAL(str, 1, 0);
	}

	if (Z_TYPE_P(charset) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid charset supplied for phalcon_escape_html()");
		RETURN_ZVAL(str, 1, 0);
	}

	escaped = php_escape_html_entities((unsigned char*) Z_STRVAL_P(str), Z_STRLEN_P(str), &length, 0, Z_LVAL_P(quote_style), Z_STRVAL_P(charset) TSRMLS_CC);

	RETURN_STRINGL(escaped, length, 0);
}





#include <ext/standard/php_string.h>
#include <Zend/zend_operators.h>



static void phalcon_make_printable_zval(zval *expr, zval *expr_copy, int *use_copy){
	zend_make_printable_zval(expr, expr_copy, use_copy);
	if (use_copy) {
		Z_SET_REFCOUNT_P(expr_copy, 1);
		Z_UNSET_ISREF_P(expr_copy);
	}
}

static int phalcon_and_function(zval *result, zval *left, zval *right){
	int istrue = zend_is_true(left) && zend_is_true(right);
	ZVAL_BOOL(result, istrue);
	return SUCCESS;
}

static void phalcon_concat_self(zval **left, zval *right TSRMLS_DC){

	zval left_copy, right_copy;
	uint length;
	int use_copy_left = 0, use_copy_right = 0;

	if (Z_TYPE_P(right) != IS_STRING) {
		phalcon_make_printable_zval(right, &right_copy, &use_copy_right);
		if (use_copy_right) {
			right = &right_copy;
		}
	}

	if (Z_TYPE_PP(left) == IS_NULL) {

		Z_STRVAL_PP(left) = emalloc(Z_STRLEN_P(right) + 1);
		memcpy(Z_STRVAL_PP(left), Z_STRVAL_P(right), Z_STRLEN_P(right));
		Z_STRVAL_PP(left)[Z_STRLEN_P(right)] = 0;
		Z_STRLEN_PP(left) = Z_STRLEN_P(right);
		Z_TYPE_PP(left) = IS_STRING;

		if (use_copy_right) {
			zval_dtor(&right_copy);
		}

		return;
	}

	if (Z_TYPE_PP(left) != IS_STRING) {
		phalcon_make_printable_zval(*left, &left_copy, &use_copy_left);
		if (use_copy_left) {
			PHALCON_CPY_WRT_CTOR(*left, (&left_copy));
		}
	}

	SEPARATE_ZVAL_IF_NOT_REF(left);

	length = Z_STRLEN_PP(left) + Z_STRLEN_P(right);
	Z_STRVAL_PP(left) = str_erealloc(Z_STRVAL_PP(left), length + 1);

	memcpy(Z_STRVAL_PP(left) + Z_STRLEN_PP(left), Z_STRVAL_P(right), Z_STRLEN_P(right));
	Z_STRVAL_PP(left)[length] = 0;
	Z_STRLEN_PP(left) = length;
	Z_TYPE_PP(left) = IS_STRING;

	if (use_copy_left) {
		zval_dtor(&left_copy);
	}

	if (use_copy_right) {
		zval_dtor(&right_copy);
	}
}

static void phalcon_concat_self_str(zval **left, const char *right, int right_length TSRMLS_DC){

	zval left_copy;
	uint length;
	int use_copy = 0;

	if (Z_TYPE_PP(left) == IS_NULL) {

		Z_STRVAL_PP(left) = emalloc(right_length + 1);
		memcpy(Z_STRVAL_PP(left), right, right_length);
		Z_STRVAL_PP(left)[right_length] = 0;
		Z_STRLEN_PP(left) = right_length;
		Z_TYPE_PP(left) = IS_STRING;

		return;
	}

	if (Z_TYPE_PP(left) != IS_STRING) {
		phalcon_make_printable_zval(*left, &left_copy, &use_copy);
		if (use_copy) {
			PHALCON_CPY_WRT_CTOR(*left, (&left_copy));
		}
	}

	SEPARATE_ZVAL_IF_NOT_REF(left);

	length = Z_STRLEN_PP(left) + right_length;
	Z_STRVAL_PP(left) = str_erealloc(Z_STRVAL_PP(left), length + 1);

	memcpy(Z_STRVAL_PP(left) + Z_STRLEN_PP(left), right, right_length);
	Z_STRVAL_PP(left)[length] = 0;
	Z_STRLEN_PP(left) = length;
	Z_TYPE_PP(left) = IS_STRING;

	if (use_copy) {
		zval_dtor(&left_copy);
	}
}

static int phalcon_compare_strict_string(zval *op1, const char *op2, int op2_length){

	switch (Z_TYPE_P(op1)) {
		case IS_STRING:
			if (!Z_STRLEN_P(op1) && !op2_length) {
				return 1;
			}
			if (Z_STRLEN_P(op1) != op2_length) {
				return 0;
			}
			return !zend_binary_strcmp(Z_STRVAL_P(op1), Z_STRLEN_P(op1), op2, op2_length);
		case IS_NULL:
			return !zend_binary_strcmp("", 0, op2, op2_length);
		case IS_BOOL:
			if (!Z_BVAL_P(op1)) {
				return !zend_binary_strcmp("0", strlen("0"), op2, op2_length);
			} else {
				return !zend_binary_strcmp("1", strlen("1"), op2, op2_length);
			}
	}

	return 0;
}

static int phalcon_compare_strict_long(zval *op1, long op2 TSRMLS_DC){

	int bool_result;

	switch (Z_TYPE_P(op1)) {
		case IS_LONG:
			return Z_LVAL_P(op1) == op2;
		case IS_DOUBLE:
			return Z_LVAL_P(op1) == (double) op2;
		case IS_NULL:
			return 0 == op2;
		case IS_BOOL:
			if (Z_BVAL_P(op1)) {
				return 0 == op2;
			} else {
				return 1 == op2;
			}
		default:
			{
				zval result, op2_tmp;
				ZVAL_LONG(&op2_tmp, op2);
				is_equal_function(&result, op1, &op2_tmp TSRMLS_CC);
				bool_result = Z_BVAL(result);
				return bool_result;
			}
	}

	return 0;
}

static int phalcon_add_function(zval *result, zval *op1, zval *op2 TSRMLS_DC){
	int status;
	int ref_count = Z_REFCOUNT_P(result);
	int is_ref = Z_ISREF_P(result);
	status = add_function(result, op1, op2 TSRMLS_CC);
	Z_SET_REFCOUNT_P(result, ref_count);
	Z_SET_ISREF_TO_P(result, is_ref);
	return status;
}

static void phalcon_cast(zval *result, zval *var, zend_uint type){

	ZVAL_ZVAL(result, var, 1, 0);

	switch (type) {
		case IS_STRING:
			convert_to_string(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		/*case IS_BOOL:
			convert_to_bool(result);
			break;*/
		case IS_ARRAY:
			if (Z_TYPE_P(result) != IS_ARRAY) {
				convert_to_array(result);
			}
			break;
	}

}

long phalcon_get_intval(const zval *op) {

	switch (Z_TYPE_P(op)) {
		case IS_LONG:
			return Z_LVAL_P(op);
		case IS_BOOL:
			return Z_BVAL_P(op);
		case IS_DOUBLE:
			return (long) Z_DVAL_P(op);
		case IS_STRING: {
			long long_value;
			double double_value;
			zend_uchar type;
			
			ASSUME(Z_STRVAL_P(op) != NULL);
			type = is_numeric_string(Z_STRVAL_P(op), Z_STRLEN_P(op), &long_value, &double_value, 0);
			if (type == IS_LONG) {
				return long_value;
			}
			if (type == IS_DOUBLE) {
				return (long)double_value;
			}
			return 0;
		}
	}

	return 0;
}

static int phalcon_is_numeric(const zval *op) {

	int type;

	switch (Z_TYPE_P(op)) {
		case IS_LONG:
			return 1;
		case IS_BOOL:
			return 0;
		case IS_DOUBLE:
			return 1;
		case IS_STRING:
			if ((type = is_numeric_string(Z_STRVAL_P(op), Z_STRLEN_P(op), NULL, NULL, 0))) {
				if (type == IS_LONG || type == IS_DOUBLE) {
					return 1;
				}
			}
	}

	return 0;
}

static int phalcon_is_equal(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_equal_function(&result, op1, op2 TSRMLS_CC);
	return Z_BVAL(result);
}

static int phalcon_less(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_smaller_function(&result, op1, op2 TSRMLS_CC);
	return Z_BVAL(result);
}

static int phalcon_less_equal(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_smaller_or_equal_function(&result, op1, op2 TSRMLS_CC);
	return Z_BVAL(result);
}

static int phalcon_less_long(zval *op1, long op2 TSRMLS_DC) {
	zval result, op2_zval;
	ZVAL_LONG(&op2_zval, op2);
	is_smaller_function(&result, op1, &op2_zval TSRMLS_CC);
	return Z_BVAL(result);
}

static int phalcon_less_equal_long(zval *op1, long op2 TSRMLS_DC) {
	zval result, op2_zval;
	ZVAL_LONG(&op2_zval, op2);
	is_smaller_or_equal_function(&result, op1, &op2_zval TSRMLS_CC);
	return Z_BVAL(result);
}

static int phalcon_greater(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_smaller_or_equal_function(&result, op1, op2 TSRMLS_CC);
	return !Z_BVAL(result);
}

static int phalcon_greater_long(zval *op1, long op2 TSRMLS_DC) {
	zval result, op2_zval;
	ZVAL_LONG(&op2_zval, op2);
	is_smaller_or_equal_function(&result, op1, &op2_zval TSRMLS_CC);
	return !Z_BVAL(result);
}

static int phalcon_greater_equal(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_smaller_function(&result, op1, op2 TSRMLS_CC);
	return !Z_BVAL(result);
}

static int phalcon_greater_equal_long(zval *op1, long op2 TSRMLS_DC) {
	zval result, op2_zval;
	ZVAL_LONG(&op2_zval, op2);
	is_smaller_function(&result, op1, &op2_zval TSRMLS_CC);
	return !Z_BVAL(result);
}

static int phalcon_is_identical(zval *op1, zval *op2 TSRMLS_DC) {
	zval result;
	is_identical_function(&result, op1, op2 TSRMLS_CC);
	return Z_BVAL(result);
}





#include <ext/standard/php_string.h>

static void phalcon_concat_sv(zval **result, const char *op1, zend_uint op1_len, zval *op2, int self_var TSRMLS_DC){

	zval result_copy, op2_copy;
	int use_copy = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy;
	int use_copy = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4), op5, op5_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsvsv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op6_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsvsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, const char *op7, zend_uint op7_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op6_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy6 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6), op7, op7_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsvsvsvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, const char *op5, zend_uint op5_len, zval *op6, const char *op7, zend_uint op7_len, zval *op8, const char *op9, zend_uint op9_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op6_copy, op8_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy6 = 0, use_copy8 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	if (Z_TYPE_P(op8) != IS_STRING) {
		zend_make_printable_zval(op8, &op8_copy, &use_copy8);
		if (use_copy8) {
			op8 = &op8_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len + Z_STRLEN_P(op8) + op9_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6), op7, op7_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len, Z_STRVAL_P(op8), Z_STRLEN_P(op8));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + op7_len + Z_STRLEN_P(op8), op9, op9_len);

	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy8) {
		zval_dtor(op8);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svsvv(zval **result, const char *op1, zend_uint op1_len, zval *op2, const char *op3, zend_uint op3_len, zval *op4, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op4_copy, op5_copy;
	int use_copy = 0, use_copy2 = 0, use_copy4 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svv(zval **result, const char *op1, zend_uint op1_len, zval *op2, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op3_copy;
	int use_copy = 0, use_copy2 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_svvs(zval **result, const char *op1, zend_uint op1_len, zval *op2, zval *op3, const char *op4, zend_uint op4_len, int self_var TSRMLS_DC){

	zval result_copy, op2_copy, op3_copy;
	int use_copy = 0, use_copy2 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = op1_len + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + op4_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, op1, op1_len);
	memcpy(Z_STRVAL_PP(result) + offset + op1_len, Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + op1_len + Z_STRLEN_P(op2) + Z_STRLEN_P(op3), op4, op4_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vs(zval **result, zval *op1, const char *op2, zend_uint op2_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy;
	int use_copy = 0, use_copy1 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvs(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), op4, op4_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvsvs(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, const char *op6, zend_uint op6_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5) + op6_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5), op6, op6_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvsvsv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, const char *op4, zend_uint op4_len, zval *op5, const char *op6, zend_uint op6_len, zval *op7, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op5_copy, op7_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy5 = 0, use_copy7 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	if (Z_TYPE_P(op7) != IS_STRING) {
		zend_make_printable_zval(op7, &op7_copy, &use_copy7);
		if (use_copy7) {
			op7 = &op7_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5) + op6_len + Z_STRLEN_P(op7);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5), op6, op6_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5) + op6_len, Z_STRVAL_P(op7), Z_STRLEN_P(op7));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy7) {
		zval_dtor(op7);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op4_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vsvvv(zval **result, zval *op1, const char *op2, zend_uint op2_len, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op3_copy, op4_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy3 = 0, use_copy4 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), op2, op2_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len, Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + op2_len + Z_STRLEN_P(op3) + Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vv(zval **result, zval *op1, zval *op2, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvs(zval **result, zval *op1, zval *op2, const char *op3, zend_uint op3_len, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + op3_len;
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), op3, op3_len);
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvsv(zval **result, zval *op1, zval *op2, const char *op3, zend_uint op3_len, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op4_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + op3_len + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), op3, op3_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + op3_len, Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvv(zval **result, zval *op1, zval *op2, zval *op3, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvvsv(zval **result, zval *op1, zval *op2, zval *op3, const char *op4, zend_uint op4_len, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + op4_len + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3), op4, op4_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + op4_len, Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op4_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy4 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvvvsvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, const char *op5, zend_uint op5_len, zval *op6, zval *op7, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op4_copy, op6_copy, op7_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy4 = 0, use_copy6 = 0, use_copy7 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op6) != IS_STRING) {
		zend_make_printable_zval(op6, &op6_copy, &use_copy6);
		if (use_copy6) {
			op6 = &op6_copy;
		}
	}

	if (Z_TYPE_P(op7) != IS_STRING) {
		zend_make_printable_zval(op7, &op7_copy, &use_copy7);
		if (use_copy7) {
			op7 = &op7_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6) + Z_STRLEN_P(op7);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4), op5, op5_len);
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + op5_len, Z_STRVAL_P(op6), Z_STRLEN_P(op6));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + op5_len + Z_STRLEN_P(op6), Z_STRVAL_P(op7), Z_STRLEN_P(op7));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy6) {
		zval_dtor(op6);
	}

	if (use_copy7) {
		zval_dtor(op7);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}

static void phalcon_concat_vvvvv(zval **result, zval *op1, zval *op2, zval *op3, zval *op4, zval *op5, int self_var TSRMLS_DC){

	zval result_copy, op1_copy, op2_copy, op3_copy, op4_copy, op5_copy;
	int use_copy = 0, use_copy1 = 0, use_copy2 = 0, use_copy3 = 0, use_copy4 = 0, use_copy5 = 0;
	uint offset = 0, length;

	if (Z_TYPE_P(op1) != IS_STRING) {
		zend_make_printable_zval(op1, &op1_copy, &use_copy1);
		if (use_copy1) {
			op1 = &op1_copy;
		}
	}

	if (Z_TYPE_P(op2) != IS_STRING) {
		zend_make_printable_zval(op2, &op2_copy, &use_copy2);
		if (use_copy2) {
			op2 = &op2_copy;
		}
	}

	if (Z_TYPE_P(op3) != IS_STRING) {
		zend_make_printable_zval(op3, &op3_copy, &use_copy3);
		if (use_copy3) {
			op3 = &op3_copy;
		}
	}

	if (Z_TYPE_P(op4) != IS_STRING) {
		zend_make_printable_zval(op4, &op4_copy, &use_copy4);
		if (use_copy4) {
			op4 = &op4_copy;
		}
	}

	if (Z_TYPE_P(op5) != IS_STRING) {
		zend_make_printable_zval(op5, &op5_copy, &use_copy5);
		if (use_copy5) {
			op5 = &op5_copy;
		}
	}

	length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4) + Z_STRLEN_P(op5);
	if (self_var) {

		if (Z_TYPE_PP(result) != IS_STRING) {
			zend_make_printable_zval(*result, &result_copy, &use_copy);
			if (use_copy) {
				PHALCON_CPY_WRT_CTOR(*result, (&result_copy));
			}
		}

		offset = Z_STRLEN_PP(result);
		length += offset;
		Z_STRVAL_PP(result) = (char *) str_erealloc(Z_STRVAL_PP(result), length + 1);

	} else {
		Z_STRVAL_PP(result) = (char *) emalloc(length + 1);
	}

	memcpy(Z_STRVAL_PP(result) + offset, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2), Z_STRVAL_P(op3), Z_STRLEN_P(op3));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3), Z_STRVAL_P(op4), Z_STRLEN_P(op4));
	memcpy(Z_STRVAL_PP(result) + offset + Z_STRLEN_P(op1) + Z_STRLEN_P(op2) + Z_STRLEN_P(op3) + Z_STRLEN_P(op4), Z_STRVAL_P(op5), Z_STRLEN_P(op5));
	Z_STRVAL_PP(result)[length] = 0;
	Z_TYPE_PP(result) = IS_STRING;
	Z_STRLEN_PP(result) = length;

	if (use_copy1) {
		zval_dtor(op1);
	}

	if (use_copy2) {
		zval_dtor(op2);
	}

	if (use_copy3) {
		zval_dtor(op3);
	}

	if (use_copy4) {
		zval_dtor(op4);
	}

	if (use_copy5) {
		zval_dtor(op5);
	}

	if (use_copy) {
		zval_dtor(&result_copy);
	}

}






#include <ctype.h>

#include <main/php_streams.h>
#include <Zend/zend_exceptions.h>
#include <Zend/zend_interfaces.h>
#include <ext/standard/file.h>
#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_filestat.h>
#include <ext/standard/php_string.h>

static int phalcon_file_exists(zval *filename TSRMLS_DC){

	zval return_value;

	if (Z_TYPE_P(filename) != IS_STRING) {
		return FAILURE;
	}

	php_stat(Z_STRVAL_P(filename), (php_stat_len) Z_STRLEN_P(filename), FS_EXISTS, &return_value TSRMLS_CC);

	if (PHALCON_IS_FALSE((&return_value))) {
		return FAILURE;
	}

	if (PHALCON_IS_EMPTY((&return_value))) {
		return FAILURE;
	}

	return SUCCESS;
}

static int phalcon_compare_mtime(zval *filename1, zval *filename2 TSRMLS_DC){

	php_stream_statbuf statbuffer1, statbuffer2;

	if (Z_TYPE_P(filename1) != IS_STRING || Z_TYPE_P(filename2) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for compare_mtime()");
		return 0;
	}

	if (php_stream_stat_path_ex(Z_STRVAL_P(filename1), 0, &statbuffer1, NULL)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "mstat failed for %s", Z_STRVAL_P(filename1));
		return 0;
	}

	if (php_stream_stat_path_ex(Z_STRVAL_P(filename2), 0, &statbuffer2, NULL)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "mstat failed for %s", Z_STRVAL_P(filename2));
		return 0;
	}

	return (int) (statbuffer1.sb.st_mtime >= statbuffer2.sb.st_mtime);
}

static void phalcon_fast_filemtime(zval *return_value, zval *filename TSRMLS_DC){

	if (Z_TYPE_P(filename) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for fast_filemtime()");
		return;
	}

	php_stat(Z_STRVAL_P(filename), (php_stat_len) Z_STRLEN_P(filename), FS_MTIME, return_value TSRMLS_CC);
}

static void phalcon_fix_path(zval **return_value, zval *path, zval *directory_separator TSRMLS_DC) {

	if (Z_TYPE_P(path) != IS_STRING || Z_TYPE_P(directory_separator) != IS_STRING) {
		return;
	}

	if (Z_STRLEN_P(path) > 0 && Z_STRLEN_P(directory_separator) > 0) {
		if (Z_STRVAL_P(path)[Z_STRLEN_P(path) - 1] != '\\' && Z_STRVAL_P(path)[Z_STRLEN_P(path) - 1] != '/') {
			PHALCON_CONCAT_VV(*return_value, path, directory_separator);
			return;
		}
	}

	zval_ptr_dtor(return_value);
	*return_value = path;
	Z_ADDREF_P(path);
}

static void phalcon_prepare_virtual_path(zval *return_value, zval *path, zval *virtual_separator TSRMLS_DC) {

	int i;
	unsigned char ch;
	smart_str virtual_str = {0};

	if (Z_TYPE_P(path) != IS_STRING || Z_TYPE_P(virtual_separator) != IS_STRING) {
		if (Z_TYPE_P(path) == IS_STRING) {
			RETURN_STRINGL(Z_STRVAL_P(path), Z_STRLEN_P(path), 1);
		} else {
			RETURN_EMPTY_STRING();
		}
		return;
	}

	for (i = 0; i < Z_STRLEN_P(path); i++) {
		ch = Z_STRVAL_P(path)[i];
		if (ch == '\0') {
			break;
		}
		if (ch == '/' || ch == '\\' || ch == ':' || !isprint(ch)) {
			smart_str_appendl(&virtual_str, Z_STRVAL_P(virtual_separator), Z_STRLEN_P(virtual_separator));
		}
		else {
			smart_str_appendc(&virtual_str, tolower(ch));
		}
	}

	smart_str_0(&virtual_str);

	if (virtual_str.c) {
		RETURN_STRINGL(virtual_str.c, virtual_str.len, 0);
	} else {
		RETURN_EMPTY_STRING();
	}
}

static void phalcon_prepare_virtual_path_ex(zval *return_value, const char *path, size_t path_len, char virtual_separator TSRMLS_DC)
{
	char *copy = ecalloc(path_len+1, 1);
	size_t i;

	for (i=0; i<path_len; ++i) {
		char c = path[i];

		if (c == '/' || c == '\\' || c == ':' || !isprint(c)) {
			copy[i] = virtual_separator;
		}
		else {
			copy[i] = tolower(c);
		}
	}

	ZVAL_STRINGL(return_value, copy, path_len, 0);
}

static void phalcon_unique_path_key(zval *return_value, zval *path TSRMLS_DC) {

	unsigned long h;
	char *strKey;

	if (Z_TYPE_P(path) != IS_STRING) {
		return;
	}

	h = zend_hash_func(Z_STRVAL_P(path), Z_STRLEN_P(path) + 1);

	strKey = emalloc(24);
	snprintf(strKey, 23, "v%lu", h);    

	RETURN_STRING(strKey, 0);
}

static void phalcon_realpath(zval *return_value, zval *filename TSRMLS_DC) {

	char resolved_path_buff[MAXPATHLEN];

	if (Z_TYPE_P(filename) != IS_STRING) {
		RETURN_FALSE;
	}

	if (strlen(Z_STRVAL_P(filename)) != (size_t)(Z_STRLEN_P(filename))) {
		RETURN_FALSE;
	}

	if (VCWD_REALPATH(Z_STRVAL_P(filename), resolved_path_buff)) {
		RETURN_STRING(resolved_path_buff, 1);
	}

	RETURN_FALSE;
}

static void phalcon_possible_autoload_filepath(zval *return_value, zval *prefix, zval *class_name, zval *virtual_separator, zval *separator TSRMLS_DC) {

	int i, length;
	unsigned char ch;
	smart_str virtual_str = {0};

	if (Z_TYPE_P(prefix) != IS_STRING || Z_TYPE_P(class_name) != IS_STRING || Z_TYPE_P(virtual_separator) != IS_STRING) {
		RETURN_FALSE;
	}

	length = Z_STRLEN_P(prefix);
	if (!length) {
		RETURN_FALSE;
	}

	if (length > Z_STRLEN_P(class_name)) {
		RETURN_FALSE;
	}

	if (separator) {
		if (Z_STRVAL_P(prefix)[Z_STRLEN_P(prefix) - 1] == Z_STRVAL_P(separator)[0]) {
			length--;
		}
	}

	for (i = length + 1; i < Z_STRLEN_P(class_name); i++) {

		ch = Z_STRVAL_P(class_name)[i];

		if (ch == '\0') {
			break;
		}

		if (ch == '\\') {
			smart_str_appendl(&virtual_str, Z_STRVAL_P(virtual_separator), Z_STRLEN_P(virtual_separator));
			continue;
		}

		if (separator) {
			if (ch == Z_STRVAL_P(separator)[0]) {
				smart_str_appendl(&virtual_str, Z_STRVAL_P(virtual_separator), Z_STRLEN_P(virtual_separator));
				continue;
			}
		}

		if ((ch == '_') || (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
			smart_str_appendc(&virtual_str, ch);
			continue;
		}

		if (ch > 127) {
			smart_str_appendc(&virtual_str, ch);
			continue;
		}

	}

	smart_str_0(&virtual_str);

	if (virtual_str.len) {
		RETURN_STRINGL(virtual_str.c, virtual_str.len, 0);
	} else {
		smart_str_free(&virtual_str);
		RETURN_FALSE;
	}

}

static void phalcon_file_get_contents(zval *return_value, zval *filename TSRMLS_DC)
{

	char *contents;
	php_stream *stream;
	int len;
	long maxlen = PHP_STREAM_COPY_ALL;
	zval *zcontext = NULL;
	php_stream_context *context = NULL;

	if (Z_TYPE_P(filename) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for phalcon_file_get_contents()");
		RETVAL_FALSE;
		return;
	}

	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(Z_STRVAL_P(filename), "rb", 0 | REPORT_ERRORS, NULL, context);
	if (!stream) {
		RETURN_FALSE;
	}

	if ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {
		RETVAL_STRINGL(contents, len, 0);
	} else {
		if (len == 0) {
			RETVAL_EMPTY_STRING();
		} else {
			RETVAL_FALSE;
		}
	}

	php_stream_close(stream);
}

static void phalcon_file_put_contents(zval *return_value, zval *filename, zval *data TSRMLS_DC)
{
	php_stream *stream;
	int numbytes = 0, use_copy = 0;
	zval *zcontext = NULL;
	zval copy;
	php_stream_context *context = NULL;

	if (Z_TYPE_P(filename) != IS_STRING) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for phalcon_file_put_contents()");
		if (return_value) {
			RETVAL_FALSE;
		}
		return;
	}

	context = php_stream_context_from_zval(zcontext, 0 & PHP_FILE_NO_DEFAULT_CONTEXT);

	stream = php_stream_open_wrapper_ex(Z_STRVAL_P(filename), "wb", ((0 & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);
	if (stream == NULL) {
		if (return_value) {
			RETURN_FALSE;
		}
		return;
	}

	switch (Z_TYPE_P(data)) {

		case IS_NULL:
		case IS_LONG:
		case IS_DOUBLE:
		case IS_BOOL:
		case IS_CONSTANT:
			zend_make_printable_zval(data, &copy, &use_copy);
			if (use_copy) {
				data = &copy;
			}
			/* no break */

		case IS_STRING:
			if (Z_STRLEN_P(data)) {
				numbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));
				if (numbytes != Z_STRLEN_P(data)) {
					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Only %d of %d bytes written, possibly out of free disk space", numbytes, Z_STRLEN_P(data));
					numbytes = -1;
				}
			}
			break;
		default:
			numbytes = -1;
			break;
	}

	php_stream_close(stream);

	if (use_copy) {
		zval_dtor(data);
	}

	if (numbytes < 0) {
		if (return_value) {
			RETURN_FALSE;
		} else {
			return;
		}
	}

	if (return_value) {
		RETURN_LONG(numbytes);
	}
	return;
}

static void phalcon_is_dir(zval *return_value, zval *path TSRMLS_DC)
{
	if (likely(Z_TYPE_P(path) == IS_STRING)) {
		php_stat(Z_STRVAL_P(path), (php_stat_len)(Z_STRLEN_P(path)), FS_IS_DIR, return_value TSRMLS_CC);
	}
	else {
		ZVAL_FALSE(return_value);
	}
}

static void phalcon_unlink(zval *return_value, zval *path TSRMLS_DC)
{
	if (likely(Z_TYPE_P(path) == IS_STRING)) {
		php_stream_context *context;
		php_stream_wrapper *wrapper;
		zval *zctx = NULL;

		if (unlikely(strlen(Z_STRVAL_P(path)) != (size_t)(Z_STRLEN_P(path)))) {
			ZVAL_FALSE(return_value);
			return;
		}

		context = php_stream_context_from_zval(zctx, 0);
		wrapper = php_stream_locate_url_wrapper(Z_STRVAL_P(path), NULL, 0 TSRMLS_CC);

		if (!wrapper || !wrapper->wops || !wrapper->wops->unlink) {
			ZVAL_FALSE(return_value);
			return;
		}

		ZVAL_BOOL(return_value, wrapper->wops->unlink(wrapper, Z_STRVAL_P(path), REPORT_ERRORS, context TSRMLS_CC));
		return;
	}

	ZVAL_FALSE(return_value);
	return;
}

static void phalcon_filemtime(zval *return_value, zval *path TSRMLS_DC)
{
	if (likely(Z_TYPE_P(path) == IS_STRING)) {
		php_stat(Z_STRVAL_P(path), (php_stat_len)(Z_STRLEN_P(path)), FS_MTIME, return_value TSRMLS_CC);
	}
	else {
		ZVAL_FALSE(return_value);
	}
}

static void phalcon_basename(zval *return_value, zval *path TSRMLS_DC)
{
	if (likely(Z_TYPE_P(path) == IS_STRING)) {
		char *ret;
		size_t ret_len;

		php_basename(Z_STRVAL_P(path), Z_STRLEN_P(path), NULL, 0, &ret, &ret_len TSRMLS_CC);
		ZVAL_STRINGL(return_value, ret, (int)ret_len, 0);
	}
	else {
		ZVAL_FALSE(return_value);
	}
}





#include <main/php_output.h>


static void phalcon_ob_start(TSRMLS_D)
{
#if PHP_VERSION_ID < 50400
	php_start_ob_buffer(NULL, 0, 1 TSRMLS_CC);
#else
	php_output_start_default(TSRMLS_C);
#endif
}

static void phalcon_ob_get_contents(zval *result TSRMLS_DC)
{
#if PHP_VERSION_ID < 50400
	php_ob_get_buffer(result TSRMLS_CC);
#else
	php_output_get_contents(result TSRMLS_CC);
#endif
}

static int phalcon_ob_end_flush(TSRMLS_D)
{
	if (phalcon_ob_get_level(TSRMLS_C) < 1) {
		php_error_docref("ref.outcontrol" TSRMLS_CC, E_NOTICE, "failed to delete and flush buffer. No buffer to flush");
		return FAILURE;
	}

#if PHP_VERSION_ID < 50400
	php_end_ob_buffer(1, 0 TSRMLS_CC);
	return SUCCESS;
#else
	return php_output_end(TSRMLS_C);
#endif
}

static int phalcon_ob_end_clean(TSRMLS_D)
{
	if (phalcon_ob_get_level(TSRMLS_C) < 1) {
		php_error_docref("ref.outcontrol" TSRMLS_CC, E_NOTICE, "failed to delete buffer. No buffer to delete");
		return FAILURE;
	}

#if PHP_VERSION_ID < 50400
	php_end_ob_buffer(0, 0 TSRMLS_CC);
	return SUCCESS;
#else
	return php_output_discard(TSRMLS_C);
#endif
}

static int phalcon_ob_flush(TSRMLS_D)
{
	if (phalcon_ob_get_level(TSRMLS_C) < 1) {
		php_error_docref("ref.outcontrol" TSRMLS_CC, E_NOTICE, "failed to flush buffer. No buffer to flush");
		return FAILURE;
	}

#if PHP_VERSION_ID < 50400
	php_end_ob_buffer(1, 1 TSRMLS_CC);
	return SUCCESS;
#else
	return php_output_flush(TSRMLS_C);
#endif
}

static int phalcon_ob_clean(TSRMLS_D)
{
	if (phalcon_ob_get_level(TSRMLS_C) < 1) {
		php_error_docref("ref.outcontrol" TSRMLS_CC, E_NOTICE, "failed to delete buffer. No buffer to delete");
		return FAILURE;
	}

#if PHP_VERSION_ID < 50400
	php_end_ob_buffer(0, 1 TSRMLS_CC);
	return SUCCESS;
#else
	return php_output_clean(TSRMLS_C);
#endif
}

static int phalcon_ob_get_level(TSRMLS_D)
{
#if PHP_VERSION_ID < 50400
	return OG(ob_nesting_level);
#else
	return php_output_get_level(TSRMLS_C);
#endif
}





#include <Zend/zend_exceptions.h>



static void phalcon_throw_exception(zval *object TSRMLS_DC){
	Z_ADDREF_P(object);
	zend_throw_exception_object(object TSRMLS_CC);
}

static void phalcon_throw_exception_string(zend_class_entry *ce, const char *message TSRMLS_DC){

	zend_throw_exception_ex(ce, 0 TSRMLS_CC, "%s", message);
}

static void phalcon_throw_exception_zval(zend_class_entry *ce, zval *message TSRMLS_DC){

	zval *object;

	MAKE_STD_ZVAL(object);
	object_init_ex(object, ce);

	PHALCON_CALL_METHODW(NULL, object, "__construct", message);
	zend_throw_exception_object(object TSRMLS_CC);
}





#include <main/php_main.h>
#include <Zend/zend_exceptions.h>

#ifndef ENFORCE_SAFE_MODE
#define ENFORCE_SAFE_MODE    0
#endif

static int phalcon_require_ret(zval **return_value_ptr, const char *require_path TSRMLS_DC)
{
	zend_file_handle file_handle;
	int ret;

#ifndef PHALCON_RELEASE
	if (return_value_ptr && *return_value_ptr) {
		fprintf(stderr, "%s: *return_value_ptr is expected to be NULL", __func__);
		phalcon_print_backtrace();
		abort();
	}
#endif

	ret = php_stream_open_for_zend_ex(require_path, &file_handle, ENFORCE_SAFE_MODE | USE_PATH | STREAM_OPEN_FOR_INCLUDE | IGNORE_URL TSRMLS_CC);
	if (ret == SUCCESS) {
		int dummy = 1;
		zend_op_array *new_op_array;

		if (!file_handle.opened_path) {
			file_handle.opened_path = estrdup(require_path);
		}

		zend_hash_add(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1, (void *)&dummy, sizeof(int), NULL);
		new_op_array = zend_compile_file(&file_handle, ZEND_REQUIRE TSRMLS_CC);
		zend_destroy_file_handle(&file_handle TSRMLS_CC);

		if (new_op_array) {
			zval **original_return_value            = EG(return_value_ptr_ptr);
			zend_op_array *original_active_op_array = EG(active_op_array);
			zend_op **original_opline_ptr           = EG(opline_ptr);

			EG(return_value_ptr_ptr) = return_value_ptr;
			EG(active_op_array)      = new_op_array;

			zend_execute(new_op_array TSRMLS_CC);
			zend_exception_restore(TSRMLS_C);
			destroy_op_array(new_op_array TSRMLS_CC);
			efree(new_op_array);

			if (EG(exception)) {
				assert(!return_value_ptr || !*return_value_ptr);
				ret = FAILURE;
			}
			else {
				ret = SUCCESS;
			}

			EG(return_value_ptr_ptr) = original_return_value;
			EG(active_op_array)      = original_active_op_array;
			EG(opline_ptr)           = original_opline_ptr;
			return ret;
		}
	}
	else {
		zend_destroy_file_handle(&file_handle TSRMLS_CC);
	}

	return FAILURE;
}





#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_var.h>

static void phalcon_serialize(zval *return_value, zval **var TSRMLS_DC) {

	php_serialize_data_t var_hash;
	smart_str buf = {0};

	PHP_VAR_SERIALIZE_INIT(var_hash);
	php_var_serialize(&buf, var, &var_hash TSRMLS_CC);
	PHP_VAR_SERIALIZE_DESTROY(var_hash);

	if (EG(exception)) {
		smart_str_free(&buf);
		RETURN_FALSE;
	}

	if (buf.c) {
		RETURN_STRINGL(buf.c, buf.len, 0);
	} else {
		RETURN_NULL();
	}
}

static void phalcon_unserialize(zval *return_value, zval *var TSRMLS_DC) {

	const unsigned char *p;
	php_unserialize_data_t var_hash;

	if (Z_TYPE_P(var) != IS_STRING) {
		RETURN_FALSE;
	}

	if (Z_STRLEN_P(var) == 0) {
		RETURN_FALSE;
	}

	p = (const unsigned char*) Z_STRVAL_P(var);
	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if (!php_var_unserialize(&return_value, &p, p + Z_STRLEN_P(var), &var_hash TSRMLS_CC)) {
		PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
		zval_dtor(return_value);
		ZVAL_NULL(return_value);
		if (!EG(exception)) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Error at offset %ld of %d bytes", (long)((char*)p - Z_STRVAL_P(var)), Z_STRLEN_P(var));
		}
		RETURN_FALSE;
	}
	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

}




#ifdef PHALCON_USE_PHP_SESSION
#include <ext/session/php_session.h>
#endif


static int phalcon_session_start(TSRMLS_D)
{
#ifdef PHALCON_USE_PHP_SESSION
	php_session_start(TSRMLS_C);
	return SUCCESS;
#else
	return phalcon_call_func_aparams(NULL, SL("session_start"), 0, NULL TSRMLS_CC);
#endif
}

static int phalcon_session_destroy(TSRMLS_D)
{
	return phalcon_call_func_aparams(NULL, SL("session_destroy"), 0, NULL TSRMLS_CC);
}

static int phalcon_get_session_id(zval *return_value, zval **return_value_ptr TSRMLS_DC)
{
#ifdef PHALCON_USE_PHP_SESSION
	if (PS(id)) {
		RETVAL_STRING(PS(id), 1);
	}
	else {
		RETVAL_EMPTY_STRING();
	}

	return SUCCESS;
#else
	return phalcon_return_call_function(return_value, return_value_ptr, SL("session_id"), 0, NULL TSRMLS_CC);
#endif
}

static int phalcon_set_session_id(zval *sid TSRMLS_DC)
{
#ifdef PHALCON_USE_PHP_SESSION
	zval copy;
	int use_copy = 0;

	if (unlikely(Z_TYPE_P(sid) != IS_STRING)) {
		zend_make_printable_zval(sid, &copy, &use_copy);
		if (use_copy) {
			sid = &copy;
		}
	}

	if (PS(id)) {
		efree(PS(id));
	}

	PS(id) = estrndup(Z_STRVAL_P(sid), Z_STRLEN_P(sid));

	if (unlikely(use_copy)) {
		zval_dtor(&copy);
	}

	return SUCCESS;
#else
	zval *params[] = { sid };
	return phalcon_call_func_aparams(NULL, SL("session_id"), 1, params TSRMLS_CC);
#endif
}

static int phalcon_session_write_close(TSRMLS_D)
{
	return phalcon_call_func_aparams(NULL, SL("session_write_close"), 0, NULL TSRMLS_CC);
}




#include <ext/standard/php_smart_str.h>

static void phalcon_orm_destroy_cache(TSRMLS_D) {

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	if (phalcon_globals_ptr->orm.parser_cache != NULL) {
		zend_hash_destroy(phalcon_globals_ptr->orm.parser_cache);
		FREE_HASHTABLE(phalcon_globals_ptr->orm.parser_cache);
		phalcon_globals_ptr->orm.parser_cache = NULL;
	}

	if (phalcon_globals_ptr->orm.ast_cache != NULL) {
		zend_hash_destroy(phalcon_globals_ptr->orm.ast_cache);
		FREE_HASHTABLE(phalcon_globals_ptr->orm.ast_cache);
		phalcon_globals_ptr->orm.ast_cache = NULL;
	}
}

static void phalcon_orm_get_prepared_ast(zval **return_value, zval *unique_id TSRMLS_DC) {

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;
	zval **temp_ast;

	if (Z_TYPE_P(unique_id) == IS_LONG) {
		if (phalcon_globals_ptr->orm.cache_level >= 1) {
			if (phalcon_globals_ptr->orm.ast_cache != NULL) {
				if (zend_hash_index_find(phalcon_globals_ptr->orm.ast_cache, Z_LVAL_P(unique_id), (void**) &temp_ast) == SUCCESS) {
					ZVAL_ZVAL(*return_value, *temp_ast, 1, 0);
					Z_SET_REFCOUNT_P(*return_value, 1);
					return;
				}
			}
		}
	}
}

static void phalcon_orm_set_prepared_ast(zval *unique_id, zval *prepared_ast TSRMLS_DC) {

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	if (Z_TYPE_P(unique_id) == IS_LONG) {
		if (phalcon_globals_ptr->orm.cache_level >= 1) {

			if (!phalcon_globals_ptr->orm.ast_cache) {
				ALLOC_HASHTABLE(phalcon_globals_ptr->orm.ast_cache);
				zend_hash_init(phalcon_globals_ptr->orm.ast_cache, 0, NULL, ZVAL_PTR_DTOR, 0);
			}

			Z_ADDREF_P(prepared_ast);

			zend_hash_index_update(
				phalcon_globals_ptr->orm.ast_cache,
				Z_LVAL_P(unique_id),
				prepared_ast,
				sizeof(zval *),
				NULL
			);
		}
	}

}

static void phalcon_orm_singlequotes(zval *return_value, zval *str TSRMLS_DC) {

	int i;
	smart_str  escaped_str = {0};
	char *marker;

	if (Z_TYPE_P(str) != IS_STRING) {
		RETURN_ZVAL(str, 1, 0);
	}

	marker = Z_STRVAL_P(str);

	for (i = 0; i < Z_STRLEN_P(str); i++) {
		if ((*marker) == '\0') {
			break;
		}
		if ((*marker) == '\'') {
			if (i > 0) {
				if (*(marker - 1) != '\\') {
					smart_str_appendc(&escaped_str, '\'');
				}
			} else {
				smart_str_appendc(&escaped_str, '\'');
			}
		}
		smart_str_appendc(&escaped_str, (*marker));
		marker++;
	}

	smart_str_0(&escaped_str);

	if (escaped_str.len) {
		RETURN_STRINGL(escaped_str.c, escaped_str.len, 0);
	} else {
		smart_str_free(&escaped_str);
		RETURN_EMPTY_STRING();
	}
}





#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_string.h>

zval *phalcon_replace_marker(int named, zval *paths, zval *replacements, unsigned long *position, char *cursor, char *marker){

	zval **zv, **tmp;
	int result = FAILURE;
	unsigned int length = 0, variable_length, ch, j;
	char *item = NULL, *cursor_var, *variable = NULL;
	int not_valid = 0;

	if (named) {
		length = cursor - marker - 1;
		item = estrndup(marker + 1, length);
		cursor_var = item;
		marker = item;
		for (j = 0; j < length; j++) {
			ch = *cursor_var;
			if (ch == '\0') {
				not_valid = 1;
				break;
			}
			if (j == 0 && !((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <= 'Z'))){
				not_valid = 1;
				break;
			}
			if ((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '-' || ch == '_' || ch ==  ':') {
				if (ch == ':') {
					variable_length = cursor_var - marker;
					variable = estrndup(marker, variable_length);
					break;
				}
			} else {
				not_valid = 1;
				break;
			}
			cursor_var++;
		}
	}

	if (!not_valid) {

		if (zend_hash_index_exists(Z_ARRVAL_P(paths), *position)) {
			if (named) {
				if (variable) {
					efree(item);
					item = variable;
					length = variable_length;
				}
				if (zend_hash_exists(Z_ARRVAL_P(replacements), item, length + 1)) {
					if ((result = zend_hash_find(Z_ARRVAL_P(replacements), item, length + 1, (void**) &zv)) == SUCCESS) {
						efree(item);
						(*position)++;
						return *zv;
					}
				}
			} else {
				if ((result = zend_hash_index_find(Z_ARRVAL_P(paths), *position, (void**) &zv)) == SUCCESS) {
					if (Z_TYPE_PP(zv) == IS_STRING) {
						if (zend_hash_exists(Z_ARRVAL_P(replacements), Z_STRVAL_PP(zv), Z_STRLEN_PP(zv) + 1)) {
							if ((result = zend_hash_find(Z_ARRVAL_P(replacements), Z_STRVAL_PP(zv), Z_STRLEN_PP(zv) + 1, (void**) &tmp)) == SUCCESS) {
								(*position)++;
								return *tmp;
							}
						}
					}
				}
			}
		}

		(*position)++;
	}

	if (item) {
		efree(item);
	}

	return NULL;
}

static void phalcon_replace_paths(zval *return_value, zval *pattern, zval *paths, zval *replacements TSRMLS_DC){

	char *cursor, *marker = NULL;
	unsigned int bracket_count = 0, parentheses_count = 0, intermediate = 0;
	unsigned char ch;
	smart_str route_str = {0};
	ulong position = 1;
	int i;
	zval *replace, replace_copy;
	int use_copy, looking_placeholder = 0;

	if (Z_TYPE_P(pattern) != IS_STRING || Z_TYPE_P(replacements) != IS_ARRAY || Z_TYPE_P(paths) != IS_ARRAY) {
		ZVAL_NULL(return_value);
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid arguments supplied for phalcon_replace_paths()");
		return;
	}

	if (Z_STRLEN_P(pattern) <= 0) {
		ZVAL_FALSE(return_value);
		return;
	}

	cursor = Z_STRVAL_P(pattern);
	if (*cursor == '/') {
		++cursor;
		i = 1;
	}
	else {
		i = 0;
	}

	if (!zend_hash_num_elements(Z_ARRVAL_P(paths))) {
		ZVAL_STRINGL(return_value, Z_STRVAL_P(pattern)+i, Z_STRLEN_P(pattern)-i, 1);
		return;
	}

	for (; i < Z_STRLEN_P(pattern); ++i) {

		ch = *cursor;
		if (ch == '\0') {
			break;
		}

		if (parentheses_count == 0 && !looking_placeholder) {
			if (ch == '{') {
				if (bracket_count == 0) {
					marker = cursor;
					intermediate = 0;
				}
				bracket_count++;
			} else {
				if (ch == '}') {
					bracket_count--;
					if (intermediate > 0) {
						if (bracket_count == 0) {
							replace = phalcon_replace_marker(1, paths, replacements, &position, cursor, marker);
							if (replace) {
								use_copy = 0;
								if (Z_TYPE_P(replace) != IS_STRING) {
									zend_make_printable_zval(replace, &replace_copy, &use_copy);
									if (use_copy) {
										replace = &replace_copy;
									}
								}
								smart_str_appendl(&route_str, Z_STRVAL_P(replace), Z_STRLEN_P(replace));
								if (use_copy) {
									zval_dtor(&replace_copy);
								}
							}
							cursor++;
							continue;
						}
					}
				}
			}
		}

		if (bracket_count == 0 && !looking_placeholder) {
			if (ch == '(') {
				if (parentheses_count == 0) {
					marker = cursor;
					intermediate = 0;
				}
				parentheses_count++;
			} else {
				if (ch == ')') {
					parentheses_count--;
					if (intermediate > 0) {
						if (parentheses_count == 0) {
							replace = phalcon_replace_marker(0, paths, replacements, &position, cursor, marker);
							if (replace) {
								use_copy = 0;
								if (Z_TYPE_P(replace) != IS_STRING) {
									zend_make_printable_zval(replace, &replace_copy, &use_copy);
									if (use_copy) {
										replace = &replace_copy;
									}
								}
								smart_str_appendl(&route_str, Z_STRVAL_P(replace), Z_STRLEN_P(replace));
								if (use_copy) {
									zval_dtor(&replace_copy);
								}
							}
							cursor++;
							continue;
						}
					}
				}
			}
		}

		if (bracket_count == 0 && parentheses_count == 0) {
			if (looking_placeholder) {
				if (intermediate > 0) {
					if (ch < 'a' || ch > 'z' || i == (Z_STRLEN_P(pattern) - 1)) {
						replace = phalcon_replace_marker(0, paths, replacements, &position, cursor, marker);
						if (replace) {
							use_copy = 0;
							if (Z_TYPE_P(replace) != IS_STRING) {
								zend_make_printable_zval(replace, &replace_copy, &use_copy);
								if (use_copy) {
									replace = &replace_copy;
								}
							}
							smart_str_appendl(&route_str, Z_STRVAL_P(replace), Z_STRLEN_P(replace));
							if (use_copy) {
								zval_dtor(&replace_copy);
							}
						}
						looking_placeholder = 0;
						continue;
					}
				}
			} else {
				if (ch == ':') {
					looking_placeholder = 1;
					marker = cursor;
					intermediate = 0;
				}
			}
		}

		if (bracket_count > 0 || parentheses_count > 0 || looking_placeholder) {
			intermediate++;
		} else {
			smart_str_appendc(&route_str, ch);
		}

		cursor++;
	}
	smart_str_0(&route_str);

	if (route_str.len) {
		RETURN_STRINGL(route_str.c, route_str.len, 0);
	} else {
		smart_str_free(&route_str);
		RETURN_EMPTY_STRING();
	}

}

static void phalcon_extract_named_params(zval *return_value, zval *str, zval *matches){

	int i, k;
	uint j, bracket_count = 0, parentheses_count = 0, ch;
	uint intermediate = 0, length, number_matches = 0, found_pattern;
	int variable_length, regexp_length = 0, not_valid = 0;
	char *cursor, *cursor_var, *marker = NULL;
	char *item, *variable = NULL, *regexp = NULL;
	smart_str route_str = {0};

	if (Z_TYPE_P(str) != IS_STRING || Z_STRLEN_P(str) <= 0 || Z_TYPE_P(matches) != IS_ARRAY) {
		ZVAL_FALSE(return_value);
		return;
	}

	cursor = Z_STRVAL_P(str);
	for (i = 0; i < Z_STRLEN_P(str); i++) {

		ch = *cursor;
		if (ch == '\0') {
			break;
		}

		if (parentheses_count == 0) {
			if (ch == '{') {
				if (bracket_count == 0) {
					marker = cursor;
					intermediate = 0;
					not_valid = 0;
				}
				bracket_count++;
			} else {
				if (ch == '}') {
					bracket_count--;
					if (intermediate > 0) {
						if (bracket_count == 0) {

							number_matches++;

							variable = NULL;
							length = cursor - marker - 1;
							item = estrndup(marker + 1, length);
							cursor_var = item;
							marker = item;
							for (j = 0; j < length; j++) {
								ch = *cursor_var;
								if (ch == '\0') {
									break;
								}
								if (j == 0 && !((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <='Z'))){
									not_valid = 1;
									break;
								}
								if ((ch >= 'a' && ch <='z') || (ch >= 'A' && ch <='Z') || (ch >= '0' && ch <='9') || ch == '-' || ch == '_' || ch ==  ':') {
									if (ch == ':') {
										regexp_length = length - j - 1;
										variable_length = cursor_var - marker;
										variable = estrndup(marker, variable_length);
										regexp = estrndup(cursor_var + 1, regexp_length);
										break;
									}
								} else {
									not_valid = 1;
									break;
								}
								cursor_var++;
							}

							if (!not_valid) {
								{
									zval *tmp;
									MAKE_STD_ZVAL(tmp);
									ZVAL_LONG(tmp, number_matches);

									if (variable) {
										if (regexp_length > 0) {
											ASSUME(regexp != NULL);

											found_pattern = 0;
											for (k = 0; k < regexp_length; k++) {
												if (regexp[k] == '\0') {
													break;
												}
												if (!found_pattern) {
													if (regexp[k] == '(') {
														found_pattern = 1;
													}
												} else {
													if (regexp[k] == ')') {
														found_pattern = 2;
														break;
													}
												}
											}

											if (found_pattern != 2) {
												smart_str_appendc(&route_str, '(');
												smart_str_appendl(&route_str, regexp, regexp_length);
												smart_str_appendc(&route_str, ')');
											} else {
												smart_str_appendl(&route_str, regexp, regexp_length);
											}
											zend_hash_update(Z_ARRVAL_P(matches), variable, variable_length + 1, &tmp, sizeof(zval *), NULL);
										}
										efree(regexp);
										efree(variable);
									} else {
										smart_str_appendl(&route_str, "([^/]*)", strlen("([^/]*)"));
										zend_hash_update(Z_ARRVAL_P(matches), item, length + 1, &tmp, sizeof(zval *), NULL);
									}
								}
							} else {
								smart_str_appendc(&route_str, '{');
								smart_str_appendl(&route_str, item, length);
								smart_str_appendc(&route_str, '}');
							}

							efree(item);

							cursor++;
							continue;
						}
					}
				}
			}

		}

		if (bracket_count == 0) {
			if (ch == '(') {
				parentheses_count++;
			} else {
				if (ch == ')') {
					parentheses_count--;
					if (parentheses_count == 0) {
						number_matches++;
					}
				}
			}
		}

		if (bracket_count > 0) {
			intermediate++;
		} else {
			smart_str_appendc(&route_str, ch);
		}

		cursor++;
	}
	smart_str_0(&route_str);

	if (route_str.len) {
		RETURN_STRINGL(route_str.c, route_str.len, 0);
	} else {
		smart_str_free(&route_str);
		RETURN_EMPTY_STRING();
	}

}





#include <ext/standard/url.h>

static void phalcon_get_uri(zval *return_value, zval *path) {

	int i, found = 0, mark = 0;
	char *cursor, *str, ch;

	if (Z_TYPE_P(path) != IS_STRING) {
		RETURN_EMPTY_STRING();
	}

	if (Z_STRLEN_P(path) > 0) {
		cursor = Z_STRVAL_P(path) + Z_STRLEN_P(path) - 1;
		for (i = Z_STRLEN_P(path); i > 0; i--) {
			ch = *cursor;
			if (ch == '/' || ch == '\\') {
				found++;
				if (found == 1) {
					mark = i - 1;
				} else {
					str = emalloc(mark - i + 1);
					memcpy(str, Z_STRVAL_P(path) + i, mark - i);
					str[mark - i] = '\0';
					ZVAL_STRINGL(return_value, str, mark - i, 0);
					return;
				}
			}
			cursor--;
		}
	}

	RETURN_EMPTY_STRING();
}

static void phalcon_raw_url_encode(zval *return_value, zval *url) {

	zval copy;
	char *escaped;
	int use_copy = 0, length;

	if (Z_TYPE_P(url) == IS_STRING) {
		zend_make_printable_zval(url, &copy, &use_copy);
		if (use_copy) {
			url = &copy;
		}
	}

	escaped = php_raw_url_encode(Z_STRVAL_P(url), Z_STRLEN_P(url), &length);

	if (use_copy) {
		zval_dtor(url);
	}

	if (escaped) {
		RETURN_STRINGL(escaped, length, 0);
	} else {
		RETURN_NULL();
	}
}




const char *phalcon_interned_DELETE         = NULL;
const char *phalcon_interned_GET            = NULL;
const char *phalcon_interned_HEAD           = NULL;
const char *phalcon_interned_OPTIONS        = NULL;
const char *phalcon_interned_PATCH          = NULL;
const char *phalcon_interned_POST           = NULL;
const char *phalcon_interned_PUT            = NULL;
const char *phalcon_interned_action         = NULL;
const char *phalcon_interned_alias          = NULL;
const char *phalcon_interned_all            = NULL;
const char *phalcon_interned_allowEmpty     = NULL;
const char *phalcon_interned_arguments      = NULL;
const char *phalcon_interned_balias         = NULL;
const char *phalcon_interned_binary_op      = NULL;
const char *phalcon_interned_code           = NULL;
const char *phalcon_interned_column         = NULL;
const char *phalcon_interned_columns        = NULL;
const char *phalcon_interned_conditions     = NULL;
const char *phalcon_interned_controller     = NULL;
const char *phalcon_interned_delete         = NULL;
const char *phalcon_interned_dispatcher     = NULL;
const char *phalcon_interned_distinct       = NULL;
const char *phalcon_interned_domain         = NULL;
const char *phalcon_interned_escaper        = NULL;
const char *phalcon_interned_expr           = NULL;
const char *phalcon_interned_fields         = NULL;
const char *phalcon_interned_file           = NULL;
const char *phalcon_interned_filter         = NULL;
const char *phalcon_interned_functionCall   = NULL;
const char *phalcon_interned_group          = NULL;
const char *phalcon_interned_groupBy        = NULL;
const char *phalcon_interned_having         = NULL;
const char *phalcon_interned_items          = NULL;
const char *phalcon_interned_joins          = NULL;
const char *phalcon_interned_label          = NULL;
const char *phalcon_interned_left           = NULL;
const char *phalcon_interned_limit          = NULL;
const char *phalcon_interned_line           = NULL;
const char *phalcon_interned_message        = NULL;
const char *phalcon_interned_model          = NULL;
const char *phalcon_interned_models         = NULL;
const char *phalcon_interned_modelsCache    = NULL;
const char *phalcon_interned_modelsManager  = NULL;
const char *phalcon_interned_modelsMetadata = NULL;
const char *phalcon_interned_module         = NULL;
const char *phalcon_interned_name           = NULL;
const char *phalcon_interned_namespace      = NULL;
const char *phalcon_interned_ns_alias       = NULL;
const char *phalcon_interned_number         = NULL;
const char *phalcon_interned_offset         = NULL;
const char *phalcon_interned_op             = NULL;
const char *phalcon_interned_order          = NULL;
const char *phalcon_interned_orderBy        = NULL;
const char *phalcon_interned_params         = NULL;
const char *phalcon_interned_parent         = NULL;
const char *phalcon_interned_paths          = NULL;
const char *phalcon_interned_qualified      = NULL;
const char *phalcon_interned_qualifiedName  = NULL;
const char *phalcon_interned_request        = NULL;
const char *phalcon_interned_response       = NULL;
const char *phalcon_interned_right          = NULL;
const char *phalcon_interned_router         = NULL;
const char *phalcon_interned_select         = NULL;
const char *phalcon_interned_self           = NULL;
const char *phalcon_interned_session        = NULL;
const char *phalcon_interned_sort           = NULL;
const char *phalcon_interned_source         = NULL;
const char *phalcon_interned_static         = NULL;
const char *phalcon_interned_sqlAlias       = NULL;
const char *phalcon_interned_table          = NULL;
const char *phalcon_interned_tables         = NULL;
const char *phalcon_interned_type           = NULL;
const char *phalcon_interned_update         = NULL;
const char *phalcon_interned_url            = NULL;
const char *phalcon_interned_value          = NULL;
const char *phalcon_interned_values         = NULL;
const char *phalcon_interned_where          = NULL;

PHALCON_STATIC void phalcon_init_interned_strings(TSRMLS_D)
{
	phalcon_interned_DELETE         = zend_new_interned_string(ZEND_STRS("DELETE"), 0 TSRMLS_CC);
	phalcon_interned_GET            = zend_new_interned_string(ZEND_STRS("GET"), 0 TSRMLS_CC);
	phalcon_interned_HEAD           = zend_new_interned_string(ZEND_STRS("HEAD"), 0 TSRMLS_CC);
	phalcon_interned_OPTIONS        = zend_new_interned_string(ZEND_STRS("OPTIONS"), 0 TSRMLS_CC);
	phalcon_interned_PATCH          = zend_new_interned_string(ZEND_STRS("PATCH"), 0 TSRMLS_CC);
	phalcon_interned_POST           = zend_new_interned_string(ZEND_STRS("POST"), 0 TSRMLS_CC);
	phalcon_interned_PUT            = zend_new_interned_string(ZEND_STRS("PUT"), 0 TSRMLS_CC);
	phalcon_interned_action         = zend_new_interned_string(ZEND_STRS("action"), 0 TSRMLS_CC);
	phalcon_interned_alias          = zend_new_interned_string(ZEND_STRS("alias"), 0 TSRMLS_CC);
	phalcon_interned_all            = zend_new_interned_string(ZEND_STRS("all"), 0 TSRMLS_CC);
	phalcon_interned_allowEmpty     = zend_new_interned_string(ZEND_STRS("allowEmpty"), 0 TSRMLS_CC);
	phalcon_interned_arguments      = zend_new_interned_string(ZEND_STRS("arguments"), 0 TSRMLS_CC);
	phalcon_interned_balias         = zend_new_interned_string(ZEND_STRS("balias"), 0 TSRMLS_CC);
	phalcon_interned_binary_op      = zend_new_interned_string(ZEND_STRS("binary-op"), 0 TSRMLS_CC);
	phalcon_interned_code           = zend_new_interned_string(ZEND_STRS("code"), 0 TSRMLS_CC);
	phalcon_interned_column         = zend_new_interned_string(ZEND_STRS("column"), 0 TSRMLS_CC);
	phalcon_interned_columns        = zend_new_interned_string(ZEND_STRS("columns"), 0 TSRMLS_CC);
	phalcon_interned_conditions     = zend_new_interned_string(ZEND_STRS("conditions"), 0 TSRMLS_CC);
	phalcon_interned_controller     = zend_new_interned_string(ZEND_STRS("controller"), 0 TSRMLS_CC);
	phalcon_interned_delete         = zend_new_interned_string(ZEND_STRS("delete"), 0 TSRMLS_CC);
	phalcon_interned_dispatcher     = zend_new_interned_string(ZEND_STRS("dispatcher"), 0 TSRMLS_CC);
	phalcon_interned_distinct       = zend_new_interned_string(ZEND_STRS("distinct"), 0 TSRMLS_CC);
	phalcon_interned_domain         = zend_new_interned_string(ZEND_STRS("domain"), 0 TSRMLS_CC);
	phalcon_interned_escaper        = zend_new_interned_string(ZEND_STRS("escaper"), 0 TSRMLS_CC);
	phalcon_interned_expr           = zend_new_interned_string(ZEND_STRS("expr"), 0 TSRMLS_CC);
	phalcon_interned_fields         = zend_new_interned_string(ZEND_STRS("fields"), 0 TSRMLS_CC);
	phalcon_interned_file           = zend_new_interned_string(ZEND_STRS("file"), 0 TSRMLS_CC);
	phalcon_interned_filter         = zend_new_interned_string(ZEND_STRS("filter"), 0 TSRMLS_CC);
	phalcon_interned_functionCall   = zend_new_interned_string(ZEND_STRS("functionCall"), 0 TSRMLS_CC);
	phalcon_interned_group          = zend_new_interned_string(ZEND_STRS("group"), 0 TSRMLS_CC);
	phalcon_interned_groupBy        = zend_new_interned_string(ZEND_STRS("groupBy"), 0 TSRMLS_CC);
	phalcon_interned_having         = zend_new_interned_string(ZEND_STRS("having"), 0 TSRMLS_CC);
	phalcon_interned_items          = zend_new_interned_string(ZEND_STRS("items"), 0 TSRMLS_CC);
	phalcon_interned_joins          = zend_new_interned_string(ZEND_STRS("joins"), 0 TSRMLS_CC);
	phalcon_interned_label          = zend_new_interned_string(ZEND_STRS("label"), 0 TSRMLS_CC);
	phalcon_interned_left           = zend_new_interned_string(ZEND_STRS("left"), 0 TSRMLS_CC);
	phalcon_interned_limit          = zend_new_interned_string(ZEND_STRS("limit"), 0 TSRMLS_CC);
	phalcon_interned_line           = zend_new_interned_string(ZEND_STRS("line"), 0 TSRMLS_CC);
	phalcon_interned_message        = zend_new_interned_string(ZEND_STRS("message"), 0 TSRMLS_CC);
	phalcon_interned_model          = zend_new_interned_string(ZEND_STRS("model"), 0 TSRMLS_CC);
	phalcon_interned_models         = zend_new_interned_string(ZEND_STRS("models"), 0 TSRMLS_CC);
	phalcon_interned_modelsCache    = zend_new_interned_string(ZEND_STRS("modelsCache"), 0 TSRMLS_CC);
	phalcon_interned_modelsManager  = zend_new_interned_string(ZEND_STRS("modelsManager"), 0 TSRMLS_CC);
	phalcon_interned_modelsMetadata = zend_new_interned_string(ZEND_STRS("modelsMetadata"), 0 TSRMLS_CC);
	phalcon_interned_module         = zend_new_interned_string(ZEND_STRS("module"), 0 TSRMLS_CC);
	phalcon_interned_name           = zend_new_interned_string(ZEND_STRS("name"), 0 TSRMLS_CC);
	phalcon_interned_namespace      = zend_new_interned_string(ZEND_STRS("namespace"), 0 TSRMLS_CC);
	phalcon_interned_ns_alias       = zend_new_interned_string(ZEND_STRS("ns-alias"), 0 TSRMLS_CC);
	phalcon_interned_number         = zend_new_interned_string(ZEND_STRS("number"), 0 TSRMLS_CC);
	phalcon_interned_offset         = zend_new_interned_string(ZEND_STRS("offset"), 0 TSRMLS_CC);
	phalcon_interned_op             = zend_new_interned_string(ZEND_STRS("op"), 0 TSRMLS_CC);
	phalcon_interned_order          = zend_new_interned_string(ZEND_STRS("order"), 0 TSRMLS_CC);
	phalcon_interned_orderBy        = zend_new_interned_string(ZEND_STRS("orderBy"), 0 TSRMLS_CC);
	phalcon_interned_params         = zend_new_interned_string(ZEND_STRS("params"), 0 TSRMLS_CC);
	phalcon_interned_parent         = zend_new_interned_string(ZEND_STRS("parent"), 0 TSRMLS_CC);
	phalcon_interned_paths          = zend_new_interned_string(ZEND_STRS("paths"), 0 TSRMLS_CC);
	phalcon_interned_qualified      = zend_new_interned_string(ZEND_STRS("qualified"), 0 TSRMLS_CC);
	phalcon_interned_qualifiedName  = zend_new_interned_string(ZEND_STRS("qualifiedName"), 0 TSRMLS_CC);
	phalcon_interned_request        = zend_new_interned_string(ZEND_STRS("request"), 0 TSRMLS_CC);
	phalcon_interned_response       = zend_new_interned_string(ZEND_STRS("response"), 0 TSRMLS_CC);
	phalcon_interned_right          = zend_new_interned_string(ZEND_STRS("right"), 0 TSRMLS_CC);
	phalcon_interned_router         = zend_new_interned_string(ZEND_STRS("router"), 0 TSRMLS_CC);
	phalcon_interned_select         = zend_new_interned_string(ZEND_STRS("select"), 0 TSRMLS_CC);
	phalcon_interned_self           = zend_new_interned_string(ZEND_STRS("self"), 0 TSRMLS_CC);
	phalcon_interned_session        = zend_new_interned_string(ZEND_STRS("session"), 0 TSRMLS_CC);
	phalcon_interned_sort           = zend_new_interned_string(ZEND_STRS("sort"), 0 TSRMLS_CC);
	phalcon_interned_source         = zend_new_interned_string(ZEND_STRS("source"), 0 TSRMLS_CC);
	phalcon_interned_static         = zend_new_interned_string(ZEND_STRS("static"), 0 TSRMLS_CC);
	phalcon_interned_sqlAlias       = zend_new_interned_string(ZEND_STRS("sqlAlias"), 0 TSRMLS_CC);
	phalcon_interned_table          = zend_new_interned_string(ZEND_STRS("table"), 0 TSRMLS_CC);
	phalcon_interned_tables         = zend_new_interned_string(ZEND_STRS("tables"), 0 TSRMLS_CC);
	phalcon_interned_type           = zend_new_interned_string(ZEND_STRS("type"), 0 TSRMLS_CC);
	phalcon_interned_update         = zend_new_interned_string(ZEND_STRS("update"), 0 TSRMLS_CC);
	phalcon_interned_url            = zend_new_interned_string(ZEND_STRS("url"), 0 TSRMLS_CC);
	phalcon_interned_value          = zend_new_interned_string(ZEND_STRS("value"), 0 TSRMLS_CC);
	phalcon_interned_values         = zend_new_interned_string(ZEND_STRS("values"), 0 TSRMLS_CC);
	phalcon_interned_where          = zend_new_interned_string(ZEND_STRS("where"), 0 TSRMLS_CC);
}



#ifndef PHALCON_INTERNAL_ARGINFO_H
#define PHALCON_INTERNAL_ARGINFO_H

#include <Zend/zend.h>
#include <Zend/zend_API.h>


ZEND_BEGIN_ARG_INFO_EX(arginfo_empty, 0, 0, 0)
ZEND_END_ARG_INFO()


/** @brief & __get($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___getref, 0, 1, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

/** @brief __get($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___get, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

/** @brief __set($property, $value) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___set, 0, 0, 2)
	ZEND_ARG_INFO(0, property)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

/** @brief __isset($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___isset, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

/** @brief __unset($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___unset, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

/** @brief __call($method, array $arguments) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___call, 0, 0, 1)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_ARRAY_INFO(0, arguments, 0)
ZEND_END_ARG_INFO()

/** @brief __callStatic($method, array $arguments) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___callstatic, 0, 0, 1)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_ARRAY_INFO(0, arguments, 0)
ZEND_END_ARG_INFO()

/** @brief __toString() */
ZEND_BEGIN_ARG_INFO_EX(arginfo___tostring, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief __destruct() */
ZEND_BEGIN_ARG_INFO_EX(arginfo___destruct, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief __set_state(array $properties) */
ZEND_BEGIN_ARG_INFO_EX(arginfo___set_state, 0, 0, 0)
	ZEND_ARG_ARRAY_INFO(0, properties, 0)
ZEND_END_ARG_INFO()

/** @brief IteratorAggregate::getIterator() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iteratoraggregate_getiterator, 0, 0, 0)
ZEND_END_ARG_INFO()


/** @brief Countable::count() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_countable_count, 0, 0, 0)
ZEND_END_ARG_INFO()


/** @brief ArrayAccess::offsetGet($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetget, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

#if PHP_VERSION_ID >= 50304

/** @brief & ArrayAccess::offsetGet($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetgetref, 0, 1, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

#else

/** @brief ArrayAccess::offsetGet($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetgetref, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

#endif

/** @brief ArrayAccess::offsetSet($property, $value) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetset, 0, 0, 2)
	ZEND_ARG_INFO(0, property)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

/** @brief ArrayAccess::offsetExists($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetexists, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

/** @brief ArrayAccess::offsetUnset($property) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_arrayaccess_offsetunset, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()


/** @brief Iterator::current() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_current, 0, 0, 0)
ZEND_END_ARG_INFO()

#if PHP_VERSION_ID >= 50304
/** @brief & Iterator::current() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_currentref, 0, 1, 0)
ZEND_END_ARG_INFO()
#else
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_currentref, 0, 0, 0)
ZEND_END_ARG_INFO()
#endif

/** @brief Iterator::key() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_key, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief Iterator::next() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_next, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief Iterator::rewind() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_rewind, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief Iterator::valid() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_iterator_valid, 0, 0, 0)
ZEND_END_ARG_INFO()


/** @brief SeekableIterator::seek($position) */
ZEND_BEGIN_ARG_INFO_EX(arginfo_seekableiterator_seek, 0, 0, 1)
	ZEND_ARG_INFO(0, position)
ZEND_END_ARG_INFO()


/** @brief JsonSerializable::jsonSerialize() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_jsonserializable_jsonserialize, 0, 0, 0)
ZEND_END_ARG_INFO()


/** @brief Serializable::serialize() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_serializable_serialize, 0, 0, 0)
ZEND_END_ARG_INFO()

/** @brief Serializable::unserialize() */
ZEND_BEGIN_ARG_INFO_EX(arginfo_serializable_unserialize, 0, 0, 0)
	ZEND_ARG_INFO(0, serialized)
ZEND_END_ARG_INFO()

#endif /* PHALCON_INTERNAL_ARGINFO_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_DISPATCHER_H
#define PHALCON_DISPATCHER_H


zend_class_entry *phalcon_dispatcher_ce;

PHALCON_INIT_CLASS(Phalcon_Dispatcher);

#endif /* PHALCON_DISPATCHER_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */



#ifndef PHALCON_FORMS_ELEMENT_HELPERS_H
#define PHALCON_FORMS_ELEMENT_HELPERS_H


static inline void phalcon_forms_element_render_helper(const char *method, int use_checked, INTERNAL_FUNCTION_PARAMETERS)
{
	zval **attributes = NULL, *widget_attributes = NULL, *uc;
	zval *params[1];

	phalcon_fetch_params_ex(0, 1, &attributes);

	if (!attributes) {
		attributes = &PHALCON_GLOBAL(z_null);
	}

	uc = use_checked ? PHALCON_GLOBAL(z_true) : PHALCON_GLOBAL(z_false);

	PHALCON_CALL_METHODW(&widget_attributes, getThis(), "prepareattributes", *attributes, uc);

	params[0] = widget_attributes;
	if (FAILURE == phalcon_return_call_class_method(return_value, return_value_ptr, phalcon_tag_ce, phalcon_fcall_ce, NULL, method, strlen(method), 1, params TSRMLS_CC)) {
		;
	}

	zval_ptr_dtor(&widget_attributes);
}

#endif /* PHALCON_FORMS_ELEMENT_HELPERS_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_DISPATCHERINTERFACE_H
#define PHALCON_DISPATCHERINTERFACE_H


zend_class_entry *phalcon_dispatcherinterface_ce;

PHALCON_INIT_CLASS(Phalcon_DispatcherInterface);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setactionsuffix, 0, 0, 1)
	ZEND_ARG_INFO(0, actionSuffix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setdefaultnamespace, 0, 0, 1)
	ZEND_ARG_INFO(0, namespace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setdefaultaction, 0, 0, 1)
	ZEND_ARG_INFO(0, actionName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setactionname, 0, 0, 1)
	ZEND_ARG_INFO(0, actionName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setparams, 0, 0, 1)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_setparam, 0, 0, 2)
	ZEND_ARG_INFO(0, param)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_getparam, 0, 0, 1)
	ZEND_ARG_INFO(0, param)
	ZEND_ARG_INFO(0, filters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcherinterface_forward, 0, 0, 1)
	ZEND_ARG_INFO(0, forward)
ZEND_END_ARG_INFO()

#endif /* PHALCON_DISPATCHERINTERFACE_H */




#ifndef PHALCON_DISPATCHER_H
#define PHALCON_DISPATCHER_H


zend_class_entry *phalcon_dispatcher_ce;

PHALCON_INIT_CLASS(Phalcon_Dispatcher);

#endif /* PHALCON_DISPATCHER_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */



#ifndef PHALCON_MVC_VIEW_ENGINE_HELPERS_H
#define PHALCON_MVC_VIEW_ENGINE_HELPERS_H


PHALCON_STATIC zend_bool phalcon_mvc_view_engine_php_symtable_merger(HashTable *ht, void *pData, zend_hash_key *hash_key, void *pParam);

#endif /* PHALCON_MBC_VIEW_ENGINE_HELPERS_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */




#ifndef PHALCON_EXCEPTION_H
#define PHALCON_EXCEPTION_H


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception);

#endif /* PHALCON_EXCEPTION_H */





zend_class_entry *phalcon_acl_ce;

PHALCON_INIT_CLASS(Phalcon_Acl){

	PHALCON_REGISTER_CLASS(Phalcon, Acl, acl, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_acl_ce, SL("ALLOW"), PHALCON_ACL_ALLOW TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_acl_ce, SL("DENY"), PHALCON_ACL_DENY TSRMLS_CC);

	return SUCCESS;
}







zend_class_entry *phalcon_config_ce;

static PHP_METHOD(Phalcon_Config, __construct);
static PHP_METHOD(Phalcon_Config, offsetExists);
static PHP_METHOD(Phalcon_Config, get);
static PHP_METHOD(Phalcon_Config, offsetGet);
static PHP_METHOD(Phalcon_Config, offsetSet);
static PHP_METHOD(Phalcon_Config, offsetUnset);
static PHP_METHOD(Phalcon_Config, merge);
static PHP_METHOD(Phalcon_Config, toArray);
static PHP_METHOD(Phalcon_Config, count);
static PHP_METHOD(Phalcon_Config, __wakeup);
static PHP_METHOD(Phalcon_Config, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, arrayConfig)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_get, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
	ZEND_ARG_INFO(0, defaultValue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_merge, 0, 0, 1)
	ZEND_ARG_INFO(0, config)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_toarray, 0, 0, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config___wakeup, 0, 0, 0)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_config_method_entry[] = {
	PHP_ME(Phalcon_Config, __construct, arginfo_phalcon_config___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Config, offsetExists, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, get, arginfo_phalcon_config_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, offsetGet, arginfo_arrayaccess_offsetget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, offsetSet, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, offsetUnset, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, merge, arginfo_phalcon_config_merge, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, toArray, arginfo_phalcon_config_toarray, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, count, arginfo_countable_count, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, __wakeup, arginfo_phalcon_config___wakeup, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Config, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_MALIAS(Phalcon_Config, __get, offsetGet, arginfo___get, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Config, __set, offsetSet, arginfo___set, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Config, __isset, offsetExists, arginfo___isset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Config, __unset, offsetUnset, arginfo___unset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


static zend_object_handlers phalcon_config_object_handlers;

typedef struct _phalcon_config_object {
	zend_object obj;  /**< Zend object data */
	HashTable* props; /**< Properties */
} phalcon_config_object;

static inline phalcon_config_object* fetchPhalconConfigObject(zval* zobj TSRMLS_DC)
{
	return (phalcon_config_object*)zend_objects_get_address(zobj TSRMLS_CC);
}

static int phalcon_config_count_elements(zval *object, long int *count TSRMLS_DC)
{
	phalcon_config_object* obj = fetchPhalconConfigObject(object TSRMLS_CC);
	*count = zend_hash_num_elements(obj->props);
	return SUCCESS;
}

static zval* phalcon_config_read_internal(phalcon_config_object *object, zval *key, int type TSRMLS_DC)
{
	zval **retval;

	if (UNEXPECTED(!key)) {
		return EG(uninitialized_zval_ptr);
	}

	retval = phalcon_hash_get(object->props, key, type);
	return retval ? *retval : NULL;
}

static zval* phalcon_config_read_property(zval *object, zval *offset, int type ZLK_DC TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		if (BP_VAR_IS == type && !zend_get_std_object_handlers()->has_property(object, offset, 0 ZLK_CC TSRMLS_CC)) {
			return EG(uninitialized_zval_ptr);
		}

		return zend_get_std_object_handlers()->read_property(object, offset, type ZLK_CC TSRMLS_CC);
	}

	return phalcon_config_read_internal(obj, offset, type TSRMLS_CC);
}

static zval* phalcon_config_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		if (BP_VAR_IS == type && !zend_get_std_object_handlers()->has_dimension(object, offset, 0 TSRMLS_CC)) {
			return EG(uninitialized_zval_ptr);
		}

		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	return phalcon_config_read_internal(obj, offset, type TSRMLS_CC);
}

static void phalcon_config_write_internal(phalcon_config_object *object, zval *offset, zval *value TSRMLS_DC)
{
	if (Z_TYPE_P(value) == IS_ARRAY) {
		zval *instance;
		HashTable *h = Z_ARRVAL_P(value);

		if (!h->nApplyCount) {
			++h->nApplyCount;
			MAKE_STD_ZVAL(instance);
			object_init_ex(instance, phalcon_config_ce);
			phalcon_config_construct_internal(instance, value TSRMLS_CC);
			phalcon_hash_update_or_insert(object->props, offset, instance);
			--h->nApplyCount;
		}
		else {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Recursion detected");
		}
	}
	else {
		Z_ADDREF_P(value);
		phalcon_hash_update_or_insert(object->props, offset, value);
	}
}

static void phalcon_config_write_property(zval *object, zval *offset, zval *value ZLK_DC TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->write_property(object, offset, value ZLK_CC TSRMLS_CC);
		return;
	}

	phalcon_config_write_internal(obj, offset, value TSRMLS_CC);
}

static void phalcon_config_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->write_dimension(object, offset, value TSRMLS_CC);
		return;
	}

	phalcon_config_write_internal(obj, offset, value TSRMLS_CC);
}

static int phalcon_config_has_internal(phalcon_config_object *object, zval *key, int check_empty TSRMLS_DC)
{
	zval **tmp = phalcon_hash_get(object->props, key, BP_VAR_NA);

	if (!tmp) {
		return 0;
	}

	if (0 == check_empty) {
		return Z_TYPE_PP(tmp) != IS_NULL;
	}

	if (1 == check_empty) {
		return zend_is_true(*tmp);
	}

	return 1;
}

static int phalcon_config_has_property(zval *object, zval *offset, int has_set_exists ZLK_DC TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		return zend_get_std_object_handlers()->has_property(object, offset, has_set_exists ZLK_CC TSRMLS_CC);
	}

	return phalcon_config_has_internal(obj, offset, 0 TSRMLS_CC);
}

static int phalcon_config_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	return phalcon_config_has_internal(obj, offset, check_empty TSRMLS_CC);
}

static void phalcon_config_unset_internal(phalcon_config_object *obj, zval *key TSRMLS_DC)
{
	phalcon_hash_unset(obj->props, key);
}

static void phalcon_config_unset_property(zval *object, zval *member ZLK_DC TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->unset_property(object, member ZLK_CC TSRMLS_CC);
		return;
	}

	phalcon_config_unset_internal(obj, member TSRMLS_CC);
}

static void phalcon_config_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->unset_dimension(object, offset TSRMLS_CC);
		return;
	}

	phalcon_config_unset_internal(obj, offset TSRMLS_CC);
}

static HashTable* phalcon_config_get_properties(zval* object TSRMLS_DC)
{
	HashTable* props = zend_std_get_properties(object TSRMLS_CC);

	if (!GC_G(gc_active)) {
		phalcon_config_object* obj = fetchPhalconConfigObject(object TSRMLS_CC);
		zend_hash_copy(props, obj->props, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
	}

	return props;
}

static int phalcon_config_compare_objects(zval *object1, zval *object2 TSRMLS_DC)
{
	phalcon_config_object *zobj1, *zobj2;
	zval result;

	zobj1 = fetchPhalconConfigObject(object1 TSRMLS_CC);
	zobj2 = fetchPhalconConfigObject(object2 TSRMLS_CC);

	if (zobj1->obj.ce != zobj2->obj.ce) {
		return 1;
	}

	if (zobj1->props == zobj2->props) {
		return 0;
	}

	zend_compare_symbol_tables(&result, zobj1->props, zobj2->props TSRMLS_CC);
	assert(Z_TYPE_P(&result) == IS_LONG);
	return Z_LVAL_P(&result);
}

static void phalcon_config_object_dtor(void* v TSRMLS_DC)
{
	phalcon_config_object* obj = v;

	zend_hash_destroy(obj->props);
	FREE_HASHTABLE(obj->props);
	zend_object_std_dtor(&(obj->obj) TSRMLS_CC);
	efree(obj);
}

static zend_object_value phalcon_config_object_ctor(zend_class_entry* ce TSRMLS_DC)
{
	phalcon_config_object *obj = ecalloc(1, sizeof(phalcon_config_object));
	zend_object_value retval;

	zend_object_std_init(&obj->obj, ce TSRMLS_CC);
	object_properties_init(&obj->obj, ce);

	ALLOC_HASHTABLE(obj->props);
	zend_hash_init(obj->props, 0, NULL, ZVAL_PTR_DTOR, 0);

	retval.handle = zend_objects_store_put(
		obj,
		(zend_objects_store_dtor_t)zend_objects_destroy_object,
		phalcon_config_object_dtor,
		NULL
		TSRMLS_CC
	);

	retval.handlers = &phalcon_config_object_handlers;

	return retval;
}

static zend_object_value phalcon_config_clone_obj(zval *object TSRMLS_DC)
{
	phalcon_config_object *orig  = fetchPhalconConfigObject(object TSRMLS_CC);
	zend_object_value result     = phalcon_config_object_ctor(Z_OBJCE_P(object) TSRMLS_CC);
	phalcon_config_object *clone = zend_object_store_get_object_by_handle(result.handle TSRMLS_CC);

	zend_objects_clone_members(&clone->obj, result, &orig->obj, Z_OBJ_HANDLE_P(object) TSRMLS_CC);
	zend_hash_copy(clone->props, orig->props, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));

	return result;
}

PHALCON_INIT_CLASS(Phalcon_Config){

	PHALCON_REGISTER_CLASS(Phalcon, Config, config, phalcon_config_method_entry, 0);

	phalcon_config_ce->create_object = phalcon_config_object_ctor;

	phalcon_config_object_handlers = *zend_get_std_object_handlers();
	phalcon_config_object_handlers.count_elements  = phalcon_config_count_elements;
	phalcon_config_object_handlers.read_property   = phalcon_config_read_property;
	phalcon_config_object_handlers.write_property  = phalcon_config_write_property;
	phalcon_config_object_handlers.unset_property  = phalcon_config_unset_property;
	phalcon_config_object_handlers.has_property    = phalcon_config_has_property;
	phalcon_config_object_handlers.read_dimension  = phalcon_config_read_dimension;
	phalcon_config_object_handlers.write_dimension = phalcon_config_write_dimension;
	phalcon_config_object_handlers.unset_dimension = phalcon_config_unset_dimension;
	phalcon_config_object_handlers.has_dimension   = phalcon_config_has_dimension;
	phalcon_config_object_handlers.get_properties  = phalcon_config_get_properties;
	phalcon_config_object_handlers.compare_objects = phalcon_config_compare_objects;
	phalcon_config_object_handlers.clone_obj       = phalcon_config_clone_obj;

	zend_class_implements(phalcon_config_ce TSRMLS_CC, 2, zend_ce_arrayaccess, spl_ce_Countable);

	return SUCCESS;
}

static void phalcon_config_construct_internal(zval* this_ptr, zval *array_config TSRMLS_DC)
{
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	phalcon_config_object* obj;

	if (!array_config || Z_TYPE_P(array_config) == IS_NULL) {
		return;
	}

	phalcon_is_iterable(array_config, &ah0, &hp0, 0, 0);

	obj = fetchPhalconConfigObject(getThis() TSRMLS_CC);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
		zval key = phalcon_get_current_key_w(ah0, &hp0);
		phalcon_config_write_internal(obj, &key, *hd TSRMLS_CC);
		zend_hash_move_forward_ex(ah0, &hp0);
	}
}

PHALCON_ATTR_WARN_UNUSED_RESULT static int phalcon_config_toarray_internal(zval **return_value_ptr, zval *this_ptr TSRMLS_DC)
{
	phalcon_config_object *obj = fetchPhalconConfigObject(this_ptr TSRMLS_CC);
	int result;

	assert(!EG(exception));
	if (likely(obj->obj.ce == phalcon_config_ce)) {
		zval *tmp;
		array_init_size(*return_value_ptr, zend_hash_num_elements(obj->props));
		zend_hash_copy(Z_ARRVAL_PP(return_value_ptr), obj->props, (copy_ctor_func_t)zval_add_ref, (void*)&tmp, sizeof(zval*));
		return SUCCESS;
	}

	if (phalcon_method_quick_exists_ex(this_ptr, SS("toarray"), 3566966151UL TSRMLS_CC) == SUCCESS) {
		zval *return_value = *return_value_ptr;
		result = phalcon_return_call_method(return_value, return_value_ptr, this_ptr, "toarray", 0, NULL TSRMLS_CC);
	}
	else {
		zval *params[] = { this_ptr };
		zval *return_value = *return_value_ptr;
		result = phalcon_return_call_function(return_value, return_value_ptr, SL("get_object_vars"), 1, params TSRMLS_CC);
	}

	return result;
}

static PHP_METHOD(Phalcon_Config, __construct){

	zval *array_config = NULL;

	phalcon_fetch_params(0, 0, 1, &array_config);
	
	if (array_config && Z_TYPE_P(array_config) != IS_ARRAY && Z_TYPE_P(array_config) != IS_NULL) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_config_exception_ce, "The configuration must be an Array");
		return;
	}

	phalcon_config_construct_internal(getThis(), array_config TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Config, offsetExists){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	RETURN_BOOL(phalcon_config_has_internal(fetchPhalconConfigObject(getThis() TSRMLS_CC), index, 0 TSRMLS_CC));
}

static PHP_METHOD(Phalcon_Config, get){

	zval *index, *default_value = NULL, *value;

	phalcon_fetch_params(0, 1, 1, &index, &default_value);

	value = phalcon_config_read_internal(fetchPhalconConfigObject(getThis() TSRMLS_CC), index, BP_VAR_NA TSRMLS_CC);
	if (!value || Z_TYPE_P(value) == IS_NULL) {
		if (default_value) {
			RETURN_ZVAL(default_value, 1, 0);
		}

		RETURN_NULL();
	}

	RETURN_ZVAL(value, 1, 0);
}

static PHP_METHOD(Phalcon_Config, offsetGet){

	zval *index;
	zval* retval;

	phalcon_fetch_params(0, 1, 0, &index);

	retval = phalcon_config_read_internal(fetchPhalconConfigObject(getThis() TSRMLS_CC), index, BP_VAR_R TSRMLS_CC);
	RETURN_ZVAL(retval, 1, 0);
}

static PHP_METHOD(Phalcon_Config, offsetSet){

	zval *index, *value;

	phalcon_fetch_params(0, 2, 0, &index, &value);
	phalcon_config_write_internal(fetchPhalconConfigObject(getThis() TSRMLS_CC), index, value TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Config, offsetUnset){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	phalcon_config_unset_internal(fetchPhalconConfigObject(getThis() TSRMLS_CC), index TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Config, merge){

	zval *config, *array_config = NULL, key, *active_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	phalcon_config_object *obj;

	phalcon_fetch_params(0, 1, 0, &config);
	
	if (Z_TYPE_P(config) != IS_OBJECT && Z_TYPE_P(config) != IS_ARRAY) {
		zend_throw_exception_ex(phalcon_config_exception_ce, 0 TSRMLS_CC, "Configuration must be an object or array");
		return;
	}

	if (Z_TYPE_P(config) == IS_OBJECT) {
		ALLOC_INIT_ZVAL(array_config);
		if (FAILURE == phalcon_config_toarray_internal(&array_config, config TSRMLS_CC)) {
			zval_ptr_dtor(&array_config);
			return;
		}
	}
	else {
		array_config = config;
		Z_ADDREF_P(array_config);
	}
	
	phalcon_is_iterable(array_config, &ah0, &hp0, 0, 0);
	
	obj = fetchPhalconConfigObject(getThis() TSRMLS_CC);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		key = phalcon_get_current_key_w(ah0, &hp0);
	
		active_value = phalcon_config_read_internal(obj, &key, BP_VAR_NA TSRMLS_CC);

		if (active_value) {
			if ((Z_TYPE_PP(hd)  == IS_OBJECT || Z_TYPE_PP(hd) == IS_ARRAY) && Z_TYPE_P(active_value) == IS_OBJECT) {
				if (phalcon_method_quick_exists_ex(active_value, SS("merge"), 226837141UL TSRMLS_CC) == SUCCESS) { /* Path AAA in the test */
					zval *params[] = { *hd };
					if (FAILURE == phalcon_call_method(NULL, active_value, "merge", 1, params TSRMLS_CC)) {
						break;
					}
				}
				else { /* Path AAB in the test */
					phalcon_config_write_internal(obj, &key, *hd TSRMLS_CC);
				}
			}
			else { /* Path AE in the test */
				phalcon_config_write_internal(obj, &key, *hd TSRMLS_CC);
			}
		}
		else { /* Path B in the test */
			phalcon_config_write_internal(obj, &key, *hd TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	zval_ptr_dtor(&array_config);
}

static PHP_METHOD(Phalcon_Config, toArray){

	zval *recursive = NULL, *tmp;
	phalcon_config_object *obj;

	phalcon_fetch_params(0, 0, 1, &recursive);

	obj = fetchPhalconConfigObject(getThis() TSRMLS_CC);
	array_init_size(return_value, zend_hash_num_elements(obj->props));
	zend_hash_copy(Z_ARRVAL_P(return_value), obj->props, (copy_ctor_func_t)zval_add_ref, (void*)&tmp, sizeof(zval*));

	if (!recursive || zend_is_true(recursive)) {
		zval **value;
		HashPosition hp;

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(return_value), &hp);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(return_value), (void**)&value, &hp) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(return_value), &hp)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(return_value), &hp);

			if (Z_TYPE_PP(value) == IS_OBJECT && phalcon_method_exists_ex(*value, SS("toarray") TSRMLS_CC) == SUCCESS) {
				zval *array_value = NULL;
				if (FAILURE == phalcon_call_method(&array_value, *value, "toarray", 0, NULL TSRMLS_CC)) {
					break;
				}

				phalcon_array_update_zval(&return_value, &key, array_value, 0);
			}
		}
	}
}

static PHP_METHOD(Phalcon_Config, count)
{
	long int cnt;

	phalcon_config_count_elements(getThis(), &cnt TSRMLS_CC);
	RETURN_LONG(cnt);
}

static PHP_METHOD(Phalcon_Config, __wakeup)
{
	HashTable *props;
	phalcon_config_object *obj;

	obj   = fetchPhalconConfigObject(getThis() TSRMLS_CC);
	props = zend_std_get_properties(getThis() TSRMLS_CC);
	zend_hash_copy(obj->props, props, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
}

static PHP_METHOD(Phalcon_Config, __set_state){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);

	object_init_ex(return_value, phalcon_config_ce);
	phalcon_config_construct_internal(return_value, data TSRMLS_CC);
}





#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_string.h>
#include <ext/standard/base64.h>



zend_class_entry *phalcon_crypt_ce;

static PHP_METHOD(Phalcon_Crypt, setCipher);
static PHP_METHOD(Phalcon_Crypt, getCipher);
static PHP_METHOD(Phalcon_Crypt, setMode);
static PHP_METHOD(Phalcon_Crypt, getMode);
static PHP_METHOD(Phalcon_Crypt, setKey);
static PHP_METHOD(Phalcon_Crypt, getKey);
static PHP_METHOD(Phalcon_Crypt, setPadding);
static PHP_METHOD(Phalcon_Crypt, getPadding);
static PHP_METHOD(Phalcon_Crypt, encrypt);
static PHP_METHOD(Phalcon_Crypt, decrypt);
static PHP_METHOD(Phalcon_Crypt, encryptBase64);
static PHP_METHOD(Phalcon_Crypt, decryptBase64);
static PHP_METHOD(Phalcon_Crypt, getAvailableCiphers);
static PHP_METHOD(Phalcon_Crypt, getAvailableModes);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_crypt_getpadding, 0, 0, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_crypt_setpadding, 0, 0, 1)
	ZEND_ARG_INFO(0, scheme)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_crypt_method_entry[] = {
	PHP_ME(Phalcon_Crypt, setCipher, arginfo_phalcon_cryptinterface_setcipher, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getCipher, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, setMode, arginfo_phalcon_cryptinterface_setmode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getMode, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, setKey, arginfo_phalcon_cryptinterface_setkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getKey, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, setPadding, arginfo_phalcon_crypt_setpadding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getPadding, arginfo_phalcon_crypt_getpadding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, encrypt, arginfo_phalcon_cryptinterface_encrypt, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, decrypt, arginfo_phalcon_cryptinterface_decrypt, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, encryptBase64, arginfo_phalcon_cryptinterface_encryptbase64, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, decryptBase64, arginfo_phalcon_cryptinterface_decryptbase64, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getAvailableCiphers, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Crypt, getAvailableModes, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Crypt){

	PHALCON_REGISTER_CLASS(Phalcon, Crypt, crypt, phalcon_crypt_method_entry, 0);

	zend_declare_property_null(phalcon_crypt_ce, SL("_key"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_crypt_ce, SL("_mode"), "cbc", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_crypt_ce, SL("_cipher"), "rijndael-256", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_crypt_ce, SL("_padding"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_crypt_ce TSRMLS_CC, 1, phalcon_cryptinterface_ce);

	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_DEFAULT"),        PHALCON_CRYPT_PADDING_DEFAULT        TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_ANSI_X_923"),     PHALCON_CRYPT_PADDING_ANSI_X_923     TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_PKCS7"),          PHALCON_CRYPT_PADDING_PKCS7          TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_ISO_10126"),      PHALCON_CRYPT_PADDING_ISO_10126      TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_ISO_IEC_7816_4"), PHALCON_CRYPT_PADDING_ISO_IEC_7816_4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_ZERO"),           PHALCON_CRYPT_PADDING_ZERO           TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_crypt_ce, SL("PADDING_SPACE"),          PHALCON_CRYPT_PADDING_SPACE          TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Crypt, setCipher){

	zval *cipher;

	phalcon_fetch_params(0, 1, 0, &cipher);

	phalcon_update_property_this_quick(this_ptr, SL("_cipher"), cipher, 3925470815UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Crypt, getCipher){


	RETURN_MEMBER_QUICK(this_ptr, "_cipher", 3925470815UL);
}

static PHP_METHOD(Phalcon_Crypt, setMode){

	zval **mode;

	phalcon_fetch_params_ex(1, 0, &mode);
	PHALCON_ENSURE_IS_STRING(mode);

	phalcon_update_property_this(this_ptr, SL("_mode"), *mode TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Crypt, getMode){


	RETURN_MEMBER_QUICK(this_ptr, "_mode", 3983285225UL);
}

static PHP_METHOD(Phalcon_Crypt, setKey){

	zval **key;

	phalcon_fetch_params_ex(1, 0, &key);
	PHALCON_ENSURE_IS_STRING(key);

	phalcon_update_property_this(this_ptr, SL("_key"), *key TSRMLS_CC);
	RETURN_THISW();
}


static PHP_METHOD(Phalcon_Crypt, getKey){


	RETURN_MEMBER_QUICK(this_ptr, "_key", 250773965UL);
}

static PHP_METHOD(Phalcon_Crypt, setPadding) {

	zval **scheme;

	phalcon_fetch_params_ex(1, 0, &scheme);
	PHALCON_ENSURE_IS_LONG(scheme);

	phalcon_update_property_this(this_ptr, SL("_padding"), *scheme TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Crypt, getPadding) {

	RETURN_MEMBER_QUICK(this_ptr, "_padding", 2759428059UL);
}

static void phalcon_crypt_pad_text(zval *return_value, zval *text, zval *mode, uint block_size, int padding_type TSRMLS_DC)
{
	uint padding_size, i;
	char padding[256];
	char *str_mode;

	assert(Z_TYPE_P(text) == IS_STRING);
	assert(Z_TYPE_P(mode) == IS_STRING);

	padding_size = 0;
	str_mode = Z_STRVAL_P(mode);

	if (!strcmp(str_mode, "ecb") || !strcmp(str_mode, "cbc")) {

		padding_size = block_size - (Z_STRLEN_P(text) % block_size);
		if (padding_size >= 256) {
			RETURN_MM_FALSE;
		}

		switch (padding_type) {
			case PHALCON_CRYPT_PADDING_ANSI_X_923:
				memset(padding, 0, padding_size - 1);
				padding[padding_size-1] = (unsigned char)padding_size;
				break;

			case PHALCON_CRYPT_PADDING_PKCS7:
				memset(padding, padding_size, padding_size);
				break;

			case PHALCON_CRYPT_PADDING_ISO_10126:
				for (i = 0; i < padding_size - 1; ++i) {
					padding[i] = (unsigned char)rand();
				}

				padding[padding_size - 1] = (unsigned char)padding_size;
				break;

			case PHALCON_CRYPT_PADDING_ISO_IEC_7816_4:
				padding[0] = 0x80;
				memset(padding + 1, 0, padding_size - 1);
				break;

			case PHALCON_CRYPT_PADDING_ZERO:
				memset(padding, 0, padding_size);
				break;

			case PHALCON_CRYPT_PADDING_SPACE:
				memset(padding, 0x20, padding_size);
				break;

			default:
				padding_size = 0;
				break;
		}
	}

	if (!padding_size) {
		ZVAL_ZVAL(return_value, text, 1, 0);
	}
	else {
		assert(padding_size <= block_size);
		phalcon_concat_vs(&return_value, text, padding, padding_size, 0 TSRMLS_CC);
	}
}

static void phalcon_crypt_unpad_text(zval *return_value, zval *text, zval *mode, uint block_size, int padding_type TSRMLS_DC)
{
	uint padding_size;
	char padding[256];
	int i;
	char *str_mode;
	char *str_text;
	uint text_len;

	assert(Z_TYPE_P(text) == IS_STRING);
	assert(Z_TYPE_P(mode) == IS_STRING);

	padding_size = 0;
	str_mode = Z_STRVAL_P(mode);
	str_text = Z_STRVAL_P(text);
	text_len = Z_STRLEN_P(text);

	if (text_len && (text_len % block_size == 0) && (!strcmp(str_mode, "ecb") || !strcmp(str_mode, "cbc"))) {
		switch (padding_type) {
			case PHALCON_CRYPT_PADDING_ANSI_X_923:
				if ((unsigned char)(str_text[text_len - 1]) <= block_size) {
					padding_size = str_text[text_len - 1];

					memset(padding, 0, padding_size - 1);
					padding[padding_size-1] = (unsigned char)padding_size;

					if (memcmp(padding, str_text + text_len - padding_size, padding_size)) {
						padding_size = 0;
					}
				}

				break;

			case PHALCON_CRYPT_PADDING_PKCS7:
				if ((unsigned char)(str_text[text_len-1]) <= block_size) {
					padding_size = str_text[text_len-1];

					memset(padding, padding_size, padding_size);

					if (memcmp(padding, str_text + text_len - padding_size, padding_size)) {
						padding_size = 0;
					}
				}

				break;

			case PHALCON_CRYPT_PADDING_ISO_10126:
				padding_size = str_text[text_len-1];
				break;

			case PHALCON_CRYPT_PADDING_ISO_IEC_7816_4:
				i = text_len - 1;
				while (i > 0 && str_text[i] == 0x00 && padding_size < block_size) {
					++padding_size;
					--i;
				}

				padding_size = ((unsigned char)str_text[i] == 0x80) ? (padding_size + 1) : 0;
				break;

			case PHALCON_CRYPT_PADDING_ZERO:
				i = text_len - 1;
				while (i >= 0 && str_text[i] == 0x00 && padding_size <= block_size) {
					++padding_size;
					--i;
				}

				break;

			case PHALCON_CRYPT_PADDING_SPACE:
				i = text_len - 1;
				while (i >= 0 && str_text[i] == 0x20 && padding_size <= block_size) {
					++padding_size;
					--i;
				}

				break;

			default:
				break;
		}

		if (padding_size && padding_size <= block_size) {
			assert(padding_size <= text_len);
			if (padding_size < text_len) {
				phalcon_substr(return_value, text, 0, text_len - padding_size);
			}
			else {
				ZVAL_EMPTY_STRING(return_value);
			}
		}
		else {
			padding_size = 0;
		}
	}

	if (!padding_size) {
		ZVAL_ZVAL(return_value, text, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Crypt, encrypt){

	zval *source, *text, *key = NULL, *encrypt_key = NULL, *cipher, *mode, *padding_type, *iv_size = NULL;
	zval *rand, *iv = NULL, *encrypt = NULL, *block_size = NULL, *padded;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &source, &key);

	/* Do not use make_printable_zval() here: we need the conversion with type juggling */
	if (Z_TYPE_P(source) != IS_STRING) {
		PHALCON_INIT_VAR(text);
		phalcon_cast(text, source, IS_STRING);
	}
	else {
		text = source;
	}

	if (phalcon_function_quick_exists_ex(SS("mcrypt_get_iv_size"), 547857179UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "mcrypt extension is required");
		return;
	}

	if (!key || Z_TYPE_P(key) == IS_NULL) {
		encrypt_key = phalcon_fetch_nproperty_this(this_ptr, SL("_key"), PH_NOISY TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT_CTOR(encrypt_key, key);
		if (Z_TYPE_P(encrypt_key) != IS_STRING) {
			convert_to_string(encrypt_key);
		}
	}

	if (PHALCON_IS_EMPTY(encrypt_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "Encryption key cannot be empty");
		return;
	}

	cipher = phalcon_fetch_nproperty_this(this_ptr, SL("_cipher"), PH_NOISY TSRMLS_CC);
	mode   = phalcon_fetch_nproperty_this(this_ptr, SL("_mode"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_FUNCTION(&iv_size, "mcrypt_get_iv_size", cipher, mode);
	if (unlikely(Z_TYPE_P(iv_size) != IS_LONG)) {
		convert_to_long(iv_size);
	}

	if (Z_STRLEN_P(encrypt_key) > Z_LVAL_P(iv_size)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "Size of key is too large for this algorithm");
		return;
	}

	PHALCON_INIT_VAR(rand);
	ZVAL_LONG(rand, 2);

	PHALCON_CALL_FUNCTION(&iv, "mcrypt_create_iv", iv_size, rand);
	if (unlikely(Z_TYPE_P(iv) != IS_STRING)) {
		convert_to_string(iv);
	}

	PHALCON_CALL_FUNCTION(&block_size, "mcrypt_get_block_size", cipher, mode);
	if (unlikely(Z_TYPE_P(block_size) != IS_LONG)) {
		convert_to_long(block_size);
	}

	padding_type = phalcon_fetch_nproperty_this(this_ptr, SL("_padding"), PH_NOISY TSRMLS_CC);

	assert(Z_TYPE_P(padding_type) == IS_LONG);
	assert(Z_TYPE_P(block_size) == IS_LONG);
	assert(Z_TYPE_P(mode) == IS_STRING);
	assert(Z_TYPE_P(text) == IS_STRING);

	PHALCON_INIT_VAR(padded);
	phalcon_crypt_pad_text(padded, text, mode, Z_LVAL_P(block_size), Z_LVAL_P(padding_type) TSRMLS_CC);
	assert(Z_TYPE_P(padded) == IS_STRING);

	PHALCON_CALL_FUNCTION(&encrypt, "mcrypt_encrypt", cipher, encrypt_key, padded, mode, iv);

	PHALCON_CONCAT_VV(return_value, iv, encrypt);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Crypt, decrypt){

	zval *text, *key = NULL, *decrypt_key = NULL, *cipher, *mode, *iv_size = NULL;
	zval *key_size, *text_size, *iv, *text_to_decipher, *decrypted = NULL;
	zval *padding_type, *block_size = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &text, &key);

	if (phalcon_function_quick_exists_ex(SS("mcrypt_get_iv_size"), 547857179UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "mcrypt extension is required");
		return;
	}

	if (!key || Z_TYPE_P(key) == IS_NULL) {
		decrypt_key = phalcon_fetch_nproperty_this(this_ptr, SL("_key"), PH_NOISY TSRMLS_CC);
	} else {
		decrypt_key = key;
	}

	if (PHALCON_IS_EMPTY(decrypt_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "Decryption key cannot be empty");
		return;
	}

	cipher = phalcon_fetch_nproperty_this(this_ptr, SL("_cipher"), PH_NOISY TSRMLS_CC);
	mode   = phalcon_fetch_nproperty_this(this_ptr, SL("_mode"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_FUNCTION(&iv_size, "mcrypt_get_iv_size", cipher, mode);
	if (unlikely(Z_TYPE_P(iv_size) != IS_LONG)) {
		convert_to_long(iv_size);
	}

	PHALCON_INIT_VAR(key_size);
	phalcon_fast_strlen(key_size, decrypt_key);
	if (PHALCON_GT(key_size, iv_size)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "Size of key is too large for this algorithm");
		return;
	}

	PHALCON_INIT_VAR(text_size);
	phalcon_fast_strlen(text_size, text);
	if (PHALCON_GT(key_size, text_size)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_crypt_exception_ce, "Size of IV is larger than text to decrypt");
		return;
	}

	PHALCON_INIT_VAR(iv);
	phalcon_substr(iv, text, 0, Z_LVAL_P(iv_size));

	PHALCON_INIT_VAR(text_to_decipher);
	phalcon_substr(text_to_decipher, text, Z_LVAL_P(iv_size), 0);

	PHALCON_CALL_FUNCTION(&decrypted, "mcrypt_decrypt", cipher, decrypt_key, text_to_decipher, mode, iv);
	if (unlikely(Z_TYPE_P(decrypted) != IS_STRING)) {
		convert_to_string(decrypted);
	}

	PHALCON_CALL_FUNCTION(&block_size, "mcrypt_get_block_size", cipher, mode);
	if (unlikely(Z_TYPE_P(block_size) != IS_LONG)) {
		convert_to_long(block_size);
	}

	padding_type = phalcon_fetch_nproperty_this(this_ptr, SL("_padding"), PH_NOISY TSRMLS_CC);

	assert(Z_TYPE_P(padding_type) == IS_LONG);
	assert(Z_TYPE_P(block_size) == IS_LONG);
	assert(Z_TYPE_P(mode) == IS_STRING);
	assert(Z_TYPE_P(decrypted) == IS_STRING);

	phalcon_crypt_unpad_text(return_value, decrypted, mode, Z_LVAL_P(block_size), Z_LVAL_P(padding_type) TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Crypt, encryptBase64){

	zval *text, *key = NULL, *safe = NULL, *encrypted = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &text, &key, &safe);

	if (!key) {
		key = PHALCON_GLOBAL(z_null);
	}

	if (!safe) {
		safe = PHALCON_GLOBAL(z_false);
	}

	PHALCON_CALL_METHOD(&encrypted, this_ptr, "encrypt", text, key);
	phalcon_base64_encode(return_value, encrypted);

	if (zend_is_true(safe)) {
		php_strtr(Z_STRVAL_P(return_value), Z_STRLEN_P(return_value), "+/", "-_", 2);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Crypt, decryptBase64){

	zval **text, **key = NULL, **safe = NULL, *decrypt_text;
	char *decoded;
	int decoded_len;

	phalcon_fetch_params_ex(1, 2, &text, &key, &safe);

	PHALCON_ENSURE_IS_STRING(text);
	if (!key) {
		key = &PHALCON_GLOBAL(z_null);
	}

	if (safe && zend_is_true(*safe)) {
		char *tmp = estrndup(Z_STRVAL_PP(text), Z_STRLEN_PP(text));
		php_strtr(tmp, Z_STRLEN_PP(text), "-_", "+/", 2);
		decoded = (char*)php_base64_decode((unsigned char*)tmp, Z_STRLEN_PP(text), &decoded_len);
		efree(tmp);
	}
	else {
		decoded = (char*)php_base64_decode((unsigned char*)(Z_STRVAL_PP(text)), Z_STRLEN_PP(text), &decoded_len);
	}

	if (!decoded) {
		RETURN_FALSE;
	}

	PHALCON_MM_GROW();
	PHALCON_ALLOC_GHOST_ZVAL(decrypt_text);
	ZVAL_STRINGL(decrypt_text, decoded, decoded_len, 0);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "decrypt", decrypt_text, *key);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Crypt, getAvailableCiphers){

	PHALCON_RETURN_CALL_FUNCTIONW("mcrypt_list_algorithms");
}

static PHP_METHOD(Phalcon_Crypt, getAvailableModes){

	PHALCON_RETURN_CALL_FUNCTIONW("mcrypt_list_modes");
}





zend_class_entry *phalcon_cryptinterface_ce;

static const zend_function_entry phalcon_cryptinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, setCipher, arginfo_phalcon_cryptinterface_setcipher)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, getCipher, NULL)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, setMode, arginfo_phalcon_cryptinterface_setmode)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, getMode, NULL)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, setKey, arginfo_phalcon_cryptinterface_setkey)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, getKey, NULL)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, encrypt, arginfo_phalcon_cryptinterface_encrypt)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, decrypt, arginfo_phalcon_cryptinterface_decrypt)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, encryptBase64, arginfo_phalcon_cryptinterface_encryptbase64)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, decryptBase64, arginfo_phalcon_cryptinterface_decryptbase64)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, getAvailableCiphers, NULL)
	PHP_ABSTRACT_ME(Phalcon_CryptInterface, getAvailableModes, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_CryptInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, CryptInterface, cryptinterface, phalcon_cryptinterface_method_entry);

	return SUCCESS;
}



















zend_class_entry *phalcon_db_ce;

static PHP_METHOD(Phalcon_Db, setup);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_setup, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_method_entry[] = {
	PHP_ME(Phalcon_Db, setup, arginfo_phalcon_db_setup, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db){

	PHALCON_REGISTER_CLASS(Phalcon, Db, db, phalcon_db_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_USE_DEFAULT"), (long int)PDO_FETCH_USE_DEFAULT TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_LAZY"),        (long int)PDO_FETCH_LAZY TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_ASSOC"),       (long int)PDO_FETCH_ASSOC TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_NUM"),         (long int)PDO_FETCH_NUM TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_BOTH"),        (long int)PDO_FETCH_BOTH TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_OBJ"),         (long int)PDO_FETCH_OBJ TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_BOUND"),       (long int)PDO_FETCH_BOUND TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_COLUMN"),      (long int)PDO_FETCH_COLUMN TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_CLASS"),       (long int)PDO_FETCH_CLASS TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_INTO"),        (long int)PDO_FETCH_INTO TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_FUNC"),        (long int)PDO_FETCH_FUNC TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_NAMED"),       (long int)PDO_FETCH_NAMED TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_KEY_PAIR") ,   (long int)PDO_FETCH_KEY_PAIR TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_GROUP"),       (long int)PDO_FETCH_GROUP TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_UNIQUE"),      (long int)PDO_FETCH_UNIQUE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_CLASSTYPE"),   (long int)PDO_FETCH_CLASSTYPE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_SERIALIZE"),   (long int)PDO_FETCH_SERIALIZE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_ce, SL("FETCH_PROPS_LATE"),  (long int)PDO_FETCH_PROPS_LATE TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db, setup){

	zval *options, *escape_identifiers;

	phalcon_fetch_params(0, 1, 0, &options);

	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Options must be an array");
		return;
	}

	if (phalcon_array_isset_string_fetch(&escape_identifiers, options, SS("escapeSqlIdentifiers"))) {
		PHALCON_GLOBAL(db).escape_identifiers = zend_is_true(escape_identifiers);
	}
}





#include <ext/standard/php_string.h>
#include <Zend/zend_builtin_functions.h>


zend_class_entry *phalcon_debug_ce;

static PHP_METHOD(Phalcon_Debug, setUri);
static PHP_METHOD(Phalcon_Debug, setShowBackTrace);
static PHP_METHOD(Phalcon_Debug, setShowFiles);
static PHP_METHOD(Phalcon_Debug, setShowFileFragment);
static PHP_METHOD(Phalcon_Debug, listen);
static PHP_METHOD(Phalcon_Debug, listenExceptions);
static PHP_METHOD(Phalcon_Debug, listenLowSeverity);
static PHP_METHOD(Phalcon_Debug, debugVar);
static PHP_METHOD(Phalcon_Debug, clearVars);
static PHP_METHOD(Phalcon_Debug, _escapeString);
static PHP_METHOD(Phalcon_Debug, _getArrayDump);
static PHP_METHOD(Phalcon_Debug, _getVarDump);
static PHP_METHOD(Phalcon_Debug, getMajorVersion);
static PHP_METHOD(Phalcon_Debug, getVersion);
static PHP_METHOD(Phalcon_Debug, getCssSources);
static PHP_METHOD(Phalcon_Debug, getJsSources);
static PHP_METHOD(Phalcon_Debug, showTraceItem);
static PHP_METHOD(Phalcon_Debug, onUncaughtException);
static PHP_METHOD(Phalcon_Debug, getCharset);
static PHP_METHOD(Phalcon_Debug, setCharset);
static PHP_METHOD(Phalcon_Debug, getLinesBeforeContext);
static PHP_METHOD(Phalcon_Debug, setLinesBeforeContext);
static PHP_METHOD(Phalcon_Debug, getLinesAfterContext);
static PHP_METHOD(Phalcon_Debug, setLinesAfterContext);
static PHP_METHOD(Phalcon_Debug, getFileLink);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_seturi, 0, 0, 1)
	ZEND_ARG_INFO(0, uri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_setshowbacktrace, 0, 0, 1)
	ZEND_ARG_INFO(0, showBackTrace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_setshowfiles, 0, 0, 1)
	ZEND_ARG_INFO(0, showFiles)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_setshowfilefragment, 0, 0, 1)
	ZEND_ARG_INFO(0, showFileFragment)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_listen, 0, 0, 0)
	ZEND_ARG_INFO(0, exceptions)
	ZEND_ARG_INFO(0, lowSeverity)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_debugvar, 0, 0, 1)
	ZEND_ARG_INFO(0, var)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_onuncaughtexception, 0, 0, 1)
	ZEND_ARG_INFO(0, exception)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_setcharset, 0, 0, 1)
	ZEND_ARG_INFO(0, charset)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_setlines, 0, 0, 1)
	ZEND_ARG_INFO(0, lines)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_debug_getfilelink, 0, 0, 3)
	ZEND_ARG_INFO(0, file)
	ZEND_ARG_INFO(0, line)
	ZEND_ARG_INFO(0, format)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_debug_method_entry[] = {
	PHP_ME(Phalcon_Debug, setUri, arginfo_phalcon_debug_seturi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, setShowBackTrace, arginfo_phalcon_debug_setshowbacktrace, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, setShowFiles, arginfo_phalcon_debug_setshowfiles, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, setShowFileFragment, arginfo_phalcon_debug_setshowfilefragment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, listen, arginfo_phalcon_debug_listen, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, listenExceptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, listenLowSeverity, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, debugVar, arginfo_phalcon_debug_debugvar, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, clearVars, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, _escapeString, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Debug, _getArrayDump, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Debug, _getVarDump, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Debug, getMajorVersion, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getVersion, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getCssSources, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getJsSources, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, showTraceItem, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Debug, onUncaughtException, arginfo_phalcon_debug_onuncaughtexception, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getCharset, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Debug, setCharset, arginfo_phalcon_debug_setcharset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getLinesBeforeContext, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, setLinesBeforeContext, arginfo_phalcon_debug_setlines, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getLinesAfterContext, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, setLinesAfterContext, arginfo_phalcon_debug_setlines, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Debug, getFileLink, arginfo_phalcon_debug_getfilelink, ZEND_ACC_PROTECTED)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Debug){

	PHALCON_REGISTER_CLASS(Phalcon, Debug, debug, phalcon_debug_method_entry, 0);

	zend_declare_property_string(phalcon_debug_ce, SL("_uri"), "//d2yyr506dy8ck0.cloudfront.net/debug/1.2.0/", ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_string(phalcon_debug_ce, SL("_theme"), "default", ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_bool(phalcon_debug_ce, SL("_hideDocumentRoot"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_debug_ce, SL("_showBackTrace"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_debug_ce, SL("_showFiles"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_debug_ce, SL("_showFileFragment"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_debug_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_debug_ce, SL("_isActive"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_string(phalcon_debug_ce, SL("_charset"), "utf-8", ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_long(phalcon_debug_ce, SL("_beforeContext"), 7, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_debug_ce, SL("_afterContext"), 5, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Debug, setUri){

	zval *uri;

	phalcon_fetch_params(0, 1, 0, &uri);
	
	phalcon_update_property_this_quick(this_ptr, SL("_uri"), uri, 251146964UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, setShowBackTrace){

	zval *show_back_trace;

	phalcon_fetch_params(0, 1, 0, &show_back_trace);
	
	phalcon_update_property_this_quick(this_ptr, SL("_showBackTrace"), show_back_trace, 3370024901UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, setShowFiles){

	zval *show_files;

	phalcon_fetch_params(0, 1, 0, &show_files);
	
	phalcon_update_property_this_quick(this_ptr, SL("_showFiles"), show_files, 1877855960UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, setShowFileFragment){

	zval *show_file_fragment;

	phalcon_fetch_params(0, 1, 0, &show_file_fragment);
	
	phalcon_update_property_this_quick(this_ptr, SL("_showFileFragment"), show_file_fragment, 3533221081UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, listen){

	zval *exceptions = NULL, *low_severity = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &exceptions, &low_severity);
	
	if (!exceptions || zend_is_true(exceptions)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "listenexceptions");
	}

	if (low_severity && zend_is_true(low_severity)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "listenlowseverity");
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Debug, listenExceptions){

	zval *handler;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(handler);
	array_init_size(handler, 2);
	phalcon_array_append(&handler, this_ptr, PH_SEPARATE);
	add_next_index_stringl(handler, SL("onUncaughtException"), 1);
	PHALCON_CALL_FUNCTION(NULL, "set_exception_handler", handler);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Debug, listenLowSeverity){
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, debugVar){

	zval *var, *key = NULL, *ztime, *backtrace, *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &var, &key);
	
	if (!key) {
		key = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(ztime);
	ZVAL_LONG(ztime, (long) time(NULL));
	
	PHALCON_INIT_VAR(backtrace);
#if PHP_VERSION_ID < 50400
#ifdef DEBUG_BACKTRACE_PROVIDE_OBJECT
	zend_fetch_debug_backtrace(backtrace, 0, DEBUG_BACKTRACE_PROVIDE_OBJECT TSRMLS_CC);
#else
	zend_fetch_debug_backtrace(backtrace, 0, 1 TSRMLS_CC);
#endif
#else
	zend_fetch_debug_backtrace(backtrace, 0, DEBUG_BACKTRACE_PROVIDE_OBJECT, 0 TSRMLS_CC);
#endif
	
	PHALCON_INIT_VAR(data);
	array_init_size(data, 3);
	phalcon_array_append(&data, var, PH_SEPARATE);
	phalcon_array_append(&data, backtrace, PH_SEPARATE);
	phalcon_array_append(&data, ztime, PH_SEPARATE);
	phalcon_update_property_array_append(this_ptr, SL("_data"), data TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Debug, clearVars){


	phalcon_update_property_null(this_ptr, SL("_data") TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, _escapeString){

	zval *value, *charset, *replaced_value;

	phalcon_fetch_params(0, 1, 0, &value);
	
	if (Z_TYPE_P(value) == IS_STRING) {
		zval line_break;
		zval escaped_line_break;

		charset = phalcon_fetch_static_property_ce(phalcon_debug_ce, SL("_charset") TSRMLS_CC);
	
		INIT_ZVAL(line_break);
		ZVAL_STRING(&line_break, "\n", 0);
	
		INIT_ZVAL(escaped_line_break);
		ZVAL_STRING(&escaped_line_break, "\\n", 0);

		ALLOC_INIT_ZVAL(replaced_value);
		phalcon_fast_str_replace(replaced_value, &line_break, &escaped_line_break, value);
		phalcon_htmlentities(return_value, replaced_value, NULL, charset TSRMLS_CC);
		zval_ptr_dtor(&replaced_value);
		return;
	}
	
	RETURN_ZVAL(value, 1, 0);
}

static PHP_METHOD(Phalcon_Debug, _getArrayDump){

	zval *argument, *n = NULL, *number_arguments, *dump;
	zval *v = NULL, *k = NULL, *var_dump = NULL, *escaped_string = NULL, *next = NULL, *array_dump = NULL;
	zval *class_name = NULL, *joined_dump;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &argument, &n);
	
	if (!n) {
		PHALCON_INIT_VAR(n);
		ZVAL_LONG(n, 0);
	}
	
	PHALCON_INIT_VAR(number_arguments);
	phalcon_fast_count(number_arguments, argument TSRMLS_CC);
	if (PHALCON_LT_LONG(n, 3)) {
		if (PHALCON_GT_LONG(number_arguments, 0)) {
			if (PHALCON_LT_LONG(number_arguments, 10)) {
	
				PHALCON_INIT_VAR(dump);
				array_init(dump);
	
				phalcon_is_iterable(argument, &ah0, &hp0, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
					PHALCON_GET_HKEY(k, ah0, hp0);
					PHALCON_GET_HVALUE(v);
	
					if (PHALCON_IS_SCALAR(v)) {
						if (PHALCON_IS_STRING(v, "")) {
							PHALCON_INIT_NVAR(var_dump);
							PHALCON_CONCAT_SVS(var_dump, "[", k, "] =&gt; (empty string)");
						} else {
							PHALCON_CALL_METHOD(&escaped_string, this_ptr, "_escapestring", v);
	
							PHALCON_INIT_NVAR(var_dump);
							PHALCON_CONCAT_SVSV(var_dump, "[", k, "] =&gt; ", escaped_string);
						}
						phalcon_array_append(&dump, var_dump, PH_SEPARATE);
					} else {
						if (Z_TYPE_P(v) == IS_ARRAY) { 
							PHALCON_INIT_NVAR(next);
							phalcon_add_function(next, n, PHALCON_GLOBAL(z_one) TSRMLS_CC);
	
							PHALCON_CALL_METHOD(&array_dump, this_ptr, "_getarraydump", v, next);
	
							PHALCON_INIT_NVAR(var_dump);
							PHALCON_CONCAT_SVSVS(var_dump, "[", k, "] =&gt; Array(", array_dump, ")");
							phalcon_array_append(&dump, var_dump, PH_SEPARATE);
							zend_hash_move_forward_ex(ah0, &hp0);
							continue;
						}
						if (Z_TYPE_P(v) == IS_OBJECT) {
							zend_class_entry *ce = Z_OBJCE_P(v);
							PHALCON_INIT_NVAR(class_name);
							ZVAL_STRINGL(class_name, ce->name, ce->name_length, !IS_INTERNED(ce->name));
	
							PHALCON_INIT_NVAR(var_dump);
							PHALCON_CONCAT_SVSVS(var_dump, "[", k, "] =&gt; Object(", class_name, ")");
							phalcon_array_append(&dump, var_dump, PH_SEPARATE);
							zend_hash_move_forward_ex(ah0, &hp0);
							continue;
						}
	
						if (Z_TYPE_P(v) == IS_NULL) {
							PHALCON_INIT_NVAR(var_dump);
							PHALCON_CONCAT_SVS(var_dump, "[", k, "] =&gt; null");
							phalcon_array_append(&dump, var_dump, PH_SEPARATE);
							zend_hash_move_forward_ex(ah0, &hp0);
							continue;
						}
	
						PHALCON_INIT_NVAR(var_dump);
						PHALCON_CONCAT_SVSV(var_dump, "[", k, "] =&gt; ", v);
						phalcon_array_append(&dump, var_dump, PH_SEPARATE);
					}
	
					zend_hash_move_forward_ex(ah0, &hp0);
				}
	
				PHALCON_INIT_VAR(joined_dump);
				phalcon_fast_join_str(joined_dump, SL(", "), dump TSRMLS_CC);
	
				RETURN_CTOR(joined_dump);
			}
	
			RETURN_NCTOR(number_arguments);
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Debug, _getVarDump){

	zval *variable, *class_name, *dumped_object = NULL;
	zval *array_dump = NULL, *dump = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &variable);
	
	if (PHALCON_IS_SCALAR(variable)) {
	
		if (Z_TYPE_P(variable) == IS_BOOL) {
			if (zend_is_true(variable)) {
				RETURN_MM_STRING("true", 1);
			} else {
				RETURN_MM_STRING("false", 1);
			}
		}
	
		if (Z_TYPE_P(variable) == IS_STRING) {
			PHALCON_RETURN_CALL_METHOD(this_ptr, "_escapestring", variable);
			RETURN_MM();
		}
	
	
		RETURN_CTOR(variable);
	}
	
	if (Z_TYPE_P(variable) == IS_OBJECT) {
		const zend_class_entry *ce = Z_OBJCE_P(variable);
	
		PHALCON_INIT_VAR(class_name);
		ZVAL_STRINGL(class_name, ce->name, ce->name_length, !IS_INTERNED(ce->name));
	
		if (phalcon_method_quick_exists_ex(variable, SS("dump"), 257071355UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(&dumped_object, variable, "dump");
	
			PHALCON_CALL_METHOD(&array_dump, this_ptr, "_getarraydump", dumped_object);
	
			PHALCON_INIT_VAR(dump);
			PHALCON_CONCAT_SVSVS(dump, "Object(", class_name, ": ", array_dump, ")");
		} else {
			PHALCON_INIT_NVAR(dump);
			PHALCON_CONCAT_SVS(dump, "Object(", class_name, ")</span>");
		}
	
		RETURN_CTOR(dump);
	}
	
	if (Z_TYPE_P(variable) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(&array_dump, this_ptr, "_getarraydump", variable);
		PHALCON_CONCAT_SVS(return_value, "Array(", array_dump, ")");
		RETURN_MM();
	}
	
	RETURN_MM_STRING(zend_zval_type_name(variable), 1);
}

static PHP_METHOD(Phalcon_Debug, getMajorVersion){

	zval *version = NULL, *parts, *major;

	PHALCON_MM_GROW();

	PHALCON_CALL_CE_STATIC(&version, phalcon_version_ce, "get");
	
	PHALCON_INIT_VAR(parts);
	phalcon_fast_explode_str(parts, SL(" "), version);
	
	PHALCON_OBS_VAR(major);
	phalcon_array_fetch_long(&major, parts, 0, PH_NOISY);
	RETURN_CCTOR(major);
}

static PHP_METHOD(Phalcon_Debug, getVersion){

	zval *version = NULL;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&version, this_ptr, "getmajorversion");
	PHALCON_CONCAT_SVSVS(return_value, "<div class=\"version\">Phalcon Framework <a target=\"_new\" href=\"http://docs.phalconphp.com/en/", version, "/\">", version, "</a></div>");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Debug, getCssSources){

	zval *uri, *sources;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(uri);
	phalcon_read_property_this(&uri, this_ptr, SL("_uri"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(sources);
	PHALCON_CONCAT_SVS(sources, "<link href=\"", uri, "jquery/jquery-ui.css\" type=\"text/css\" rel=\"stylesheet\" />");
	PHALCON_SCONCAT_SVS(sources, "<link href=\"", uri, "themes/default/style.css\" type=\"text/css\" rel=\"stylesheet\" />");
	RETURN_CTOR(sources);
}

static PHP_METHOD(Phalcon_Debug, getJsSources){

	zval *uri, *sources;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(uri);
	phalcon_read_property_this(&uri, this_ptr, SL("_uri"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(sources);
	PHALCON_CONCAT_SVS(sources, "<script type=\"text/javascript\" src=\"", uri, "jquery/jquery.js\"></script>");
	PHALCON_SCONCAT_SVS(sources, "<script type=\"text/javascript\" src=\"", uri, "jquery/jquery-ui.js\"></script>");
	PHALCON_SCONCAT_SVS(sources, "<script type=\"text/javascript\" src=\"", uri, "jquery/jquery.scrollTo.js\"></script>");
	PHALCON_SCONCAT_SVS(sources, "<script type=\"text/javascript\" src=\"", uri, "prettify/prettify.js\"></script>");
	PHALCON_SCONCAT_SVS(sources, "<script type=\"text/javascript\" src=\"", uri, "pretty.js\"></script>");
	RETURN_CTOR(sources);
}

static PHP_METHOD(Phalcon_Debug, getFileLink) {

	zval **file, **line, **format;

	phalcon_fetch_params_ex(3, 0, &file, &line, &format);

	PHALCON_ENSURE_IS_STRING(file);
	PHALCON_ENSURE_IS_STRING(line);

	if (Z_TYPE_PP(format) == IS_STRING) {
		char *tmp, *link;
		int tmp_len, link_len;
		zval z_link = zval_used_for_init;

		tmp  = php_str_to_str_ex(Z_STRVAL_PP(format), Z_STRLEN_PP(format), SL("%f"), Z_STRVAL_PP(file), Z_STRLEN_PP(file), &tmp_len, 1, NULL);
		link = php_str_to_str_ex(tmp, tmp_len, SL("%l"), Z_STRVAL_PP(line), Z_STRLEN_PP(line), &link_len, 1, NULL);

		ZVAL_STRINGL(&z_link, link, link_len, 0);

		efree(tmp);
		PHALCON_CONCAT_SVSVS(return_value, "<a href=\"", &z_link, "\">", *file, "</a>");
		efree(link);
	}
	else {
		RETVAL_ZVAL(*file, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Debug, showTraceItem){

	zval *n, *trace, *link_format, *space, *two_spaces, *underscore;
	zval *minus, *html, *class_name;
	zval *namespace_separator, *prepare_uri_class;
	zval *lower_class_name, *prepared_function_name;
	zval *prepare_internal_class, *type, *function_name = NULL;
	zval *trace_args, *arguments, *argument = NULL, *dumped_argument = NULL;
	zval *span_argument = NULL, *joined_arguments, *z_one;
	zval *file, *line, *show_files, *lines = NULL, *number_lines;
	zval *show_file_fragment, *before_context, *before_line;
	zval *first_line = NULL, *after_context, *after_line, *last_line = NULL;
	zval *comment_pattern, *charset, *tab;
	zval *comment, *i = NULL, *line_position = NULL, *current_line = NULL;
	zval *trimmed = NULL, *is_comment = NULL, *spaced_current_line = NULL;
	zval *escaped_line = NULL, *formatted_file = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &n, &trace, &link_format);
	
	PHALCON_INIT_VAR(space);
	ZVAL_STRING(space, " ", 1);
	
	PHALCON_INIT_VAR(two_spaces);
	ZVAL_STRING(two_spaces, "  ", 1);
	
	PHALCON_INIT_VAR(underscore);
	ZVAL_STRING(underscore, "_", 1);
	
	PHALCON_INIT_VAR(minus);
	ZVAL_STRING(minus, "-", 1);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CONCAT_SVS(html, "<tr><td align=\"right\" valign=\"top\" class=\"error-number\">#", n, "</td><td>");
	if (phalcon_array_isset_quick_string(trace, SS("class"), 4138154555UL)) {
		zend_class_entry *class_ce;
	
		PHALCON_OBS_VAR(class_name);
		phalcon_array_fetch_quick_string(&class_name, trace, SS("class"), 4138154555UL, PH_NOISY);

		class_ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_AUTO | ZEND_FETCH_CLASS_SILENT TSRMLS_CC);

		if (!class_ce) {
			/* Unable to load the class, should never happen */
		}
		else if (is_phalcon_class(class_ce)) {
			PHALCON_INIT_VAR(namespace_separator);
			ZVAL_STRING(namespace_separator, "\\", 1);
	
			/* Prepare the class name according to the Phalcon's conventions */
			PHALCON_INIT_VAR(prepare_uri_class);
			phalcon_fast_str_replace(prepare_uri_class, namespace_separator, underscore, class_name);

			/* Generate a link to the official docs */
			PHALCON_SCONCAT_SVSVS(html, "<span class=\"error-class\"><a target=\"_new\" href=\"http://docs.phalconphp.com/en/latest/api/", prepare_uri_class, ".html\">", class_name, "</a></span>");
		} else if (class_ce->type == ZEND_INTERNAL_CLASS) {
			PHALCON_INIT_VAR(lower_class_name);
			phalcon_fast_strtolower(lower_class_name, class_name);

			PHALCON_INIT_VAR(prepare_internal_class);
			phalcon_fast_str_replace(prepare_internal_class, underscore, minus, lower_class_name);

			/* Generate a link to the official docs */
			PHALCON_SCONCAT_SVSVS(html, "<span class=\"error-class\"><a target=\"_new\" href=\"http://php.net/manual/en/class.", prepare_internal_class, ".php\">", class_name, "</a></span>");
		} else {
			PHALCON_SCONCAT_SVS(html, "<span class=\"error-class\">", class_name, "</span>");
		}
	
		PHALCON_OBS_VAR(type);
		phalcon_array_fetch_quick_string(&type, trace, SS("type"), 276192743UL, PH_NOISY);
		phalcon_concat_self(&html, type TSRMLS_CC);
	}
	
	if (phalcon_array_isset_quick_string(trace, SS("class"), 4138154555UL)) {
		PHALCON_OBS_VAR(function_name);
		phalcon_array_fetch_quick_string(&function_name, trace, SS("function"), 1487618475UL, PH_NOISY);
		PHALCON_SCONCAT_SVS(html, "<span class=\"error-function\">", function_name, "</span>");
	} else {
		zend_function *func;

		PHALCON_OBS_NVAR(function_name);
		phalcon_array_fetch_quick_string(&function_name, trace, SS("function"), 1487618475UL, PH_NOISY);
		convert_to_string(function_name);
	
		if (phalcon_fetch_function(&func, Z_STRVAL_P(function_name), Z_STRLEN_P(function_name) TSRMLS_CC) == SUCCESS) {
	
			if (func->type == ZEND_INTERNAL_FUNCTION) {
				PHALCON_INIT_VAR(prepared_function_name);
				phalcon_fast_str_replace(prepared_function_name, underscore, minus, function_name);
				PHALCON_SCONCAT_SVSVS(html, "<span class=\"error-function\"><a target=\"_new\" href=\"http://php.net/manual/en/function.", prepared_function_name, ".php\">", function_name, "</a></span>");
			} else {
				PHALCON_SCONCAT_SVS(html, "<span class=\"error-function\">", function_name, "</span>");
			}
		} else {
			PHALCON_SCONCAT_SVS(html, "<span class=\"error-function\">", function_name, "</span>");
		}
	}
	
	if (phalcon_array_isset_quick_string(trace, SS("args"), 253399346UL)) {
	
		PHALCON_OBS_VAR(trace_args);
		phalcon_array_fetch_quick_string(&trace_args, trace, SS("args"), 253399346UL, PH_NOISY);
		if (phalcon_fast_count_ev(trace_args TSRMLS_CC)) {
	
			PHALCON_INIT_VAR(arguments);
			array_init(arguments);
	
			phalcon_is_iterable(trace_args, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(argument);
	
				PHALCON_CALL_METHOD(&dumped_argument, this_ptr, "_getvardump", argument);
	
				PHALCON_INIT_NVAR(span_argument);
				PHALCON_CONCAT_SVS(span_argument, "<span class=\"error-parameter\">", dumped_argument, "</span>");
	
				phalcon_array_append(&arguments, span_argument, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			PHALCON_INIT_VAR(joined_arguments);
			phalcon_fast_join_str(joined_arguments, SL(", "), arguments TSRMLS_CC);
			PHALCON_SCONCAT_SVS(html, "(", joined_arguments, ")");
		} else {
			phalcon_concat_self_str(&html, SL("()") TSRMLS_CC);
		}
	}
	
	if (phalcon_array_isset_quick_string(trace, SS("file"), 259010501UL)) {
	
		z_one = PHALCON_GLOBAL(z_one);
	
		PHALCON_OBS_VAR(file);
		phalcon_array_fetch_quick_string(&file, trace, SS("file"), 259010501UL, PH_NOISY);
	
		PHALCON_OBS_VAR(line);
		phalcon_array_fetch_quick_string(&line, trace, SS("line"), 266128205UL, PH_NOISY);

		PHALCON_CALL_METHOD(&formatted_file, getThis(), "getfilelink", file, line, link_format);
	
		PHALCON_SCONCAT_SVSVS(html, "<br/><div class=\"error-file\">", formatted_file, " (", line, ")</div>");
	
		PHALCON_OBS_VAR(show_files);
		phalcon_read_property_this(&show_files, this_ptr, SL("_showFiles"), PH_NOISY TSRMLS_CC);
	
		if (zend_is_true(show_files)) {
	
			PHALCON_CALL_FUNCTION(&lines, "file", file);
	
			PHALCON_INIT_VAR(number_lines);
			phalcon_fast_count(number_lines, lines TSRMLS_CC);
	
			PHALCON_OBS_VAR(show_file_fragment);
			phalcon_read_property_this(&show_file_fragment, this_ptr, SL("_showFileFragment"), PH_NOISY TSRMLS_CC);
	
			if (zend_is_true(show_file_fragment)) {
	
				before_context = phalcon_fetch_nproperty_this(getThis(), SL("_beforeContext"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(before_line);
				sub_function(before_line, line, before_context TSRMLS_CC);
	
				if (PHALCON_LT_LONG(before_line, 1)) {
					PHALCON_CPY_WRT_CTOR(first_line, z_one);
				} else {
					PHALCON_CPY_WRT(first_line, before_line);
				}
	
				after_context = phalcon_fetch_nproperty_this(getThis(), SL("_afterContext"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(after_line);
				phalcon_add_function(after_line, line, after_context TSRMLS_CC);
	
				if (PHALCON_GT(after_line, number_lines)) {
					PHALCON_CPY_WRT(last_line, number_lines);
				} else {
					PHALCON_CPY_WRT(last_line, after_line);
				}
	
				PHALCON_SCONCAT_SVSVSVS(html, "<pre class='prettyprint highlight:", first_line, ":", line, " linenums:", first_line, "'>");
			} else {
				PHALCON_CPY_WRT_CTOR(first_line, z_one);
				PHALCON_CPY_WRT(last_line, number_lines);
				PHALCON_SCONCAT_SVSVS(html, "<pre class='prettyprint highlight:", first_line, ":", line, " linenums error-scroll'>");
			}
	
			PHALCON_INIT_VAR(comment_pattern);
			ZVAL_STRING(comment_pattern, "#\\*\\/$#", 1);
	
			charset = phalcon_fetch_static_property_ce(phalcon_debug_ce, SL("_charset") TSRMLS_CC);
	
			PHALCON_INIT_VAR(tab);
			ZVAL_STRING(tab, "\t", 1);
	
			PHALCON_INIT_VAR(comment);
			ZVAL_STRING(comment, "* /", 1);
			PHALCON_CPY_WRT(i, first_line);
	
			while (PHALCON_LE(i, last_line)) {
	
				PHALCON_INIT_NVAR(line_position);
				sub_function(line_position, i, z_one TSRMLS_CC);
	
				PHALCON_OBS_NVAR(current_line);
				phalcon_array_fetch(&current_line, lines, line_position, PH_NOISY);
	
				if (zend_is_true(show_file_fragment)) {
					if (PHALCON_IS_EQUAL(i, first_line)) {
	
						PHALCON_INIT_NVAR(trimmed);
						phalcon_fast_trim(trimmed, current_line, PHALCON_TRIM_RIGHT TSRMLS_CC);
	
						PHALCON_INIT_NVAR(is_comment);
	
						RETURN_MM_ON_FAILURE(phalcon_preg_match(is_comment, comment_pattern, current_line, NULL TSRMLS_CC));
	
						if (zend_is_true(is_comment)) {
							PHALCON_INIT_NVAR(spaced_current_line);
							phalcon_fast_str_replace(spaced_current_line, comment, space, current_line);
							PHALCON_CPY_WRT(current_line, spaced_current_line);
						}
					}
				}
	
				if (PHALCON_IS_STRING(current_line, "\n")) {
					phalcon_concat_self_str(&html, SL("&nbsp;\n") TSRMLS_CC);
				} else {
					if (PHALCON_IS_STRING(current_line, "\r\n")) {
						phalcon_concat_self_str(&html, SL("&nbsp;\n") TSRMLS_CC);
					} else {
						PHALCON_INIT_NVAR(spaced_current_line);
						phalcon_fast_str_replace(spaced_current_line, tab, two_spaces, current_line);
	
						PHALCON_INIT_NVAR(escaped_line);
						phalcon_htmlentities(escaped_line, spaced_current_line, NULL, charset TSRMLS_CC);
						phalcon_concat_self(&html, escaped_line TSRMLS_CC);
					}
				}
	
				phalcon_increment(i);
			}
			phalcon_concat_self_str(&html, SL("</pre>") TSRMLS_CC);
		}
	}
	
	phalcon_concat_self_str(&html, SL("</td></tr>") TSRMLS_CC);
	
	RETURN_CTOR(html);
}

static PHP_METHOD(Phalcon_Debug, onUncaughtException){

	zval *exception, *is_active = NULL, *message = NULL;
	zval *class_name, *css_sources = NULL, *escaped_message = NULL;
	zval *html, *version = NULL, *file = NULL, *line = NULL, *show_back_trace;
	zval *data_vars, *trace = NULL, *trace_item = NULL, *n = NULL, *html_item = NULL;
	zval *_REQUEST, *value = NULL, *key_request = NULL, *joined_value = NULL, *_SERVER;
	zval *key_server = NULL, *files = NULL, *key_file = NULL;
	zval *memory, *data_var = NULL, *key_var = NULL, *variable = NULL, *dumped_argument = NULL;
	zval *js_sources = NULL, *formatted_file = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4;
	HashPosition hp0, hp1, hp2, hp3, hp4;
	zval **hd;
	char* link_format;
	zend_bool ini_exists = 1;
	zval z_link_format = zval_used_for_init;
	zend_class_entry *ce;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &exception);
	PHALCON_VERIFY_CLASS_EX(exception, zend_exception_get_default(TSRMLS_C), phalcon_exception_ce, 1);
	
	if (phalcon_ob_get_level(TSRMLS_C) > 0) {
		phalcon_ob_end_clean(TSRMLS_C);
	}
	
	is_active = phalcon_fetch_static_property_ce(phalcon_debug_ce, SL("_isActive") TSRMLS_CC);
	
	if (zend_is_true(is_active)) {
		PHALCON_CALL_METHOD(&message, exception, "getmessage");
		zend_print_zval(message, 0);
	}
	
	zend_update_static_property_bool(phalcon_debug_ce, SL("_isActive"), 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(class_name);
	ce = Z_OBJCE_P(exception);
	ZVAL_STRINGL(class_name, ce->name, ce->name_length, !IS_INTERNED(ce->name));
	
	PHALCON_CALL_METHOD(&message, exception, "getmessage");
	
	PHALCON_CALL_METHOD(&css_sources, this_ptr, "getcsssources");
	
	PHALCON_CPY_WRT(escaped_message, message);
	
	PHALCON_INIT_VAR(html);
	PHALCON_CONCAT_SVSVS(html, "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/><title>", class_name, ": ", escaped_message, "</title>");
	PHALCON_SCONCAT_VS(html, css_sources, "</head><body>");
	
	PHALCON_CALL_METHOD(&version, this_ptr, "getversion");
	phalcon_concat_self(&html, version TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&file, exception, "getfile");
	PHALCON_CALL_METHOD(&line, exception, "getline");
	
	link_format = zend_ini_string_ex(SS("xdebug.file_link_format"), 0, &ini_exists);
	if (!link_format || !ini_exists || !strlen(link_format)) {
		link_format = "file://%f#%l";
	}

	ZVAL_STRING(&z_link_format, link_format, 0);

	PHALCON_CALL_METHOD(&formatted_file, getThis(), "getfilelink", file, line, &z_link_format);

	phalcon_concat_self_str(&html, SL("<div align=\"center\"><div class=\"error-main\">") TSRMLS_CC);
	PHALCON_SCONCAT_SVSVS(html, "<h1>", class_name, ": ", escaped_message, "</h1>");
	PHALCON_SCONCAT_SVSVS(html, "<span class=\"error-file\">", formatted_file, " (", line, ")</span>");
	phalcon_concat_self_str(&html, SL("</div>") TSRMLS_CC);
	
	PHALCON_OBS_VAR(show_back_trace);
	phalcon_read_property_this(&show_back_trace, this_ptr, SL("_showBackTrace"), PH_NOISY TSRMLS_CC);
	
	if (zend_is_true(show_back_trace)) {
		PHALCON_OBS_VAR(data_vars);
		phalcon_read_property_this(&data_vars, this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);

		phalcon_concat_self_str(&html, SL("<div class=\"error-info\"><div id=\"tabs\"><ul>") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-1\">Backtrace</a></li>") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-2\">Request</a></li>") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-3\">Server</a></li>") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-4\">Included Files</a></li>") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-5\">Memory</a></li>") TSRMLS_CC);
		if (Z_TYPE_P(data_vars) == IS_ARRAY) { 
			phalcon_concat_self_str(&html, SL("<li><a href=\"#error-tabs-6\">Variables</a></li>") TSRMLS_CC);
		}
	
		phalcon_concat_self_str(&html, SL("</ul>") TSRMLS_CC);
	
		phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-1\"><table cellspacing=\"0\" align=\"center\" width=\"100%\">") TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&trace, exception, "gettrace");
	
		phalcon_is_iterable(trace, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(n, ah0, hp0);
			PHALCON_GET_HVALUE(trace_item);
	
			PHALCON_CALL_METHOD(&html_item, this_ptr, "showtraceitem", n, trace_item, &z_link_format);
			phalcon_concat_self(&html, html_item TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
	
		phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-2\"><table cellspacing=\"0\" align=\"center\" class=\"superglobal-detail\">") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<tr><th>Key</th><th>Value</th></tr>") TSRMLS_CC);
		_REQUEST = phalcon_get_global(SS("_REQUEST") TSRMLS_CC);
	
		if (Z_TYPE_P(_REQUEST) == IS_ARRAY) {
			phalcon_is_iterable(_REQUEST, &ah1, &hp1, 0, 0);

			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
				PHALCON_GET_HKEY(key_request, ah1, hp1);
				PHALCON_GET_HVALUE(value);
	
				if (Z_TYPE_P(value) == IS_ARRAY) {
					PHALCON_CALL_METHOD(&joined_value, this_ptr, "_getvardump", value);
					PHALCON_SCONCAT_SVSVS(html, "<tr><td class=\"key\">", key_request, "</td><td>", joined_value, "</td></tr>");
				} else {
					PHALCON_SCONCAT_SVSVS(html, "<tr><td class=\"key\">", key_request, "</td><td>", value, "</td></tr>");
				}
				zend_hash_move_forward_ex(ah1, &hp1);
			}
		}
	
		phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
	
		phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-3\"><table cellspacing=\"0\" align=\"center\" class=\"superglobal-detail\">") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<tr><th>Key</th><th>Value</th></tr>") TSRMLS_CC);
		_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	
		if (Z_TYPE_P(_SERVER) == IS_ARRAY) {
			phalcon_is_iterable(_SERVER, &ah2, &hp2, 0, 0);

			while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {

				PHALCON_GET_HKEY(key_server, ah2, hp2);
				PHALCON_GET_HVALUE(value);
	
				PHALCON_CALL_METHOD(&dumped_argument, this_ptr, "_getvardump", value);
				PHALCON_SCONCAT_SVSVS(html, "<tr><td class=\"key\">", key_server, "</td><td>", dumped_argument, "</td></tr>");

				zend_hash_move_forward_ex(ah2, &hp2);
			}
		}
	
		phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
	
		PHALCON_CALL_FUNCTION(&files, "get_included_files");
		phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-4\"><table cellspacing=\"0\" align=\"center\" class=\"superglobal-detail\">") TSRMLS_CC);
		phalcon_concat_self_str(&html, SL("<tr><th>#</th><th>Path</th></tr>") TSRMLS_CC);
	
		phalcon_is_iterable(files, &ah3, &hp3, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
			PHALCON_GET_HKEY(key_file, ah3, hp3);
			PHALCON_GET_HVALUE(value);
	
			PHALCON_SCONCAT_SVSVS(html, "<tr><td>", key_file, "</th><td>", value, "</td></tr>");
	
			zend_hash_move_forward_ex(ah3, &hp3);
		}
	
		phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
	
		PHALCON_INIT_VAR(memory);
		ZVAL_LONG(memory, zend_memory_usage(1 TSRMLS_CC));
		phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-5\"><table cellspacing=\"0\" align=\"center\" class=\"superglobal-detail\">") TSRMLS_CC);
		PHALCON_SCONCAT_SVS(html, "<tr><th colspan=\"2\">Memory</th></tr><tr><td>Usage</td><td>", memory, "</td></tr>");
		phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
	
		if (Z_TYPE_P(data_vars) == IS_ARRAY) { 
			phalcon_concat_self_str(&html, SL("<div id=\"error-tabs-6\"><table cellspacing=\"0\" align=\"center\" class=\"superglobal-detail\">") TSRMLS_CC);
			phalcon_concat_self_str(&html, SL("<tr><th>Key</th><th>Value</th></tr>") TSRMLS_CC);
	
			phalcon_is_iterable(data_vars, &ah4, &hp4, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {
	
				PHALCON_GET_HKEY(key_var, ah4, hp4);
				PHALCON_GET_HVALUE(data_var);
	
				PHALCON_OBS_NVAR(variable);
				phalcon_array_fetch_long(&variable, data_var, 0, PH_NOISY);
	
				PHALCON_CALL_METHOD(&dumped_argument, this_ptr, "_getvardump", variable);
				PHALCON_SCONCAT_SVSVS(html, "<tr><td class=\"key\">", key_var, "</td><td>", dumped_argument, "</td></tr>");
	
				zend_hash_move_forward_ex(ah4, &hp4);
			}
	
			phalcon_concat_self_str(&html, SL("</table></div>") TSRMLS_CC);
		}
	
		phalcon_concat_self_str(&html, SL("</div>") TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(&js_sources, this_ptr, "getjssources");
	PHALCON_SCONCAT_VS(html, js_sources, "</div></body></html>");
	
	zend_print_zval(html, 0);
	
	zend_update_static_property_bool(phalcon_debug_ce, SL("_isActive"), 0 TSRMLS_CC);
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Debug, getCharset) {
	zval *charset = phalcon_fetch_static_property_ce(phalcon_debug_ce, SL("_charset") TSRMLS_CC);
	RETURN_ZVAL(charset, 1, 0);
}

static PHP_METHOD(Phalcon_Debug, setCharset) {

	zval **charset;

	phalcon_fetch_params_ex(1, 0, &charset);
	PHALCON_ENSURE_IS_STRING(charset);

	phalcon_update_static_property_ce(phalcon_debug_ce, SL("_charset"), *charset TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, getLinesBeforeContext) {
	RETURN_MEMBER(getThis(), "_beforeContext");
}

static PHP_METHOD(Phalcon_Debug, setLinesBeforeContext) {

	zval **lines;

	phalcon_fetch_params_ex(1, 0, &lines);
	PHALCON_ENSURE_IS_LONG(lines);

	phalcon_update_property_this(getThis(), SL("_beforeContext"), *lines TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Debug, getLinesAfterContext) {
	RETURN_MEMBER(getThis(), "_afterContext");
}

static PHP_METHOD(Phalcon_Debug, setLinesAfterContext) {

	zval **lines;

	phalcon_fetch_params_ex(1, 0, &lines);
	PHALCON_ENSURE_IS_LONG(lines);

	phalcon_update_property_this(getThis(), SL("_afterContext"), *lines TSRMLS_CC);
	RETURN_THISW();
}







zend_class_entry *phalcon_di_ce;

static zend_object_handlers phalcon_di_object_handlers;

typedef struct _phalcon_di_object {
	zend_object obj;
	HashTable* services;
	HashTable* shared;
	int fresh;
} phalcon_di_object;

static inline phalcon_di_object* phalcon_di_get_object(zval *obj TSRMLS_DC)
{
	return (phalcon_di_object*)zend_objects_get_address(obj TSRMLS_CC);
}

static PHP_FUNCTION(phalcon_di_method_handler)
{
	Z_OBJ_HANDLER_P(getThis(), call_method)(((zend_internal_function*)EG(current_execute_data)->function_state.function)->function_name, INTERNAL_FUNCTION_PARAM_PASSTHRU);
	efree(((zend_internal_function*)EG(current_execute_data)->function_state.function));
}

static union _zend_function* phalcon_di_get_method(zval **object_ptr, char *method, int method_len ZLK_DC TSRMLS_DC)
{
	char *lc_method_name   = emalloc(method_len + 1);
	phalcon_di_object *obj = phalcon_di_get_object(*object_ptr TSRMLS_CC);
	zend_function fbc;

	zend_str_tolower_copy(lc_method_name, method, method_len);

	if (
		   zend_hash_find(&obj->obj.ce->function_table, lc_method_name, method_len+1, (void **)&fbc) == FAILURE
		&& method_len > 3
		&& (!memcmp(lc_method_name, "get", 3) || !memcmp(lc_method_name, "set", 3))
	) {
		zend_internal_function *f = emalloc(sizeof(zend_internal_function));

		f->type          = ZEND_INTERNAL_FUNCTION;
		f->handler       = ZEND_FN(phalcon_di_method_handler);
		f->arg_info      = NULL;
		f->num_args      = 0;
		f->scope         = obj->obj.ce;
		f->fn_flags      = ZEND_ACC_CALL_VIA_HANDLER;
		f->function_name = method;
#if PHP_VERSION_ID < 50400
		f->module        = obj->obj.ce->module;
		f->pass_rest_by_reference = 0;
		f->return_reference = ZEND_RETURN_VALUE;
#else
		f->module        = (ZEND_INTERNAL_CLASS == obj->obj.ce->type) ? obj->obj.ce->info.internal.module : 0;
#endif

		efree(lc_method_name);
		return (union _zend_function*)f;
	}

	efree(lc_method_name);
	return std_object_handlers.get_method(object_ptr, method, method_len ZLK_CC TSRMLS_CC);
}

static int phalcon_di_call_method_internal(zval *return_value, zval **return_value_ptr, zval *this_ptr, const char *method, zval *param TSRMLS_DC)
{
	int method_len       = strlen(method);
	char *lc_method_name = emalloc(method_len + 1);
	int retval           = FAILURE;

	zend_str_tolower_copy(lc_method_name, method, method_len);

	if (method_len > 3 && (!memcmp(lc_method_name, "get", 3) || !memcmp(lc_method_name, "set", 3))) {
		phalcon_di_object *obj = phalcon_di_get_object(getThis() TSRMLS_CC);
		char *service          = estrndup(method+3, method_len-3);

		service[0] = tolower(service[0]);

		if (SUCCESS == zend_symtable_exists(obj->services, method, method_len + 1)) {
			zval *svc;
			zval *params[2];

			PHALCON_ALLOC_GHOST_ZVAL(svc);
			ZVAL_STRINGL(svc, service, method_len - 3, 0);

			params[0] = svc;
			params[1] = param;

			if (lc_method_name[0] == 'g') {
				retval = phalcon_return_call_method(return_value, return_value_ptr, this_ptr, "get", 2, params TSRMLS_CC);
			}
			else {
				retval = phalcon_return_call_method(return_value, return_value_ptr, this_ptr, "set", 2, params TSRMLS_CC);
			}

			if (EG(exception)) {
				retval = SUCCESS;
			}
		}
	}

	if (FAILURE == retval) {
		zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Call to undefined method or service '%s'", method);
	}

	efree(lc_method_name);
	return retval;
}

static int phalcon_di_call_method(const char *method, INTERNAL_FUNCTION_PARAMETERS)
{
	zval **param;

	if (!ZEND_NUM_ARGS()) {
		param = &PHALCON_GLOBAL(z_null);
	}
	else {
		phalcon_fetch_parameters_ex(0 TSRMLS_CC, 1, 0, &param);
	}

	return phalcon_di_call_method_internal(return_value, return_value_ptr, getThis(), method, *param TSRMLS_CC);
}

static zval* phalcon_di_read_dimension_internal(zval *this_ptr, phalcon_di_object *obj, zval *offset, zval *parameters TSRMLS_DC)
{
	zval *tmp = NULL;
	zval **retval = &tmp, **service;
	zend_class_entry *ce;

	assert(Z_TYPE_P(offset) == IS_STRING);

	if (UNEXPECTED(!offset)) {
		return EG(uninitialized_zval_ptr);
	}

	if (SUCCESS == zend_symtable_find(obj->shared, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&retval)) {
		obj->fresh = 0;
		return *retval;
	}

	/* Resolve the instance normally */
	if (SUCCESS == zend_symtable_find(obj->services, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&service)) {
		zval *params[] = { parameters, this_ptr };

		/* The service is registered in the DI */
		if (FAILURE == phalcon_call_method(retval, *service, "resolve", 2, params TSRMLS_CC)) {
			return NULL;
		}

		/* *retval has refcount = 1 here, it will be used in zend_symtable_update() */
		ce = (Z_TYPE_PP(retval) == IS_OBJECT) ? Z_OBJCE_PP(retval) : NULL;
	}
	else {
		/* The DI also acts as builder for any class even if it isn't defined in the DI */
		if (phalcon_class_exists_ex(&ce, offset, 1 TSRMLS_CC)) {
			MAKE_STD_ZVAL(*retval);
			if (FAILURE == phalcon_create_instance_params_ce(*retval, ce, parameters TSRMLS_CC)) {
				return NULL;
			}

			/* *retval has refcount = 1 here, it will be used in zend_symtable_update() */
		}
		else {
			zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Service '%s' was not found in the dependency injection container", Z_STRVAL_P(offset));
			return NULL;
		}
	}

	/* Pass the DI itself if the instance implements Phalcon\DI\InjectionAwareInterface */
	if (ce && instanceof_function_ex(ce, phalcon_di_injectionawareinterface_ce, 1 TSRMLS_CC)) {
		zval *params[] = { this_ptr };
		if (FAILURE == phalcon_call_method(NULL, *retval, "setdi", 1, params TSRMLS_CC)) {
			zval_ptr_dtor(retval);
			return NULL;
		}
	}

	assert(Z_REFCOUNT_PP(retval) == 1);
	zend_symtable_update(obj->shared, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void*)retval, sizeof(zval*), NULL);
	obj->fresh = 1;

	return *retval;
}

static zval* phalcon_di_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	phalcon_di_object *obj = phalcon_di_get_object(object TSRMLS_CC);
	zval tmp, *ret;

	if (!is_phalcon_class(obj->obj.ce)) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(offset) != IS_STRING)) {
		ZVAL_ZVAL(&tmp, offset, 1, 0);
		convert_to_string(&tmp);
		offset = &tmp;
	}

	ret = phalcon_di_read_dimension_internal(object, obj, offset, PHALCON_GLOBAL(z_null) TSRMLS_CC);

	if (UNEXPECTED(offset == &tmp)) {
		zval_dtor(&tmp);
	}

	return ret;
}

static int phalcon_di_has_dimension_internal(phalcon_di_object *obj, zval *offset, int check_empty)
{
	zval **tmp = phalcon_hash_get(obj->services, offset, BP_VAR_NA);

	if (!tmp) {
		return 0;
	}

	if (0 == check_empty) {
		return Z_TYPE_PP(tmp) != IS_NULL;
	}

	if (1 == check_empty) {
		return zend_is_true(*tmp);
	}

	return 1;
}

static int phalcon_di_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	phalcon_di_object *obj = phalcon_di_get_object(object TSRMLS_CC);

	if (!is_phalcon_class(obj->obj.ce)) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	return phalcon_di_has_dimension_internal(obj, offset, check_empty);
}

static zval* phalcon_di_write_dimension_internal(phalcon_di_object *obj, zval *offset, zval *value TSRMLS_DC)
{
	zval *retval;
	zval *params[] = { offset, value, PHALCON_GLOBAL(z_true) };

	assert(Z_TYPE_P(offset) == IS_STRING);

	MAKE_STD_ZVAL(retval);
	object_init_ex(retval, phalcon_di_service_ce);
	if (FAILURE == phalcon_call_method(NULL, retval, "__construct", 3, params TSRMLS_CC)) {
		return NULL;
	}

	zend_hash_update(obj->services, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, &retval, sizeof(zval*), NULL);
	return retval;
}

static void phalcon_di_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	phalcon_di_object *obj = phalcon_di_get_object(object TSRMLS_CC);
	zval tmp;

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->write_dimension(object, offset, value TSRMLS_CC);
		return;
	}

	if (UNEXPECTED(Z_TYPE_P(offset) != IS_STRING)) {
		ZVAL_ZVAL(&tmp, offset, 1, 0);
		convert_to_string(&tmp);
		offset = &tmp;
	}

	phalcon_di_write_dimension_internal(obj, offset, value TSRMLS_CC);

	if (UNEXPECTED(offset == &tmp)) {
		zval_dtor(&tmp);
	}
}

static inline void phalcon_di_unset_dimension_internal(phalcon_di_object *obj, zval *offset)
{
	assert(Z_TYPE_P(offset) == IS_STRING);
	zend_symtable_del(obj->services, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1);
}

static void phalcon_di_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	phalcon_di_object *obj = phalcon_di_get_object(object TSRMLS_CC);
	zval tmp;

	if (!is_phalcon_class(obj->obj.ce)) {
		zend_get_std_object_handlers()->unset_dimension(object, offset TSRMLS_CC);
		return;
	}

	if (UNEXPECTED(Z_TYPE_P(offset) != IS_STRING)) {
		ZVAL_ZVAL(&tmp, offset, 1, 0);
		convert_to_string(&tmp);
		offset = &tmp;
	}

	phalcon_di_unset_dimension_internal(obj, offset);

	if (UNEXPECTED(offset == &tmp)) {
		zval_dtor(&tmp);
	}
}

static HashTable* phalcon_di_get_properties(zval* object TSRMLS_DC)
{
	HashTable* props = zend_std_get_properties(object TSRMLS_CC);

	if (!GC_G(gc_active) && !props->nApplyCount) {
		phalcon_di_object *obj = phalcon_di_get_object(object TSRMLS_CC);
		zval *zv;

		MAKE_STD_ZVAL(zv);
		array_init_size(zv, zend_hash_num_elements(obj->services));
		zend_hash_copy(Z_ARRVAL_P(zv), obj->services, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
		zend_hash_quick_update(props, "_services", sizeof("_services"), 479369827UL, (void*)&zv, sizeof(zval*), NULL);

		MAKE_STD_ZVAL(zv);
		array_init_size(zv, zend_hash_num_elements(obj->shared));
		zend_hash_copy(Z_ARRVAL_P(zv), obj->shared, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
		zend_hash_quick_update(props, "_sharedInstances", sizeof("_sharedInstances"), 479369827UL, (void*)&zv, sizeof(zval*), NULL);

		MAKE_STD_ZVAL(zv);
		ZVAL_BOOL(zv, obj->fresh);
		zend_hash_quick_update(props, "_freshInstance", sizeof("_freshInstance"), 1734543825UL, (void*)&zv, sizeof(zval*), NULL);
	}

	return props;
}

static void phalcon_di_dtor(void *v TSRMLS_DC)
{
	phalcon_di_object *obj = v;

	zend_hash_destroy(obj->services);
	zend_hash_destroy(obj->shared);
	FREE_HASHTABLE(obj->services);
	FREE_HASHTABLE(obj->shared);

	zend_object_std_dtor(&obj->obj TSRMLS_CC);
	efree(obj);
}

static zend_object_value phalcon_di_ctor(zend_class_entry* ce TSRMLS_DC)
{
	phalcon_di_object *obj = ecalloc(1, sizeof(phalcon_di_object));
	zend_object_value retval;

	zend_object_std_init(&obj->obj, ce TSRMLS_CC);
	object_properties_init(&obj->obj, ce);

	ALLOC_HASHTABLE(obj->services);
	ALLOC_HASHTABLE(obj->shared);
	zend_hash_init(obj->services, 32, NULL, ZVAL_PTR_DTOR, 0);
	zend_hash_init(obj->shared, 8, NULL, ZVAL_PTR_DTOR, 0);

	retval.handle = zend_objects_store_put(
		obj,
		(zend_objects_store_dtor_t)zend_objects_destroy_object,
		phalcon_di_dtor,
		NULL TSRMLS_CC
	);

	retval.handlers = &phalcon_di_object_handlers;
	return retval;
}

static zend_object_value phalcon_di_clone_obj(zval *zobject TSRMLS_DC)
{
	zend_object_value new_obj_val;
	phalcon_di_object *old_object;
	phalcon_di_object *new_object;
	zend_object_handle handle = Z_OBJ_HANDLE_P(zobject);

	old_object  = phalcon_di_get_object(zobject TSRMLS_CC);
	new_obj_val = phalcon_di_ctor(Z_OBJCE_P(zobject) TSRMLS_CC);
	new_object  = zend_object_store_get_object_by_handle(new_obj_val.handle TSRMLS_CC);

	zend_objects_clone_members(&new_object->obj, new_obj_val, &old_object->obj, handle TSRMLS_CC);

	zend_hash_copy(new_object->services, old_object->services, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
	zend_hash_copy(new_object->shared, old_object->shared, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
	new_object->fresh = old_object->fresh;

	return new_obj_val;
}

static void phalcon_di_set_services(zval *this_ptr, zval *services TSRMLS_DC)
{
	phalcon_di_object *obj = phalcon_di_get_object(this_ptr TSRMLS_CC);
	zend_hash_copy(obj->services, Z_ARRVAL_P(services), (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
}

static PHP_METHOD(Phalcon_DI, __construct);
static PHP_METHOD(Phalcon_DI, set);
static PHP_METHOD(Phalcon_DI, setShared);
static PHP_METHOD(Phalcon_DI, remove);
static PHP_METHOD(Phalcon_DI, attempt);
static PHP_METHOD(Phalcon_DI, getRaw);
static PHP_METHOD(Phalcon_DI, setService);
static PHP_METHOD(Phalcon_DI, getService);
static PHP_METHOD(Phalcon_DI, get);
static PHP_METHOD(Phalcon_DI, getShared);
static PHP_METHOD(Phalcon_DI, has);
static PHP_METHOD(Phalcon_DI, wasFreshInstance);
static PHP_METHOD(Phalcon_DI, getServices);
static PHP_METHOD(Phalcon_DI, __call);
static PHP_METHOD(Phalcon_DI, setDefault);
static PHP_METHOD(Phalcon_DI, getDefault);
static PHP_METHOD(Phalcon_DI, reset);
static PHP_METHOD(Phalcon_DI, __clone);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_di___call, 0, 0, 1)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_di_setshared, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_di_attempt, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, definition)
	ZEND_ARG_INFO(0, shared)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_di_getraw, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_di_method_entry[] = {
	PHP_ME(Phalcon_DI, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	/* Phalcon\DiInterface*/
	PHP_ME(Phalcon_DI, set, arginfo_phalcon_diinterface_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, remove, arginfo_phalcon_diinterface_remove, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, getRaw, arginfo_phalcon_di_getraw, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, getService, arginfo_phalcon_diinterface_getservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, setService, arginfo_phalcon_diinterface_setservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, get, arginfo_phalcon_diinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, getShared, arginfo_phalcon_diinterface_getshared, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, has, arginfo_phalcon_diinterface_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, wasFreshInstance, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, getServices, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, setDefault, arginfo_phalcon_diinterface_setdefault, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_DI, getDefault, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_DI, reset, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)

	/* Convenience methods */
	PHP_ME(Phalcon_DI, attempt, arginfo_phalcon_di_attempt, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, setShared, arginfo_phalcon_di_setshared, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_DI, setRaw, setService, arginfo_phalcon_diinterface_setservice, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)

	/* Syntactic sugar */
	PHP_MALIAS(Phalcon_DI, offsetExists, has, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_DI, offsetSet, setShared, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_DI, offsetGet, getShared, arginfo_arrayaccess_offsetget, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_DI, offsetUnset, remove, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI, __call, arginfo_phalcon_di___call, ZEND_ACC_PUBLIC)

	/* Misc */
	PHP_ME(Phalcon_DI, __clone, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DI){

	PHALCON_REGISTER_CLASS(Phalcon, DI, di, phalcon_di_method_entry, 0);

	zend_declare_property_null(phalcon_di_ce, SL("_default"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_class_implements(phalcon_di_ce TSRMLS_CC, 1, phalcon_diinterface_ce);

	phalcon_di_ce->create_object = phalcon_di_ctor;
	phalcon_di_ce->serialize     = zend_class_serialize_deny;
	phalcon_di_ce->unserialize   = zend_class_unserialize_deny;

	phalcon_di_object_handlers = *zend_get_std_object_handlers();
	phalcon_di_object_handlers.read_dimension  = phalcon_di_read_dimension;
	phalcon_di_object_handlers.has_dimension   = phalcon_di_has_dimension;
	phalcon_di_object_handlers.write_dimension = phalcon_di_write_dimension;
	phalcon_di_object_handlers.unset_dimension = phalcon_di_unset_dimension;
	phalcon_di_object_handlers.get_method      = phalcon_di_get_method;
	phalcon_di_object_handlers.call_method     = (zend_object_call_method_t)phalcon_di_call_method;
	phalcon_di_object_handlers.clone_obj       = phalcon_di_clone_obj;

	if (!nusphere_dbg_present) {
		phalcon_di_object_handlers.get_properties = phalcon_di_get_properties;
	}

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI, __construct){

	zval *default_di;

	default_di = phalcon_fetch_static_property_ce(phalcon_di_ce, SL("_default") TSRMLS_CC);
	if (Z_TYPE_P(default_di) == IS_NULL) {
		phalcon_update_static_property_ce(phalcon_di_ce, SL("_default"), this_ptr TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_DI, set) {

	zval **name, **definition, **shared = NULL, *service;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(2, 1, &name, &definition, &shared);
	PHALCON_ENSURE_IS_STRING(name);
	
	if (!shared) {
		shared = &PHALCON_GLOBAL(z_false);
	}

	MAKE_STD_ZVAL(service);
	object_init_ex(service, phalcon_di_service_ce);
	/* Won't throw exceptions */
	PHALCON_CALL_METHODW(NULL, service, "__construct", *name, *definition, *shared);

	obj = phalcon_di_get_object(getThis() TSRMLS_CC);

	zend_hash_update(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, &service, sizeof(zval*), NULL);
	RETURN_ZVAL(service, 1, 0);
}

static PHP_METHOD(Phalcon_DI, setShared){

	zval **name, **definition, *retval;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(2, 0, &name, &definition);
	PHALCON_ENSURE_IS_STRING(name);

	obj    = phalcon_di_get_object(getThis() TSRMLS_CC);
	retval = phalcon_di_write_dimension_internal(obj, *name, *definition TSRMLS_CC);
	RETURN_ZVAL(retval, 1, 0);
}

static PHP_METHOD(Phalcon_DI, remove){

	zval **name;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);
	
	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	phalcon_di_unset_dimension_internal(obj, *name);
}

static PHP_METHOD(Phalcon_DI, attempt){

	zval **name, **definition, **shared = NULL;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(2, 1, &name, &definition, &shared);
	PHALCON_ENSURE_IS_STRING(name);
	
	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	if (!zend_symtable_exists(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1)) {
		PHALCON_MM_GROW();

		if (!shared) {
			shared = &PHALCON_GLOBAL(z_false);
		}

		object_init_ex(return_value, phalcon_di_service_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", *name, *definition, *shared);
	
		Z_ADDREF_P(return_value);
		zend_hash_update(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, &return_value, sizeof(zval*), NULL);

		PHALCON_MM_RESTORE();
	}
}

static PHP_METHOD(Phalcon_DI, setService)
{
	zval **name_or_def, **raw_definition = NULL;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 1, &name_or_def, &raw_definition);

	obj = phalcon_di_get_object(getThis() TSRMLS_CC);

	if (raw_definition != NULL) {
		zval *name = NULL;
		raw_definition = name_or_def;
		PHALCON_VERIFY_INTERFACE_EX(*raw_definition, phalcon_di_serviceinterface_ce, phalcon_di_exception_ce, 0);

		PHALCON_CALL_METHODW(&name, *raw_definition, "getname");

		Z_ADDREF_PP(raw_definition);
		zend_hash_update(obj->services, Z_STRVAL_P(name), Z_STRLEN_P(name)+1, (void*)raw_definition, sizeof(zval*), NULL);
		zval_ptr_dtor(&name);
	}
	else {
		zval **name = name_or_def;
		PHALCON_ENSURE_IS_STRING(name);
		PHALCON_VERIFY_INTERFACE_EX(*raw_definition, phalcon_di_serviceinterface_ce, phalcon_di_exception_ce, 0);

		Z_ADDREF_PP(raw_definition);
		zend_hash_update(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, (void*)raw_definition, sizeof(zval*), NULL);
	}

	RETURN_ZVAL(*raw_definition, 1, 0);
}

static PHP_METHOD(Phalcon_DI, getRaw){

	zval **name, **service;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);

	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	if (SUCCESS == zend_symtable_find(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, (void**)&service)) {
		PHALCON_RETURN_CALL_METHODW(*service, "getdefinition");
		return;
	}

	zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Service '%s' was not found in the dependency injection container", Z_STRVAL_PP(name));
}

static PHP_METHOD(Phalcon_DI, getService){

	zval **name, **service;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);
	
	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	if (SUCCESS == zend_symtable_find(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, (void**)&service)) {
		RETURN_ZVAL(*service, 1, 0);
	}

	zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Service '%s' was not found in the dependency injection container", Z_STRVAL_PP(name));
}

static PHP_METHOD(Phalcon_DI, get){

	zval **name, **parameters = NULL, **service;
	phalcon_di_object *obj;
	zend_class_entry *ce;

	phalcon_fetch_params_ex(1, 1, &name, &parameters);
	PHALCON_ENSURE_IS_STRING(name);
	
	if (!parameters) {
		parameters = &PHALCON_GLOBAL(z_null);
	}

	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	if (SUCCESS == zend_symtable_find(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, (void**)&service)) {
		/* The service is registered in the DI */
		PHALCON_RETURN_CALL_METHODW(*service, "resolve", *parameters, this_ptr);

		if (return_value_ptr) {
			return_value = *return_value_ptr;
		}

		ce = (Z_TYPE_P(return_value) == IS_OBJECT) ? Z_OBJCE_P(return_value) : NULL;
	}
	else {
		/* The DI also acts as builder for any class even if it isn't defined in the DI */
		if (phalcon_class_exists_ex(&ce, *name, 1 TSRMLS_CC)) {
			if (FAILURE == phalcon_create_instance_params_ce(return_value, ce, *parameters TSRMLS_CC)) {
				return;
			}
		}
		else {
			zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Service '%s' was not found in the dependency injection container", Z_STRVAL_PP(name));
			return;
		}
	}

	/* Pass the DI itself if the instance implements Phalcon\DI\InjectionAwareInterface */
	if (ce && instanceof_function_ex(ce, phalcon_di_injectionawareinterface_ce, 1 TSRMLS_CC)) {
		PHALCON_CALL_METHODW(NULL, return_value, "setdi", this_ptr);
	}
}

static PHP_METHOD(Phalcon_DI, getShared){

	zval **name, **parameters = NULL;
	zval *retval;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 1, &name, &parameters);
	PHALCON_ENSURE_IS_STRING(name);
	if (!parameters) {
		parameters = &PHALCON_GLOBAL(z_null);
	}

	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	
	retval = phalcon_di_read_dimension_internal(getThis(), obj, *name, *parameters TSRMLS_CC);
	if (retval) {
		RETURN_ZVAL(retval, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_DI, has){

	zval **name;
	phalcon_di_object *obj;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);
	
	obj = phalcon_di_get_object(getThis() TSRMLS_CC);
	RETURN_BOOL(zend_symtable_exists(obj->services, Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1));
}

static PHP_METHOD(Phalcon_DI, wasFreshInstance){

	phalcon_di_object *obj = phalcon_di_get_object(getThis() TSRMLS_CC);

	RETURN_BOOL(obj->fresh);
}

static PHP_METHOD(Phalcon_DI, getServices){

	phalcon_di_object *obj = phalcon_di_get_object(getThis() TSRMLS_CC);

	array_init_size(return_value, zend_hash_num_elements(obj->services));
	zend_hash_copy(Z_ARRVAL_P(return_value), obj->services, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
}





static PHP_METHOD(Phalcon_DI, __call){

	zval **method, **arguments = NULL;

	phalcon_fetch_params_ex(1, 1, &method, &arguments);
	PHALCON_ENSURE_IS_STRING(method);

	if (!arguments) {
		arguments = &PHALCON_GLOBAL(z_null);
	}
	
	phalcon_di_call_method_internal(return_value, return_value_ptr, getThis(), Z_STRVAL_PP(method), *arguments TSRMLS_CC);
}

static PHP_METHOD(Phalcon_DI, setDefault){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	
	phalcon_update_static_property_ce(phalcon_di_ce, SL("_default"), dependency_injector TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_DI, getDefault){

	zval *default_di;

	default_di = phalcon_fetch_static_property_ce(phalcon_di_ce, SL("_default") TSRMLS_CC);
	RETURN_CTORW(default_di);
}

static PHP_METHOD(Phalcon_DI, reset){

	zend_update_static_property_null(phalcon_di_ce, SL("_default") TSRMLS_CC);
}

static PHP_METHOD(Phalcon_DI, __clone) {
}





#include <Zend/zend_interfaces.h>


zend_class_entry *phalcon_diinterface_ce;

static const zend_function_entry phalcon_diinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_DiInterface, set, arginfo_phalcon_diinterface_set)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, remove, arginfo_phalcon_diinterface_remove)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, get, arginfo_phalcon_diinterface_get)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, getShared, arginfo_phalcon_diinterface_getshared)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, setService, arginfo_phalcon_diinterface_setservice)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, getService, arginfo_phalcon_diinterface_getservice)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, has, arginfo_phalcon_diinterface_has)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, wasFreshInstance, NULL)
	PHP_ABSTRACT_ME(Phalcon_DiInterface, getServices, NULL)
	ZEND_FENTRY(setDefault, NULL, arginfo_phalcon_diinterface_setdefault, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(getDefault, NULL, NULL, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(reset, NULL, NULL, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_DiInterface){

	PHALCON_REGISTER_INTERFACE_EX(Phalcon, DiInterface, diinterface, zend_ce_arrayaccess, phalcon_diinterface_method_entry);

	return SUCCESS;
}



















zend_class_entry *phalcon_dispatcher_ce;

static PHP_METHOD(Phalcon_Dispatcher, __construct);
static PHP_METHOD(Phalcon_Dispatcher, setDI);
static PHP_METHOD(Phalcon_Dispatcher, getDI);
static PHP_METHOD(Phalcon_Dispatcher, setEventsManager);
static PHP_METHOD(Phalcon_Dispatcher, getEventsManager);
static PHP_METHOD(Phalcon_Dispatcher, setActionSuffix);
static PHP_METHOD(Phalcon_Dispatcher, setModuleName);
static PHP_METHOD(Phalcon_Dispatcher, getModuleName);
static PHP_METHOD(Phalcon_Dispatcher, setNamespaceName);
static PHP_METHOD(Phalcon_Dispatcher, getNamespaceName);
static PHP_METHOD(Phalcon_Dispatcher, setDefaultNamespace);
static PHP_METHOD(Phalcon_Dispatcher, getDefaultNamespace);
static PHP_METHOD(Phalcon_Dispatcher, setDefaultAction);
static PHP_METHOD(Phalcon_Dispatcher, setActionName);
static PHP_METHOD(Phalcon_Dispatcher, getActionName);
static PHP_METHOD(Phalcon_Dispatcher, setParams);
static PHP_METHOD(Phalcon_Dispatcher, getParams);
static PHP_METHOD(Phalcon_Dispatcher, setParam);
static PHP_METHOD(Phalcon_Dispatcher, getParam);
static PHP_METHOD(Phalcon_Dispatcher, getActiveMethod);
static PHP_METHOD(Phalcon_Dispatcher, isFinished);
static PHP_METHOD(Phalcon_Dispatcher, setReturnedValue);
static PHP_METHOD(Phalcon_Dispatcher, getReturnedValue);
static PHP_METHOD(Phalcon_Dispatcher, dispatch);
static PHP_METHOD(Phalcon_Dispatcher, forward);
static PHP_METHOD(Phalcon_Dispatcher, wasForwarded);
static PHP_METHOD(Phalcon_Dispatcher, getHandlerClass);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcher_setmodulename, 0, 0, 1)
	ZEND_ARG_INFO(0, moduleName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcher_setnamespacename, 0, 0, 1)
	ZEND_ARG_INFO(0, namespaceName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_dispatcher_setreturnedvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_dispatcher_method_entry[] = {
	PHP_ME(Phalcon_Dispatcher, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Dispatcher, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setActionSuffix, arginfo_phalcon_dispatcherinterface_setactionsuffix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setModuleName, arginfo_phalcon_dispatcher_setmodulename, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getModuleName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setNamespaceName, arginfo_phalcon_dispatcher_setnamespacename, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getNamespaceName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setDefaultNamespace, arginfo_phalcon_dispatcherinterface_setdefaultnamespace, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getDefaultNamespace, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setDefaultAction, arginfo_phalcon_dispatcherinterface_setdefaultaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setActionName, arginfo_phalcon_dispatcherinterface_setactionname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getActionName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setParams, arginfo_phalcon_dispatcherinterface_setparams, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getParams, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setParam, arginfo_phalcon_dispatcherinterface_setparam, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getParam, arginfo_phalcon_dispatcherinterface_getparam, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getActiveMethod, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, isFinished, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, setReturnedValue, arginfo_phalcon_dispatcher_setreturnedvalue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getReturnedValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, dispatch, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, forward, arginfo_phalcon_dispatcherinterface_forward, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, wasForwarded, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Dispatcher, getHandlerClass, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Dispatcher){

	PHALCON_REGISTER_CLASS(Phalcon, Dispatcher, dispatcher, phalcon_dispatcher_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_dispatcher_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_activeHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_finished"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_dispatcher_ce, SL("_forwarded"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_moduleName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_namespaceName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_handlerName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_actionName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_returnedValue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_lastHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_defaultNamespace"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_defaultHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_defaultAction"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_handlerSuffix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_dispatcher_ce, SL("_actionSuffix"), "Action", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_dispatcher_ce, SL("_isExactHandler"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_previousHandlerName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_dispatcher_ce, SL("_previousActionName"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_NO_DI"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_CYCLIC_ROUTING"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_HANDLER_NOT_FOUND"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_INVALID_HANDLER"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_INVALID_PARAMS"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_dispatcher_ce, SL("EXCEPTION_ACTION_NOT_FOUND"), 5 TSRMLS_CC);

	zend_class_implements(phalcon_dispatcher_ce TSRMLS_CC, 3, phalcon_dispatcherinterface_ce, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Dispatcher, __construct){

	phalcon_update_property_empty_array(this_ptr, SL("_params") TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Dispatcher, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Dispatcher, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);

	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setActionSuffix){

	zval *action_suffix;

	phalcon_fetch_params(0, 1, 0, &action_suffix);

	phalcon_update_property_this_quick(this_ptr, SL("_actionSuffix"), action_suffix, 879621975UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, setModuleName){

	zval *module_name;

	phalcon_fetch_params(0, 1, 0, &module_name);

	phalcon_update_property_this_quick(this_ptr, SL("_moduleName"), module_name, 4053279339UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getModuleName){


	RETURN_MEMBER_QUICK(this_ptr, "_moduleName", 4053279339UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setNamespaceName){

	zval *namespace_name;

	phalcon_fetch_params(0, 1, 0, &namespace_name);

	phalcon_update_property_this_quick(this_ptr, SL("_namespaceName"), namespace_name, 816833906UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getNamespaceName){


	RETURN_MEMBER_QUICK(this_ptr, "_namespaceName", 816833906UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setDefaultNamespace){

	zval *namespace;

	phalcon_fetch_params(0, 1, 0, &namespace);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultNamespace"), namespace, 761145590UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getDefaultNamespace){


	RETURN_MEMBER_QUICK(this_ptr, "_defaultNamespace", 761145590UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setDefaultAction){

	zval *action_name;

	phalcon_fetch_params(0, 1, 0, &action_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultAction"), action_name, 895696999UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, setActionName){

	zval *action_name;

	phalcon_fetch_params(0, 1, 0, &action_name);

	phalcon_update_property_this_quick(this_ptr, SL("_actionName"), action_name, 2975797059UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getActionName){


	RETURN_MEMBER_QUICK(this_ptr, "_actionName", 2975797059UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setParams){

	zval *params, *exception_message;

	phalcon_fetch_params(0, 1, 0, &params);

	if (Z_TYPE_P(params) != IS_ARRAY) {
		PHALCON_MM_GROW();
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "Parameters must be an Array", 1);
		PHALCON_CALL_METHOD(NULL, this_ptr, "_throwdispatchexception", exception_message);
		RETURN_MM_NULL();
	}

	phalcon_update_property_this_quick(this_ptr, SL("_params"), params, 3223731112UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Dispatcher, getParams){


	RETURN_MEMBER_QUICK(this_ptr, "_params", 3223731112UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setParam){

	zval *param, *value;

	phalcon_fetch_params(0, 2, 0, &param, &value);

	phalcon_update_property_array(this_ptr, SL("_params"), param, value TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getParam){

	zval *param, *filters = NULL, *default_value = NULL;
	zval *exception_code;
	zval *exception_message, *service, *filter = NULL;
	zval *params, *param_value, *dependency_injector;

	phalcon_fetch_params(0, 1, 2, &param, &filters, &default_value);

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&param_value, params, param)) {

		if (filters && Z_TYPE_P(filters) != IS_NULL) {
			PHALCON_MM_GROW();
			dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_INIT_VAR(exception_code);
				ZVAL_LONG(exception_code, 0);

				PHALCON_INIT_VAR(exception_message);
				ZVAL_STRING(exception_message, "A dependency injection object is required to access the 'filter' service", 1);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_throwdispatchexception", exception_message, exception_code);
				RETURN_MM();
			}

			PHALCON_INIT_VAR(service);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);

			PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
			PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
			PHALCON_RETURN_CALL_METHOD(filter, "sanitize", param_value, filters);
			RETURN_MM();
		} else {
			RETURN_ZVAL(param_value, 1, 0);
		}
	}

	if (default_value) {
		RETURN_ZVAL(default_value, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Dispatcher, getActiveMethod){

	zval *suffix, *action_name;

	suffix      = phalcon_fetch_nproperty_this(this_ptr, SL("_actionSuffix"), PH_NOISY TSRMLS_CC);
	action_name = phalcon_fetch_nproperty_this(this_ptr, SL("_actionName"), PH_NOISY TSRMLS_CC);

	PHALCON_CONCAT_VV(return_value, action_name, suffix);
}

static PHP_METHOD(Phalcon_Dispatcher, isFinished){


	RETURN_MEMBER_QUICK(this_ptr, "_finished", 385784334UL);
}

static PHP_METHOD(Phalcon_Dispatcher, setReturnedValue){

	zval *value;

	phalcon_fetch_params(0, 1, 0, &value);

	phalcon_update_property_this_quick(this_ptr, SL("_returnedValue"), value, 4143876906UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Dispatcher, getReturnedValue){


	RETURN_MEMBER_QUICK(this_ptr, "_returnedValue", 4143876906UL);
}

static int phalcon_dispatcher_fire_event(zval **return_value_ptr, zval *mgr, const char *event, zval *source, zval *data TSRMLS_DC)
{
	if (mgr) {
		zval *event_name;
		int status, status2;
		zend_uint nparams = (data ? 3 : 2);
		zval *params[3];

		MAKE_STD_ZVAL(event_name);
		ZVAL_STRING(event_name, event, 0);

		params[0] = event_name;
		params[1] = source;
		params[2] = data;

		status = phalcon_call_method(return_value_ptr, mgr, "fire", nparams, params TSRMLS_CC);

		if (EG(exception)) {
			zval *exception = EG(exception);
			Z_ADDREF_P(exception);

			zend_clear_exception(TSRMLS_C);

			assert(Z_REFCOUNT_P(exception) == 1);
			/* exception will be destroyed automatically after return from _handleexception */
			Z_DELREF_P(exception);

			/* source == this_ptr */
			assert(Z_TYPE_P(source) == IS_OBJECT && instanceof_function_ex(Z_OBJCE_P(source), phalcon_dispatcherinterface_ce, 1 TSRMLS_CC));
			if (is_phalcon_class(Z_OBJCE_P(source))) {
				zval *params[] = { event_name, source, exception };
				/* Shortcut, save one method call */
				ZVAL_STRING(event_name, "dispatch:beforeException", 0);
				status2 = phalcon_call_method(NULL, mgr, "fire", 3, params TSRMLS_CC);
			}
			else {
				zval *params[] = { exception };
				status2 = phalcon_call_method(NULL, source, "_handleexception", 1, params TSRMLS_CC);
			}

			if (FAILURE == status2) {
				status = FAILURE;
			}
		}

		ZVAL_NULL(event_name);
		zval_ptr_dtor(&event_name);
		return status;
	}
	else if (return_value_ptr) {
		MAKE_STD_ZVAL(*return_value_ptr);
		ZVAL_TRUE(*return_value_ptr);
	}

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Dispatcher, dispatch){

	zval *exception_code = NULL;
	zval *exception_message = NULL;
	zval *status = NULL, *value = NULL, *handler = NULL;
	zval *camelized_class = NULL, *handler_class = NULL, *has_service = NULL;
	zval *was_fresh = NULL, *action_method = NULL, *params = NULL, *call_object = NULL;
	zval *exception = NULL;
	zval *dependency_injector, *events_manager, *tmp;
	zval *handler_suffix, *action_suffix, *namespace_name, *handler_name, *action_name;
	int number_dispatches = 0;

	PHALCON_MM_GROW();

	dependency_injector = phalcon_fetch_property_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (!dependency_injector || Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(exception_code);
		ZVAL_LONG(exception_code, 0);

		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "A dependency injection container is required to access related dispatching services", 1);
		PHALCON_CALL_METHOD(NULL, this_ptr, "_throwdispatchexception", exception_message, exception_code);
		RETURN_MM();
	}

	events_manager = phalcon_fetch_property_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (events_manager && Z_TYPE_P(events_manager) != IS_OBJECT) {
		events_manager = NULL;
	}

	PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
	RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:beforeDispatchLoop", this_ptr, NULL TSRMLS_CC));
	if (PHALCON_IS_FALSE(status)) {
		RETURN_MM_FALSE;
	}

	PHALCON_INIT_VAR(value);

	PHALCON_INIT_VAR(handler);

	handler_suffix = phalcon_fetch_nproperty_this(this_ptr, SL("_handlerSuffix"), PH_NOISY TSRMLS_CC);
	action_suffix  = phalcon_fetch_nproperty_this(this_ptr, SL("_actionSuffix"), PH_NOISY TSRMLS_CC);

	phalcon_update_property_this(this_ptr, SL("_finished"), PHALCON_GLOBAL(z_false) TSRMLS_CC);

	while (1) {

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(tmp)) {
			break;
		}

		++number_dispatches;

		if (number_dispatches == 256) {
			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 1);

			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Dispatcher has detected a cyclic routing causing stability problems", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "_throwdispatchexception", exception_message, exception_code);
			break;
		}

		phalcon_update_property_this(this_ptr, SL("_finished"), PHALCON_GLOBAL(z_true) TSRMLS_CC);

		namespace_name = phalcon_fetch_nproperty_this(this_ptr, SL("_namespaceName"), PH_NOISY TSRMLS_CC);
		if (!zend_is_true(namespace_name)) {
			namespace_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultNamespace"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_namespaceName"), namespace_name, 816833906UL TSRMLS_CC);
		}

		handler_name = phalcon_fetch_nproperty_this(this_ptr, SL("_handlerName"), PH_NOISY TSRMLS_CC);
		if (!zend_is_true(handler_name)) {
			handler_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultHandler"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), handler_name, 2743819555UL TSRMLS_CC);
		}

		action_name = phalcon_fetch_nproperty_this(this_ptr, SL("_actionName"), PH_NOISY TSRMLS_CC);
		if (!zend_is_true(action_name)) {
			action_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAction"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_actionName"), action_name, 2975797059UL TSRMLS_CC);
		}

		if (events_manager) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
			RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:beforeDispatch", this_ptr, NULL TSRMLS_CC));
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}

			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_FALSE(tmp)) {
				continue;
			}
		}

		if (!phalcon_memnstr_str(handler_name, SL("\\"))) {
			PHALCON_INIT_NVAR(camelized_class);
			phalcon_camelize(camelized_class, handler_name);
		} else if (phalcon_start_with_str(handler_name, SL("\\"))) {
			PHALCON_INIT_NVAR(camelized_class);
			ZVAL_STRINGL(camelized_class, Z_STRVAL_P(handler_name)+1, Z_STRLEN_P(handler_name)-1, 1);
		} else {
			camelized_class = handler_name;
		}

		PHALCON_INIT_NVAR(handler_class);
		if (zend_is_true(namespace_name)) {
			if (phalcon_end_with_str(namespace_name, SL("\\"))) {
				PHALCON_CONCAT_VVV(handler_class, namespace_name, camelized_class, handler_suffix);
			} else {
				PHALCON_CONCAT_VSVV(handler_class, namespace_name, "\\", camelized_class, handler_suffix);
			}
		} else {
			PHALCON_CONCAT_VV(handler_class, camelized_class, handler_suffix);
		}

		PHALCON_CALL_METHOD(&has_service, dependency_injector, "has", handler_class);
		if (!zend_is_true(has_service)) {
			PHALCON_INIT_NVAR(has_service);
			assert(Z_TYPE_P(handler_class) == IS_STRING);
			ZVAL_LONG(has_service, phalcon_class_exists(Z_STRVAL_P(handler_class), Z_STRLEN_P(handler_class), 1 TSRMLS_CC));
		}

		if (!zend_is_true(has_service)) {

			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 2);

			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_VS(exception_message, handler_class, " handler class cannot be loaded");

			PHALCON_CALL_METHOD(&status, this_ptr, "_throwdispatchexception", exception_message, exception_code);
			if (PHALCON_IS_FALSE(status)) {

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}

			break;
		}

		PHALCON_CALL_METHOD(&handler, dependency_injector, "getshared", handler_class);
		if (Z_TYPE_P(handler) != IS_OBJECT) {

			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 3);

			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Invalid handler returned from the services container", 1);

			PHALCON_CALL_METHOD(&status, this_ptr, "_throwdispatchexception", exception_message, exception_code);
			if (PHALCON_IS_FALSE(status)) {

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}

			break;
		}

		PHALCON_CALL_METHOD(&was_fresh, dependency_injector, "wasfreshinstance");

		phalcon_update_property_this_quick(this_ptr, SL("_activeHandler"), handler, 2923197278UL TSRMLS_CC);

		PHALCON_INIT_NVAR(action_method);
		PHALCON_CONCAT_VV(action_method, action_name, action_suffix);
		if (phalcon_method_exists(handler, action_method TSRMLS_CC) == FAILURE) {

			if (events_manager) {
				PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
				RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:beforeNotFoundAction", this_ptr, NULL TSRMLS_CC));
				if (PHALCON_IS_FALSE(status)) {
					continue;
				}

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}

			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 5);

			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSVS(exception_message, "Action '", action_name, "' was not found on handler '", handler_name, "'");

			PHALCON_CALL_METHOD(&status, this_ptr, "_throwdispatchexception", exception_message, exception_code);
			if (PHALCON_IS_FALSE(status)) {

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}

			break;
		}

		if (events_manager) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
			RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:beforeExecuteRoute", this_ptr, NULL TSRMLS_CC));
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}

			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_FALSE(tmp)) {
				continue;
			}
		}

		if (phalcon_method_quick_exists_ex(handler, SS("beforeexecuteroute"), 3852116986UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(&status, handler, "beforeexecuteroute", this_ptr);
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}

			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_FALSE(tmp)) {
				continue;
			}
		}

		if (PHALCON_IS_TRUE(was_fresh)) {
			if (phalcon_method_quick_exists_ex(handler, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD(NULL, handler, "initialize");
			}

			if (events_manager) {
				PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
				RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:afterInitialize", this_ptr, NULL TSRMLS_CC));
				if (PHALCON_IS_FALSE(status)) {
					continue;
				}

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}
		}

		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(params) != IS_ARRAY) {

			PHALCON_INIT_NVAR(exception_code);
			ZVAL_LONG(exception_code, 4);

			PHALCON_INIT_NVAR(exception_message);
			ZVAL_STRING(exception_message, "Action parameters must be an Array", 1);

			PHALCON_CALL_METHOD(&status, this_ptr, "_throwdispatchexception", exception_message, exception_code);
			if (PHALCON_IS_FALSE(status)) {

				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}

			break;
		}

		PHALCON_INIT_NVAR(call_object);
		array_init_size(call_object, 2);
		phalcon_array_append(&call_object, handler, 0);
		phalcon_array_append(&call_object, action_method, 0);

		PHALCON_INIT_NVAR(value);
		/* Call the method allowing exceptions */
		PHALCON_CALL_USER_FUNC_ARRAY_NOEX(value, call_object, params);

		/* Check if an exception has ocurred */
		if (EG(exception)) {
			/* Copy the exception to rethrow it later if needed */
			PHALCON_CPY_WRT(exception, EG(exception));

			/* Clear the exception  */
			zend_clear_exception(TSRMLS_C);

			/* Try to handle the exception */
			PHALCON_CALL_METHOD(&status, this_ptr, "_handleexception", exception);
			if (PHALCON_IS_FALSE(status)) {
				tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_FALSE(tmp)) {
					continue;
				}
			}
			else {
				/* Exception was not handled, rethrow it */
				phalcon_throw_exception(exception TSRMLS_CC);
				RETURN_MM();
			}
		} else {
			/* Update the latest value produced by the latest handler */
			phalcon_update_property_this_quick(this_ptr, SL("_returnedValue"), value, 4143876906UL TSRMLS_CC);
		}

		phalcon_update_property_this_quick(this_ptr, SL("_lastHandler"), handler, 1315517974UL TSRMLS_CC);

		if (events_manager) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(status);
			RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(&status, events_manager, "dispatch:afterExecuteRoute", this_ptr, value TSRMLS_CC));
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}

			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_FALSE(tmp)) {
				continue;
			}

			RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(NULL, events_manager, "dispatch:afterDispatch", this_ptr, NULL TSRMLS_CC));
		}

		if (phalcon_method_quick_exists_ex(handler, SS("afterexecuteroute"), 2573764025UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(&status, handler, "afterexecuteroute", this_ptr, value);
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}

			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_finished"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_FALSE(tmp)) {
				continue;
			}
		}
	}

	RETURN_MM_ON_FAILURE(phalcon_dispatcher_fire_event(NULL, events_manager, "dispatch:afterDispatchLoop", this_ptr, NULL TSRMLS_CC));
	RETURN_CCTOR(handler);
}

static PHP_METHOD(Phalcon_Dispatcher, forward){

	zval *forward, *exception_message;
	zval *namespace_name, *controller_name, *task_name, *action_name, *params, *previous_controller_name, *previous_action_name;

	phalcon_fetch_params(0, 1, 0, &forward);

	if (Z_TYPE_P(forward) != IS_ARRAY) {
		PHALCON_MM_GROW();
		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "Forward parameter must be an Array", 1);
		PHALCON_CALL_METHOD(NULL, this_ptr, "_throwdispatchexception", exception_message);
		RETURN_MM_NULL();
	}

	previous_controller_name = phalcon_fetch_nproperty_this(this_ptr, SL("_handlerName"), PH_NOISY TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_previousHandlerName"), previous_controller_name, 1385015136UL TSRMLS_CC);

	previous_action_name = phalcon_fetch_nproperty_this(this_ptr, SL("_actionName"), PH_NOISY TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_previousActionName"), previous_action_name, 3455223264UL TSRMLS_CC);

	if (phalcon_array_isset_string_fetch(&namespace_name, forward, SS("namespace"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_namespaceName"), namespace_name, 816833906UL TSRMLS_CC);
	}

	if (phalcon_array_isset_string_fetch(&controller_name, forward, SS("controller"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), controller_name, 2743819555UL TSRMLS_CC);
	} else {
		if (phalcon_array_isset_string_fetch(&task_name, forward, SS("task"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), task_name, 2743819555UL TSRMLS_CC);
		}
	}

	if (phalcon_array_isset_string_fetch(&action_name, forward, SS("action"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_actionName"), action_name, 2975797059UL TSRMLS_CC);
	}

	if (phalcon_array_isset_string_fetch(&params, forward, SS("params"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_params"), params, 3223731112UL TSRMLS_CC);
	}

	phalcon_update_property_this(this_ptr, SL("_finished"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_forwarded"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Dispatcher, wasForwarded){


	RETURN_MEMBER_QUICK(this_ptr, "_forwarded", 1865074274UL);
}

static PHP_METHOD(Phalcon_Dispatcher, getHandlerClass){

	zval *camelized_class = NULL;
	zval *handler_suffix, *namespace_name, *handler_name;

	PHALCON_MM_GROW();

	handler_suffix = phalcon_fetch_nproperty_this(this_ptr, SL("_handlerSuffix"), PH_NOISY TSRMLS_CC);

	namespace_name = phalcon_fetch_nproperty_this(this_ptr, SL("_namespaceName"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(namespace_name)) {
		namespace_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultNamespace"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_namespaceName"), namespace_name, 816833906UL TSRMLS_CC);
	}

	handler_name = phalcon_fetch_nproperty_this(this_ptr, SL("_handlerName"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(handler_name)) {
		handler_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultHandler"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), handler_name, 2743819555UL TSRMLS_CC);
	}

	if (!phalcon_memnstr_str(handler_name, SL("\\"))) {
		PHALCON_INIT_VAR(camelized_class);
		phalcon_camelize(camelized_class, handler_name);
	} else if (phalcon_start_with_str(handler_name, SL("\\"))) {
		PHALCON_INIT_VAR(camelized_class);
		ZVAL_STRINGL(camelized_class, Z_STRVAL_P(handler_name)+1, Z_STRLEN_P(handler_name)-1, 1);
	} else {
		camelized_class = handler_name;
	}

	if (zend_is_true(namespace_name)) {
		if (phalcon_end_with_str(namespace_name, SL("\\"))) {
			PHALCON_CONCAT_VVV(return_value, namespace_name, camelized_class, handler_suffix);
		} else {
			PHALCON_CONCAT_VSVV(return_value, namespace_name, "\\", camelized_class, handler_suffix);
		}
	} else {
		PHALCON_CONCAT_VV(return_value, camelized_class, handler_suffix);
	}

	phalcon_update_property_this(this_ptr, SL("_isExactHandler"), PHALCON_GLOBAL(z_false) TSRMLS_CC);

	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_dispatcherinterface_ce;

static const zend_function_entry phalcon_dispatcherinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setActionSuffix, arginfo_phalcon_dispatcherinterface_setactionsuffix)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setDefaultNamespace, arginfo_phalcon_dispatcherinterface_setdefaultnamespace)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setDefaultAction, arginfo_phalcon_dispatcherinterface_setdefaultaction)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setActionName, arginfo_phalcon_dispatcherinterface_setactionname)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, getActionName, NULL)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setParams, arginfo_phalcon_dispatcherinterface_setparams)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, getParams, NULL)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, setParam, arginfo_phalcon_dispatcherinterface_setparam)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, getParam, arginfo_phalcon_dispatcherinterface_getparam)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, isFinished, NULL)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, getReturnedValue, NULL)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, dispatch, NULL)
	PHP_ABSTRACT_ME(Phalcon_DispatcherInterface, forward, arginfo_phalcon_dispatcherinterface_forward)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DispatcherInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, DispatcherInterface, dispatcherinterface, phalcon_dispatcherinterface_method_entry);

	return SUCCESS;
}


















#include <ext/standard/html.h>


zend_class_entry *phalcon_escaper_ce;

static PHP_METHOD(Phalcon_Escaper, setEncoding);
static PHP_METHOD(Phalcon_Escaper, getEncoding);
static PHP_METHOD(Phalcon_Escaper, setHtmlQuoteType);
static PHP_METHOD(Phalcon_Escaper, detectEncoding);
static PHP_METHOD(Phalcon_Escaper, normalizeEncoding);
static PHP_METHOD(Phalcon_Escaper, escapeHtml);
static PHP_METHOD(Phalcon_Escaper, escapeHtmlAttr);
static PHP_METHOD(Phalcon_Escaper, escapeCss);
static PHP_METHOD(Phalcon_Escaper, escapeJs);
static PHP_METHOD(Phalcon_Escaper, escapeUrl);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_escaper_detectencoding, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_escaper_normalizeencoding, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_escaper_method_entry[] = {
	PHP_ME(Phalcon_Escaper, setEncoding, arginfo_phalcon_escaperinterface_setencoding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, getEncoding, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, setHtmlQuoteType, arginfo_phalcon_escaperinterface_sethtmlquotetype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, detectEncoding, arginfo_phalcon_escaper_detectencoding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, normalizeEncoding, arginfo_phalcon_escaper_normalizeencoding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, escapeHtml, arginfo_phalcon_escaperinterface_escapehtml, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, escapeHtmlAttr, arginfo_phalcon_escaperinterface_escapehtmlattr, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, escapeCss, arginfo_phalcon_escaperinterface_escapecss, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, escapeJs, arginfo_phalcon_escaperinterface_escapejs, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Escaper, escapeUrl, arginfo_phalcon_escaperinterface_escapeurl, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Escaper){

	PHALCON_REGISTER_CLASS(Phalcon, Escaper, escaper, phalcon_escaper_method_entry, 0);

	zend_declare_property_string(phalcon_escaper_ce, SL("_encoding"), "utf-8", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_escaper_ce, SL("_htmlEscapeMap"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_escaper_ce, SL("_htmlQuoteType"), 3, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_escaper_ce TSRMLS_CC, 1, phalcon_escaperinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Escaper, setEncoding){

	zval **encoding;

	phalcon_fetch_params_ex(1, 0, &encoding);
	PHALCON_ENSURE_IS_STRING(encoding);
	phalcon_update_property_this(this_ptr, SL("_encoding"), *encoding TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Escaper, getEncoding){


	RETURN_MEMBER_QUICK(this_ptr, "_encoding", 4261080171UL);
}

static PHP_METHOD(Phalcon_Escaper, setHtmlQuoteType){

	zval **quote_type;

	phalcon_fetch_params_ex(1, 0, &quote_type);
	PHALCON_ENSURE_IS_LONG(quote_type);
	phalcon_update_property_this(this_ptr, SL("_htmlQuoteType"), *quote_type TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Escaper, detectEncoding){

	zval *str, *charset = NULL, *strict_check, *detected = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &str);

	PHALCON_INIT_VAR(charset);
	phalcon_is_basic_charset(charset, str);
	if (Z_TYPE_P(charset) == IS_STRING) {
		RETURN_CTOR(charset);
	}

	if (phalcon_function_quick_exists_ex(SS("mb_detect_encoding"), 2715391634UL TSRMLS_CC) == FAILURE) {
		RETURN_MM_NULL();
	}

	strict_check = PHALCON_GLOBAL(z_true);

	PHALCON_INIT_NVAR(charset);
	ZVAL_STRING(charset, "UTF-32", 1);

	PHALCON_CALL_FUNCTION(&detected, "mb_detect_encoding", str, charset, strict_check);
	if (zend_is_true(detected)) {
		RETURN_CTOR(charset);
	}

	PHALCON_INIT_NVAR(charset);
	ZVAL_STRING(charset, "UTF-16", 1);

	PHALCON_CALL_FUNCTION(&detected, "mb_detect_encoding", str, charset, strict_check);
	if (zend_is_true(detected)) {
		RETURN_CTOR(charset);
	}

	PHALCON_INIT_NVAR(charset);
	ZVAL_STRING(charset, "UTF-8", 1);

	PHALCON_CALL_FUNCTION(&detected, "mb_detect_encoding", str, charset, strict_check);
	if (zend_is_true(detected)) {
		RETURN_CTOR(charset);
	}

	PHALCON_INIT_NVAR(charset);
	ZVAL_STRING(charset, "ISO-8859-1", 1);

	PHALCON_CALL_FUNCTION(&detected, "mb_detect_encoding", str, charset, strict_check);
	if (zend_is_true(detected)) {
		RETURN_CTOR(charset);
	}

	PHALCON_INIT_NVAR(charset);
	ZVAL_STRING(charset, "ASCII", 1);

	PHALCON_CALL_FUNCTION(&detected, "mb_detect_encoding", str, charset, strict_check);
	if (zend_is_true(detected)) {
		RETURN_CTOR(charset);
	}

	PHALCON_RETURN_CALL_FUNCTION("mb_detect_encoding", str);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Escaper, normalizeEncoding){

	zval *str, *encoding = NULL, *charset;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &str);

	if (phalcon_function_quick_exists_ex(SS("mb_convert_encoding"), 2165643194UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_escaper_exception_ce, "Extension 'mbstring' is required");
		return;
	}

	PHALCON_CALL_METHOD(&encoding, this_ptr, "detectencoding", str);

	PHALCON_INIT_VAR(charset);
	ZVAL_STRING(charset, "UTF-32", 1);

	PHALCON_RETURN_CALL_FUNCTION("mb_convert_encoding", str, charset, encoding);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Escaper, escapeHtml){

	zval *text;
	zval *html_quote_type, *encoding;

	phalcon_fetch_params(0, 1, 0, &text);

	if (Z_TYPE_P(text) == IS_STRING) {
		html_quote_type = phalcon_fetch_nproperty_this(this_ptr, SL("_htmlQuoteType"), PH_NOISY TSRMLS_CC);
		encoding        = phalcon_fetch_nproperty_this(this_ptr, SL("_encoding"), PH_NOISY TSRMLS_CC);

		phalcon_htmlspecialchars(return_value, text, html_quote_type, encoding TSRMLS_CC);
		return;
	}

	RETURN_ZVAL(text, 1, 0);
}

static PHP_METHOD(Phalcon_Escaper, escapeHtmlAttr){

	zval *attribute, *encoding;

	phalcon_fetch_params(0, 1, 0, &attribute);

	if (Z_TYPE_P(attribute) == IS_STRING && zend_is_true(attribute)) {
		zval quoting;

		INIT_ZVAL(quoting);
		ZVAL_LONG(&quoting, ENT_QUOTES);

		encoding = phalcon_fetch_nproperty_this(this_ptr, SL("_encoding"), PH_NOISY TSRMLS_CC);

		phalcon_htmlspecialchars(return_value, attribute, &quoting, encoding TSRMLS_CC);
		return;
	}

	RETURN_ZVAL(attribute, 1, 0);
}

static PHP_METHOD(Phalcon_Escaper, escapeCss){

	zval *css, *normalized = NULL;

	phalcon_fetch_params(0, 1, 0, &css);

	if (Z_TYPE_P(css) == IS_STRING && zend_is_true(css)) {
		PHALCON_MM_GROW();

		PHALCON_CALL_METHOD(&normalized, this_ptr, "normalizeencoding", css);

		phalcon_escape_css(return_value, normalized);
		RETURN_MM();
	}

	RETURN_ZVAL(css, 1, 0);
}

static PHP_METHOD(Phalcon_Escaper, escapeJs){

	zval *js, *normalized = NULL;

	phalcon_fetch_params(0, 1, 0, &js);

	if (Z_TYPE_P(js) == IS_STRING && zend_is_true(js)) {
		PHALCON_MM_GROW();

		PHALCON_CALL_METHOD(&normalized, this_ptr, "normalizeencoding", js);

		phalcon_escape_js(return_value, normalized);
		RETURN_MM();
	}

	RETURN_ZVAL(js, 1, 0);
}

static PHP_METHOD(Phalcon_Escaper, escapeUrl){

	zval *url;

	phalcon_fetch_params(0, 1, 0, &url);

	phalcon_raw_url_encode(return_value, url);
}





zend_class_entry *phalcon_escaperinterface_ce;

static const zend_function_entry phalcon_escaperinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, setEncoding, arginfo_phalcon_escaperinterface_setencoding)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, getEncoding, NULL)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, setHtmlQuoteType, arginfo_phalcon_escaperinterface_sethtmlquotetype)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, escapeHtml, arginfo_phalcon_escaperinterface_escapehtml)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, escapeHtmlAttr, arginfo_phalcon_escaperinterface_escapehtmlattr)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, escapeCss, arginfo_phalcon_escaperinterface_escapecss)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, escapeJs, arginfo_phalcon_escaperinterface_escapejs)
	PHP_ABSTRACT_ME(Phalcon_EscaperInterface, escapeUrl, arginfo_phalcon_escaperinterface_escapeurl)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_EscaperInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, EscaperInterface, escaperinterface, phalcon_escaperinterface_method_entry);

	return SUCCESS;
}













#include <Zend/zend_exceptions.h>


zend_class_entry *phalcon_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon, Exception, exception, zend_exception_get_default(TSRMLS_C), NULL, 0);

	return SUCCESS;
}





#include <Zend/zend_closures.h>


zend_class_entry *phalcon_filter_ce;

static PHP_METHOD(Phalcon_Filter, add);
static PHP_METHOD(Phalcon_Filter, sanitize);
static PHP_METHOD(Phalcon_Filter, _sanitize);
static PHP_METHOD(Phalcon_Filter, getFilters);

static const zend_function_entry phalcon_filter_method_entry[] = {
	PHP_ME(Phalcon_Filter, add, arginfo_phalcon_filterinterface_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Filter, sanitize, arginfo_phalcon_filterinterface_sanitize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Filter, _sanitize, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Filter, getFilters, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Filter){

	PHALCON_REGISTER_CLASS(Phalcon, Filter, filter, phalcon_filter_method_entry, 0);

	zend_declare_property_null(phalcon_filter_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_filter_ce TSRMLS_CC, 1, phalcon_filterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Filter, add){

	zval **name, **handler;

	phalcon_fetch_params_ex(2, 0, &name, &handler);

	PHALCON_ENSURE_IS_STRING(name);
	
	if (Z_TYPE_PP(handler) != IS_OBJECT && !phalcon_is_callable(*handler TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_filter_exception_ce, "Filter must be an object or callable");
		return;
	}
	
	phalcon_update_property_array(this_ptr, SL("_filters"), *name, *handler TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Filter, sanitize){

	zval *value, *filters, *norecursive = NULL, *new_value = NULL, *filter = NULL, *array_value = NULL;
	zval *item_value = NULL, *item_key = NULL, *filter_value = NULL, *sanizited_value = NULL;
	zval *key = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &value, &filters, &norecursive);

	if (!norecursive) {
		norecursive = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		PHALCON_CPY_WRT(new_value, value);
		if (Z_TYPE_P(value) != IS_NULL) {
	
			phalcon_is_iterable(filters, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(filter);
	
				if (Z_TYPE_P(new_value) == IS_ARRAY && !zend_is_true(norecursive)) { 
	
					PHALCON_INIT_NVAR(array_value);
					array_init(array_value);
	
					phalcon_is_iterable(new_value, &ah1, &hp1, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
						PHALCON_GET_HKEY(item_key, ah1, hp1);
						PHALCON_GET_HVALUE(item_value);
	
						PHALCON_CALL_METHOD(&filter_value, this_ptr, "_sanitize", item_value, filter);
						phalcon_array_update_zval(&array_value, item_key, filter_value, PH_COPY | PH_SEPARATE);
	
						zend_hash_move_forward_ex(ah1, &hp1);
					}
	
					PHALCON_CPY_WRT(new_value, array_value);
				} else {
					PHALCON_CALL_METHOD(&filter_value, this_ptr, "_sanitize", new_value, filter);
					PHALCON_CPY_WRT(new_value, filter_value);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		RETURN_CCTOR(new_value);
	}
	
	if (Z_TYPE_P(value) == IS_ARRAY && !zend_is_true(norecursive)) { 

		PHALCON_INIT_VAR(sanizited_value);
		array_init(sanizited_value);
	
		phalcon_is_iterable(value, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HKEY(key, ah2, hp2);
			PHALCON_GET_HVALUE(item_value);
	
			PHALCON_CALL_METHOD(&filter_value, this_ptr, "_sanitize", item_value, filters);
			phalcon_array_update_zval(&sanizited_value, key, filter_value, PH_COPY);
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
	} else {
		PHALCON_CALL_METHOD(&sanizited_value, this_ptr, "_sanitize", value, filters);
	}
	
	RETURN_CCTOR(sanizited_value);
}

static PHP_METHOD(Phalcon_Filter, _sanitize){

	zval *value, *filter, *filters, *filter_object;
	zval *arguments, *type = NULL, *quote, *empty_str, *escaped;
	zval *filtered = NULL, *allow_fraction, *options, *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &value, &filter);
	
	PHALCON_OBS_VAR(filters);
	phalcon_read_property_this(&filters, this_ptr, SL("_filters"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&filter_object, filters, filter) && (Z_TYPE_P(filter_object) == IS_OBJECT || phalcon_is_callable(filter_object TSRMLS_CC))) {
	
		if (phalcon_is_callable(filter_object TSRMLS_CC)) {
			PHALCON_INIT_VAR(arguments);
			array_init_size(arguments, 1);
			phalcon_array_append(&arguments, value, 0);
			PHALCON_CALL_USER_FUNC_ARRAY(return_value, filter_object, arguments);
			RETURN_MM();
		}

		if (instanceof_function(Z_OBJCE_P(filter_object), zend_ce_closure TSRMLS_CC)) {
			PHALCON_INIT_VAR(arguments);
			array_init_size(arguments, 1);
			phalcon_array_append(&arguments, value, 0);
			PHALCON_CALL_USER_FUNC_ARRAY(return_value, filter_object, arguments);
			RETURN_MM();
		}
	
		PHALCON_RETURN_CALL_METHOD(filter_object, "filter", value);
		RETURN_MM();
	}
	
	
	if (PHALCON_IS_STRING(filter, "email")) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 517); /* FILTER_SANITIZE_EMAIL */
	
		PHALCON_INIT_VAR(quote);
		ZVAL_STRING(quote, "'", 1);
	
		PHALCON_INIT_VAR(empty_str);
		ZVAL_STRING(empty_str, "", 1);
	
		PHALCON_INIT_VAR(escaped);
		phalcon_fast_str_replace(escaped, quote, empty_str, value);
	
		PHALCON_CALL_FUNCTION(&filtered, "filter_var", escaped, type);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "int")) {
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 519); /* FILTER_SANITIZE_NUMBER_INT */
	
		PHALCON_CALL_FUNCTION(&filtered, "filter_var", value, type);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "string")) {
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 513); /* FILTER_SANITIZE_STRING */
	
		PHALCON_CALL_FUNCTION(&filtered, "filter_var", value, type);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "float")) {
		PHALCON_INIT_VAR(allow_fraction);
		ZVAL_LONG(allow_fraction, 4096);
	
		PHALCON_INIT_VAR(options);
		array_init_size(options, 1);
		phalcon_array_update_string(&options, SL("flags"), allow_fraction, PH_COPY);
	
		PHALCON_INIT_NVAR(type);
		ZVAL_LONG(type, 520);
	
		PHALCON_CALL_FUNCTION(&filtered, "filter_var", value, type, options);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "alphanum")) {
		PHALCON_INIT_NVAR(filtered);
		phalcon_filter_alphanum(filtered, value);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "trim")) {
		PHALCON_INIT_NVAR(filtered);
		phalcon_fast_trim(filtered, value, PHALCON_TRIM_BOTH TSRMLS_CC);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "striptags")) {
		PHALCON_INIT_NVAR(filtered);
		phalcon_fast_strip_tags(filtered, value);
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "lower")) {
		if (phalcon_function_quick_exists_ex(SS("mb_strtolower"), 3802586680UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_FUNCTION(&filtered, "mb_strtolower", value);
		} else {
			PHALCON_INIT_NVAR(filtered);
			phalcon_fast_strtolower(filtered, value);
		}
		goto ph_end_0;
	}
	
	if (PHALCON_IS_STRING(filter, "upper")) {
		if (phalcon_function_quick_exists_ex(SS("mb_strtoupper"), 4155739579UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_FUNCTION(&filtered, "mb_strtoupper", value);
		} else {
			PHALCON_INIT_NVAR(filtered);
			phalcon_fast_strtoupper(filtered, value);
		}
		goto ph_end_0;
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Sanitize filter ", filter, " is not supported");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_filter_exception_ce, exception_message);
	return;
	
	ph_end_0:
	
	RETURN_CCTOR(filtered);
}

static PHP_METHOD(Phalcon_Filter, getFilters){


	RETURN_MEMBER_QUICK(this_ptr, "_filters", 3850488637UL);
}





zend_class_entry *phalcon_filterinterface_ce;

static const zend_function_entry phalcon_filterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_FilterInterface, add, arginfo_phalcon_filterinterface_add)
	PHP_ABSTRACT_ME(Phalcon_FilterInterface, sanitize, arginfo_phalcon_filterinterface_sanitize)
	PHP_ABSTRACT_ME(Phalcon_FilterInterface, getFilters, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_FilterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, FilterInterface, filterinterface, phalcon_filterinterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_flash_ce;

static PHP_METHOD(Phalcon_Flash, __construct);
static PHP_METHOD(Phalcon_Flash, setImplicitFlush);
static PHP_METHOD(Phalcon_Flash, setAutomaticHtml);
static PHP_METHOD(Phalcon_Flash, setCssClasses);
static PHP_METHOD(Phalcon_Flash, error);
static PHP_METHOD(Phalcon_Flash, notice);
static PHP_METHOD(Phalcon_Flash, success);
static PHP_METHOD(Phalcon_Flash, warning);
static PHP_METHOD(Phalcon_Flash, outputMessage);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, cssClasses)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_setimplicitflush, 0, 0, 1)
	ZEND_ARG_INFO(0, implicitFlush)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_setautomatichtml, 0, 0, 1)
	ZEND_ARG_INFO(0, automaticHtml)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_setcssclasses, 0, 0, 1)
	ZEND_ARG_INFO(0, cssClasses)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_outputmessage, 0, 0, 2)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_flash_method_entry[] = {
	PHP_ME(Phalcon_Flash, __construct, arginfo_phalcon_flash___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Flash, setImplicitFlush, arginfo_phalcon_flash_setimplicitflush, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, setAutomaticHtml, arginfo_phalcon_flash_setautomatichtml, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, setCssClasses, arginfo_phalcon_flash_setcssclasses, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, error, arginfo_phalcon_flashinterface_error, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, notice, arginfo_phalcon_flashinterface_notice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, success, arginfo_phalcon_flashinterface_success, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, warning, arginfo_phalcon_flashinterface_warning, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash, outputMessage, arginfo_phalcon_flash_outputmessage, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Flash){

	PHALCON_REGISTER_CLASS(Phalcon, Flash, flash, phalcon_flash_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_flash_ce, SL("_cssClasses"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_flash_ce, SL("_implicitFlush"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_flash_ce, SL("_automaticHtml"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Flash, __construct){

	zval *css_classes = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &css_classes);
	
	if (!css_classes) {
		PHALCON_INIT_VAR(css_classes);
	} else {
		PHALCON_SEPARATE_PARAM(css_classes);
	}
	
	if (Z_TYPE_P(css_classes) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(css_classes);
		array_init_size(css_classes, 4);
		add_assoc_stringl_ex(css_classes, SS("error"), SL("errorMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("notice"), SL("noticeMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("success"), SL("successMessage"), 1);
		add_assoc_stringl_ex(css_classes, SS("warning"), SL("warningMessage"), 1);
	}
	phalcon_update_property_this_quick(this_ptr, SL("_cssClasses"), css_classes, 1944388667UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Flash, setImplicitFlush){

	zval *implicit_flush;

	phalcon_fetch_params(0, 1, 0, &implicit_flush);
	
	phalcon_update_property_this_quick(this_ptr, SL("_implicitFlush"), implicit_flush, 521244897UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Flash, setAutomaticHtml){

	zval *automatic_html;

	phalcon_fetch_params(0, 1, 0, &automatic_html);
	
	phalcon_update_property_this_quick(this_ptr, SL("_automaticHtml"), automatic_html, 1414140864UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Flash, setCssClasses){

	zval *css_classes;

	phalcon_fetch_params(0, 1, 0, &css_classes);
	
	if (Z_TYPE_P(css_classes) == IS_ARRAY) { 
		phalcon_update_property_this_quick(this_ptr, SL("_cssClasses"), css_classes, 1944388667UL TSRMLS_CC);
		RETURN_THISW();
	}
	PHALCON_THROW_EXCEPTION_STRW(phalcon_flash_exception_ce, "CSS classes must be an Array");
	return;
}

static void phalcon_flash_message_helper(INTERNAL_FUNCTION_PARAMETERS, const char *stype)
{
	zval **msg, *type;

	phalcon_fetch_params_ex(1, 0, &msg);

	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_STRING(type, stype, 1);

	PHALCON_RETURN_CALL_METHODW(getThis(), "message", type, *msg);
}

static PHP_METHOD(Phalcon_Flash, error)
{
	phalcon_flash_message_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, "error");
}

static PHP_METHOD(Phalcon_Flash, notice)
{
	phalcon_flash_message_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, "notice");
}

static PHP_METHOD(Phalcon_Flash, success)
{
	phalcon_flash_message_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, "success");
}

static PHP_METHOD(Phalcon_Flash, warning)
{
	phalcon_flash_message_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, "warning");
}

static PHP_METHOD(Phalcon_Flash, outputMessage){

	zval *type, *message, *automatic_html, *classes;
	zval *type_classes, *joined_classes, *css_classes = NULL;
	zval *implicit_flush, *content, *msg = NULL, *html_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int flag_automatic_html;
	int flag_implicit_flush;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &message);

	automatic_html      = phalcon_fetch_nproperty_this(this_ptr, SL("_automaticHtml"), PH_NOISY TSRMLS_CC);
	flag_automatic_html = zend_is_true(automatic_html);
	if (flag_automatic_html) {

		classes = phalcon_fetch_nproperty_this(this_ptr, SL("_cssClasses"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(css_classes);
		if (phalcon_array_isset_fetch(&type_classes, classes, type)) {
			if (Z_TYPE_P(type_classes) == IS_ARRAY) {
				PHALCON_INIT_VAR(joined_classes);
				phalcon_fast_join_str(joined_classes, SL(" "), type_classes TSRMLS_CC);

				PHALCON_CONCAT_SVS(css_classes, " class=\"", joined_classes, "\"");
			} else {
				PHALCON_CONCAT_SVS(css_classes, " class=\"", type_classes, "\"");
			}
		} else {
			ZVAL_EMPTY_STRING(css_classes);
		}
	}

	implicit_flush      = phalcon_fetch_nproperty_this(this_ptr, SL("_implicitFlush"), PH_NOISY TSRMLS_CC);
	flag_implicit_flush = zend_is_true(implicit_flush);
	if (Z_TYPE_P(message) == IS_ARRAY) {

		if (!flag_implicit_flush) {
			PHALCON_INIT_VAR(content);
			ZVAL_EMPTY_STRING(content);
		}

		phalcon_is_iterable(message, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HVALUE(msg);

			if (flag_automatic_html) {
				PHALCON_INIT_NVAR(html_message);
				PHALCON_CONCAT_SVSVS(html_message, "<div", css_classes, ">", msg, "</div>" PHP_EOL);
			} else {
				PHALCON_CPY_WRT(html_message, msg);
			}

			if (flag_implicit_flush) {
				zend_print_zval(html_message, 0);
			} else {
				phalcon_concat_self(&content, html_message TSRMLS_CC);
			}

			zend_hash_move_forward_ex(ah0, &hp0);
		}

		if (!flag_implicit_flush) {
			RETURN_CTOR(content);
		}
	} else {
		if (flag_automatic_html) {
			PHALCON_INIT_NVAR(html_message);
			PHALCON_CONCAT_SVSVS(html_message, "<div", css_classes, ">", message, "</div>" PHP_EOL);
		} else {
			PHALCON_CPY_WRT(html_message, message);
		}

		if (flag_implicit_flush) {
			zend_print_zval(html_message, 0);
		} else {
			RETURN_CCTOR(html_message);
		}
	}

	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_flashinterface_ce;

static const zend_function_entry phalcon_flashinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_FlashInterface, error, arginfo_phalcon_flashinterface_error)
	PHP_ABSTRACT_ME(Phalcon_FlashInterface, notice, arginfo_phalcon_flashinterface_notice)
	PHP_ABSTRACT_ME(Phalcon_FlashInterface, success, arginfo_phalcon_flashinterface_success)
	PHP_ABSTRACT_ME(Phalcon_FlashInterface, warning, arginfo_phalcon_flashinterface_warning)
	PHP_ABSTRACT_ME(Phalcon_FlashInterface, message, arginfo_phalcon_flashinterface_message)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_FlashInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon, FlashInterface, flashinterface, phalcon_flashinterface_method_entry);

	return SUCCESS;
}











zend_class_entry *phalcon_image_ce;

PHALCON_INIT_CLASS(Phalcon_Image){

	PHALCON_REGISTER_CLASS(Phalcon, Image, image, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);
	
	/* Resizing constraints */
	zend_declare_class_constant_long(phalcon_image_ce, SL("NONE"),    PHALCON_IMAGE_NONE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("WIDTH"),   PHALCON_IMAGE_WIDTH TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("HEIGHT"),  PHALCON_IMAGE_HEIGHT TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("AUTO"),    PHALCON_IMAGE_AUTO TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("INVERSE"), PHALCON_IMAGE_INVERSE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("PRECISE"), PHALCON_IMAGE_PRECISE TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("TENSILE"), PHALCON_IMAGE_TENSILE TSRMLS_CC);

	/* Flipping directions */
	zend_declare_class_constant_long(phalcon_image_ce, SL("HORIZONTAL"), PHALCON_IMAGE_HORIZONTAL TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("VERTICAL"),   PHALCON_IMAGE_VERTICAL TSRMLS_CC);

	/* Driver: GD, ImageMagick, etc */
	zend_declare_class_constant_long(phalcon_image_ce, SL("GD"),      PHALCON_IMAGE_GD TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_image_ce, SL("IMAGICK"), PHALCON_IMAGE_IMAGICK TSRMLS_CC);

	return SUCCESS;
}





zend_class_entry *phalcon_kernel_ce;

static PHP_METHOD(Phalcon_Kernel, preComputeHashKey);
static PHP_METHOD(Phalcon_Kernel, preComputeHashKey32);
static PHP_METHOD(Phalcon_Kernel, preComputeHashKey64);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_kernel_precomputehashkey, 0, 0, 1)
	ZEND_ARG_INFO(0, arrKey)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_kernel_method_entry[] = {
	PHP_ME(Phalcon_Kernel, preComputeHashKey,   arginfo_phalcon_kernel_precomputehashkey, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Kernel, preComputeHashKey32, arginfo_phalcon_kernel_precomputehashkey, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Kernel, preComputeHashKey64, arginfo_phalcon_kernel_precomputehashkey, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Kernel){

	PHALCON_REGISTER_CLASS(Phalcon, Kernel, kernel, phalcon_kernel_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Kernel, preComputeHashKey){

	char *arKey, *strKey;
	unsigned int nKeyLength;
	register ulong hash = 5381;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &arKey, &nKeyLength) == FAILURE) {
		RETURN_NULL();
	}

	nKeyLength++;

	/* variant with the hash unrolled eight times */
	for (; nKeyLength >= 8; nKeyLength -= 8) {
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
	}

	switch (nKeyLength) {
		case 7: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 6: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 5: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 4: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 3: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 2: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 1: hash = ((hash << 5) + hash) + *arKey++; break;
	}

	strKey = emalloc(24);
	snprintf(strKey, 24, "%lu", hash);

	RETURN_STRING(strKey, 0);
}

static PHP_METHOD(Phalcon_Kernel, preComputeHashKey32){

	char *arKey, *strKey;
	unsigned int nKeyLength;
	ulong hash;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &arKey, &nKeyLength) == FAILURE) {
		RETURN_NULL();
	}

	nKeyLength++;
	hash = zend_inline_hash_func(arKey, nKeyLength) & 0xFFFFFFFFul;
	strKey = emalloc(24);
	snprintf(strKey, 24, "%lu", hash);

	RETURN_STRING(strKey, 0);
}

static PHP_METHOD(Phalcon_Kernel, preComputeHashKey64){

	char *arKey, *strKey;
	unsigned int nKeyLength;
	register unsigned long long hash = 5381;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &arKey, &nKeyLength) == FAILURE) {
		RETURN_NULL();
	}

	nKeyLength++;

	/* variant with the hash unrolled eight times */
	for (; nKeyLength >= 8; nKeyLength -= 8) {
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
		hash = ((hash << 5) + hash) + *arKey++;
	}

	switch (nKeyLength) {
		case 7: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 6: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 5: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 4: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 3: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 2: hash = ((hash << 5) + hash) + *arKey++;
		/* no break */
		case 1: hash = ((hash << 5) + hash) + *arKey++; break;
	}

	strKey = emalloc(24);
	snprintf(strKey, 24, "%llu", hash);

	RETURN_STRING(strKey, 0);
}





zend_class_entry *phalcon_loader_ce;

static PHP_METHOD(Phalcon_Loader, __construct);
static PHP_METHOD(Phalcon_Loader, setEventsManager);
static PHP_METHOD(Phalcon_Loader, getEventsManager);
static PHP_METHOD(Phalcon_Loader, setExtensions);
static PHP_METHOD(Phalcon_Loader, getExtensions);
static PHP_METHOD(Phalcon_Loader, registerNamespaces);
static PHP_METHOD(Phalcon_Loader, getNamespaces);
static PHP_METHOD(Phalcon_Loader, registerPrefixes);
static PHP_METHOD(Phalcon_Loader, getPrefixes);
static PHP_METHOD(Phalcon_Loader, registerDirs);
static PHP_METHOD(Phalcon_Loader, getDirs);
static PHP_METHOD(Phalcon_Loader, registerClasses);
static PHP_METHOD(Phalcon_Loader, getClasses);
static PHP_METHOD(Phalcon_Loader, register);
static PHP_METHOD(Phalcon_Loader, unregister);
static PHP_METHOD(Phalcon_Loader, autoLoad);
static PHP_METHOD(Phalcon_Loader, getFoundPath);
static PHP_METHOD(Phalcon_Loader, getCheckedPath);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_setextensions, 0, 0, 1)
	ZEND_ARG_INFO(0, extensions)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_registernamespaces, 0, 0, 1)
	ZEND_ARG_INFO(0, namespaces)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_registerprefixes, 0, 0, 1)
	ZEND_ARG_INFO(0, prefixes)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_registerdirs, 0, 0, 1)
	ZEND_ARG_INFO(0, directories)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_registerclasses, 0, 0, 1)
	ZEND_ARG_INFO(0, classes)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_loader_autoload, 0, 0, 1)
	ZEND_ARG_INFO(0, className)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_loader_method_entry[] = {
	PHP_ME(Phalcon_Loader, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Loader, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, setExtensions, arginfo_phalcon_loader_setextensions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getExtensions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, registerNamespaces, arginfo_phalcon_loader_registernamespaces, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getNamespaces, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, registerPrefixes, arginfo_phalcon_loader_registerprefixes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getPrefixes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, registerDirs, arginfo_phalcon_loader_registerdirs, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getDirs, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, registerClasses, arginfo_phalcon_loader_registerclasses, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getClasses, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, register, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, unregister, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, autoLoad, arginfo_phalcon_loader_autoload, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getFoundPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Loader, getCheckedPath, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Loader){

	PHALCON_REGISTER_CLASS(Phalcon, Loader, loader, phalcon_loader_method_entry, 0);

	zend_declare_property_null(phalcon_loader_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_foundPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_checkedPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_prefixes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_classes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_extensions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_namespaces"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_loader_ce, SL("_directories"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_loader_ce, SL("_registered"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_loader_ce TSRMLS_CC, 1, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Loader, __construct){

	zval *extensions;

	PHALCON_ALLOC_GHOST_ZVAL(extensions);
	array_init_size(extensions, 1);
	add_next_index_stringl(extensions, SL("php"), 1);
	phalcon_update_property_this_quick(this_ptr, SL("_extensions"), extensions, 726159316UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Loader, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Loader, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Loader, setExtensions){

	zval *extensions;

	phalcon_fetch_params(0, 1, 0, &extensions);
	
	if (Z_TYPE_P(extensions) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_loader_exception_ce, "Parameter extensions must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_extensions"), extensions, 726159316UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Loader, getExtensions){


	RETURN_MEMBER_QUICK(this_ptr, "_extensions", 726159316UL);
}

static PHP_METHOD(Phalcon_Loader, registerNamespaces){

	zval *namespaces, *merge = NULL, *current_namespaces;
	zval *merged_namespaces = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &namespaces, &merge);
	
	if (Z_TYPE_P(namespaces) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter namespaces must be an array");
		return;
	}
	if (merge && zend_is_true(merge)) {
	
		current_namespaces = phalcon_fetch_nproperty_this(this_ptr, SL("_namespaces"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_namespaces) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_namespaces);
			phalcon_fast_array_merge(merged_namespaces, &current_namespaces, &namespaces TSRMLS_CC);
		} else {
			merged_namespaces = namespaces;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_namespaces"), merged_namespaces, 3363620132UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_namespaces"), namespaces, 3363620132UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, getNamespaces){


	RETURN_MEMBER_QUICK(this_ptr, "_namespaces", 3363620132UL);
}

static PHP_METHOD(Phalcon_Loader, registerPrefixes){

	zval *prefixes, *merge = NULL, *current_prefixes, *merged_prefixes = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &prefixes, &merge);
	
	if (Z_TYPE_P(prefixes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter prefixes must be an array");
		return;
	}

	if (merge && zend_is_true(merge)) {
		current_prefixes = phalcon_fetch_nproperty_this(this_ptr, SL("_prefixes"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_prefixes) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_prefixes);
			phalcon_fast_array_merge(merged_prefixes, &current_prefixes, &prefixes TSRMLS_CC);
		} else {
			merged_prefixes = prefixes;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_prefixes"), merged_prefixes, 900970058UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_prefixes"), prefixes, 900970058UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, getPrefixes){


	RETURN_MEMBER_QUICK(this_ptr, "_prefixes", 900970058UL);
}

static PHP_METHOD(Phalcon_Loader, registerDirs){

	zval *directories, *merge = NULL, *current_directories;
	zval *merged_directories = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &directories, &merge);
	
	if (Z_TYPE_P(directories) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter directories must be an array");
		return;
	}

	if (merge && zend_is_true(merge)) {
		current_directories = phalcon_fetch_nproperty_this(this_ptr, SL("_directories"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_directories) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_directories);
			phalcon_fast_array_merge(merged_directories, &current_directories, &directories TSRMLS_CC);
		} else {
			merged_directories = directories;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_directories"), merged_directories, 3207828897UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_directories"), directories, 3207828897UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, getDirs){


	RETURN_MEMBER_QUICK(this_ptr, "_directories", 3207828897UL);
}

static PHP_METHOD(Phalcon_Loader, registerClasses){

	zval *classes, *merge = NULL, *current_classes, *merged_classes = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &classes, &merge);
	
	if (Z_TYPE_P(classes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_loader_exception_ce, "Parameter classes must be an array");
		return;
	}

	if (merge && zend_is_true(merge)) {
		current_classes = phalcon_fetch_nproperty_this(this_ptr, SL("_classes"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_classes) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_classes);
			phalcon_fast_array_merge(merged_classes, &current_classes, &classes TSRMLS_CC);
		} else {
			merged_classes = classes;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_classes"), merged_classes, 3992428914UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_classes"), classes, 3992428914UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, getClasses){


	RETURN_MEMBER_QUICK(this_ptr, "_classes", 3992428914UL);
}

static PHP_METHOD(Phalcon_Loader, register){

	zval *registered, *autoloader;

	PHALCON_MM_GROW();

	registered = phalcon_fetch_nproperty_this(this_ptr, SL("_registered"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(registered)) {
		PHALCON_INIT_VAR(autoloader);
		array_init_size(autoloader, 2);
		phalcon_array_append(&autoloader, this_ptr, 0);
		add_next_index_stringl(autoloader, SL("autoLoad"), 1);
		PHALCON_CALL_FUNCTION(NULL, "spl_autoload_register", autoloader);
		phalcon_update_property_this(this_ptr, SL("_registered"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, unregister){

	zval *registered, *autoloader;

	PHALCON_MM_GROW();

	registered = phalcon_fetch_nproperty_this(this_ptr, SL("_registered"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_TRUE(registered)) {
		PHALCON_INIT_VAR(autoloader);
		array_init_size(autoloader, 2);
		phalcon_array_append(&autoloader, this_ptr, 0);
		add_next_index_stringl(autoloader, SL("autoLoad"), 1);
		PHALCON_CALL_FUNCTION(NULL, "spl_autoload_unregister", autoloader);
		phalcon_update_property_this(this_ptr, SL("_registered"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Loader, autoLoad){

	zval *class_name, *events_manager, *event_name = NULL;
	zval *classes, *file_path = NULL, *extensions, *ds, *namespace_separator;
	zval *empty_str, *namespaces, *directory = NULL;
	zval *ns_prefix = NULL, *ns_prefixed = NULL, *file_name = NULL, *fixed_directory = NULL;
	zval *extension = NULL, *pseudo_separator, *prefixes;
	zval *prefix = NULL, *ds_class_name, *ns_class_name;
	zval *directories;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5;
	zval **hd;
	char slash[2] = {DEFAULT_SLASH, 0};

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &class_name);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "loader:beforeCheckClass", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, class_name);
	}
	
	PHALCON_OBS_VAR(classes);
	phalcon_read_property_this(&classes, this_ptr, SL("_classes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(classes) == IS_ARRAY) { 
		if (phalcon_array_isset(classes, class_name)) {
	
			PHALCON_OBS_VAR(file_path);
			phalcon_array_fetch(&file_path, classes, class_name, PH_NOISY);
			convert_to_string_ex(&file_path);
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				phalcon_update_property_this_quick(this_ptr, SL("_foundPath"), file_path, 2210068013UL TSRMLS_CC);
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "loader:pathFound", 1);
				PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
			}
	
			RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(file_path) TSRMLS_CC));
			RETURN_MM_TRUE;
		}
	}
	
	PHALCON_OBS_VAR(extensions);
	phalcon_read_property_this(&extensions, this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(ds);
	ZVAL_STRING(ds, slash, 1);
	
	PHALCON_INIT_VAR(namespace_separator);
	ZVAL_STRING(namespace_separator, "\\", 1);
	
	PHALCON_INIT_VAR(empty_str);
	ZVAL_EMPTY_STRING(empty_str);
	
	PHALCON_OBS_VAR(namespaces);
	phalcon_read_property_this(&namespaces, this_ptr, SL("_namespaces"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(namespaces) == IS_ARRAY) { 
	
		phalcon_is_iterable(namespaces, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(ns_prefix, ah0, hp0);
			PHALCON_GET_HVALUE(directory);
	
			PHALCON_INIT_NVAR(ns_prefixed);
			PHALCON_CONCAT_VV(ns_prefixed, ns_prefix, namespace_separator);

			if (phalcon_start_with(class_name, ns_prefixed, NULL)) {
	
				PHALCON_INIT_NVAR(file_name);
				phalcon_possible_autoload_filepath(file_name, ns_prefix, class_name, ds, NULL TSRMLS_CC);
				if (zend_is_true(file_name)) {
	
					PHALCON_INIT_NVAR(fixed_directory);
					phalcon_fix_path(&fixed_directory, directory, ds TSRMLS_CC);
	
					phalcon_is_iterable(extensions, &ah1, &hp1, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
						PHALCON_GET_HVALUE(extension);
	
						PHALCON_INIT_NVAR(file_path);
						PHALCON_CONCAT_VVSV(file_path, fixed_directory, file_name, ".", extension);
	
						if (Z_TYPE_P(events_manager) == IS_OBJECT) {
							phalcon_update_property_this_quick(this_ptr, SL("_checkedPath"), file_path, 2930914648UL TSRMLS_CC);
	
							PHALCON_INIT_NVAR(event_name);
							ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
							PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
						}
	
						if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
							if (Z_TYPE_P(events_manager) == IS_OBJECT) {
								phalcon_update_property_this_quick(this_ptr, SL("_foundPath"), file_path, 2210068013UL TSRMLS_CC);
	
								PHALCON_INIT_NVAR(event_name);
								ZVAL_STRING(event_name, "loader:pathFound", 1);
								PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
							}
	
							assert(Z_TYPE_P(file_path) == IS_STRING);
							RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(file_path) TSRMLS_CC));
	
							RETURN_MM_TRUE;
						}
	
						zend_hash_move_forward_ex(ah1, &hp1);
					}
	
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_INIT_VAR(pseudo_separator);
	ZVAL_STRING(pseudo_separator, "_", 1);
	
	PHALCON_OBS_VAR(prefixes);
	phalcon_read_property_this(&prefixes, this_ptr, SL("_prefixes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(prefixes) == IS_ARRAY) { 
	
		phalcon_is_iterable(prefixes, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HKEY(prefix, ah2, hp2);
			PHALCON_GET_HVALUE(directory);
	
			if (phalcon_start_with(class_name, prefix, NULL)) {
	
				PHALCON_INIT_NVAR(file_name);
				phalcon_possible_autoload_filepath(file_name, prefix, class_name, ds, pseudo_separator TSRMLS_CC);
				if (zend_is_true(file_name)) {
	
					PHALCON_INIT_NVAR(fixed_directory);
					phalcon_fix_path(&fixed_directory, directory, ds TSRMLS_CC);
	
					phalcon_is_iterable(extensions, &ah3, &hp3, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
						PHALCON_GET_HVALUE(extension);
	
						PHALCON_INIT_NVAR(file_path);
						PHALCON_CONCAT_VVSV(file_path, fixed_directory, file_name, ".", extension);
	
						if (Z_TYPE_P(events_manager) == IS_OBJECT) {
							phalcon_update_property_this_quick(this_ptr, SL("_checkedPath"), file_path, 2930914648UL TSRMLS_CC);
	
							PHALCON_INIT_NVAR(event_name);
							ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
							PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
						}
	
						if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
	
							if (Z_TYPE_P(events_manager) == IS_OBJECT) {
								phalcon_update_property_this_quick(this_ptr, SL("_foundPath"), file_path, 2210068013UL TSRMLS_CC);
	
								PHALCON_INIT_NVAR(event_name);
								ZVAL_STRING(event_name, "loader:pathFound", 1);
								PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
							}

							assert(Z_TYPE_P(file_path) == IS_STRING);
							RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(file_path) TSRMLS_CC));
							RETURN_MM_TRUE;
						}
	
						zend_hash_move_forward_ex(ah3, &hp3);
					}
	
				}
			}
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
	}
	
	PHALCON_INIT_VAR(ds_class_name);
	phalcon_fast_str_replace(ds_class_name, pseudo_separator, ds, class_name);
	
	PHALCON_INIT_VAR(ns_class_name);
	phalcon_fast_str_replace(ns_class_name, namespace_separator, ds, ds_class_name);
	
	PHALCON_OBS_VAR(directories);
	phalcon_read_property_this(&directories, this_ptr, SL("_directories"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(directories) == IS_ARRAY) { 
	
		phalcon_is_iterable(directories, &ah4, &hp4, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {
	
			PHALCON_GET_HVALUE(directory);
	
			PHALCON_INIT_NVAR(fixed_directory);
			phalcon_fix_path(&fixed_directory, directory, ds TSRMLS_CC);
	
			phalcon_is_iterable(extensions, &ah5, &hp5, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) == SUCCESS) {
	
				PHALCON_GET_HVALUE(extension);
	
				PHALCON_INIT_NVAR(file_path);
				PHALCON_CONCAT_VVSV(file_path, fixed_directory, ns_class_name, ".", extension);
	
				if (Z_TYPE_P(events_manager) == IS_OBJECT) {
					phalcon_update_property_this_quick(this_ptr, SL("_checkedPath"), file_path, 2930914648UL TSRMLS_CC);
	
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "loader:beforeCheckPath", 1);
					PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
				}
	
				if (phalcon_file_exists(file_path TSRMLS_CC) == SUCCESS) {
	
					if (Z_TYPE_P(events_manager) == IS_OBJECT) {
						phalcon_update_property_this_quick(this_ptr, SL("_foundPath"), file_path, 2210068013UL TSRMLS_CC);
	
						PHALCON_INIT_NVAR(event_name);
						ZVAL_STRING(event_name, "loader:pathFound", 1);
						PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, file_path);
					}
	
					assert(Z_TYPE_P(file_path) == IS_STRING);
					RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(file_path) TSRMLS_CC));
	
					RETURN_MM_TRUE;
				}
	
				zend_hash_move_forward_ex(ah5, &hp5);
			}
	
			zend_hash_move_forward_ex(ah4, &hp4);
		}
	
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "loader:afterCheckClass", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, class_name);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Loader, getFoundPath){


	RETURN_MEMBER_QUICK(this_ptr, "_foundPath", 2210068013UL);
}

static PHP_METHOD(Phalcon_Loader, getCheckedPath){


	RETURN_MEMBER_QUICK(this_ptr, "_checkedPath", 2930914648UL);
}






zend_class_entry *phalcon_logger_ce;

PHALCON_INIT_CLASS(Phalcon_Logger){

	PHALCON_REGISTER_CLASS(Phalcon, Logger, logger, NULL, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_logger_ce, SL("SPECIAL"),   PHALCON_LOGGER_SPECIAL   TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CUSTOM"),    PHALCON_LOGGER_CUSTOM    TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("DEBUG"),     PHALCON_LOGGER_DEBUG     TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("INFO"),      PHALCON_LOGGER_INFO      TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("NOTICE"),    PHALCON_LOGGER_NOTICE    TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("WARNING"),   PHALCON_LOGGER_WARNING   TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ERROR"),     PHALCON_LOGGER_ERROR     TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("ALERT"),     PHALCON_LOGGER_ALERT     TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("CRITICAL"),  PHALCON_LOGGER_CRITICAL  TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("EMERGENCE"), PHALCON_LOGGER_EMERGENCY TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_logger_ce, SL("EMERGENCY"), PHALCON_LOGGER_EMERGENCY TSRMLS_CC);

	return SUCCESS;
}




#include <Zend/zend_interfaces.h>
#include <ext/spl/spl_array.h>
#include <ext/standard/php_var.h>
#include <ext/standard/php_smart_str.h>


zend_class_entry *phalcon_registry_ce;

static zend_object_handlers phalcon_registry_object_handlers;

typedef struct _phalcon_registry_object {
	zend_object obj;   /**< Zend Object */
	zval *properties;  /**< The registry itself */
	HashPosition pos;  /**< Current position used by the iterator */
} phalcon_registry_object;

PHALCON_ATTR_NONNULL static inline phalcon_registry_object* phalcon_registry_get_object(zval *obj TSRMLS_DC)
{
	return (phalcon_registry_object*)zend_objects_get_address(obj TSRMLS_CC);
}

static void phalcon_registry_dtor(void *v TSRMLS_DC)
{
	phalcon_registry_object *obj = v;

	zval_ptr_dtor(&obj->properties);
	zend_object_std_dtor(&obj->obj TSRMLS_CC);
	efree(obj);
}

static zend_object_value phalcon_registry_ctor(zend_class_entry* ce TSRMLS_DC)
{
	phalcon_registry_object *obj = ecalloc(1, sizeof(phalcon_registry_object));
	zend_object_value retval;

	zend_object_std_init(&obj->obj, ce TSRMLS_CC);
	object_properties_init(&obj->obj, ce);

	MAKE_STD_ZVAL(obj->properties);
	array_init(obj->properties);
	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(obj->properties), &obj->pos);

	retval.handle = zend_objects_store_put(
		obj,
		(zend_objects_store_dtor_t)zend_objects_destroy_object,
		phalcon_registry_dtor,
		NULL TSRMLS_CC
	);

	retval.handlers = &phalcon_registry_object_handlers;
	return retval;
}

static PHP_FUNCTION(phalcon_registry_method_handler)
{
	Z_OBJ_HANDLER_P(getThis(), call_method)(((zend_internal_function*)EG(current_execute_data)->function_state.function)->function_name, INTERNAL_FUNCTION_PARAM_PASSTHRU);
	efree(((zend_internal_function*)EG(current_execute_data)->function_state.function));
}

static union _zend_function* phalcon_registry_get_method(zval **object_ptr, char *method, int method_len ZLK_DC TSRMLS_DC)
{
	char *lc_method_name         = emalloc(method_len + 1);
	phalcon_registry_object *obj = phalcon_registry_get_object(*object_ptr TSRMLS_CC);
	zend_function fbc;

	zend_str_tolower_copy(lc_method_name, method, method_len);

	if (zend_hash_find(&obj->obj.ce->function_table, lc_method_name, method_len+1, (void **)&fbc) == FAILURE) {
		zend_internal_function *f = emalloc(sizeof(zend_internal_function));

		f->type          = ZEND_INTERNAL_FUNCTION;
		f->handler       = ZEND_FN(phalcon_registry_method_handler);
		f->arg_info      = NULL;
		f->num_args      = 0;
		f->scope         = obj->obj.ce;
		f->fn_flags      = ZEND_ACC_CALL_VIA_HANDLER;
		f->function_name = method;
#if PHP_VERSION_ID < 50400
		f->module        = obj->obj.ce->module;
		f->pass_rest_by_reference = 0;
		f->return_reference = ZEND_RETURN_VALUE;
#else
		f->module        = obj->obj.ce->info.internal.module;
#endif

		efree(lc_method_name);
		return (union _zend_function*)f;
	}

	efree(lc_method_name);
	return std_object_handlers.get_method(object_ptr, method, method_len ZLK_CC TSRMLS_CC);
}

static int phalcon_registry_call_method(const char *method, INTERNAL_FUNCTION_PARAMETERS)
{
	zval ***args, *params, **callback;
	int argc, result;
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);

	if (!ZEND_NUM_ARGS()) {
		params = NULL;
	}
	else {
		int i;

		if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "+", &args, &argc)) {
			return FAILURE;
		}

		MAKE_STD_ZVAL(params);
		array_init_size(params, argc);

		for (i=0; i<argc; ++i) {
			Z_ADDREF_PP(args[i]);
			add_next_index_zval(params, *(args[i]));
		}
	}

	if (zend_hash_find(Z_ARRVAL_P(obj->properties), method, strlen(method)+1, (void**)&callback) == SUCCESS) {
		result = phalcon_call_user_func_array_noex(return_value, *callback, params TSRMLS_CC);
	}
	else {
		result = FAILURE;
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Call to undefined method Phalcon\\Registry::%s", method);
	}

	if (params) {
		zval_ptr_dtor(&params);
		efree(args);
	}

	return result;
}


#if PHP_VERSION_ID < 50500

static zval** phalcon_registry_get_property_ptr_ptr(zval *object, zval *member ZLK_DC TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	return phalcon_hash_get(Z_ARRVAL_P(obj->properties), member, BP_VAR_W);
}

#else

static zval** phalcon_registry_get_property_ptr_ptr(zval *object, zval *member, int type, const zend_literal* key TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	if (key) {
		return phalcon_hash_fast_get(Z_ARRVAL_P(obj->properties), type, key);
	}

	return phalcon_hash_get(Z_ARRVAL_P(obj->properties), member, type);
}

#endif

static zval* phalcon_registry_read_property(zval *object, zval *member, int type ZLK_DC TSRMLS_DC)
{
	zval **result;
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);

#if PHP_VERSION_ID >= 50400
	if (key) {
		result = phalcon_hash_fast_get(Z_ARRVAL_P(obj->properties), type, key);
	}
	else
#endif
	{
		result = phalcon_hash_get(Z_ARRVAL_P(obj->properties), member, type);
	}

	return result ? *result : NULL;
}

static void phalcon_registry_write_property(zval *object, zval *member, zval *value ZLK_DC TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);

	Z_ADDREF_P(value);
#if PHP_VERSION_ID >= 50400
	if (key) {
		phalcon_hash_quick_update_or_insert(Z_ARRVAL_P(obj->properties), value, key);
	}
	else
#endif
	{
		phalcon_hash_update_or_insert(Z_ARRVAL_P(obj->properties), member, value);
	}
}

static void phalcon_registry_unset_property(zval *object, zval *member ZLK_DC TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);

#if PHP_VERSION_ID >= 50400
	if (key) {
		phalcon_hash_fast_unset(Z_ARRVAL_P(obj->properties), key);
	}
	else
#endif
	{
		phalcon_hash_unset(Z_ARRVAL_P(obj->properties), member);
	}
}

static int phalcon_registry_has_property(zval *object, zval *member, int has_set_exists ZLK_DC TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	zval **tmp;

#if PHP_VERSION_ID >= 50400
	if (key) {
		tmp = phalcon_hash_fast_get(Z_ARRVAL_P(obj->properties), BP_VAR_NA, key);
	}
	else
#endif
	{
		tmp = phalcon_hash_get(Z_ARRVAL_P(obj->properties), member, BP_VAR_NA);
	}

	if (!tmp) {
		return 0;
	}

	if (0 == has_set_exists) {
		return Z_TYPE_PP(tmp) != IS_NULL;
	}

	if (1 == has_set_exists) {
		return zend_is_true(*tmp);
	}

	return 1;
}

static zval* phalcon_registry_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval **ret;
	phalcon_registry_object *obj;

	if (UNEXPECTED(!offset)) {
		return EG(uninitialized_zval_ptr);
	}

	obj = phalcon_registry_get_object(object TSRMLS_CC);
	ret = phalcon_hash_get(Z_ARRVAL_P(obj->properties), offset, type);

	/* For write context we need to return a reference */
	if ((type == BP_VAR_W || type == BP_VAR_RW || type == BP_VAR_UNSET) && !Z_ISREF_PP(ret)) {
		if (Z_REFCOUNT_PP(ret) > 1) {
			zval *newval;

			MAKE_STD_ZVAL(newval);
			*newval = **ret;
			zval_copy_ctor(newval);
			Z_SET_REFCOUNT_P(newval, 1);

			Z_DELREF_PP(ret);
			*ret = newval;
		}

		Z_SET_ISREF_PP(ret);
	}

	return *ret;
}

static void phalcon_registry_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	phalcon_registry_write_property(object, offset, value ZLK_NULL_CC TSRMLS_CC);
}

static int phalcon_registry_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	return phalcon_registry_has_property(object, offset, check_empty ZLK_NULL_CC TSRMLS_CC);
}

static void phalcon_registry_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	phalcon_registry_unset_property(object, offset ZLK_NULL_CC TSRMLS_CC);
}

static int phalcon_registry_count_elements(zval *object, long int *count TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	*count = zend_hash_num_elements(Z_ARRVAL_P(obj->properties));
	return SUCCESS;
}

static HashTable* phalcon_registry_get_properties(zval *object TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	return Z_ARRVAL_P(obj->properties);
}

static int phalcon_registry_compare_objects(zval *object1, zval *object2 TSRMLS_DC)
{
	phalcon_registry_object *zobj1, *zobj2;
	zval result;

	zobj1 = phalcon_registry_get_object(object1 TSRMLS_CC);
	zobj2 = phalcon_registry_get_object(object2 TSRMLS_CC);

	if (zobj1->obj.ce != zobj2->obj.ce) {
		return 1;
	}

	if (zobj1->properties == zobj2->properties) {
		return 0;
	}

	zend_compare_symbol_tables(&result, Z_ARRVAL_P(zobj1->properties), Z_ARRVAL_P(zobj2->properties) TSRMLS_CC);
	assert(Z_TYPE_P(&result) == IS_LONG);
	return Z_LVAL_P(&result);
}

static int phalcon_registry_serialize(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(object TSRMLS_CC);
	smart_str buf = { NULL, 0, 0 };
	php_serialize_data_t var_hash;

	PHP_VAR_SERIALIZE_INIT(var_hash);
	php_var_serialize(&buf, &obj->properties, &var_hash TSRMLS_CC);
	PHP_VAR_SERIALIZE_DESTROY(var_hash);

	if (buf.c) {
		*buffer  = (unsigned char*)buf.c;
		*buf_len = buf.len;
		return SUCCESS;
	}

	return FAILURE;
}

static int phalcon_registry_unserialize(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC)
{
	phalcon_registry_object *obj;
	php_unserialize_data_t var_hash;
	zval zv = zval_used_for_init, *pzv = &zv;
	const unsigned char *max;
	int retval;

	object_init_ex(*object, ce);
	obj = phalcon_registry_get_object(*object TSRMLS_CC);

	max = buf + buf_len;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	retval = (php_var_unserialize(&pzv, &buf, max, &var_hash TSRMLS_CC) && Z_TYPE(zv) == IS_ARRAY) ? SUCCESS : FAILURE;
	if (SUCCESS == retval) {
		if (zend_hash_num_elements(Z_ARRVAL(zv)) != 0) {
			zend_hash_copy(Z_ARRVAL_P(obj->properties), Z_ARRVAL(zv), (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
		}
	}
	else {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Bad parameters passed to Phalcon\\Registry::unserialize()");
	}

	zval_dtor(pzv);
	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);

	return retval;
}

static void phalcon_registry_iterator_dtor(zend_object_iterator *it TSRMLS_DC)
{
	zval_ptr_dtor((zval**)&it->data);
	efree(it);
}

static int phalcon_registry_iterator_valid(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);
	return obj->pos != NULL ? SUCCESS : FAILURE;
}

static void phalcon_registry_iterator_get_current_data(zend_object_iterator *it, zval ***data TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);

	if (FAILURE == zend_hash_get_current_data_ex(Z_ARRVAL_P(obj->properties), (void**)data, &obj->pos)) {
		*data = NULL;
	}
}

#if ZEND_MODULE_API_NO >= 20121212
static void phalcon_registry_iterator_get_current_key(zend_object_iterator *it, zval *key TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);

	zend_hash_get_current_key_zval_ex(Z_ARRVAL_P(obj->properties), key, &obj->pos);
}
#else
static int phalcon_registry_iterator_get_current_key(zend_object_iterator *it, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);
	return zend_hash_get_current_key_ex(Z_ARRVAL_P(obj->properties), str_key, str_key_len, int_key, 1, &obj->pos);
}
#endif

static void phalcon_registry_iterator_move_forward(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);
	zend_hash_move_forward_ex(Z_ARRVAL_P(obj->properties), &obj->pos);
}

static void phalcon_registry_iterator_rewind(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_registry_object *obj = phalcon_registry_get_object((zval*)it->data TSRMLS_CC);
	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(obj->properties), &obj->pos);
}

static zend_object_iterator_funcs phalcon_registry_iterator_funcs = {
	phalcon_registry_iterator_dtor,
	phalcon_registry_iterator_valid,
	phalcon_registry_iterator_get_current_data,
	phalcon_registry_iterator_get_current_key,
	phalcon_registry_iterator_move_forward,
	phalcon_registry_iterator_rewind,
	NULL
};

static zend_object_iterator* phalcon_registry_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)
{
	zend_object_iterator *result;

	result = emalloc(sizeof(zend_object_iterator));

	Z_ADDREF_P(object);
	result->data  = object;
	result->funcs = &phalcon_registry_iterator_funcs;
	return result;
}

static PHP_METHOD(Phalcon_Registry, __get)
{
	zval **property, **result;
	phalcon_registry_object *obj;

	assert(return_value_ptr != NULL);

	phalcon_fetch_params_ex(1, 0, &property);

	obj    = phalcon_registry_get_object(getThis() TSRMLS_CC);
	result = phalcon_hash_get(Z_ARRVAL_P(obj->properties), *property, BP_VAR_W);

	zval_ptr_dtor(return_value_ptr);
	*return_value_ptr = *result;
	Z_ADDREF_PP(return_value_ptr);
	Z_SET_ISREF_PP(return_value_ptr);
}

static PHP_METHOD(Phalcon_Registry, __set)
{
	zval **property, **value;

	phalcon_fetch_params_ex(2, 0, &property, &value);
	phalcon_registry_write_property(getThis(), *property, *value ZLK_NULL_CC TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, __isset)
{
	zval **property;

	phalcon_fetch_params_ex(1, 0, &property);
	phalcon_registry_has_property(getThis(), *property, 0 ZLK_NULL_CC TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, __unset)
{
	zval **property;

	phalcon_fetch_params_ex(1, 0, &property);
	phalcon_registry_unset_property(getThis(), *property ZLK_NULL_CC TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, __call)
{
	zval **name, **arguments, **callback;
	phalcon_registry_object *obj;

	phalcon_fetch_params_ex(2, 0, &name, &arguments);
	PHALCON_ENSURE_IS_STRING(name);

	obj = phalcon_registry_get_object(getThis() TSRMLS_CC);

	if (zend_hash_find(Z_ARRVAL_P(obj->properties), Z_STRVAL_PP(name), Z_STRLEN_PP(name)+1, (void**)&callback) == SUCCESS) {
		RETURN_ON_FAILURE(phalcon_call_user_func_array(return_value, *callback, *arguments TSRMLS_CC));
	}
	else {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Call to undefined method Phalcon\\Registry::%s", Z_STRVAL_PP(name));
	}
}

static PHP_METHOD(Phalcon_Registry, count)
{
	long int result;

	phalcon_registry_count_elements(getThis(), &result TSRMLS_CC);
	RETURN_LONG(result);
}

static PHP_METHOD(Phalcon_Registry, offsetGet)
{
	if (return_value_ptr) {
		ZEND_MN(Phalcon_Registry___get)(INTERNAL_FUNCTION_PARAM_PASSTHRU);
	}
	else {
		zval **offset, **result;
		phalcon_registry_object *obj;

		phalcon_fetch_params_ex(1, 0, &offset);

		obj    = phalcon_registry_get_object(getThis() TSRMLS_CC);
		result = phalcon_hash_get(Z_ARRVAL_P(obj->properties), *offset, BP_VAR_R);

		RETURN_ZVAL(*result, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Registry, offsetSet)
{
	zval **offset, **value;

	phalcon_fetch_params_ex(2, 0, &offset, &value);
	phalcon_registry_write_dimension(getThis(), *offset, *value TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, offsetUnset)
{
	zval **offset;

	phalcon_fetch_params_ex(1, 0, &offset);
	phalcon_registry_unset_dimension(getThis(), *offset TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, offsetExists)
{
	zval **offset;

	phalcon_fetch_params_ex(1, 0, &offset);
	phalcon_registry_has_dimension(getThis(), *offset, 0 TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Registry, current)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	zval **data;

	if (SUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_P(obj->properties), (void**)&data, &obj->pos)) {
		if (return_value_ptr) {
			zval_ptr_dtor(return_value_ptr);
			*return_value_ptr = *data;
			Z_ADDREF_PP(data);
			Z_SET_ISREF_PP(data);
			return;
		}

		RETURN_ZVAL(*data, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Registry, key)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	zval key   = phalcon_get_current_key_w(Z_ARRVAL_P(obj->properties), &obj->pos);
	zval *pkey = &key;
	RETURN_ZVAL(pkey, 1, 0);
}

static PHP_METHOD(Phalcon_Registry, next)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	zend_hash_move_forward_ex(Z_ARRVAL_P(obj->properties), &obj->pos);
}

static PHP_METHOD(Phalcon_Registry, rewind)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(obj->properties), &obj->pos);
}

static PHP_METHOD(Phalcon_Registry, valid)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	RETURN_BOOL(obj->pos != NULL);
}

static PHP_METHOD(Phalcon_Registry, jsonSerialize)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	RETURN_ZVAL(obj->properties, 1, 0);
}

static PHP_METHOD(Phalcon_Registry, serialize)
{
	phalcon_registry_object *obj = phalcon_registry_get_object(getThis() TSRMLS_CC);
	smart_str buf = { NULL, 0, 0 };
	php_serialize_data_t var_hash;

	PHP_VAR_SERIALIZE_INIT(var_hash);
	php_var_serialize(&buf, &obj->properties, &var_hash TSRMLS_CC);
	PHP_VAR_SERIALIZE_DESTROY(var_hash);

	if (buf.c) {
		RETURN_STRINGL(buf.c, buf.len, 0);
	}
}

static PHP_METHOD(Phalcon_Registry, unserialize)
{
	zval **str;
	phalcon_registry_object *obj;
	php_unserialize_data_t var_hash;
	zval zv = zval_used_for_init, *pzv = &zv;
	const unsigned char *buf, *max;

	phalcon_fetch_params_ex(1, 0, &str);
	PHALCON_ENSURE_IS_STRING(str);

	obj = phalcon_registry_get_object(getThis() TSRMLS_CC);

	if (zend_hash_num_elements(Z_ARRVAL_P(obj->properties))) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Cannot call unserialize() on an already constructed object");
		return;
	}

	buf = (unsigned char*)(Z_STRVAL_PP(str));
	max = buf + Z_STRLEN_PP(str);

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	if (php_var_unserialize(&pzv, &buf, max, &var_hash TSRMLS_CC) && Z_TYPE(zv) == IS_ARRAY) {
		if (zend_hash_num_elements(Z_ARRVAL(zv)) != 0) {
			zend_hash_copy(Z_ARRVAL_P(obj->properties), Z_ARRVAL(zv), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));
		}
	}
	else {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Bad parameters passed to Phalcon\\Registry::unserialize()");
	}

	zval_dtor(pzv);
	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
}

static PHP_METHOD(Phalcon_Registry, __wakeup)
{
}

static const zend_function_entry phalcon_registry_method_entry[] = {
	PHP_ME(Phalcon_Registry, __get, arginfo___getref, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, __set, arginfo___set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, __isset, arginfo___isset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, __unset, arginfo___unset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, __call, arginfo___call, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, count, arginfo_countable_count, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, offsetGet, arginfo_arrayaccess_offsetgetref, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, offsetSet, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, offsetUnset, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, offsetExists, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, current, arginfo_iterator_current, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, key, arginfo_iterator_key, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, next, arginfo_iterator_next, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, rewind, arginfo_iterator_rewind, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, valid, arginfo_iterator_valid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, jsonSerialize, arginfo_jsonserializable_jsonserialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Registry, serialize, arginfo_serializable_serialize, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Registry, unserialize, arginfo_serializable_unserialize, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
	PHP_ME(Phalcon_Registry, __wakeup, arginfo_empty, ZEND_ACC_PRIVATE)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Registry)
{
	zend_class_entry **jsonserializable_ce = NULL;

	PHALCON_REGISTER_CLASS(Phalcon, Registry, registry, phalcon_registry_method_entry, ZEND_ACC_FINAL_CLASS);

	phalcon_registry_ce->create_object = phalcon_registry_ctor;
	phalcon_registry_ce->serialize     = phalcon_registry_serialize;
	phalcon_registry_ce->unserialize   = phalcon_registry_unserialize;

	phalcon_registry_object_handlers = *zend_get_std_object_handlers();
	phalcon_registry_object_handlers.get_property_ptr_ptr = phalcon_registry_get_property_ptr_ptr;
	phalcon_registry_object_handlers.read_property        = phalcon_registry_read_property;
	phalcon_registry_object_handlers.write_property       = phalcon_registry_write_property;
	phalcon_registry_object_handlers.unset_property       = phalcon_registry_unset_property;
	phalcon_registry_object_handlers.has_property         = phalcon_registry_has_property;
	phalcon_registry_object_handlers.read_dimension       = phalcon_registry_read_dimension;
	phalcon_registry_object_handlers.has_dimension        = phalcon_registry_has_dimension;
	phalcon_registry_object_handlers.write_dimension      = phalcon_registry_write_dimension;
	phalcon_registry_object_handlers.unset_dimension      = phalcon_registry_unset_dimension;
	phalcon_registry_object_handlers.get_properties       = phalcon_registry_get_properties;
	phalcon_registry_object_handlers.count_elements       = phalcon_registry_count_elements;
	phalcon_registry_object_handlers.compare_objects      = phalcon_registry_compare_objects;
	phalcon_registry_object_handlers.get_method           = phalcon_registry_get_method;
	phalcon_registry_object_handlers.call_method          = (zend_object_call_method_t)phalcon_registry_call_method;

	phalcon_registry_ce->get_iterator = phalcon_registry_get_iterator;

	zend_hash_find(CG(class_table), ZEND_STRS("jsonserializable"), (void**)&jsonserializable_ce);

	zend_class_implements(
		phalcon_registry_ce TSRMLS_CC,
		(jsonserializable_ce ? 5 : 4),
		zend_ce_arrayaccess,
		zend_ce_iterator,
		zend_ce_serializable,
		spl_ce_Countable,
		(jsonserializable_ce ? *jsonserializable_ce : NULL) /* must be the last one */
	);

	return SUCCESS;
}





#include <stdlib.h>

#ifdef PHALCON_USE_PHP_HASH
#include <ext/hash/php_hash.h>
#endif
#include <ext/standard/base64.h>
#include <ext/standard/php_string.h>
#include <ext/standard/php_crypt.h>
#include <main/spprintf.h>

#if PHP_WIN32
#include <win32/winutil.h>
#else
#include <fcntl.h>
#endif



static const unsigned char ascii64[] = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

zend_class_entry *phalcon_security_ce;

static PHP_METHOD(Phalcon_Security, setDI);
static PHP_METHOD(Phalcon_Security, getDI);
static PHP_METHOD(Phalcon_Security, setRandomBytes);
static PHP_METHOD(Phalcon_Security, getRandomBytes);
static PHP_METHOD(Phalcon_Security, setWorkFactor);
static PHP_METHOD(Phalcon_Security, getWorkFactor);
static PHP_METHOD(Phalcon_Security, getSaltBytes);
static PHP_METHOD(Phalcon_Security, hash);
static PHP_METHOD(Phalcon_Security, checkHash);
static PHP_METHOD(Phalcon_Security, isLegacyHash);
static PHP_METHOD(Phalcon_Security, getTokenKey);
static PHP_METHOD(Phalcon_Security, getToken);
static PHP_METHOD(Phalcon_Security, checkToken);
static PHP_METHOD(Phalcon_Security, getSessionToken);
static PHP_METHOD(Phalcon_Security, computeHmac);
static PHP_METHOD(Phalcon_Security, deriveKey);
static PHP_METHOD(Phalcon_Security, pbkdf2);
static PHP_METHOD(Phalcon_Security, getDefaultHash);
static PHP_METHOD(Phalcon_Security, setDefaultHash);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_setrandombytes, 0, 0, 1)
	ZEND_ARG_INFO(0, randomBytes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_setworkfactor, 0, 0, 1)
	ZEND_ARG_INFO(0, workFactor)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_hash, 0, 0, 1)
	ZEND_ARG_INFO(0, password)
	ZEND_ARG_INFO(0, workFactor)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_checkhash, 0, 0, 2)
	ZEND_ARG_INFO(0, password)
	ZEND_ARG_INFO(0, passwordHash)
	ZEND_ARG_INFO(0, maxPasswordLength)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_islegacyhash, 0, 0, 1)
	ZEND_ARG_INFO(0, passwordHash)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_gettokenkey, 0, 0, 0)
	ZEND_ARG_INFO(0, numberBytes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_gettoken, 0, 0, 0)
	ZEND_ARG_INFO(0, numberBytes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_checktoken, 0, 0, 0)
	ZEND_ARG_INFO(0, tokenKey)
	ZEND_ARG_INFO(0, tokenValue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_computehmac, 0, 0, 3)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, algo)
	ZEND_ARG_INFO(0, raw)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_derivekey, 0, 0, 2)
	ZEND_ARG_INFO(0, password)
	ZEND_ARG_INFO(0, salt)
	ZEND_ARG_INFO(0, hash)
	ZEND_ARG_INFO(0, iterations)
	ZEND_ARG_INFO(0, size)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_security_setdefaulthash, 0, 0, 1)
	ZEND_ARG_INFO(0, hash)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_security_method_entry[] = {
	PHP_ME(Phalcon_Security, setDI, arginfo_phalcon_security_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getDI, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, setRandomBytes, arginfo_phalcon_security_setrandombytes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getRandomBytes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, setWorkFactor, arginfo_phalcon_security_setworkfactor, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getWorkFactor, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getSaltBytes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, hash, arginfo_phalcon_security_hash, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, checkHash, arginfo_phalcon_security_checkhash, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, isLegacyHash, arginfo_phalcon_security_islegacyhash, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getTokenKey, arginfo_phalcon_security_gettokenkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getToken, arginfo_phalcon_security_gettoken, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, checkToken, arginfo_phalcon_security_checktoken, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, getSessionToken, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, computeHmac, arginfo_phalcon_security_computehmac, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Security, deriveKey, arginfo_phalcon_security_derivekey, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Security, pbkdf2, arginfo_phalcon_security_derivekey, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Security, getDefaultHash, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Security, setDefaultHash, arginfo_phalcon_security_setdefaulthash, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Security){

	PHALCON_REGISTER_CLASS(Phalcon, Security, security, phalcon_security_method_entry, 0);

	zend_declare_property_null(phalcon_security_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_security_ce, SL("_workFactor"), 8, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_security_ce, SL("_numberBytes"), 16, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_security_ce, SL("_csrf"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_security_ce, SL("_defaultHash"), PHALCON_SECURITY_CRYPT_DEFAULT, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_security_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_DEFAULT"),    PHALCON_SECURITY_CRYPT_DEFAULT    TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_STD_DES"),    PHALCON_SECURITY_CRYPT_STD_DES    TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_EXT_DES"),    PHALCON_SECURITY_CRYPT_EXT_DES    TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_MD5"),        PHALCON_SECURITY_CRYPT_MD5        TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_BLOWFISH"),   PHALCON_SECURITY_CRYPT_BLOWFISH   TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_BLOWFISH_X"), PHALCON_SECURITY_CRYPT_BLOWFISH_X TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_BLOWFISH_Y"), PHALCON_SECURITY_CRYPT_BLOWFISH_Y TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_SHA256"),     PHALCON_SECURITY_CRYPT_SHA256     TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_security_ce, SL("CRYPT_SHA512"),     PHALCON_SECURITY_CRYPT_SHA512     TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Security, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_security_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Security, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Security, setRandomBytes){

	zval **random_bytes;

	phalcon_fetch_params_ex(1, 0, &random_bytes);

	PHALCON_ENSURE_IS_LONG(random_bytes);

	if (Z_LVAL_PP(random_bytes) < 16) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_security_exception_ce, "At least 16 bytes are needed to produce a correct salt");
		return;
	}

	phalcon_update_property_this(this_ptr, SL("_numberBytes"), *random_bytes TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Security, getRandomBytes){


	RETURN_MEMBER_QUICK(this_ptr, "_numberBytes", 1300189556UL);
}

static PHP_METHOD(Phalcon_Security, setWorkFactor){

	zval **work_factor;

	phalcon_fetch_params_ex(1, 0, &work_factor);

	PHALCON_ENSURE_IS_LONG(work_factor);
	phalcon_update_property_this(this_ptr, SL("_workFactor"), *work_factor TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Security, getWorkFactor){


	RETURN_MEMBER_QUICK(this_ptr, "_workFactor", 3598705926UL);
}

static PHP_METHOD(Phalcon_Security, getSaltBytes)
{
	zval **number_bytes = NULL, **b64 = NULL;
	int i_bytes, encode;
	char *result = NULL;

	phalcon_fetch_params_ex(0, 2, &number_bytes, &b64);
	if (number_bytes) {
		PHALCON_ENSURE_IS_LONG(number_bytes);
		i_bytes = Z_LVAL_PP(number_bytes);
	}
	else {
		zval *n = phalcon_fetch_nproperty_this(this_ptr, SL("_numberBytes"), PH_NOISY TSRMLS_CC);
		i_bytes = (Z_TYPE_P(n) == IS_LONG) ? Z_LVAL_P(n) : phalcon_get_intval(n);
	}

	encode = (!b64 || zend_is_true(*b64)) ? 1 : 0;

#if PHP_WIN32
	{
		result = emalloc(i_bytes + 1);
		result[i_bytes] = 0;
		if (php_win32_get_random_bytes((BYTE*)result, (size_t)i_bytes) == FAILURE) {
			efree(result);
			RETURN_FALSE;
		}
	}
#else
	if (phalcon_function_quick_exists_ex(SS("openssl_random_pseudo_bytes"), 2196693822UL TSRMLS_CC) == FAILURE) {
		ssize_t read_bytes = 0;
		int fd = open("/dev/urandom", O_RDONLY);
		if (EXPECTED(fd >= 0)) {
			result = emalloc(i_bytes + 1);

			while (read_bytes < i_bytes) {
				ssize_t n = read(fd, result + read_bytes, i_bytes - read_bytes);
				if (n < 0) {
					break;
				}

				read_bytes += n;
			}

			close(fd);
		}

		if (UNEXPECTED(read_bytes != i_bytes)) {
			efree(result);
			RETURN_FALSE;
		}
	}
	else {
		zval *tmp = NULL, *n;

		PHALCON_ALLOC_GHOST_ZVAL(n);
		ZVAL_LONG(n, i_bytes);
		PHALCON_CALL_FUNCTIONW(&tmp, "openssl_random_pseudo_bytes", n);

		if (Z_TYPE_P(tmp) != IS_STRING || Z_STRLEN_P(tmp) < i_bytes) {
			zval_ptr_dtor(&tmp);
			RETURN_FALSE;
		}

		result = Z_STRVAL_P(tmp);
		ZVAL_NULL(tmp);
		zval_ptr_dtor(&tmp);
	}

	result[i_bytes] = 0;
#endif

	if (encode) {
		int encoded_len;
		char *encoded = (char*)php_base64_encode((unsigned char*)result, i_bytes, &encoded_len);
		if (encoded) {
			assert(encoded_len >= i_bytes);
			php_strtr(encoded, encoded_len, "+=", "./", 2);
			encoded[i_bytes] = 0;
			RETVAL_STRINGL(encoded, i_bytes, 0);
		}
		else {
			RETVAL_FALSE;
		}

		efree(result);
	}
	else {
		RETURN_STRINGL(result, i_bytes, 0);
	}
}

static PHP_METHOD(Phalcon_Security, hash)
{
	zval **password, **work_factor = NULL, *tmp, *n_bytes, *z_salt, *salt_bytes = NULL, *default_hash;
	char variant;
	char *salt;
	int salt_len, i_factor, i_hash;

	PHALCON_MM_GROW();

	phalcon_fetch_params_ex(1, 1, &password, &work_factor);
	PHALCON_ENSURE_IS_STRING(password);

	if (!work_factor || Z_TYPE_PP(work_factor) == IS_NULL) {
		tmp         = phalcon_fetch_nproperty_this(this_ptr, SL("_workFactor"), PH_NOISY TSRMLS_CC);
		work_factor = &tmp;
	}

	i_factor = (Z_TYPE_PP(work_factor) == IS_LONG) ? Z_LVAL_PP(work_factor) : phalcon_get_intval(*work_factor);

	default_hash = phalcon_fetch_nproperty_this(getThis(), SL("_defaultHash"), PH_NOISY TSRMLS_CC);
	i_hash       = (Z_TYPE_P(default_hash) == IS_LONG) ? Z_LVAL_P(default_hash) : phalcon_get_intval(default_hash);

	switch (i_hash) {
		default:
		case PHALCON_SECURITY_CRYPT_DEFAULT:
		case PHALCON_SECURITY_CRYPT_BLOWFISH:
			if (!PHALCON_GLOBAL(security.crypt_blowfish_supported)) RETURN_FALSE;
			variant = 'a';
			break;

		case PHALCON_SECURITY_CRYPT_BLOWFISH_X:
			if (!PHALCON_GLOBAL(security.crypt_blowfish_y_supported)) RETURN_FALSE;
			variant = 'x';
			break;

		case PHALCON_SECURITY_CRYPT_BLOWFISH_Y:
			if (!PHALCON_GLOBAL(security.crypt_blowfish_y_supported)) RETURN_FALSE;
			variant = 'y';
			break;

		case PHALCON_SECURITY_CRYPT_STD_DES:
			if (!PHALCON_GLOBAL(security.crypt_std_des_supported)) RETURN_FALSE;
			break;

		case PHALCON_SECURITY_CRYPT_EXT_DES:
			if (!PHALCON_GLOBAL(security.crypt_ext_des_supported)) RETURN_FALSE;
			break;

		case PHALCON_SECURITY_CRYPT_MD5:
			if (!PHALCON_GLOBAL(security.crypt_md5_supported)) RETURN_FALSE;
			break;

		case PHALCON_SECURITY_CRYPT_SHA256:
			if (!PHALCON_GLOBAL(security.crypt_sha256_supported)) RETURN_FALSE;
			variant = '5';
			break;

		case PHALCON_SECURITY_CRYPT_SHA512:
			if (!PHALCON_GLOBAL(security.crypt_sha512_supported)) RETURN_FALSE;
			variant = '6';
			break;
	}

	switch (i_hash) {
		case PHALCON_SECURITY_CRYPT_DEFAULT:
		case PHALCON_SECURITY_CRYPT_BLOWFISH:
		case PHALCON_SECURITY_CRYPT_BLOWFISH_X:
		case PHALCON_SECURITY_CRYPT_BLOWFISH_Y:
		default: {
			PHALCON_ALLOC_GHOST_ZVAL(n_bytes);
			ZVAL_LONG(n_bytes, 22);
			PHALCON_CALL_METHOD(&salt_bytes, this_ptr, "getsaltbytes", n_bytes);
			if (Z_TYPE_P(salt_bytes) != IS_STRING) {
				zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unable to get random bytes for the salt");
				RETURN_MM();
			}

			if (i_factor < 4) {
				i_factor = 4;
			}
			else if (i_factor > 31) {
				i_factor = 31;
			}

			assert(Z_STRLEN_P(salt_bytes) == 22);
			salt_len = spprintf(&salt, 0, "$2%c$%02d$%.22s", variant, i_factor, Z_STRVAL_P(salt_bytes));
			assert(salt_len == 29);
			break;
		}

		case PHALCON_SECURITY_CRYPT_STD_DES: {
		/* Standard DES-based hash with a two character salt from the alphabet "./0-9A-Za-z". */
			PHALCON_ALLOC_GHOST_ZVAL(n_bytes);
			ZVAL_LONG(n_bytes, 2);
			PHALCON_CALL_METHOD(&salt_bytes, this_ptr, "getsaltbytes", n_bytes);
			if (Z_TYPE_P(salt_bytes) != IS_STRING) {
				zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unable to get random bytes for the salt");
				RETURN_MM();
			}

			assert(Z_STRLEN_P(salt_bytes) == 2);
			salt     = Z_STRVAL_P(salt_bytes);
			salt_len = Z_STRLEN_P(salt_bytes);
			ZVAL_NULL(salt_bytes);
			break;
		}

		case PHALCON_SECURITY_CRYPT_EXT_DES: {
			char buf[4];
			buf[0] = ascii64[i_factor & 0x3F];
			buf[1] = ascii64[(i_factor >> 6)  & 0x3F];
			buf[2] = ascii64[(i_factor >> 12) & 0x3F];
			buf[3] = ascii64[(i_factor >> 18) & 0x3F];

			PHALCON_ALLOC_GHOST_ZVAL(n_bytes);
			ZVAL_LONG(n_bytes, 4);
			PHALCON_CALL_METHOD(&salt_bytes, this_ptr, "getsaltbytes", n_bytes);
			if (Z_TYPE_P(salt_bytes) != IS_STRING) {
				zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unable to get random bytes for the salt");
				RETURN_MM();
			}

			assert(Z_STRLEN_P(salt_bytes) == 4);
			salt_len = spprintf(&salt, 0, "_%c%c%c%c%.4s", buf[0], buf[1], buf[2], buf[3], Z_STRVAL_P(salt_bytes));
			assert(salt_len == 9);
			break;
		}

		case PHALCON_SECURITY_CRYPT_MD5: {
		/* MD5 hashing with a twelve character salt starting with $1$ */
			PHALCON_ALLOC_GHOST_ZVAL(n_bytes);
			ZVAL_LONG(n_bytes, 12);
			PHALCON_CALL_METHOD(&salt_bytes, this_ptr, "getsaltbytes", n_bytes);
			if (Z_TYPE_P(salt_bytes) != IS_STRING) {
				zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unable to get random bytes for the salt");
				RETURN_MM();
			}

			assert(Z_STRLEN_P(salt_bytes) == 12);
			salt_len = spprintf(&salt, 0, "$1$%.12s", Z_STRVAL_P(salt_bytes));
			assert(salt_len == 15);
			break;
		}

		case PHALCON_SECURITY_CRYPT_SHA256:
		/* SHA-256 hash with a sixteen character salt prefixed with $5$. */
		case PHALCON_SECURITY_CRYPT_SHA512: {
			PHALCON_ALLOC_GHOST_ZVAL(n_bytes);
			ZVAL_LONG(n_bytes, 16);
			PHALCON_CALL_METHOD(&salt_bytes, this_ptr, "getsaltbytes", n_bytes);
			if (Z_TYPE_P(salt_bytes) != IS_STRING) {
				zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unable to get random bytes for the salt");
				RETURN_MM();
			}

			assert(Z_STRLEN_P(salt_bytes) == 16);
			if (i_factor) {
				salt_len = spprintf(&salt, 0, "$%c$rounds=%d$%.16s", variant, i_factor, Z_STRVAL_P(salt_bytes));
			}
			else {
				salt_len = spprintf(&salt, 0, "$%c$%.16s", variant, Z_STRVAL_P(salt_bytes));
				assert(salt_len == 19);
			}

			break;
		}
	}

	PHALCON_ALLOC_GHOST_ZVAL(z_salt);
	ZVAL_STRINGL(z_salt, salt, salt_len, 0);

	PHALCON_RETURN_CALL_FUNCTION("crypt", *password, z_salt);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_STRLEN_P(return_value) < 13) {
		zval_dtor(return_value);
		RETURN_MM_FALSE;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Security, checkHash){

	zval **password, **password_hash, **max_pass_length = NULL, *hash = NULL;
	zval *params[2];
	int check = 0;

	phalcon_fetch_params_ex(2, 1, &password, &password_hash, &max_pass_length);

	PHALCON_ENSURE_IS_STRING(password);
	PHALCON_ENSURE_IS_STRING(password_hash);

	if (max_pass_length) {
		PHALCON_ENSURE_IS_LONG(max_pass_length);
		if (Z_LVAL_PP(max_pass_length) > 0 && Z_STRLEN_PP(password) > Z_LVAL_PP(max_pass_length)) {
			RETURN_FALSE;
		}
	}

	params[0] = *password;
	params[1] = *password_hash;
	RETURN_ON_FAILURE(phalcon_call_func_aparams(&hash, SL("crypt"), 2, params TSRMLS_CC));

	if (UNEXPECTED(Z_TYPE_P(hash) != IS_STRING)) {
		convert_to_string(hash);
	}

	if (Z_STRLEN_P(hash) == Z_STRLEN_PP(password_hash)) {
		int n    = Z_STRLEN_P(hash);
		char *h1 = Z_STRVAL_P(hash);
		char *h2 = Z_STRVAL_PP(password_hash);

		while (n) {
			check |= ((unsigned int)*h1) ^ ((unsigned int)*h2);
			++h1;
			++h2;
			--n;
		}

		zval_ptr_dtor(&hash);
		RETURN_BOOL(check == 0);
	}

	zval_ptr_dtor(&hash);
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Security, isLegacyHash){

	zval *password_hash;

	phalcon_fetch_params(0, 1, 0, &password_hash);

	if (phalcon_start_with_str(password_hash, SL("$2a$"))) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Security, getTokenKey){

	zval *number_bytes = NULL, *random_bytes = NULL, *base64bytes;
	zval *safe_bytes, *dependency_injector, *service;
	zval *session = NULL, *key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &number_bytes);

	if (!number_bytes) {
		PHALCON_INIT_VAR(number_bytes);
		ZVAL_LONG(number_bytes, 12);
	}

	if (phalcon_function_quick_exists_ex(SS("openssl_random_pseudo_bytes"), 2196693822UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "Openssl extension must be loaded");
		return;
	}

	PHALCON_CALL_FUNCTION(&random_bytes, "openssl_random_pseudo_bytes", number_bytes);

	PHALCON_INIT_VAR(base64bytes);
	phalcon_base64_encode(base64bytes, random_bytes);

	PHALCON_INIT_VAR(safe_bytes);
	phalcon_filter_alphanum(safe_bytes, base64bytes);

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}

	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);

	PHALCON_INIT_VAR(key);
	ZVAL_STRING(key, "$PHALCON/CSRF/KEY$", 1);
	PHALCON_CALL_METHOD(NULL, session, "set", key, safe_bytes);

	RETURN_CTOR(safe_bytes);
}

static PHP_METHOD(Phalcon_Security, getToken){

	zval *number_bytes = NULL, *random_bytes = NULL, *token, *dependency_injector;
	zval *service, *session = NULL, *key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &number_bytes);

	if (!number_bytes) {
		PHALCON_INIT_VAR(number_bytes);
		ZVAL_LONG(number_bytes, 12);
	}

	if (phalcon_function_quick_exists_ex(SS("openssl_random_pseudo_bytes"), 2196693822UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "Openssl extension must be loaded");
		return;
	}

	PHALCON_CALL_FUNCTION(&random_bytes, "openssl_random_pseudo_bytes", number_bytes);

	PHALCON_INIT_VAR(token);
	phalcon_md5(token, random_bytes);

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}

	PHALCON_ALLOC_GHOST_ZVAL(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);

	PHALCON_ALLOC_GHOST_ZVAL(key);
	ZVAL_STRING(key, "$PHALCON/CSRF$", 1);
	PHALCON_CALL_METHOD(NULL, session, "set", key, token);

	RETURN_CTOR(token);
}

static PHP_METHOD(Phalcon_Security, checkToken){

	zval *token_key = NULL, *token_value = NULL, *dependency_injector;
	zval *service = NULL, *session = NULL, *key = NULL, *request = NULL;
	zval *token = NULL, *session_token = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &token_key, &token_value);

	if (!token_value) {
		token_value = PHALCON_GLOBAL(z_null);
	}

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}

	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);

	if (!token_key || Z_TYPE_P(token_key) == IS_NULL) {
		PHALCON_INIT_VAR(key);
		ZVAL_STRING(key, "$PHALCON/CSRF/KEY$", 1);

		PHALCON_CALL_METHOD(&token_key, session, "get", key);
	}

	if (Z_TYPE_P(token_value) == IS_NULL) {
		PHALCON_INIT_NVAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_request);

		PHALCON_CALL_METHOD(&request, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(request, phalcon_http_requestinterface_ce);

		PHALCON_CALL_METHOD(&token, request, "getpost", token_key);
	} else {
		PHALCON_CPY_WRT(token, token_value);
	}

	PHALCON_INIT_NVAR(key);
	ZVAL_STRING(key, "$PHALCON/CSRF$", 1);

	PHALCON_CALL_METHOD(&session_token, session, "get", key);

	is_equal_function(return_value, token, session_token TSRMLS_CC);

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Security, getSessionToken){

	zval *dependency_injector, *service, *session = NULL;
	zval *key;

	PHALCON_MM_GROW();

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_security_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}

	PHALCON_ALLOC_GHOST_ZVAL(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);

	PHALCON_ALLOC_GHOST_ZVAL(key);
	ZVAL_STRING(key, "$PHALCON/CSRF$", 1);

	PHALCON_RETURN_CALL_METHOD(session, "get", key);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Security, computeHmac)
{
	zval **data, **key, **algo, **raw = NULL;

	phalcon_fetch_params_ex(3, 1, &data, &key, &algo, &raw);

	if (!raw) {
		raw = &(PHALCON_GLOBAL(z_false));
	}

	PHALCON_RETURN_CALL_FUNCTIONW("hash_hmac", *algo, *data, *key, *raw);
}

static PHP_METHOD(Phalcon_Security, pbkdf2)
{
	zval **password, **salt, **hash = NULL, **iterations = NULL, **size = NULL;
	char* s_hash;
	int i_iterations = 0, i_size = 0;

	phalcon_fetch_params_ex(2, 3, &password, &salt, &hash, &iterations, &size);

	PHALCON_ENSURE_IS_STRING(password);
	PHALCON_ENSURE_IS_STRING(salt);

	if (Z_STRLEN_PP(salt) > INT_MAX - 4) {
		zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Salt is too long: %d", Z_STRLEN_PP(salt));
		return;
	}

	s_hash = (!hash || Z_TYPE_PP(hash) != IS_STRING) ? "sha512" : Z_STRVAL_PP(hash);

	if (iterations) {
		PHALCON_ENSURE_IS_LONG(iterations);
		i_iterations = Z_LVAL_PP(iterations);
	}

	if (i_iterations <= 0) {
		i_iterations = 5000;
	}

	if (size) {
		PHALCON_ENSURE_IS_LONG(size);
		i_size = Z_LVAL_PP(size);
	}

	if (i_size < 0) {
		i_size = 0;
	}

	{
		zval *algo, *tmp = NULL, *K1 = NULL, *K2 = NULL, *computed_salt, *result;
		int i_hash_len, block_count, i, j, k;
		int salt_len = Z_STRLEN_PP(salt);
		char *s;
		div_t d;

		PHALCON_MM_GROW();

		PHALCON_INIT_VAR(algo);
		ZVAL_STRING(algo, s_hash, 1);

		PHALCON_CALL_FUNCTION(&tmp, "hash", algo, PHALCON_GLOBAL(z_null), PHALCON_GLOBAL(z_true));
		if (PHALCON_IS_FALSE(tmp) || Z_TYPE_P(tmp) != IS_STRING) {
			RETURN_MM_FALSE;
		}

		i_hash_len = Z_STRLEN_P(tmp);
		if (!i_size) {
			i_size = i_hash_len;
		}

		PHALCON_INIT_VAR(computed_salt);
		s = safe_emalloc(salt_len, 1, 5);
		s[salt_len + 4] = 0;
		memcpy(s, Z_STRVAL_PP(salt), salt_len);
		ZVAL_STRINGL(computed_salt, s, salt_len + 4, 0);

		PHALCON_INIT_VAR(result);

		d           = div(i_size, i_hash_len);
		block_count = d.quot + (d.rem ? 1 : 0);

		for (i = 1; i <= block_count; ++i) {

			s[salt_len+0] = (unsigned char)(i >> 24);
			s[salt_len+1] = (unsigned char)(i >> 16);
			s[salt_len+2] = (unsigned char)(i >> 8);
			s[salt_len+3] = (unsigned char)(i);

			PHALCON_CALL_FUNCTION(&K1, "hash_hmac", algo, computed_salt, *password, PHALCON_GLOBAL(z_true));
            if (Z_TYPE_P(K1) != IS_STRING) {
                RETURN_MM_FALSE;
            }

			PHALCON_CPY_WRT_CTOR(K2, K1);

			for (j = 1; j < i_iterations; ++j) {
				char *k1, *k2;

				PHALCON_CALL_FUNCTION(&tmp, "hash_hmac", algo, K1, *password, PHALCON_GLOBAL(z_true));
                if (Z_TYPE_P(tmp) != IS_STRING) {
                    RETURN_MM_FALSE;
                }

				PHALCON_CPY_WRT(K1, tmp);

				k1 = Z_STRVAL_P(K1);
				k2 = Z_STRVAL_P(K2);
				for (k = 0; k < Z_STRLEN_P(K2); ++k) {
					k2[k] ^= k1[k];
				}
			}

			phalcon_concat_self(&result, K2 TSRMLS_CC);
		}

		if (i_size == i_hash_len) {
			RETVAL_STRINGL(Z_STRVAL_P(result), Z_STRLEN_P(result), 0);
			ZVAL_NULL(result);
		}
		else {
			phalcon_substr(return_value, result, 0, i_size);
		}

		PHALCON_MM_RESTORE();
	}
}

static PHP_METHOD(Phalcon_Security, deriveKey)
{
	zval **password, **salt, **hash = NULL, **iterations = NULL, **size = NULL;
	char* s_hash;
	int i_iterations = 0, i_size = 0;

	phalcon_fetch_params_ex(2, 3, &password, &salt, &hash, &iterations, &size);

	PHALCON_ENSURE_IS_STRING(password);
	PHALCON_ENSURE_IS_STRING(salt);

	if (Z_STRLEN_PP(salt) > INT_MAX - 4) {
		zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Salt is too long: %d", Z_STRLEN_PP(salt));
		return;
	}

	s_hash = (!hash || Z_TYPE_PP(hash) != IS_STRING) ? "sha512" : Z_STRVAL_PP(hash);

	if (iterations) {
		PHALCON_ENSURE_IS_LONG(iterations);
		i_iterations = Z_LVAL_PP(iterations);
	}

	if (i_iterations <= 0) {
		i_iterations = 5000;
	}

	if (size) {
		PHALCON_ENSURE_IS_LONG(size);
		i_size = Z_LVAL_PP(size);
	}

	if (i_size < 0) {
		i_size = 0;
	}


#if defined(PHALCON_USE_PHP_HASH)
	{
		const php_hash_ops *ops = php_hash_fetch_ops(s_hash, hash ? (size_t)(Z_STRLEN_PP(hash)) : strlen(s_hash));
		void *context;
		unsigned char *K1, *K2, *digest, *temp, *result, *computed_salt;
		long int i, j, loops, digest_length;
		int salt_len = Z_STRLEN_PP(salt);
		int pass_len = Z_STRLEN_PP(password);
		int k;

		if (!ops) {
			zend_throw_exception_ex(phalcon_security_exception_ce, 0 TSRMLS_CC, "Unknown hashing algorithm: %s", s_hash);
			return;
		}

		context = emalloc(ops->context_size);
		ops->hash_init(context);

		K1     = emalloc(2 * ops->block_size + 2 * ops->digest_size);
		K2     = K1 + ops->block_size;
		digest = K2 + ops->block_size;
		temp   = digest + ops->digest_size;

		/* Set up keys that will be used for all HMAC rounds */
		memset(K1, 0, ops->block_size);
		if (pass_len > ops->block_size) {
			ops->hash_init(context);
			ops->hash_update(context, (unsigned char*)Z_STRVAL_PP(password), pass_len);
			ops->hash_final(K1, context);
		}
		else {
			memcpy(K1, Z_STRVAL_PP(password), pass_len);
		}

		for (i = 0; i < ops->block_size; ++i) {
			K2[i] = K1[i] ^ 0x5C;
			K1[i] = K1[i] ^ 0x36;
		}

		digest_length = (i_size) ? i_size : ops->digest_size;
		loops         = ceil((float)digest_length / (float)ops->digest_size);

		result        = safe_emalloc(loops, ops->digest_size, 1);
		computed_salt = safe_emalloc(salt_len, 1, 4);
		memcpy(computed_salt, Z_STRVAL_PP(salt), salt_len);

		for (i = 1; i <= loops; ++i) {
			computed_salt[salt_len+0] = (unsigned char)(i >> 24);
			computed_salt[salt_len+1] = (unsigned char)(i >> 16);
			computed_salt[salt_len+2] = (unsigned char)(i >> 8);
			computed_salt[salt_len+3] = (unsigned char)(i);

			ops->hash_init(context);
			ops->hash_update(context, K1, ops->block_size);
			ops->hash_update(context, computed_salt, (long int)(salt_len) + 4);
			ops->hash_final(digest, context);

			ops->hash_init(context);
			ops->hash_update(context, K2, ops->block_size);
			ops->hash_update(context, digest, ops->digest_size);
			ops->hash_final(digest, context);

			memcpy(temp, digest, ops->digest_size);

			for (j = 1; j < i_iterations; ++j) {
				ops->hash_init(context);
				ops->hash_update(context, K1, ops->block_size);
				ops->hash_update(context, digest, ops->digest_size);
				ops->hash_final(digest, context);

				ops->hash_init(context);
				ops->hash_update(context, K2, ops->block_size);
				ops->hash_update(context, digest, ops->digest_size);
				ops->hash_final(digest, context);

				for (k = 0; k < ops->digest_size; ++k) {
					temp[k] ^= digest[k];
				}
			}

			memcpy(result + (i-1) * ops->digest_size, temp, ops->digest_size);
		}

		memset(K1, 0, 2 * ops->block_size);
		memset(computed_salt, 0, salt_len + 4);
		efree(K1);
		efree(computed_salt);
		efree(context);

		if (digest_length != ops->digest_size) {
			char *retval = safe_emalloc(i_size, 1, 1);
			memcpy(retval, result, i_size);
			retval[i_size] = 0;
			efree(result);
			RETVAL_STRINGL(retval, i_size, 0);
		}
		else {
			result[digest_length] = 0;
			RETVAL_STRINGL((char*)result, digest_length, 0);
		}
	}
#elif PHP_VERSION_ID >= 50000
	{
		zval *algo, *iter, *len;

		MAKE_STD_ZVAL(algo);
		ZVAL_STRING(algo, s_hash, 1);

		MAKE_STD_ZVAL(iter);
		ZVAL_LONG(iter, i_iterations);

		MAKE_STD_ZVAL(len);
		ZVAL_LONG(len, i_size);

		{
			zval *params[] = { algo, *password, *salt, iter, len, PHALCON_GLOBAL(z_true) };
			if (FAILURE == phalcon_return_call_function(return_value, return_value_ptr, SL("hash_pbkdf2"), 6, params TSRMLS_CC)) {
				;
			}
		}

		zval_ptr_dtor(&algo);
		zval_ptr_dtor(&iter);
		zval_ptr_dtor(&len);
	}
#else
	ZEND_MN(Phalcon_Security_pbkdf2)(INTERNAL_FUNCTION_PARAM_PASSTHRU);
#endif
}

static PHP_METHOD(Phalcon_Security, setDefaultHash)
{
	zval **default_hash;

	phalcon_fetch_params_ex(1, 0, &default_hash);
	PHALCON_ENSURE_IS_LONG(default_hash);

	phalcon_update_property_this(getThis(), SL("_defaultHash"), *default_hash TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Security, getDefaultHash)
{
	RETURN_MEMBER(getThis(), "_defaultHash");
}






zend_class_entry *phalcon_tag_ce;

static PHP_METHOD(Phalcon_Tag, setDI);
static PHP_METHOD(Phalcon_Tag, getDI);
static PHP_METHOD(Phalcon_Tag, getUrlService);
static PHP_METHOD(Phalcon_Tag, getEscaperService);
static PHP_METHOD(Phalcon_Tag, getAutoescape);
static PHP_METHOD(Phalcon_Tag, setAutoescape);
static PHP_METHOD(Phalcon_Tag, setDefault);
static PHP_METHOD(Phalcon_Tag, setDefaults);
static PHP_METHOD(Phalcon_Tag, hasValue);
static PHP_METHOD(Phalcon_Tag, getValue);
static PHP_METHOD(Phalcon_Tag, resetInput);
static PHP_METHOD(Phalcon_Tag, linkTo);
static PHP_METHOD(Phalcon_Tag, _inputField);
static PHP_METHOD(Phalcon_Tag, _inputFieldChecked);
static PHP_METHOD(Phalcon_Tag, colorField);
static PHP_METHOD(Phalcon_Tag, textField);
static PHP_METHOD(Phalcon_Tag, numericField);
static PHP_METHOD(Phalcon_Tag, rangeField);
static PHP_METHOD(Phalcon_Tag, emailField);
static PHP_METHOD(Phalcon_Tag, dateField);
static PHP_METHOD(Phalcon_Tag, dateTimeField);
static PHP_METHOD(Phalcon_Tag, dateTimeLocalField);
static PHP_METHOD(Phalcon_Tag, monthField);
static PHP_METHOD(Phalcon_Tag, timeField);
static PHP_METHOD(Phalcon_Tag, weekField);
static PHP_METHOD(Phalcon_Tag, passwordField);
static PHP_METHOD(Phalcon_Tag, hiddenField);
static PHP_METHOD(Phalcon_Tag, fileField);
static PHP_METHOD(Phalcon_Tag, checkField);
static PHP_METHOD(Phalcon_Tag, radioField);
static PHP_METHOD(Phalcon_Tag, imageInput);
static PHP_METHOD(Phalcon_Tag, searchField);
static PHP_METHOD(Phalcon_Tag, telField);
static PHP_METHOD(Phalcon_Tag, urlField);
static PHP_METHOD(Phalcon_Tag, submitButton);
static PHP_METHOD(Phalcon_Tag, selectStatic);
static PHP_METHOD(Phalcon_Tag, select);
static PHP_METHOD(Phalcon_Tag, textArea);
static PHP_METHOD(Phalcon_Tag, form);
static PHP_METHOD(Phalcon_Tag, endForm);
static PHP_METHOD(Phalcon_Tag, setTitle);
static PHP_METHOD(Phalcon_Tag, setTitleSeparator);
static PHP_METHOD(Phalcon_Tag, appendTitle);
static PHP_METHOD(Phalcon_Tag, prependTitle);
static PHP_METHOD(Phalcon_Tag, getTitleSeparator);
static PHP_METHOD(Phalcon_Tag, getTitle);
static PHP_METHOD(Phalcon_Tag, stylesheetLink);
static PHP_METHOD(Phalcon_Tag, javascriptInclude);
static PHP_METHOD(Phalcon_Tag, image);
static PHP_METHOD(Phalcon_Tag, friendlyTitle);
static PHP_METHOD(Phalcon_Tag, setDocType);
static PHP_METHOD(Phalcon_Tag, getDocType);
static PHP_METHOD(Phalcon_Tag, tagHtml);
static PHP_METHOD(Phalcon_Tag, tagHtmlClose);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_setautoescape, 0, 0, 1)
	ZEND_ARG_INFO(0, autoescape)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_setdefault, 0, 0, 2)
	ZEND_ARG_INFO(0, id)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_setdefaults, 0, 0, 1)
	ZEND_ARG_INFO(0, values)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_hasvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_getvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_linkto, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, text)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_generic_field, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_selectstatic, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_select, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_textarea, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_form, 0, 0, 0)
	ZEND_ARG_INFO(0, parameters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_settitle, 0, 0, 1)
	ZEND_ARG_INFO(0, title)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_settitleseparator, 0, 0, 1)
	ZEND_ARG_INFO(0, separator)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_appendtitle, 0, 0, 1)
	ZEND_ARG_INFO(0, title)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_prependtitle, 0, 0, 1)
	ZEND_ARG_INFO(0, title)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_gettitle, 0, 0, 0)
	ZEND_ARG_INFO(0, tags)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_stylesheetlink, 0, 0, 0)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, local)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_javascriptinclude, 0, 0, 0)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, local)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_image, 0, 0, 0)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, local)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_friendlytitle, 0, 0, 1)
	ZEND_ARG_INFO(0, text)
	ZEND_ARG_INFO(0, separator)
	ZEND_ARG_INFO(0, lowercase)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_setdoctype, 0, 0, 1)
	ZEND_ARG_INFO(0, doctype)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_taghtml, 0, 0, 1)
	ZEND_ARG_INFO(0, tagName)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, selfClose)
	ZEND_ARG_INFO(0, onlyStart)
	ZEND_ARG_INFO(0, useEol)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_taghtmlclose, 0, 0, 1)
	ZEND_ARG_INFO(0, tagName)
	ZEND_ARG_INFO(0, useEol)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_tag_method_entry[] = {
	PHP_ME(Phalcon_Tag, setDI, arginfo_phalcon_tag_setdi, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getDI, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getUrlService, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getEscaperService, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getAutoescape, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setAutoescape, arginfo_phalcon_tag_setautoescape, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setDefault, arginfo_phalcon_tag_setdefault, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setDefaults, arginfo_phalcon_tag_setdefaults, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_MALIAS(Phalcon_Tag, displayTo, setDefault, arginfo_phalcon_tag_setdefault, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, hasValue, arginfo_phalcon_tag_hasvalue, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getValue, arginfo_phalcon_tag_getvalue, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, resetInput, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, linkTo, arginfo_phalcon_tag_linkto, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, _inputField, NULL, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Tag, _inputFieldChecked, NULL, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Tag, colorField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, textField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, numericField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, rangeField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, emailField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, dateField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, dateTimeField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, dateTimeLocalField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, monthField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, timeField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, weekField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, passwordField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, hiddenField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, searchField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, telField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, urlField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, fileField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, checkField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, radioField, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, imageInput, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, submitButton, arginfo_phalcon_tag_generic_field, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, selectStatic, arginfo_phalcon_tag_selectstatic, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, select, arginfo_phalcon_tag_select, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, textArea, arginfo_phalcon_tag_textarea, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Tag, form, arginfo_phalcon_tag_form, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, endForm, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setTitle, arginfo_phalcon_tag_settitle, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setTitleSeparator, arginfo_phalcon_tag_settitleseparator, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, appendTitle, arginfo_phalcon_tag_appendtitle, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, prependTitle, arginfo_phalcon_tag_prependtitle, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getTitle, arginfo_phalcon_tag_gettitle, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getTitleSeparator, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, stylesheetLink, arginfo_phalcon_tag_stylesheetlink, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, javascriptInclude, arginfo_phalcon_tag_javascriptinclude, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, image, arginfo_phalcon_tag_image, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, friendlyTitle, arginfo_phalcon_tag_friendlytitle, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, setDocType, arginfo_phalcon_tag_setdoctype, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, getDocType, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, tagHtml, arginfo_phalcon_tag_taghtml, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag, tagHtmlClose, arginfo_phalcon_tag_taghtmlclose, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Tag){

	PHALCON_REGISTER_CLASS(Phalcon, Tag, tag, phalcon_tag_method_entry, 0);

	zend_declare_property_null(phalcon_tag_ce, SL("_displayValues"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_documentTitle"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_documentTitleSeparator"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_long(phalcon_tag_ce, SL("_documentType"), 11, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_urlService"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_dispatcherService"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_tag_ce, SL("_escaperService"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_bool(phalcon_tag_ce, SL("_autoEscape"), 1, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML32"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_STRICT"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_TRANSITIONAL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML401_FRAMESET"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("HTML5"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_STRICT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_TRANSITIONAL"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML10_FRAMESET"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML11"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML20"), 10 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_tag_ce, SL("XHTML5"), 11 TSRMLS_CC);

	return SUCCESS;
}

static void phalcon_tag_get_escaper(zval **return_value_ptr, zval *params TSRMLS_DC)
{
	zval *autoescape, *result = NULL;

	if (!phalcon_array_isset_string_fetch(&autoescape, params, SS("escape"))) {
		autoescape = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_autoEscape") TSRMLS_CC);
	}

	if (zend_is_true(autoescape)) {
		if (FAILURE == phalcon_call_class_method_aparams(&result, NULL, phalcon_fcall_self, NULL, SL("getescaperservice"), 0, NULL TSRMLS_CC)) {
			assert(result == NULL);
		}
	}

	*return_value_ptr = result;
}

static zend_bool phalcon_tag_attribute_filter(HashTable *ht, void *pData, zend_hash_key *hash_key, void *pParam)
{
	zval **z = (zval**)pData;
	return hash_key->arKey && hash_key->nKeyLength && Z_TYPE_PP(z) != IS_ARRAY;
}

PHALCON_STATIC void phalcon_tag_render_attributes(zval *code, zval *attributes TSRMLS_DC)
{
	zval *escaper, *escaped = NULL, *attrs;
	zval **value;
	HashPosition hp;
	uint i;

	struct str_size_t {
		const char *str;
		uint size;
	};

	static const struct str_size_t order[9] = {
		{ SS("type") },
		{ SS("for") },
		{ SS("src") },
		{ SS("href") },
		{ SS("action") },
		{ SS("id") },
		{ SS("name") },
		{ SS("value") },
		{ SS("class") },
	};

	assert(Z_TYPE_P(attributes) == IS_ARRAY);

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(escaper);
	phalcon_tag_get_escaper(&escaper, attributes TSRMLS_CC);
	if (EG(exception)) {
		assert(escaper == NULL);
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_INIT_VAR(attrs);
	array_init_size(attrs, zend_hash_num_elements(Z_ARRVAL_P(attributes)));

	for (i=0; i<sizeof(order)/sizeof(order[0]); ++i) {
		if (phalcon_hash_find(Z_ARRVAL_P(attributes), order[i].str, order[i].size, (void**)&value) == SUCCESS) {
			Z_ADDREF_PP(value);
			add_assoc_zval_ex(attrs, order[i].str, order[i].size, *value);
		}
	}

	zend_hash_merge_ex(Z_ARRVAL_P(attrs), Z_ARRVAL_P(attributes), (copy_ctor_func_t)zval_add_ref, sizeof(zval*), phalcon_tag_attribute_filter, NULL);

	if (phalcon_array_isset_quick_string(attrs, SS("escape"), 1978755574UL)) {
		phalcon_array_unset_string(&attrs, SS("escape"), 0);
	}

	if (escaper) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(attrs), &hp);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(attrs), (void**)&value, &hp) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(attrs), &hp)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(attrs), &hp);
			if (Z_TYPE_P(&key) == IS_STRING && Z_TYPE_PP(value) != IS_NULL) {
				PHALCON_CALL_METHOD(&escaped, escaper, "escapehtmlattr", *value);
				PHALCON_SCONCAT_SVSVS(code, " ", &key, "=\"", escaped, "\"");
			}
		}
	}
	else {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(attrs), &hp);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(attrs), (void**)&value, &hp) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(attrs), &hp)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(attrs), &hp);
			if (Z_TYPE_P(&key) == IS_STRING && Z_TYPE_PP(value) != IS_NULL) {
				PHALCON_SCONCAT_SVSVS(code, " ", &key, "=\"", *value, "\"");
			}
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_tag_exception_ce, 0);
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_dependencyInjector"), dependency_injector TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Tag, getDI){

	zval *dependency_injector;

	dependency_injector = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_dependencyInjector") TSRMLS_CC);
	RETURN_CTORW(dependency_injector);
}

static PHP_METHOD(Phalcon_Tag, getUrlService){

	zval *url = NULL, *dependency_injector = NULL, *service;

	PHALCON_MM_GROW();

	url = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_urlService") TSRMLS_CC);
	if (Z_TYPE_P(url) != IS_OBJECT) {
	
		dependency_injector = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_dependencyInjector") TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			dependency_injector = NULL;
			PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
		}
	
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "A dependency injector container is required to obtain the \"url\" service");
			return;
		}

		PHALCON_VERIFY_INTERFACE(dependency_injector, phalcon_diinterface_ce);
	
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_url);
	
		url = NULL;
		PHALCON_CALL_METHOD(&url, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(url, phalcon_mvc_urlinterface_ce);
		phalcon_update_static_property_ce(phalcon_tag_ce, SL("_urlService"), url TSRMLS_CC);
	}
	
	RETURN_CTOR(url);
}

static PHP_METHOD(Phalcon_Tag, getEscaperService){

	zval *escaper = NULL, *dependency_injector = NULL, *service;

	PHALCON_MM_GROW();

	escaper = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_escaperService") TSRMLS_CC);
	if (Z_TYPE_P(escaper) != IS_OBJECT) {
	
		dependency_injector = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_dependencyInjector") TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			dependency_injector = NULL;
			PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
		}
	
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "A dependency injector container is required to obtain the \"escaper\" service");
			return;
		}

		PHALCON_VERIFY_INTERFACE(dependency_injector, phalcon_diinterface_ce);
	
		PHALCON_ALLOC_GHOST_ZVAL(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_escaper);
	
		escaper = NULL;
		PHALCON_CALL_METHOD(&escaper, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(escaper, phalcon_escaperinterface_ce);
		phalcon_update_static_property_ce(phalcon_tag_ce, SL("_escaperService"), escaper TSRMLS_CC);
	}
	
	RETURN_CTOR(escaper);
}

static PHP_METHOD(Phalcon_Tag, getAutoescape) {

	zval *autoescape;

	autoescape = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_autoEscape") TSRMLS_CC);
	RETURN_ZVAL(autoescape, 1, 0);
}

static PHP_METHOD(Phalcon_Tag, setAutoescape){

	zval *autoescape;

	phalcon_fetch_params(0, 1, 0, &autoescape);
	
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_autoEscape"), autoescape TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Tag, setDefault){

	zval *id, *value;

	phalcon_fetch_params(0, 2, 0, &id, &value);
	
	if (Z_TYPE_P(value) != IS_NULL) {
		if (Z_TYPE_P(value) == IS_ARRAY || Z_TYPE_P(value) == IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_tag_exception_ce, "Only scalar values can be assigned to UI components");
			return;
		}
	}

	phalcon_update_static_property_array_multi_ce(phalcon_tag_ce, SL("_displayValues"), value TSRMLS_CC, SL("z"), 1, id);
}

static PHP_METHOD(Phalcon_Tag, setDefaults){

	zval *values, *merge = NULL, *display_values, *merged_values = NULL;;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &values, &merge);

	if (!merge) {
		merge = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_tag_exception_ce, "An array is required as default values");
		return;
	}

	if (zend_is_true(merge)) {

		display_values = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_displayValues") TSRMLS_CC);
		if (Z_TYPE_P(display_values) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_values);
			phalcon_fast_array_merge(merged_values, &display_values, &values TSRMLS_CC);
			phalcon_update_static_property_ce(phalcon_tag_ce, SL("_displayValues"), merged_values TSRMLS_CC);
		} else {
			phalcon_update_static_property_ce(phalcon_tag_ce, SL("_displayValues"), values TSRMLS_CC);
		}
	} else {
		phalcon_update_static_property_ce(phalcon_tag_ce, SL("_displayValues"), values TSRMLS_CC);
	}

	PHALCON_MM_RESTORE();
	
}


static PHP_METHOD(Phalcon_Tag, hasValue){

	zval *name, *display_values, *_POST;

	phalcon_fetch_params(0, 1, 0, &name);
	
	display_values = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_displayValues") TSRMLS_CC);
	
	if (phalcon_array_isset(display_values, name)) {
		RETURN_TRUE;
	}

	_POST = phalcon_get_global(SS("_POST") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_POST, name));
}

static PHP_METHOD(Phalcon_Tag, getValue){

	zval *name, *params = NULL, *display_values, *value = NULL, *_POST;

	phalcon_fetch_params(0, 1, 1, &name, &params);
	
	if (!params || !phalcon_array_isset_string_fetch(&value, params, SS("value"))) {
		display_values = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_displayValues") TSRMLS_CC);

		assert(value == NULL);

		if (!phalcon_array_isset_fetch(&value, display_values, name)) {

			assert(value == NULL);

			/* Check if there is a post value for the item */
			_POST = phalcon_get_global(SS("_POST") TSRMLS_CC);
			if (!phalcon_array_isset_fetch(&value, _POST, name)) {
				RETURN_NULL();
			}
		}
	}
	
	assert(value != NULL);
	RETURN_ZVAL(value, 1, 0);
}

static PHP_METHOD(Phalcon_Tag, resetInput){

	zval *empty_array;

	MAKE_STD_ZVAL(empty_array);
	array_init(empty_array);

	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_displayValues"), empty_array TSRMLS_CC);

	phalcon_set_symbol_str(SS("_POST"), empty_array TSRMLS_CC);

	zval_ptr_dtor(&empty_array);
}

static PHP_METHOD(Phalcon_Tag, linkTo){

	zval *parameters, *text = NULL, *local = NULL,  *params = NULL;
	zval *action, *url = NULL, *internal_url = NULL, *link_text, *z_local;
	zval *code, *query;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &parameters, &text, &local);
	
	if (!text) {
		text = PHALCON_GLOBAL(z_null);
	}

	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 3);
		phalcon_array_append(&params, parameters, 0);
		phalcon_array_append(&params, text, 0);
		phalcon_array_append(&params, local, 0);
	} else {
		PHALCON_CPY_WRT_CTOR(params, parameters);
	}
	
	if (phalcon_array_isset_long_fetch(&action, params, 0)) {
	} else if (phalcon_array_isset_string_fetch(&action, params, SS("action"))) {
		phalcon_array_unset_string(&params, SS("action"), 0);
	}
	else {
		PHALCON_INIT_VAR(action);
		ZVAL_EMPTY_STRING(action);
	}
	
	if (phalcon_array_isset_long_fetch(&link_text, params, 1)) {
	} else if (phalcon_array_isset_string_fetch(&link_text, params, SS("text"))) {
		phalcon_array_unset_string(&params, SS("text"), 0);
	}
	else {
		PHALCON_INIT_VAR(link_text);
		ZVAL_EMPTY_STRING(link_text);
	}

	if (phalcon_array_isset_long_fetch(&z_local, params, 2)) {
	} else if (phalcon_array_isset_string_fetch(&z_local, params, SS("local"))) {
		phalcon_array_unset_string(&params, SS("local"), 0);
	} else {
		PHALCON_INIT_VAR(z_local);
		ZVAL_NULL(z_local);
	}
	
	if (phalcon_array_isset_string_fetch(&query, params, SS("query"))) {
		phalcon_array_unset_string(&params, SS("query"), 0);
	} else {
		PHALCON_INIT_VAR(query);
		ZVAL_NULL(query);
	}

	PHALCON_CALL_SELF(&url, "geturlservice");		
	PHALCON_CALL_METHOD(&internal_url, url, "get", action, query, z_local);
	phalcon_array_update_string(&params, SL("href"), internal_url, PH_COPY);

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<a", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_CONCAT_VSVS(return_value, code, ">", link_text, "</a>");
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, _inputField){

	zval *type, *parameters, *as_value = NULL, *params = NULL, *value = NULL;
	zval *id = NULL, *name, *code, *doctype, *escaper;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &type, &parameters, &as_value);
	
	if (!as_value) {
		as_value = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, 0);
	} else {
		PHALCON_CPY_WRT_CTOR(params, parameters);
	}
	
	if (PHALCON_IS_FALSE(as_value)) {
		if (!phalcon_array_isset_long_fetch(&id, params, 0)) {
			PHALCON_OBS_VAR(id);
			phalcon_array_fetch_quick_string(&id, params, SS("id"), 193494642UL, PH_NOISY);
			phalcon_array_update_long(&params, 0, id, PH_COPY);
		}

		if (phalcon_array_isset_string_fetch(&name, params, SS("name"))) {
			if (!zend_is_true(name)) {
				phalcon_array_update_string(&params, ISL(name), id, PH_COPY);
			}
		}
		else {
			phalcon_array_update_string(&params, ISL(name), id, PH_COPY);
		}

		if (!phalcon_memnstr_str(id, SL("["))) {
			if (!phalcon_array_isset_quick_string(params, SS("id"), 193494642UL)) {
				phalcon_array_update_string(&params, SL("id"), id, PH_COPY);
			}
		}

		PHALCON_CALL_SELF(&value, "getvalue", id, params);
		phalcon_array_update_string(&params, ISL(value), value, PH_COPY);
	} else {
		if (!phalcon_array_isset_quick_string(params, SS("value"), 574111618UL)) {
			if (phalcon_array_isset_long_fetch(&value, params, 0)) {
				phalcon_array_update_string(&params, ISL(value), value, PH_COPY);
			}
		}
	}

	PHALCON_OBS_VAR(escaper);
	phalcon_tag_get_escaper(&escaper, params TSRMLS_CC);
	if (EG(exception)) {
		assert(escaper == NULL);
		PHALCON_MM_RESTORE();
		return;
	}

	phalcon_array_update_string(&params, ISL(type), type, PH_COPY);

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<input", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);
	
	if (PHALCON_GT_LONG(doctype, 5)) {
		PHALCON_CONCAT_VS(return_value, code, " />");
	} else {
		PHALCON_CONCAT_VS(return_value, code, ">");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, _inputFieldChecked){

	zval *type, *parameters, *params = NULL, *value = NULL, *id = NULL, *name;
	zval *current_value, *code, *doctype;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &parameters);
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, 0);
	} else {
		PHALCON_CPY_WRT_CTOR(params, parameters);
	}
	
	if (!phalcon_array_isset_long_fetch(&id, params, 0)) {
		PHALCON_OBS_VAR(id);
		phalcon_array_fetch_quick_string(&id, params, SS("id"), 193494642UL, PH_NOISY);
		phalcon_array_update_long(&params, 0, id, PH_COPY);
	}
	
	if (!phalcon_array_isset_string_fetch(&name, params, SS("name"))) {
		phalcon_array_update_string(&params, ISL(name), id, PH_COPY);
	} else {
		if (!zend_is_true(name)) {
			phalcon_array_update_string(&params, ISL(name), id, PH_COPY);
		}
	}
	
	if (!phalcon_memnstr_str(id, SL("["))) {
		if (!phalcon_array_isset_quick_string(params, SS("id"), 193494642UL)) {
			phalcon_array_update_string(&params, SL("id"), id, PH_COPY);
		}
	}

	if (phalcon_array_isset_string_fetch(&current_value, params, SS("value"))) {
		phalcon_array_unset_string(&params, SS("value"), 0);

		PHALCON_CALL_SELF(&value, "getvalue", id, params);

		if (Z_TYPE_P(value) != IS_NULL && PHALCON_IS_EQUAL(current_value, value)) {
			phalcon_array_update_string_string(&params, SL("checked"), SL("checked"), 0);
		}

		phalcon_array_update_string(&params, ISL(value), current_value, PH_COPY);
	} else {
		PHALCON_CALL_SELF(&value, "getvalue", id, params);

		if (zend_is_true(value)) {
			phalcon_array_update_string_string(&params, SL("checked"), SL("checked"), 0);
		}

		phalcon_array_update_string(&params, ISL(value), value, PH_COPY);
	}

	phalcon_array_update_string(&params, ISL(type), type, PH_COPY);

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<input", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);
	
	if (PHALCON_GT_LONG(doctype, 5)) {
		PHALCON_CONCAT_VS(return_value, code, " />");
	} else {
		PHALCON_CONCAT_VS(return_value, code, ">");
	}
	
	PHALCON_MM_RESTORE();
}

static void phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAMETERS, const char* type, int as_value)
{
	zval *parameters, *field_type;

	phalcon_fetch_params(0, 1, 0, &parameters);

	PHALCON_ALLOC_GHOST_ZVAL(field_type);
	ZVAL_STRING(field_type, type, 1);

	if (as_value) {
		PHALCON_RETURN_CALL_SELFW("_inputfield", field_type, parameters, PHALCON_GLOBAL(z_true));
	}
	else {
		PHALCON_RETURN_CALL_SELFW("_inputfield", field_type, parameters);
	}
}

static void phalcon_tag_generic_field_checked(INTERNAL_FUNCTION_PARAMETERS, const char* type)
{
	zval *parameters, *field_type;

	phalcon_fetch_params(0, 1, 0, &parameters);

	PHALCON_ALLOC_GHOST_ZVAL(field_type);
	ZVAL_STRING(field_type, type, 1);
	PHALCON_RETURN_CALL_SELFW("_inputfieldchecked", field_type, parameters);
}

static PHP_METHOD(Phalcon_Tag, colorField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "color", 0);
}

static PHP_METHOD(Phalcon_Tag, textField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "text", 0);
}

static PHP_METHOD(Phalcon_Tag, numericField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "number", 0);
}

static PHP_METHOD(Phalcon_Tag, rangeField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "range", 0);
}

static PHP_METHOD(Phalcon_Tag, emailField){
	
	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "email", 0);
}

static PHP_METHOD(Phalcon_Tag, dateField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "date", 0);
}

static PHP_METHOD(Phalcon_Tag, dateTimeField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "datetime", 0);
}

static PHP_METHOD(Phalcon_Tag, dateTimeLocalField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "datetime-local", 0);
}

static PHP_METHOD(Phalcon_Tag, monthField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "month", 0);
}

static PHP_METHOD(Phalcon_Tag, timeField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "time", 0);
}

static PHP_METHOD(Phalcon_Tag, weekField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "week", 0);
}

static PHP_METHOD(Phalcon_Tag, passwordField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "password", 0);
}

static PHP_METHOD(Phalcon_Tag, hiddenField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "hidden", 0);
}

static PHP_METHOD(Phalcon_Tag, fileField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "file", 0);
}

static PHP_METHOD(Phalcon_Tag, searchField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "search", 0);
}

static PHP_METHOD(Phalcon_Tag, telField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "tel", 0);
}

static PHP_METHOD(Phalcon_Tag, urlField){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "url", 0);
}

static PHP_METHOD(Phalcon_Tag, checkField){

	phalcon_tag_generic_field_checked(INTERNAL_FUNCTION_PARAM_PASSTHRU, "checkbox");
}

static PHP_METHOD(Phalcon_Tag, radioField){

	phalcon_tag_generic_field_checked(INTERNAL_FUNCTION_PARAM_PASSTHRU, "radio");
}

static PHP_METHOD(Phalcon_Tag, imageInput){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "image", 1);
}

static PHP_METHOD(Phalcon_Tag, submitButton){

	phalcon_tag_generic_field(INTERNAL_FUNCTION_PARAM_PASSTHRU, "submit", 1);
}

static PHP_METHOD(Phalcon_Tag, selectStatic){

	zval *parameters, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &parameters, &data);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_RETURN_CALL_CE_STATIC(phalcon_tag_select_ce, "selectfield", parameters, data);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Tag, select){

	zval *parameters, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &parameters, &data);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_RETURN_CALL_CE_STATIC(phalcon_tag_select_ce, "selectfield", parameters, data);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Tag, textArea){

	zval *parameters, *params = NULL, *id = NULL, *name, *content = NULL, *code;
	zval *escaped = NULL, *escaper;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &parameters);
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	if (!phalcon_array_isset_long_fetch(&id, params, 0)) {
		if (phalcon_array_isset_string_fetch(&id, params, SS("id"))) {
			phalcon_array_update_long(&params, 0, id, PH_COPY | PH_SEPARATE);
		}
	}
	
	if (!phalcon_array_isset_string_fetch(&name, params, SS("name"))) {
		phalcon_array_update_string(&params, ISL(name), id, PH_COPY | PH_SEPARATE);
	} else {
		if (!zend_is_true(name)) {
			phalcon_array_update_string(&params, ISL(name), id, PH_COPY | PH_SEPARATE);
		}
	}
	
	if (!phalcon_array_isset_quick_string(params, SS("id"), 193494642UL)) {
		phalcon_array_update_string(&params, SL("id"), id, PH_COPY | PH_SEPARATE);
	}

	PHALCON_CALL_SELF(&content, "getvalue", id, params);

	PHALCON_OBS_VAR(escaper);
	phalcon_tag_get_escaper(&escaper, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	if (escaper) {
		PHALCON_CALL_METHOD(&escaped, escaper, "escapehtml", content);
	}
	else {
		escaped = content;
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<textarea", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_CONCAT_VSVS(return_value, code, ">", escaped, "</textarea>");

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, form){

	zval *parameters = NULL, *params = NULL, *params_action = NULL, *action = NULL;
	zval *url = NULL, *code;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		PHALCON_INIT_VAR(parameters);
	} else {
		PHALCON_SEPARATE_PARAM(parameters);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}

	if (!phalcon_array_isset_long_fetch(&params_action, params, 0)) {
		if (!phalcon_array_isset_string_fetch(&params_action, params, SS("action"))) {
			assert(params_action == NULL);
			PHALCON_INIT_VAR(params_action);
		}
	}
	
	if (!phalcon_array_isset_quick_string(params, SS("method"), 3193080326UL)) {
		phalcon_array_update_string_string(&params, SL("method"), SL("post"), PH_SEPARATE);
	}
	
	if (Z_TYPE_P(params_action) != IS_NULL) {
		PHALCON_CALL_SELF(&url, "geturlservice");
		PHALCON_CALL_METHOD(&action, url, "get", params_action);
	}
	else {
		PHALCON_INIT_VAR(action);
	}
	
	if (phalcon_array_isset_string_fetch(&parameters, params, SS("parameters"))) {
		PHALCON_SCONCAT_SV(action, "?", parameters);
	}
	
	if (Z_TYPE_P(action) != IS_NULL) {
		phalcon_array_update_string(&params, SL("action"), action, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<form", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_CONCAT_VS(return_value, code, ">");
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, endForm){


	RETURN_STRING("</form>", 1);
}

static PHP_METHOD(Phalcon_Tag, setTitle){

	zval *title;

	phalcon_fetch_params(0, 1, 0, &title);
	
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_documentTitle"), title TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Tag, setTitleSeparator){

	zval *title_separator;

	phalcon_fetch_params(0, 1, 0, &title_separator);
	
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_documentTitleSeparator"), title_separator TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Tag, appendTitle){

	zval *title, *document_title, *document_title_separator, *r0;

	phalcon_fetch_params(0, 1, 0, &title);
	
	document_title = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitle") TSRMLS_CC);
	document_title_separator = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitleSeparator") TSRMLS_CC);
	ALLOC_INIT_ZVAL(r0);
	PHALCON_CONCAT_VVV(r0, document_title, document_title_separator, title);
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_documentTitle"), r0 TSRMLS_CC);
	zval_ptr_dtor(&r0);
}

static PHP_METHOD(Phalcon_Tag, prependTitle){

	zval *title, *document_title, *document_title_separator, *r0;

	phalcon_fetch_params(0, 1, 0, &title);
	
	document_title = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitle") TSRMLS_CC);
	document_title_separator = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitleSeparator") TSRMLS_CC);
	
	ALLOC_INIT_ZVAL(r0);
	PHALCON_CONCAT_VVV(r0, title, document_title_separator, document_title);
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_documentTitle"), r0 TSRMLS_CC);
	zval_ptr_dtor(&r0);
}

static PHP_METHOD(Phalcon_Tag, getTitle){

	zval *tags = NULL, *document_title;

	phalcon_fetch_params(0, 0, 1, &tags);
	
	document_title = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitle") TSRMLS_CC);
	if (!tags || zend_is_true(tags)) {
		PHALCON_CONCAT_SVS(return_value, "<title>", document_title, "</title>" PHP_EOL);
	}
	else {
		RETURN_ZVAL(document_title, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Tag, getTitleSeparator){

	zval *document_title_separator;
	document_title_separator = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentTitleSeparator") TSRMLS_CC);
	RETURN_ZVAL(document_title_separator, 1, 0);
}

static PHP_METHOD(Phalcon_Tag, stylesheetLink){

	zval *parameters = NULL, *local = NULL, *params = NULL, *first_param;
	zval *url = NULL, *url_href, *href = NULL, *code, *doctype, *z_local;
	zval *rel;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &parameters, &local);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) {
		PHALCON_INIT_VAR(params);
		array_init_size(params, 2);
		phalcon_array_append(&params, parameters, 0);
		phalcon_array_append(&params, local, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}

	if (!phalcon_array_isset_quick_string(params, SS("href"), 261698186UL)) {
		if (phalcon_array_isset_long_fetch(&first_param, params, 0)) {
			phalcon_array_update_string(&params, SL("href"), first_param, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_string_string(&params, SL("href"), SL(""), PH_SEPARATE);
		}
	}
	
	if (phalcon_array_isset_long_fetch(&z_local, params, 1)) {
	} else if (phalcon_array_isset_string_fetch(&z_local, params, SS("local"))) {
		phalcon_array_unset_string(&params, SS("local"), PH_SEPARATE);
	}
	else {
		PHALCON_INIT_VAR(z_local);
		ZVAL_TRUE(z_local);
	}
	
	if (!phalcon_array_isset_quick_string(params, SS("type"), 276192743UL)) {
		phalcon_array_update_string_string(&params, ISL(type), SL("text/css"), PH_SEPARATE);
	}
	
	if (zend_is_true(z_local)) {
		PHALCON_CALL_SELF(&url, "geturlservice");
	
		PHALCON_OBS_VAR(url_href);
		phalcon_array_fetch_quick_string(&url_href, params, SS("href"), 261698186UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&href, url, "getstatic", url_href);
		phalcon_array_update_string(&params, SL("href"), href, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(code);
	
	if (phalcon_array_isset_string_fetch(&rel, params, SS("rel"))) {
		phalcon_array_unset_string(&params, SS("rel"), PH_SEPARATE);
		PHALCON_CONCAT_SVS(code, "<link rel=\"", rel, "\"");
	} else {
		ZVAL_STRING(code, "<link rel=\"stylesheet\"", 1);
	}

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);
	
	if (PHALCON_GT_LONG(doctype, 5)) {
		PHALCON_CONCAT_VS(return_value, code, " />" PHP_EOL);
	} else {
		PHALCON_CONCAT_VS(return_value, code, ">" PHP_EOL);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, javascriptInclude){

	zval *parameters = NULL, *local = NULL, *params = NULL, *first_param;
	zval *url = NULL, *params_src, *src = NULL, *code, *z_local;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &parameters, &local);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) {
		PHALCON_INIT_VAR(params);
		array_init_size(params, 2);
		phalcon_array_append(&params, parameters, 0);
		phalcon_array_append(&params, local, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}

	if (!phalcon_array_isset_quick_string(params, SS("src"), 2090733773UL)) {
		if (phalcon_array_isset_long_fetch(&first_param, params, 0)) {
			phalcon_array_update_string(&params, SL("src"), first_param, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_string_string(&params, SL("src"), SL(""), PH_SEPARATE);
		}
	}
	
	if (phalcon_array_isset_long_fetch(&z_local, params, 1)) {
	} else if (phalcon_array_isset_string_fetch(&z_local, params, SS("local"))) {
		phalcon_array_unset_string(&params, SS("local"), PH_SEPARATE);
	} else {
		PHALCON_INIT_VAR(z_local);
		ZVAL_TRUE(z_local);
	}
	
	if (!phalcon_array_isset_quick_string(params, SS("type"), 276192743UL)) {
		phalcon_array_update_string_string(&params, ISL(type), SL("text/javascript"), PH_SEPARATE);
	}
	
	if (zend_is_true(z_local)) {
		PHALCON_CALL_SELF(&url, "geturlservice");
	
		PHALCON_OBS_VAR(params_src);
		phalcon_array_fetch_quick_string(&params_src, params, SS("src"), 2090733773UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&src, url, "getstatic", params_src);
		phalcon_array_update_string(&params, SL("src"), src, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<script", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_CONCAT_VS(return_value, code, "></script>" PHP_EOL);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, image){

	zval *parameters = NULL, *local = NULL, *params = NULL, *first_param, *second_param;
	zval *url = NULL, *url_src, *src = NULL, *code, *doctype;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &parameters, &local);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	if (!local) {
		PHALCON_INIT_VAR(local);
		if (Z_TYPE_P(parameters) == IS_ARRAY && phalcon_array_isset_long_fetch(&second_param, parameters, 1)) {
			ZVAL_BOOL(local, zend_is_true(second_param));
		} else {
			ZVAL_TRUE(local);
		}
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}

	if (!phalcon_array_isset_quick_string(params, SS("src"), 2090733773UL)) {
		if (phalcon_array_isset_long_fetch(&first_param, params, 0)) {
			phalcon_array_update_string(&params, SL("src"), first_param, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_string_string(&params, SL("src"), SL(""), PH_SEPARATE);
		}
	}
	
	if (zend_is_true(local)) {
		PHALCON_CALL_SELF(&url, "geturlservice");
	
		PHALCON_OBS_VAR(url_src);
		phalcon_array_fetch_quick_string(&url_src, params, SS("src"), 2090733773UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&src, url, "getstatic", url_src);
		phalcon_array_update_string(&params, SL("src"), src, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<img", 1);

	phalcon_tag_render_attributes(code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);
	
	if (PHALCON_GT_LONG(doctype, 5)) {
		PHALCON_CONCAT_VS(return_value, code, " />");
	} else {
		PHALCON_CONCAT_VS(return_value, code, ">");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, friendlyTitle){

	zval *text, *separator = NULL, *lowercase = NULL, *pattern, *friendly = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &text, &separator, &lowercase);
	
	if (!separator) {
		PHALCON_INIT_VAR(separator);
		ZVAL_STRING(separator, "-", 1);
	}
	
	if (!lowercase) {
		lowercase = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "~[^a-z0-9A-Z]+~", 1);
	
	PHALCON_CALL_FUNCTION(&friendly, "preg_replace", pattern, separator, text);
	if (zend_is_true(lowercase)) {
		phalcon_fast_strtolower(return_value, friendly);
	} else {
		RETVAL_ZVAL(friendly, 1, 0);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Tag, setDocType){

	zval *doctype;

	phalcon_fetch_params(0, 1, 0, &doctype);
	
	phalcon_update_static_property_ce(phalcon_tag_ce, SL("_documentType"), doctype TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Tag, getDocType){

	zval *doctype;

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);

	switch (phalcon_get_intval(doctype)) {
		case 1:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">" PHP_EOL, 1);
		/* no break */
		case 2:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"" PHP_EOL "\t\"http://www.w3.org/TR/html4/strict.dtd\">" PHP_EOL, 1);
		/* no break */
		case 3:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"" PHP_EOL "\t\"http://www.w3.org/TR/html4/loose.dtd\">" PHP_EOL, 1);
		/* no break */
		case 4:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"" PHP_EOL"\t\"http://www.w3.org/TR/html4/frameset.dtd\">" PHP_EOL, 1);
		/* no break */
		case 5:  RETURN_STRING("<!DOCTYPE html>" PHP_EOL, 1);
		/* no break */
		case 6:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"" PHP_EOL "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">" PHP_EOL, 1);
		/* no break */
		case 7:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"" PHP_EOL "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">" PHP_EOL, 1);
		/* no break */
		case 8:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"" PHP_EOL "\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">" PHP_EOL, 1);
		/* no break */
		case 9:  RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"" PHP_EOL"\t\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">" PHP_EOL, 1);
		/* no break */
		case 10: RETURN_STRING("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 2.0//EN\"" PHP_EOL "\t\"http://www.w3.org/MarkUp/DTD/xhtml2.dtd\">" PHP_EOL, 1);
		/* no break */
		case 11: RETURN_STRING("<!DOCTYPE html>" PHP_EOL, 1);
		/* no break */
		default: RETURN_EMPTY_STRING();
	}
}

static PHP_METHOD(Phalcon_Tag, tagHtml){

	zval *tag_name, *parameters = NULL, *self_close = NULL, *only_start = NULL;
	zval *use_eol = NULL, *params = NULL, *local_code, *doctype;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 4, &tag_name, &parameters, &self_close, &only_start, &use_eol);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (!self_close) {
		self_close = PHALCON_GLOBAL(z_false);
	}
	
	if (!only_start) {
		only_start = PHALCON_GLOBAL(z_false);
	}
	
	if (!use_eol) {
		use_eol = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) {
		PHALCON_INIT_VAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, parameters, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(local_code);
	PHALCON_CONCAT_SV(local_code, "<", tag_name);

	phalcon_tag_render_attributes(local_code, params TSRMLS_CC);
	if (EG(exception)) {
		PHALCON_MM_RESTORE();
		return;
	}

	doctype = phalcon_fetch_static_property_ce(phalcon_tag_ce, SL("_documentType") TSRMLS_CC);
	
	if (PHALCON_GT_LONG(doctype, 5)) {
		if (zend_is_true(self_close)) {
			phalcon_concat_self_str(&local_code, SL(" />") TSRMLS_CC);
		} else {
			phalcon_concat_self_str(&local_code, SL(">") TSRMLS_CC);
		}
	} else {
		if (zend_is_true(only_start)) {
			phalcon_concat_self_str(&local_code, SL(">") TSRMLS_CC);
		} else {
			PHALCON_SCONCAT_SVS(local_code, "></", tag_name, ">");
		}
	}
	
	if (zend_is_true(use_eol)) {
		phalcon_concat_self_str(&local_code, SL(PHP_EOL) TSRMLS_CC);
	}
	
	RETURN_CTOR(local_code);
}

static PHP_METHOD(Phalcon_Tag, tagHtmlClose){

	zval *tag_name, *use_eol = NULL, *local_code;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &tag_name, &use_eol);
	
	if (!use_eol) {
		use_eol = PHALCON_GLOBAL(z_false);
	}
	
	PHALCON_INIT_VAR(local_code);
	PHALCON_CONCAT_SVS(local_code, "</", tag_name, ">");
	if (zend_is_true(use_eol)) {
		phalcon_concat_self_str(&local_code, SL(PHP_EOL) TSRMLS_CC);
	}
	
	RETURN_CTOR(local_code);
}






zend_class_entry *phalcon_text_ce;

static PHP_METHOD(Phalcon_Text, camelize);
static PHP_METHOD(Phalcon_Text, uncamelize);
static PHP_METHOD(Phalcon_Text, increment);
static PHP_METHOD(Phalcon_Text, random);
static PHP_METHOD(Phalcon_Text, startsWith);
static PHP_METHOD(Phalcon_Text, endsWith);
static PHP_METHOD(Phalcon_Text, lower);
static PHP_METHOD(Phalcon_Text, upper);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_camelize, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_uncamelize, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_increment, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
	ZEND_ARG_INFO(0, separator)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_random, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, length)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_startswith, 0, 0, 2)
	ZEND_ARG_INFO(0, str)
	ZEND_ARG_INFO(0, start)
	ZEND_ARG_INFO(0, ignoreCase)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_endswith, 0, 0, 2)
	ZEND_ARG_INFO(0, str)
	ZEND_ARG_INFO(0, end)
	ZEND_ARG_INFO(0, ignoreCase)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_lower, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_text_upper, 0, 0, 1)
	ZEND_ARG_INFO(0, str)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_text_method_entry[] = {
	PHP_ME(Phalcon_Text, camelize, arginfo_phalcon_text_camelize, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, uncamelize, arginfo_phalcon_text_uncamelize, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, increment, arginfo_phalcon_text_increment, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, random, arginfo_phalcon_text_random, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, startsWith, arginfo_phalcon_text_startswith, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, endsWith, arginfo_phalcon_text_endswith, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, lower, arginfo_phalcon_text_lower, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Text, upper, arginfo_phalcon_text_upper, ZEND_ACC_STATIC|ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Text){

	PHALCON_REGISTER_CLASS(Phalcon, Text, text, phalcon_text_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_class_constant_long(phalcon_text_ce, SL("RANDOM_ALNUM"),   PHALCON_TEXT_RANDOM_ALNUM   TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_text_ce, SL("RANDOM_ALPHA"),   PHALCON_TEXT_RANDOM_ALPHA   TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_text_ce, SL("RANDOM_HEXDEC"),  PHALCON_TEXT_RANDOM_HEXDEC  TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_text_ce, SL("RANDOM_NUMERIC"), PHALCON_TEXT_RANDOM_NUMERIC TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_text_ce, SL("RANDOM_NOZERO"),  PHALCON_TEXT_RANDOM_NOZERO  TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Text, camelize){

	zval *str;

	phalcon_fetch_params(0, 1, 0, &str);
	
	phalcon_camelize(return_value, str);
	return;
}

static PHP_METHOD(Phalcon_Text, uncamelize){

	zval *str;

	phalcon_fetch_params(0, 1, 0, &str);
	
	phalcon_uncamelize(return_value, str);
	return;
}

static PHP_METHOD(Phalcon_Text, increment){

	zval *str, *separator = NULL, *parts, *number = NULL, *first_part;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &str, &separator);
	
	if (!separator) {
		PHALCON_INIT_VAR(separator);
	} else {
		PHALCON_SEPARATE_PARAM(separator);
	}
	
	if (Z_TYPE_P(separator) == IS_NULL) {
		PHALCON_INIT_NVAR(separator);
		ZVAL_STRING(separator, "_", 1);
	}
	
	PHALCON_INIT_VAR(parts);
	phalcon_fast_explode(parts, separator, str);
	if (phalcon_array_isset_long(parts, 1)) {
		PHALCON_OBS_VAR(number);
		phalcon_array_fetch_long(&number, parts, 1, PH_NOISY);
		SEPARATE_ZVAL(&number);
		phalcon_increment(number);
	} else {
		number = PHALCON_GLOBAL(z_one);
	}
	
	PHALCON_OBS_VAR(first_part);
	phalcon_array_fetch_long(&first_part, parts, 0, PH_NOISY);
	PHALCON_CONCAT_VVV(return_value, first_part, separator, number);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Text, random){

	zval *type, *length = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &type, &length);
	
	if (!length) {
		PHALCON_INIT_VAR(length);
		ZVAL_LONG(length, 8);
	}
	
	phalcon_random_string(return_value, type, length TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Text, startsWith){

	zval *str, *start, *ignore_case = NULL;
	zval *case_sensitive;

	phalcon_fetch_params(0, 2, 1, &str, &start, &ignore_case);
	
	if (!ignore_case) {
		case_sensitive = PHALCON_GLOBAL(z_false);
	}
	else {
		case_sensitive = zend_is_true(ignore_case) ? PHALCON_GLOBAL(z_false) : PHALCON_GLOBAL(z_true);
	}

	RETURN_BOOL(phalcon_start_with(str, start, case_sensitive));
}

static PHP_METHOD(Phalcon_Text, endsWith){

	zval *str, *end, *ignore_case = NULL;
	zval *case_sensitive;

	phalcon_fetch_params(0, 2, 1, &str, &end, &ignore_case);
	
	if (!ignore_case) {
		case_sensitive = PHALCON_GLOBAL(z_false);
	}
	else {
		case_sensitive = zend_is_true(ignore_case) ? PHALCON_GLOBAL(z_false) : PHALCON_GLOBAL(z_true);
	}

	RETURN_BOOL(phalcon_end_with(str, end, case_sensitive));
}

static PHP_METHOD(Phalcon_Text, lower){

	zval *str;

	phalcon_fetch_params(0, 1, 0, &str);
	
	if (phalcon_function_quick_exists_ex(SS("mb_strtolower"), 3802586680UL TSRMLS_CC) == SUCCESS) {
		PHALCON_MM_GROW();
		PHALCON_RETURN_CALL_FUNCTION("mb_strtolower", str);
		RETURN_MM();
	}

	phalcon_fast_strtolower(return_value, str);
}

static PHP_METHOD(Phalcon_Text, upper){

	zval *str;

	phalcon_fetch_params(0, 1, 0, &str);
	
	if (phalcon_function_quick_exists_ex(SS("mb_strtoupper"), 4155739579UL TSRMLS_CC) == SUCCESS) {
		PHALCON_MM_GROW();
		PHALCON_RETURN_CALL_FUNCTION("mb_strtoupper", str);
		RETURN_MM();
	}

	phalcon_fast_strtoupper(return_value, str);
}







zend_class_entry *phalcon_validation_ce;

static PHP_METHOD(Phalcon_Validation, __construct);
static PHP_METHOD(Phalcon_Validation, validate);
static PHP_METHOD(Phalcon_Validation, add);
static PHP_METHOD(Phalcon_Validation, setFilters);
static PHP_METHOD(Phalcon_Validation, getFilters);
static PHP_METHOD(Phalcon_Validation, getValidators);
static PHP_METHOD(Phalcon_Validation, getEntity);
static PHP_METHOD(Phalcon_Validation, getMessages);
static PHP_METHOD(Phalcon_Validation, appendMessage);
static PHP_METHOD(Phalcon_Validation, bind);
static PHP_METHOD(Phalcon_Validation, getValue);
static PHP_METHOD(Phalcon_Validation, setDefaultMessages);
static PHP_METHOD(Phalcon_Validation, getDefaultMessage);
static PHP_METHOD(Phalcon_Validation, setLabels);
static PHP_METHOD(Phalcon_Validation, getLabel);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, validators)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_validate, 0, 0, 0)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, entity)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_add, 0, 0, 2)
	ZEND_ARG_INFO(0, attribute)
	ZEND_ARG_INFO(0, validator)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_setfilters, 0, 0, 2)
	ZEND_ARG_INFO(0, attribute)
	ZEND_ARG_INFO(0, filters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_getfilters, 0, 0, 0)
	ZEND_ARG_INFO(0, attribute)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_appendmessage, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_bind, 0, 0, 2)
	ZEND_ARG_INFO(0, entity)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_getvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, attribute)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_setdefaultmessages, 0, 0, 0)
	ZEND_ARG_INFO(0, messages)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_getdefaultmessage, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_setlabels, 0, 0, 1)
	ZEND_ARG_INFO(0, labels)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_getlabel, 0, 0, 1)
	ZEND_ARG_INFO(0, field)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_validation_method_entry[] = {
	PHP_ME(Phalcon_Validation, __construct, arginfo_phalcon_validation___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Validation, validate, arginfo_phalcon_validation_validate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, add, arginfo_phalcon_validation_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, setFilters, arginfo_phalcon_validation_setfilters, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getFilters, arginfo_phalcon_validation_getfilters, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getValidators, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getEntity, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, appendMessage, arginfo_phalcon_validation_appendmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, bind, arginfo_phalcon_validation_bind, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getValue, arginfo_phalcon_validation_getvalue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, setDefaultMessages, arginfo_phalcon_validation_setdefaultmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getDefaultMessage, arginfo_phalcon_validation_getdefaultmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, setLabels, arginfo_phalcon_validation_setlabels, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation, getLabel, arginfo_phalcon_validation_getlabel, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation){

	PHALCON_REGISTER_CLASS_EX(Phalcon, Validation, validation, phalcon_di_injectable_ce, phalcon_validation_method_entry, 0);

	zend_declare_property_null(phalcon_validation_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_entity"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_validators"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_values"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_defaultMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_ce, SL("_labels"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static int phalcon_validation_getdefaultmessage_helper(const zend_class_entry *ce, zval **return_value_ptr, zval *this_ptr, const char *type TSRMLS_DC)
{
	if (is_phalcon_class(ce)) {
		zval *msg;
		zval *messages = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultMessages"), PH_NOISY TSRMLS_CC);

		MAKE_STD_ZVAL(*return_value_ptr);
		if (phalcon_array_isset_string_fetch(&msg, messages, type, strlen(type)+1)) {
			ZVAL_ZVAL(*return_value_ptr, msg, 1, 0);
		}
		else {
			ZVAL_NULL(*return_value_ptr);
		}

		return SUCCESS;
	}

	{
		zval *t;
		zval *params[1];

		PHALCON_ALLOC_GHOST_ZVAL(t);
		ZVAL_STRING(t, type, 1);
		params[0] = t;

		ALLOC_INIT_ZVAL(*return_value_ptr);
		return phalcon_return_call_method(*return_value_ptr, NULL, this_ptr, "getdefaultmessage", 1, params TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Validation, __construct){

	zval *validators = NULL;

	phalcon_fetch_params(0, 0, 1, &validators);
	
	if (!validators) {
		validators = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(validators) != IS_NULL) {
		if (Z_TYPE_P(validators) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STRW(phalcon_validation_exception_ce, "Validators must be an array");
			return;
		}
		phalcon_update_property_this_quick(this_ptr, SL("_validators"), validators, 2342846045UL TSRMLS_CC);
	}
	
	PHALCON_CALL_METHODW(NULL, getThis(), "setdefaultmessages");

	/* Check for an 'initialize' method */
	if (phalcon_method_quick_exists_ex(this_ptr, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHODW(NULL, getThis(), "initialize");
	}
}

static PHP_METHOD(Phalcon_Validation, validate){

	zval *data = NULL, *entity = NULL, *validators, *messages = NULL, *status = NULL;
	zval *scope = NULL, *attribute = NULL, *validator = NULL;
	zval *must_cancel = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &entity);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!entity) {
		entity = PHALCON_GLOBAL(z_null);
	}
	
	validators = phalcon_fetch_nproperty_this(this_ptr, SL("_validators"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(validators) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "There are no validators to validate");
		return;
	}
	
	phalcon_update_property_null(this_ptr, SL("_values") TSRMLS_CC);
	
	PHALCON_INIT_VAR(messages);
	object_init_ex(messages, phalcon_validation_message_group_ce);
	PHALCON_CALL_METHOD(NULL, messages, "__construct");
	
	if (phalcon_method_quick_exists_ex(this_ptr, SS("beforevalidation"), 4025473891UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&status, this_ptr, "beforevalidation", data, entity, messages);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_CCTOR(status);
		}
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_messages"), messages, 743366684UL TSRMLS_CC);
	if (Z_TYPE_P(data) == IS_ARRAY || Z_TYPE_P(data) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);
	}
	
	phalcon_is_iterable(validators, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(scope);
	
		if (Z_TYPE_P(scope) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "The validator scope is not valid");
			return;
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, scope, 0, PH_NOISY);
	
		PHALCON_OBS_NVAR(validator);
		phalcon_array_fetch_long(&validator, scope, 1, PH_NOISY);
		if (Z_TYPE_P(validator) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "One of the validators is not valid");
			return;
		}
	
		PHALCON_CALL_METHOD(&status, validator, "validate", this_ptr, attribute);
	
		if (PHALCON_IS_FALSE(status)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(must_cancel);
			RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(Z_OBJCE_P(validator), &must_cancel, validator, "cancelOnFail" TSRMLS_CC));

			if (zend_is_true(must_cancel)) {
				break;
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_OBS_NVAR(messages);
	phalcon_read_property_this(&messages, this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (phalcon_method_quick_exists_ex(this_ptr, SS("aftervalidation"), 1795965282UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "aftervalidation", data, entity, messages);
	}
	
	RETURN_CCTOR(messages);
}

static PHP_METHOD(Phalcon_Validation, add){

	zval **attribute, **validator, *scope;

	phalcon_fetch_params_ex(2, 0, &attribute, &validator);

	PHALCON_ENSURE_IS_STRING(attribute);
	PHALCON_VERIFY_INTERFACE_EX(*validator, phalcon_validation_validatorinterface_ce, phalcon_validation_exception_ce, 0);
	
	PHALCON_ALLOC_GHOST_ZVAL(scope);
	array_init_size(scope, 2);
	phalcon_array_append(&scope, *attribute, 0);
	phalcon_array_append(&scope, *validator, 0);
	phalcon_update_property_array_append(this_ptr, SL("_validators"), scope TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation, setFilters){

	zval *attribute, *filters;

	phalcon_fetch_params(0, 2, 0, &attribute, &filters);
	
	phalcon_update_property_array(this_ptr, SL("_filters"), attribute, filters TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation, getFilters){

	zval *attribute = NULL, *filters, *attribute_filters;

	phalcon_fetch_params(0, 0, 1, &attribute);
	
	filters = phalcon_fetch_nproperty_this(this_ptr, SL("_filters"), PH_NOISY TSRMLS_CC);
	if (attribute && Z_TYPE_P(attribute) == IS_STRING) {
		if (phalcon_array_isset_fetch(&attribute_filters, filters, attribute)) {
			RETURN_ZVAL(attribute_filters, 1, 0);
		}

		RETURN_NULL();
	}
	
	RETURN_ZVAL(filters, 1, 0);
}

static PHP_METHOD(Phalcon_Validation, getValidators){


	RETURN_MEMBER_QUICK(this_ptr, "_validators", 2342846045UL);
}

static PHP_METHOD(Phalcon_Validation, getEntity){


	RETURN_MEMBER_QUICK(this_ptr, "_entity", 2413912609UL);
}

static PHP_METHOD(Phalcon_Validation, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_messages", 743366684UL);
}

static PHP_METHOD(Phalcon_Validation, appendMessage){

	zval *message, *messages;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, messages, "appendmessage", message);
	}
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Validation, bind){

	zval *entity, *data;

	phalcon_fetch_params(0, 2, 0, &entity, &data);
	
	if (Z_TYPE_P(entity) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_validation_exception_ce, "The entity must be an object");
		return;
	}
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		if (Z_TYPE_P(data) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_validation_exception_ce, "The data to validate must be an array or object");
			return;
		}
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_entity"), entity, 2413912609UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation, getValue){

	zval *attribute, *entity, *method, *value = NULL, *data, *values;
	zval *filters, *field_filters, *service_name;
	zval *dependency_injector = NULL, *filter_service = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &attribute);
	
	PHALCON_OBS_VAR(entity);
	phalcon_read_property_this(&entity, this_ptr, SL("_entity"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(entity) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(method);
		PHALCON_CONCAT_SV(method, "get", attribute);
		zend_str_tolower(Z_STRVAL_P(method), Z_STRLEN_P(method));
		if (phalcon_method_exists_ex(entity, Z_STRVAL_P(method), Z_STRLEN_P(method)+1 TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(&value, entity, Z_STRVAL_P(method));
		} else if (phalcon_method_quick_exists_ex(entity, SS("readattribute"), 95450773UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(&value, entity, "readattribute", attribute);
		} else if (phalcon_isset_property_zval(entity, attribute TSRMLS_CC)) {
			PHALCON_OBS_VAR(value);
			phalcon_read_property_zval(&value, entity, attribute, PH_NOISY TSRMLS_CC);
		} else {
			PHALCON_INIT_VAR(value);
		}
	
		RETURN_CCTOR(value);
	}
	
	PHALCON_OBS_VAR(data);
	phalcon_read_property_this(&data, this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		if (Z_TYPE_P(data) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "There are no data to validate");
			return;
		}
	}
	
	PHALCON_OBS_VAR(values);
	phalcon_read_property_this(&values, this_ptr, SL("_values"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(values, attribute)) {
		PHALCON_OBS_NVAR(value);
		phalcon_array_fetch(&value, values, attribute, PH_NOISY);
		RETURN_CCTOR(value);
	}
	
	PHALCON_INIT_NVAR(value);
	
	if (Z_TYPE_P(data) == IS_ARRAY) { 
		if (phalcon_array_isset(data, attribute)) {
			PHALCON_OBS_NVAR(value);
			phalcon_array_fetch(&value, data, attribute, PH_NOISY);
		}
	} else {
		if (Z_TYPE_P(data) == IS_OBJECT) {
			if (phalcon_isset_property_zval(data, attribute TSRMLS_CC)) {
				PHALCON_OBS_NVAR(value);
				phalcon_read_property_zval(&value, data, attribute, PH_NOISY TSRMLS_CC);
			}
		}
	}
	
	if (Z_TYPE_P(value) != IS_NULL) {
	
		PHALCON_OBS_VAR(filters);
		phalcon_read_property_this(&filters, this_ptr, SL("_filters"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(filters) == IS_ARRAY) { 
			if (phalcon_array_isset(filters, attribute)) {
	
				PHALCON_OBS_VAR(field_filters);
				phalcon_array_fetch(&field_filters, filters, attribute, PH_NOISY);
				if (zend_is_true(field_filters)) {
	
					PHALCON_INIT_VAR(service_name);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service_name, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&dependency_injector, this_ptr, "getdi");
					if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
						PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
	
						if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
							PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "A dependency injector is required to obtain the 'filter' service");
							return;
						}
					}
	
					PHALCON_CALL_METHOD(&filter_service, dependency_injector, "getshared", service_name);
					if (Z_TYPE_P(filter_service) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "Returned 'filter' service is invalid");
						return;
					}
	
					PHALCON_VERIFY_INTERFACE(filter_service, phalcon_filterinterface_ce);
					PHALCON_RETURN_CALL_METHOD(filter_service, "sanitize", value, field_filters);
					RETURN_MM();
				}
			}
		}
	
		phalcon_update_property_array(this_ptr, SL("_values"), attribute, value TSRMLS_CC);
	
		RETURN_CCTOR(value);
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Validation, setDefaultMessages)
{
	zval *messages = NULL, *m, *default_messages;

	PHALCON_MM_GROW();
	phalcon_fetch_params(1, 0, 1, &messages);

	if (messages && Z_TYPE_P(messages) != IS_NULL && Z_TYPE_P(messages) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "Messages must be an array");
		return;
	}

	PHALCON_INIT_VAR(default_messages);
	array_init_size(default_messages, 22);

	add_assoc_stringl_ex(default_messages, SS("Alnum"),             SL("Field :field must contain only letters and numbers"), 1);
	add_assoc_stringl_ex(default_messages, SS("Alpha"),             SL("Field :field must contain only letters"), 1);
	add_assoc_stringl_ex(default_messages, SS("Between"),           SL("Field :field must be within the range of :min to :max"), 1);
	add_assoc_stringl_ex(default_messages, SS("Confirmation"),      SL("Field :field must be the same as :with"), 1);
	add_assoc_stringl_ex(default_messages, SS("Digit"),             SL("Field :field must be numeric"), 1);
	add_assoc_stringl_ex(default_messages, SS("Email"),             SL("Field :field must be an email address"), 1);
	add_assoc_stringl_ex(default_messages, SS("ExclusionIn"),       SL("Field :field must not be a part of list: :domain"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileEmpty"),         SL("Field :field must not be empty"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileIniSize"),       SL("File :field exceeds the maximum file size"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileMaxResolution"), SL("File :field must not exceed :max resolution"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileMinResolution"), SL("File :field must be at least :min resolution"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileSize"),          SL("File :field exceeds the size of :max"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileType"),          SL("File :field must be of type: :types"), 1);
	add_assoc_stringl_ex(default_messages, SS("FileValid"),         SL("Field :field is not valid"), 1);
	add_assoc_stringl_ex(default_messages, SS("Identical"),         SL("Field :field does not have the expected value"), 1);
	add_assoc_stringl_ex(default_messages, SS("InclusionIn"),       SL("Field :field must be a part of list: :domain"), 1);
	add_assoc_stringl_ex(default_messages, SS("PresenceOf"),        SL("Field :field is required"), 1);
	add_assoc_stringl_ex(default_messages, SS("Regex"),             SL("Field :field does not match the required format"), 1);
	add_assoc_stringl_ex(default_messages, SS("TooLong"),           SL("Field :field must not exceed :max characters long"), 1);
	add_assoc_stringl_ex(default_messages, SS("TooShort"),          SL("Field :field must be at least :min characters long"), 1);
	add_assoc_stringl_ex(default_messages, SS("Uniqueness"),        SL("Field :field must be unique"), 1);
	add_assoc_stringl_ex(default_messages, SS("Url"),               SL("Field :field must be a url"), 1);

	if (!messages || Z_TYPE_P(messages) == IS_NULL) {
		phalcon_update_property_this(getThis(), SL("_defaultMessages"), default_messages TSRMLS_CC);
	}
	else {
		PHALCON_INIT_VAR(m);
		phalcon_fast_array_merge(m, &default_messages, &messages TSRMLS_CC);
		phalcon_update_property_this(getThis(), SL("_defaultMessages"), m TSRMLS_CC);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Validation, getDefaultMessage)
{
	zval *type, *messages, *msg;

	phalcon_fetch_params(0, 1, 0, &type);

	messages = phalcon_fetch_nproperty_this(getThis(), SL("_defaultMessages"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&msg, messages, type)) {
		RETURN_ZVAL(msg, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Validation, setLabels) {

	zval *labels;

	phalcon_fetch_params(0, 1, 0, &labels);

	if (Z_TYPE_P(labels) != IS_ARRAY) {
		zend_throw_exception_ex(phalcon_validation_exception_ce, 0 TSRMLS_CC, "Labels must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_labels"), labels, 2333994455UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation, getLabel) {

	zval *field_param = NULL, *labels, *value;
	zval *field = NULL;

	PHALCON_MM_GROW();
	phalcon_fetch_params(1, 1, 0, &field_param);

	if (Z_TYPE_P(field_param) != IS_STRING && Z_TYPE_P(field_param) != IS_NULL) {
		zend_throw_exception_ex(phalcon_validation_exception_ce, 0 TSRMLS_CC, "Parameter 'field' must be a string");
		RETURN_MM_NULL();
	}

	if (Z_TYPE_P(field_param) == IS_STRING) {
		field = field_param;
	} else {
		PHALCON_INIT_VAR(field);
		ZVAL_EMPTY_STRING(field);
	}

	labels = phalcon_fetch_nproperty_this(getThis(), SL("_labels"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(labels) == IS_ARRAY) {
		if (phalcon_array_isset_fetch(&value, labels, field)) {
			RETURN_CTOR(value);
		}
	}

	RETURN_MM_NULL();
}





zend_class_entry *phalcon_version_ce;

static PHP_METHOD(Phalcon_Version, _getVersion);
static PHP_METHOD(Phalcon_Version, get);
static PHP_METHOD(Phalcon_Version, getId);

static const zend_function_entry phalcon_version_method_entry[] = {
	PHP_ME(Phalcon_Version, _getVersion, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Version, get, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Version, getId, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Version){

	PHALCON_REGISTER_CLASS(Phalcon, Version, version, phalcon_version_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Version, _getVersion){

	array_init_size(return_value, 5);
	add_next_index_long(return_value, 1);
	add_next_index_long(return_value, 3);
	add_next_index_long(return_value, 4);
	add_next_index_long(return_value, PHALCON_VERSION_STABLE);
	add_next_index_long(return_value, 1);
}

static PHP_METHOD(Phalcon_Version, get){

	zval *version = NULL, *major, *medium, *minor, *special, *special_number;
	zval *result, *suffix;

	PHALCON_MM_GROW();

	PHALCON_CALL_SELF(&version, "_getversion");

	PHALCON_OBS_VAR(major);
	phalcon_array_fetch_long(&major, version, 0, PH_NOISY);

	PHALCON_OBS_VAR(medium);
	phalcon_array_fetch_long(&medium, version, 1, PH_NOISY);

	PHALCON_OBS_VAR(minor);
	phalcon_array_fetch_long(&minor, version, 2, PH_NOISY);

	PHALCON_OBS_VAR(special);
	phalcon_array_fetch_long(&special, version, 3, PH_NOISY);

	PHALCON_OBS_VAR(special_number);
	phalcon_array_fetch_long(&special_number, version, 4, PH_NOISY);

	PHALCON_INIT_VAR(result);
	PHALCON_CONCAT_VSVSVS(result, major, ".", medium, ".", minor, " ");

	PHALCON_INIT_VAR(suffix);
	switch (phalcon_get_intval(special)) {

		case PHALCON_VERSION_ALPHA:
			PHALCON_CONCAT_SV(suffix, "ALPHA ", special_number);
			break;

		case PHALCON_VERSION_BETA:
			PHALCON_CONCAT_SV(suffix, "BETA ", special_number);
			break;

		case PHALCON_VERSION_RC:
			PHALCON_CONCAT_SV(suffix, "RC ", special_number);
			break;

		default:
			ZVAL_STRING(suffix, "", 1);
			break;

	}
	phalcon_concat_self(&result, suffix TSRMLS_CC);
	phalcon_fast_trim(return_value, result, PHALCON_TRIM_BOTH TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Version, getId){

	zval *version = NULL, *major, *medium, *minor, *special, *special_number;
	zval *format, *real_medium = NULL, *real_minor = NULL;

	PHALCON_MM_GROW();

	PHALCON_CALL_SELF(&version, "_getversion");

	PHALCON_OBS_VAR(major);
	phalcon_array_fetch_long(&major, version, 0, PH_NOISY);

	PHALCON_OBS_VAR(medium);
	phalcon_array_fetch_long(&medium, version, 1, PH_NOISY);

	PHALCON_OBS_VAR(minor);
	phalcon_array_fetch_long(&minor, version, 2, PH_NOISY);

	PHALCON_OBS_VAR(special);
	phalcon_array_fetch_long(&special, version, 3, PH_NOISY);

	PHALCON_OBS_VAR(special_number);
	phalcon_array_fetch_long(&special_number, version, 4, PH_NOISY);

	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "%02s", 1);

	PHALCON_CALL_FUNCTION(&real_medium, "sprintf", format, medium);

	PHALCON_CALL_FUNCTION(&real_minor, "sprintf", format, minor);
	PHALCON_CONCAT_VVVVV(return_value, major, real_medium, real_minor, special, special_number);
	RETURN_MM();
}






static PHP_METHOD(Phalcon_Acl_Adapter, setEventsManager);
static PHP_METHOD(Phalcon_Acl_Adapter, getEventsManager);
static PHP_METHOD(Phalcon_Acl_Adapter, setDefaultAction);
static PHP_METHOD(Phalcon_Acl_Adapter, getDefaultAction);
static PHP_METHOD(Phalcon_Acl_Adapter, getActiveRole);
static PHP_METHOD(Phalcon_Acl_Adapter, getActiveResource);
static PHP_METHOD(Phalcon_Acl_Adapter, getActiveAccess);

zend_class_entry *phalcon_acl_adapter_ce;

static const zend_function_entry phalcon_acl_adapter_method_entry[] = {
	PHP_ME(Phalcon_Acl_Adapter, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, setDefaultAction, arginfo_phalcon_acl_adapter_setdefaultaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, getDefaultAction, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, getActiveRole, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, getActiveResource, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter, getActiveAccess, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Acl_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Adapter, acl_adapter, phalcon_acl_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_acl_adapter_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_acl_adapter_ce, SL("_defaultAccess"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_acl_adapter_ce, SL("_accessGranted"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_ce, SL("_activeRole"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_ce, SL("_activeResource"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_ce, SL("_activeAccess"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_adapter_ce TSRMLS_CC, 2, phalcon_events_eventsawareinterface_ce, phalcon_acl_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Acl_Adapter, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Acl_Adapter, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Acl_Adapter, setDefaultAction){

	zval *default_access;

	phalcon_fetch_params(0, 1, 0, &default_access);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultAccess"), default_access, 875397115UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Acl_Adapter, getDefaultAction){


	RETURN_MEMBER_QUICK(this_ptr, "_defaultAccess", 875397115UL);
}

static PHP_METHOD(Phalcon_Acl_Adapter, getActiveRole){


	RETURN_MEMBER_QUICK(this_ptr, "_activeRole", 3079165426UL);
}

static PHP_METHOD(Phalcon_Acl_Adapter, getActiveResource){


	RETURN_MEMBER_QUICK(this_ptr, "_activeResource", 1323587080UL);
}

static PHP_METHOD(Phalcon_Acl_Adapter, getActiveAccess){


	RETURN_MEMBER_QUICK(this_ptr, "_activeAccess", 2176370066UL);
}





zend_class_entry *phalcon_acl_adapterinterface_ce;

static const zend_function_entry phalcon_acl_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, setDefaultAction, arginfo_phalcon_acl_adapterinterface_setdefaultaction)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getDefaultAction, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, addRole, arginfo_phalcon_acl_adapterinterface_addrole)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, addInherit, arginfo_phalcon_acl_adapterinterface_addinherit)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, isRole, arginfo_phalcon_acl_adapterinterface_isrole)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, isResource, arginfo_phalcon_acl_adapterinterface_isresource)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, addResource, arginfo_phalcon_acl_adapterinterface_addresource)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, addResourceAccess, arginfo_phalcon_acl_adapterinterface_addresourceaccess)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, dropResourceAccess, arginfo_phalcon_acl_adapterinterface_dropresourceaccess)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, allow, arginfo_phalcon_acl_adapterinterface_allow)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, deny, arginfo_phalcon_acl_adapterinterface_allow)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, isAllowed, arginfo_phalcon_acl_adapterinterface_isallowed)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getActiveRole, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getActiveResource, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getActiveAccess, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getRoles, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Acl_AdapterInterface, getResources, arginfo_phalcon_acl_adapterinterface_empty)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Acl_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, AdapterInterface, acl_adapterinterface, phalcon_acl_adapterinterface_method_entry);

	return SUCCESS;
}






















zend_class_entry *phalcon_acl_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Acl_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Acl, Exception, acl_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_acl_resource_ce;

static PHP_METHOD(Phalcon_Acl_Resource, __construct);
static PHP_METHOD(Phalcon_Acl_Resource, getName);
static PHP_METHOD(Phalcon_Acl_Resource, getDescription);
static PHP_METHOD(Phalcon_Acl_Resource, __toString);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_acl_resource___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, description)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_acl_resource_method_entry[] = {
	PHP_ME(Phalcon_Acl_Resource, __construct, arginfo_phalcon_acl_resource___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Acl_Resource, getName, arginfo_phalcon_acl_resourceinterface_getname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Resource, getDescription, arginfo_phalcon_acl_resourceinterface_getdescription, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Resource, __toString, arginfo___tostring, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Acl_Resource){

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Resource, acl_resource, phalcon_acl_resource_method_entry, 0);

	zend_declare_property_null(phalcon_acl_resource_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_resource_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_resource_ce TSRMLS_CC, 1, phalcon_acl_resourceinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Acl_Resource, __construct){

	zval *name, *description = NULL;

	phalcon_fetch_params(0, 1, 1, &name, &description);
	
	if (PHALCON_IS_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_acl_exception_ce, "Resource name cannot be \"*\"");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	if (description && Z_TYPE_P(description) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_description"), description, 1348915240UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Acl_Resource, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Acl_Resource, getDescription){


	RETURN_MEMBER_QUICK(this_ptr, "_description", 1348915240UL);
}

static PHP_METHOD(Phalcon_Acl_Resource, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}






zend_class_entry *phalcon_acl_resourceinterface_ce;

static const zend_function_entry phalcon_acl_resourceinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Acl_ResourceInterface, getName, arginfo_phalcon_acl_resourceinterface_getname)
	PHP_ABSTRACT_ME(Phalcon_Acl_ResourceInterface, getDescription, arginfo_phalcon_acl_resourceinterface_getdescription)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Acl_ResourceInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, ResourceInterface, acl_resourceinterface, phalcon_acl_resourceinterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_acl_role_ce;

static PHP_METHOD(Phalcon_Acl_Role, __construct);
static PHP_METHOD(Phalcon_Acl_Role, getName);
static PHP_METHOD(Phalcon_Acl_Role, getDescription);
static PHP_METHOD(Phalcon_Acl_Role, __toString);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_acl_role___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, description)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_acl_role_method_entry[] = {
	PHP_ME(Phalcon_Acl_Role, __construct, arginfo_phalcon_acl_role___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Acl_Role, getName, arginfo_phalcon_acl_roleinterface_getname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Role, getDescription, arginfo_phalcon_acl_roleinterface_getdescription, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Role, __toString, arginfo___tostring, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Acl_Role){

	PHALCON_REGISTER_CLASS(Phalcon\\Acl, Role, acl_role, phalcon_acl_role_method_entry, 0);

	zend_declare_property_null(phalcon_acl_role_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_role_ce, SL("_description"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_role_ce TSRMLS_CC, 1, phalcon_acl_roleinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Acl_Role, __construct){

	zval *name, *description = NULL;

	phalcon_fetch_params(0, 1, 1, &name, &description);
	
	if (PHALCON_IS_STRING(name, "*")) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_acl_exception_ce, "Role name cannot be \"*\"");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	if (description && Z_TYPE_P(description) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_description"), description, 1348915240UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Acl_Role, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Acl_Role, getDescription){


	RETURN_MEMBER_QUICK(this_ptr, "_description", 1348915240UL);
}

static PHP_METHOD(Phalcon_Acl_Role, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}






zend_class_entry *phalcon_acl_roleinterface_ce;

static const zend_function_entry phalcon_acl_roleinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Acl_RoleInterface, getName, arginfo_phalcon_acl_roleinterface_getname)
	PHP_ABSTRACT_ME(Phalcon_Acl_RoleInterface, getDescription, arginfo_phalcon_acl_roleinterface_getdescription)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Acl_RoleInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Acl, RoleInterface, acl_roleinterface, phalcon_acl_roleinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_acl_adapter_memory_ce;

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, __construct);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addRole);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addInherit);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isRole);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isResource);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResource);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResourceAccess);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, dropResourceAccess);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, _allowOrDeny);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, allow);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, deny);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isAllowed);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, getRoles);
static PHP_METHOD(Phalcon_Acl_Adapter_Memory, getResources);

static const zend_function_entry phalcon_acl_adapter_memory_method_entry[] = {
	PHP_ME(Phalcon_Acl_Adapter_Memory, __construct, arginfo_phalcon_acl_adapterinterface_empty, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Acl_Adapter_Memory, addRole, arginfo_phalcon_acl_adapterinterface_addrole, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, addInherit, arginfo_phalcon_acl_adapterinterface_addinherit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, isRole, arginfo_phalcon_acl_adapterinterface_isrole, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, isResource, arginfo_phalcon_acl_adapterinterface_isresource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, addResource, arginfo_phalcon_acl_adapterinterface_addresource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, addResourceAccess, arginfo_phalcon_acl_adapterinterface_addresourceaccess, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, dropResourceAccess, arginfo_phalcon_acl_adapterinterface_dropresourceaccess, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, _allowOrDeny, arginfo_phalcon_acl_adapterinterface_empty, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Acl_Adapter_Memory, allow, arginfo_phalcon_acl_adapterinterface_allow, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, deny, arginfo_phalcon_acl_adapterinterface_allow, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, isAllowed, arginfo_phalcon_acl_adapterinterface_isallowed, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, getRoles, arginfo_phalcon_acl_adapterinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Acl_Adapter_Memory, getResources, arginfo_phalcon_acl_adapterinterface_empty, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Acl_Adapter_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Acl\\Adapter, Memory, acl_adapter_memory, phalcon_acl_adapter_ce, phalcon_acl_adapter_memory_method_entry, 0);

	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_rolesNames"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roles"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resourcesNames"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_resources"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_access"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_roleInherits"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_acl_adapter_memory_ce, SL("_accessList"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_acl_adapter_memory_ce TSRMLS_CC, 1, phalcon_acl_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, __construct){

	zval *resources_names, *access_list;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(resources_names);
	array_init_size(resources_names, 1);
	phalcon_array_update_string(&resources_names, SL("*"), PHALCON_GLOBAL(z_true), PH_COPY);
	phalcon_update_property_this_quick(this_ptr, SL("_resourcesNames"), resources_names, 2424408563UL TSRMLS_CC);
	
	PHALCON_INIT_VAR(access_list);
	array_init_size(access_list, 1);
	phalcon_array_update_string(&access_list, SL("*!*"), PHALCON_GLOBAL(z_true), PH_COPY);
	phalcon_update_property_this_quick(this_ptr, SL("_accessList"), access_list, 2206680658UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addRole){

	zval *role, *access_inherits = NULL, *role_name = NULL, *object = NULL;
	zval *roles_names, *default_access;
	zval *key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &role, &access_inherits);
	
	if (!access_inherits) {
		access_inherits = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(role) == IS_OBJECT) {
		PHALCON_CALL_METHOD(&role_name, role, "getname");
		PHALCON_CPY_WRT(object, role);
	} else {
		PHALCON_CPY_WRT(role_name, role);
	
		PHALCON_INIT_NVAR(object);
		object_init_ex(object, phalcon_acl_role_ce);
		PHALCON_CALL_METHOD(NULL, object, "__construct", role);
	
	}
	
	roles_names = phalcon_fetch_nproperty_this(this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(roles_names, role_name)) {
		RETURN_MM_FALSE;
	}
	
	phalcon_update_property_array_append(this_ptr, SL("_roles"), object TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_rolesNames"), role_name, PHALCON_GLOBAL(z_true) TSRMLS_CC);
	
	default_access = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAccess"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VS(key, role_name, "!*!*");
	phalcon_update_property_array(this_ptr, SL("_access"), key, default_access TSRMLS_CC);
	if (Z_TYPE_P(access_inherits) != IS_NULL) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "addinherit", role_name, access_inherits);
		RETURN_MM();
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addInherit){

	zval *role_name, *role_to_inherit, *roles_names;
	zval *exception_message = NULL, *role_inherit_name = NULL;
	zval *roles_inherits, *empty_arr, *_roleInherits;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &role_name, &role_to_inherit);
	
	PHALCON_OBS_VAR(roles_names);
	phalcon_read_property_this(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(roles_names, role_name)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role '", role_name, "' does not exist in the role list");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	if (Z_TYPE_P(role_to_inherit) == IS_OBJECT) {
		PHALCON_CALL_METHOD(&role_inherit_name, role_to_inherit, "getname");
	} else {
		PHALCON_CPY_WRT(role_inherit_name, role_to_inherit);
	}
	
	if (!phalcon_array_isset(roles_names, role_inherit_name)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role '", role_inherit_name, "' (to inherit) does not exist in the role list");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	if (PHALCON_IS_EQUAL(role_inherit_name, role_name)) {
		RETURN_MM_FALSE;
	}
	
	PHALCON_OBS_VAR(roles_inherits);
	phalcon_read_property_this(&roles_inherits, this_ptr, SL("_roleInherits"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(roles_inherits, role_name)) {
		PHALCON_INIT_VAR(empty_arr);
		array_init(empty_arr);
		phalcon_update_property_array(this_ptr, SL("_roleInherits"), role_name, empty_arr TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(_roleInherits);
	phalcon_read_property_this(&_roleInherits, this_ptr, SL("_roleInherits"), PH_NOISY TSRMLS_CC);
	phalcon_array_append_multi_2(&_roleInherits, role_name, role_inherit_name, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_roleInherits"), _roleInherits, 1806479324UL TSRMLS_CC);
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isRole){

	zval *role_name, *roles_names;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &role_name);
	
	PHALCON_OBS_VAR(roles_names);
	phalcon_read_property_this(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(roles_names, role_name)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isResource){

	zval *resource_name, *resources_names;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &resource_name);
	
	PHALCON_OBS_VAR(resources_names);
	phalcon_read_property_this(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(resources_names, resource_name)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResource){

	zval *resource, *access_list = NULL, *resource_name = NULL;
	zval *object = NULL, *resources_names;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &resource, &access_list);
	
	if (!access_list) {
		access_list = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(resource) == IS_OBJECT) {
		PHALCON_CALL_METHOD(&resource_name, resource, "getname");
		PHALCON_CPY_WRT(object, resource);
	} else {
		PHALCON_CPY_WRT(resource_name, resource);
	
		PHALCON_INIT_NVAR(object);
		object_init_ex(object, phalcon_acl_resource_ce);
		PHALCON_CALL_METHOD(NULL, object, "__construct", resource_name);
	
	}
	
	PHALCON_OBS_VAR(resources_names);
	phalcon_read_property_this(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(resources_names, resource_name)) {
		phalcon_update_property_array_append(this_ptr, SL("_resources"), object TSRMLS_CC);
		phalcon_update_property_array(this_ptr, SL("_resourcesNames"), resource_name, PHALCON_GLOBAL(z_true) TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "addresourceaccess", resource_name, access_list);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, addResourceAccess){

	zval *resource_name, *access_list, *resources_names;
	zval *exception_message, *internal_access_list;
	zval *access_name = NULL, *access_key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &resource_name, &access_list);
	
	PHALCON_OBS_VAR(resources_names);
	phalcon_read_property_this(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(resources_names, resource_name)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Resource '", resource_name, "' does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_OBS_VAR(internal_access_list);
	phalcon_read_property_this(&internal_access_list, this_ptr, SL("_accessList"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
	
		phalcon_is_iterable(access_list, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(access_name);
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSV(access_key, resource_name, "!", access_name);
			if (!phalcon_array_isset(internal_access_list, access_key)) {
				phalcon_update_property_array(this_ptr, SL("_accessList"), access_key, PHALCON_GLOBAL(z_true) TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		if (Z_TYPE_P(access_list) == IS_STRING) {
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSV(access_key, resource_name, "!", access_list);
			if (!phalcon_array_isset(internal_access_list, access_key)) {
				phalcon_update_property_array(this_ptr, SL("_accessList"), access_key, PHALCON_GLOBAL(z_true) TSRMLS_CC);
			}
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, dropResourceAccess){

	zval *resource_name, *access_list, *access_name = NULL;
	zval *access_key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &resource_name, &access_list);
	
	if (Z_TYPE_P(access_list) == IS_ARRAY) { 
	
		phalcon_is_iterable(access_list, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(access_name);
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSV(access_key, resource_name, "!", access_name);
			phalcon_unset_property_array(this_ptr, SL("_accessList"), access_key TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		PHALCON_INIT_VAR(access_key);
		PHALCON_CONCAT_VSV(access_key, resource_name, "!", access_list);
		phalcon_unset_property_array(this_ptr, SL("_accessList"), access_key TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, _allowOrDeny){

	zval *role_name, *resource_name, *access, *action;
	zval *roles_names, *exception_message = NULL, *resources_names;
	zval *default_access, *access_list, *internal_access;
	zval *access_name = NULL, *access_key = NULL, *access_key_all = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &role_name, &resource_name, &access, &action);
	
	PHALCON_OBS_VAR(roles_names);
	phalcon_read_property_this(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(roles_names, role_name)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Role \"", role_name, "\" does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_OBS_VAR(resources_names);
	phalcon_read_property_this(&resources_names, this_ptr, SL("_resourcesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(resources_names, resource_name)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Resource \"", resource_name, "\" does not exist in ACL");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
		return;
	}
	
	PHALCON_OBS_VAR(default_access);
	phalcon_read_property_this(&default_access, this_ptr, SL("_defaultAccess"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(access_list);
	phalcon_read_property_this(&access_list, this_ptr, SL("_accessList"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(internal_access);
	phalcon_read_property_this(&internal_access, this_ptr, SL("_access"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(access) == IS_ARRAY) { 
	
		phalcon_is_iterable(access, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(access_name);
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSV(access_key, resource_name, "!", access_name);
			if (!phalcon_array_isset(access_list, access_key)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "Acccess '", access_name, "' does not exist in resource '", resource_name, "'");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
				return;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_is_iterable(access, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(access_name);
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSVSV(access_key, role_name, "!", resource_name, "!", access_name);
			phalcon_update_property_array(this_ptr, SL("_access"), access_key, action TSRMLS_CC);
			if (!PHALCON_IS_STRING(access_name, "*")) {
	
				PHALCON_INIT_NVAR(access_key_all);
				PHALCON_CONCAT_VSVS(access_key_all, role_name, "!", resource_name, "!*");
				if (!phalcon_array_isset(internal_access, access_key_all)) {
					phalcon_update_property_array(this_ptr, SL("_access"), access_key_all, default_access TSRMLS_CC);
				}
			}
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
	} else {
		if (!PHALCON_IS_STRING(access, "*")) {
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSV(access_key, resource_name, "!", access);
			if (!phalcon_array_isset(access_list, access_key)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "Acccess '", access, "' does not exist in resource '", resource_name, "'");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_acl_exception_ce, exception_message);
				return;
			}
		}
	
		PHALCON_INIT_NVAR(access_key);
		PHALCON_CONCAT_VSVSV(access_key, role_name, "!", resource_name, "!", access);
	
		phalcon_update_property_array(this_ptr, SL("_access"), access_key, action TSRMLS_CC);
		if (!PHALCON_IS_STRING(access, "*")) {
	
			PHALCON_INIT_NVAR(access_key);
			PHALCON_CONCAT_VSVS(access_key, role_name, "!", resource_name, "!*");
	
			if (!phalcon_array_isset(internal_access, access_key)) {
				phalcon_update_property_array(this_ptr, SL("_access"), access_key, default_access TSRMLS_CC);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, allow){

	zval *role_name, *resource_name, *access, *action, *roles_names;
	zval *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &role_name, &resource_name, &access);
	
	PHALCON_INIT_VAR(action);
	ZVAL_LONG(action, 1);

	if (!PHALCON_IS_STRING(role_name, "*")) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "_allowordeny", role_name, resource_name, access, action);
	} else {
		PHALCON_OBS_VAR(roles_names);
		phalcon_read_property_this(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);

		phalcon_is_iterable(roles_names, &ah0, &hp0, 0, 0);	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);

			PHALCON_CALL_METHOD(NULL, this_ptr, "_allowordeny", key, resource_name, access, action);
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, deny){

	zval *role_name, *resource_name, *access, *action, *roles_names;
	zval *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &role_name, &resource_name, &access);
	
	PHALCON_INIT_VAR(action);
	ZVAL_LONG(action, 0);

	if (!PHALCON_IS_STRING(role_name, "*")) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "_allowordeny", role_name, resource_name, access, action);
	} else {
		PHALCON_OBS_VAR(roles_names);
		phalcon_read_property_this(&roles_names, this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);

		phalcon_is_iterable(roles_names, &ah0, &hp0, 0, 0);
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);

			PHALCON_CALL_METHOD(NULL, this_ptr, "_allowordeny", key, resource_name, access, action);
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}

	RETURN_MM();
}

#define PHALCON_ACL_NO      0
#define PHALCON_ACL_YES     1
#define PHALCON_ACL_DUNNO  -1

static int phalcon_role_adapter_memory_check_inheritance(zval *role, zval *resource, zval *access, zval *access_list, zval* role_inherits TSRMLS_DC)
{
	zval *inherited_roles, *access_key;
	zval **parent_role;
	int result = PHALCON_ACL_DUNNO;
	HashPosition hp;

	assert(Z_TYPE_P(role) == IS_STRING);
	assert(Z_TYPE_P(resource) == IS_STRING);
	assert(Z_TYPE_P(access) == IS_STRING);
	assert(Z_TYPE_P(access_list) == IS_ARRAY);

	if (!phalcon_array_isset_fetch(&inherited_roles, role_inherits, role) || Z_TYPE_P(inherited_roles) != IS_ARRAY) {
		return PHALCON_ACL_DUNNO;
	}

	ALLOC_INIT_ZVAL(access_key);
	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(inherited_roles), &hp);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(inherited_roles), (void**)&parent_role, &hp) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(inherited_roles), &hp)
	) {
		int found;
		zval *have_access;

		phalcon_concat_vsvsv(&access_key, *parent_role, SL("!"), resource, SL("!"), access, 0 TSRMLS_CC);
		found = phalcon_array_isset_fetch(&have_access, access_list, access_key);
		zval_dtor(access_key);
		ZVAL_NULL(access_key);

		if (found) {
			result = zend_is_true(have_access) ? PHALCON_ACL_YES : PHALCON_ACL_NO;
		}
		else {
			result = phalcon_role_adapter_memory_check_inheritance(*parent_role, resource, access, access_list, role_inherits TSRMLS_CC);
		}

		if (PHALCON_ACL_DUNNO != result) {
			break;
		}
	}

	zval_ptr_dtor(&access_key);
	return result;
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, isAllowed){

	zval *role, *resource, *access, *events_manager, *role_inherits;
	zval *event_name = NULL, *status = NULL, *default_access, *roles_names;
	zval *have_access = NULL, *access_list, *access_key = NULL;
	zval star;
	int allow_access;

	PHALCON_MM_GROW();

	INIT_ZVAL(star);
	ZVAL_STRING(&star, "*", 0);

	phalcon_fetch_params(1, 3, 0, &role, &resource, &access);
	
	phalcon_update_property_this_quick(this_ptr, SL("_activeRole"), role, 3079165426UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_activeResource"), resource, 1323587080UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_activeAccess"), access, 2176370066UL TSRMLS_CC);
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "acl:beforeCheckAccess", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_CTOR(status);
		}
	}
	
	default_access = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAccess"), PH_NOISY TSRMLS_CC);
	
	roles_names = phalcon_fetch_nproperty_this(this_ptr, SL("_rolesNames"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(roles_names, role)) {
		RETURN_CTOR(default_access);
	}
	
	access_list = phalcon_fetch_nproperty_this(this_ptr, SL("_access"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(access_key);
	PHALCON_CONCAT_VSVSV(access_key, role, "!", resource, "!", access);
	
	if (phalcon_array_isset_fetch(&have_access, access_list, access_key)) {
		allow_access = zend_is_true(have_access) ? PHALCON_ACL_YES : PHALCON_ACL_NO;
	}
	else {
		allow_access = PHALCON_ACL_DUNNO;
	}

	if (PHALCON_ACL_DUNNO == allow_access) {
		role_inherits = phalcon_fetch_nproperty_this(this_ptr, SL("_roleInherits"), PH_NOISY TSRMLS_CC);
		allow_access  = phalcon_role_adapter_memory_check_inheritance(role, resource, access, access_list, role_inherits TSRMLS_CC);
	}
	
	if (PHALCON_ACL_DUNNO == allow_access) {
	
		PHALCON_INIT_NVAR(access_key);
		PHALCON_CONCAT_VSVS(access_key, role, "!", resource, "!*");
	
		if (phalcon_array_isset_fetch(&have_access, access_list, access_key)) {
			allow_access = zend_is_true(have_access) ? PHALCON_ACL_YES : PHALCON_ACL_NO;
		}
		else {
			allow_access = phalcon_role_adapter_memory_check_inheritance(role, resource, &star, access_list, role_inherits TSRMLS_CC);
		}
	}
	
	if (PHALCON_ACL_DUNNO == allow_access) {
	
		PHALCON_INIT_NVAR(access_key);
		PHALCON_CONCAT_VS(access_key, role, "!*!*");
	
		if (phalcon_array_isset_fetch(&have_access, access_list, access_key)) {
			allow_access = zend_is_true(have_access) ? PHALCON_ACL_YES : PHALCON_ACL_NO;
		}
		else {
			allow_access = phalcon_role_adapter_memory_check_inheritance(role, &star, &star, access_list, role_inherits TSRMLS_CC);
		}
	}

	ZVAL_BOOL(return_value, PHALCON_ACL_YES == allow_access);

	phalcon_update_property_this_quick(this_ptr, SL("_accessGranted"), return_value, 3188809627UL TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "acl:afterCheckAccess", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, return_value);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, getRoles){


	RETURN_MEMBER_QUICK(this_ptr, "_roles", 2795361801UL);
}

static PHP_METHOD(Phalcon_Acl_Adapter_Memory, getResources){


	RETURN_MEMBER_QUICK(this_ptr, "_resources", 3320036063UL);
}






zend_class_entry *phalcon_annotations_adapter_ce;

static PHP_METHOD(Phalcon_Annotations_Adapter, setReader);
static PHP_METHOD(Phalcon_Annotations_Adapter, getReader);
static PHP_METHOD(Phalcon_Annotations_Adapter, get);
static PHP_METHOD(Phalcon_Annotations_Adapter, getMethods);
static PHP_METHOD(Phalcon_Annotations_Adapter, getMethod);
static PHP_METHOD(Phalcon_Annotations_Adapter, getProperties);
static PHP_METHOD(Phalcon_Annotations_Adapter, getProperty);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_setreader, 0, 0, 1)
	ZEND_ARG_INFO(0, reader)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_get, 0, 0, 1)
	ZEND_ARG_INFO(0, className)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_getmethods, 0, 0, 1)
	ZEND_ARG_INFO(0, className)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_getmethod, 0, 0, 2)
	ZEND_ARG_INFO(0, className)
	ZEND_ARG_INFO(0, methodName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_getproperties, 0, 0, 1)
	ZEND_ARG_INFO(0, className)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_getproperty, 0, 0, 2)
	ZEND_ARG_INFO(0, className)
	ZEND_ARG_INFO(0, propertyName)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_adapter_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Adapter, setReader, arginfo_phalcon_annotations_adapter_setreader, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, getReader, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, get, arginfo_phalcon_annotations_adapter_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, getMethods, arginfo_phalcon_annotations_adapter_getmethods, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, getMethod, arginfo_phalcon_annotations_adapter_getmethod, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, getProperties, arginfo_phalcon_annotations_adapter_getproperties, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter, getProperty, arginfo_phalcon_annotations_adapter_getproperty, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Annotations, Adapter, annotations_adapter, phalcon_annotations_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_annotations_adapter_ce, SL("_reader"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_adapter_ce, SL("_annotations"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_annotations_adapter_ce TSRMLS_CC, 1, phalcon_annotations_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Adapter, setReader){

	zval *reader;

	phalcon_fetch_params(0, 1, 0, &reader);
	
	if (Z_TYPE_P(reader) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_annotations_exception_ce, "Invalid annotations reader");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_reader"), reader, 1648179735UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Annotations_Adapter, getReader){

	zval *reader;

	reader = phalcon_fetch_nproperty_this(this_ptr, SL("_reader"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(reader) != IS_OBJECT) {
		object_init_ex(return_value, phalcon_annotations_reader_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_reader"), return_value, 1648179735UL TSRMLS_CC);
		return;
	}
	
	RETURN_ZVAL(reader, 1, 0);
}

static PHP_METHOD(Phalcon_Annotations_Adapter, get){

	zval *class_name, *real_class_name = NULL, *annotations;
	zval *class_annotations = NULL, *reader = NULL, *parsed_annotations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &class_name);
	
	if (Z_TYPE_P(class_name) == IS_OBJECT) {
		const zend_class_entry *ce = Z_OBJCE_P(class_name);
		PHALCON_INIT_VAR(real_class_name);
		ZVAL_STRINGL(real_class_name, ce->name, ce->name_length, !IS_INTERNED(ce->name));
	} else {
		PHALCON_CPY_WRT(real_class_name, class_name);
	}
	
	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&class_annotations, annotations, real_class_name)) {
		RETURN_CTOR(class_annotations);
	}
	
	PHALCON_CALL_METHOD(&class_annotations, this_ptr, "read", real_class_name);
	if (Z_TYPE_P(class_annotations) == IS_NULL) {
	
		PHALCON_CALL_METHOD(&reader, this_ptr, "getreader");
		PHALCON_CALL_METHOD(&parsed_annotations, reader, "parse", real_class_name);
	
		if (Z_TYPE_P(parsed_annotations) == IS_ARRAY) { 
			PHALCON_INIT_NVAR(class_annotations);
			object_init_ex(class_annotations, phalcon_annotations_reflection_ce);
			PHALCON_CALL_METHOD(NULL, class_annotations, "__construct", parsed_annotations);
	
			phalcon_update_property_array(this_ptr, SL("_annotations"), real_class_name, class_annotations TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, this_ptr, "write", real_class_name, class_annotations);
		}
	}
	
	RETURN_CTOR(class_annotations);
}

static PHP_METHOD(Phalcon_Annotations_Adapter, getMethods){

	zval *class_name, *class_annotations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &class_name);
	
	PHALCON_CALL_METHOD(&class_annotations, this_ptr, "get", class_name);
	
	if (Z_TYPE_P(class_annotations) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(class_annotations, "getmethodsannotations");
		RETURN_MM();
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Annotations_Adapter, getMethod){

	zval *class_name, *method_name, *class_annotations = NULL;
	zval *methods = NULL, *method = NULL, *name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &class_name, &method_name);
	
	PHALCON_CALL_METHOD(&class_annotations, this_ptr, "get", class_name);
	
	if (Z_TYPE_P(class_annotations) == IS_OBJECT) {
	
		PHALCON_CALL_METHOD(&methods, class_annotations, "getmethodsannotations");
		if (Z_TYPE_P(methods) == IS_ARRAY) { 
	
			phalcon_is_iterable(methods, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(name, ah0, hp0);
				PHALCON_GET_HVALUE(method);
	
				if (PHALCON_IS_EQUAL(name, method_name)) {
					RETURN_CTOR(method);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	object_init_ex(return_value, phalcon_annotations_collection_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Annotations_Adapter, getProperties){

	zval *class_name, *class_annotations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &class_name);
	
	PHALCON_CALL_METHOD(&class_annotations, this_ptr, "get", class_name);
	
	if (Z_TYPE_P(class_annotations) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(class_annotations, "getpropertiesannotations");
		RETURN_MM();
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Annotations_Adapter, getProperty){

	zval *class_name, *property_name, *class_annotations = NULL;
	zval *properties = NULL, *property = NULL, *name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &class_name, &property_name);
	
	PHALCON_CALL_METHOD(&class_annotations, this_ptr, "get", class_name);
	
	if (Z_TYPE_P(class_annotations) == IS_OBJECT) {
	
		PHALCON_CALL_METHOD(&properties, class_annotations, "getpropertiesannotations");
		if (Z_TYPE_P(properties) == IS_ARRAY) { 
	
			phalcon_is_iterable(properties, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(name, ah0, hp0);
				PHALCON_GET_HVALUE(property);
	
				if (PHALCON_IS_EQUAL(name, property_name)) {
					RETURN_CTOR(property);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	object_init_ex(return_value, phalcon_annotations_collection_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct");
	
	RETURN_MM();
}





zend_class_entry *phalcon_annotations_adapterinterface_ce;

static const zend_function_entry phalcon_annotations_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, read, arginfo_phalcon_annotations_adapterinterface_read)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, write, arginfo_phalcon_annotations_adapterinterface_write)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, setReader, arginfo_phalcon_annotations_adapterinterface_setreader)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, getReader, NULL)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, get, arginfo_phalcon_annotations_adapterinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, getMethods, arginfo_phalcon_annotations_adapterinterface_getmethods)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, getMethod, arginfo_phalcon_annotations_adapterinterface_getmethod)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, getProperties, arginfo_phalcon_annotations_adapterinterface_getproperties)
	PHP_ABSTRACT_ME(Phalcon_Annotations_AdapterInterface, getProperty, arginfo_phalcon_annotations_adapterinterface_getproperty)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Annotations_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Annotations, AdapterInterface, annotations_adapterinterface, phalcon_annotations_adapterinterface_method_entry);

	return SUCCESS;
}

















zend_class_entry *phalcon_annotations_annotation_ce;

static PHP_METHOD(Phalcon_Annotations_Annotation, __construct);
static PHP_METHOD(Phalcon_Annotations_Annotation, getName);
static PHP_METHOD(Phalcon_Annotations_Annotation, getExpression);
static PHP_METHOD(Phalcon_Annotations_Annotation, getExprArguments);
static PHP_METHOD(Phalcon_Annotations_Annotation, getArguments);
static PHP_METHOD(Phalcon_Annotations_Annotation, numberArguments);
static PHP_METHOD(Phalcon_Annotations_Annotation, getArgument);
static PHP_METHOD(Phalcon_Annotations_Annotation, hasArgument);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_annotation___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, reflectionData)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_annotation_getexpression, 0, 0, 1)
	ZEND_ARG_INFO(0, expr)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_annotation_getargument, 0, 0, 1)
	ZEND_ARG_INFO(0, position)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_annotation_hasargument, 0, 0, 1)
	ZEND_ARG_INFO(0, position)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_annotation_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Annotation, __construct, arginfo_phalcon_annotations_annotation___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Annotations_Annotation, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, getExpression, arginfo_phalcon_annotations_annotation_getexpression, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, getExprArguments, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, getArguments, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, numberArguments, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, getArgument, arginfo_phalcon_annotations_annotation_getargument, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Annotation, hasArgument, arginfo_phalcon_annotations_annotation_hasargument, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Annotations_Annotation, getNamedArgument, getArgument, arginfo_phalcon_annotations_annotation_getargument, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Annotations_Annotation, getNamedParameter, getArgument, arginfo_phalcon_annotations_annotation_getargument, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_MALIAS(Phalcon_Annotations_Annotation, hasNamedArgument, hasArgument, arginfo_phalcon_annotations_annotation_hasargument, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Annotations_Annotation){

	PHALCON_REGISTER_CLASS(Phalcon\\Annotations, Annotation, annotations_annotation, phalcon_annotations_annotation_method_entry, 0);

	zend_declare_property_null(phalcon_annotations_annotation_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_annotation_ce, SL("_arguments"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_annotation_ce, SL("_exprArguments"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Annotation, __construct){

	zval *reflection_data, *name = NULL, *arguments, *expr_arguments;
	zval *argument = NULL, *expr = NULL, *resolved_argument = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &reflection_data);
	
	if (Z_TYPE_P(reflection_data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_annotations_exception_ce, "Reflection data must be an array");
		return;
	}
	
	PHALCON_OBS_VAR(name);
	phalcon_array_fetch_quick_string(&name, reflection_data, SS("name"), 268211462UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	
	if (phalcon_array_isset_string_fetch(&expr_arguments, reflection_data, SS("arguments"))) {
	
		phalcon_is_iterable(expr_arguments, &ah0, &hp0, 0, 0);
	
		PHALCON_INIT_VAR(arguments);
		array_init_size(arguments, zend_hash_num_elements(ah0));

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			zval *n;

			PHALCON_GET_HVALUE(argument);
	
			PHALCON_OBS_NVAR(expr);
			phalcon_array_fetch_quick_string(&expr, argument, SS("expr"), 258368420UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&resolved_argument, this_ptr, "getexpression", expr);
			if (phalcon_array_isset_string_fetch(&n, argument, SS("name"))) {
				phalcon_array_update_zval(&arguments, n, resolved_argument, PH_COPY);
			} else {
				phalcon_array_append(&arguments, resolved_argument, 0);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_arguments"), arguments, 314247962UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_exprArguments"), expr_arguments, 3152251737UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Annotation, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Annotations_Annotation, getExpression){

	zval *expr = NULL, *type, *items, *item = NULL;
	zval *resolved_item = NULL, *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	PHALCON_SEPARATE_PARAM(expr);
	
	if (Z_TYPE_P(expr) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_annotations_exception_ce, "The expression is not valid");
		return;
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, expr, SS("type"), 276192743UL, PH_NOISY);
	
	switch (phalcon_get_intval(type)) {
	
		case PHANNOT_T_INTEGER:
		case PHANNOT_T_DOUBLE:
		case PHANNOT_T_STRING:
		case PHANNOT_T_IDENTIFIER:
			if (return_value_ptr) {
				zval_ptr_dtor(return_value_ptr);
				phalcon_array_fetch_string(return_value_ptr, expr, SL("value"), PH_NOISY);
			}
			else {
				phalcon_array_fetch_quick_string(&return_value, expr, SS("value"), 574111618UL, PH_NOISY);
			}
			RETURN_MM();
			/* no break because of implicit return */
	
		case PHANNOT_T_NULL:
			RETURN_MM_NULL();
			/* no break because of implicit return */
	
		case PHANNOT_T_FALSE:
			RETURN_MM_FALSE;
			/* no break because of implicit return */
	
		case PHANNOT_T_TRUE:
			RETURN_MM_TRUE;
			/* no break because of implicit return */
	
		case PHANNOT_T_ARRAY:
			PHALCON_OBS_VAR(items);
			phalcon_array_fetch_quick_string(&items, expr, SS("items"), 87624199UL, PH_NOISY);
	
			phalcon_is_iterable(items, &ah0, &hp0, 0, 0);
			array_init_size(return_value, zend_hash_num_elements(ah0));
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
				zval *name;
	
				PHALCON_GET_HVALUE(item);
	
				PHALCON_OBS_NVAR(expr);
				phalcon_array_fetch_quick_string(&expr, item, SS("expr"), 258368420UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&resolved_item, this_ptr, "getexpression", expr);
				if (phalcon_array_isset_string_fetch(&name, item, SS("name"))) {
					phalcon_array_update_zval(&return_value, name, resolved_item, PH_COPY);
				} else {
					phalcon_array_append(&return_value, resolved_item, 0);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			RETURN_MM();
			/* no break because of implicit return */
	
		case PHANNOT_T_ANNOTATION:
			object_init_ex(return_value, phalcon_annotations_annotation_ce);
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", expr);
			RETURN_MM();
			/* no break because of implicit return */
	
		default:
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "The expression ", type, " is unknown");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_annotations_exception_ce, exception_message);
			return;
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Annotation, getExprArguments){


	RETURN_MEMBER_QUICK(this_ptr, "_exprArguments", 3152251737UL);
}

static PHP_METHOD(Phalcon_Annotations_Annotation, getArguments){


	RETURN_MEMBER_QUICK(this_ptr, "_arguments", 314247962UL);
}

static PHP_METHOD(Phalcon_Annotations_Annotation, numberArguments){

	zval *arguments;

	arguments = phalcon_fetch_nproperty_this(this_ptr, SL("_arguments"), PH_NOISY TSRMLS_CC);
	phalcon_fast_count(return_value, arguments TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Annotations_Annotation, getArgument){

	zval *position, *arguments, *tmp;

	phalcon_fetch_params(0, 1, 0, &position);
	
	arguments = phalcon_fetch_nproperty_this(this_ptr, SL("_arguments"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&tmp, arguments, position)) {
		RETURN_ZVAL(tmp, 1, 0);
	}
}

static PHP_METHOD(Phalcon_Annotations_Annotation, hasArgument){

	zval *position, *arguments;

	phalcon_fetch_params(0, 1, 0, &position);
	
	arguments = phalcon_fetch_nproperty_this(this_ptr, SL("_arguments"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(arguments, position));
}









zend_class_entry *phalcon_annotations_collection_ce;

static PHP_METHOD(Phalcon_Annotations_Collection, __construct);
static PHP_METHOD(Phalcon_Annotations_Collection, count);
static PHP_METHOD(Phalcon_Annotations_Collection, rewind);
static PHP_METHOD(Phalcon_Annotations_Collection, current);
static PHP_METHOD(Phalcon_Annotations_Collection, key);
static PHP_METHOD(Phalcon_Annotations_Collection, next);
static PHP_METHOD(Phalcon_Annotations_Collection, valid);
static PHP_METHOD(Phalcon_Annotations_Collection, getAnnotations);
static PHP_METHOD(Phalcon_Annotations_Collection, get);
static PHP_METHOD(Phalcon_Annotations_Collection, getAll);
static PHP_METHOD(Phalcon_Annotations_Collection, has);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_collection___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, reflectionData)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_collection_get, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_collection_getall, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_collection_has, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_collection_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Collection, __construct, arginfo_phalcon_annotations_collection___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Annotations_Collection, count, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, rewind, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, current, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, key, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, next, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, valid, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, getAnnotations, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, get, arginfo_phalcon_annotations_collection_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, getAll, arginfo_phalcon_annotations_collection_getall, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Collection, has, arginfo_phalcon_annotations_collection_has, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_Collection){

	PHALCON_REGISTER_CLASS(Phalcon\\Annotations, Collection, annotations_collection, phalcon_annotations_collection_method_entry, 0);

	zend_declare_property_long(phalcon_annotations_collection_ce, SL("_position"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_collection_ce, SL("_annotations"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_annotations_collection_ce TSRMLS_CC, 2, zend_ce_iterator, spl_ce_Countable);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Collection, __construct){

	zval *reflection_data = NULL, *annotations, **annotation_data;
	zval *annotation = NULL;
	HashPosition hp0;

	phalcon_fetch_params(0, 0, 1, &reflection_data);
	
	if (!reflection_data || Z_TYPE_P(reflection_data) == IS_NULL) {
		return;
	}

	if (Z_TYPE_P(reflection_data) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_annotations_exception_ce, "Reflection data must be an array");
		return;
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(annotations);
	array_init_size(annotations, zend_hash_num_elements(Z_ARRVAL_P(reflection_data)));

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(reflection_data), &hp0);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(reflection_data), (void**)&annotation_data, &hp0) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(reflection_data), &hp0)
	) {
		PHALCON_INIT_NVAR(annotation);
		object_init_ex(annotation, phalcon_annotations_annotation_ce);
		PHALCON_CALL_METHOD(NULL, annotation, "__construct", *annotation_data);
		phalcon_array_append(&annotations, annotation, 0);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_annotations"), annotations, 1219636498UL TSRMLS_CC);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Collection, count){

	zval *annotations;

	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) == IS_ARRAY) {
		RETURN_LONG(zend_hash_num_elements(Z_ARRVAL_P(annotations)));
	}

	RETURN_LONG(0);
}

static PHP_METHOD(Phalcon_Annotations_Collection, rewind){


	phalcon_update_property_long(this_ptr, SL("_position"), 0 TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Annotations_Collection, current){

	zval *position, *annotations, *annotation;

	position    = phalcon_fetch_nproperty_this(this_ptr, SL("_position"), PH_NOISY TSRMLS_CC);
	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&annotation, annotations, position)) {
		RETURN_ZVAL(annotation, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Annotations_Collection, key){


	RETURN_MEMBER_QUICK(this_ptr, "_position", 2925265369UL);
}

static PHP_METHOD(Phalcon_Annotations_Collection, next){


	phalcon_property_incr(this_ptr, SL("_position") TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Annotations_Collection, valid){

	zval *position, *annotations;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(position);
	phalcon_read_property_this(&position, this_ptr, SL("_position"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(annotations);
	phalcon_read_property_this(&annotations, this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(annotations, position)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Annotations_Collection, getAnnotations){


	RETURN_MEMBER_QUICK(this_ptr, "_annotations", 1219636498UL);
}

static PHP_METHOD(Phalcon_Annotations_Collection, get){

	zval *name, *annotations, *annotation = NULL, *annotation_name = NULL;
	zval *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	PHALCON_OBS_VAR(annotations);
	phalcon_read_property_this(&annotations, this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) == IS_ARRAY) { 
	
		phalcon_is_iterable(annotations, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(annotation);
	
			PHALCON_CALL_METHOD(&annotation_name, annotation, "getname");
			if (PHALCON_IS_EQUAL(name, annotation_name)) {
				RETURN_CCTOR(annotation);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "The collection doesn't have an annotation called '", name, "'");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_annotations_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Annotations_Collection, getAll){

	zval *name, *found, *annotations, *annotation = NULL, *annotation_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	PHALCON_INIT_VAR(found);
	array_init(found);
	
	PHALCON_OBS_VAR(annotations);
	phalcon_read_property_this(&annotations, this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) == IS_ARRAY) { 
	
		phalcon_is_iterable(annotations, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(annotation);
	
			PHALCON_CALL_METHOD(&annotation_name, annotation, "getname");
			if (PHALCON_IS_EQUAL(name, annotation_name)) {
				phalcon_array_append(&found, annotation, 0);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_CTOR(found);
}

static PHP_METHOD(Phalcon_Annotations_Collection, has){

	zval *name, *annotations, *annotation = NULL, *annotation_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	PHALCON_OBS_VAR(annotations);
	phalcon_read_property_this(&annotations, this_ptr, SL("_annotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) == IS_ARRAY) { 
	
		phalcon_is_iterable(annotations, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(annotation);
	
			PHALCON_CALL_METHOD(&annotation_name, annotation, "getname");
			if (PHALCON_IS_EQUAL(name, annotation_name)) {
				RETURN_MM_TRUE;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_MM_FALSE;
}







zend_class_entry *phalcon_annotations_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Annotations_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Annotations, Exception, annotations_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}


/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is include which follows the "include" declaration
** in the input file. */
#include <stdio.h>
/* #line 28 "parser.y" */



#include <ext/standard/php_smart_str.h>
#include <main/spprintf.h>




static zval *phannot_ret_literal_zval(int type, phannot_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_long(ret, phalcon_interned_type, type);
	if (T) {
		add_assoc_stringl(ret, phalcon_interned_value, T->token, T->token_len, 0);
		efree(T);
	}

	return ret;
}

static zval *phannot_ret_array(zval *items)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_long(ret, phalcon_interned_type, PHANNOT_T_ARRAY);

	if (items) {
		add_assoc_zval(ret, phalcon_interned_items, items);
	}

	return ret;
}

static zval *phannot_ret_zval_list(zval *list_left, zval *right_list)
{
	zval *ret;
	HashPosition pos;
	HashTable *list;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	if (list_left) {

		list = Z_ARRVAL_P(list_left);
		if (zend_hash_index_exists(list, 0)) {
			zend_hash_internal_pointer_reset_ex(list, &pos);
			for (;; zend_hash_move_forward_ex(list, &pos)) {

				zval ** item;

				if (zend_hash_get_current_data_ex(list, (void**) &item, &pos) == FAILURE) {
					break;
				}

				Z_ADDREF_PP(item);
				add_next_index_zval(ret, *item);

			}
			zval_ptr_dtor(&list_left);
		} else {
			add_next_index_zval(ret, list_left);
		}
	}

	add_next_index_zval(ret, right_list);

	return ret;
}

static zval *phannot_ret_named_item(phannot_parser_token *name, zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_zval(ret, phalcon_interned_expr, expr);
	if (name != NULL) {
		add_assoc_stringl(ret, phalcon_interned_name, name->token, name->token_len, 0);
		efree(name);
	}

	return ret;
}

static zval *phannot_ret_annotation(phannot_parser_token *name, zval *arguments, phannot_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 5);

	add_assoc_long(ret, phalcon_interned_type, PHANNOT_T_ANNOTATION);

	if (name) {
		add_assoc_stringl(ret, phalcon_interned_name, name->token, name->token_len, 0);
		efree(name);
	}

	if (arguments) {
		add_assoc_zval(ret, phalcon_interned_arguments, arguments);
	}

	add_assoc_string(ret, phalcon_interned_file, (char*)state->active_file, !IS_INTERNED(state->active_file));
	add_assoc_long(ret, phalcon_interned_line, state->active_line);

	return ret;
}


/* #line 133 "parser.c" */
/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    JJCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    JJNOCODE           is a number of type JJCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash 
**                       table.
**    JJFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    JJACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    phannot_JTOKENTYPE     is the data type used for minor tokens given 
**                       directly to the parser from the tokenizer.
**    JJMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is phannot_JTOKENTYPE.  The entry in the union
**                       for base tokens is called "jj0".
**    JJSTACKDEPTH       is the maximum depth of the parser's stack.
**    phannot_ARG_SDECL     A static variable declaration for the %extra_argument
**    phannot_ARG_PDECL     A parameter declaration for the %extra_argument
**    phannot_ARG_STORE     Code to store %extra_argument into jjpParser
**    phannot_ARG_FETCH     Code to extract %extra_argument from jjpParser
**    JJNSTATE           the combined number of states.
**    JJNRULE            the number of rules in the grammar
**    JJERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define JJCODETYPE unsigned char
#define JJNOCODE 28
#define JJACTIONTYPE unsigned char
#define phannot_JTOKENTYPE phannot_parser_token*
typedef union {
  phannot_JTOKENTYPE jj0;
  zval* jj36;
  int jj55;
} JJMINORTYPE;
#define JJSTACKDEPTH 100
#define phannot_ARG_SDECL phannot_parser_status *status;
#define phannot_ARG_PDECL ,phannot_parser_status *status
#define phannot_ARG_FETCH phannot_parser_status *status = jjpParser->status
#define phannot_ARG_STORE jjpParser->status = status
#define JJNSTATE 40
#define JJNRULE 25
#define JJERRORSYMBOL 18
#define JJERRSYMDT jj55
#define JJ_NO_ACTION      (JJNSTATE+JJNRULE+2)
#define JJ_ACCEPT_ACTION  (JJNSTATE+JJNRULE+1)
#define JJ_ERROR_ACTION   (JJNSTATE+JJNRULE)

/* Next are that tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < JJNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   JJNSTATE <= N < JJNSTATE+JJNRULE   Reduce by rule N-JJNSTATE.
**
**   N == JJNSTATE+JJNRULE              A syntax error has occurred.
**
**   N == JJNSTATE+JJNRULE+1            The parser accepts its input.
**
**   N == JJNSTATE+JJNRULE+2            No such action.  Denotes unused
**                                      slots in the jj_action[] table.
**
** The action table is constructed as a single large table named jj_action[].
** Given state S and lookahead X, the action is computed as
**
**      jj_action[ jj_shift_ofst[S] + X ]
**
** If the index value jj_shift_ofst[S]+X is out of range or if the value
** jj_lookahead[jj_shift_ofst[S]+X] is not equal to X or if jj_shift_ofst[S]
** is equal to JJ_SHIFT_USE_DFLT, it means that the action is not in the table
** and that jj_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the jj_reduce_ofst[] array is used in place of
** the jj_shift_ofst[] array and JJ_REDUCE_USE_DFLT is used in place of
** JJ_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  jj_action[]        A single table containing all actions.
**  jj_lookahead[]     A table containing the lookahead for each entry in
**                     jj_action.  Used to detect hash collisions.
**  jj_shift_ofst[]    For each state, the offset into jj_action for
**                     shifting terminals.
**  jj_reduce_ofst[]   For each state, the offset into jj_action for
**                     shifting non-terminals after a reduce.
**  jj_default[]       Default action for each state.
*/
static JJACTIONTYPE jj_action[] = {
 /*     0 */     4,   28,   15,   38,   12,   14,   16,   18,   20,   21,
 /*    10 */    22,   23,   24,    4,   31,    4,   28,   15,   40,   12,
 /*    20 */    30,   16,   18,   20,   21,   22,   23,   24,    3,   31,
 /*    30 */     4,   17,   15,    6,   19,   35,   16,   18,   20,   21,
 /*    40 */    22,   23,   24,    5,   31,   15,    7,   27,   11,   16,
 /*    50 */    54,   54,   15,   25,   27,   11,   16,   15,   32,   27,
 /*    60 */    11,   16,   66,    1,    2,   39,   41,   15,    4,   10,
 /*    70 */    11,   16,   15,    9,    9,   37,   16,    8,   13,   36,
 /*    80 */     9,   29,   34,   54,   54,   54,   54,   54,   26,   54,
 /*    90 */    54,   54,   54,   54,   54,   54,   33,
};
static JJCODETYPE jj_lookahead[] = {
 /*     0 */     2,    3,   22,    5,    6,   25,   26,    9,   10,   11,
 /*    10 */    12,   13,   14,    2,   16,    2,    3,   22,    0,    6,
 /*    20 */    25,   26,    9,   10,   11,   12,   13,   14,   22,   16,
 /*    30 */     2,    3,   22,    4,    6,   25,   26,    9,   10,   11,
 /*    40 */    12,   13,   14,    3,   16,   22,   23,   24,   25,   26,
 /*    50 */    27,   27,   22,   23,   24,   25,   26,   22,   23,   24,
 /*    60 */    25,   26,   19,   20,   21,   22,    0,   22,    2,   24,
 /*    70 */    25,   26,   22,    1,    1,   25,   26,    5,    7,    8,
 /*    80 */     1,    7,    8,   27,   27,   27,   27,   27,   15,   27,
 /*    90 */    27,   27,   27,   27,   27,   27,   17,
};
#define JJ_SHIFT_USE_DFLT (-3)
static signed char jj_shift_ofst[] = {
 /*     0 */    11,   18,   66,   -3,   40,   29,   -2,   72,   -3,   13,
 /*    10 */    -3,   -3,   71,   28,   -3,   -3,   -3,   -3,   -3,   -3,
 /*    20 */    -3,   -3,   -3,   -3,   13,   73,   -3,   -3,   74,   28,
 /*    30 */    -3,   13,   79,   -3,   28,   -3,   28,   -3,   -3,   -3,
};
#define JJ_REDUCE_USE_DFLT (-21)
static signed char jj_reduce_ofst[] = {
 /*     0 */    43,  -21,    6,  -21,  -21,  -21,   23,  -21,  -21,   45,
 /*    10 */   -21,  -21,  -21,  -20,  -21,  -21,  -21,  -21,  -21,  -21,
 /*    20 */   -21,  -21,  -21,  -21,   30,  -21,  -21,  -21,  -21,   -5,
 /*    30 */   -21,   35,  -21,  -21,   10,  -21,   50,  -21,  -21,  -21,
};
static JJACTIONTYPE jj_default[] = {
 /*     0 */    65,   65,   65,   42,   65,   46,   65,   65,   44,   65,
 /*    10 */    47,   49,   58,   65,   50,   54,   55,   56,   57,   58,
 /*    20 */    59,   60,   61,   62,   65,   65,   63,   48,   56,   65,
 /*    30 */    52,   65,   65,   64,   65,   53,   65,   51,   45,   43,
};
#define JJ_SZ_ACTTAB (sizeof(jj_action)/sizeof(jj_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammer, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef JJFALLBACK
static const JJCODETYPE jjFallback[] = {
};
#endif /* JJFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct jjStackEntry {
  int stateno;       /* The state-number */
  int major;         /* The major token value.  This is the code
                     ** number for the token at this stack level */
  JJMINORTYPE minor; /* The user-supplied minor token value.  This
                     ** is the value of the token  */
};
typedef struct jjStackEntry jjStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct jjParser {
  int jjidx;                    /* Index of top element in stack */
  int jjerrcnt;                 /* Shifts left before out of the error */
  phannot_ARG_SDECL                /* A place to hold %extra_argument */
  jjStackEntry jjstack[JJSTACKDEPTH];  /* The parser's stack */
};
typedef struct jjParser jjParser;

#ifndef NDEBUG
#include <stdio.h>
static FILE *jjTraceFILE = 0;
static char *jjTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
static void phannot_Trace(FILE *TraceFILE, char *zTracePrompt){
  jjTraceFILE = TraceFILE;
  jjTracePrompt = zTracePrompt;
  if( jjTraceFILE==0 ) jjTracePrompt = 0;
  else if( jjTracePrompt==0 ) jjTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *jjTokenName[] = { 
  "$",             "COMMA",         "AT",            "IDENTIFIER",  
  "PARENTHESES_OPEN",  "PARENTHESES_CLOSE",  "STRING",        "EQUALS",      
  "COLON",         "INTEGER",       "DOUBLE",        "NULL",        
  "FALSE",         "TRUE",          "BRACKET_OPEN",  "BRACKET_CLOSE",
  "SBRACKET_OPEN",  "SBRACKET_CLOSE",  "error",         "program",     
  "annotation_language",  "annotation_list",  "annotation",    "argument_list",
  "argument_item",  "expr",          "array",       
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *jjRuleName[] = {
 /*   0 */ "program ::= annotation_language",
 /*   1 */ "annotation_language ::= annotation_list",
 /*   2 */ "annotation_list ::= annotation_list annotation",
 /*   3 */ "annotation_list ::= annotation",
 /*   4 */ "annotation ::= AT IDENTIFIER PARENTHESES_OPEN argument_list PARENTHESES_CLOSE",
 /*   5 */ "annotation ::= AT IDENTIFIER PARENTHESES_OPEN PARENTHESES_CLOSE",
 /*   6 */ "annotation ::= AT IDENTIFIER",
 /*   7 */ "argument_list ::= argument_list COMMA argument_item",
 /*   8 */ "argument_list ::= argument_item",
 /*   9 */ "argument_item ::= expr",
 /*  10 */ "argument_item ::= STRING EQUALS expr",
 /*  11 */ "argument_item ::= STRING COLON expr",
 /*  12 */ "argument_item ::= IDENTIFIER EQUALS expr",
 /*  13 */ "argument_item ::= IDENTIFIER COLON expr",
 /*  14 */ "expr ::= annotation",
 /*  15 */ "expr ::= array",
 /*  16 */ "expr ::= IDENTIFIER",
 /*  17 */ "expr ::= INTEGER",
 /*  18 */ "expr ::= STRING",
 /*  19 */ "expr ::= DOUBLE",
 /*  20 */ "expr ::= NULL",
 /*  21 */ "expr ::= FALSE",
 /*  22 */ "expr ::= TRUE",
 /*  23 */ "array ::= BRACKET_OPEN argument_list BRACKET_CLOSE",
 /*  24 */ "array ::= SBRACKET_OPEN argument_list SBRACKET_CLOSE",
};
#endif /* NDEBUG */

const char *phannot_TokenName(int tokenType){
#ifndef NDEBUG
  if( tokenType>0 && (size_t)tokenType<(sizeof(jjTokenName)/sizeof(jjTokenName[0])) ){
    return jjTokenName[tokenType];
  }else{
    return "Unknown";
  }
#else
  return "";
#endif
}

void *phannot_Alloc(void *(*mallocProc)(size_t)){
  jjParser *pParser;
  pParser = (jjParser*)(*mallocProc)( (size_t)sizeof(jjParser) );
  if( pParser ){
    pParser->jjidx = -1;
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "jjmajor" is the symbol code, and "jjpminor" is a pointer to
** the value.
*/
static void jj_destructor(JJCODETYPE jjmajor, JJMINORTYPE *jjpminor){
  switch( jjmajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
/* #line 198 "parser.y" */
{
	if ((jjpminor->jj0)) {
		if ((jjpminor->jj0)->free_flag) {
			efree((jjpminor->jj0)->token);
		}
		efree((jjpminor->jj0));
	}
}
/* #line 501 "parser.c" */
      break;
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
/* #line 211 "parser.y" */
{ zval_ptr_dtor(&(jjpminor->jj36)); }
/* #line 511 "parser.c" */
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

static int jj_pop_parser_stack(jjParser *pParser){
  JJCODETYPE jjmajor;
  jjStackEntry *jjtos = &pParser->jjstack[pParser->jjidx];

  if( pParser->jjidx<0 ) return 0;
#ifndef NDEBUG
  if( jjTraceFILE && pParser->jjidx>=0 ){
    fprintf(jjTraceFILE,"%sPopping %s\n",
      jjTracePrompt,
      jjTokenName[jjtos->major]);
  }
#endif
  jjmajor = jjtos->major;
  jj_destructor( jjmajor, &jjtos->minor);
  pParser->jjidx--;
  return jjmajor;
}

static void phannot_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  jjParser *pParser = (jjParser*)p;
  if( pParser==0 ) return;
  while( pParser->jjidx>=0 ) jj_pop_parser_stack(pParser);
  (*freeProc)((void*)pParser);
}

static int jj_find_shift_action(
  jjParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->jjstack[pParser->jjidx].stateno;
 
  /* if( pParser->jjidx<0 ) return JJ_NO_ACTION;  */
  i = jj_shift_ofst[stateno];
  if( i==JJ_SHIFT_USE_DFLT ){
    return jj_default[stateno];
  }
  if( iLookAhead==JJNOCODE ){
    return JJ_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)JJ_SZ_ACTTAB || jj_lookahead[i]!=iLookAhead ){
#ifdef JJFALLBACK
    int iFallback;            /* Fallback token */
    if( iLookAhead<sizeof(jjFallback)/sizeof(jjFallback[0])
           && (iFallback = jjFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
      if( jjTraceFILE ){
        fprintf(jjTraceFILE, "%sFALLBACK %s => %s\n",
           jjTracePrompt, jjTokenName[iLookAhead], jjTokenName[iFallback]);
      }
#endif
      return jj_find_shift_action(pParser, iFallback);
    }
#endif
    return jj_default[stateno];
  }else{
    return jj_action[i];
  }
}

static int jj_find_reduce_action(
  jjParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->jjstack[pParser->jjidx].stateno;
 
  i = jj_reduce_ofst[stateno];
  if( i==JJ_REDUCE_USE_DFLT ){
    return jj_default[stateno];
  }
  if( iLookAhead==JJNOCODE ){
    return JJ_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)JJ_SZ_ACTTAB || jj_lookahead[i]!=iLookAhead ){
    return jj_default[stateno];
  }else{
    return jj_action[i];
  }
}

static void jj_shift(
  jjParser *jjpParser,          /* The parser to be shifted */
  int jjNewState,               /* The new state to shift in */
  int jjMajor,                  /* The major token to shift in */
  JJMINORTYPE *jjpMinor         /* Pointer ot the minor token to shift in */
){
  jjStackEntry *jjtos;
  jjpParser->jjidx++;
  if( jjpParser->jjidx>=JJSTACKDEPTH ){
     phannot_ARG_FETCH;
     jjpParser->jjidx--;
#ifndef NDEBUG
     if( jjTraceFILE ){
       fprintf(jjTraceFILE,"%sStack Overflow!\n",jjTracePrompt);
     }
#endif
     while( jjpParser->jjidx>=0 ) jj_pop_parser_stack(jjpParser);
     /* Here code is inserted which will execute if the parser
     ** stack every overflows */
     phannot_ARG_STORE; /* Suppress warning about unused %extra_argument var */
     return;
  }
  jjtos = &jjpParser->jjstack[jjpParser->jjidx];
  jjtos->stateno = jjNewState;
  jjtos->major = jjMajor;
  jjtos->minor = *jjpMinor;
#ifndef NDEBUG
  if( jjTraceFILE && jjpParser->jjidx>0 ){
    int i;
    fprintf(jjTraceFILE,"%sShift %d\n",jjTracePrompt,jjNewState);
    fprintf(jjTraceFILE,"%sStack:",jjTracePrompt);
    for(i=1; i<=jjpParser->jjidx; i++)
      fprintf(jjTraceFILE," %s",jjTokenName[jjpParser->jjstack[i].major]);
    fprintf(jjTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static struct {
  JJCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} jjRuleInfo[] = {
  { 19, 1 },
  { 20, 1 },
  { 21, 2 },
  { 21, 1 },
  { 22, 5 },
  { 22, 4 },
  { 22, 2 },
  { 23, 3 },
  { 23, 1 },
  { 24, 1 },
  { 24, 3 },
  { 24, 3 },
  { 24, 3 },
  { 24, 3 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 25, 1 },
  { 26, 3 },
  { 26, 3 },
};

static void jj_accept(jjParser*);  /* Forward Declaration */

static void jj_reduce(
  jjParser *jjpParser,         /* The parser */
  int jjruleno                 /* Number of the rule by which to reduce */
){
  int jjgoto;                     /* The next state */
  int jjact;                      /* The next action */
  JJMINORTYPE jjgotominor;        /* The LHS of the rule reduced */
  jjStackEntry *jjmsp;            /* The top of the parser's stack */
  int jjsize;                     /* Amount to pop the stack */
  phannot_ARG_FETCH;
  jjmsp = &jjpParser->jjstack[jjpParser->jjidx];
#ifndef NDEBUG
  if( jjTraceFILE && jjruleno>=0 
        && jjruleno<(int)(sizeof(jjRuleName)/sizeof(jjRuleName[0])) ){
    fprintf(jjTraceFILE, "%sReduce [%s].\n", jjTracePrompt,
      jjRuleName[jjruleno]);
  }
#endif /* NDEBUG */

  switch( jjruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
      case 0:
/* #line 207 "parser.y" */
{
	status->ret = jjmsp[0].minor.jj36;
}
/* #line 753 "parser.c" */
        break;
      case 1:
      case 14:
      case 15:
/* #line 213 "parser.y" */
{
	jjgotominor.jj36 = jjmsp[0].minor.jj36;
}
/* #line 762 "parser.c" */
        break;
      case 2:
/* #line 219 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_zval_list(jjmsp[-1].minor.jj36, jjmsp[0].minor.jj36);
}
/* #line 769 "parser.c" */
        break;
      case 3:
      case 8:
/* #line 223 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_zval_list(NULL, jjmsp[0].minor.jj36);
}
/* #line 777 "parser.c" */
        break;
      case 4:
/* #line 230 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_annotation(jjmsp[-3].minor.jj0, jjmsp[-1].minor.jj36, status->scanner_state);
  jj_destructor(2,&jjmsp[-4].minor);
  jj_destructor(4,&jjmsp[-2].minor);
  jj_destructor(5,&jjmsp[0].minor);
}
/* #line 787 "parser.c" */
        break;
      case 5:
/* #line 234 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_annotation(jjmsp[-2].minor.jj0, NULL, status->scanner_state);
  jj_destructor(2,&jjmsp[-3].minor);
  jj_destructor(4,&jjmsp[-1].minor);
  jj_destructor(5,&jjmsp[0].minor);
}
/* #line 797 "parser.c" */
        break;
      case 6:
/* #line 238 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_annotation(jjmsp[0].minor.jj0, NULL, status->scanner_state);
  jj_destructor(2,&jjmsp[-1].minor);
}
/* #line 805 "parser.c" */
        break;
      case 7:
/* #line 244 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_zval_list(jjmsp[-2].minor.jj36, jjmsp[0].minor.jj36);
  jj_destructor(1,&jjmsp[-1].minor);
}
/* #line 813 "parser.c" */
        break;
      case 9:
/* #line 254 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_named_item(NULL, jjmsp[0].minor.jj36);
}
/* #line 820 "parser.c" */
        break;
      case 10:
      case 12:
/* #line 258 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_named_item(jjmsp[-2].minor.jj0, jjmsp[0].minor.jj36);
  jj_destructor(7,&jjmsp[-1].minor);
}
/* #line 829 "parser.c" */
        break;
      case 11:
      case 13:
/* #line 262 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_named_item(jjmsp[-2].minor.jj0, jjmsp[0].minor.jj36);
  jj_destructor(8,&jjmsp[-1].minor);
}
/* #line 838 "parser.c" */
        break;
      case 16:
/* #line 284 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_IDENTIFIER, jjmsp[0].minor.jj0);
}
/* #line 845 "parser.c" */
        break;
      case 17:
/* #line 288 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_INTEGER, jjmsp[0].minor.jj0);
}
/* #line 852 "parser.c" */
        break;
      case 18:
/* #line 292 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_STRING, jjmsp[0].minor.jj0);
}
/* #line 859 "parser.c" */
        break;
      case 19:
/* #line 296 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_DOUBLE, jjmsp[0].minor.jj0);
}
/* #line 866 "parser.c" */
        break;
      case 20:
/* #line 300 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_NULL, NULL);
  jj_destructor(11,&jjmsp[0].minor);
}
/* #line 874 "parser.c" */
        break;
      case 21:
/* #line 304 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_FALSE, NULL);
  jj_destructor(12,&jjmsp[0].minor);
}
/* #line 882 "parser.c" */
        break;
      case 22:
/* #line 308 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_literal_zval(PHANNOT_T_TRUE, NULL);
  jj_destructor(13,&jjmsp[0].minor);
}
/* #line 890 "parser.c" */
        break;
      case 23:
/* #line 312 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_array(jjmsp[-1].minor.jj36);
  jj_destructor(14,&jjmsp[-2].minor);
  jj_destructor(15,&jjmsp[0].minor);
}
/* #line 899 "parser.c" */
        break;
      case 24:
/* #line 316 "parser.y" */
{
	jjgotominor.jj36 = phannot_ret_array(jjmsp[-1].minor.jj36);
  jj_destructor(16,&jjmsp[-2].minor);
  jj_destructor(17,&jjmsp[0].minor);
}
/* #line 908 "parser.c" */
        break;
  };
  jjgoto = jjRuleInfo[jjruleno].lhs;
  jjsize = jjRuleInfo[jjruleno].nrhs;
  jjpParser->jjidx -= jjsize;
  jjact = jj_find_reduce_action(jjpParser,jjgoto);
  if( jjact < JJNSTATE ){
    jj_shift(jjpParser,jjact,jjgoto,&jjgotominor);
  }else if( jjact == JJNSTATE + JJNRULE + 1 ){
    jj_accept(jjpParser);
  }
}

static void jj_parse_failed(
  jjParser *jjpParser           /* The parser */
){
  phannot_ARG_FETCH;
#ifndef NDEBUG
  if( jjTraceFILE ){
    fprintf(jjTraceFILE,"%sFail!\n",jjTracePrompt);
  }
#endif
  while( jjpParser->jjidx>=0 ) jj_pop_parser_stack(jjpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
  phannot_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void jj_syntax_error(
  jjParser *jjpParser,           /* The parser */
  int jjmajor,                   /* The major type of the error token */
  JJMINORTYPE jjminor            /* The minor type of the error token */
){
  phannot_ARG_FETCH;
#define JTOKEN (jjminor.jj0)
/* #line 153 "parser.y" */

	if (status->scanner_state->start_length) {
		char *token_name = NULL;
		const phannot_token_names *tokens = phannot_tokens;
		uint active_token = status->scanner_state->active_token;
		uint near_length = status->scanner_state->start_length;

		if (active_token) {
			do {
				if (tokens->code == active_token) {
					token_name = tokens->name;
					break;
				}
				++tokens;
			} while (tokens[0].code != 0);
		}

		if (!token_name) {
			token_name  = "UNKNOWN";
		}

		if (near_length > 0) {
			if (status->token->value) {
				spprintf(&status->syntax_error, 0, "Syntax error, unexpected token %s(%s), near to '%s' in %s on line %d", token_name, status->token->value, status->scanner_state->start, status->scanner_state->active_file, status->scanner_state->active_line);
			} else {
				spprintf(&status->syntax_error, 0, "Syntax error, unexpected token %s, near to '%s' in %s on line %d", token_name, status->scanner_state->start, status->scanner_state->active_file, status->scanner_state->active_line);
			}
		} else {
			if (active_token != PHANNOT_T_IGNORE) {
				if (status->token->value) {
					spprintf(&status->syntax_error, 0, "Syntax error, unexpected token %s(%s), at the end of docblock in %s on line %d", token_name, status->token->value, status->scanner_state->active_file, status->scanner_state->active_line);
				} else {
					spprintf(&status->syntax_error, 0, "Syntax error, unexpected token %s, at the end of docblock in %s on line %d", token_name, status->scanner_state->active_file, status->scanner_state->active_line);
				}
			} else {
				spprintf(&status->syntax_error, 0, "Syntax error, unexpected EOF, at the end of docblock in %s on line %d", status->scanner_state->active_file, status->scanner_state->active_line);
			}
		}
	} else {
		spprintf(&status->syntax_error, 0, "Syntax error, unexpected EOF in %s", status->scanner_state->active_file);
	}

	status->status = PHANNOT_PARSING_FAILED;

/* #line 995 "parser.c" */
  phannot_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void jj_accept(
  jjParser *jjpParser           /* The parser */
){
  phannot_ARG_FETCH;
#ifndef NDEBUG
  if( jjTraceFILE ){
    fprintf(jjTraceFILE,"%sAccept!\n",jjTracePrompt);
  }
#endif
  while( jjpParser->jjidx>=0 ) jj_pop_parser_stack(jjpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  phannot_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "phannot_Alloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
static void phannot_(
  void *jjp,                   /* The parser */
  int jjmajor,                 /* The major token code number */
  phannot_JTOKENTYPE jjminor       /* The value for the token */
  phannot_ARG_PDECL               /* Optional %extra_argument parameter */
){
  JJMINORTYPE jjminorunion;
  int jjact;            /* The parser action. */
  int jjendofinput;     /* True if we are at the end of input */
  int jjerrorhit = 0;   /* True if jjmajor has invoked an error */
  jjParser *jjpParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  jjpParser = (jjParser*)jjp;
  if( jjpParser->jjidx<0 ){
    if( jjmajor==0 ) return;
    jjpParser->jjidx = 0;
    jjpParser->jjerrcnt = -1;
    jjpParser->jjstack[0].stateno = 0;
    jjpParser->jjstack[0].major = 0;
  }
  jjminorunion.jj0 = jjminor;
  jjendofinput = (jjmajor==0);
  phannot_ARG_STORE;

#ifndef NDEBUG
  if( jjTraceFILE ){
    fprintf(jjTraceFILE,"%sInput %s\n",jjTracePrompt,jjTokenName[jjmajor]);
  }
#endif

  do{
    jjact = jj_find_shift_action(jjpParser,jjmajor);
    if( jjact<JJNSTATE ){
      jj_shift(jjpParser,jjact,jjmajor,&jjminorunion);
      jjpParser->jjerrcnt--;
      if( jjendofinput && jjpParser->jjidx>=0 ){
        jjmajor = 0;
      }else{
        jjmajor = JJNOCODE;
      }
    }else if( jjact < JJNSTATE + JJNRULE ){
      jj_reduce(jjpParser,jjact-JJNSTATE);
    }else if( jjact == JJ_ERROR_ACTION ){
      int jjmx;
#ifndef NDEBUG
      if( jjTraceFILE ){
        fprintf(jjTraceFILE,"%sSyntax Error!\n",jjTracePrompt);
      }
#endif
#ifdef JJERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( jjpParser->jjerrcnt<0 ){
        jj_syntax_error(jjpParser,jjmajor,jjminorunion);
      }
      jjmx = jjpParser->jjstack[jjpParser->jjidx].major;
      if( jjmx==JJERRORSYMBOL || jjerrorhit ){
#ifndef NDEBUG
        if( jjTraceFILE ){
          fprintf(jjTraceFILE,"%sDiscard input token %s\n",
             jjTracePrompt,jjTokenName[jjmajor]);
        }
#endif
        jj_destructor(jjmajor,&jjminorunion);
        jjmajor = JJNOCODE;
      }else{
         while(
          jjpParser->jjidx >= 0 &&
          jjmx != JJERRORSYMBOL &&
          (jjact = jj_find_shift_action(jjpParser,JJERRORSYMBOL)) >= JJNSTATE
        ){
          jj_pop_parser_stack(jjpParser);
        }
        if( jjpParser->jjidx < 0 || jjmajor==0 ){
          jj_destructor(jjmajor,&jjminorunion);
          jj_parse_failed(jjpParser);
          jjmajor = JJNOCODE;
        }else if( jjmx!=JJERRORSYMBOL ){
          JJMINORTYPE u2;
          u2.JJERRSYMDT = 0;
          jj_shift(jjpParser,jjact,JJERRORSYMBOL,&u2);
        }
      }
      jjpParser->jjerrcnt = 3;
      jjerrorhit = 1;
#else  /* JJERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( jjpParser->jjerrcnt<=0 ){
        jj_syntax_error(jjpParser,jjmajor,jjminorunion);
      }
      jjpParser->jjerrcnt = 3;
      jj_destructor(jjmajor,&jjminorunion);
      if( jjendofinput ){
        jj_parse_failed(jjpParser);
      }
      jjmajor = JJNOCODE;
#endif
    }else{
      jj_accept(jjpParser);
      jjmajor = JJNOCODE;
    }
  }while( jjmajor!=JJNOCODE && jjpParser->jjidx>=0 );
  return;
}


#ifndef PHP_PHALCON_H
#endif

const phannot_token_names phannot_tokens[] =
{
	{ "INTEGER",        PHANNOT_T_INTEGER },
	{ "DOUBLE",         PHANNOT_T_DOUBLE },
	{ "STRING",         PHANNOT_T_STRING },
	{ "IDENTIFIER",     PHANNOT_T_IDENTIFIER },
	{ "@",              PHANNOT_T_AT },
	{ ",",              PHANNOT_T_COMMA },
	{ "=",              PHANNOT_T_EQUALS },
	{ ":",              PHANNOT_T_COLON },
	{ "(",              PHANNOT_T_PARENTHESES_OPEN },
	{ ")",              PHANNOT_T_PARENTHESES_CLOSE },
	{ "{",              PHANNOT_T_BRACKET_OPEN },
	{ "}",              PHANNOT_T_BRACKET_CLOSE },
 	{ "[",              PHANNOT_T_SBRACKET_OPEN },
	{ "]",              PHANNOT_T_SBRACKET_CLOSE },
	{ "ARBITRARY TEXT", PHANNOT_T_ARBITRARY_TEXT },
	{ NULL, 0 }
};

static void *phannot_wrapper_alloc(size_t bytes){
	return emalloc(bytes);
}

static void phannot_wrapper_free(void *pointer){
	efree(pointer);
}

static void phannot_parse_with_token(void* phannot_parser, int opcode, int parsercode, phannot_scanner_token *token, phannot_parser_status *parser_status){

	phannot_parser_token *pToken;

	pToken = emalloc(sizeof(phannot_parser_token));
	pToken->opcode = opcode;
	pToken->token = token->value;
	pToken->token_len = token->len;
	pToken->free_flag = 1;

	phannot_(phannot_parser, parsercode, pToken, parser_status);

	token->value = NULL;
	token->len = 0;
}

static void phannot_scanner_error_msg(phannot_parser_status *parser_status, char **error_msg TSRMLS_DC){

	phannot_scanner_state *state = parser_status->scanner_state;

	if (state->start) {
		if (state->start_length > 16) {
			spprintf(error_msg, 0, "Scanning error before '%.16s...' in %s on line %d", state->start, state->active_file, state->active_line);
		} else {
			spprintf(error_msg, 0, "Scanning error before '%s' in %s on line %d", state->start, state->active_file, state->active_line);
		}
	} else {
		spprintf(error_msg, 0, "Scanning error near to EOF in %s", state->active_file);
	}
}

static int phannot_parse_annotations(zval *result, const char *comment, zend_uint comment_len, const char *file_path, zend_uint line TSRMLS_DC){

	char *error_msg = NULL;

	ZVAL_NULL(result);

	if (phannot_internal_parse_annotations(&result, comment, comment_len, file_path, line, &error_msg TSRMLS_CC) == FAILURE) {
		if (likely(error_msg != NULL)) {
			zend_throw_exception_ex(phalcon_annotations_exception_ce, 0 TSRMLS_CC, "%s", error_msg);
			efree(error_msg);
		}
		else {
			zend_throw_exception_ex(phalcon_annotations_exception_ce, 0 TSRMLS_CC, "Error parsing annotation");
		}

		return FAILURE;
	}

	return SUCCESS;
}

static void phannot_remove_comment_separators(char **ret, zend_uint *ret_len, const char *comment, zend_uint length, zend_uint *start_lines)
{
	int start_mode = 1, open_parentheses;
	zend_uint i, j;
	smart_str processed_str = {0};
	char ch;

	(*start_lines) = 0;

	for (i = 0; i < length; i++) {

		ch = comment[i];

		if (start_mode) {
			if (ch == ' ' || ch == '*' || ch == '/' || ch == '\t' || ch == 11) {
				continue;
			}
			start_mode = 0;
		}

		if (ch == '@') {

			smart_str_appendc(&processed_str, ch);
			i++;

			open_parentheses = 0;
			for (j = i; j < length; j++) {

				ch = comment[j];

				if (start_mode) {
					if (ch == ' ' || ch == '*' || ch == '/' || ch == '\t' || ch == 11) {
						continue;
					}
					start_mode = 0;
				}

				if (open_parentheses == 0) {

					if (isalnum(ch) || '_' == ch || '\\' == ch) {
						smart_str_appendc(&processed_str, ch);
						continue;
					}

					if (ch == '(') {
						smart_str_appendc(&processed_str, ch);
						open_parentheses++;
						continue;
					}

				} else {

					smart_str_appendc(&processed_str, ch);

					if (ch == '(') {
						open_parentheses++;
					} else if (ch == ')') {
						open_parentheses--;
					} else if (ch == '\n') {
						(*start_lines)++;
						start_mode = 1;
					}

					if (open_parentheses > 0) {
						continue;
					}
				}

				i = j;
				smart_str_appendc(&processed_str, ' ');
				break;
			}
		}

		if (ch == '\n') {
			(*start_lines)++;
			start_mode = 1;
		}
	}

	smart_str_0(&processed_str);

	if (processed_str.len) {
		*ret     = processed_str.c;
		*ret_len = processed_str.len;
	} else {
		*ret     = NULL;
		*ret_len = 0;
	}
}

static int phannot_internal_parse_annotations(zval **result, const char *comment, zend_uint comment_len, const char *file_path, zend_uint line, char **error_msg TSRMLS_DC)
{
	phannot_scanner_state *state;
	phannot_scanner_token token;
	zend_uint start_lines;
	int scanner_status, status = SUCCESS;
	phannot_parser_status *parser_status = NULL;
	void* phannot_parser;
	char *processed_comment;
	zend_uint processed_comment_len;

	*error_msg = NULL;

	if (UNEXPECTED(!comment)) {
		ZVAL_BOOL(*result, 0);
		spprintf(error_msg, 0, "Empty annotation");
		return FAILURE;
	}

	if (comment_len < 2) {
		ZVAL_BOOL(*result, 0);
		return SUCCESS;
	}

	phannot_remove_comment_separators(&processed_comment, &processed_comment_len, comment, comment_len, &start_lines);

	if (processed_comment_len < 2) {
		ZVAL_BOOL(*result, 0);
		if (processed_comment) {
			efree(processed_comment);
		}

		return SUCCESS;
	}

	phannot_parser = phannot_Alloc(phannot_wrapper_alloc);
	if (unlikely(!phannot_parser)) {
		ZVAL_BOOL(*result, 0);
		return FAILURE;
	}

	parser_status = emalloc(sizeof(phannot_parser_status) + sizeof(phannot_scanner_state));
	state         = (phannot_scanner_state*)((char*)parser_status + sizeof(phannot_parser_status));

	parser_status->status = PHANNOT_PARSING_OK;
	parser_status->scanner_state = state;
	parser_status->ret = NULL;
	parser_status->token = &token;
	parser_status->syntax_error = NULL;

	state->active_token = 0;
	state->start = processed_comment;
	state->start_length = 0;
	state->mode = PHANNOT_MODE_RAW;
	state->active_file = file_path;

	token.value = NULL;
	token.len = 0;

	if (line) {
		state->active_line = line - start_lines;
	} else {
		state->active_line = 1;
	}

	state->end = state->start;

	while(0 <= (scanner_status = phannot_get_token(state, &token))) {

		state->active_token = token.opcode;

		state->start_length = processed_comment + processed_comment_len - state->start;

		switch (token.opcode) {

			case PHANNOT_T_IGNORE:
				break;

			case PHANNOT_T_AT:
				phannot_(phannot_parser, PHANNOT_AT, NULL, parser_status);
				break;
			case PHANNOT_T_COMMA:
				phannot_(phannot_parser, PHANNOT_COMMA, NULL, parser_status);
				break;
			case PHANNOT_T_EQUALS:
				phannot_(phannot_parser, PHANNOT_EQUALS, NULL, parser_status);
				break;
			case PHANNOT_T_COLON:
				phannot_(phannot_parser, PHANNOT_COLON, NULL, parser_status);
				break;

			case PHANNOT_T_PARENTHESES_OPEN:
				phannot_(phannot_parser, PHANNOT_PARENTHESES_OPEN, NULL, parser_status);
				break;
			case PHANNOT_T_PARENTHESES_CLOSE:
				phannot_(phannot_parser, PHANNOT_PARENTHESES_CLOSE, NULL, parser_status);
				break;

			case PHANNOT_T_BRACKET_OPEN:
				phannot_(phannot_parser, PHANNOT_BRACKET_OPEN, NULL, parser_status);
				break;
			case PHANNOT_T_BRACKET_CLOSE:
				phannot_(phannot_parser, PHANNOT_BRACKET_CLOSE, NULL, parser_status);
				break;

			case PHANNOT_T_SBRACKET_OPEN:
				phannot_(phannot_parser, PHANNOT_SBRACKET_OPEN, NULL, parser_status);
				break;
			case PHANNOT_T_SBRACKET_CLOSE:
				phannot_(phannot_parser, PHANNOT_SBRACKET_CLOSE, NULL, parser_status);
				break;

			case PHANNOT_T_NULL:
				phannot_(phannot_parser, PHANNOT_NULL, NULL, parser_status);
				break;
			case PHANNOT_T_TRUE:
				phannot_(phannot_parser, PHANNOT_TRUE, NULL, parser_status);
				break;
			case PHANNOT_T_FALSE:
				phannot_(phannot_parser, PHANNOT_FALSE, NULL, parser_status);
				break;

			case PHANNOT_T_INTEGER:
				phannot_parse_with_token(phannot_parser, PHANNOT_T_INTEGER, PHANNOT_INTEGER, &token, parser_status);
				break;
			case PHANNOT_T_DOUBLE:
				phannot_parse_with_token(phannot_parser, PHANNOT_T_DOUBLE, PHANNOT_DOUBLE, &token, parser_status);
				break;
			case PHANNOT_T_STRING:
				phannot_parse_with_token(phannot_parser, PHANNOT_T_STRING, PHANNOT_STRING, &token, parser_status);
				break;
			case PHANNOT_T_IDENTIFIER:
				phannot_parse_with_token(phannot_parser, PHANNOT_T_IDENTIFIER, PHANNOT_IDENTIFIER, &token, parser_status);
				break;
			/*case PHANNOT_T_ARBITRARY_TEXT:
				phannot_parse_with_token(phannot_parser, PHANNOT_T_ARBITRARY_TEXT, PHANNOT_ARBITRARY_TEXT, &token, parser_status);
				break;*/

			default:
				parser_status->status = PHANNOT_PARSING_FAILED;
				if (!*error_msg) {
					spprintf(error_msg, 0, "Scanner: unknown opcode %d on in %s line %d", token.opcode, state->active_file, state->active_line);
				}
				break;
		}

		if (parser_status->status != PHANNOT_PARSING_OK) {
			status = FAILURE;
			break;
		}

		state->end = state->start;
	}

	if (status != FAILURE) {
		switch (scanner_status) {
			case PHANNOT_SCANNER_RETCODE_ERR:
			case PHANNOT_SCANNER_RETCODE_IMPOSSIBLE:
				if (!*error_msg) {
					phannot_scanner_error_msg(parser_status, error_msg TSRMLS_CC);
				}
				status = FAILURE;
				break;
			default:
				phannot_(phannot_parser, 0, NULL, parser_status);
		}
	}

	state->active_token = 0;
	state->start = NULL;

	if (parser_status->status != PHANNOT_PARSING_OK) {
		status = FAILURE;
		if (parser_status->syntax_error) {
			if (!*error_msg) {
				*error_msg = parser_status->syntax_error;
			}
			else {
				efree(parser_status->syntax_error);
			}
		}
	}

	phannot_Free(phannot_parser, phannot_wrapper_free);

	if (status != FAILURE) {
		if (parser_status->status == PHANNOT_PARSING_OK) {
			if (parser_status->ret) {
				ZVAL_ZVAL(*result, parser_status->ret, 0, 0);
				ZVAL_NULL(parser_status->ret);
				zval_ptr_dtor(&parser_status->ret);
			} else {
				array_init(*result);
			}
		}
	}

	efree(processed_comment);
	efree(parser_status);

	return status;
}






zend_class_entry *phalcon_annotations_reader_ce;

static PHP_METHOD(Phalcon_Annotations_Reader, parse);
static PHP_METHOD(Phalcon_Annotations_Reader, parseDocBlock);

static const zend_function_entry phalcon_annotations_reader_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Reader, parse, arginfo_phalcon_annotations_readerinterface_parse, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Reader, parseDocBlock, arginfo_phalcon_annotations_readerinterface_parsedocblock, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Annotations_Reader){

	PHALCON_REGISTER_CLASS(Phalcon\\Annotations, Reader, annotations_reader, phalcon_annotations_reader_method_entry, 0);

	zend_class_implements(phalcon_annotations_reader_ce TSRMLS_CC, 1, phalcon_annotations_readerinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Reader, parse){

	zval *class_name, *annotations;
	zval *class_annotations, *annotations_properties, *annotations_methods;
	zend_class_entry *class_ce;
	const char *file;
	zend_uint line;

	phalcon_fetch_params(0, 1, 0, &class_name);

	if (unlikely(Z_TYPE_P(class_name) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_annotations_exception_ce, "The class name must be a string");
		return;
	}

	class_ce = zend_fetch_class(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), ZEND_FETCH_CLASS_AUTO | ZEND_FETCH_CLASS_SILENT TSRMLS_CC);
	if (!class_ce) {
		zend_throw_exception_ex(phalcon_annotations_exception_ce, 0 TSRMLS_CC, "Class %s does not exist", Z_STRVAL_P(class_name));
		return;
	}

	if (class_ce->type != ZEND_USER_CLASS) {
		array_init(return_value);
		return;
	}

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(annotations);
	array_init(annotations);

	file = phalcon_get_class_filename(class_ce);
	if (!file) {
		file = "(unknown)";
	}

	/* Class info */
	{
		const char *cmt;
		zend_uint cmt_len;

		if (phalcon_get_class_doc_comment(class_ce, &cmt, &cmt_len)) {
			line = phalcon_get_class_startline(class_ce);

			PHALCON_INIT_VAR(class_annotations);
			RETURN_MM_ON_FAILURE(phannot_parse_annotations(class_annotations, cmt, cmt_len, file, line TSRMLS_CC));

			if (Z_TYPE_P(class_annotations) == IS_ARRAY) {
				phalcon_array_update_string(&annotations, SL("class"), class_annotations, PH_COPY);
			}
		}
	}

	/* Get class properties */
	{
		HashTable *props = &class_ce->properties_info;
		if (zend_hash_num_elements(props) > 0) {
			HashPosition hp;
			zend_property_info *property;

			PHALCON_INIT_VAR(annotations_properties);
			array_init_size(annotations_properties, zend_hash_num_elements(props));

			for (
				zend_hash_internal_pointer_reset_ex(props, &hp);
				zend_hash_get_current_data_ex(props, (void**)&property, &hp) != FAILURE;
				zend_hash_move_forward_ex(props, &hp)
			) {
				const char *cmt;
				zend_uint cmt_len;

				if (phalcon_get_property_doc_comment(property, &cmt, &cmt_len)) {
					zval *property_annotations;

					MAKE_STD_ZVAL(property_annotations);
					if (FAILURE == phannot_parse_annotations(property_annotations, cmt, cmt_len, file, 0 TSRMLS_CC)) {
						zval_ptr_dtor(&property_annotations);
						RETURN_MM();
					}

					if (Z_TYPE_P(property_annotations) == IS_ARRAY) {
						#if PHP_VERSION_ID >= 50400
						{
							const char *prop_name, *class_name;
							if (zend_unmangle_property_name(property->name, property->name_length - 1, &class_name, &prop_name) == SUCCESS) {
								add_assoc_zval_ex(annotations_properties, prop_name, strlen(prop_name) + 1, property_annotations);
							}
						}
						#else
						{
							char *prop_name, *class_name;
							if (zend_unmangle_property_name(property->name, property->name_length - 1, &class_name, &prop_name) == SUCCESS) {
								add_assoc_zval_ex(annotations_properties, prop_name, strlen(prop_name) + 1, property_annotations);
							}
						}
						#endif
					} else {
						zval_ptr_dtor(&property_annotations);
					}
				}
			}

			if (zend_hash_num_elements(Z_ARRVAL_P(annotations_properties))) {
				phalcon_array_update_string(&annotations, SL("properties"), annotations_properties, PH_COPY);
			}
		}
	}

	/* Get class methods */
	{
		HashTable *methods = &class_ce->function_table;
		if (zend_hash_num_elements(methods) > 0) {
			HashPosition hp;
			zend_function *method;

			PHALCON_INIT_VAR(annotations_methods);
			array_init_size(annotations_methods, zend_hash_num_elements(methods));

			for (
				zend_hash_internal_pointer_reset_ex(methods, &hp);
				zend_hash_get_current_data_ex(methods, (void**)&method, &hp) != FAILURE;
				zend_hash_move_forward_ex(methods, &hp)
			) {
				const char *cmt;
				zend_uint cmt_len;

				if (phalcon_get_function_doc_comment(method, &cmt, &cmt_len)) {
					zval *method_annotations;

					line = phalcon_get_function_startline(method);

					MAKE_STD_ZVAL(method_annotations);
					if (FAILURE == phannot_parse_annotations(method_annotations, cmt, cmt_len, file, line TSRMLS_CC)) {
						zval_ptr_dtor(&method_annotations);
						RETURN_MM();
					}

					if (Z_TYPE_P(method_annotations) == IS_ARRAY) {
						add_assoc_zval_ex(annotations_methods, method->common.function_name, strlen(method->common.function_name) + 1, method_annotations);
					}
					else {
						zval_ptr_dtor(&method_annotations);
					}
				}
			}

			if (zend_hash_num_elements(Z_ARRVAL_P(annotations_methods))) {
				phalcon_array_update_string(&annotations, SL("methods"), annotations_methods, PH_COPY);
			}
		}
	}

	RETURN_CTOR(annotations);
}

static PHP_METHOD(Phalcon_Annotations_Reader, parseDocBlock)
{
	zval **doc_block, **file = NULL, **line = NULL;

	phalcon_fetch_params_ex(3, 0, &doc_block, &file, &line);

	PHALCON_ENSURE_IS_STRING(doc_block);
	PHALCON_ENSURE_IS_STRING(file);
	PHALCON_ENSURE_IS_LONG(line);

	RETURN_ON_FAILURE(phannot_parse_annotations(return_value, Z_STRVAL_PP(doc_block), Z_STRLEN_PP(doc_block), Z_STRVAL_PP(file), Z_LVAL_PP(line) TSRMLS_CC));
}






zend_class_entry *phalcon_annotations_readerinterface_ce;

static const zend_function_entry phalcon_annotations_readerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Annotations_ReaderInterface, parse, arginfo_phalcon_annotations_readerinterface_parse)
	ZEND_FENTRY(parseDocBlock, NULL, arginfo_phalcon_annotations_readerinterface_parsedocblock, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_ReaderInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Annotations, ReaderInterface, annotations_readerinterface, phalcon_annotations_readerinterface_method_entry);

	return SUCCESS;
}










zend_class_entry *phalcon_annotations_reflection_ce;

static PHP_METHOD(Phalcon_Annotations_Reflection, __construct);
static PHP_METHOD(Phalcon_Annotations_Reflection, getClassAnnotations);
static PHP_METHOD(Phalcon_Annotations_Reflection, getMethodsAnnotations);
static PHP_METHOD(Phalcon_Annotations_Reflection, getPropertiesAnnotations);
static PHP_METHOD(Phalcon_Annotations_Reflection, getReflectionData);
static PHP_METHOD(Phalcon_Annotations_Reflection, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_reflection___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, reflectionData)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_reflection___set_state, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_reflection_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Reflection, __construct, arginfo_phalcon_annotations_reflection___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Annotations_Reflection, getClassAnnotations, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Reflection, getMethodsAnnotations, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Reflection, getPropertiesAnnotations, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Reflection, getReflectionData, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Reflection, __set_state, arginfo_phalcon_annotations_reflection___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_Reflection){

	PHALCON_REGISTER_CLASS(Phalcon\\Annotations, Reflection, annotations_reflection, phalcon_annotations_reflection_method_entry, 0);

	zend_declare_property_null(phalcon_annotations_reflection_ce, SL("_reflectionData"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_reflection_ce, SL("_classAnnotations"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_reflection_ce, SL("_methodAnnotations"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_annotations_reflection_ce, SL("_propertyAnnotations"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Reflection, __construct){

	zval *reflection_data = NULL;

	phalcon_fetch_params(0, 0, 1, &reflection_data);
	
	if (reflection_data && Z_TYPE_P(reflection_data) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_reflectionData"), reflection_data, 3848141129UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Annotations_Reflection, getClassAnnotations){

	zval *annotations, *reflection_data, *reflection_class;

	PHALCON_MM_GROW();

	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_classAnnotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) != IS_OBJECT) {
	
		reflection_data = phalcon_fetch_nproperty_this(this_ptr, SL("_reflectionData"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&reflection_class, reflection_data, SS("class"))) {
			object_init_ex(return_value, phalcon_annotations_collection_ce);
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", reflection_class);
	
			phalcon_update_property_this_quick(this_ptr, SL("_classAnnotations"), return_value, 372163368UL TSRMLS_CC);
			RETURN_MM();
		}
	
		phalcon_update_property_this(this_ptr, SL("_classAnnotations"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	RETURN_CTOR(annotations);
}

static PHP_METHOD(Phalcon_Annotations_Reflection, getMethodsAnnotations){

	zval *annotations, *reflection_data, *reflection_methods;
	zval *reflection_method = NULL, *method_name = NULL;
	zval *collection = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_methodAnnotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) != IS_OBJECT) {
	
		reflection_data = phalcon_fetch_nproperty_this(this_ptr, SL("_reflectionData"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&reflection_methods, reflection_data, SS("methods"))) {
			if (phalcon_fast_count_ev(reflection_methods TSRMLS_CC)) {
	
				array_init(return_value);
	
				phalcon_is_iterable(reflection_methods, &ah0, &hp0, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
					PHALCON_GET_HKEY(method_name, ah0, hp0);
					PHALCON_GET_HVALUE(reflection_method);
	
					PHALCON_INIT_NVAR(collection);
					object_init_ex(collection, phalcon_annotations_collection_ce);
					PHALCON_CALL_METHOD(NULL, collection, "__construct", reflection_method);
	
					phalcon_array_update_zval(&return_value, method_name, collection, PH_COPY);
	
					zend_hash_move_forward_ex(ah0, &hp0);
				}
	
				phalcon_update_property_this_quick(this_ptr, SL("_methodAnnotations"), return_value, 4229536243UL TSRMLS_CC);
	
				RETURN_MM();
			}
		}
	
		phalcon_update_property_bool(this_ptr, SL("_methodAnnotations"), 0 TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	RETURN_CTOR(annotations);
}

static PHP_METHOD(Phalcon_Annotations_Reflection, getPropertiesAnnotations){

	zval *annotations, *reflection_data, *reflection_properties;
	zval *reflection_property = NULL, *property = NULL;
	zval *collection = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	annotations = phalcon_fetch_nproperty_this(this_ptr, SL("_propertyAnnotations"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(annotations) != IS_OBJECT) {
	
		reflection_data = phalcon_fetch_nproperty_this(this_ptr, SL("_reflectionData"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&reflection_properties, reflection_data, SS("properties"))) {
	
			if (phalcon_fast_count_ev(reflection_properties TSRMLS_CC)) {
	
				array_init(return_value);
	
				phalcon_is_iterable(reflection_properties, &ah0, &hp0, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
					PHALCON_GET_HKEY(property, ah0, hp0);
					PHALCON_GET_HVALUE(reflection_property);
	
					PHALCON_INIT_NVAR(collection);
					object_init_ex(collection, phalcon_annotations_collection_ce);
					PHALCON_CALL_METHOD(NULL, collection, "__construct", reflection_property);
	
					phalcon_array_update_zval(&return_value, property, collection, PH_COPY);
	
					zend_hash_move_forward_ex(ah0, &hp0);
				}
	
				phalcon_update_property_this_quick(this_ptr, SL("_propertyAnnotations"), return_value, 762458551UL TSRMLS_CC);
	
				RETURN_MM();
			}
		}
	
		phalcon_update_property_bool(this_ptr, SL("_propertyAnnotations"), 0 TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	RETURN_CTOR(annotations);
}

static PHP_METHOD(Phalcon_Annotations_Reflection, getReflectionData){


	RETURN_MEMBER_QUICK(this_ptr, "_reflectionData", 3848141129UL);
}

static PHP_METHOD(Phalcon_Annotations_Reflection, __set_state){

	zval *data, *reflection_data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	if (Z_TYPE_P(data) == IS_ARRAY) { 
	
		if (phalcon_array_isset_quick_string(data, SS("_reflectionData"), 3848141129UL)) {
			PHALCON_OBS_VAR(reflection_data);
			phalcon_array_fetch_quick_string(&reflection_data, data, SS("_reflectionData"), 3848141129UL, PH_NOISY);
			object_init_ex(return_value, phalcon_annotations_reflection_ce);
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", reflection_data);
	
			RETURN_MM();
		}
	}
	object_init_ex(return_value, phalcon_annotations_reflection_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct");
	
	RETURN_MM();
}



/* Generated by re2c 0.13.5 on Sat Jan 11 18:45:29 2014 */
/* #line 1 "scanner.re" */




#define JJCTYPE unsigned char
#define JJCURSOR (s->start)
#define JJLIMIT (s->end)
#define JJMARKER q

static int phannot_get_token(phannot_scanner_state *s, phannot_scanner_token *token) {

	char next, *q = JJCURSOR, *start = JJCURSOR;
	int status = PHANNOT_SCANNER_RETCODE_IMPOSSIBLE;

	while (PHANNOT_SCANNER_RETCODE_IMPOSSIBLE == status) {

		if (s->mode == PHANNOT_MODE_RAW) {

			if (*JJCURSOR == '\n') {
				s->active_line++;
			}

			next = *(JJCURSOR+1);

			if (*JJCURSOR == '\0' || *JJCURSOR == '@') {
				if ((next >= 'A' && next <= 'Z') || (next >= 'a' && next <= 'z')) {
					s->mode = PHANNOT_MODE_ANNOTATION;
					continue;
				}
			}

			++JJCURSOR;
			token->opcode = PHANNOT_T_IGNORE;
			return 0;

		} else {

		
/* #line 61 "scanner.c" */
		{
			JJCTYPE jjch;
			unsigned int jjaccept = 0;
			static const unsigned char jjbm[] = {
				  0,  96,  96,  96,  96,  96,  96,  96, 
				 96, 104,  96,  96,  96, 104,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				104,  96,  32,  96,  96,  96,  96,  64, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				240, 240, 240, 240, 240, 240, 240, 240, 
				240, 240,  96,  96,  96,  96,  96,  96, 
				 96, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112,  96,   0,  96,  96, 112, 
				 96, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
			};

			jjch = *JJCURSOR;
			switch (jjch) {
			case 0x00:	goto jj38;
			case '\t':
			case '\r':
			case ' ':	goto jj34;
			case '\n':	goto jj36;
			case '"':	goto jj10;
			case '\'':	goto jj11;
			case '(':	goto jj14;
			case ')':	goto jj16;
			case ',':	goto jj32;
			case '-':	goto jj2;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto jj4;
			case ':':	goto jj30;
			case '=':	goto jj28;
			case '@':	goto jj26;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'G':
			case 'H':
			case 'I':
			case 'J':
			case 'K':
			case 'L':
			case 'M':
			case 'O':
			case 'P':
			case 'Q':
			case 'R':
			case 'S':
			case 'U':
			case 'V':
			case 'W':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 'u':
			case 'v':
			case 'w':
			case 'x':
			case 'y':
			case 'z':	goto jj13;
			case 'F':
			case 'f':	goto jj8;
			case 'N':
			case 'n':	goto jj6;
			case 'T':
			case 't':	goto jj9;
			case '[':	goto jj22;
			case '\\':	goto jj12;
			case ']':	goto jj24;
			case '{':	goto jj18;
			case '}':	goto jj20;
			default:	goto jj40;
			}
jj2:
			++JJCURSOR;
			if (jjbm[0+(jjch = *JJCURSOR)] & 128) {
				goto jj71;
			}
jj3:
/* #line 178 "scanner.re" */
			{
			status = PHANNOT_SCANNER_RETCODE_ERR;
			break;
		}
/* #line 197 "scanner.c" */
jj4:
			jjaccept = 0;
			jjch = *(JJMARKER = ++JJCURSOR);
			goto jj72;
jj5:
/* #line 62 "scanner.re" */
			{
			token->opcode = PHANNOT_T_INTEGER;
			token->value = estrndup(start, JJCURSOR - start);
			token->len = JJCURSOR - start;
			q = JJCURSOR;
			return 0;
		}
/* #line 211 "scanner.c" */
jj6:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'U') goto jj66;
			if (jjch == 'u') goto jj66;
			goto jj44;
jj7:
/* #line 104 "scanner.re" */
			{
			token->opcode = PHANNOT_T_IDENTIFIER;
			token->value = estrndup(start, JJCURSOR - start);
			token->len = JJCURSOR - start;
			q = JJCURSOR;
			return 0;
		}
/* #line 227 "scanner.c" */
jj8:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'A') goto jj61;
			if (jjch == 'a') goto jj61;
			goto jj44;
jj9:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'R') goto jj57;
			if (jjch == 'r') goto jj57;
			goto jj44;
jj10:
			jjaccept = 2;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch <= 0x00) goto jj3;
			goto jj55;
jj11:
			jjaccept = 2;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch <= 0x00) goto jj3;
			goto jj50;
jj12:
			jjch = *++JJCURSOR;
			if (jjch <= '^') {
				if (jjch <= '@') goto jj3;
				if (jjch <= 'Z') goto jj43;
				goto jj3;
			} else {
				if (jjch == '`') goto jj3;
				if (jjch <= 'z') goto jj43;
				goto jj3;
			}
jj13:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			goto jj44;
jj14:
			++JJCURSOR;
/* #line 112 "scanner.re" */
			{
			token->opcode = PHANNOT_T_PARENTHESES_OPEN;
			return 0;
		}
/* #line 272 "scanner.c" */
jj16:
			++JJCURSOR;
/* #line 117 "scanner.re" */
			{
			token->opcode = PHANNOT_T_PARENTHESES_CLOSE;
			return 0;
		}
/* #line 280 "scanner.c" */
jj18:
			++JJCURSOR;
/* #line 122 "scanner.re" */
			{
			token->opcode = PHANNOT_T_BRACKET_OPEN;
			return 0;
		}
/* #line 288 "scanner.c" */
jj20:
			++JJCURSOR;
/* #line 127 "scanner.re" */
			{
			token->opcode = PHANNOT_T_BRACKET_CLOSE;
			return 0;
		}
/* #line 296 "scanner.c" */
jj22:
			++JJCURSOR;
/* #line 132 "scanner.re" */
			{
			token->opcode = PHANNOT_T_SBRACKET_OPEN;
			return 0;
		}
/* #line 304 "scanner.c" */
jj24:
			++JJCURSOR;
/* #line 137 "scanner.re" */
			{
			token->opcode = PHANNOT_T_SBRACKET_CLOSE;
			return 0;
		}
/* #line 312 "scanner.c" */
jj26:
			++JJCURSOR;
/* #line 142 "scanner.re" */
			{
			token->opcode = PHANNOT_T_AT;
			return 0;
		}
/* #line 320 "scanner.c" */
jj28:
			++JJCURSOR;
/* #line 147 "scanner.re" */
			{
			token->opcode = PHANNOT_T_EQUALS;
			return 0;
		}
/* #line 328 "scanner.c" */
jj30:
			++JJCURSOR;
/* #line 152 "scanner.re" */
			{
			token->opcode = PHANNOT_T_COLON;
			return 0;
		}
/* #line 336 "scanner.c" */
jj32:
			++JJCURSOR;
/* #line 157 "scanner.re" */
			{
			token->opcode = PHANNOT_T_COMMA;
			return 0;
		}
/* #line 344 "scanner.c" */
jj34:
			++JJCURSOR;
			jjch = *JJCURSOR;
			goto jj42;
jj35:
/* #line 162 "scanner.re" */
			{
			token->opcode = PHANNOT_T_IGNORE;
			return 0;
		}
/* #line 355 "scanner.c" */
jj36:
			++JJCURSOR;
/* #line 167 "scanner.re" */
			{
			s->active_line++;
			token->opcode = PHANNOT_T_IGNORE;
			return 0;
		}
/* #line 364 "scanner.c" */
jj38:
			++JJCURSOR;
/* #line 173 "scanner.re" */
			{
			status = PHANNOT_SCANNER_RETCODE_EOF;
			break;
		}
/* #line 372 "scanner.c" */
jj40:
			jjch = *++JJCURSOR;
			goto jj3;
jj41:
			++JJCURSOR;
			jjch = *JJCURSOR;
jj42:
			if (jjbm[0+jjch] & 8) {
				goto jj41;
			}
			goto jj35;
jj43:
			jjaccept = 1;
			JJMARKER = ++JJCURSOR;
			jjch = *JJCURSOR;
jj44:
			if (jjbm[0+jjch] & 16) {
				goto jj43;
			}
			if (jjch != '\\') goto jj7;
jj45:
			++JJCURSOR;
			jjch = *JJCURSOR;
			if (jjch <= '^') {
				if (jjch <= '@') goto jj46;
				if (jjch <= 'Z') goto jj47;
			} else {
				if (jjch == '`') goto jj46;
				if (jjch <= 'z') goto jj47;
			}
jj46:
			JJCURSOR = JJMARKER;
			if (jjaccept <= 2) {
				if (jjaccept <= 1) {
					if (jjaccept <= 0) {
						goto jj5;
					} else {
						goto jj7;
					}
				} else {
					goto jj3;
				}
			} else {
				if (jjaccept <= 4) {
					if (jjaccept <= 3) {
						goto jj60;
					} else {
						goto jj65;
					}
				} else {
					goto jj69;
				}
			}
jj47:
			jjaccept = 1;
			JJMARKER = ++JJCURSOR;
			jjch = *JJCURSOR;
			if (jjch <= '[') {
				if (jjch <= '9') {
					if (jjch <= '/') goto jj7;
					goto jj47;
				} else {
					if (jjch <= '@') goto jj7;
					if (jjch <= 'Z') goto jj47;
					goto jj7;
				}
			} else {
				if (jjch <= '_') {
					if (jjch <= '\\') goto jj45;
					if (jjch <= '^') goto jj7;
					goto jj47;
				} else {
					if (jjch <= '`') goto jj7;
					if (jjch <= 'z') goto jj47;
					goto jj7;
				}
			}
jj49:
			++JJCURSOR;
			jjch = *JJCURSOR;
jj50:
			if (jjbm[0+jjch] & 32) {
				goto jj49;
			}
			if (jjch <= 0x00) goto jj46;
			if (jjch <= '[') goto jj52;
			++JJCURSOR;
			jjch = *JJCURSOR;
			if (jjch == '\n') goto jj46;
			goto jj49;
jj52:
			++JJCURSOR;
/* #line 95 "scanner.re" */
			{
			token->opcode = PHANNOT_T_STRING;
			token->value = estrndup(q, JJCURSOR - q - 1);
			token->len = JJCURSOR - q - 1;
			q = JJCURSOR;
			return 0;
		}
/* #line 473 "scanner.c" */
jj54:
			++JJCURSOR;
			jjch = *JJCURSOR;
jj55:
			if (jjbm[0+jjch] & 64) {
				goto jj54;
			}
			if (jjch <= 0x00) goto jj46;
			if (jjch <= '[') goto jj52;
			++JJCURSOR;
			jjch = *JJCURSOR;
			if (jjch == '\n') goto jj46;
			goto jj54;
jj57:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'U') goto jj58;
			if (jjch != 'u') goto jj44;
jj58:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'E') goto jj59;
			if (jjch != 'e') goto jj44;
jj59:
			jjaccept = 3;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjbm[0+jjch] & 16) {
				goto jj43;
			}
			if (jjch == '\\') goto jj45;
jj60:
/* #line 89 "scanner.re" */
			{
			token->opcode = PHANNOT_T_TRUE;
			return 0;
		}
/* #line 510 "scanner.c" */
jj61:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'L') goto jj62;
			if (jjch != 'l') goto jj44;
jj62:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'S') goto jj63;
			if (jjch != 's') goto jj44;
jj63:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'E') goto jj64;
			if (jjch != 'e') goto jj44;
jj64:
			jjaccept = 4;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjbm[0+jjch] & 16) {
				goto jj43;
			}
			if (jjch == '\\') goto jj45;
jj65:
/* #line 84 "scanner.re" */
			{
			token->opcode = PHANNOT_T_FALSE;
			return 0;
		}
/* #line 539 "scanner.c" */
jj66:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'L') goto jj67;
			if (jjch != 'l') goto jj44;
jj67:
			jjaccept = 1;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjch == 'L') goto jj68;
			if (jjch != 'l') goto jj44;
jj68:
			jjaccept = 5;
			jjch = *(JJMARKER = ++JJCURSOR);
			if (jjbm[0+jjch] & 16) {
				goto jj43;
			}
			if (jjch == '\\') goto jj45;
jj69:
/* #line 79 "scanner.re" */
			{
			token->opcode = PHANNOT_T_NULL;
			return 0;
		}
/* #line 563 "scanner.c" */
jj70:
			jjch = *++JJCURSOR;
			if (jjch <= '/') goto jj46;
			if (jjch <= '9') goto jj73;
			goto jj46;
jj71:
			jjaccept = 0;
			JJMARKER = ++JJCURSOR;
			jjch = *JJCURSOR;
jj72:
			if (jjbm[0+jjch] & 128) {
				goto jj71;
			}
			if (jjch == '.') goto jj70;
			goto jj5;
jj73:
			++JJCURSOR;
			jjch = *JJCURSOR;
			if (jjch <= '/') goto jj75;
			if (jjch <= '9') goto jj73;
jj75:
/* #line 71 "scanner.re" */
			{
			token->opcode = PHANNOT_T_DOUBLE;
			token->value = estrndup(start, JJCURSOR - start);
			token->len = JJCURSOR - start;
			q = JJCURSOR;
			return 0;
		}
/* #line 593 "scanner.c" */
		}
/* #line 183 "scanner.re" */


		}
	}

	return status;
}






zend_class_entry *phalcon_annotations_adapter_apc_ce;

static PHP_METHOD(Phalcon_Annotations_Adapter_Apc, read);
static PHP_METHOD(Phalcon_Annotations_Adapter_Apc, write);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_apc_read, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_apc_write, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_adapter_apc_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Adapter_Apc, read, arginfo_phalcon_annotations_adapter_apc_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter_Apc, write, arginfo_phalcon_annotations_adapter_apc_write, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Annotations_Adapter_Apc){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Annotations\\Adapter, Apc, annotations_adapter_apc, phalcon_annotations_adapter_ce, phalcon_annotations_adapter_apc_method_entry, 0);

	zend_class_implements(phalcon_annotations_adapter_apc_ce TSRMLS_CC, 1, phalcon_annotations_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Apc, read){

	zval *key, *prefixed_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SV(prefixed_key, "_PHAN", key);
	
	phalcon_strtolower_inplace(prefixed_key);
	
	PHALCON_RETURN_CALL_FUNCTION("apc_fetch", prefixed_key);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_TYPE_P(return_value) != IS_OBJECT) {
		zval_dtor(return_value);
		ZVAL_NULL(return_value);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Apc, write){

	zval *key, *data, *prefixed_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &key, &data);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SV(prefixed_key, "_PHAN", key);
	
	phalcon_strtolower_inplace(prefixed_key);
	PHALCON_CALL_FUNCTION(NULL, "apc_store", prefixed_key, data);
	
	PHALCON_MM_RESTORE();
}





#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_var.h>


zend_class_entry *phalcon_annotations_adapter_files_ce;

static PHP_METHOD(Phalcon_Annotations_Adapter_Files, __construct);
static PHP_METHOD(Phalcon_Annotations_Adapter_Files, read);
static PHP_METHOD(Phalcon_Annotations_Adapter_Files, write);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_files___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_files_read, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_files_write, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_adapter_files_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Adapter_Files, __construct, arginfo_phalcon_annotations_adapter_files___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Annotations_Adapter_Files, read, arginfo_phalcon_annotations_adapter_files_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter_Files, write, arginfo_phalcon_annotations_adapter_files_write, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Annotations_Adapter_Files){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Annotations\\Adapter, Files, annotations_adapter_files, phalcon_annotations_adapter_ce, phalcon_annotations_adapter_files_method_entry, 0);

	zend_declare_property_string(phalcon_annotations_adapter_files_ce, SL("_annotationsDir"), "./", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_annotations_adapter_files_ce TSRMLS_CC, 1, phalcon_annotations_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Files, __construct){

	zval *options = NULL, *annotations_dir;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		if (phalcon_array_isset_string_fetch(&annotations_dir, options, SS("annotationsDir"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_annotationsDir"), annotations_dir, 4233102065UL TSRMLS_CC);
		}
	}
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Files, read){

	zval **key, *annotations_dir, *virtual_key, *path;

	phalcon_fetch_params_ex(1, 0, &key);
	PHALCON_ENSURE_IS_STRING(key);

	PHALCON_MM_GROW();

	annotations_dir = phalcon_fetch_nproperty_this(this_ptr, SL("_annotationsDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(virtual_key);
	phalcon_prepare_virtual_path_ex(virtual_key, Z_STRVAL_PP(key), Z_STRLEN_PP(key), '_' TSRMLS_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VVS(path, annotations_dir, virtual_key, ".php");
	
	if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
		zval *tmp = NULL;
		RETURN_MM_ON_FAILURE(phalcon_require_ret(&tmp, Z_STRVAL_P(path) TSRMLS_CC));
		RETVAL_ZVAL(tmp, 1, 1);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Files, write){

	zval **key, **data, *annotations_dir;
	zval *virtual_key, *path, *php_export;
	zval *status;
	smart_str exp = { NULL, 0, 0 };

	phalcon_fetch_params_ex(2, 0, &key, &data);
	PHALCON_ENSURE_IS_STRING(key);

	PHALCON_MM_GROW();

	annotations_dir = phalcon_fetch_nproperty_this(this_ptr, SL("_annotationsDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(virtual_key);
	phalcon_prepare_virtual_path_ex(virtual_key, Z_STRVAL_PP(key), Z_STRLEN_PP(key), '_' TSRMLS_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VVS(path, annotations_dir, virtual_key, ".php");
	
	smart_str_appends(&exp, "<?php return ");
	php_var_export_ex(data, 0, &exp TSRMLS_CC);
	smart_str_appendc(&exp, ';');
	smart_str_0(&exp);
	
	PHALCON_INIT_VAR(php_export);
	ZVAL_STRINGL(php_export, exp.c, exp.len, 0);
	
	PHALCON_INIT_VAR(status);
	phalcon_file_put_contents(status, path, php_export TSRMLS_CC);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_annotations_exception_ce, "Annotations directory cannot be written");
		return;
	}
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_annotations_adapter_memory_ce;

static PHP_METHOD(Phalcon_Annotations_Adapter_Memory, read);
static PHP_METHOD(Phalcon_Annotations_Adapter_Memory, write);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_memory_read, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_memory_write, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_adapter_memory_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Adapter_Memory, read, arginfo_phalcon_annotations_adapter_memory_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter_Memory, write, arginfo_phalcon_annotations_adapter_memory_write, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_Adapter_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Annotations\\Adapter, Memory, annotations_adapter_memory, phalcon_annotations_adapter_ce, phalcon_annotations_adapter_memory_method_entry, 0);

	zend_declare_property_null(phalcon_annotations_adapter_memory_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_annotations_adapter_memory_ce TSRMLS_CC, 1, phalcon_annotations_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Memory, read){

	zval *key, *data, *lowercased_key, *annotations;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key);
	
	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(lowercased_key);
	phalcon_fast_strtolower(lowercased_key, key);
	if (phalcon_array_isset_fetch(&annotations, data, lowercased_key)) {
		RETURN_CTOR(annotations);
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Memory, write){

	zval *key, *data, *lowercased_key;

	phalcon_fetch_params(0, 2, 0, &key, &data);
	
	MAKE_STD_ZVAL(lowercased_key);
	phalcon_fast_strtolower(lowercased_key, key);
	phalcon_update_property_array(this_ptr, SL("_data"), lowercased_key, data TSRMLS_CC);
	zval_ptr_dtor(&lowercased_key);
}






zend_class_entry *phalcon_annotations_adapter_xcache_ce;

static PHP_METHOD(Phalcon_Annotations_Adapter_Xcache, read);
static PHP_METHOD(Phalcon_Annotations_Adapter_Xcache, write);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_xcache_read, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_annotations_adapter_xcache_write, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_annotations_adapter_xcache_method_entry[] = {
	PHP_ME(Phalcon_Annotations_Adapter_Xcache, read, arginfo_phalcon_annotations_adapter_xcache_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Annotations_Adapter_Xcache, write, arginfo_phalcon_annotations_adapter_xcache_write, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Annotations_Adapter_Xcache){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Annotations\\Adapter, Xcache, annotations_adapter_xcache, phalcon_annotations_adapter_ce, phalcon_annotations_adapter_xcache_method_entry, 0);

	zend_class_implements(phalcon_annotations_adapter_xcache_ce TSRMLS_CC, 1, phalcon_annotations_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Xcache, read){

	zval *key, *prefixed_key, *serialized = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SV(prefixed_key, "_PHAN", key);
	
	phalcon_strtolower_inplace(prefixed_key);
	
	PHALCON_CALL_FUNCTION(&serialized, "xcache_get", prefixed_key);
	if (Z_TYPE_P(serialized) == IS_STRING) {
		phalcon_unserialize(return_value, serialized TSRMLS_CC);
		if (Z_TYPE_P(return_value) != IS_OBJECT) {
			zval_dtor(return_value);
			RETVAL_NULL();
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Annotations_Adapter_Xcache, write){

	zval *key, *data, *prefixed_key;
	zval *serialized;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &key, &data);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SV(prefixed_key, "_PHAN", key);
	
	phalcon_strtolower_inplace(prefixed_key);
	
	PHALCON_INIT_VAR(serialized);
	phalcon_serialize(serialized, &data TSRMLS_CC);
	PHALCON_CALL_FUNCTION(NULL, "xcache_set", prefixed_key, serialized);
	
	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_assets_collection_ce;

static PHP_METHOD(Phalcon_Assets_Collection, add);
static PHP_METHOD(Phalcon_Assets_Collection, addCss);
static PHP_METHOD(Phalcon_Assets_Collection, addJs);
static PHP_METHOD(Phalcon_Assets_Collection, getResources);
static PHP_METHOD(Phalcon_Assets_Collection, count);
static PHP_METHOD(Phalcon_Assets_Collection, rewind);
static PHP_METHOD(Phalcon_Assets_Collection, current);
static PHP_METHOD(Phalcon_Assets_Collection, key);
static PHP_METHOD(Phalcon_Assets_Collection, next);
static PHP_METHOD(Phalcon_Assets_Collection, valid);
static PHP_METHOD(Phalcon_Assets_Collection, setTargetPath);
static PHP_METHOD(Phalcon_Assets_Collection, getTargetPath);
static PHP_METHOD(Phalcon_Assets_Collection, setSourcePath);
static PHP_METHOD(Phalcon_Assets_Collection, getSourcePath);
static PHP_METHOD(Phalcon_Assets_Collection, setTargetUri);
static PHP_METHOD(Phalcon_Assets_Collection, getTargetUri);
static PHP_METHOD(Phalcon_Assets_Collection, setPrefix);
static PHP_METHOD(Phalcon_Assets_Collection, getPrefix);
static PHP_METHOD(Phalcon_Assets_Collection, setLocal);
static PHP_METHOD(Phalcon_Assets_Collection, getLocal);
static PHP_METHOD(Phalcon_Assets_Collection, setAttributes);
static PHP_METHOD(Phalcon_Assets_Collection, getAttributes);
static PHP_METHOD(Phalcon_Assets_Collection, addFilter);
static PHP_METHOD(Phalcon_Assets_Collection, setFilters);
static PHP_METHOD(Phalcon_Assets_Collection, getFilters);
static PHP_METHOD(Phalcon_Assets_Collection, join);
static PHP_METHOD(Phalcon_Assets_Collection, getJoin);
static PHP_METHOD(Phalcon_Assets_Collection, getRealTargetPath);
static PHP_METHOD(Phalcon_Assets_Collection, setTargetLocal);
static PHP_METHOD(Phalcon_Assets_Collection, getTargetLocal);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_add, 0, 0, 1)
	ZEND_ARG_INFO(0, resource)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_addcss, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_addjs, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_settargetpath, 0, 0, 1)
	ZEND_ARG_INFO(0, targetPath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_setsourcepath, 0, 0, 1)
	ZEND_ARG_INFO(0, sourcePath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_settargeturi, 0, 0, 1)
	ZEND_ARG_INFO(0, targetUri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_setprefix, 0, 0, 1)
	ZEND_ARG_INFO(0, prefix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_setlocal, 0, 0, 1)
	ZEND_ARG_INFO(0, local)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_setattributes, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_addfilter, 0, 0, 1)
	ZEND_ARG_INFO(0, filter)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_setfilters, 0, 0, 1)
	ZEND_ARG_INFO(0, filters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_join, 0, 0, 1)
	ZEND_ARG_INFO(0, join)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_getrealtargetpath, 0, 0, 0)
	ZEND_ARG_INFO(0, basePath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_collection_settargetlocal, 0, 0, 1)
	ZEND_ARG_INFO(0, targetLocal)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_collection_method_entry[] = {
	PHP_ME(Phalcon_Assets_Collection, add, arginfo_phalcon_assets_collection_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, addCss, arginfo_phalcon_assets_collection_addcss, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, addJs, arginfo_phalcon_assets_collection_addjs, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getResources, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, count, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, rewind, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, current, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, key, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, next, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, valid, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setTargetPath, arginfo_phalcon_assets_collection_settargetpath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getTargetPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setSourcePath, arginfo_phalcon_assets_collection_setsourcepath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getSourcePath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setTargetUri, arginfo_phalcon_assets_collection_settargeturi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getTargetUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setPrefix, arginfo_phalcon_assets_collection_setprefix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getPrefix, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setLocal, arginfo_phalcon_assets_collection_setlocal, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getLocal, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setAttributes, arginfo_phalcon_assets_collection_setattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getAttributes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, addFilter, arginfo_phalcon_assets_collection_addfilter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setFilters, arginfo_phalcon_assets_collection_setfilters, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getFilters, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, join, arginfo_phalcon_assets_collection_join, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getJoin, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getRealTargetPath, arginfo_phalcon_assets_collection_getrealtargetpath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, setTargetLocal, arginfo_phalcon_assets_collection_settargetlocal, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Collection, getTargetLocal, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Collection){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets, Collection, assets_collection, phalcon_assets_collection_method_entry, 0);

	zend_declare_property_null(phalcon_assets_collection_ce, SL("_prefix"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_assets_collection_ce, SL("_local"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_resources"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_position"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_attributes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_assets_collection_ce, SL("_join"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_targetUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_targetPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_collection_ce, SL("_sourcePath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_assets_collection_ce, SL("_targetLocal"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_assets_collection_ce TSRMLS_CC, 2, spl_ce_Countable, zend_ce_iterator);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Collection, add){

	zval *resource;

	phalcon_fetch_params(0, 1, 0, &resource);
	
	if (Z_TYPE_P(resource) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Resource must be an object");
		return;
	}
	phalcon_update_property_array_append(this_ptr, SL("_resources"), resource TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, addCss){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *collection_local = NULL;
	zval *collection_attributes = NULL, *resource;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &path, &local, &filter, &attributes);
	
	if (!local) {
		local = PHALCON_GLOBAL(z_null);
	}
	
	if (!filter) {
		filter = PHALCON_GLOBAL(z_true);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(local) == IS_BOOL) {
		collection_local = local;
	} else {
		collection_local = phalcon_fetch_nproperty_this(this_ptr, SL("_local"), PH_NOISY TSRMLS_CC);
	}

	if (Z_TYPE_P(attributes) == IS_ARRAY) { 
		collection_attributes = attributes;
	} else {
		collection_attributes = phalcon_fetch_nproperty_this(this_ptr, SL("_attributes"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(resource);
	object_init_ex(resource, phalcon_assets_resource_css_ce);
	PHALCON_CALL_METHOD(NULL, resource, "__construct", path, collection_local, filter, collection_attributes);
	
	phalcon_update_property_array_append(this_ptr, SL("_resources"), resource TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Collection, addJs){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *collection_local = NULL;
	zval *collection_attributes = NULL, *resource;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &path, &local, &filter, &attributes);
	
	if (!local) {
		local = PHALCON_GLOBAL(z_null);
	}
	
	if (!filter) {
		filter = PHALCON_GLOBAL(z_true);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(local) == IS_BOOL) {
		collection_local = local;
	} else {
		collection_local = phalcon_fetch_nproperty_this(this_ptr, SL("_local"), PH_NOISY TSRMLS_CC);
	}

	if (Z_TYPE_P(attributes) == IS_ARRAY) { 
		collection_attributes = attributes;
	} else {
		collection_attributes = phalcon_fetch_nproperty_this(this_ptr, SL("_attributes"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(resource);
	object_init_ex(resource, phalcon_assets_resource_js_ce);
	PHALCON_CALL_METHOD(NULL, resource, "__construct", path, collection_local, filter, collection_attributes);
	
	phalcon_update_property_array_append(this_ptr, SL("_resources"), resource TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Collection, getResources){

	zval *resources;

	resources = phalcon_fetch_nproperty_this(this_ptr, SL("_resources"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(resources) != IS_ARRAY) { 
		array_init(return_value);
		return;
	}
	
	RETURN_ZVAL(resources, 1, 0);
}

static PHP_METHOD(Phalcon_Assets_Collection, count){

	zval *resources;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(resources);
	phalcon_read_property_this(&resources, this_ptr, SL("_resources"), PH_NOISY TSRMLS_CC);
	phalcon_fast_count(return_value, resources TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Assets_Collection, rewind){


	phalcon_update_property_long(this_ptr, SL("_position"), 0 TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Assets_Collection, current){

	zval *position, *resources, *resource;

	position  = phalcon_fetch_nproperty_this(this_ptr, SL("_position"), PH_NOISY TSRMLS_CC);
	resources = phalcon_fetch_nproperty_this(this_ptr, SL("_resources"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&resource, resources, position)) {
		RETURN_ZVAL(resource, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Assets_Collection, key){


	RETURN_MEMBER_QUICK(this_ptr, "_position", 2925265369UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, next){


	phalcon_property_incr(this_ptr, SL("_position") TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Assets_Collection, valid){

	zval *position, *resources;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(position);
	phalcon_read_property_this(&position, this_ptr, SL("_position"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(resources);
	phalcon_read_property_this(&resources, this_ptr, SL("_resources"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(resources, position)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Assets_Collection, setTargetPath){

	zval *target_path;

	phalcon_fetch_params(0, 1, 0, &target_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_targetPath"), target_path, 3658201208UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getTargetPath){


	RETURN_MEMBER_QUICK(this_ptr, "_targetPath", 3658201208UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, setSourcePath){

	zval *source_path;

	phalcon_fetch_params(0, 1, 0, &source_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_sourcePath"), source_path, 1419415746UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getSourcePath){


	RETURN_MEMBER_QUICK(this_ptr, "_sourcePath", 1419415746UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, setTargetUri){

	zval *target_uri;

	phalcon_fetch_params(0, 1, 0, &target_uri);
	
	phalcon_update_property_this_quick(this_ptr, SL("_targetUri"), target_uri, 2193460699UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getTargetUri){


	RETURN_MEMBER_QUICK(this_ptr, "_targetUri", 2193460699UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, setPrefix){

	zval *prefix;

	phalcon_fetch_params(0, 1, 0, &prefix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getPrefix){


	RETURN_MEMBER_QUICK(this_ptr, "_prefix", 3873791314UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, setLocal){

	zval *local;

	phalcon_fetch_params(0, 1, 0, &local);
	
	phalcon_update_property_this_quick(this_ptr, SL("_local"), local, 2560221423UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getLocal){


	RETURN_MEMBER_QUICK(this_ptr, "_local", 2560221423UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, setAttributes){

	zval *attributes;

	phalcon_fetch_params(0, 1, 0, &attributes);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Attributes must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_attributes"), attributes, 1565778155UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getAttributes){


	RETURN_MEMBER_QUICK(this_ptr, "_attributes", 1565778155UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, addFilter){

	zval *filter;

	phalcon_fetch_params(0, 1, 0, &filter);
	
	phalcon_update_property_array_append(this_ptr, SL("_filters"), filter TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, setFilters){

	zval *filters;

	phalcon_fetch_params(0, 1, 0, &filters);
	
	if (Z_TYPE_P(filters) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Filters must be an array of filters");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_filters"), filters, 3850488637UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getFilters){


	RETURN_MEMBER_QUICK(this_ptr, "_filters", 3850488637UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, join){

	zval *join;

	phalcon_fetch_params(0, 1, 0, &join);
	
	phalcon_update_property_this_quick(this_ptr, SL("_join"), join, 3979733204UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getJoin){


	RETURN_MEMBER_QUICK(this_ptr, "_join", 3979733204UL);
}

static PHP_METHOD(Phalcon_Assets_Collection, getRealTargetPath){

	zval *base_path = NULL, *target_path, *complete_path;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &base_path);
	
	if (!base_path) {
		base_path = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(target_path);
	phalcon_read_property_this(&target_path, this_ptr, SL("_targetPath"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(complete_path);
	PHALCON_CONCAT_VV(complete_path, base_path, target_path);
	
	if (phalcon_file_exists(complete_path TSRMLS_CC) == SUCCESS) {
		phalcon_realpath(return_value, complete_path TSRMLS_CC);
		RETURN_MM();
	}
	
	RETURN_CTOR(complete_path);
}

static PHP_METHOD(Phalcon_Assets_Collection, setTargetLocal){

	zval *target_local;

	phalcon_fetch_params(0, 1, 0, &target_local);
	
	phalcon_update_property_this_quick(this_ptr, SL("_targetLocal"), target_local, 321001910UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Collection, getTargetLocal){


	RETURN_MEMBER_QUICK(this_ptr, "_targetLocal", 321001910UL);
}







zend_class_entry *phalcon_assets_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Assets_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Assets, Exception, assets_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_assets_filterinterface_ce;

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_filterinterface_filter, 0, 0, 1)
	ZEND_ARG_INFO(0, content)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_filterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Assets_FilterInterface, filter, arginfo_phalcon_assets_filterinterface_filter)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_FilterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Assets, FilterInterface, assets_filterinterface, phalcon_assets_filterinterface_method_entry);

	return SUCCESS;
}







zend_class_entry *phalcon_assets_manager_ce;

static PHP_METHOD(Phalcon_Assets_Manager, __construct);
static PHP_METHOD(Phalcon_Assets_Manager, setOptions);
static PHP_METHOD(Phalcon_Assets_Manager, getOptions);
static PHP_METHOD(Phalcon_Assets_Manager, useImplicitOutput);
static PHP_METHOD(Phalcon_Assets_Manager, addCss);
static PHP_METHOD(Phalcon_Assets_Manager, addJs);
static PHP_METHOD(Phalcon_Assets_Manager, addResourceByType);
static PHP_METHOD(Phalcon_Assets_Manager, addResource);
static PHP_METHOD(Phalcon_Assets_Manager, set);
static PHP_METHOD(Phalcon_Assets_Manager, get);
static PHP_METHOD(Phalcon_Assets_Manager, getCss);
static PHP_METHOD(Phalcon_Assets_Manager, getJs);
static PHP_METHOD(Phalcon_Assets_Manager, collection);
static PHP_METHOD(Phalcon_Assets_Manager, output);
static PHP_METHOD(Phalcon_Assets_Manager, outputCss);
static PHP_METHOD(Phalcon_Assets_Manager, outputJs);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_setoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_useimplicitoutput, 0, 0, 1)
	ZEND_ARG_INFO(0, implicitOutput)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_addcss, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_addjs, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_addresourcebytype, 0, 0, 2)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, resource)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_addresource, 0, 0, 1)
	ZEND_ARG_INFO(0, resource)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_set, 0, 0, 2)
	ZEND_ARG_INFO(0, id)
	ZEND_ARG_INFO(0, collection)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_get, 0, 0, 1)
	ZEND_ARG_INFO(0, id)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_collection, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_output, 0, 0, 2)
	ZEND_ARG_INFO(0, collection)
	ZEND_ARG_INFO(0, callback)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_outputcss, 0, 0, 0)
	ZEND_ARG_INFO(0, collectionName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_manager_outputjs, 0, 0, 0)
	ZEND_ARG_INFO(0, collectionName)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_manager_method_entry[] = {
	PHP_ME(Phalcon_Assets_Manager, __construct, arginfo_phalcon_assets_manager___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Assets_Manager, setOptions, arginfo_phalcon_assets_manager_setoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, useImplicitOutput, arginfo_phalcon_assets_manager_useimplicitoutput, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, addCss, arginfo_phalcon_assets_manager_addcss, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, addJs, arginfo_phalcon_assets_manager_addjs, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, addResourceByType, arginfo_phalcon_assets_manager_addresourcebytype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, addResource, arginfo_phalcon_assets_manager_addresource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, set, arginfo_phalcon_assets_manager_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, get, arginfo_phalcon_assets_manager_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, getCss, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, getJs, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, collection, arginfo_phalcon_assets_manager_collection, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, output, arginfo_phalcon_assets_manager_output, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, outputCss, arginfo_phalcon_assets_manager_outputcss, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Manager, outputJs, arginfo_phalcon_assets_manager_outputjs, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets, Manager, assets_manager, phalcon_assets_manager_method_entry, 0);

	zend_declare_property_null(phalcon_assets_manager_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_manager_ce, SL("_collections"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_assets_manager_ce, SL("_implicitOutput"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Manager, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Assets_Manager, setOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Options must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Manager, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Assets_Manager, useImplicitOutput){

	zval *implicit_output;

	phalcon_fetch_params(0, 1, 0, &implicit_output);
	
	phalcon_update_property_this_quick(this_ptr, SL("_implicitOutput"), implicit_output, 3405432336UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Manager, addCss){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *type, *resource;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &path, &local, &filter, &attributes);
	
	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (!filter) {
		filter = PHALCON_GLOBAL(z_true);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "css", 1);
	
	PHALCON_INIT_VAR(resource);
	object_init_ex(resource, phalcon_assets_resource_css_ce);
	PHALCON_CALL_METHOD(NULL, resource, "__construct", path, local, filter, attributes);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "addresourcebytype", type, resource);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Manager, addJs){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *type, *resource;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &path, &local, &filter, &attributes);
	
	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (!filter) {
		filter = PHALCON_GLOBAL(z_true);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "js", 1);
	
	PHALCON_INIT_VAR(resource);
	object_init_ex(resource, phalcon_assets_resource_js_ce);
	PHALCON_CALL_METHOD(NULL, resource, "__construct", path, local, filter, attributes);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "addresourcebytype", type, resource);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Manager, addResourceByType){

	zval *type, *resource, *collections, *collection = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &resource);
	
	PHALCON_OBS_VAR(collections);
	phalcon_read_property_this(&collections, this_ptr, SL("_collections"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(collections, type)) {
		PHALCON_OBS_VAR(collection);
		phalcon_array_fetch(&collection, collections, type, PH_NOISY);
	} else {
		PHALCON_INIT_NVAR(collection);
		object_init_ex(collection, phalcon_assets_collection_ce);
		phalcon_update_property_array(this_ptr, SL("_collections"), type, collection TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(NULL, collection, "add", resource);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Manager, addResource){

	zval *resource, *type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &resource);
	
	PHALCON_VERIFY_CLASS_EX(resource, phalcon_assets_resource_ce, phalcon_assets_exception_ce, 1);
	PHALCON_CALL_METHOD(&type, resource, "gettype");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "addresourcebytype", type, resource);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Assets_Manager, set){

	zval *id, *collection;

	phalcon_fetch_params(0, 2, 0, &id, &collection);
	
	if (unlikely(Z_TYPE_P(id) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Collection-Id must be a string");
		return;
	}
	if (unlikely(Z_TYPE_P(collection) != IS_OBJECT)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Collection must be an object");
		return;
	}
	
	phalcon_update_property_array(this_ptr, SL("_collections"), id, collection TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Manager, get){

	zval *id, *collections, *collection;

	phalcon_fetch_params(0, 1, 0, &id);
	
	if (unlikely(Z_TYPE_P(id) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Collection-Id must be a string");
		return;
	}
	
	collections = phalcon_fetch_nproperty_this(this_ptr, SL("_collections"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&collection, collections, id)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "The collection does not exist in the manager");
		return;
	}
	
	RETURN_ZVAL(collection, 1, 0);
}

static PHP_METHOD(Phalcon_Assets_Manager, getCss){

	zval *collections, *collection;

	collections = phalcon_fetch_nproperty_this(this_ptr, SL("_collections"), PH_NOISY TSRMLS_CC);
	
	if (!phalcon_array_isset_string_fetch(&collection, collections, SS("css"))) {
		object_init_ex(return_value, phalcon_assets_collection_ce);
		return;
	}
	
	RETURN_ZVAL(collection, 1, 0);
}

static PHP_METHOD(Phalcon_Assets_Manager, getJs){

	zval *collections, *collection;

	collections = phalcon_fetch_nproperty_this(this_ptr, SL("_collections"), PH_NOISY TSRMLS_CC);
	
	if (!phalcon_array_isset_string_fetch(&collection, collections, SS("js"))) {
		object_init_ex(return_value, phalcon_assets_collection_ce);
		return;
	}
	
	RETURN_ZVAL(collection, 1, 0);
}

static PHP_METHOD(Phalcon_Assets_Manager, collection){

	zval *name, *collections, *collection = NULL;

	phalcon_fetch_params(0, 1, 0, &name);
	
	collections = phalcon_fetch_nproperty_this(this_ptr, SL("_collections"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&collection, collections, name)) {
		RETURN_ZVAL(collection, 1, 0);
	}

	object_init_ex(return_value, phalcon_assets_collection_ce);
	phalcon_update_property_array(this_ptr, SL("_collections"), name, return_value TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Assets_Manager, output){

	zval *collection, *callback, *type = NULL, *output, *use_implicit_output;
	zval *resources = NULL, *filters = NULL, *prefix = NULL, *source_base_path = NULL;
	zval *target_base_path = NULL, *options, *collection_source_path = NULL;
	zval *complete_source_path = NULL, *collection_target_path = NULL;
	zval *complete_target_path = NULL, *filtered_joined_content = NULL;
	zval *join = NULL, *exception_message = NULL, *is_directory;
	zval *resource = NULL, *filter_needed = NULL, *local = NULL, *source_path = NULL;
	zval *target_path = NULL, *path = NULL, *prefixed_path = NULL, *attributes = NULL;
	zval *parameters = NULL, *html = NULL, *content = NULL, *must_filter = NULL;
	zval *filter = NULL, *filtered_content = NULL, *target_uri = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	zval *type_css;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &collection, &callback, &type);
	
	PHALCON_INIT_VAR(output);
	
	PHALCON_OBS_VAR(use_implicit_output);
	phalcon_read_property_this(&use_implicit_output, this_ptr, SL("_implicitOutput"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&resources, collection, "getresources");
	
	PHALCON_CALL_METHOD(&filters, collection, "getfilters");
	
	PHALCON_CALL_METHOD(&prefix, collection, "getprefix");

	PHALCON_INIT_VAR(type_css);
	ZVAL_STRING(type_css, "css", 1);
	
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(source_base_path);
	
		PHALCON_INIT_VAR(target_base_path);
	
		PHALCON_OBS_VAR(options);
		phalcon_read_property_this(&options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(options) == IS_ARRAY) { 
	
			if (phalcon_array_isset_quick_string(options, SS("sourceBasePath"), 4090541534UL)) {
				PHALCON_OBS_NVAR(source_base_path);
				phalcon_array_fetch_quick_string(&source_base_path, options, SS("sourceBasePath"), 4090541534UL, PH_NOISY);
			}
	
			if (phalcon_array_isset_quick_string(options, SS("targetBasePath"), 2556086420UL)) {
				PHALCON_OBS_NVAR(target_base_path);
				phalcon_array_fetch_quick_string(&target_base_path, options, SS("targetBasePath"), 2556086420UL, PH_NOISY);
			}
		}
	
		PHALCON_CALL_METHOD(&collection_source_path, collection, "getsourcepath");
	
		if (PHALCON_IS_NOT_EMPTY(collection_source_path)) {
			PHALCON_INIT_VAR(complete_source_path);
			PHALCON_CONCAT_VV(complete_source_path, source_base_path, collection_source_path);
		} else {
			PHALCON_CPY_WRT(complete_source_path, source_base_path);
		}
	
		PHALCON_CALL_METHOD(&collection_target_path, collection, "gettargetpath");
	
		if (PHALCON_IS_NOT_EMPTY(collection_target_path)) {
			PHALCON_INIT_VAR(complete_target_path);
			PHALCON_CONCAT_VV(complete_target_path, target_base_path, collection_target_path);
		} else {
			PHALCON_CPY_WRT(complete_target_path, target_base_path);
		}
	
		PHALCON_INIT_VAR(filtered_joined_content);
	
		PHALCON_CALL_METHOD(&join, collection, "getjoin");
	
		if (zend_is_true(join)) {
	
			if (PHALCON_IS_EMPTY(complete_target_path)) {
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Path '", complete_target_path, "' is not a valid target path (1)");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_VAR(is_directory);
			phalcon_is_dir(is_directory, complete_target_path TSRMLS_CC);
	
			if (PHALCON_IS_TRUE(is_directory)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Path '", complete_target_path, "' is not a valid target path (2)");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
				return;
			}
		}
	}
	
	phalcon_is_iterable(resources, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(resource);
	
		PHALCON_INIT_NVAR(filter_needed);
		ZVAL_FALSE(filter_needed);

		if (!type) {
			PHALCON_CALL_METHOD(&type, resource, "gettype");
		}

		PHALCON_CALL_METHOD(&local, resource, "getlocal");
	
		if (Z_TYPE_P(filters) == IS_ARRAY) { 
			if (zend_is_true(local)) {

				PHALCON_CALL_METHOD(&source_path, resource, "getrealsourcepath", complete_source_path);

				if (!zend_is_true(source_path)) {
					PHALCON_CALL_METHOD(&source_path, resource, "getpath");

					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Resource '", source_path, "' does not have a valid source path");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CALL_METHOD(&source_path, resource, "getpath");

				PHALCON_INIT_NVAR(filter_needed);
				ZVAL_TRUE(filter_needed);
			}

			PHALCON_CALL_METHOD(&target_path, resource, "getrealtargetpath", complete_target_path);

			if (PHALCON_IS_EMPTY(target_path)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Resource '", source_path, "' does not have a valid target path");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
				return;
			}

			if (zend_is_true(local)) {

				if (PHALCON_IS_EQUAL(target_path, source_path)) {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Resource '", target_path, "' have the same source and target paths");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
					return;
				}
				if (phalcon_file_exists(target_path TSRMLS_CC) == SUCCESS) {
					if (phalcon_compare_mtime(target_path, source_path TSRMLS_CC)) {
						PHALCON_INIT_NVAR(filter_needed);
						ZVAL_TRUE(filter_needed);
					}
				} else {
					PHALCON_INIT_NVAR(filter_needed);
					ZVAL_TRUE(filter_needed);
				}
			}
		}
	
		if (Z_TYPE_P(filters) != IS_ARRAY) { 
			PHALCON_CALL_METHOD(&path, resource, "getrealtargeturi");
			if (Z_TYPE_P(prefix) != IS_NULL) {
				PHALCON_INIT_NVAR(prefixed_path);
				PHALCON_CONCAT_VV(prefixed_path, prefix, path);
			} else {
				PHALCON_CPY_WRT(prefixed_path, path);
			}
	
			PHALCON_CALL_METHOD(&attributes, resource, "getattributes");
	
			PHALCON_INIT_NVAR(parameters);
			array_init_size(parameters, 2);
			if (Z_TYPE_P(attributes) == IS_ARRAY) { 
				phalcon_array_update_long(&attributes, 0, prefixed_path, PH_COPY | PH_SEPARATE);
	
				phalcon_array_append(&parameters, attributes, 0);
			} else {
				phalcon_array_append(&parameters, prefixed_path, 0);
			}

			phalcon_array_append(&parameters, local, 0);
	
			PHALCON_INIT_NVAR(html);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(html, callback, parameters);
	
			if (zend_is_true(use_implicit_output)) {
				zend_print_zval(html, 0);
			} else {
				phalcon_concat_self(&output, html TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}
	
		if (zend_is_true(filter_needed)) {
	
			PHALCON_CALL_METHOD(&content, resource, "getcontent", complete_source_path);
	
			PHALCON_CALL_METHOD(&must_filter, resource, "getfilter");
	
			if (zend_is_true(must_filter)) {
	
				phalcon_is_iterable(filters, &ah1, &hp1, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
					PHALCON_GET_HVALUE(filter);
	
					if (Z_TYPE_P(filter) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_assets_exception_ce, "Filter is invalid");
						return;
					}
	
					PHALCON_CALL_METHOD(&filtered_content, filter, "filter", content);
					PHALCON_CPY_WRT_CTOR(content, filtered_content);

					zend_hash_move_forward_ex(ah1, &hp1);
				}

				if (zend_is_true(join)) {
					if (PHALCON_IS_EQUAL(type, type_css)) {
						if (Z_TYPE_P(filtered_joined_content) == IS_NULL) {
							PHALCON_INIT_NVAR(filtered_joined_content);
							PHALCON_CONCAT_VS(filtered_joined_content, content, "");
						} else {
							PHALCON_SCONCAT_VS(filtered_joined_content, content, "");
						}
					} else {
						if (Z_TYPE_P(filtered_joined_content) == IS_NULL) {
							PHALCON_INIT_NVAR(filtered_joined_content);
							PHALCON_CONCAT_VS(filtered_joined_content, content, ";");
						} else {
							PHALCON_SCONCAT_VS(filtered_joined_content, content, ";");
						}
					}
				}

			} else {
				if (zend_is_true(join)) {
					if (Z_TYPE_P(filtered_joined_content) == IS_NULL) {
						PHALCON_CPY_WRT(filtered_joined_content, content);
					} else {
						phalcon_concat_self(&filtered_joined_content, content TSRMLS_CC);
					}
				} else {
					PHALCON_CPY_WRT(filtered_content, content);
				}
			}
	
			if (!zend_is_true(join)) {
				phalcon_file_put_contents(NULL, target_path, filtered_content TSRMLS_CC);
			}
		}
	
		if (!zend_is_true(join)) {
	
			PHALCON_CALL_METHOD(&path, resource, "getrealtargeturi");
			if (Z_TYPE_P(prefix) != IS_NULL) {
				PHALCON_INIT_NVAR(prefixed_path);
				PHALCON_CONCAT_VV(prefixed_path, prefix, path);
			} else {
				PHALCON_CPY_WRT(prefixed_path, path);
			}
	
			PHALCON_CALL_METHOD(&attributes, resource, "getattributes");
	
			PHALCON_INIT_NVAR(local);
			ZVAL_TRUE(local);
	
			PHALCON_INIT_NVAR(parameters);
			array_init_size(parameters, 2);
			if (Z_TYPE_P(attributes) == IS_ARRAY) { 
				phalcon_array_update_long(&attributes, 0, prefixed_path, PH_COPY | PH_SEPARATE);
	
				phalcon_array_append(&parameters, attributes, 0);
			} else {
				phalcon_array_append(&parameters, prefixed_path, 0);
			}

			phalcon_array_append(&parameters, local, 0);

			PHALCON_INIT_NVAR(html);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(html, callback, parameters);
	
			if (zend_is_true(use_implicit_output)) {
				zend_print_zval(html, 0);
			} else {
				phalcon_concat_self(&output, html TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		if (zend_is_true(join)) {
	
			phalcon_file_put_contents(NULL, complete_target_path, filtered_joined_content TSRMLS_CC);
	
			PHALCON_CALL_METHOD(&target_uri, collection, "gettargeturi");
			if (Z_TYPE_P(prefix) != IS_NULL) {
				PHALCON_INIT_NVAR(prefixed_path);
				PHALCON_CONCAT_VV(prefixed_path, prefix, target_uri);
			} else {
				PHALCON_CPY_WRT(prefixed_path, target_uri);
			}
	
			PHALCON_CALL_METHOD(&attributes, collection, "getattributes");
			PHALCON_CALL_METHOD(&local, collection, "gettargetlocal");
	
			PHALCON_INIT_NVAR(parameters);
			array_init_size(parameters, 2);
			if (Z_TYPE_P(attributes) == IS_ARRAY) { 
				phalcon_array_update_long(&attributes, 0, prefixed_path, PH_COPY | PH_SEPARATE);
	
				phalcon_array_append(&parameters, attributes, 0);
			} else {
				phalcon_array_append(&parameters, prefixed_path, 0);
			}

			phalcon_array_append(&parameters, local, 0);

			PHALCON_INIT_NVAR(html);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(html, callback, parameters);
	
			if (zend_is_true(use_implicit_output)) {
				zend_print_zval(html, 0);
			} else {
				phalcon_concat_self(&output, html TSRMLS_CC);
			}
		}
	}
	
	RETURN_CCTOR(output);
}

static PHP_METHOD(Phalcon_Assets_Manager, outputCss){

	zval *collection_name = NULL, *collection = NULL, *callback, *type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &collection_name);
	
	if (!collection_name || PHALCON_IS_EMPTY(collection_name)) {
		PHALCON_CALL_METHOD(&collection, this_ptr, "getcss");
	} else {
		PHALCON_CALL_METHOD(&collection, this_ptr, "get", collection_name);
	}
	
	PHALCON_INIT_VAR(callback);
	array_init_size(callback, 2);
	add_next_index_stringl(callback, SL("Phalcon\\Tag"), 1);
	add_next_index_stringl(callback, SL("stylesheetLink"), 1);

	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "css", 1);
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "output", collection, callback, type);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Assets_Manager, outputJs){

	zval *collection_name = NULL, *collection = NULL, *callback, *type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &collection_name);
	
	if (!collection_name) {
		collection_name = PHALCON_GLOBAL(z_null);
	}

	if (PHALCON_IS_EMPTY(collection_name)) {
		PHALCON_CALL_METHOD(&collection, this_ptr, "getjs");
	} else {
		PHALCON_CALL_METHOD(&collection, this_ptr, "get", collection_name);
	}
	
	PHALCON_INIT_VAR(callback);
	array_init_size(callback, 2);
	add_next_index_stringl(callback, SL("Phalcon\\Tag"), 1);
	add_next_index_stringl(callback, SL("javascriptInclude"), 1);
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "js", 1);

	PHALCON_RETURN_CALL_METHOD(this_ptr, "output", collection, callback, type);

	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_assets_resource_ce;

static PHP_METHOD(Phalcon_Assets_Resource, __construct);
static PHP_METHOD(Phalcon_Assets_Resource, setType);
static PHP_METHOD(Phalcon_Assets_Resource, getType);
static PHP_METHOD(Phalcon_Assets_Resource, setPath);
static PHP_METHOD(Phalcon_Assets_Resource, getPath);
static PHP_METHOD(Phalcon_Assets_Resource, setLocal);
static PHP_METHOD(Phalcon_Assets_Resource, getLocal);
static PHP_METHOD(Phalcon_Assets_Resource, setFilter);
static PHP_METHOD(Phalcon_Assets_Resource, getFilter);
static PHP_METHOD(Phalcon_Assets_Resource, setAttributes);
static PHP_METHOD(Phalcon_Assets_Resource, getAttributes);
static PHP_METHOD(Phalcon_Assets_Resource, setTargetUri);
static PHP_METHOD(Phalcon_Assets_Resource, getTargetUri);
static PHP_METHOD(Phalcon_Assets_Resource, setSourcePath);
static PHP_METHOD(Phalcon_Assets_Resource, getSourcePath);
static PHP_METHOD(Phalcon_Assets_Resource, setTargetPath);
static PHP_METHOD(Phalcon_Assets_Resource, getTargetPath);
static PHP_METHOD(Phalcon_Assets_Resource, getContent);
static PHP_METHOD(Phalcon_Assets_Resource, getRealTargetUri);
static PHP_METHOD(Phalcon_Assets_Resource, getRealSourcePath);
static PHP_METHOD(Phalcon_Assets_Resource, getRealTargetPath);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_settype, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_setpath, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_setlocal, 0, 0, 1)
	ZEND_ARG_INFO(0, local)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_setfilter, 0, 0, 1)
	ZEND_ARG_INFO(0, filter)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_setattributes, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_settargeturi, 0, 0, 1)
	ZEND_ARG_INFO(0, targetUri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_setsourcepath, 0, 0, 1)
	ZEND_ARG_INFO(0, sourcePath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_settargetpath, 0, 0, 1)
	ZEND_ARG_INFO(0, targetPath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_getcontent, 0, 0, 0)
	ZEND_ARG_INFO(0, basePath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_getrealsourcepath, 0, 0, 0)
	ZEND_ARG_INFO(0, basePath)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_getrealtargetpath, 0, 0, 0)
	ZEND_ARG_INFO(0, basePath)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_resource_method_entry[] = {
	PHP_ME(Phalcon_Assets_Resource, __construct, arginfo_phalcon_assets_resource___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Assets_Resource, setType, arginfo_phalcon_assets_resource_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setPath, arginfo_phalcon_assets_resource_setpath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setLocal, arginfo_phalcon_assets_resource_setlocal, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getLocal, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setFilter, arginfo_phalcon_assets_resource_setfilter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getFilter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setAttributes, arginfo_phalcon_assets_resource_setattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getAttributes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setTargetUri, arginfo_phalcon_assets_resource_settargeturi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getTargetUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setSourcePath, arginfo_phalcon_assets_resource_setsourcepath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getSourcePath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, setTargetPath, arginfo_phalcon_assets_resource_settargetpath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getTargetPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getContent, arginfo_phalcon_assets_resource_getcontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getRealTargetUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getRealSourcePath, arginfo_phalcon_assets_resource_getrealsourcepath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Assets_Resource, getRealTargetPath, arginfo_phalcon_assets_resource_getrealtargetpath, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Resource){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets, Resource, assets_resource, phalcon_assets_resource_method_entry, 0);

	zend_declare_property_null(phalcon_assets_resource_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_path"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_local"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_filter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_attributes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_sourcePath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_targetPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_assets_resource_ce, SL("_targetUri"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Resource, __construct){

	zval *type, *path, *local = NULL, *filter = NULL, *attributes = NULL;

	phalcon_fetch_params(0, 2, 3, &type, &path, &local, &filter, &attributes);
	
	if (!local) {
		local = PHALCON_GLOBAL(z_true);
	}
	
	if (!filter) {
		filter = PHALCON_GLOBAL(z_true);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_path"), path, 3986357393UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_local"), local, 2560221423UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
	if (Z_TYPE_P(attributes) == IS_ARRAY) { 
		phalcon_update_property_this_quick(this_ptr, SL("_attributes"), attributes, 1565778155UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Assets_Resource, setType){

	zval *type;

	phalcon_fetch_params(0, 1, 0, &type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setPath){

	zval *path;

	phalcon_fetch_params(0, 1, 0, &path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_path"), path, 3986357393UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getPath){


	RETURN_MEMBER_QUICK(this_ptr, "_path", 3986357393UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setLocal){

	zval *local;

	phalcon_fetch_params(0, 1, 0, &local);
	
	phalcon_update_property_this_quick(this_ptr, SL("_local"), local, 2560221423UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getLocal){


	RETURN_MEMBER_QUICK(this_ptr, "_local", 2560221423UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setFilter){

	zval *filter;

	phalcon_fetch_params(0, 1, 0, &filter);
	
	phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getFilter){


	RETURN_MEMBER_QUICK(this_ptr, "_filter", 3500594986UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setAttributes){

	zval *attributes;

	phalcon_fetch_params(0, 1, 0, &attributes);
	
	phalcon_update_property_this_quick(this_ptr, SL("_attributes"), attributes, 1565778155UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getAttributes){


	RETURN_MEMBER_QUICK(this_ptr, "_attributes", 1565778155UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setTargetUri){

	zval *target_uri;

	phalcon_fetch_params(0, 1, 0, &target_uri);
	
	phalcon_update_property_this_quick(this_ptr, SL("_targetUri"), target_uri, 2193460699UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getTargetUri){


	RETURN_MEMBER_QUICK(this_ptr, "_targetUri", 2193460699UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setSourcePath){

	zval *source_path;

	phalcon_fetch_params(0, 1, 0, &source_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_sourcePath"), source_path, 1419415746UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getSourcePath){


	RETURN_MEMBER_QUICK(this_ptr, "_targetPath", 3658201208UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, setTargetPath){

	zval *target_path;

	phalcon_fetch_params(0, 1, 0, &target_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_targetPath"), target_path, 3658201208UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Assets_Resource, getTargetPath){


	RETURN_MEMBER_QUICK(this_ptr, "_sourcePath", 1419415746UL);
}

static PHP_METHOD(Phalcon_Assets_Resource, getContent){

	zval *base_path = NULL, *source_path = NULL, *complete_path;
	zval *local, *exception_message = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &base_path);
	
	if (!base_path) {
		base_path = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(source_path);
	phalcon_read_property_this(&source_path, this_ptr, SL("_sourcePath"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_EMPTY(source_path)) {
		PHALCON_OBS_NVAR(source_path);
		phalcon_read_property_this(&source_path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(complete_path);
	PHALCON_CONCAT_VV(complete_path, base_path, source_path);
	
	PHALCON_OBS_VAR(local);
	phalcon_read_property_this(&local, this_ptr, SL("_local"), PH_NOISY TSRMLS_CC);
	
	if (zend_is_true(local)) {
	
		if (phalcon_file_exists(complete_path TSRMLS_CC) == FAILURE) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Resource's content for \"", complete_path, "\" cannot be loaded");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
			return;
		}
	}
	
	phalcon_file_get_contents(return_value, complete_path TSRMLS_CC);
	if (PHALCON_IS_FALSE(return_value)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Resource's content for \"", complete_path, "\" cannot be read");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_assets_exception_ce, exception_message);
		return;
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Assets_Resource, getRealTargetUri){

	zval *target_uri;

	target_uri = phalcon_fetch_nproperty_this(this_ptr, SL("_targetUri"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_EMPTY(target_uri)) {
		target_uri = phalcon_fetch_nproperty_this(this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	}
	
	RETURN_ZVAL(target_uri, 1, 0);
}

static PHP_METHOD(Phalcon_Assets_Resource, getRealSourcePath){

	zval *base_path = NULL, *source_path = NULL, *local, *complete_path;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &base_path);
	
	if (!base_path) {
		base_path = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(source_path);
	phalcon_read_property_this(&source_path, this_ptr, SL("_sourcePath"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_EMPTY(source_path)) {
		PHALCON_OBS_NVAR(source_path);
		phalcon_read_property_this(&source_path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(local);
	phalcon_read_property_this(&local, this_ptr, SL("_local"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(local)) {
		PHALCON_INIT_VAR(complete_path);
		PHALCON_CONCAT_VV(complete_path, base_path, source_path);
	
		phalcon_realpath(return_value, complete_path TSRMLS_CC);
		RETURN_MM();
	}
	
	RETURN_CCTOR(source_path);
}

static PHP_METHOD(Phalcon_Assets_Resource, getRealTargetPath){

	zval *base_path = NULL, *target_path = NULL, *local, *complete_path;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &base_path);
	
	if (!base_path) {
		base_path = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(target_path);
	phalcon_read_property_this(&target_path, this_ptr, SL("_targetPath"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_EMPTY(target_path)) {
		PHALCON_OBS_NVAR(target_path);
		phalcon_read_property_this(&target_path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(local);
	phalcon_read_property_this(&local, this_ptr, SL("_local"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(local)) {
	
		PHALCON_INIT_VAR(complete_path);
		PHALCON_CONCAT_VV(complete_path, base_path, target_path);
	
		if (phalcon_file_exists(complete_path TSRMLS_CC) == SUCCESS) {
			phalcon_realpath(return_value, complete_path TSRMLS_CC);
			RETURN_MM();
		}
	
		RETURN_CTOR(complete_path);
	}
	
	RETURN_CCTOR(target_path);
}




#ifdef PHALCON_NON_FREE
#else
#endif


zend_class_entry *phalcon_assets_filters_cssmin_ce;

static PHP_METHOD(Phalcon_Assets_Filters_Cssmin, filter);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_filters_cssmin_filter, 0, 0, 1)
	ZEND_ARG_INFO(0, content)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_filters_cssmin_method_entry[] = {
	PHP_ME(Phalcon_Assets_Filters_Cssmin, filter, arginfo_phalcon_assets_filters_cssmin_filter, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Filters_Cssmin){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets\\Filters, Cssmin, assets_filters_cssmin, phalcon_assets_filters_cssmin_method_entry, 0);

	zend_class_implements(phalcon_assets_filters_cssmin_ce TSRMLS_CC, 1, phalcon_assets_filterinterface_ce);
	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Filters_Cssmin, filter){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	if (phalcon_cssmin(return_value, content TSRMLS_CC) == FAILURE) {
		return;
	}
}


/* cssmin.c

Copyright (c) 2010  (www.ryanday.org)

w3c css spec: http://www.w3.org/TR/CSS2/syndata.html
this parser makes no attempt to understand css as such it does not interpret css to spec.

** cannot handle nested { blocks but will ignore aditional { in parens ()
** no in quote detection for ( or }

function get, peek and general lookahead structure taken from..

jsmin.c

Copyright (c) 2002 Douglas Crockford  (www.crockford.com)


Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#ifdef PHALCON_NON_FREE

#include <ext/standard/php_smart_str.h>



#define STATE_FREE 1
#define STATE_ATRULE 2
#define STATE_SELECTOR 3
#define STATE_BLOCK 4
#define STATE_DECLARATION 5
#define STATE_COMMENT 6

typedef struct _cssmin_parser {
	int tmp_state;
	int state;
	int last_state;
	int in_paren;
	zval *style;
	const char *error;
	smart_str *minified;
	int style_pointer;
} cssmin_parser;

/* get -- return the next character from stdin. Watch out for lookahead. If
the character is a control character, translate it to a space or
linefeed.
*/

static char cssmin_peek(cssmin_parser *parser){
	char ch;
	if (parser->style_pointer < Z_STRLEN_P(parser->style)) {
		ch = Z_STRVAL_P(parser->style)[parser->style_pointer];
		return ch;
	}
	return EOF;
}

static char cssmin_back_peek(cssmin_parser *parser){
	char ch;
	if (parser->style_pointer > 1) {
		ch = Z_STRVAL_P(parser->style)[parser->style_pointer - 1];
		return ch;
	}
	return EOF;
}

/* machine

*/
static int phalcon_cssmin_machine(cssmin_parser *parser, unsigned char c TSRMLS_DC){

	unsigned char p;

	if (parser->state != STATE_COMMENT) {
		if (c == '/' && cssmin_peek(parser) == '*') {
			parser->tmp_state = parser->state;
			parser->state = STATE_COMMENT;
		}
	}

	switch (parser->state) {
		case STATE_FREE:
			if (c == ' ' && c == '\t' && c == '\n' && c == '\r') {
				c = 0;
			} else if (c == '@'){
				parser->state = STATE_ATRULE;
				break;
			} else if(c > 0){
				//fprintf(stdout,"one to 3 - %c %i",c,c);
				parser->state = STATE_SELECTOR;
			}
			/* no break */
		case STATE_SELECTOR:
			if (c == '{') {
				parser->state = STATE_BLOCK;
			} else {
				if(c == '\n' || c == '\r') {
					c = 0;
				} else {
					if(c == '@'){
						parser->state = STATE_ATRULE;
					} else {
						if ((c == ' ' || c == '\t')) {
							p = cssmin_peek(parser);
							if (p == '{' || p == '\t' || p == ' ' || p == '>' || p == ',') {
								c = 0;
							} else {
								p = cssmin_back_peek(parser);
								if (p == ',' || p == '>' || p == ':') {
									c = 0;
								} else {
									c = ' ';
								}
							}
						}
					}
				}
			}
			break;
		case STATE_ATRULE:
			/* support
				@import etc.
				@font-face{
			*/
			if (c == '\r' || c == '\n' || c == ';') {
				c = ';';
				parser->state = STATE_FREE;
			} else {
				if(c == '{') {
					parser->state = STATE_BLOCK;
				}
			}
			break;
		case STATE_BLOCK:
			if (c == ' ' || c == '\t' || c == '\n' || c == '\r' ) {
				c = 0;
				break;
			} else {
				if (c == '}') {
					parser->state = STATE_FREE;
					//fprintf(stdout,"closing bracket found in block\n");
					break;
				} else {
					parser->state = STATE_DECLARATION;
				}
			}
			/* no break */
		case STATE_DECLARATION:
			if (c == '(') {
				parser->in_paren = 1;
			}
			if (parser->in_paren == 0) {
				if (c == ';') {
					parser->state = STATE_BLOCK;
					if (cssmin_peek(parser) == '}') {
						c = 0;
					}
				} else if (c == '}') {
					parser->state = STATE_FREE;
				} else {
					if (c == '\n' || c == '\r') {
					  c = 0;
					} else {
						if (c == ' ' || c == '\t') {
							p = cssmin_peek(parser);
							if (p == ' ' || p == '\t') {
								c = 0;
							} else {
								c = ' ';
							}
						}
					}
				}

			} else {
				if (c == ')') {
					parser->in_paren = 0;
				}
			}

			break;
		case STATE_COMMENT:
			if (c == '*' && cssmin_peek(parser) == '/'){
				parser->style_pointer += 2;
				parser->state = parser->tmp_state;
			}
			c = 0;
			break;
	}

	return c;
}

static int phalcon_cssmin_internal(zval *return_value, zval *style, const char **error TSRMLS_DC) {

	int i;
	unsigned char c;
	cssmin_parser parser;
	smart_str minified = {0};

	parser.tmp_state = 0;
	parser.state = 1;
	parser.last_state = 1;
	parser.in_paren = 0;
	parser.style = style;
	parser.error = NULL;
	parser.minified = &minified;

	for (i = 0; i < Z_STRLEN_P(style); i++) {
		parser.style_pointer = i + 1;
		c = phalcon_cssmin_machine(&parser, Z_STRVAL_P(style)[i] TSRMLS_CC);
		if (c != 0) {
			smart_str_appendc(parser.minified, c);
		}
		i = parser.style_pointer - 1;
	}

	smart_str_0(&minified);

	if (minified.len) {
		ZVAL_STRINGL(return_value, minified.c, minified.len, 0);
	} else {
		ZVAL_EMPTY_STRING(return_value);
	}

	*error = parser.error;
	return SUCCESS;
}

/* cssmin -- minify the css
	removes comments
	removes newlines and line feeds keeping
	removes last semicolon from last property
*/

static int phalcon_cssmin(zval *return_value, zval *style TSRMLS_DC) {

	const char *error = NULL;

	ZVAL_NULL(return_value);

	if (Z_TYPE_P(style) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Style must be a string");
		return FAILURE;
	}

	if (phalcon_cssmin_internal(return_value, style, &error TSRMLS_CC) == FAILURE) {
		if (error) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, error);
		} else {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Unknown error");
		}

		return FAILURE;
	}

	return SUCCESS;
}
#endif




#ifdef PHALCON_NON_FREE
#else
#endif


zend_class_entry *phalcon_assets_filters_jsmin_ce;

static PHP_METHOD(Phalcon_Assets_Filters_Jsmin, filter);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_filters_jsmin_filter, 0, 0, 1)
	ZEND_ARG_INFO(0, content)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_filters_jsmin_method_entry[] = {
	PHP_ME(Phalcon_Assets_Filters_Jsmin, filter, arginfo_phalcon_assets_filters_jsmin_filter, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Filters_Jsmin){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets\\Filters, Jsmin, assets_filters_jsmin, phalcon_assets_filters_jsmin_method_entry, 0);

	zend_class_implements(phalcon_assets_filters_jsmin_ce TSRMLS_CC, 1, phalcon_assets_filterinterface_ce);
	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Filters_Jsmin, filter){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	if (phalcon_jsmin(return_value, content TSRMLS_CC) == FAILURE) {
		return;
	}
}



/* jsmin.c
   2013-03-29

Copyright (c) 2002 Douglas Crockford  (www.crockford.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/


#ifdef PHALCON_NON_FREE

#include <ext/standard/php_smart_str.h>



#define JSMIN_ACTION_OUTPUT_NEXT 1
#define JSMIN_ACTION_NEXT_DELETE 2
#define JSMIN_ACTION_NEXT 3

typedef struct _jsmin_parser {
	zval *script;
	const char *error;
	int script_pointer;
	int inside_string;
	smart_str *minified;
	unsigned char theA;
	unsigned char theB;
	unsigned char theC;
	unsigned char theX;
	unsigned char theY;
} jsmin_parser;

static void jsmin_error(jsmin_parser *parser, const char* s, int s_length TSRMLS_DC)
{
	parser->error = s;
}

/* isAlphanum -- return true if the character is a letter, digit, underscore,
		dollar sign, or non-ASCII character.
*/

static int jsmin_isAlphanum(int c) {
	return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\' || c > 126);
}


/* get -- return the next character from stdin. Watch out for lookahead. If
		the character is a control character, translate it to a space or
		linefeed.
*/

static unsigned char jsmin_peek(jsmin_parser *parser){
	unsigned char ch;
	if (parser->script_pointer < Z_STRLEN_P(parser->script)) {
		ch = Z_STRVAL_P(parser->script)[parser->script_pointer];
		return ch;
	}
	return '\0';
}

static unsigned char jsmin_get(jsmin_parser *parser) {

	unsigned char c;

	if (parser->script_pointer < Z_STRLEN_P(parser->script)) {
		c = Z_STRVAL_P(parser->script)[parser->script_pointer];
		parser->script_pointer++;
	} else {
		c = '\0';
	}

	parser->theC = c;

	if (parser->inside_string == 1) {
		if (c >= ' ' || c == '\n' || c == '\t' || c == '\0') {
			return c;
		}
	} else {
		if (c >= ' ' || c == '\n' || c == '\0') {
			return c;
		}
	}
	if (c == '\r') {
		return '\n';
	}
	return ' ';
}


/* next -- get the next character, excluding comments. peek() is used to see
		if a '/' is followed by a '/' or '*'.
*/

static int jsmin_next(jsmin_parser *parser TSRMLS_DC) {
	unsigned char c = jsmin_get(parser);
	if  (c == '/') {
		switch (jsmin_peek(parser)) {
			case '/':
				for (;;) {
					c = jsmin_get(parser);
					if (c <= '\n') {
						break;
					}
				}
				break;
		case '*':
			jsmin_get(parser);
			while (c != ' ') {
				switch (jsmin_get(parser)) {
					case '*':
						if (jsmin_peek(parser) == '/') {
							jsmin_get(parser);
							c = ' ';
						}
						break;
					case '\0':
						jsmin_error(parser, SL("Unterminated comment.") TSRMLS_CC);
						return FAILURE;
				}
			}
			break;
		}
	}
	parser->theY = parser->theX;
	parser->theX = c;
	return c;
}

/* action -- do something! What you do is determined by the argument:
		1   Output A. Copy B to A. Get the next B.
		2   Copy B to A. Get the next B. (Delete A).
		3   Get the next B. (Delete B).
   action treats a string as a single character. Wow!
   action recognizes a regular expression if it is preceded by ( or , or =.
*/

static int jsmin_action(jsmin_parser *parser, unsigned char d TSRMLS_DC) {
	switch (d) {
		case JSMIN_ACTION_OUTPUT_NEXT:
			smart_str_appendc(parser->minified, parser->theA);
			if (
				(parser->theY == '\n' || parser->theY == ' ') &&
				(parser->theA == '+' || parser->theA == '-' || parser->theA == '*' || parser->theA == '/') &&
				(parser->theB == '+' || parser->theB == '-' || parser->theB == '*' || parser->theB == '/')
			) {
				smart_str_appendc(parser->minified, parser->theY);
			}
			/* no break */
		case JSMIN_ACTION_NEXT_DELETE:
			parser->theA = parser->theB;
			if (parser->theA == '\'' || parser->theA == '"' || parser->theA == '`') {
				parser->inside_string = 1;
				for (;;) {
					smart_str_appendc(parser->minified, parser->theA);
					parser->theA = jsmin_get(parser);
					if (parser->theA == parser->theB) {
						break;
					}
					if (parser->theA == '\\') {
						smart_str_appendc(parser->minified, parser->theA);
						parser->theA = jsmin_get(parser);
					}
					if (parser->theA == '\0') {
						jsmin_error(parser, SL("Unterminated string literal.") TSRMLS_CC);
						return FAILURE;
					}
				}
				parser->inside_string = 0;
			}
			/* no break */
		case JSMIN_ACTION_NEXT:
			parser->theB = jsmin_next(parser TSRMLS_CC);
			if (parser->error != NULL) {
				return FAILURE;
			}
			if (parser->theB == '/' && (
				parser->theA == '(' || parser->theA == ',' || parser->theA == '=' || parser->theA == ':' ||
				parser->theA == '[' || parser->theA == '!' || parser->theA == '&' || parser->theA == '|' ||
				parser->theA == '?' || parser->theA == '+' || parser->theA == '-' || parser->theA == '~' ||
				parser->theA == '*' || parser->theA == '/' || parser->theA == '{' || parser->theA == '\n'
			)) {
				smart_str_appendc(parser->minified, parser->theA);
				if (parser->theA == '/' || parser->theA == '*') {
					smart_str_appendc(parser->minified, ' ');
				}
				smart_str_appendc(parser->minified, parser->theB);
				for (;;) {
					parser->theA = jsmin_get(parser);
					if (parser->theA == '[') {
						for (;;) {
							smart_str_appendc(parser->minified, parser->theA);
							parser->theA = jsmin_get(parser);
							if (parser->theA == ']') {
								break;
							}
							if (parser->theA == '\\') {
								smart_str_appendc(parser->minified, parser->theA);
								parser->theA = jsmin_get(parser);
							}
							if (parser->theA == '\0') {
								jsmin_error(parser, SL("Unterminated set in Regular Expression literal.") TSRMLS_CC);
								return FAILURE;
							}
						}
					} else {
						if (parser->theA == '/') {
							switch (jsmin_peek(parser)) {
								case '/':
								case '*':
									jsmin_error(parser, SL("Unterminated set in Regular Expression literal.") TSRMLS_CC);
									return FAILURE;
							}
							break;
						} else {
							if (parser->theA == '\\') {
								smart_str_appendc(parser->minified, parser->theA);
								parser->theA = jsmin_get(parser);
							}
						}
					}
					if (parser->theA == '\0') {
						jsmin_error(parser, SL("Unterminated Regular Expression literal.") TSRMLS_CC);
						return FAILURE;
					}
					smart_str_appendc(parser->minified, parser->theA);
				}
				parser->theB = jsmin_next(parser TSRMLS_CC);
				if (parser->error != NULL) {
					return FAILURE;
				}
			}
	}

	return SUCCESS;
}


/* jsmin -- Copy the input to the output, deleting the characters which are
		insignificant to JavaScript. Comments will be removed. Tabs will be
		replaced with spaces. Carriage returns will be replaced with linefeeds.
		Most spaces and linefeeds will be removed.
*/

static int phalcon_jsmin_internal(zval *return_value, zval *script, const char **error TSRMLS_DC) {

	jsmin_parser parser;
	smart_str minified = {0};
	int status = SUCCESS;

	parser.theA = '\n';
	parser.theX = '\0';
	parser.theY = '\0';
	parser.script = script;
	parser.error = NULL;
	parser.script_pointer = 0;
	parser.inside_string = 0;
	parser.minified = &minified;

	if (jsmin_action(&parser, JSMIN_ACTION_NEXT TSRMLS_CC) == FAILURE) {
		*error = parser.error;
		return FAILURE;
	}

	while (parser.theA != '\0') {
		if (status == FAILURE) {
			break;
		}
		switch (parser.theA) {
			case ' ':
				if (jsmin_action(&parser, jsmin_isAlphanum(parser.theB) ? JSMIN_ACTION_OUTPUT_NEXT : JSMIN_ACTION_NEXT_DELETE TSRMLS_CC)) {
					status = FAILURE;
					break;
				}
				break;
			case '\n':
				switch (parser.theB) {
					case '{':
					case '[':
					case '(':
					case '+':
					case '-':
					case '!':
					case '~':
						if (jsmin_action(&parser, JSMIN_ACTION_OUTPUT_NEXT TSRMLS_CC) == FAILURE) {
							status = FAILURE;
							break;
						}
						break;
					case ' ':
						if (jsmin_action(&parser, JSMIN_ACTION_NEXT TSRMLS_CC) == FAILURE) {
							status = FAILURE;
							break;
						}
						break;
					default:
						if (jsmin_action(&parser, jsmin_isAlphanum(parser.theB) ? JSMIN_ACTION_OUTPUT_NEXT : JSMIN_ACTION_NEXT_DELETE TSRMLS_CC) == FAILURE) {
							status = FAILURE;
							break;
						}
				}
				break;
			default:
				switch (parser.theB) {
					case ' ':
						if (jsmin_action(&parser, jsmin_isAlphanum(parser.theA) ? JSMIN_ACTION_OUTPUT_NEXT : JSMIN_ACTION_NEXT TSRMLS_CC) == FAILURE) {
							status = FAILURE;
							break;
						}
						break;
					case '\n':
						switch (parser.theA) {
							case '}':
							case ']':
							case ')':
							case '+':
							case '-':
							case '"':
							case '\'':
							case '`':
								if (jsmin_action(&parser, JSMIN_ACTION_OUTPUT_NEXT TSRMLS_CC) == FAILURE) {
									status = FAILURE;
									break;
								}
								break;
							default:
								if (jsmin_action(&parser, jsmin_isAlphanum(parser.theA) ? JSMIN_ACTION_OUTPUT_NEXT : JSMIN_ACTION_NEXT TSRMLS_CC) == FAILURE) {
									status = FAILURE;
									break;
								}
							}
							break;
					default:
						if (jsmin_action(&parser, JSMIN_ACTION_OUTPUT_NEXT TSRMLS_CC) == FAILURE) {
							status = FAILURE;
							break;
						}
						break;
				}
		}
	}

	if (status == FAILURE) {
		smart_str_free(&minified);
		*error = parser.error;
		return FAILURE;
	}

	smart_str_0(&minified);

	if (minified.len) {
		ZVAL_STRINGL(return_value, minified.c, minified.len, 0);
	} else {
		ZVAL_STRING(return_value, "", 1);
	}

	return SUCCESS;
}

static int phalcon_jsmin(zval *return_value, zval *script TSRMLS_DC) {

	const char *error = NULL;

	ZVAL_NULL(return_value);

	if (Z_TYPE_P(script) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Script must be a string");
		return FAILURE;
	}

	if (phalcon_jsmin_internal(return_value, script, &error TSRMLS_CC) == FAILURE){
		if (error) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, error);
		} else {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Unknown error");
		}

		return FAILURE;
	}

	return SUCCESS;
}
#endif



/* placeholder for non-free csssminifier.c */


#ifndef PHALCON_NON_FREE


static int phalcon_cssmin(zval *return_value, zval *style TSRMLS_DC) {

	PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Non-free csssminifier not available");
	return FAILURE;
}
#endif



/* placeholder for non-free jsminifier.c */


#ifndef PHALCON_NON_FREE


static int phalcon_jsmin(zval *return_value, zval *script TSRMLS_DC) {

	PHALCON_THROW_EXCEPTION_STRW(phalcon_assets_exception_ce, "Non-free jsminifier not available");
	return FAILURE;
}

#endif






zend_class_entry *phalcon_assets_filters_none_ce;

static PHP_METHOD(Phalcon_Assets_Filters_None, filter);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_filters_none_filter, 0, 0, 1)
	ZEND_ARG_INFO(0, content)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_filters_none_method_entry[] = {
	PHP_ME(Phalcon_Assets_Filters_None, filter, arginfo_phalcon_assets_filters_none_filter, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Filters_None){

	PHALCON_REGISTER_CLASS(Phalcon\\Assets\\Filters, None, assets_filters_none, phalcon_assets_filters_none_method_entry, 0);

	zend_class_implements(phalcon_assets_filters_none_ce TSRMLS_CC, 1, phalcon_assets_filterinterface_ce);
	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Filters_None, filter){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	RETURN_CTORW(content);
}







zend_class_entry *phalcon_assets_resource_css_ce;

static PHP_METHOD(Phalcon_Assets_Resource_Css, __construct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_css___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_resource_css_method_entry[] = {
	PHP_ME(Phalcon_Assets_Resource_Css, __construct, arginfo_phalcon_assets_resource_css___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Resource_Css){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Assets\\Resource, Css, assets_resource_css, phalcon_assets_resource_ce, phalcon_assets_resource_css_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Resource_Css, __construct){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *type;

	phalcon_fetch_params(0, 1, 3, &path, &local, &filter, &attributes);
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_STRING(type, "css", 1);
	
	PHALCON_CALL_PARENTW(NULL,
		phalcon_assets_resource_css_ce, this_ptr, "__construct",
		type, path,
		(local ? local : PHALCON_GLOBAL(z_true)),
		(filter ? filter : PHALCON_GLOBAL(z_true)),
		(attributes ? attributes : PHALCON_GLOBAL(z_null))
	);
}







zend_class_entry *phalcon_assets_resource_js_ce;

static PHP_METHOD(Phalcon_Assets_Resource_Js, __construct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_assets_resource_js___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, local)
	ZEND_ARG_INFO(0, filter)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_assets_resource_js_method_entry[] = {
	PHP_ME(Phalcon_Assets_Resource_Js, __construct, arginfo_phalcon_assets_resource_js___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Assets_Resource_Js){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Assets\\Resource, Js, assets_resource_js, phalcon_assets_resource_ce, phalcon_assets_resource_js_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Assets_Resource_Js, __construct){

	zval *path, *local = NULL, *filter = NULL, *attributes = NULL, *type;

	phalcon_fetch_params(0, 1, 3, &path, &local, &filter, &attributes);
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_STRING(type, "js", 1);
	
	PHALCON_CALL_PARENTW(NULL,
		phalcon_assets_resource_js_ce, this_ptr, "__construct",
		type, path,
		(local ? local : PHALCON_GLOBAL(z_true)),
		(filter ? filter : PHALCON_GLOBAL(z_true)),
		(attributes ? attributes : PHALCON_GLOBAL(z_null))
	);
}






zend_class_entry *phalcon_cache_backend_ce;

static PHP_METHOD(Phalcon_Cache_Backend, __construct);
static PHP_METHOD(Phalcon_Cache_Backend, start);
static PHP_METHOD(Phalcon_Cache_Backend, stop);
static PHP_METHOD(Phalcon_Cache_Backend, getFrontend);
static PHP_METHOD(Phalcon_Cache_Backend, getOptions);
static PHP_METHOD(Phalcon_Cache_Backend, isFresh);
static PHP_METHOD(Phalcon_Cache_Backend, isStarted);
static PHP_METHOD(Phalcon_Cache_Backend, setLastKey);
static PHP_METHOD(Phalcon_Cache_Backend, getLastKey);
static PHP_METHOD(Phalcon_Cache_Backend, getLifetime);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend, __construct, arginfo_phalcon_cache_backend___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend, start, arginfo_phalcon_cache_backendinterface_start, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, stop, arginfo_phalcon_cache_backendinterface_stop, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, getFrontend, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, isFresh, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, isStarted, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, setLastKey, arginfo_phalcon_cache_backendinterface_setlastkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, getLastKey, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend, getLifetime, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache, Backend, cache_backend, phalcon_cache_backend_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_cache_backend_ce, SL("_frontend"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_backend_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cache_backend_ce, SL("_lastKey"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_backend_ce, SL("_lastLifetime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_fresh"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_cache_backend_ce, SL("_started"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend, __construct){

	zval *frontend, *options = NULL, *prefix;

	phalcon_fetch_params(0, 1, 1, &frontend, &options);
	
	PHALCON_VERIFY_INTERFACE_EX(frontend, phalcon_cache_frontendinterface_ce, phalcon_cache_exception_ce, 0);

	if (options) {
		if (phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
		}

		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_frontend"), frontend, 3187914628UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Cache_Backend, start){

	zval *key_name, *lifetime = NULL, *fresh = NULL;
	zval *frontend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	if (!lifetime) {
		lifetime = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "get", key_name, lifetime);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_TYPE_P(return_value) == IS_NULL) {
		fresh = PHALCON_GLOBAL(z_true);
	
		frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
		PHALCON_CALL_METHOD(NULL, frontend, "start");
	} else {
		fresh = PHALCON_GLOBAL(z_false);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_fresh"), fresh, 2329058172UL TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_started"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
	
	if (Z_TYPE_P(lifetime) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_lastLifetime"), lifetime, 3936785351UL TSRMLS_CC);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend, stop){

	zval *stop_buffer = NULL, *frontend;

	phalcon_fetch_params(0, 0, 1, &stop_buffer);
	
	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_MM_GROW();
		frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
		PHALCON_MM_RESTORE();
	}

	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Cache_Backend, getFrontend){


	RETURN_MEMBER_QUICK(this_ptr, "_frontend", 3187914628UL);
}

static PHP_METHOD(Phalcon_Cache_Backend, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Cache_Backend, isFresh){


	RETURN_MEMBER_QUICK(this_ptr, "_fresh", 2329058172UL);
}

static PHP_METHOD(Phalcon_Cache_Backend, isStarted){


	RETURN_MEMBER_QUICK(this_ptr, "_started", 433407867UL);
}

static PHP_METHOD(Phalcon_Cache_Backend, setLastKey){

	zval *last_key;

	phalcon_fetch_params(0, 1, 0, &last_key);
	
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), last_key, 394299009UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Cache_Backend, getLastKey){


	RETURN_MEMBER_QUICK(this_ptr, "_lastKey", 394299009UL);
}

static PHP_METHOD(Phalcon_Cache_Backend, getLifetime){


	RETURN_MEMBER_QUICK(this_ptr, "_lastLifetime", 3936785351UL);
}





zend_class_entry *phalcon_cache_backendinterface_ce;

static const zend_function_entry phalcon_cache_backendinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, start, arginfo_phalcon_cache_backendinterface_start)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, stop, arginfo_phalcon_cache_backendinterface_stop)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, getFrontend, NULL)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, getOptions, NULL)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, isFresh, NULL)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, isStarted, NULL)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, setLastKey, arginfo_phalcon_cache_backendinterface_setlastkey)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, getLastKey, NULL)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, get, arginfo_phalcon_cache_backendinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, save, arginfo_phalcon_cache_backendinterface_save)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, delete, arginfo_phalcon_cache_backendinterface_delete)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, exists, arginfo_phalcon_cache_backendinterface_exists)
	PHP_ABSTRACT_ME(Phalcon_Cache_BackendInterface, flush, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_BackendInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Cache, BackendInterface, cache_backendinterface, phalcon_cache_backendinterface_method_entry);

	return SUCCESS;
}





















zend_class_entry *phalcon_cache_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Cache_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache, Exception, cache_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_cache_frontendinterface_ce;

static const zend_function_entry phalcon_cache_frontendinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, getLifetime, arginfo_phalcon_cache_frontendinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, isBuffering, arginfo_phalcon_cache_frontendinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, start, arginfo_phalcon_cache_frontendinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, getContent, arginfo_phalcon_cache_frontendinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, stop, arginfo_phalcon_cache_frontendinterface_empty)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore)
	PHP_ABSTRACT_ME(Phalcon_Cache_FrontendInterface, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Cache_FrontendInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Cache, FrontendInterface, cache_frontendinterface, phalcon_cache_frontendinterface_method_entry);

	return SUCCESS;
}













zend_class_entry *phalcon_cache_multiple_ce;

static PHP_METHOD(Phalcon_Cache_Multiple, __construct);
static PHP_METHOD(Phalcon_Cache_Multiple, push);
static PHP_METHOD(Phalcon_Cache_Multiple, get);
static PHP_METHOD(Phalcon_Cache_Multiple, start);
static PHP_METHOD(Phalcon_Cache_Multiple, save);
static PHP_METHOD(Phalcon_Cache_Multiple, delete);
static PHP_METHOD(Phalcon_Cache_Multiple, exists);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, backends)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_push, 0, 0, 1)
	ZEND_ARG_INFO(0, backend)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_get, 0, 0, 1)
	ZEND_ARG_INFO(0, keyName)
	ZEND_ARG_INFO(0, lifetime)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_start, 0, 0, 1)
	ZEND_ARG_INFO(0, keyName)
	ZEND_ARG_INFO(0, lifetime)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_save, 0, 0, 0)
	ZEND_ARG_INFO(0, keyName)
	ZEND_ARG_INFO(0, content)
	ZEND_ARG_INFO(0, lifetime)
	ZEND_ARG_INFO(0, stopBuffer)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_delete, 0, 0, 1)
	ZEND_ARG_INFO(0, keyName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_multiple_exists, 0, 0, 0)
	ZEND_ARG_INFO(0, keyName)
	ZEND_ARG_INFO(0, lifetime)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_multiple_method_entry[] = {
	PHP_ME(Phalcon_Cache_Multiple, __construct, arginfo_phalcon_cache_multiple___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Multiple, push, arginfo_phalcon_cache_multiple_push, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Multiple, get, arginfo_phalcon_cache_multiple_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Multiple, start, arginfo_phalcon_cache_multiple_start, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Multiple, save, arginfo_phalcon_cache_multiple_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Multiple, delete, arginfo_phalcon_cache_multiple_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Multiple, exists, arginfo_phalcon_cache_multiple_exists, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Multiple){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache, Multiple, cache_multiple, phalcon_cache_multiple_method_entry, 0);

	zend_declare_property_null(phalcon_cache_multiple_ce, SL("_backends"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Multiple, __construct){

	zval *backends = NULL;

	phalcon_fetch_params(0, 0, 1, &backends);
	
	if (!backends) {
		backends = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(backends) != IS_NULL) {
		if (Z_TYPE_P(backends) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STRW(phalcon_cache_exception_ce, "The backends must be an array");
			return;
		}
		phalcon_update_property_this_quick(this_ptr, SL("_backends"), backends, 2548946143UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Cache_Multiple, push){

	zval *backend;

	phalcon_fetch_params(0, 1, 0, &backend);
	
	PHALCON_VERIFY_INTERFACE_EX(backend, phalcon_cache_backendinterface_ce, phalcon_cache_exception_ce, 0)
	phalcon_update_property_array_append(this_ptr, SL("_backends"), backend TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Cache_Multiple, get){

	zval *key_name, *lifetime = NULL, *backends;
	zval *content = NULL;
	HashPosition hp0;
	zval **backend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	if (!lifetime) {
		lifetime = PHALCON_GLOBAL(z_null);
	}
	
	backends = phalcon_fetch_nproperty_this(this_ptr, SL("_backends"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(backends) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(backends), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(backends), (void**)&backend, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(backends), &hp0)
		) {
			PHALCON_CALL_METHOD(&content, *backend, "get", key_name, lifetime);
			if (Z_TYPE_P(content) != IS_NULL) {
				RETURN_CCTOR(content);
			}
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Cache_Multiple, start){

	zval *key_name, *lifetime = NULL, *backends;
	HashPosition hp0;
	zval **backend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	if (!lifetime) {
		lifetime = PHALCON_GLOBAL(z_null);
	}
	
	backends = phalcon_fetch_nproperty_this(this_ptr, SL("_backends"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(backends) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(backends), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(backends), (void**)&backend, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(backends), &hp0)
		) {
			PHALCON_CALL_METHOD(NULL, *backend, "start", key_name, lifetime);
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Multiple, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *backends;
	HashPosition hp0;
	zval **backend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);
	
	if (!key_name) {
		key_name = PHALCON_GLOBAL(z_null);
	}
	
	if (!content) {
		content = PHALCON_GLOBAL(z_null);
	}
	
	if (!lifetime) {
		lifetime = PHALCON_GLOBAL(z_null);
	}
	
	if (!stop_buffer) {
		stop_buffer = PHALCON_GLOBAL(z_true);
	}
	
	backends = phalcon_fetch_nproperty_this(this_ptr, SL("_backends"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(backends) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(backends), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(backends), (void**)&backend, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(backends), &hp0)
		) {
			PHALCON_CALL_METHOD(NULL, *backend, "save", key_name, content, lifetime, stop_buffer);
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Multiple, delete){

	zval *key_name, *backends;
	HashPosition hp0;
	zval **backend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);
	backends = phalcon_fetch_nproperty_this(this_ptr, SL("_backends"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(backends) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(backends), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(backends), (void**)&backend, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(backends), &hp0)
		) {
			PHALCON_CALL_METHOD(NULL, *backend, "delete", key_name);
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Multiple, exists){

	zval *key_name = NULL, *lifetime = NULL, *backends;
	zval *exists = NULL;
	HashPosition hp0;
	zval **backend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);
	
	if (!key_name) {
		key_name = PHALCON_GLOBAL(z_null);
	}
	
	if (!lifetime) {
		lifetime = PHALCON_GLOBAL(z_null);
	}
	
	backends = phalcon_fetch_nproperty_this(this_ptr, SL("_backends"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(backends) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(backends), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(backends), (void**)&backend, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(backends), &hp0)
		) {
			PHALCON_CALL_METHOD(&exists, *backend, "exists", key_name, lifetime);
			if (zend_is_true(exists)) {
				RETURN_MM_TRUE;
			}
		}
	}

	RETURN_MM_FALSE;
}






zend_class_entry *phalcon_cache_backend_apc_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Apc, get);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, save);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Apc, flush);

static const zend_function_entry phalcon_cache_backend_apc_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Apc, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Apc, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

static int phalcon_cache_backend_is_old_apcu = -1;

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Apc){

	if (-1 == phalcon_cache_backend_is_old_apcu) {
		phalcon_cache_backend_is_old_apcu = zend_hash_exists(&module_registry, SS("apcu"));
		if (phalcon_cache_backend_is_old_apcu) {
			zend_constant *c;
			if (zend_hash_find(EG(zend_constants), SS("APCU_APC_FULL_BC"), (void**)&c) == SUCCESS) {
				phalcon_cache_backend_is_old_apcu = !zend_is_true(&c->value);
			}
		}
	}

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Apc, cache_backend_apc, phalcon_cache_backend_ce, phalcon_cache_backend_apc_method_entry, 0);

	zend_class_implements(phalcon_cache_backend_apc_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, get){

	zval *key_name, *lifetime = NULL, *prefixed_key;
	zval *cached_content = NULL;
	zval *frontend, *prefix;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCA", prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_FUNCTION(&cached_content, "apc_fetch", prefixed_key);
	if (PHALCON_IS_FALSE(cached_content)) {
		RETURN_MM_NULL();
	}

	if (phalcon_is_numeric(cached_content)) {
		RETURN_CCTOR(cached_content);
	} else {
		PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *cached_content = NULL;
	zval *prepared_content = NULL, *ttl = NULL, *is_buffering = NULL;
	zval *last_key, *prefix, *frontend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCA", prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}
	
	if (!phalcon_is_numeric(cached_content)) {
		PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);
	}
	
	if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
		zval *last_lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(last_lifetime) == IS_NULL) {
			PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
		}
		else {
			ttl = last_lifetime;
		}
	} else {
		ttl = lifetime;
	}
	
	if (!prepared_content) {
		PHALCON_CALL_FUNCTION(NULL, "apc_store", last_key, cached_content, ttl);
	} else {
		PHALCON_CALL_FUNCTION(NULL, "apc_store", last_key, prepared_content, ttl);
	}
	
	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");
	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, increment){

	zval **key_name, **value = NULL, *prefixed_key;
	zval *cached_content = NULL;
	zval *prefix;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCA", prefix, *key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	if (SUCCESS == phalcon_function_quick_exists_ex(SS("apc_inc"), 2617297490UL TSRMLS_CC)) {
		PHALCON_RETURN_CALL_FUNCTION("apc_inc", prefixed_key, *value);
	} else {
		PHALCON_CALL_FUNCTION(&cached_content, "apc_fetch", prefixed_key);

		if (Z_TYPE_P(cached_content) == IS_LONG) {
			add_function(return_value, cached_content, *value TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, this_ptr, "save", *key_name, return_value);
		}
		else {
			RETVAL_FALSE;
		}
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, decrement){

	zval **key_name, **value = NULL, *prefixed_key;
	zval *cached_content = NULL;
	zval *prefix;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCA", prefix, *key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	if (SUCCESS == phalcon_function_quick_exists_ex(SS("apc_dec"), 2617108004UL TSRMLS_CC)) {
		PHALCON_RETURN_CALL_FUNCTION("apc_dec", prefixed_key, *value);
	} else {
		PHALCON_CALL_FUNCTION(&cached_content, "apc_fetch", prefixed_key);

		if (Z_TYPE_P(cached_content) == IS_LONG) {
			sub_function(return_value, cached_content, *value TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, this_ptr, "save", *key_name, return_value);
		}
		else {
			RETVAL_FALSE;
		}
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, delete){

	zval *key_name, *prefix, *key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_ALLOC_GHOST_ZVAL(key);
	PHALCON_CONCAT_SVV(key, "_PHCA", prefix, key_name);
	
	PHALCON_RETURN_CALL_FUNCTION("apc_delete", key);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, queryKeys){

	zval *prefix = NULL, *type, *prefix_pattern, *iterator;
	zval *key = NULL;
	zend_class_entry *apciterator_ce;
#if PHP_VERSION_ID < 50500
	char *str_key;
	uint str_key_len;
	ulong int_key;
	int key_type;
#else
	zval *itkey = NULL;
#endif
	zend_object_iterator *it;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &prefix);
	
	PHALCON_INIT_VAR(prefix_pattern);
	if (!prefix) {
		ZVAL_STRING(prefix_pattern, "/^_PHCA/", 1);
	}
	else {
		PHALCON_CONCAT_SVS(prefix_pattern, "/^_PHCA", prefix, "/");
	}
	
	array_init(return_value);
	
	apciterator_ce = zend_fetch_class(SL("APCIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, apciterator_ce);
	assert(phalcon_has_constructor(iterator TSRMLS_CC));
	if (!phalcon_cache_backend_is_old_apcu) {
		PHALCON_ALLOC_GHOST_ZVAL(type);
		ZVAL_STRING(type, "user", 1);
		PHALCON_CALL_METHOD(NULL, iterator, "__construct", type, prefix_pattern);
	}
	else {
		PHALCON_CALL_METHOD(NULL, iterator, "__construct", prefix_pattern);
	}

	/* APCIterator implements Iterator */
	assert(instanceof_function_ex(apciterator_ce, zend_ce_iterator, 1 TSRMLS_CC));

	it = apciterator_ce->get_iterator(apciterator_ce, iterator, 0 TSRMLS_CC);

	/* APCIterator is an iterator */
	assert(it != NULL);

	/* APCIterator has key() method */
	assert(it->funcs->get_current_key != NULL);

	/* APCIterator has rewind() method */
	assert(it->funcs->rewind != NULL);

	it->funcs->rewind(it TSRMLS_CC);
	while (it->funcs->valid(it TSRMLS_CC) == SUCCESS && !EG(exception)) {
		PHALCON_INIT_NVAR(key);
#if PHP_VERSION_ID < 50500
		key_type = it->funcs->get_current_key(it, &str_key, &str_key_len, &int_key TSRMLS_CC);
		if (likely(key_type == HASH_KEY_IS_STRING)) {
			ZVAL_STRINGL(key, str_key + 5, str_key_len - 5 - 1, 1);
			efree(str_key);

			phalcon_array_append(&return_value, key, PH_COPY);
		}
#else
		PHALCON_INIT_NVAR(itkey);
		it->funcs->get_current_key(it, itkey TSRMLS_CC);
		if (likely(Z_TYPE_P(itkey) == IS_STRING)) {
			ZVAL_STRINGL(key, Z_STRVAL_P(itkey) + 5, Z_STRLEN_P(itkey) - 5, 1);
			phalcon_array_append(&return_value, key, PH_COPY);
		}
#endif

		it->funcs->move_forward(it TSRMLS_CC);
	}
	
	it->funcs->dtor(it TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, exists){

	zval *key_name = NULL, *lifetime = NULL, *cache_exists = NULL;
	zval *last_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCA", prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		PHALCON_CALL_FUNCTION(&cache_exists, "apc_exists", last_key);
		if (PHALCON_IS_NOT_FALSE(cache_exists)) {
			RETURN_MM_TRUE;
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Apc, flush){

	zval *type, *prefix_pattern, *iterator;
	zval *key = NULL;
	zval *params[1];
	zend_class_entry *apciterator_ce;
#if PHP_VERSION_ID < 50500
	char *str_key;
	uint str_key_len;
	ulong int_key;
	int key_type;
#else
	zval *itkey = NULL;
#endif
	zend_object_iterator *it;

	PHALCON_MM_GROW();
	
	PHALCON_INIT_VAR(prefix_pattern);
	ZVAL_STRING(prefix_pattern, "/^_PHCA/", 1);	
	
	apciterator_ce = zend_fetch_class(SL("APCIterator"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, apciterator_ce);
	assert(phalcon_has_constructor(iterator TSRMLS_CC));
	if (!phalcon_cache_backend_is_old_apcu) {
		PHALCON_ALLOC_GHOST_ZVAL(type);
		ZVAL_STRING(type, "user", 1);
		PHALCON_CALL_METHOD(NULL, iterator, "__construct", type, prefix_pattern);
	}
	else {
		PHALCON_CALL_METHOD(NULL, iterator, "__construct", prefix_pattern);
	}

	/* APCIterator implements Iterator */
	assert(instanceof_function_ex(apciterator_ce, zend_ce_iterator, 1 TSRMLS_CC));

	it = apciterator_ce->get_iterator(apciterator_ce, iterator, 0 TSRMLS_CC);

	/* APCIterator is an iterator */
	assert(it != NULL);

	/* APCIterator has key() method */
	assert(it->funcs->get_current_key != NULL);

	/* APCIterator has rewind() method */
	assert(it->funcs->rewind != NULL);

	it->funcs->rewind(it TSRMLS_CC);
	while (it->funcs->valid(it TSRMLS_CC) == SUCCESS && !EG(exception)) {
		PHALCON_INIT_NVAR(key);
		params[0] = key;
#if PHP_VERSION_ID < 50500
		key_type = it->funcs->get_current_key(it, &str_key, &str_key_len, &int_key TSRMLS_CC);
		if (likely(key_type == HASH_KEY_IS_STRING)) {
			ZVAL_STRINGL(key, str_key, str_key_len - 1, 1);
			efree(str_key);

			if (FAILURE == phalcon_call_func_aparams(NULL, SL("apc_delete"), 1, params TSRMLS_CC)) {
				break;
			}
		}
#else
		PHALCON_INIT_NVAR(itkey);
		it->funcs->get_current_key(it, itkey TSRMLS_CC);
		if (likely(Z_TYPE_P(itkey) == IS_STRING)) {
			ZVAL_STRINGL(key, Z_STRVAL_P(itkey), Z_STRLEN_P(itkey), 1);
			if (FAILURE == phalcon_call_func_aparams(NULL, SL("apc_delete"), 1, params TSRMLS_CC)) {
				break;
			}
		}
#endif

		it->funcs->move_forward(it TSRMLS_CC);
	}

	it->funcs->dtor(it TSRMLS_CC);
	RETURN_MM_TRUE;
}





#include <ext/spl/spl_directory.h>


zend_class_entry *phalcon_cache_backend_file_ce;

static PHP_METHOD(Phalcon_Cache_Backend_File, __construct);
static PHP_METHOD(Phalcon_Cache_Backend_File, get);
static PHP_METHOD(Phalcon_Cache_Backend_File, save);
static PHP_METHOD(Phalcon_Cache_Backend_File, delete);
static PHP_METHOD(Phalcon_Cache_Backend_File, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_File, exists);
static PHP_METHOD(Phalcon_Cache_Backend_File, increment);
static PHP_METHOD(Phalcon_Cache_Backend_File, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_File, flush);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_file___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_file_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_File, __construct, arginfo_phalcon_cache_backend_file___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend_File, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_File, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, File, cache_backend_file, phalcon_cache_backend_ce, phalcon_cache_backend_file_method_entry, 0);

	zend_class_implements(phalcon_cache_backend_file_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_File, __construct){

	zval *frontend, *options = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &frontend, &options);

	if (!options || !phalcon_array_isset_quick_string(options, SS("cacheDir"), 1104587096UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cache directory must be specified with the option cacheDir");
		return;
	}

	PHALCON_CALL_PARENT(NULL, phalcon_cache_backend_file_ce, this_ptr, "__construct", frontend, options);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, get){

	zval *key_name, *lifetime = NULL;
	zval *options, *prefix, *prefixed_key, *cache_dir;
	zval *cache_file, *tmp = NULL;
	zval *modified_time;
	zval *cached_content, *exception_message;
	long int now, ttl, mtime, diff;
	int expired;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&cache_dir, options, SS("cacheDir")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);

	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {

		zval *frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);

		now = (long int)time(NULL);

		if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
			zval *last_lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(last_lifetime) == IS_NULL) {
				PHALCON_CALL_METHOD(&tmp, frontend, "getlifetime");
				ttl = phalcon_get_intval(tmp);
			} else {
				ttl = phalcon_get_intval(last_lifetime);
			}
		} else {
			ttl = phalcon_get_intval(lifetime);
		}

		PHALCON_INIT_VAR(modified_time);
		phalcon_filemtime(modified_time, cache_file TSRMLS_CC);
		if (unlikely(Z_TYPE_P(modified_time) != IS_LONG)) {
			convert_to_long(modified_time);
		}

		mtime   = Z_LVAL_P(modified_time);
		diff    = now - ttl;
		expired = diff > mtime;

		if (!expired) {

			PHALCON_INIT_VAR(cached_content);
			phalcon_file_get_contents(cached_content, cache_file TSRMLS_CC);
			if (PHALCON_IS_FALSE(cached_content)) {
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Cache file ", cache_file, " could not be opened");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_cache_exception_ce, exception_message);
				return;
			}

			if (phalcon_is_numeric(cached_content)) {
				RETURN_CCTOR(cached_content);
			} else {
				PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
			}

			RETURN_MM();
		}
	}

	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *cache_file, *cached_content = NULL, *prepared_content = NULL, *status, *is_buffering = NULL;
	zval *last_key, *frontend, *options, *cache_dir;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}

	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	options  = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&cache_dir, options, SS("cacheDir")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, last_key);

	if (!content || !zend_is_true(content)) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}

	PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);

	PHALCON_INIT_VAR(status);
	if (!phalcon_is_numeric(cached_content)) {
		phalcon_file_put_contents(status, cache_file, prepared_content TSRMLS_CC);
	} else {
		phalcon_file_put_contents(status, cache_file, cached_content TSRMLS_CC);
	}
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cache directory is not writable");
		return;
	}

	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");
	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}

	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}

	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, delete){

	zval *key_name, *prefixed_key, *cache_file;
	zval *options, *prefix, *cache_dir;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);

	if (unlikely(!phalcon_array_isset_string_fetch(&cache_dir, options, SS("cacheDir")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);

	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
		phalcon_unlink(return_value, cache_file TSRMLS_CC);
		RETURN_MM();
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Backend_File, queryKeys){

	zval *prefix = NULL, *options, *cache_dir, *iterator;
	zval **item, *is_directory = NULL, *key = NULL;
	zend_object_iterator *it;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &prefix);

	array_init(return_value);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&cache_dir, options, SS("cacheDir")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, spl_ce_DirectoryIterator);
	assert(phalcon_has_constructor(iterator TSRMLS_CC));
	PHALCON_CALL_METHOD(NULL, iterator, "__construct", cache_dir);

	/* DirectoryIterator implements Iterator */
	assert(instanceof_function_ex(spl_ce_DirectoryIterator, zend_ce_iterator, 1 TSRMLS_CC));

	it = spl_ce_DirectoryIterator->get_iterator(spl_ce_DirectoryIterator, iterator, 0 TSRMLS_CC);

	/* DirectoryIterator is an iterator */
	assert(it != NULL);

	/* DirectoryIterator has rewind() method */
	assert(it->funcs->rewind != NULL);

	it->funcs->rewind(it TSRMLS_CC);
	while (it->funcs->valid(it TSRMLS_CC) == SUCCESS && !EG(exception)) {
		it->funcs->get_current_data(it, &item TSRMLS_CC);

		PHALCON_OBSERVE_OR_NULLIFY_VAR(is_directory);
		if (FAILURE == phalcon_call_method(&is_directory, *item, "isdir", 0, NULL TSRMLS_CC)) {
			break;
		}

		if (!EG(exception) && PHALCON_IS_FALSE(is_directory)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(key);
			if (FAILURE == phalcon_call_method(&key, *item, "getfilename", 0, NULL TSRMLS_CC)) {
				break;
			}

			if (!EG(exception) && (!prefix || phalcon_start_with(key, prefix, NULL))) {
				phalcon_array_append(&return_value, key, 0);
			}
		}

		it->funcs->move_forward(it TSRMLS_CC);
	}

	it->funcs->dtor(it TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, exists){

	zval *key_name = NULL, *lifetime = NULL, *last_key, *options;
	zval *cache_dir, *cache_file, *frontend;
	zval *tmp = NULL, *modified_time;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

		PHALCON_OBS_VAR(cache_dir);
		phalcon_array_fetch_quick_string(&cache_dir, options, SS("cacheDir"), 1104587096UL, PH_NOISY);

		PHALCON_INIT_VAR(cache_file);
		PHALCON_CONCAT_VV(cache_file, cache_dir, last_key);

		if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {
			long int mtime, ttl;

			frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);

			if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
				PHALCON_CALL_METHOD(&tmp, frontend, "getlifetime");

				ttl = likely(Z_TYPE_P(tmp) == IS_LONG) ? Z_LVAL_P(tmp) : phalcon_get_intval(tmp);
			} else {
				ttl = likely(Z_TYPE_P(lifetime) == IS_LONG) ? Z_LVAL_P(lifetime) : phalcon_get_intval(lifetime);
			}

			PHALCON_INIT_VAR(modified_time);
			phalcon_filemtime(modified_time, cache_file TSRMLS_CC);
			mtime = likely(Z_TYPE_P(modified_time) == IS_LONG) ? Z_LVAL_P(modified_time) : phalcon_get_intval(modified_time);

			if (mtime + ttl > (long int)time(NULL)) {
				RETURN_MM_TRUE;
			}
		}
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Backend_File, increment){

	zval **key_name, **value = NULL, *lifetime = NULL, *options, *prefix, *prefixed_key, *status;
	zval *cache_dir, *cache_file;
	zval *modified_time;
	zval *cached_content, *tmp = NULL;
	long int now, ttl, mtime, diff;
	int expired;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);
	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, *key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	PHALCON_OBS_VAR(cache_dir);
	phalcon_array_fetch_quick_string(&cache_dir, options, SS("cacheDir"), 1104587096UL, PH_NOISY);

	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);
	assert(Z_TYPE_P(cache_file) == IS_STRING);

	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {

		zval *frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
		now = (long int)time(NULL);

		if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
			zval *last_lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(last_lifetime) == IS_NULL) {
				PHALCON_CALL_METHOD(&tmp, frontend, "getlifetime");
				ttl = phalcon_get_intval(tmp);
			} else {
				ttl = phalcon_get_intval(last_lifetime);
			}
		} else {
			ttl = phalcon_get_intval(lifetime);
		}

		PHALCON_INIT_VAR(modified_time);
		phalcon_filemtime(modified_time, cache_file TSRMLS_CC);
		if (unlikely(Z_TYPE_P(modified_time) != IS_LONG)) {
			convert_to_long(modified_time);
		}

		mtime   = Z_LVAL_P(modified_time);
		diff    = now - ttl;
		expired = diff > mtime;

		if (!expired) {

			PHALCON_INIT_VAR(cached_content);
			phalcon_file_get_contents(cached_content, cache_file TSRMLS_CC);
			if (PHALCON_IS_FALSE(cached_content)) {
				zend_throw_exception_ex(phalcon_cache_exception_ce, 0 TSRMLS_CC, "Failed to open cache file %s", Z_STRVAL_P(cache_file));
				RETURN_MM();
			}

			add_function(return_value, *value, cached_content TSRMLS_CC);

			PHALCON_INIT_VAR(status);
			phalcon_file_put_contents(status, cache_file, return_value TSRMLS_CC);

			if (PHALCON_IS_FALSE(status)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cache directory can't be written");
				return;
			}

			RETURN_MM();
		}
	}

	RETVAL_FALSE;
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, decrement){

	zval **key_name, **value = NULL, *lifetime = NULL, *options, *prefix, *prefixed_key, *status;
	zval *cache_dir, *cache_file;
	zval *modified_time;
	zval *cached_content, *tmp = NULL;
	long int now, ttl, mtime, diff;
	int expired;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);
	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, *key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	PHALCON_OBS_VAR(cache_dir);
	phalcon_array_fetch_quick_string(&cache_dir, options, SS("cacheDir"), 1104587096UL, PH_NOISY);

	PHALCON_INIT_VAR(cache_file);
	PHALCON_CONCAT_VV(cache_file, cache_dir, prefixed_key);
	assert(Z_TYPE_P(cache_file) == IS_STRING);

	if (phalcon_file_exists(cache_file TSRMLS_CC) == SUCCESS) {

		zval *frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
		now = (long int)time(NULL);

		if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
			zval *last_lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(last_lifetime) == IS_NULL) {
				PHALCON_CALL_METHOD(&tmp, frontend, "getlifetime");
				ttl = phalcon_get_intval(tmp);
			} else {
				ttl = phalcon_get_intval(last_lifetime);
			}
		} else {
			ttl = phalcon_get_intval(lifetime);
		}

		PHALCON_INIT_VAR(modified_time);
		phalcon_filemtime(modified_time, cache_file TSRMLS_CC);
		if (unlikely(Z_TYPE_P(modified_time) != IS_LONG)) {
			convert_to_long(modified_time);
		}

		mtime   = Z_LVAL_P(modified_time);
		diff    = now - ttl;
		expired = diff > mtime;

		if (!expired) {

			PHALCON_INIT_VAR(cached_content);
			phalcon_file_get_contents(cached_content, cache_file TSRMLS_CC);
			if (PHALCON_IS_FALSE(cached_content)) {
				zend_throw_exception_ex(phalcon_cache_exception_ce, 0 TSRMLS_CC, "Failed to open cache file %s", Z_STRVAL_P(cache_file));
				RETURN_MM();
			}

			sub_function(return_value, cached_content, *value TSRMLS_CC);

			PHALCON_INIT_VAR(status);
			phalcon_file_put_contents(status, cache_file, return_value TSRMLS_CC);

			if (PHALCON_IS_FALSE(status)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cache directory can't be written");
				return;
			}

			RETURN_MM();
		}
	}

	RETVAL_FALSE;
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_File, flush){

	zval *options, *prefix, *cache_dir, *iterator;
	zval **item, *is_file = NULL, *key = NULL, *cache_file = NULL;
	zend_object_iterator *it;

	PHALCON_MM_GROW();

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&cache_dir, options, SS("cacheDir")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, spl_ce_DirectoryIterator);
	assert(phalcon_has_constructor(iterator TSRMLS_CC));
	PHALCON_CALL_METHOD(NULL, iterator, "__construct", cache_dir);

	/* DirectoryIterator implements Iterator */
	assert(instanceof_function_ex(spl_ce_DirectoryIterator, zend_ce_iterator, 1 TSRMLS_CC));

	it = spl_ce_DirectoryIterator->get_iterator(spl_ce_DirectoryIterator, iterator, 0 TSRMLS_CC);

	/* DirectoryIterator is an iterator */
	assert(it != NULL);

	/* DirectoryIterator has rewind() method */
	assert(it->funcs->rewind != NULL);

	it->funcs->rewind(it TSRMLS_CC);
	while (it->funcs->valid(it TSRMLS_CC) == SUCCESS && !EG(exception)) {
		it->funcs->get_current_data(it, &item TSRMLS_CC);

		PHALCON_OBSERVE_OR_NULLIFY_VAR(is_file);
		if (FAILURE == phalcon_call_method(&is_file, *item, "isfile", 0, NULL TSRMLS_CC)) {
			break;
		}

		if (PHALCON_IS_TRUE(is_file)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(key);
			if (FAILURE == phalcon_call_method(&key, *item, "getfilename", 0, NULL TSRMLS_CC)) {
				break;
			}

			PHALCON_OBSERVE_OR_NULLIFY_VAR(cache_file);
			if (FAILURE == phalcon_call_method(&cache_file, *item, "getpathname", 0, NULL TSRMLS_CC)) {
				break;
			}

			if (PHALCON_IS_EMPTY(prefix) || phalcon_start_with(key, prefix, NULL)) {
				phalcon_unlink(return_value, cache_file TSRMLS_CC);
			}
		}

		it->funcs->move_forward(it TSRMLS_CC);
	}

	it->funcs->dtor(it TSRMLS_CC);

	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_cache_backend_libmemcached_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, __construct);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, _connect);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, get);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, save);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, flush);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, getTrackingKey);
static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, setTrackingKey);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_libmemcached___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_libmemcached_settrackingkey, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_libmemcached_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, __construct, arginfo_phalcon_cache_backend_libmemcached___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, _connect, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, getTrackingKey, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Libmemcached, setTrackingKey, arginfo_phalcon_cache_backend_libmemcached_settrackingkey, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Libmemcached){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Libmemcached, cache_backend_libmemcached, phalcon_cache_backend_ce, phalcon_cache_backend_libmemcached_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_libmemcached_ce, SL("_memcache"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_libmemcached_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, __construct){

	zval *frontend, *options = NULL, *server, *servers;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &frontend, &options);

	if (!options) {
		PHALCON_INIT_VAR(options);
	} else {
		PHALCON_SEPARATE_PARAM(options);
	}

	if (Z_TYPE_P(options) != IS_ARRAY) {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}

	if (!phalcon_array_isset_quick_string(options, SS("servers"), 243047535UL)) {
		PHALCON_INIT_VAR(servers);
		array_init_size(servers, 1);

		PHALCON_INIT_VAR(server);
		array_init_size(server, 3);

		phalcon_array_update_string_string(&server, SL("host"), SL("127.0.0.1"), 0);
		phalcon_array_update_string_long(&server, SL("port"), 11211, 0);
		phalcon_array_update_string_long(&server, SL("weight"), 1, 0);

		phalcon_array_append(&servers, server, 0);

		phalcon_array_update_string(&options, SL("servers"), servers, PH_COPY);
	}

	if (!phalcon_array_isset_quick_string(options, SS("statsKey"), 2508919229UL)) {
		phalcon_array_update_string_string(&options, SL("statsKey"), SL("_PHCM"), 0);
	}

	PHALCON_CALL_PARENT(NULL, phalcon_cache_backend_libmemcached_ce, this_ptr, "__construct", frontend, options);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, _connect){

	zval *options, *memcache, *servers, *client = NULL, *res = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	ce0 = zend_fetch_class(SL("Memcached"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_INIT_VAR(memcache);
	object_init_ex(memcache, ce0);
	if (phalcon_has_constructor(memcache TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, memcache, "__construct");
	}

	if (!phalcon_array_isset_string_fetch(&servers, options, SS("servers")) || Z_TYPE_P(servers) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Servers must be an array");
		return;
	}

	phalcon_array_isset_string_fetch(&client, options, SS("client"));

	PHALCON_RETURN_CALL_METHOD(memcache, "addservers", servers);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (!zend_is_true(return_value)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cannot connect to Memcached server");
		return;
	}

	if (client && Z_TYPE_P(client) == IS_ARRAY) {
		HashPosition hp;
		zval **hd;

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(client), &hp);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(client), (void**)&hd, &hp) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(client), &hp)
		) {
			zval option = phalcon_get_current_key_w(Z_ARRVAL_P(client), &hp);

			if (Z_TYPE(option) == IS_STRING) {
				PHALCON_INIT_NVAR(res);
				if (zend_get_constant(Z_STRVAL(option), Z_STRLEN(option), res TSRMLS_CC)) {
					PHALCON_CALL_METHOD(NULL, memcache, "setoption", res, *hd);
				}
			} else {
				PHALCON_CALL_METHOD(NULL, memcache, "setoption", &option, *hd);
			}
		}
	}

	phalcon_update_property_this_quick(this_ptr, SL("_memcache"), memcache, 958186231UL TSRMLS_CC);

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, get){

	zval *key_name, *lifetime = NULL, *memcache, *frontend, *prefix;
	zval *prefixed_key, *cached_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	PHALCON_CALL_METHOD(&cached_content, memcache, "get", prefixed_key);
	if (PHALCON_IS_FALSE(cached_content)) {
		RETURN_MM_NULL();
	}

	if (phalcon_is_numeric(cached_content)) {
		RETURN_CCTOR(cached_content);
	} else {
		PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key, *frontend, *memcache, *cached_content = NULL;
	zval *prepared_content = NULL, *ttl = NULL, *success = NULL;
	zval *options, *special_key, *keys = NULL, *is_buffering = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}

	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}

	if (!phalcon_is_numeric(cached_content)) {
		PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);
	}

	if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
		zval *tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(tmp) == IS_NULL) {
			PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
		}
		else {
			ttl = tmp;
		}
	} else {
		ttl = lifetime;
	}

	if (!prepared_content) {
		PHALCON_CALL_METHOD(&success, memcache, "set", last_key, cached_content, ttl);
	} else {
		PHALCON_CALL_METHOD(&success, memcache, "set", last_key, prepared_content, ttl);
	}

	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Failed storing data in memcached");
		return;
	}

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	if (Z_TYPE_P(special_key) != IS_NULL) {
		/* Update the stats key */
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) != IS_ARRAY) {
			PHALCON_INIT_NVAR(keys);
			array_init(keys);
		}

		if (!phalcon_array_isset(keys, last_key)) {
			phalcon_array_update_zval(&keys, last_key, ttl, PH_COPY);
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}
	}

	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");

	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}

	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}

	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, increment){
	zval *key_name, *value = NULL, *memcache, *prefix;
	zval *prefixed_key, *cached_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &value);

	if (!value) {
		PHALCON_INIT_VAR(value);
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1);
	}

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	PHALCON_CALL_METHOD(&cached_content, memcache, "increment", prefixed_key, value);
	if (PHALCON_IS_FALSE(cached_content)) {
		RETURN_MM_NULL();
	}

	RETURN_CCTOR(cached_content);
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, decrement){
	zval *key_name, *value = NULL, *memcache, *prefix;
	zval *prefixed_key, *cached_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &value);

	if (!value) {
		PHALCON_INIT_VAR(value);
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1);
	}

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);

	PHALCON_CALL_METHOD(&cached_content, memcache, "decrement", prefixed_key, value);
	if (PHALCON_IS_FALSE(cached_content)) {
		RETURN_MM_NULL();
	}

	RETURN_CCTOR(cached_content);
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, delete){

	zval *key_name, *memcache, *prefix, *prefixed_key;
	zval *options, *special_key, *keys = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	if (Z_TYPE_P(special_key) != IS_NULL) {
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) == IS_ARRAY) {
			phalcon_array_unset(&keys, prefixed_key, 0);
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}
	}

	/* Delete the key from memcached */
	PHALCON_RETURN_CALL_METHOD(memcache, "delete", prefixed_key);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, queryKeys){

	zval *prefix = NULL, *memcache, *options, *special_key;
	zval *keys = NULL, *real_key = NULL;

	phalcon_fetch_params(0, 0, 1, &prefix);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		zend_throw_exception_ex(phalcon_cache_exception_ce, 0 TSRMLS_CC, "Unexpected inconsistency in options");
		return;
	}

	array_init(return_value);
	if (Z_TYPE_P(special_key) == IS_NULL) {
		return;
	}

	PHALCON_MM_GROW();

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	/* Get the key from memcached */
	PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
	if (Z_TYPE_P(keys) == IS_ARRAY) {
		HashPosition pos;
		zval **value;

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void**)&value, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &pos)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(keys), &pos);

			if (!prefix || !zend_is_true(prefix) || phalcon_start_with(&key, prefix, NULL)) {
				PHALCON_INIT_NVAR(real_key);
				ZVAL_STRINGL(real_key, Z_STRVAL(key), Z_STRLEN(key), 1);
				phalcon_array_append(&return_value, real_key, 0);
			}
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, exists){

	zval *key_name = NULL, *lifetime = NULL, *value = NULL;
	zval *last_key, *memcache;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(memcache) != IS_OBJECT) {
			PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
			memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
		}

		PHALCON_CALL_METHOD(&value, memcache, "get", last_key);
		RETVAL_BOOL(PHALCON_IS_NOT_FALSE(value));
	}
	else {
		RETVAL_FALSE;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, flush){

	zval *memcache, *options, *special_key;
	zval *keys = NULL;
	HashPosition pos;
	zval **value;

	PHALCON_MM_GROW();

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_connect");
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	}

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	/* Get the key from memcached */
	if (Z_TYPE_P(special_key) != IS_NULL) {
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) == IS_ARRAY) {

			for (
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &pos);
				zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void**)&value, &pos) == SUCCESS;
				zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &pos)
			) {
				zval key = phalcon_get_current_key_w(Z_ARRVAL_P(keys), &pos);
				
				PHALCON_CALL_METHOD(NULL, memcache, "delete", &key);
			}
			
			zend_hash_clean(Z_ARRVAL_P(keys));
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}		
	} else {
		PHALCON_CALL_METHOD(&keys, memcache, "flush");
	}

	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, getTrackingKey)
{
	zval *stats_key;
	zval *options = phalcon_fetch_nproperty_this(getThis(), SL("_options"), PH_NOISY TSRMLS_CC);

	if (!phalcon_array_isset_string_fetch(&stats_key, options, SS("statsKey"))) {
		RETURN_NULL();
	}

	RETURN_ZVAL(stats_key, 1, 0);
}

static PHP_METHOD(Phalcon_Cache_Backend_Libmemcached, setTrackingKey)
{
	zval **key, *options;
	int separated;

	phalcon_fetch_params_ex(1, 0, &key);

	options   = phalcon_fetch_nproperty_this(getThis(), SL("_options"), PH_NOISY TSRMLS_CC);
	separated = phalcon_maybe_separate_zval(&options);
	phalcon_array_update_string(&options, SL("statsKey"), *key, PH_COPY);

	if (separated) {
		Z_DELREF_P(options);
		phalcon_update_property_this(getThis(), SL("_options"), options TSRMLS_CC);
	}

	RETURN_ZVAL(getThis(), 1, 0);
}







zend_class_entry *phalcon_cache_backend_memcache_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, __construct);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, _connect);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, get);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, save);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, flush);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, getTrackingKey);
static PHP_METHOD(Phalcon_Cache_Backend_Memcache, setTrackingKey);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_memcache___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_memcache_settrackingkey, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_memcache_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Memcache, __construct, arginfo_phalcon_cache_backend_memcache___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend_Memcache, _connect, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Cache_Backend_Memcache, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, getTrackingKey, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memcache, setTrackingKey, arginfo_phalcon_cache_backend_memcache_settrackingkey, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Memcache)
{
	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Memcache, cache_backend_memcache, phalcon_cache_backend_ce, phalcon_cache_backend_memcache_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_memcache_ce, SL("_memcache"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_memcache_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, __construct){

	zval *frontend, *options = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &frontend, &options);
	
	if (!options) {
		PHALCON_INIT_VAR(options);
	} else {
		PHALCON_SEPARATE_PARAM(options);
	}
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(options);
		array_init_size(options, 4);
	}

	if (!phalcon_array_isset_quick_string(options, SS("host"), 261606083UL)) {
		phalcon_array_update_string_string(&options, SL("host"), SL("127.0.0.1"), 0);
	}
	
	if (!phalcon_array_isset_quick_string(options, SS("port"), 271092362UL)) {
		phalcon_array_update_string_long(&options, SL("port"), 11211, 0);
	}
	
	if (!phalcon_array_isset_quick_string(options, SS("persistent"), 2222052598UL)) {
		phalcon_array_update_string_bool(&options, SL("persistent"), 0, 0);
	}
	
	if (!phalcon_array_isset_quick_string(options, SS("statsKey"), 2508919229UL)) {
		phalcon_array_update_string_string(&options, SL("statsKey"), SL("_PHCM"), 0);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_cache_backend_memcache_ce, this_ptr, "__construct", frontend, options);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, _connect)
{
	zval *options, *memcache, *host, *port, *persistent;
	zval *success = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	ce0 = zend_fetch_class(SL("Memcache"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_INIT_VAR(memcache);
	object_init_ex(memcache, ce0);
	if (phalcon_has_constructor(memcache TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, memcache, "__construct");
	}
	
	if (
		   !phalcon_array_isset_string_fetch(&host, options, SS("host"))
		|| !phalcon_array_isset_string_fetch(&port, options, SS("port"))
		|| !phalcon_array_isset_string_fetch(&persistent, options, SS("persistent"))
	) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	if (zend_is_true(persistent)) {
		PHALCON_CALL_METHOD(&success, memcache, "pconnect", host, port);
	} else {
		PHALCON_CALL_METHOD(&success, memcache, "connect", host, port);
	}
	
	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Cannot connect to Memcached server");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_memcache"), memcache, 958186231UL TSRMLS_CC);
	RETURN_CTOR(memcache);
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, get){

	zval *key_name, *lifetime = NULL, *memcache, *frontend;
	zval *prefix, *prefixed_key, *cached_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&cached_content, memcache, "get", prefixed_key);
	if (PHALCON_IS_FALSE(cached_content)) {
		RETURN_MM_NULL();
	}

	if (phalcon_is_numeric(cached_content)) {
		RETURN_CCTOR(cached_content);
	}
	
	PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *cached_content = NULL, *prepared_content = NULL, *ttl = NULL, *flags, *success = NULL;
	zval *keys = NULL, *is_buffering = NULL;
	zval *last_key, *frontend, *memcache, *options, *special_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	
	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}

	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}
	
	PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);

	if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
		zval *tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(tmp) == IS_NULL) {
			PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
		}
		else {
			ttl = tmp;
		}
	} else {
		ttl = lifetime;
	}
	
	PHALCON_INIT_VAR(flags);
	ZVAL_LONG(flags, 0);
	
	if (phalcon_is_numeric(cached_content)) {
		PHALCON_CALL_METHOD(&success, memcache, "set", last_key, cached_content, flags, ttl);
	} else {
		PHALCON_CALL_METHOD(&success, memcache, "set", last_key, prepared_content, flags, ttl);
	}

	if (!zend_is_true(success)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Failed to store data in memcached");
		return;
	}
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	if (Z_TYPE_P(special_key) != IS_NULL) {
		/* Update the stats key */
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) != IS_ARRAY) {
			PHALCON_INIT_NVAR(keys);
			array_init(keys);
		}

		if (!phalcon_array_isset(keys, last_key)) {
			phalcon_array_update_zval(&keys, last_key, ttl, PH_COPY);
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}
	}
	
	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");

	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, delete){

	zval *key_name, *memcache, *prefix, *prefixed_key;
	zval *options, *special_key, *keys = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);
	
	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	if (Z_TYPE_P(special_key) != IS_NULL) {
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) == IS_ARRAY) {
			phalcon_array_unset(&keys, prefixed_key, 0);
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}
	}
	
	/* Delete the key from memcached */
	PHALCON_RETURN_CALL_METHOD(memcache, "delete", prefixed_key);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, queryKeys){

	zval *prefix = NULL, *memcache, *options, *special_key;
	zval *keys = NULL, *real_key = NULL;

	phalcon_fetch_params(0, 0, 1, &prefix);

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		zend_throw_exception_ex(phalcon_cache_exception_ce, 0 TSRMLS_CC, "Unexpected inconsistency in options");
		return;
	}

	array_init(return_value);
	if (Z_TYPE_P(special_key) == IS_NULL) {
		return;
	}

	PHALCON_MM_GROW();

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}
	
	/* Get the key from memcached */
	PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		HashPosition pos;
		zval **value;

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void**)&value, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &pos)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(keys), &pos);
	
			if (!prefix || !zend_is_true(prefix) || phalcon_start_with(&key, prefix, NULL)) {
				PHALCON_INIT_NVAR(real_key);
				ZVAL_STRINGL(real_key, Z_STRVAL(key), Z_STRLEN(key), 1);
				phalcon_array_append(&return_value, real_key, 0);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, exists){

	zval *key_name = NULL, *lifetime = NULL, *value = NULL;
	zval *last_key, *memcache;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(memcache) != IS_OBJECT) {
			memcache = NULL;
			PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
		}
	
		PHALCON_CALL_METHOD(&value, memcache, "get", last_key);
		RETVAL_BOOL(PHALCON_IS_NOT_FALSE(value));
	}
	else {
		RETVAL_FALSE;
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, increment){

	zval *key_name = NULL, *value = NULL, *memcache = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &value);

	if (!key_name) {
		PHALCON_INIT_VAR(key_name);
	}

	if (!value) {
		PHALCON_INIT_VAR(value);
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1); 
	}

	if (Z_TYPE_P(value) != IS_LONG) {
		PHALCON_SEPARATE_PARAM(value);
		convert_to_long_ex(&value);
	}

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}

	PHALCON_RETURN_CALL_METHOD(memcache, "increment", key_name, value);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, decrement){

	zval *key_name = NULL, *value = NULL, *memcache = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &value);

	if (!key_name) {
		PHALCON_INIT_VAR(key_name);
	}

	if (!value) {
		PHALCON_INIT_VAR(value);
	}

	if (Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1);
	}

	if (Z_TYPE_P(value) != IS_LONG) {
		PHALCON_SEPARATE_PARAM(value);
		convert_to_long_ex(&value);
	}

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}

	PHALCON_RETURN_CALL_METHOD(memcache, "decrement", key_name, value);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, flush){

	zval *memcache, *options, *special_key;
	zval *keys = NULL, *key = NULL, *param, *all_slabs = NULL, *slabs = NULL, *slabid = NULL, *cachedump = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3;
	HashPosition hp0, hp1, hp2, hp3;
	zval **hd;

	PHALCON_MM_GROW();

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(memcache) != IS_OBJECT) {
		memcache = NULL;
		PHALCON_CALL_METHOD(&memcache, this_ptr, "_connect");
	}

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}
	
	/* Get the key from memcached */
	if (Z_TYPE_P(special_key) != IS_NULL) {
		PHALCON_CALL_METHOD(&keys, memcache, "get", special_key);
		if (Z_TYPE_P(keys) == IS_ARRAY) {
			phalcon_is_iterable(keys, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
				PHALCON_GET_HKEY(key, ah0, hp0);

				PHALCON_CALL_METHOD(NULL, memcache, "delete", key);

				zend_hash_move_forward_ex(ah0, &hp0);
			}
			
			zend_hash_clean(Z_ARRVAL_P(keys));
			PHALCON_CALL_METHOD(NULL, memcache, "set", special_key, keys);
		}
	} else {
		PHALCON_INIT_VAR(param);
		ZVAL_STRING(param, "slabs", 1);

		PHALCON_CALL_METHOD(&all_slabs, memcache, "getextendedstats", param);

		if (Z_TYPE_P(all_slabs) != IS_ARRAY) {
			RETURN_MM_FALSE;
		}

		phalcon_is_iterable(all_slabs, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HVALUE(slabs);

			phalcon_is_iterable(slabs, &ah1, &hp1, 0, 0);

			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
				PHALCON_GET_HKEY(slabid, ah1, hp1);

				PHALCON_CALL_METHOD(&cachedump, memcache, "cachedump", slabid);
				if (Z_TYPE_P(cachedump) != IS_ARRAY) {
					continue;
				}

				phalcon_is_iterable(cachedump, &ah2, &hp2, 0, 0);

				while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
					PHALCON_GET_HVALUE(keys);

					if (Z_TYPE_P(keys) != IS_ARRAY) {
						continue;
					}

					phalcon_is_iterable(keys, &ah3, &hp3, 0, 0);

					while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
						PHALCON_GET_HKEY(key, ah3, hp3);

						PHALCON_CALL_METHOD(NULL, memcache, "delete", key);

						zend_hash_move_forward_ex(ah3, &hp3);
					}

					zend_hash_move_forward_ex(ah2, &hp2);
				}

				zend_hash_move_forward_ex(ah1, &hp1);
			}

			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, getTrackingKey)
{
	zval *stats_key;
	zval *options = phalcon_fetch_nproperty_this(getThis(), SL("_options"), PH_NOISY TSRMLS_CC);

	if (!phalcon_array_isset_string_fetch(&stats_key, options, SS("statsKey"))) {
		RETURN_NULL();
	}

	RETURN_ZVAL(stats_key, 1, 0);
}

static PHP_METHOD(Phalcon_Cache_Backend_Memcache, setTrackingKey)
{
	zval **key, *options;
	int separated;

	phalcon_fetch_params_ex(1, 0, &key);

	options   = phalcon_fetch_nproperty_this(getThis(), SL("_options"), PH_NOISY TSRMLS_CC);
	separated = phalcon_maybe_separate_zval(&options);
	phalcon_array_update_string(&options, SL("statsKey"), *key, PH_COPY);

	if (separated) {
		Z_DELREF_P(options);
		phalcon_update_property_this(getThis(), SL("_options"), options TSRMLS_CC);
	}

	RETURN_ZVAL(getThis(), 1, 0);
}






zend_class_entry *phalcon_cache_backend_memory_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Memory, get);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, save);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Memory, flush);

static const zend_function_entry phalcon_cache_backend_memory_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Memory, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Memory, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Memory, cache_backend_memory, phalcon_cache_backend_ce, phalcon_cache_backend_memory_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_memory_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_memory_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, get){

	zval *key_name, *lifetime = NULL;
	zval *data, *cached_content, *frontend, *last_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);

	if (Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
		phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), last_key, 394299009UL TSRMLS_CC);
	}

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&cached_content, data, last_key)) {
		if (Z_TYPE_P(cached_content) != IS_NULL) {
			if (phalcon_is_numeric(cached_content)) {
				RETVAL_ZVAL(cached_content, 1, 0);
			} else {
				frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
				PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
			}
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *cached_content = NULL, *prepared_content = NULL, *is_buffering = NULL;
	zval *last_key, *frontend;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}

	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}

	if (phalcon_is_numeric(cached_content))	{
		phalcon_update_property_array(this_ptr, SL("_data"), last_key, cached_content TSRMLS_CC);
	} else {
		PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);
		phalcon_update_property_array(this_ptr, SL("_data"), last_key, prepared_content TSRMLS_CC);
	}

	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");

	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}

	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}

	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, delete){

	zval *key_name, *prefix, *key, *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);

	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, prefix, key_name);

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(data, key)) {
		phalcon_unset_property_array(this_ptr, SL("_data"), key TSRMLS_CC);
		RETURN_MM_TRUE;
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, queryKeys){

	zval *prefix = NULL;
	zval *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &prefix);

	if (prefix && unlikely(Z_TYPE_P(prefix) != IS_STRING)) {
		PHALCON_SEPARATE_PARAM(prefix);
		convert_to_string(prefix);
	}

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);

	if (likely(Z_TYPE_P(data) == IS_ARRAY)) {
		if (!prefix) {
			phalcon_array_keys(return_value, data);
		}
		else {
			HashPosition pos;
			char *str_index;
			uint str_index_len;
			ulong num_index;
			int type;

			for (
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data), &pos);
				(type = zend_hash_get_current_key_ex(Z_ARRVAL_P(data), &str_index, &str_index_len, &num_index, 0, &pos)) != HASH_KEY_NON_EXISTANT;
				zend_hash_move_forward_ex(Z_ARRVAL_P(data), &pos)
			) {
				if (type == HASH_KEY_IS_STRING && str_index_len > (uint)(Z_STRLEN_P(prefix)) && !memcmp(Z_STRVAL_P(prefix), str_index, str_index_len-1)) {
					add_next_index_stringl(return_value, str_index, str_index_len - 1, 1);
				}
				else if (unlikely(type == HASH_KEY_IS_LONG)) {
					char buf[8 * sizeof(ulong) + 2];
                    int buflength = 8 * sizeof(ulong) + 2;
					int size;
					size = snprintf(buf, buflength, "%ld", (long) num_index);
					if (size >= Z_STRLEN_P(prefix) && !memcmp(Z_STRVAL_P(prefix), buf, size)) {
						add_next_index_long(return_value, (long) num_index);
					}
				}
			}
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, exists){

	zval *key_name = NULL, *lifetime = NULL;
	zval *last_key, *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);

	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset(data, last_key)) {
			RETURN_MM_TRUE;
		}
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, increment){

	zval **key_name, **value = NULL, *last_key, *data;
	zval *cached_content;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	if (Z_TYPE_PP(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, *key_name);
	}

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&cached_content, data, last_key)) {
		RETVAL_FALSE;
		RETURN_MM();
	}


	add_function(return_value, cached_content, *value TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_data"), last_key, return_value TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, decrement){

	zval **key_name, **value = NULL, *last_key, *data;
	zval *cached_content;

	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();

	if (Z_TYPE_PP(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, *key_name);
	}

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&cached_content, data, last_key)) {
		RETVAL_FALSE;
		RETURN_MM();
	}

	sub_function(return_value, cached_content, *value TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_data"), last_key, return_value TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Memory, flush){

	phalcon_update_property_null(this_ptr, SL("_data") TSRMLS_CC);

	RETURN_TRUE;
}





#include <ext/standard/php_rand.h>


zend_class_entry *phalcon_cache_backend_mongo_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, __construct);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, _getCollection);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, get);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, save);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, gc);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Mongo, flush);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_mongo___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_mongo_empty, 0, 0, 0)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_mongo_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Mongo, __construct, arginfo_phalcon_cache_backend_mongo___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend_Mongo, _getCollection, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Cache_Backend_Mongo, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, gc, arginfo_phalcon_cache_backend_mongo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Mongo, flush, arginfo_phalcon_cache_backend_mongo_empty, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Mongo){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Mongo, cache_backend_mongo, phalcon_cache_backend_ce, phalcon_cache_backend_mongo_method_entry, 0);

	zend_declare_property_null(phalcon_cache_backend_mongo_ce, SL("_collection"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_backend_mongo_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, __construct){

	zval *frontend, *options = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &frontend, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_array_isset_quick_string(options, SS("mongo"), 238552933UL)) {
		if (!phalcon_array_isset_quick_string(options, SS("server"), 2350074396UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'server' is required");
			return;
		}
	}
	if (!phalcon_array_isset_quick_string(options, SS("db"), 193489131UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'db' is required");
		return;
	}
	
	if (!phalcon_array_isset_quick_string(options, SS("collection"), 1563790257UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The parameter 'collection' is required");
		return;
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_cache_backend_mongo_ce, this_ptr, "__construct", frontend, options);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, _getCollection){

	zval *mongo_collection, *mongo_database = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	mongo_collection = phalcon_fetch_nproperty_this(this_ptr, SL("_collection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(mongo_collection) != IS_OBJECT) {
		zval *options, *mongo;
		zval *server = NULL, *database = NULL, *collection = NULL;

		options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
		if (phalcon_array_isset_string_fetch(&mongo, options, SS("mongo"))) {
			if (Z_TYPE_P(mongo) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The 'mongo' parameter must be a valid Mongo instance");
				return;
			}
		} else {
			phalcon_array_isset_string_fetch(&server, options, SS("server"));
			if (!server || Z_TYPE_P(server) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB connection string");
				return;
			}
	
			ce0 = zend_fetch_class(SL("MongoClient"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
			PHALCON_INIT_VAR(mongo);
			object_init_ex(mongo, ce0);
			assert(phalcon_has_constructor(mongo TSRMLS_CC));
			PHALCON_CALL_METHOD(NULL, mongo, "__construct", server);
		}
	
		phalcon_array_isset_string_fetch(&database, options, SS("db"));
		if (!database || Z_TYPE_P(database) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB db");
			return;
		}
	
		phalcon_array_isset_string_fetch(&collection, options, SS("collection"));
		if (!collection || Z_TYPE_P(collection) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The backend requires a valid MongoDB collection");
			return;
		}
	
		PHALCON_CALL_METHOD(&mongo_database, mongo, "selectdb", database);
		PHALCON_RETURN_CALL_METHOD(mongo_database, "selectcollection", collection);
	}
	else {
		RETVAL_ZVAL(mongo_collection, 1, 0);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, get){

	zval *key_name, *lifetime = NULL, *frontend, *prefix, *prefixed_key;
	zval *collection = NULL, *conditions, *document = NULL, *time_condition;
	zval *cached_content;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 2);
	phalcon_array_update_string(&conditions, SL("key"), prefixed_key, PH_COPY);
	
	MAKE_STD_ZVAL(time_condition);
	array_init_size(time_condition, 1);
	add_assoc_long_ex(time_condition, SS("$gt"), (long int)time(NULL));
	add_assoc_zval_ex(conditions, SS("time"), time_condition);

	PHALCON_CALL_METHOD(&document, collection, "findone", conditions);
	if (Z_TYPE_P(document) == IS_ARRAY) { 
		if (likely(phalcon_array_isset_string_fetch(&cached_content, document, SS("data")))) {
			if (phalcon_is_numeric(cached_content)) {
				RETURN_CCTOR(cached_content);
			} else {
				PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
				RETURN_MM();
			}
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is corrupt");
			return;
		}
	} else {
		RETURN_MM_NULL();
	}
	
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *last_key, *frontend, *cached_content = NULL;
	zval *prepared_content = NULL, *ttl = NULL, *collection = NULL, *timestamp;
	zval *conditions, *document = NULL, *data, *is_buffering = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}

	if (!phalcon_is_numeric(cached_content)) {
		PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);
	}

	if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
		zval *tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(tmp) == IS_NULL) {
			PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
		}
		else {
			ttl = tmp;
		}
	} else {
		ttl = lifetime;
	}
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(timestamp);
	ZVAL_LONG(timestamp, (long) time(NULL) + phalcon_get_intval(ttl));
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	phalcon_array_update_string(&conditions, SL("key"), last_key, PH_COPY);
	
	PHALCON_CALL_METHOD(&document, collection, "findone", conditions);

	if (Z_TYPE_P(document) == IS_ARRAY) { 
		phalcon_array_update_string(&document, SL("time"), timestamp, PH_COPY);
		if (prepared_content) {
			phalcon_array_update_string(&document, SL("data"), prepared_content, PH_COPY);
		} else {
			phalcon_array_update_string(&document, SL("data"), cached_content, PH_COPY);
		}
		PHALCON_CALL_METHOD(NULL, collection, "save", document);
	} else {
		PHALCON_INIT_VAR(data);
		array_init_size(data, 3);
		phalcon_array_update_string(&data, SL("key"), last_key, PH_COPY);
		phalcon_array_update_string(&data, SL("time"), timestamp, PH_COPY);

		if (prepared_content) {
			phalcon_array_update_string(&data, SL("data"), prepared_content, PH_COPY);
		} else {
			phalcon_array_update_string(&data, SL("data"), cached_content, PH_COPY);
		}

		PHALCON_CALL_METHOD(NULL, collection, "save", data);
	}
	
	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");

	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}

	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, delete){

	zval *key_name, *prefix, *prefixed_key, *collection = NULL;
	zval *conditions;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	phalcon_array_update_string(&conditions, SL("key"), prefixed_key, PH_COPY);
	PHALCON_CALL_METHOD(NULL, collection, "remove", conditions);

	if ((php_rand(TSRMLS_C) % 100) == 0) {
		PHALCON_CALL_METHOD(NULL, getThis(), "gc");
	}

	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, queryKeys){

	zval *prefix = NULL, *collection = NULL, *fields = NULL, *pattern, *regex;
	zval *conditions, *documents = NULL, *documents_array = NULL, *time_condition;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &prefix);
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(fields);
	array_init_size(fields, 1);
	add_next_index_stringl(fields, SL("key"), 1);

	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 2);

	if (prefix && zend_is_true(prefix)) {
		PHALCON_INIT_VAR(pattern);
		PHALCON_CONCAT_SVS(pattern, "/^", prefix, "/");
		ce0 = zend_fetch_class(SL("MongoRegex"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	
		PHALCON_INIT_VAR(regex);
		object_init_ex(regex, ce0);
		assert(phalcon_has_constructor(regex TSRMLS_CC));
		PHALCON_CALL_METHOD(NULL, regex, "__construct", pattern);
	
		phalcon_array_update_string(&conditions, SL("key"), regex, PH_COPY);
	}
	
	MAKE_STD_ZVAL(time_condition);
	array_init_size(time_condition, 1);
	add_assoc_long_ex(time_condition, SS("$gt"), (long int)time(NULL));
	phalcon_array_update_string(&conditions, SL("time"), time_condition, 0);

	PHALCON_CALL_METHOD(&documents, collection, "find", conditions, fields);
	
	array_init(return_value);
	
	PHALCON_CALL_FUNCTION(&documents_array, "iterator_to_array", documents);

	phalcon_is_iterable(documents_array, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
		zval *key;
		if (likely(phalcon_array_isset_string_fetch(&key, *hd, SS("key")))) {
			Z_ADDREF_P(key);
			add_next_index_zval(return_value, key);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, exists){

	zval *key_name = NULL, *lifetime = NULL, *collection = NULL;
	zval *last_key;
	zval *conditions, *number = NULL, *time_condition;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_VV(last_key, prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		long int n;

		PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
		PHALCON_INIT_VAR(conditions);
		array_init_size(conditions, 2);
		phalcon_array_update_string(&conditions, SL("key"), last_key, PH_COPY);

		MAKE_STD_ZVAL(time_condition);
		array_init_size(time_condition, 1);
		add_assoc_long_ex(time_condition, SS("$gt"), (long int)time(NULL));
		phalcon_array_update_string(&conditions, SL("time"), time_condition, 0);
	
		PHALCON_CALL_METHOD(&number, collection, "count", conditions);

		n = likely(Z_TYPE_P(number) == IS_LONG) ? Z_LVAL_P(number) : phalcon_get_intval(number);

		RETVAL_BOOL(n > 0);
	}
	else {
		RETVAL_FALSE;
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, gc) {

	zval *conditions, *time_condition, *collection = NULL;

	PHALCON_MM_GROW();

	MAKE_STD_ZVAL(time_condition);
	array_init_size(time_condition, 1);
	add_assoc_long_ex(time_condition, SS("$gt"), (long int)time(NULL));

	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	add_assoc_zval_ex(conditions, SS("time"), time_condition);

	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	PHALCON_CALL_METHOD(NULL, collection, "remove", conditions);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, increment){

	zval *key_name, *lifetime = NULL, *frontend, *prefix, *prefixed_key, *value = NULL;
	zval *collection = NULL, *conditions, *document = NULL, *timestamp;
	zval *ttl = NULL, *modified_time, *difference, *not_expired;
	zval *cached_content;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &value);

	if (!value) {
		PHALCON_INIT_VAR(value);
		ZVAL_LONG(value, 1);
	} 

	if(Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1);
	}

	if (Z_TYPE_P(value) != IS_LONG) {	
		PHALCON_SEPARATE_PARAM(value);
		convert_to_long_ex(&value);
	}

	PHALCON_OBS_VAR(frontend);
	phalcon_read_property_this(&frontend, this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(prefix);
	phalcon_read_property_this(&prefix, this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	phalcon_array_update_string(&conditions, SL("key"), prefixed_key, PH_COPY);
	
	PHALCON_CALL_METHOD(&document, collection, "findone", conditions);

	PHALCON_INIT_VAR(timestamp);
	PHALCON_INIT_VAR(lifetime);
	ZVAL_LONG(timestamp, (long) time(NULL));

	PHALCON_OBS_NVAR(lifetime);
	phalcon_read_property_this(&lifetime, this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}

	
	if (!phalcon_array_isset_quick_string(document, SS("time"), 275614484UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
		return;
	}
	
	PHALCON_OBS_VAR(modified_time);
	phalcon_array_fetch_quick_string(&modified_time, document, SS("time"), 275614484UL, PH_NOISY);
	
	PHALCON_INIT_VAR(difference);
	sub_function(difference, timestamp, ttl TSRMLS_CC);
	
	PHALCON_INIT_VAR(not_expired);
	is_smaller_function(not_expired, difference, modified_time TSRMLS_CC);
	
	if (PHALCON_IS_TRUE(not_expired)) {
		if (!phalcon_array_isset_quick_string(document, SS("data"), 256359743UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
			return;
		}
	
		PHALCON_OBS_VAR(cached_content);
		phalcon_array_fetch_quick_string(&cached_content, document, SS("data"), 256359743UL, PH_NOISY);

		if(Z_TYPE_P(cached_content) != IS_LONG) {
			PHALCON_SEPARATE_PARAM(cached_content);
			convert_to_long_ex(&cached_content);
		}

		if (phalcon_is_numeric(cached_content)) {
			add_function(return_value, cached_content, value TSRMLS_CC);
				
			PHALCON_INIT_NVAR(ttl);
			phalcon_add_function(ttl, lifetime, timestamp TSRMLS_CC);

			PHALCON_CALL_METHOD(NULL, this_ptr, "save", prefixed_key, return_value);
		}

		RETURN_MM();
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, decrement){

	zval *key_name, *lifetime = NULL, *frontend, *prefix, *prefixed_key, *value = NULL;
	zval *collection = NULL, *conditions, *document = NULL, *timestamp;
	zval *ttl = NULL, *modified_time, *difference, *not_expired;
	zval *cached_content;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &value);

	if (!value) {
		PHALCON_INIT_VAR(value);
		ZVAL_LONG(value, 1);
	} 

	if(Z_TYPE_P(value) == IS_NULL) {
		ZVAL_LONG(value, 1);
	}

	if (Z_TYPE_P(value) != IS_LONG) {	
		PHALCON_SEPARATE_PARAM(value);
		convert_to_long_ex(&value);
	}

	PHALCON_OBS_VAR(frontend);
	phalcon_read_property_this(&frontend, this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(prefix);
	phalcon_read_property_this(&prefix, this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_VV(prefixed_key, prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	phalcon_array_update_string(&conditions, SL("key"), prefixed_key, PH_COPY);
	
	PHALCON_CALL_METHOD(&document, collection, "findone", conditions);

	PHALCON_INIT_VAR(timestamp);
	PHALCON_INIT_VAR(lifetime);
	ZVAL_LONG(timestamp, (long) time(NULL));

	PHALCON_OBS_NVAR(lifetime);
	phalcon_read_property_this(&lifetime, this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(lifetime) == IS_NULL) {
		PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
	} else {
		PHALCON_CPY_WRT(ttl, lifetime);
	}

	
	if (!phalcon_array_isset_quick_string(document, SS("time"), 275614484UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
		return;
	}
	
	PHALCON_OBS_VAR(modified_time);
	phalcon_array_fetch_quick_string(&modified_time, document, SS("time"), 275614484UL, PH_NOISY);
	
	PHALCON_INIT_VAR(difference);
	sub_function(difference, timestamp, ttl TSRMLS_CC);
	
	PHALCON_INIT_VAR(not_expired);
	is_smaller_function(not_expired, difference, modified_time TSRMLS_CC);
	
	if (PHALCON_IS_TRUE(not_expired)) {
		if (!phalcon_array_isset_quick_string(document, SS("data"), 256359743UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache is currupted");
			return;
		}
	
		PHALCON_OBS_VAR(cached_content);
		phalcon_array_fetch_quick_string(&cached_content, document, SS("data"), 256359743UL, PH_NOISY);

		if(Z_TYPE_P(cached_content) != IS_LONG) {
			PHALCON_SEPARATE_PARAM(cached_content);
			convert_to_long_ex(&cached_content);
		}

		if (phalcon_is_numeric(cached_content)) {
			sub_function(return_value, cached_content, value TSRMLS_CC);
				
			PHALCON_INIT_NVAR(ttl);
			phalcon_add_function(ttl, lifetime, timestamp TSRMLS_CC);

			PHALCON_CALL_METHOD(NULL, this_ptr, "save", prefixed_key, return_value);
		}

		RETURN_MM();
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Cache_Backend_Mongo, flush){

	zval *collection = NULL;

	PHALCON_MM_GROW();
	
	PHALCON_CALL_METHOD(&collection, this_ptr, "_getcollection");
	PHALCON_CALL_METHOD(NULL, collection, "remove");

	if ((php_rand(TSRMLS_C) % 100) == 0) {
		PHALCON_CALL_METHOD(NULL, getThis(), "gc");
	}

	RETURN_MM_TRUE;
}






zend_class_entry *phalcon_cache_backend_xcache_ce;

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, __construct);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, get);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, save);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, delete);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, queryKeys);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, exists);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, increment);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, decrement);
static PHP_METHOD(Phalcon_Cache_Backend_Xcache, flush);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_backend_xcache___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, frontend)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_backend_xcache_method_entry[] = {
	PHP_ME(Phalcon_Cache_Backend_Xcache, __construct, arginfo_phalcon_cache_backend_xcache___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Backend_Xcache, get, arginfo_phalcon_cache_backendinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, save, arginfo_phalcon_cache_backendinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, delete, arginfo_phalcon_cache_backendinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, queryKeys, arginfo_phalcon_cache_backendinterface_querykeys, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, exists, arginfo_phalcon_cache_backendinterface_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, increment, arginfo_phalcon_cache_backendinterface_increment, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, decrement, arginfo_phalcon_cache_backendinterface_decrement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Backend_Xcache, flush, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Backend_Xcache){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Backend, Xcache, cache_backend_xcache, phalcon_cache_backend_ce, phalcon_cache_backend_xcache_method_entry, 0);

	zend_class_implements(phalcon_cache_backend_xcache_ce TSRMLS_CC, 1, phalcon_cache_backendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, __construct){

	zval *frontend, *options = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &frontend, &options);
	
	if (!options) {
		PHALCON_INIT_VAR(options);
	} else {
		PHALCON_SEPARATE_PARAM(options);
	}
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}

	if (!phalcon_array_isset_quick_string(options, SS("statsKey"), 2508919229UL)) {
		phalcon_array_update_string_string(&options, SL("statsKey"), SL("_PHCX"), 0);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_cache_backend_xcache_ce, this_ptr, "__construct", frontend, options);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, get){

	zval *key_name, *lifetime = NULL, *frontend, *prefix, *prefixed_key;
	zval *cached_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &key_name, &lifetime);
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	prefix   = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCX", prefix, key_name);
	phalcon_update_property_this_quick(this_ptr, SL("_lastKey"), prefixed_key, 394299009UL TSRMLS_CC);
	
	PHALCON_CALL_FUNCTION(&cached_content, "xcache_get", prefixed_key);
	if (Z_TYPE_P(cached_content) == IS_NULL) {
		RETURN_MM_NULL();
	}

	if (phalcon_is_numeric(cached_content)) {
		RETURN_CCTOR(cached_content);
	} else {
		PHALCON_RETURN_CALL_METHOD(frontend, "afterretrieve", cached_content);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, save){

	zval *key_name = NULL, *content = NULL, *lifetime = NULL, *stop_buffer = NULL;
	zval *cached_content = NULL, *keys = NULL, *last_key, *frontend;
	zval *prepared_content = NULL, *ttl = NULL, *success = NULL, *is_buffering = NULL;
	zval *prefix, *options, *special_key, *z_zero, *tmp;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 4, &key_name, &content, &lifetime, &stop_buffer);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCX", prefix, key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}
	
	frontend = phalcon_fetch_nproperty_this(this_ptr, SL("_frontend"), PH_NOISY TSRMLS_CC);
	if (!content || Z_TYPE_P(content) == IS_NULL) {
		PHALCON_CALL_METHOD(&cached_content, frontend, "getcontent");
	} else {
		cached_content = content;
	}
	
	if (!phalcon_is_numeric(cached_content)) {
		PHALCON_CALL_METHOD(&prepared_content, frontend, "beforestore", cached_content);
	}
	
	if (!lifetime || Z_TYPE_P(lifetime) == IS_NULL) {
		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_lastLifetime"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(tmp) == IS_NULL) {
			PHALCON_CALL_METHOD(&ttl, frontend, "getlifetime");
		}
		else {
			ttl = tmp;
		}
	} else {
		ttl = lifetime;
	}
	
	if (!prepared_content) {
		PHALCON_CALL_FUNCTION(&success, "xcache_set", last_key, cached_content, ttl);
	} else {
		PHALCON_CALL_FUNCTION(&success, "xcache_set", last_key, prepared_content, ttl);
	}
	
	PHALCON_CALL_METHOD(&is_buffering, frontend, "isbuffering");
	if (!stop_buffer || PHALCON_IS_TRUE(stop_buffer)) {
		PHALCON_CALL_METHOD(NULL, frontend, "stop");
	}
	
	if (PHALCON_IS_TRUE(is_buffering)) {
		zend_print_zval(cached_content, 0);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	
	if (zend_is_true(success)) {
	
		options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
		if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
			return;
		}
	
		PHALCON_CALL_FUNCTION(&keys, "xcache_get", special_key);
		if (Z_TYPE_P(keys) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(keys);
			array_init(keys);
		}
	
		z_zero = PHALCON_GLOBAL(z_zero);
		phalcon_array_update_zval(&keys, last_key, ttl, PH_COPY);
		PHALCON_CALL_FUNCTION(NULL, "xcache_set", special_key, keys, z_zero);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, delete){

	zval *key_name, *prefix, *prefixed_key;
	zval *options, *special_key, *keys = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key_name);
	
	prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefixed_key);
	PHALCON_CONCAT_SVV(prefixed_key, "_PHCX", prefix, key_name);
	
	PHALCON_RETURN_CALL_FUNCTION("xcache_unset", prefixed_key);
	
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_CALL_FUNCTION(&keys, "xcache_get", special_key);
	if (Z_TYPE_P(keys) == IS_ARRAY) { 
		zval *z_zero = PHALCON_GLOBAL(z_zero);
		phalcon_array_unset(&keys, prefixed_key, 0);
		PHALCON_CALL_FUNCTION(NULL, "xcache_set", special_key, keys, z_zero);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, queryKeys){

	zval *prefix = NULL, *prefixed, *options, *special_key;
	zval *keys = NULL, *real_key = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &prefix);

	PHALCON_INIT_VAR(prefixed);
	if (!prefix) {
		ZVAL_STRING(prefixed, "_PHCX", 1);
	}
	else {
		PHALCON_CONCAT_SV(prefixed, "_PHCX", prefix);
	}
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}
	
	array_init(return_value);

	PHALCON_CALL_FUNCTION(&keys, "xcache_get", special_key);
	if (Z_TYPE_P(keys) == IS_ARRAY) {
		HashPosition pos;
		zval **value;

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void**)&value, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &pos)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(keys), &pos);
	
			if (Z_TYPE(key) == IS_STRING && phalcon_memnstr(&key, prefixed)) {
				PHALCON_INIT_NVAR(real_key);
				phalcon_substr(real_key, &key, 5, 0);
				phalcon_array_append(&return_value, real_key, 0);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, exists){

	zval *key_name = NULL, *lifetime = NULL, *last_key;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &key_name, &lifetime);
	
	if (!key_name || Z_TYPE_P(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCX", prefix, key_name);
	}

	if (zend_is_true(last_key)) {
		PHALCON_RETURN_CALL_FUNCTION("xcache_isset", last_key);
	}
	else {
		RETVAL_FALSE;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, increment){
	
	zval **key_name = NULL, **value = NULL, *last_key = NULL;
	zval *origVal = NULL;
	
	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();
	
	if (Z_TYPE_PP(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCX", prefix, *key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}

	if (phalcon_function_quick_exists_ex(SS("xcache_inc"), 3083158730UL TSRMLS_CC) == SUCCESS) {
		PHALCON_RETURN_CALL_FUNCTION("xcache_inc", last_key, *value);
	} else {
		PHALCON_CALL_FUNCTION(&origVal, "xcache_get", last_key);
		add_function(return_value, origVal, *value TSRMLS_CC);
		PHALCON_CALL_METHOD(NULL, this_ptr, "save", *key_name, return_value);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, decrement){
	
	zval **key_name = NULL, **value = NULL, *last_key = NULL;
	zval *origVal = NULL;
	
	phalcon_fetch_params_ex(1, 1, &key_name, &value);

	if (!value || Z_TYPE_PP(value) == IS_NULL) {
		value = &PHALCON_GLOBAL(z_one);
	}
	else {
		PHALCON_ENSURE_IS_LONG(value);
	}

	PHALCON_MM_GROW();
	
	if (Z_TYPE_PP(key_name) == IS_NULL) {
		last_key = phalcon_fetch_nproperty_this(this_ptr, SL("_lastKey"), PH_NOISY TSRMLS_CC);
	} else {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(last_key);
		PHALCON_CONCAT_SVV(last_key, "_PHCX", prefix, *key_name);
	}

	if (!zend_is_true(last_key)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "The cache must be started first");
		return;
	}

	if (phalcon_function_quick_exists_ex(SS("xcache_inc"), 3083158730UL TSRMLS_CC) == SUCCESS) {
		PHALCON_RETURN_CALL_FUNCTION("xcache_inc", last_key, *value);
	} else {
		PHALCON_CALL_FUNCTION(&origVal, "xcache_get", last_key);
		sub_function(return_value, origVal, *value TSRMLS_CC);
		PHALCON_CALL_METHOD(NULL, this_ptr, "save", *key_name, return_value);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Cache_Backend_Xcache, flush){

	zval *prefixed, *options, *special_key, *z_zero;
	zval *keys = NULL, *real_key = NULL;
	HashPosition pos;
	zval **value;

	PHALCON_MM_GROW();

	z_zero = PHALCON_GLOBAL(z_zero);

	PHALCON_INIT_VAR(prefixed);
	ZVAL_STRING(prefixed, "_PHCX", 1);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	if (unlikely(!phalcon_array_isset_string_fetch(&special_key, options, SS("statsKey")))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cache_exception_ce, "Unexpected inconsistency in options");
		return;
	}

	PHALCON_CALL_FUNCTION(&keys, "xcache_get", special_key);
	if (Z_TYPE_P(keys) == IS_ARRAY) {
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(keys), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(keys), (void**)&value, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(keys), &pos)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(keys), &pos);

			PHALCON_INIT_NVAR(real_key);
			ZVAL_STRINGL(real_key, Z_STRVAL(key), Z_STRLEN(key), 1);
	
			PHALCON_CALL_FUNCTION(NULL, "xcache_unset", real_key);
		}

		zend_hash_clean(Z_ARRVAL_P(keys));
		PHALCON_CALL_FUNCTION(NULL, "xcache_set", special_key, keys, z_zero);
	}
	
	RETURN_MM_TRUE;
}






zend_class_entry *phalcon_cache_frontend_base64_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_Base64, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_Base64, afterRetrieve);

static const zend_function_entry phalcon_cache_frontend_base64_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_Base64, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Base64, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Base64){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Frontend, Base64, cache_frontend_base64, phalcon_cache_frontend_data_ce, phalcon_cache_frontend_base64_method_entry, 0);

	zend_class_implements(phalcon_cache_frontend_base64_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Base64, beforeStore){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	phalcon_base64_encode(return_value, data);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Base64, afterRetrieve){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	phalcon_base64_decode(return_value, data);
}






zend_class_entry *phalcon_cache_frontend_data_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_Data, __construct);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, getLifetime);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, isBuffering);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, start);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, getContent);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, stop);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_Data, afterRetrieve);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_frontend_data___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, frontendOptions)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_frontend_data_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_Data, __construct, arginfo_phalcon_cache_frontend_data___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Frontend_Data, getLifetime, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, isBuffering, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, start, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, getContent, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, stop, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Data, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Data){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Data, cache_frontend_data, phalcon_cache_frontend_data_method_entry, 0);

	zend_declare_property_null(phalcon_cache_frontend_data_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_frontend_data_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, __construct){

	zval *frontend_options = NULL;

	phalcon_fetch_params(0, 0, 1, &frontend_options);
	
	if (frontend_options) {
		phalcon_update_property_this_quick(this_ptr, SL("_frontendOptions"), frontend_options, 164501392UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, getLifetime){

	zval *options, *lifetime;

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_frontendOptions"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&lifetime, options, SS("lifetime"))) {
		RETURN_ZVAL(lifetime, 1, 0);
	}
	else {
		RETURN_LONG(1);
	}
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, isBuffering){


	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, start){


	
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, getContent){


	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, stop){


	
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, beforeStore){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	phalcon_serialize(return_value, &data TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Data, afterRetrieve){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	phalcon_unserialize(return_value, data TSRMLS_CC);
}






zend_class_entry *phalcon_cache_frontend_igbinary_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_Igbinary, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_Igbinary, afterRetrieve);

static const zend_function_entry phalcon_cache_frontend_igbinary_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_Igbinary, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Igbinary, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Igbinary){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Frontend, Igbinary, cache_frontend_igbinary, phalcon_cache_frontend_data_ce, phalcon_cache_frontend_igbinary_method_entry, 0);

	zend_class_implements(phalcon_cache_frontend_igbinary_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Igbinary, beforeStore){

	zval *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	PHALCON_RETURN_CALL_FUNCTION("igbinary_serialize", data);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Cache_Frontend_Igbinary, afterRetrieve){

	zval *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	PHALCON_RETURN_CALL_FUNCTION("igbinary_unserialize", data);
	RETURN_MM();
}





zend_class_entry *phalcon_cache_frontend_json_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_Json, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_Json, afterRetrieve);

static const zend_function_entry phalcon_cache_frontend_json_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_Json, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Json, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Json){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Frontend, Json, cache_frontend_json, phalcon_cache_frontend_data_ce, phalcon_cache_frontend_json_method_entry, 0);

	zend_class_implements(phalcon_cache_frontend_json_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Json, beforeStore){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ON_FAILURE(phalcon_json_encode(return_value, data, 0 TSRMLS_CC));
}

static PHP_METHOD(Phalcon_Cache_Frontend_Json, afterRetrieve){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ON_FAILURE(phalcon_json_decode(return_value, data, 0 TSRMLS_CC));
}






zend_class_entry *phalcon_cache_frontend_none_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_None, getLifetime);
static PHP_METHOD(Phalcon_Cache_Frontend_None, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_None, afterRetrieve);

static const zend_function_entry phalcon_cache_frontend_none_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_None, getLifetime, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_None, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_None, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_None){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Cache\\Frontend, None, cache_frontend_none, phalcon_cache_frontend_data_ce, phalcon_cache_frontend_none_method_entry, 0);

	zend_class_implements(phalcon_cache_frontend_none_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_None, getLifetime){


	RETURN_LONG(1);
}

static PHP_METHOD(Phalcon_Cache_Frontend_None, beforeStore){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ZVAL(data, 1, 0);
}

static PHP_METHOD(Phalcon_Cache_Frontend_None, afterRetrieve){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ZVAL(data, 1, 0);
}






zend_class_entry *phalcon_cache_frontend_output_ce;

static PHP_METHOD(Phalcon_Cache_Frontend_Output, __construct);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, getLifetime);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, isBuffering);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, start);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, getContent);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, stop);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, beforeStore);
static PHP_METHOD(Phalcon_Cache_Frontend_Output, afterRetrieve);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cache_frontend_output___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, frontendOptions)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cache_frontend_output_method_entry[] = {
	PHP_ME(Phalcon_Cache_Frontend_Output, __construct, arginfo_phalcon_cache_frontend_output___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Cache_Frontend_Output, getLifetime, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, isBuffering, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, start, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, getContent, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, stop, arginfo_phalcon_cache_frontendinterface_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, beforeStore, arginfo_phalcon_cache_frontendinterface_beforestore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Cache_Frontend_Output, afterRetrieve, arginfo_phalcon_cache_frontendinterface_afterretrieve, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Cache_Frontend_Output){

	PHALCON_REGISTER_CLASS(Phalcon\\Cache\\Frontend, Output, cache_frontend_output, phalcon_cache_frontend_output_method_entry, 0);

	zend_declare_property_bool(phalcon_cache_frontend_output_ce, SL("_buffering"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cache_frontend_output_ce, SL("_frontendOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cache_frontend_output_ce TSRMLS_CC, 1, phalcon_cache_frontendinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, __construct){

	zval *frontend_options = NULL;

	phalcon_fetch_params(0, 0, 1, &frontend_options);
	
	if (frontend_options) {
		phalcon_update_property_this_quick(this_ptr, SL("_frontendOptions"), frontend_options, 164501392UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, getLifetime){

	zval *options, *lifetime;

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_frontendOptions"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&lifetime, options, SS("lifetime"))) {
		RETURN_ZVAL(lifetime, 1, 0);
	}
	else {
		RETURN_LONG(1);
	}
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, isBuffering){


	RETURN_MEMBER_QUICK(this_ptr, "_buffering", 4086213532UL);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, start){

	phalcon_update_property_bool(this_ptr, SL("_buffering"), 1 TSRMLS_CC);
	phalcon_ob_start(TSRMLS_C);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, getContent){

	zval *buffering;

	buffering = phalcon_fetch_nproperty_this(this_ptr, SL("_buffering"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(buffering)) {
		phalcon_ob_get_contents(return_value TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, stop){

	zval *buffering;

	buffering = phalcon_fetch_nproperty_this(this_ptr, SL("_buffering"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(buffering)) {
		phalcon_ob_end_clean(TSRMLS_C);
	}
	
	phalcon_update_property_bool(this_ptr, SL("_buffering"), 0 TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, beforeStore){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ZVAL(data, 1, 0);
}

static PHP_METHOD(Phalcon_Cache_Frontend_Output, afterRetrieve){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	RETURN_ZVAL(data, 1, 0);
}






zend_class_entry *phalcon_cli_console_ce;

static PHP_METHOD(Phalcon_CLI_Console, __construct);
static PHP_METHOD(Phalcon_CLI_Console, setDI);
static PHP_METHOD(Phalcon_CLI_Console, getDI);
static PHP_METHOD(Phalcon_CLI_Console, setEventsManager);
static PHP_METHOD(Phalcon_CLI_Console, getEventsManager);
static PHP_METHOD(Phalcon_CLI_Console, registerModules);
static PHP_METHOD(Phalcon_CLI_Console, addModules);
static PHP_METHOD(Phalcon_CLI_Console, getModules);
static PHP_METHOD(Phalcon_CLI_Console, handle);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console_seteventsmanager, 0, 0, 1)
	ZEND_ARG_INFO(0, eventsManager)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console_registermodules, 0, 0, 1)
	ZEND_ARG_INFO(0, modules)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console_addmodules, 0, 0, 1)
	ZEND_ARG_INFO(0, modules)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_console_handle, 0, 0, 0)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cli_console_method_entry[] = {
	PHP_ME(Phalcon_CLI_Console, __construct, arginfo_phalcon_cli_console___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_CLI_Console, setDI, arginfo_phalcon_cli_console_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, getDI, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, setEventsManager, arginfo_phalcon_cli_console_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, getEventsManager, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, registerModules, arginfo_phalcon_cli_console_registermodules, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, addModules, arginfo_phalcon_cli_console_addmodules, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, getModules, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Console, handle, arginfo_phalcon_cli_console_handle, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_CLI_Console){

	PHALCON_REGISTER_CLASS(Phalcon\\CLI, Console, cli_console, phalcon_cli_console_method_entry, 0);

	zend_declare_property_null(phalcon_cli_console_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_modules"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_console_ce, SL("_moduleObject"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cli_console_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_CLI_Console, __construct){

	zval *dependency_injector = NULL;

	phalcon_fetch_params(0, 0, 1, &dependency_injector);
	
	if (dependency_injector && Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_CLI_Console, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_cli_console_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_CLI_Console, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_CLI_Console, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Console, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_CLI_Console, registerModules){

	zval *modules;

	phalcon_fetch_params(0, 1, 0, &modules);
	
	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_cli_console_exception_ce, "Modules must be an Array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_modules"), modules, 379092157UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Console, addModules){

	zval *modules, *original_modules, *register_modules;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &modules);
	
	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Modules must be an Array");
		return;
	}
	
	PHALCON_OBS_VAR(original_modules);
	phalcon_read_property_this(&original_modules, this_ptr, SL("_modules"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(register_modules);
	phalcon_fast_array_merge(register_modules, &modules, &original_modules TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modules"), register_modules, 379092157UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_CLI_Console, getModules){


	RETURN_MEMBER_QUICK(this_ptr, "_modules", 379092157UL);
}

static PHP_METHOD(Phalcon_CLI_Console, handle){

	zval *arguments = NULL, *dependency_injector, *events_manager;
	zval *service = NULL, *router = NULL, *module_name = NULL, *event_name = NULL;
	zval *status = NULL, *modules, *exception_msg = NULL, *module;
	zval *path, *class_name = NULL, *module_object = NULL, *task_name = NULL;
	zval *action_name = NULL, *params = NULL, *dispatcher = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &arguments);
	
	if (!arguments) {
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "A dependency injection object is required to access internal services");
		return;
	}
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_router);
	
	PHALCON_CALL_METHOD(&router, dependency_injector, "getshared", service);
	PHALCON_VERIFY_CLASS(router, phalcon_cli_router_ce);
	PHALCON_CALL_METHOD(NULL, router, "handle", arguments);
	
	PHALCON_CALL_METHOD(&module_name, router, "getmodulename");
	if (zend_is_true(module_name)) {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "console:beforeStartModule", 1);
	
			PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, module_name);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_MM_FALSE;
			}
		}
	
		PHALCON_OBS_VAR(modules);
		phalcon_read_property_this(&modules, this_ptr, SL("_modules"), PH_NOISY TSRMLS_CC);
		if (!phalcon_array_isset(modules, module_name)) {
			PHALCON_INIT_VAR(exception_msg);
			PHALCON_CONCAT_SVS(exception_msg, "Module '", module_name, "' isn't registered in the console container");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_cli_console_exception_ce, exception_msg);
			return;
		}
	
		PHALCON_OBS_VAR(module);
		phalcon_array_fetch(&module, modules, module_name, PH_NOISY);
		if (Z_TYPE_P(module) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_cli_console_exception_ce, "Invalid module definition path");
			return;
		}
	
		if (phalcon_array_isset_quick_string(module, SS("path"), 270591026UL)) {
	
			PHALCON_OBS_VAR(path);
			phalcon_array_fetch_quick_string(&path, module, SS("path"), 270591026UL, PH_NOISY);
			convert_to_string_ex(&path);

			if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
				RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(path) TSRMLS_CC));
			} else {
				zend_throw_exception_ex(phalcon_cli_console_exception_ce, 0 TSRMLS_CC, "Modules definition path '%s' does not exist", Z_STRVAL_P(path));
				PHALCON_MM_RESTORE();
				return;
			}
		}
	
		if (phalcon_array_isset_quick_string(module, SS("className"), 362439804UL)) {
			PHALCON_OBS_VAR(class_name);
			phalcon_array_fetch_quick_string(&class_name, module, SS("className"), 362439804UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(class_name);
			ZVAL_STRING(class_name, "Module", 1);
		}
	
		PHALCON_CALL_METHOD(&module_object, dependency_injector, "get", class_name);
		PHALCON_CALL_METHOD(NULL, module_object, "registerautoloaders");
		PHALCON_CALL_METHOD(NULL, module_object, "registerservices", dependency_injector);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			phalcon_update_property_this_quick(this_ptr, SL("_moduleObject"), module_object, 121977121UL TSRMLS_CC);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "console:afterStartModule", 1);
	
			PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, module_name);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_MM_FALSE;
			}
		}
	}
	
	PHALCON_CALL_METHOD(&task_name, router, "gettaskname");
	PHALCON_CALL_METHOD(&action_name, router, "getactionname");
	PHALCON_CALL_METHOD(&params, router, "getparams");
	
	PHALCON_INIT_NVAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_dispatcher);
	
	PHALCON_CALL_METHOD(&dispatcher, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(dispatcher, phalcon_dispatcherinterface_ce);
	PHALCON_CALL_METHOD(NULL, dispatcher, "settaskname", task_name);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setactionname", action_name);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setparams", params);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "console:beforeHandleTask", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, dispatcher);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_RETURN_CALL_METHOD(dispatcher, "dispatch");
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "console:afterHandleTask", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, return_value);
	}
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_cli_dispatcher_ce;

static PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskSuffix);
static PHP_METHOD(Phalcon_CLI_Dispatcher, setDefaultTask);
static PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskName);
static PHP_METHOD(Phalcon_CLI_Dispatcher, getTaskName);
static PHP_METHOD(Phalcon_CLI_Dispatcher, _throwDispatchException);
static PHP_METHOD(Phalcon_CLI_Dispatcher, _handleException);
static PHP_METHOD(Phalcon_CLI_Dispatcher, getTaskClass);
static PHP_METHOD(Phalcon_CLI_Dispatcher, getLastTask);
static PHP_METHOD(Phalcon_CLI_Dispatcher, getActiveTask);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_dispatcher_settasksuffix, 0, 0, 1)
	ZEND_ARG_INFO(0, taskSuffix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_dispatcher_setdefaulttask, 0, 0, 1)
	ZEND_ARG_INFO(0, taskName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_dispatcher_settaskname, 0, 0, 1)
	ZEND_ARG_INFO(0, taskName)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cli_dispatcher_method_entry[] = {
	PHP_ME(Phalcon_CLI_Dispatcher, setTaskSuffix, arginfo_phalcon_cli_dispatcher_settasksuffix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, setDefaultTask, arginfo_phalcon_cli_dispatcher_setdefaulttask, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, setTaskName, arginfo_phalcon_cli_dispatcher_settaskname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, getTaskName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, _throwDispatchException, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_CLI_Dispatcher, _handleException, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_CLI_Dispatcher, getTaskClass, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, getLastTask, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Dispatcher, getActiveTask, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_CLI_Dispatcher){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI, Dispatcher, cli_dispatcher, phalcon_dispatcher_ce, phalcon_cli_dispatcher_method_entry, 0);

	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_handlerSuffix"), "Task", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_defaultHandler"), "main", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_cli_dispatcher_ce, SL("_defaultAction"), "main", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cli_dispatcher_ce TSRMLS_CC, 1, phalcon_dispatcherinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskSuffix){

	zval *task_suffix;

	phalcon_fetch_params(0, 1, 0, &task_suffix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_handlerSuffix"), task_suffix, 1659190583UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, setDefaultTask){

	zval *task_name;

	phalcon_fetch_params(0, 1, 0, &task_name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultHandler"), task_name, 2940762855UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, setTaskName){

	zval *task_name;

	phalcon_fetch_params(0, 1, 0, &task_name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), task_name, 2743819555UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, getTaskName){


	RETURN_MEMBER_QUICK(this_ptr, "_handlerName", 2743819555UL);
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, _throwDispatchException){

	zval *message, *exception_code = NULL, *exception, *events_manager;
	zval *event_name, *status = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &exception_code);
	
	if (!exception_code) {
		exception_code = PHALCON_GLOBAL(z_zero);
	}
	
	PHALCON_INIT_VAR(exception);
	object_init_ex(exception, phalcon_cli_dispatcher_exception_ce);
	PHALCON_CALL_METHOD(NULL, exception, "__construct", message, exception_code);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, exception);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	phalcon_throw_exception(exception TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, _handleException){

	zval *exception, *events_manager, *event_name;
	zval *status = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &exception);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, exception);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, getTaskClass){


	PHALCON_MM_GROW();

	PHALCON_RETURN_CALL_METHOD(this_ptr, "gethandlername");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, getLastTask){


	RETURN_MEMBER_QUICK(this_ptr, "_lastHandler", 1315517974UL);
}

static PHP_METHOD(Phalcon_CLI_Dispatcher, getActiveTask){


	RETURN_MEMBER_QUICK(this_ptr, "_activeHandler", 2923197278UL);
}







zend_class_entry *phalcon_cli_router_ce;

static PHP_METHOD(Phalcon_CLI_Router, __construct);
static PHP_METHOD(Phalcon_CLI_Router, setDI);
static PHP_METHOD(Phalcon_CLI_Router, getDI);
static PHP_METHOD(Phalcon_CLI_Router, setDefaultModule);
static PHP_METHOD(Phalcon_CLI_Router, setDefaultTask);
static PHP_METHOD(Phalcon_CLI_Router, setDefaultAction);
static PHP_METHOD(Phalcon_CLI_Router, handle);
static PHP_METHOD(Phalcon_CLI_Router, getModuleName);
static PHP_METHOD(Phalcon_CLI_Router, getTaskName);
static PHP_METHOD(Phalcon_CLI_Router, getActionName);
static PHP_METHOD(Phalcon_CLI_Router, getParams);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_router_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_router_setdefaultmodule, 0, 0, 1)
	ZEND_ARG_INFO(0, moduleName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_router_setdefaulttask, 0, 0, 1)
	ZEND_ARG_INFO(0, taskName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_router_setdefaultaction, 0, 0, 1)
	ZEND_ARG_INFO(0, actionName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_cli_router_handle, 0, 0, 0)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_cli_router_method_entry[] = {
	PHP_ME(Phalcon_CLI_Router, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_CLI_Router, setDI, arginfo_phalcon_cli_router_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, getDI, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, setDefaultModule, arginfo_phalcon_cli_router_setdefaultmodule, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, setDefaultTask, arginfo_phalcon_cli_router_setdefaulttask, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, setDefaultAction, arginfo_phalcon_cli_router_setdefaultaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, handle, arginfo_phalcon_cli_router_handle, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, getModuleName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, getTaskName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, getActionName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_CLI_Router, getParams, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_CLI_Router){

	PHALCON_REGISTER_CLASS(Phalcon\\CLI, Router, cli_router, phalcon_cli_router_method_entry, 0);

	zend_declare_property_null(phalcon_cli_router_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_module"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_task"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultModule"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultTask"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultAction"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_cli_router_ce, SL("_defaultParams"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_cli_router_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_CLI_Router, __construct){

	phalcon_update_property_empty_array(this_ptr, SL("_params") TSRMLS_CC);
	phalcon_update_property_empty_array(this_ptr, SL("_defaultParams") TSRMLS_CC);
}

static PHP_METHOD(Phalcon_CLI_Router, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_cli_router_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_CLI_Router, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_CLI_Router, setDefaultModule){

	zval *module_name;

	phalcon_fetch_params(0, 1, 0, &module_name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultModule"), module_name, 3959488399UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Router, setDefaultTask){

	zval *task_name;

	phalcon_fetch_params(0, 1, 0, &task_name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultTask"), task_name, 3852862556UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Router, setDefaultAction){

	zval *action_name;

	phalcon_fetch_params(0, 1, 0, &action_name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultAction"), action_name, 895696999UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_CLI_Router, handle){

	zval *arguments = NULL, *module_name = NULL, *task_name = NULL, *action_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &arguments);
	
	if (!arguments) {
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
	} else {
		PHALCON_SEPARATE_PARAM(arguments);
	}
	
	if (Z_TYPE_P(arguments) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_cli_router_exception_ce, "Arguments must be an Array");
		return;
	}
	
	PHALCON_INIT_VAR(module_name);
	
	PHALCON_INIT_VAR(task_name);
	
	PHALCON_INIT_VAR(action_name);
	
	if (phalcon_array_isset_quick_string(arguments, SS("module"), 3565923467UL)) {
		PHALCON_OBS_NVAR(module_name);
		phalcon_array_fetch_quick_string(&module_name, arguments, SS("module"), 3565923467UL, PH_NOISY);
		phalcon_array_unset_string(&arguments, SS("module"), PH_SEPARATE);
	}
	
	if (phalcon_array_isset_quick_string(arguments, SS("task"), 275333720UL)) {
		PHALCON_OBS_NVAR(task_name);
		phalcon_array_fetch_quick_string(&task_name, arguments, SS("task"), 275333720UL, PH_NOISY);
		phalcon_array_unset_string(&arguments, SS("task"), PH_SEPARATE);
	}
	
	if (phalcon_array_isset_quick_string(arguments, SS("action"), 502132067UL)) {
		PHALCON_OBS_NVAR(action_name);
		phalcon_array_fetch_quick_string(&action_name, arguments, SS("action"), 502132067UL, PH_NOISY);
		phalcon_array_unset_string(&arguments, SS("action"), PH_SEPARATE);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_module"), module_name, 4176304298UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_task"), task_name, 3991100087UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_action"), action_name, 1112512898UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_params"), arguments, 3223731112UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_CLI_Router, getModuleName){


	RETURN_MEMBER_QUICK(this_ptr, "_module", 4176304298UL);
}

static PHP_METHOD(Phalcon_CLI_Router, getTaskName){


	RETURN_MEMBER_QUICK(this_ptr, "_task", 3991100087UL);
}

static PHP_METHOD(Phalcon_CLI_Router, getActionName){


	RETURN_MEMBER_QUICK(this_ptr, "_action", 1112512898UL);
}

static PHP_METHOD(Phalcon_CLI_Router, getParams){


	RETURN_MEMBER_QUICK(this_ptr, "_params", 3223731112UL);
}







zend_class_entry *phalcon_cli_task_ce;

static const zend_function_entry phalcon_cli_task_method_entry[] = {
	PHP_FE_END
};



PHALCON_INIT_CLASS(Phalcon_CLI_Task){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI, Task, cli_task, phalcon_di_injectable_ce, phalcon_cli_task_method_entry, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_cli_console_exception_ce;

PHALCON_INIT_CLASS(Phalcon_CLI_Console_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Console, Exception, cli_console_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_cli_dispatcher_exception_ce;

PHALCON_INIT_CLASS(Phalcon_CLI_Dispatcher_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Dispatcher, Exception, cli_dispatcher_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_cli_router_exception_ce;

PHALCON_INIT_CLASS(Phalcon_CLI_Router_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\CLI\\Router, Exception, cli_router_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_config_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Config_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config, Exception, config_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_config_adapter_ini_ce;

static PHP_METHOD(Phalcon_Config_Adapter_Ini, __construct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_adapter_ini___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, filePath)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_config_adapter_ini_method_entry[] = {
	PHP_ME(Phalcon_Config_Adapter_Ini, __construct, arginfo_phalcon_config_adapter_ini___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};

static void phalcon_config_adapter_ini_update_zval_directive(zval **arr, zval *section, zval *directive, zval *value TSRMLS_DC)
{
	zval *t1, *t2;
	zval **temp1 = &t1, **temp2 = &t2, *index = NULL;
	int i, n;

	assert(Z_TYPE_PP(arr) == IS_ARRAY);
	assert(Z_TYPE_P(directive) == IS_ARRAY);

	n = zend_hash_num_elements(Z_ARRVAL_P(directive));
	assert(n > 1);

	if (!phalcon_array_isset_fetch(temp1, *arr, section)) {
		PHALCON_ALLOC_GHOST_ZVAL(t1);
		array_init_size(t1, 1);
		phalcon_array_update_zval(arr, section, t1, PH_COPY);
	}

	if (Z_TYPE_PP(temp1) != IS_ARRAY) {
		convert_to_array_ex(temp1);
	}

	for (i = 0; i < n - 1; i++) {
		phalcon_array_fetch_long(&index, directive, i, PH_NOISY);

		if (!phalcon_array_isset_fetch(temp2, *temp1, index)) {
			PHALCON_ALLOC_GHOST_ZVAL(t2);
			array_init_size(t2, 1);
			phalcon_array_update_zval(temp1, index, t2, PH_COPY);
		}
		else if (Z_TYPE_PP(temp2) != IS_ARRAY) {
			convert_to_array_ex(temp2);
		}

		t1 = t2;
		zval_ptr_dtor(&index);
	}

	phalcon_array_fetch_long(&index, directive, n - 1, PH_NOISY);
	phalcon_array_update_zval(temp1, index, value, PH_COPY);
	zval_ptr_dtor(&index);
}

PHALCON_INIT_CLASS(Phalcon_Config_Adapter_Ini){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Ini, config_adapter_ini, phalcon_config_ce, phalcon_config_adapter_ini_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Config_Adapter_Ini, __construct){

	zval **file_path, *ini_config = NULL;
	zval *config, *directives = NULL;
	zval *section = NULL, *value = NULL, *key = NULL, *directive_parts = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	phalcon_fetch_params_ex(1, 0, &file_path);
	PHALCON_ENSURE_IS_STRING(file_path);

	PHALCON_MM_GROW();

	PHALCON_CALL_FUNCTION(&ini_config, "parse_ini_file", *file_path, PHALCON_GLOBAL(z_true));
	
	if (Z_TYPE_P(ini_config) != IS_ARRAY) {
		zend_throw_exception_ex(phalcon_config_exception_ce, 0 TSRMLS_CC, "Configuration file '%s' cannot be loaded", Z_STRVAL_PP(file_path));
		PHALCON_MM_RESTORE();
		return;
	}
	
	PHALCON_INIT_VAR(config);
	array_init(config);
	
	phalcon_is_iterable(ini_config, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(section, ah0, hp0);
		PHALCON_GET_HVALUE(directives);
	
		if (unlikely(Z_TYPE_P(directives) != IS_ARRAY) || zend_hash_num_elements(Z_ARRVAL_P(directives)) == 0) {
			phalcon_array_update_zval(&config, section, directives, PH_COPY);
		}
		else {
			phalcon_is_iterable(directives, &ah1, &hp1, 0, 0);

			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {

				PHALCON_GET_HKEY(key, ah1, hp1);
				PHALCON_GET_HVALUE(value);

				if (Z_TYPE_P(key) == IS_STRING && memchr(Z_STRVAL_P(key), '.', Z_STRLEN_P(key))) {
					PHALCON_INIT_NVAR(directive_parts);
					phalcon_fast_explode_str(directive_parts, SL("."), key);
					phalcon_config_adapter_ini_update_zval_directive(&config, section, directive_parts, value TSRMLS_CC);
				} else {
					phalcon_array_update_multi_2(&config, section, key, value, 0);
				}

				zend_hash_move_forward_ex(ah1, &hp1);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_config_adapter_ini_ce, this_ptr, "__construct", config);
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_config_adapter_json_ce;

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_adapter_json___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, filePath)
ZEND_END_ARG_INFO()

static PHP_METHOD(Phalcon_Config_Adapter_Json, __construct);

static const zend_function_entry phalcon_config_adapter_json_method_entry[] = {
	PHP_ME(Phalcon_Config_Adapter_Json, __construct, arginfo_phalcon_config_adapter_json___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Config_Adapter_Json){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Json, config_adapter_json, phalcon_config_ce, phalcon_config_adapter_json_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Config_Adapter_Json, __construct){

	zval *file_path, *contents, *array;

	phalcon_fetch_params(0, 1, 0, &file_path);

	ALLOC_INIT_ZVAL(contents);
	ALLOC_INIT_ZVAL(array);
	phalcon_file_get_contents(contents, file_path TSRMLS_CC);

	if (Z_TYPE_P(contents) == IS_STRING) {
		if (FAILURE == phalcon_json_decode(array, contents, 1 TSRMLS_CC)) {
			zval_ptr_dtor(&contents);
			zval_ptr_dtor(&array);
			return;
		}
	}

	zval_ptr_dtor(&contents);

	if (Z_TYPE_P(array) != IS_ARRAY) {
		zval_dtor(array);
		array_init_size(array, 0);
	}

	phalcon_config_construct_internal(getThis(), array TSRMLS_CC);
	zval_ptr_dtor(&array);
}






zend_class_entry *phalcon_config_adapter_php_ce;

static PHP_METHOD(Phalcon_Config_Adapter_Php, __construct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_adapter_php___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, filePath)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_config_adapter_php_method_entry[] = {
	PHP_ME(Phalcon_Config_Adapter_Php, __construct, arginfo_phalcon_config_adapter_php___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Config_Adapter_Php){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Php, config_adapter_php, phalcon_config_ce, phalcon_config_adapter_php_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Config_Adapter_Php, __construct){

	zval **file_path, *config = NULL;

	phalcon_fetch_params_ex(1, 0, &file_path);
	PHALCON_ENSURE_IS_STRING(file_path);

	if (phalcon_require_ret(&config, Z_STRVAL_PP(file_path) TSRMLS_CC) == FAILURE) {
		zend_throw_exception_ex(phalcon_config_exception_ce, 0 TSRMLS_CC, "Configuration file '%s' cannot be loaded", Z_STRVAL_PP(file_path));
		return;
	}

	PHALCON_MM_GROW();
	Z_DELREF_P(config);
	PHALCON_CALL_PARENT(NULL, phalcon_config_adapter_php_ce, this_ptr, "__construct", config);
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_config_adapter_yaml_ce;

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_config_adapter_yaml___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, filePath)
ZEND_END_ARG_INFO()

static PHP_METHOD(Phalcon_Config_Adapter_Yaml, __construct);

static const zend_function_entry phalcon_config_adapter_yaml_method_entry[] = {
	PHP_ME(Phalcon_Config_Adapter_Yaml, __construct, arginfo_phalcon_config_adapter_yaml___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Config_Adapter_Yaml){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Config\\Adapter, Yaml, config_adapter_yaml, phalcon_config_ce, phalcon_config_adapter_yaml_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Config_Adapter_Yaml, __construct){

	zval *file_path, *array = NULL;

	phalcon_fetch_params(0, 1, 0, &file_path);

	PHALCON_CALL_FUNCTIONW(&array, "yaml_parse_file", file_path);

	if (Z_TYPE_P(array) != IS_ARRAY) {
		ZVAL_NULL(array);
		zval_ptr_dtor(&array);
		return;
	}

	phalcon_config_construct_internal(getThis(), array TSRMLS_CC);
	zval_ptr_dtor(&array);
}





zend_class_entry *phalcon_crypt_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Crypt_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Crypt, Exception, crypt_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_db_adapter_ce;

static PHP_METHOD(Phalcon_Db_Adapter, __construct);
static PHP_METHOD(Phalcon_Db_Adapter, setEventsManager);
static PHP_METHOD(Phalcon_Db_Adapter, getEventsManager);
static PHP_METHOD(Phalcon_Db_Adapter, setDialect);
static PHP_METHOD(Phalcon_Db_Adapter, getDialect);
static PHP_METHOD(Phalcon_Db_Adapter, fetchOne);
static PHP_METHOD(Phalcon_Db_Adapter, fetchAll);
static PHP_METHOD(Phalcon_Db_Adapter, insert);
static PHP_METHOD(Phalcon_Db_Adapter, update);
static PHP_METHOD(Phalcon_Db_Adapter, delete);
static PHP_METHOD(Phalcon_Db_Adapter, getColumnList);
static PHP_METHOD(Phalcon_Db_Adapter, limit);
static PHP_METHOD(Phalcon_Db_Adapter, tableExists);
static PHP_METHOD(Phalcon_Db_Adapter, viewExists);
static PHP_METHOD(Phalcon_Db_Adapter, forUpdate);
static PHP_METHOD(Phalcon_Db_Adapter, sharedLock);
static PHP_METHOD(Phalcon_Db_Adapter, createTable);
static PHP_METHOD(Phalcon_Db_Adapter, dropTable);
static PHP_METHOD(Phalcon_Db_Adapter, createView);
static PHP_METHOD(Phalcon_Db_Adapter, dropView);
static PHP_METHOD(Phalcon_Db_Adapter, addColumn);
static PHP_METHOD(Phalcon_Db_Adapter, modifyColumn);
static PHP_METHOD(Phalcon_Db_Adapter, dropColumn);
static PHP_METHOD(Phalcon_Db_Adapter, addIndex);
static PHP_METHOD(Phalcon_Db_Adapter, dropIndex);
static PHP_METHOD(Phalcon_Db_Adapter, addPrimaryKey);
static PHP_METHOD(Phalcon_Db_Adapter, dropPrimaryKey);
static PHP_METHOD(Phalcon_Db_Adapter, addForeignKey);
static PHP_METHOD(Phalcon_Db_Adapter, dropForeignKey);
static PHP_METHOD(Phalcon_Db_Adapter, getColumnDefinition);
static PHP_METHOD(Phalcon_Db_Adapter, listTables);
static PHP_METHOD(Phalcon_Db_Adapter, listViews);
static PHP_METHOD(Phalcon_Db_Adapter, describeIndexes);
static PHP_METHOD(Phalcon_Db_Adapter, describeReferences);
static PHP_METHOD(Phalcon_Db_Adapter, tableOptions);
static PHP_METHOD(Phalcon_Db_Adapter, createSavepoint);
static PHP_METHOD(Phalcon_Db_Adapter, releaseSavepoint);
static PHP_METHOD(Phalcon_Db_Adapter, rollbackSavepoint);
static PHP_METHOD(Phalcon_Db_Adapter, setNestedTransactionsWithSavepoints);
static PHP_METHOD(Phalcon_Db_Adapter, isNestedTransactionsWithSavepoints);
static PHP_METHOD(Phalcon_Db_Adapter, getNestedTransactionSavepointName);
static PHP_METHOD(Phalcon_Db_Adapter, getDefaultIdValue);
static PHP_METHOD(Phalcon_Db_Adapter, supportSequences);
static PHP_METHOD(Phalcon_Db_Adapter, useExplicitIdValue);
static PHP_METHOD(Phalcon_Db_Adapter, getDescriptor);
static PHP_METHOD(Phalcon_Db_Adapter, getConnectionId);
static PHP_METHOD(Phalcon_Db_Adapter, getSQLStatement);
static PHP_METHOD(Phalcon_Db_Adapter, getRealSQLStatement);
static PHP_METHOD(Phalcon_Db_Adapter, getSQLVariables);
static PHP_METHOD(Phalcon_Db_Adapter, getSQLBindTypes);
static PHP_METHOD(Phalcon_Db_Adapter, getType);
static PHP_METHOD(Phalcon_Db_Adapter, getDialectType);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_seteventsmanager, 0, 0, 1)
	ZEND_ARG_INFO(0, eventsManager)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_setdialect, 0, 0, 1)
	ZEND_ARG_INFO(0, dialect)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_adapter_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter, __construct, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Adapter, setEventsManager, arginfo_phalcon_db_adapter_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getEventsManager, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, setDialect, arginfo_phalcon_db_adapter_setdialect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getDialect, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, fetchOne, arginfo_phalcon_db_adapterinterface_fetchone, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, fetchAll, arginfo_phalcon_db_adapterinterface_fetchall, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, insert, arginfo_phalcon_db_adapterinterface_insert, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, update, arginfo_phalcon_db_adapterinterface_update, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, delete, arginfo_phalcon_db_adapterinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getColumnList, arginfo_phalcon_db_adapterinterface_getcolumnlist, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, limit, arginfo_phalcon_db_adapterinterface_limit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, tableExists, arginfo_phalcon_db_adapterinterface_tableexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, viewExists, arginfo_phalcon_db_adapterinterface_viewexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, forUpdate, arginfo_phalcon_db_adapterinterface_forupdate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, sharedLock, arginfo_phalcon_db_adapterinterface_sharedlock, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, createTable, arginfo_phalcon_db_adapterinterface_createtable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropTable, arginfo_phalcon_db_adapterinterface_droptable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, createView, arginfo_phalcon_db_adapterinterface_createview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropView, arginfo_phalcon_db_adapterinterface_dropview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, addColumn, arginfo_phalcon_db_adapterinterface_addcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, modifyColumn, arginfo_phalcon_db_adapterinterface_modifycolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropColumn, arginfo_phalcon_db_adapterinterface_dropcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, addIndex, arginfo_phalcon_db_adapterinterface_addindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropIndex, arginfo_phalcon_db_adapterinterface_dropindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, addPrimaryKey, arginfo_phalcon_db_adapterinterface_addprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropPrimaryKey, arginfo_phalcon_db_adapterinterface_dropprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, addForeignKey, arginfo_phalcon_db_adapterinterface_addforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, dropForeignKey, arginfo_phalcon_db_adapterinterface_dropforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getColumnDefinition, arginfo_phalcon_db_adapterinterface_getcolumndefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, listTables, arginfo_phalcon_db_adapterinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, listViews, arginfo_phalcon_db_adapterinterface_listviews, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, describeIndexes, arginfo_phalcon_db_adapterinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, describeReferences, arginfo_phalcon_db_adapterinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, tableOptions, arginfo_phalcon_db_adapterinterface_tableoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, createSavepoint, arginfo_phalcon_db_adapterinterface_createsavepoint, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, releaseSavepoint, arginfo_phalcon_db_adapterinterface_releasesavepoint, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, rollbackSavepoint, arginfo_phalcon_db_adapterinterface_rollbacksavepoint, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, setNestedTransactionsWithSavepoints, arginfo_phalcon_db_adapterinterface_setnestedtransactionswithsavepoints, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, isNestedTransactionsWithSavepoints, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getNestedTransactionSavepointName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getDefaultIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, supportSequences, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, useExplicitIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getDescriptor, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getConnectionId, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getSQLStatement, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getRealSQLStatement, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getSQLVariables, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getSQLBindTypes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter, getDialectType, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Adapter, db_adapter, phalcon_db_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_db_adapter_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_descriptor"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_dialectType"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_dialect"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_connectionId"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlVariables"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_ce, SL("_sqlBindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_adapter_ce, SL("_transactionLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_adapter_ce, SL("_transactionsWithSavepoints"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_adapter_ce, SL("_connectionConsecutive"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_ce TSRMLS_CC, 2, phalcon_events_eventsawareinterface_ce, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter, __construct){

	zval *descriptor, *connection_consecutive;
	zval *next_consecutive, *dialect_type, *dialect_class = NULL;
	zval *dialect_object;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &descriptor);
	
	connection_consecutive = phalcon_fetch_static_property_ce(phalcon_db_adapter_ce, SL("_connectionConsecutive") TSRMLS_CC);
	
	PHALCON_INIT_VAR(next_consecutive);
	phalcon_add_function(next_consecutive, connection_consecutive, PHALCON_GLOBAL(z_one) TSRMLS_CC);
	phalcon_update_static_property_ce(phalcon_db_adapter_ce, SL("_connectionConsecutive"), next_consecutive TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_connectionId"), connection_consecutive, 802624385UL TSRMLS_CC);
	
	if (!phalcon_array_isset_string_fetch(&dialect_class, descriptor, SS("dialectClass"))) {
		dialect_type = phalcon_fetch_nproperty_this(this_ptr, SL("_dialectType"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(dialect_class);
		PHALCON_CONCAT_SV(dialect_class, "phalcon\\db\\dialect\\", dialect_type);
	}
	
	if (likely(Z_TYPE_P(dialect_class) == IS_STRING)) {
		ce0 = phalcon_fetch_class(dialect_class TSRMLS_CC);
		PHALCON_INIT_VAR(dialect_object);
		object_init_ex(dialect_object, ce0);
		if (phalcon_has_constructor(dialect_object TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, dialect_object, "__construct");
		}
		phalcon_update_property_this_quick(this_ptr, SL("_dialect"), dialect_object, 4072955610UL TSRMLS_CC);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_descriptor"), descriptor, 691635363UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_Adapter, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, setDialect){

	zval *dialect;

	phalcon_fetch_params(0, 1, 0, &dialect);
	PHALCON_VERIFY_INTERFACE_EX(dialect, phalcon_db_dialectinterface_ce, phalcon_db_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dialect"), dialect, 4072955610UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Db_Adapter, getDialect){


	RETURN_MEMBER_QUICK(this_ptr, "_dialect", 4072955610UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, fetchOne){

	zval *sql_query, *fetch_mode = NULL, *bind_params = NULL, *bind_types = NULL;
	zval *result = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &sql_query, &fetch_mode, &bind_params, &bind_types);
	
	if (!fetch_mode) {
		PHALCON_INIT_VAR(fetch_mode);
		ZVAL_LONG(fetch_mode, PDO_FETCH_BOTH);
	}
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&result, this_ptr, "query", sql_query, bind_params, bind_types);
	if (Z_TYPE_P(result) == IS_OBJECT) {
		if (Z_TYPE_P(fetch_mode) != IS_NULL) {
			PHALCON_CALL_METHOD(NULL, result, "setfetchmode", fetch_mode);
		}
		PHALCON_RETURN_CALL_METHOD(result, "fetch");
		RETURN_MM();
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Db_Adapter, fetchAll){

	zval *sql_query, *fetch_mode = NULL, *bind_params = NULL, *bind_types = NULL;
	zval *result = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &sql_query, &fetch_mode, &bind_params, &bind_types);
	
	if (!fetch_mode) {
		PHALCON_INIT_VAR(fetch_mode);
		ZVAL_LONG(fetch_mode, PDO_FETCH_BOTH);
	}
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&result, this_ptr, "query", sql_query, bind_params, bind_types);
	if (likely(Z_TYPE_P(result) == IS_OBJECT)) {
		if (Z_TYPE_P(fetch_mode) != IS_NULL) {
			PHALCON_CALL_METHOD(NULL, result, "setfetchmode", fetch_mode);
		}

		PHALCON_RETURN_CALL_METHOD(result, "fetchall");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, insert){

	zval *table, *values, *fields = NULL, *data_types = NULL, *exception_message;
	zval *placeholders, *insert_values, *bind_data_types = NULL;
	zval *value = NULL, *position = NULL, *str_value = NULL, *bind_type = NULL;
	zval *escaped_table = NULL, *joined_values, *escaped_fields = NULL;
	zval *field = NULL, *escaped_field = NULL, *joined_fields;
	zval *insert_sql = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 2, &table, &values, &fields, &data_types);
	
	if (!fields) {
		fields = PHALCON_GLOBAL(z_null);
	}
	
	if (!data_types) {
		data_types = PHALCON_GLOBAL(z_null);
	}
	
	if (unlikely(Z_TYPE_P(values) != IS_ARRAY)) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The second parameter for insert isn't an Array");
		return;
	}
	
	if (!phalcon_fast_count_ev(values TSRMLS_CC)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Unable to insert into ", table, " without data");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(insert_values);
	array_init(insert_values);
	if (Z_TYPE_P(data_types) == IS_ARRAY) { 
		PHALCON_INIT_VAR(bind_data_types);
		array_init(bind_data_types);
	} else {
		PHALCON_CPY_WRT(bind_data_types, data_types);
	}
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(position, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (Z_TYPE_P(value) == IS_OBJECT) {
			PHALCON_INIT_NVAR(str_value);
			phalcon_strval(str_value, value);
			phalcon_array_append(&placeholders, str_value, 0);
		} else {
			if (Z_TYPE_P(value) == IS_NULL) {
				phalcon_array_append_string(&placeholders, SL("null"), 0);
			} else {
				phalcon_array_append_string(&placeholders, SL("?"), 0);
				phalcon_array_append(&insert_values, value, 0);
				if (Z_TYPE_P(data_types) == IS_ARRAY) { 
					if (!phalcon_array_isset(data_types, position)) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Incomplete number of bind types");
						return;
					}
	
					PHALCON_OBS_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, data_types, position, PH_NOISY);
					phalcon_array_append(&bind_data_types, bind_type, PH_SEPARATE);
				}
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_CALL_METHOD(&escaped_table, this_ptr, "escapeidentifier", table);
	} else {
		PHALCON_CPY_WRT(escaped_table, table);
	}
	
	PHALCON_INIT_VAR(joined_values);
	phalcon_fast_join_str(joined_values, SL(", "), placeholders TSRMLS_CC);
	if (Z_TYPE_P(fields) == IS_ARRAY) { 
		if (PHALCON_GLOBAL(db).escape_identifiers) {
	
			PHALCON_INIT_VAR(escaped_fields);
			array_init(escaped_fields);
	
			phalcon_is_iterable(fields, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HVALUE(field);
	
				PHALCON_CALL_METHOD(&escaped_field, this_ptr, "escapeidentifier", field);
				phalcon_array_append(&escaped_fields, escaped_field, 0);
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
		} else {
			PHALCON_CPY_WRT(escaped_fields, fields);
		}
	
		PHALCON_INIT_VAR(joined_fields);
		phalcon_fast_join_str(joined_fields, SL(", "), escaped_fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(insert_sql);
		PHALCON_CONCAT_SVSVSVS(insert_sql, "INSERT INTO ", escaped_table, " (", joined_fields, ") VALUES (", joined_values, ")");
	} else {
		PHALCON_INIT_VAR(insert_sql);
		PHALCON_CONCAT_SVSVS(insert_sql, "INSERT INTO ", escaped_table, " VALUES (", joined_values, ")");
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", insert_sql, insert_values, bind_data_types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, update){

	zval *table, *fields, *values, *where_condition = NULL;
	zval *data_types = NULL, *placeholders, *update_values;
	zval *bind_data_types = NULL, *value = NULL, *position = NULL, *field = NULL;
	zval *escaped_field = NULL, *set_clause_part = NULL, *bind_type = NULL;
	zval *escaped_table = NULL, *set_clause, *update_sql = NULL;
	zval *conditions, *where_bind, *where_types;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 2, &table, &fields, &values, &where_condition, &data_types);
	
	if (!where_condition) {
		where_condition = PHALCON_GLOBAL(z_null);
	}
	
	if (!data_types) {
		data_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(update_values);
	array_init(update_values);
	if (Z_TYPE_P(data_types) == IS_ARRAY) { 
		PHALCON_INIT_VAR(bind_data_types);
		array_init(bind_data_types);
	} else {
		PHALCON_CPY_WRT(bind_data_types, data_types);
	}
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(position, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (!phalcon_array_isset(fields, position)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The number of values in the update is not the same as fields");
			return;
		}
	
		PHALCON_OBS_NVAR(field);
		phalcon_array_fetch(&field, fields, position, PH_NOISY);
		if (PHALCON_GLOBAL(db).escape_identifiers) {
			PHALCON_CALL_METHOD(&escaped_field, this_ptr, "escapeidentifier", field);
		} else {
			PHALCON_CPY_WRT(escaped_field, field);
		}
	
		if (Z_TYPE_P(value) == IS_OBJECT) {
			PHALCON_INIT_NVAR(set_clause_part);
			PHALCON_CONCAT_VSV(set_clause_part, escaped_field, " = ", value);
			phalcon_array_append(&placeholders, set_clause_part, 0);
		} else {
			if (Z_TYPE_P(value) == IS_NULL) {
				PHALCON_INIT_NVAR(set_clause_part);
				PHALCON_CONCAT_VS(set_clause_part, escaped_field, " = null");
			} else {
				PHALCON_INIT_NVAR(set_clause_part);
				PHALCON_CONCAT_VS(set_clause_part, escaped_field, " = ?");
				phalcon_array_append(&update_values, value, PH_SEPARATE);
				if (Z_TYPE_P(data_types) == IS_ARRAY) { 
					if (!phalcon_array_isset(data_types, position)) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Incomplete number of bind types");
						return;
					}
	
					PHALCON_OBS_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, data_types, position, PH_NOISY);
					phalcon_array_append(&bind_data_types, bind_type, PH_SEPARATE);
				}
			}
			phalcon_array_append(&placeholders, set_clause_part, PH_SEPARATE);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_CALL_METHOD(&escaped_table, this_ptr, "escapeidentifier", table);
	} else {
		PHALCON_CPY_WRT(escaped_table, table);
	}
	
	PHALCON_INIT_VAR(set_clause);
	phalcon_fast_join_str(set_clause, SL(", "), placeholders TSRMLS_CC);
	if (Z_TYPE_P(where_condition) != IS_NULL) {
	
		PHALCON_INIT_VAR(update_sql);
		PHALCON_CONCAT_SVSVS(update_sql, "UPDATE ", escaped_table, " SET ", set_clause, " WHERE ");
	
		if (Z_TYPE_P(where_condition) == IS_STRING) {
			phalcon_concat_self(&update_sql, where_condition TSRMLS_CC);
		} else {
			if (unlikely(Z_TYPE_P(where_condition) != IS_ARRAY)) { 
				PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid WHERE clause conditions");
				return;
			}
	
			if (phalcon_array_isset_quick_string(where_condition, SS("conditions"), 1055696255UL)) {
				PHALCON_OBS_VAR(conditions);
				phalcon_array_fetch_quick_string(&conditions, where_condition, SS("conditions"), 1055696255UL, PH_NOISY);
				phalcon_concat_self(&update_sql, conditions TSRMLS_CC);
			}
	
			if (phalcon_array_isset_quick_string(where_condition, SS("bind"), 254268962UL)) {
				PHALCON_OBS_VAR(where_bind);
				phalcon_array_fetch_quick_string(&where_bind, where_condition, SS("bind"), 254268962UL, PH_NOISY);
				phalcon_merge_append(update_values, where_bind);
			}
	
			if (phalcon_array_isset_quick_string(where_condition, SS("bindTypes"), 3951758359UL)) {
				PHALCON_OBS_VAR(where_types);
				phalcon_array_fetch_quick_string(&where_types, where_condition, SS("bindTypes"), 3951758359UL, PH_NOISY);
				phalcon_merge_append(bind_data_types, where_types);
			}
		}
	} else {
		PHALCON_INIT_NVAR(update_sql);
		PHALCON_CONCAT_SVSV(update_sql, "UPDATE ", escaped_table, " SET ", set_clause);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", update_sql, update_values, bind_data_types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, delete){

	zval *table, *where_condition = NULL, *placeholders = NULL;
	zval *data_types = NULL, *escaped_table = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &table, &where_condition, &placeholders, &data_types);
	
	if (!where_condition) {
		where_condition = PHALCON_GLOBAL(z_null);
	}
	
	if (!placeholders) {
		placeholders = PHALCON_GLOBAL(z_null);
	}
	
	if (!data_types) {
		data_types = PHALCON_GLOBAL(z_null);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_CALL_METHOD(&escaped_table, this_ptr, "escapeidentifier", table);
	} else {
		PHALCON_CPY_WRT(escaped_table, table);
	}

	PHALCON_INIT_VAR(sql);
	if (PHALCON_IS_NOT_EMPTY(where_condition)) {
		PHALCON_CONCAT_SVSV(sql, "DELETE FROM ", escaped_table, " WHERE ", where_condition);
	} else {
		PHALCON_CONCAT_SV(sql, "DELETE FROM ", escaped_table);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql, placeholders, data_types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, getColumnList){

	zval *column_list, *dialect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column_list);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(dialect, "getcolumnlist", column_list);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, limit){

	zval *sql_query, *number, *dialect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &sql_query, &number);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(dialect, "limit", sql_query, number);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, tableExists){

	zval *table_name, *schema_name = NULL, *dialect, *sql = NULL;
	zval *fetch_num, *num = NULL, *first;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table_name, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "tableexists", table_name, schema_name);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&num, this_ptr, "fetchone", sql, fetch_num);
	
	PHALCON_OBS_VAR(first);
	phalcon_array_fetch_long(&first, num, 0, PH_NOISY);
	RETURN_CCTOR(first);
}

static PHP_METHOD(Phalcon_Db_Adapter, viewExists){

	zval *view_name, *schema_name = NULL, *dialect, *sql = NULL, *fetch_num;
	zval *num = NULL, *first;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &view_name, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "viewexists", view_name, schema_name);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&num, this_ptr, "fetchone", sql, fetch_num);
	
	PHALCON_OBS_VAR(first);
	phalcon_array_fetch_long(&first, num, 0, PH_NOISY);
	RETURN_CCTOR(first);
}

static PHP_METHOD(Phalcon_Db_Adapter, forUpdate){

	zval *sql_query, *dialect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &sql_query);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(dialect, "forupdate", sql_query);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, sharedLock){

	zval *sql_query, *dialect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &sql_query);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(dialect, "sharedlock", sql_query);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, createTable){

	zval *table_name, *schema_name, *definition;
	zval *exception_message, *columns, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &definition);
	
	if (Z_TYPE_P(definition) != IS_ARRAY) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid definition to create the table '", table_name, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
		return;
	}

	if (!phalcon_array_isset_string_fetch(&columns, definition, SS("columns"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	if (!phalcon_fast_count_ev(columns TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "createtable", table_name, schema_name, definition);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropTable){

	zval *table_name, *schema_name = NULL, *if_exists = NULL, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &table_name, &schema_name, &if_exists);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "droptable", table_name, schema_name, if_exists);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, createView){

	zval *view_name, *definition, *schema_name = NULL, *exception_message;
	zval *dialect, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &view_name, &definition, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid definition to create the view '", view_name, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
		return;
	}

	if (!phalcon_array_isset_quick_string(definition, SS("sql"), 2090732981UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The table must contain at least one column");
		return;
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "createview", view_name, definition, schema_name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropView){

	zval *view_name, *schema_name = NULL, *if_exists = NULL, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &view_name, &schema_name, &if_exists);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "dropview", view_name, schema_name, if_exists);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, addColumn){

	zval *table_name, *schema_name, *column, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "addcolumn", table_name, schema_name, column);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, modifyColumn){

	zval *table_name, *schema_name, *column, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "modifycolumn", table_name, schema_name, column);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropColumn){

	zval *table_name, *schema_name, *column_name;
	zval *dialect, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column_name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "dropcolumn", table_name, schema_name, column_name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, addIndex){

	zval *table_name, *schema_name, *index, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "addindex", table_name, schema_name, index);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropIndex){

	zval *table_name, *schema_name, *index_name;
	zval *dialect, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index_name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "dropindex", table_name, schema_name, index_name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, addPrimaryKey){

	zval *table_name, *schema_name, *index, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "addprimarykey", table_name, schema_name, index);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropPrimaryKey){

	zval *table_name, *schema_name, *dialect, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &table_name, &schema_name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "dropprimarykey", table_name, schema_name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, addForeignKey){

	zval *table_name, *schema_name, *reference, *dialect;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &reference);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "addforeignkey", table_name, schema_name, reference);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;
	zval *dialect, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &reference_name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "dropforeignkey", table_name, schema_name, reference_name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, getColumnDefinition){

	zval *column, *dialect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(dialect, "getcolumndefinition", column);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, listTables){

	zval *schema_name = NULL, *dialect, *sql = NULL, *fetch_num, *tables = NULL;
	zval **table, *table_name;
	HashPosition hp0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "listtables", schema_name);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&tables, this_ptr, "fetchall", sql, fetch_num);
	
	if (Z_TYPE_P(tables) == IS_ARRAY) {
		array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(tables)));

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(tables), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(tables), (void**)&table, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(tables), &hp0)
		) {
			if (phalcon_array_isset_long_fetch(&table_name, *table, 0)) {
				phalcon_array_append(&return_value, table_name, 0);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, listViews){

	zval *schema_name = NULL, *dialect, *sql = NULL, *fetch_num, *tables = NULL;
	zval **table, *table_name;
	HashPosition hp0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "listviews", schema_name);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&tables, this_ptr, "fetchall", sql, fetch_num);
	
	if (Z_TYPE_P(tables) == IS_ARRAY) {
		array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(tables)));

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(tables), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(tables), (void**)&table, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(tables), &hp0)
		) {
			if (phalcon_array_isset_long_fetch(&table_name, *table, 0)) {
				phalcon_array_append(&return_value, table_name, 0);
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, describeIndexes){

	zval *table, *schema = NULL, *dialect, *fetch_num, *sql = NULL, *describe = NULL;
	zval *indexes, *index = NULL, *key_name = NULL, *column_name = NULL;
	zval *index_columns = NULL, *name = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describeindexes", table, schema);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(indexes);
	array_init(indexes);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(index);

		PHALCON_OBS_NVAR(key_name);
		phalcon_array_fetch_long(&key_name, index, 2, PH_NOISY);
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, index, 4, PH_NOISY);
		phalcon_array_append_multi_2(&indexes, key_name, column_name, 0);

		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	array_init(return_value);
	
	phalcon_is_iterable(indexes, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah1, hp1);
		PHALCON_GET_HVALUE(index_columns);
	
		PHALCON_INIT_NVAR(index);
		object_init_ex(index, phalcon_db_index_ce);
		PHALCON_CALL_METHOD(NULL, index, "__construct", name, index_columns);
	
		phalcon_array_update_zval(&return_value, name, index, PH_COPY);
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, describeReferences){

	zval *table, *schema = NULL, *dialect, *fetch_num, *sql = NULL, *empty_arr;
	zval *references, *describe = NULL, *reference = NULL, *constraint_name = NULL;
	zval *referenced_schema = NULL, *referenced_table = NULL;
	zval *reference_array = NULL, *column_name = NULL, *referenced_columns = NULL;
	zval *array_reference = NULL;
	zval *name = NULL, *columns = NULL, *definition = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describereferences", table, schema);
	
	PHALCON_INIT_VAR(empty_arr);
	array_init(empty_arr);

	PHALCON_INIT_VAR(references);
	array_init(references);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(reference);
	
		PHALCON_OBS_NVAR(constraint_name);
		phalcon_array_fetch_long(&constraint_name, reference, 2, PH_NOISY);
		if (!phalcon_array_isset(references, constraint_name)) {
			PHALCON_OBS_NVAR(referenced_schema);
			phalcon_array_fetch_long(&referenced_schema, reference, 3, PH_NOISY);
	
			PHALCON_OBS_NVAR(referenced_table);
			phalcon_array_fetch_long(&referenced_table, reference, 4, PH_NOISY);
	
			PHALCON_INIT_NVAR(reference_array);
			array_init_size(reference_array, 4);
			phalcon_array_update_string(&reference_array, SL("referencedSchema"), referenced_schema, PH_COPY);
			phalcon_array_update_string(&reference_array, SL("referencedTable"), referenced_table, PH_COPY);
			phalcon_array_update_string(&reference_array, SL("columns"), empty_arr, PH_COPY);
			phalcon_array_update_string(&reference_array, SL("referencedColumns"), empty_arr, PH_COPY);
			phalcon_array_update_zval(&references, constraint_name, reference_array, PH_COPY);
		}
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, reference, 1, PH_NOISY);
		phalcon_array_update_zval_string_append_multi_3(&references, constraint_name, SL("columns"), column_name, 0);
	
		PHALCON_OBS_NVAR(referenced_columns);
		phalcon_array_fetch_long(&referenced_columns, reference, 5, PH_NOISY);
		phalcon_array_update_zval_string_append_multi_3(&references, constraint_name, SL("referencedColumns"), referenced_columns, 0);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	array_init(return_value);
	
	phalcon_is_iterable(references, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah1, hp1);
		PHALCON_GET_HVALUE(array_reference);
	
		PHALCON_OBS_NVAR(referenced_schema);

		phalcon_array_fetch_quick_string(&referenced_schema, array_reference, SS("referencedSchema"), 3300645545UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(referenced_table);
		phalcon_array_fetch_quick_string(&referenced_table, array_reference, SS("referencedTable"), 3390337856UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(columns);
		phalcon_array_fetch_quick_string(&columns, array_reference, SS("columns"), 1041822630UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(referenced_columns);
		phalcon_array_fetch_quick_string(&referenced_columns, array_reference, SS("referencedColumns"), 1045113721UL, PH_NOISY);
	
		PHALCON_INIT_NVAR(definition);
		array_init_size(definition, 4);
		phalcon_array_update_string(&definition, SL("referencedSchema"), referenced_schema, PH_COPY);
		phalcon_array_update_string(&definition, SL("referencedTable"), referenced_table, PH_COPY);
		phalcon_array_update_string(&definition, SL("columns"), columns, PH_COPY );
		phalcon_array_update_string(&definition, SL("referencedColumns"), referenced_columns, PH_COPY);
	
		PHALCON_INIT_NVAR(reference);
		object_init_ex(reference, phalcon_db_reference_ce);
		PHALCON_CALL_METHOD(NULL, reference, "__construct", name, definition);
	
		phalcon_array_update_zval(&return_value, name, reference, PH_COPY);
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter, tableOptions){

	zval *table_name, *schema_name = NULL, *dialect, *sql = NULL;
	zval *fetch_assoc, *describe = NULL, *first;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table_name, &schema_name);
	
	if (!schema_name) {
		schema_name = PHALCON_GLOBAL(z_null);
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "tableoptions", table_name, schema_name);
	if (zend_is_true(sql)) {
		PHALCON_INIT_VAR(fetch_assoc);
		ZVAL_LONG(fetch_assoc, PDO_FETCH_ASSOC);
	
		PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_assoc);
	
		PHALCON_OBS_VAR(first);
		phalcon_array_fetch_long(&first, describe, 0, PH_NOISY);
		RETURN_CCTOR(first);
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Db_Adapter, createSavepoint){

	zval *name, *dialect, *supports_sp = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&supports_sp, dialect, "supportssavepoints");
	if (!zend_is_true(supports_sp)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Savepoints are not supported by this database adapter.");
		return;
	}
	
	PHALCON_CALL_METHOD(&sql, dialect, "createsavepoint", name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, releaseSavepoint){

	zval *name, *dialect, *supports_sp = NULL, *supports_rsp = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&supports_sp, dialect, "supportssavepoints");
	if (!zend_is_true(supports_sp)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Savepoints are not supported by this database adapter");
		return;
	}
	
	PHALCON_CALL_METHOD(&supports_rsp, dialect, "supportsreleasesavepoints");
	if (!zend_is_true(supports_rsp)) {
		RETURN_MM_FALSE;
	}
	
	PHALCON_CALL_METHOD(&sql, dialect, "releasesavepoint", name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, rollbackSavepoint){

	zval *name, *dialect, *supports_sp = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&supports_sp, dialect, "supportssavepoints");
	if (!zend_is_true(supports_sp)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Savepoints are not supported by this database adapter");
		return;
	}
	
	PHALCON_CALL_METHOD(&sql, dialect, "rollbacksavepoint", name);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", sql);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, setNestedTransactionsWithSavepoints){

	zval *nested_transactions_with_savepoints;
	zval *transaction_level, *dialect, *supports_sp = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &nested_transactions_with_savepoints);
	
	transaction_level = phalcon_fetch_nproperty_this(this_ptr, SL("_transactionLevel"), PH_NOISY TSRMLS_CC);
	if (PHALCON_GT_LONG(transaction_level, 0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Nested transaction with savepoints behavior cannot be changed while a transaction is open");
		return;
	}
	
	dialect = phalcon_fetch_nproperty_this(this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&supports_sp, dialect, "supportssavepoints");
	if (!zend_is_true(supports_sp)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Savepoints are not supported by this database adapter");
		return;
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_transactionsWithSavepoints"), nested_transactions_with_savepoints, 2137960997UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Db_Adapter, isNestedTransactionsWithSavepoints){


	RETURN_MEMBER_QUICK(this_ptr, "_transactionsWithSavepoints", 2137960997UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getNestedTransactionSavepointName){

	zval *transaction_level;

	transaction_level = phalcon_fetch_nproperty_this(this_ptr, SL("_transactionLevel"), PH_NOISY TSRMLS_CC);
	PHALCON_CONCAT_SV(return_value, "PHALCON_SAVEPOINT_", transaction_level);
}

static PHP_METHOD(Phalcon_Db_Adapter, getDefaultIdValue){

	zval *null_value;

	PHALCON_MM_GROW();

	PHALCON_ALLOC_GHOST_ZVAL(null_value);
	ZVAL_STRING(null_value, "null", 1);
	object_init_ex(return_value, phalcon_db_rawvalue_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", null_value);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter, supportSequences){


	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter, useExplicitIdValue){


	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter, getDescriptor){


	RETURN_MEMBER_QUICK(this_ptr, "_descriptor", 691635363UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getConnectionId){


	RETURN_MEMBER_QUICK(this_ptr, "_connectionId", 802624385UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getSQLStatement){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlStatement", 18972457UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getRealSQLStatement){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlStatement", 18972457UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getSQLVariables){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlVariables", 3213579853UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getSQLBindTypes){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlBindTypes", 3288357222UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Db_Adapter, getDialectType){


	RETURN_MEMBER_QUICK(this_ptr, "_dialectType", 1868597628UL);
}





zend_class_entry *phalcon_db_adapterinterface_ce;

static const zend_function_entry phalcon_db_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, fetchOne, arginfo_phalcon_db_adapterinterface_fetchone)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, fetchAll, arginfo_phalcon_db_adapterinterface_fetchall)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, insert, arginfo_phalcon_db_adapterinterface_insert)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, update, arginfo_phalcon_db_adapterinterface_update)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, delete, arginfo_phalcon_db_adapterinterface_delete)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getColumnList, arginfo_phalcon_db_adapterinterface_getcolumnlist)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, limit, arginfo_phalcon_db_adapterinterface_limit)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, tableExists, arginfo_phalcon_db_adapterinterface_tableexists)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, viewExists, arginfo_phalcon_db_adapterinterface_viewexists)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, forUpdate, arginfo_phalcon_db_adapterinterface_forupdate)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, sharedLock, arginfo_phalcon_db_adapterinterface_sharedlock)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, createTable, arginfo_phalcon_db_adapterinterface_createtable)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropTable, arginfo_phalcon_db_adapterinterface_droptable)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, createView, arginfo_phalcon_db_adapterinterface_createview)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropView, arginfo_phalcon_db_adapterinterface_dropview)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, addColumn, arginfo_phalcon_db_adapterinterface_addcolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, modifyColumn, arginfo_phalcon_db_adapterinterface_modifycolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropColumn, arginfo_phalcon_db_adapterinterface_dropcolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, addIndex, arginfo_phalcon_db_adapterinterface_addindex)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropIndex, arginfo_phalcon_db_adapterinterface_dropindex)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, addPrimaryKey, arginfo_phalcon_db_adapterinterface_addprimarykey)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropPrimaryKey, arginfo_phalcon_db_adapterinterface_dropprimarykey)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, addForeignKey, arginfo_phalcon_db_adapterinterface_addforeignkey)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, dropForeignKey, arginfo_phalcon_db_adapterinterface_dropforeignkey)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getColumnDefinition, arginfo_phalcon_db_adapterinterface_getcolumndefinition)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, listTables, arginfo_phalcon_db_adapterinterface_listtables)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, listViews, arginfo_phalcon_db_adapterinterface_listviews)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getDescriptor, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getConnectionId, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getSQLStatement, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getRealSQLStatement, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getSQLVariables, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getSQLBindTypes, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getDialectType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getDialect, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, connect, arginfo_phalcon_db_adapterinterface_connect)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, query, arginfo_phalcon_db_adapterinterface_query)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, execute, arginfo_phalcon_db_adapterinterface_execute)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, affectedRows, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, close, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, escapeIdentifier, arginfo_phalcon_db_adapterinterface_escapeidentifier)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, escapeString, arginfo_phalcon_db_adapterinterface_escapestring)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, convertBoundParams, arginfo_phalcon_db_adapterinterface_convertboundparams)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, lastInsertId, arginfo_phalcon_db_adapterinterface_lastinsertid)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, begin, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, rollback, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, commit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, isUnderTransaction, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getInternalHandler, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, describeIndexes, arginfo_phalcon_db_adapterinterface_describeindexes)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, describeReferences, arginfo_phalcon_db_adapterinterface_describereferences)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, tableOptions, arginfo_phalcon_db_adapterinterface_tableoptions)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, useExplicitIdValue, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getDefaultIdValue, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, supportSequences, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, createSavepoint, arginfo_phalcon_db_adapterinterface_createsavepoint)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, releaseSavepoint, arginfo_phalcon_db_adapterinterface_releasesavepoint)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, rollbackSavepoint, arginfo_phalcon_db_adapterinterface_rollbacksavepoint)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, setNestedTransactionsWithSavepoints, arginfo_phalcon_db_adapterinterface_setnestedtransactionswithsavepoints)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, isNestedTransactionsWithSavepoints, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, getNestedTransactionSavepointName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_AdapterInterface, describeColumns, arginfo_phalcon_db_adapterinterface_describecolumns)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Db_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, AdapterInterface, db_adapterinterface, phalcon_db_adapterinterface_method_entry);

	return SUCCESS;
}






































































zend_class_entry *phalcon_db_column_ce;

static PHP_METHOD(Phalcon_Db_Column, __construct);
static PHP_METHOD(Phalcon_Db_Column, getSchemaName);
static PHP_METHOD(Phalcon_Db_Column, getName);
static PHP_METHOD(Phalcon_Db_Column, getType);
static PHP_METHOD(Phalcon_Db_Column, getSize);
static PHP_METHOD(Phalcon_Db_Column, getScale);
static PHP_METHOD(Phalcon_Db_Column, isUnsigned);
static PHP_METHOD(Phalcon_Db_Column, isNotNull);
static PHP_METHOD(Phalcon_Db_Column, isPrimary);
static PHP_METHOD(Phalcon_Db_Column, isAutoIncrement);
static PHP_METHOD(Phalcon_Db_Column, isNumeric);
static PHP_METHOD(Phalcon_Db_Column, isFirst);
static PHP_METHOD(Phalcon_Db_Column, getAfterPosition);
static PHP_METHOD(Phalcon_Db_Column, getBindType);
static PHP_METHOD(Phalcon_Db_Column, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_column___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, columnName)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_column_method_entry[] = {
	PHP_ME(Phalcon_Db_Column, __construct, arginfo_phalcon_db_column___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Column, getSchemaName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getSize, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getScale, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isUnsigned, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isNotNull, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isPrimary, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isAutoIncrement, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isNumeric, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, isFirst, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getAfterPosition, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, getBindType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Column, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Column){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Column, db_column, phalcon_db_column_method_entry, 0);

	zend_declare_property_null(phalcon_db_column_ce, SL("_columnName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_schemaName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_isNumeric"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_size"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_scale"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_unsigned"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_notNull"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_primary"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_autoIncrement"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_column_ce, SL("_first"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_column_ce, SL("_after"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_column_ce, SL("_bindType"), 2, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_INTEGER"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_VARCHAR"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DECIMAL"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DATETIME"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_CHAR"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_TEXT"), 6 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_FLOAT"), 7 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_BOOLEAN"), 8 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("TYPE_DOUBLE"), 9 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_NULL"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_INT"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_STR"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_BOOL"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_PARAM_DECIMAL"), 32 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_db_column_ce, SL("BIND_SKIP"), 1024 TSRMLS_CC);

	zend_class_implements(phalcon_db_column_ce TSRMLS_CC, 1, phalcon_db_columninterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Column, __construct){

	zval *column_name, *definition, *type, *not_null;
	zval *primary, *size, *scale, *dunsigned, *is_numeric;
	zval *auto_increment, *first, *after, *bind_type;

	phalcon_fetch_params(0, 2, 0, &column_name, &definition);
	
	phalcon_update_property_this_quick(this_ptr, SL("_columnName"), column_name, 3251978323UL TSRMLS_CC);
	
	if (phalcon_array_isset_string_fetch(&type, definition, SS("type"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Column type is required");
		return;
	}
	
	if (phalcon_array_isset_string_fetch(&not_null, definition, SS("notNull"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_notNull"), not_null, 628108368UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&primary, definition, SS("primary"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_primary"), primary, 3445614760UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&size, definition, SS("size"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_size"), size, 3990209087UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&scale, definition, SS("scale"))) {
		int i_type     = phalcon_get_intval(type);
		int is_numeric = (i_type == 3 || i_type == 7 || i_type == 9);
	
		if (is_numeric) {
			phalcon_update_property_this_quick(this_ptr, SL("_scale"), scale, 2819877996UL TSRMLS_CC);
		}
	}
	
	if (phalcon_array_isset_string_fetch(&dunsigned, definition, SS("unsigned"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_unsigned"), dunsigned, 127907201UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&is_numeric, definition, SS("isNumeric"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_isNumeric"), is_numeric, 2501917651UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&auto_increment, definition, SS("autoIncrement"))) {
		if (PHALCON_IS_LONG(type, 0)) {
			phalcon_update_property_this_quick(this_ptr, SL("_autoIncrement"), auto_increment, 3100381058UL TSRMLS_CC);
		} else {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Column type cannot be auto-increment");
			return;
		}
	}
	
	if (phalcon_array_isset_string_fetch(&first, definition, SS("first"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_first"), first, 2318852460UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&after, definition, SS("after"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_after"), after, 2119674294UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&bind_type, definition, SS("bindType"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_bindType"), bind_type, 926651555UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Db_Column, getSchemaName){


	RETURN_MEMBER_QUICK(this_ptr, "_schemaName", 851420310UL);
}

static PHP_METHOD(Phalcon_Db_Column, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_columnName", 3251978323UL);
}

static PHP_METHOD(Phalcon_Db_Column, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Db_Column, getSize){


	RETURN_MEMBER_QUICK(this_ptr, "_size", 3990209087UL);
}

static PHP_METHOD(Phalcon_Db_Column, getScale){


	RETURN_MEMBER_QUICK(this_ptr, "_scale", 2819877996UL);
}

static PHP_METHOD(Phalcon_Db_Column, isUnsigned){


	RETURN_MEMBER_QUICK(this_ptr, "_unsigned", 127907201UL);
}

static PHP_METHOD(Phalcon_Db_Column, isNotNull){


	RETURN_MEMBER_QUICK(this_ptr, "_notNull", 628108368UL);
}

static PHP_METHOD(Phalcon_Db_Column, isPrimary){


	RETURN_MEMBER_QUICK(this_ptr, "_primary", 3445614760UL);
}

static PHP_METHOD(Phalcon_Db_Column, isAutoIncrement){


	RETURN_MEMBER_QUICK(this_ptr, "_autoIncrement", 3100381058UL);
}

static PHP_METHOD(Phalcon_Db_Column, isNumeric){


	RETURN_MEMBER_QUICK(this_ptr, "_isNumeric", 2501917651UL);
}

static PHP_METHOD(Phalcon_Db_Column, isFirst){


	RETURN_MEMBER_QUICK(this_ptr, "_first", 2318852460UL);
}

static PHP_METHOD(Phalcon_Db_Column, getAfterPosition){


	RETURN_MEMBER_QUICK(this_ptr, "_after", 2119674294UL);
}

static PHP_METHOD(Phalcon_Db_Column, getBindType){


	RETURN_MEMBER_QUICK(this_ptr, "_bindType", 926651555UL);
}

static PHP_METHOD(Phalcon_Db_Column, __set_state){

	zval *data, *definition, *column_name, *column_type = NULL;
	zval *not_null, *primary, *size, *scale, *dunsigned, *after;
	zval *is_numeric, *first, *bind_type;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column state must be an array");
		return;
	}
	
	if (!phalcon_array_isset_string_fetch(&column_name, data, SS("_columnName"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column name is required");
		return;
	}

	PHALCON_INIT_VAR(definition);
	array_init(definition);

	if (phalcon_array_isset_string_fetch(&column_type, data, SS("_type"))) {
		phalcon_array_update_string(&definition, SL("type"), column_type, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&not_null, data, SS("_notNull"))) {
		phalcon_array_update_string(&definition, SL("notNull"), not_null, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&primary, data, SS("_primary"))) {
		phalcon_array_update_string(&definition, SL("primary"), primary, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&size, data, SS("_size"))) {
		phalcon_array_update_string(&definition, SL("size"), size, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&scale, data, SS("_scale"))) {
		phalcon_array_update_string(&definition, SL("scale"), scale, PH_COPY);
	}

	if (phalcon_array_isset_string_fetch(&dunsigned, data, SS("_unsigned"))) {
		phalcon_array_update_string(&definition, SL("unsigned"), dunsigned, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&after, data, SS("_after"))) {
		phalcon_array_update_string(&definition, SL("after"), after, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&is_numeric, data, SS("_isNumeric"))) {
		phalcon_array_update_string(&definition, SL("isNumeric"), is_numeric, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&first, data, SS("_first"))) {
		phalcon_array_update_string(&definition, SL("first"), first, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&bind_type, data, SS("_bindType"))) {
		phalcon_array_update_string(&definition, SL("bindType"), bind_type, PH_COPY);
	}
	
	object_init_ex(return_value, phalcon_db_column_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", column_name, definition);
	
	RETURN_MM();
}





zend_class_entry *phalcon_db_columninterface_ce;

static const zend_function_entry phalcon_db_columninterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getSchemaName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getSize, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getScale, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isUnsigned, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isNotNull, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isPrimary, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isAutoIncrement, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isNumeric, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, isFirst, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getAfterPosition, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ColumnInterface, getBindType, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_ColumnInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ColumnInterface, db_columninterface, phalcon_db_columninterface_method_entry);

	return SUCCESS;
}



















zend_class_entry *phalcon_db_dialect_ce;

static PHP_METHOD(Phalcon_Db_Dialect, limit);
static PHP_METHOD(Phalcon_Db_Dialect, forUpdate);
static PHP_METHOD(Phalcon_Db_Dialect, sharedLock);
static PHP_METHOD(Phalcon_Db_Dialect, getColumnList);
static PHP_METHOD(Phalcon_Db_Dialect, getSqlExpression);
static PHP_METHOD(Phalcon_Db_Dialect, getSqlTable);
static PHP_METHOD(Phalcon_Db_Dialect, select);
static PHP_METHOD(Phalcon_Db_Dialect, supportsSavepoints);
static PHP_METHOD(Phalcon_Db_Dialect, supportsReleaseSavepoints);
static PHP_METHOD(Phalcon_Db_Dialect, createSavepoint);
static PHP_METHOD(Phalcon_Db_Dialect, releaseSavepoint);
static PHP_METHOD(Phalcon_Db_Dialect, rollbackSavepoint);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_dialect_getsqlexpression, 0, 0, 1)
	ZEND_ARG_INFO(0, expression)
	ZEND_ARG_INFO(0, escapeChar)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_dialect_getsqltable, 0, 0, 1)
	ZEND_ARG_INFO(0, table)
	ZEND_ARG_INFO(0, escapeChar)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_dialect_method_entry[] = {
	PHP_ME(Phalcon_Db_Dialect, limit, arginfo_phalcon_db_dialectinterface_limit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, forUpdate, arginfo_phalcon_db_dialectinterface_forupdate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, sharedLock, arginfo_phalcon_db_dialectinterface_sharedlock, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, getColumnList, arginfo_phalcon_db_dialectinterface_getcolumnlist, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, getSqlExpression, arginfo_phalcon_db_dialect_getsqlexpression, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, getSqlTable, arginfo_phalcon_db_dialect_getsqltable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, select, arginfo_phalcon_db_dialectinterface_select, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, supportsSavepoints, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, supportsReleaseSavepoints, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, createSavepoint, arginfo_phalcon_db_dialectinterface_createsavepoint, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, releaseSavepoint, arginfo_phalcon_db_dialectinterface_releasesavepoint, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect, rollbackSavepoint, arginfo_phalcon_db_dialectinterface_rollbacksavepoint, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Dialect){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Dialect, db_dialect, phalcon_db_dialect_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_db_dialect_ce, SL("_escapeChar"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_dialect_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Dialect, limit){

	zval *sql_query, *number, *limit;

	phalcon_fetch_params(1, 2, 0, &sql_query, &number);
	
	if (phalcon_is_numeric(number)) {
		PHALCON_MM_GROW();
		PHALCON_INIT_VAR(limit);
		ZVAL_LONG(limit, phalcon_get_intval(number));
		PHALCON_CONCAT_VSV(return_value, sql_query, " LIMIT ", limit);
		RETURN_MM();
	}
	
	RETURN_ZVAL(sql_query, 1, 0);
}

static PHP_METHOD(Phalcon_Db_Dialect, forUpdate){

	zval *sql_query;

	phalcon_fetch_params(0, 1, 0, &sql_query);
	
	PHALCON_CONCAT_VS(return_value, sql_query, " FOR UPDATE");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect, sharedLock){

	zval *sql_query;

	phalcon_fetch_params(0, 1, 0, &sql_query);
	
	PHALCON_CONCAT_VS(return_value, sql_query, " LOCK IN SHARE MODE");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect, getColumnList){

	zval *column_list, *str_list, *escape_char, *column = NULL;
	zval *column_quoted = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column_list);
	
	PHALCON_INIT_VAR(str_list);
	array_init(str_list);
	
	PHALCON_OBS_VAR(escape_char);
	phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
	
	phalcon_is_iterable(column_list, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(column);
	
		PHALCON_INIT_NVAR(column_quoted);
		PHALCON_CONCAT_VVV(column_quoted, escape_char, column, escape_char);
		phalcon_array_append(&str_list, column_quoted, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_fast_join_str(return_value, SL(", "), str_list TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Dialect, getSqlExpression){

	zval *expression, *escape_char = NULL, *type, *name = NULL, *escaped_name = NULL;
	zval *domain, *escaped_domain = NULL, *value = NULL, *operator = NULL;
	zval *left = NULL, *expression_left = NULL, *right = NULL, *expression_right = NULL;
	zval *expression_group, *sql_arguments, *arguments;
	zval *argument = NULL, *argument_expression = NULL, *arguments_joined;
	zval *sql_items, *items, *item = NULL, *item_expression = NULL;
	zval *list_expression, *exception_message;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &expression, &escape_char);
	
	if (!escape_char) {
		PHALCON_INIT_VAR(escape_char);
	} else {
		PHALCON_SEPARATE_PARAM(escape_char);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		if (Z_TYPE_P(escape_char) == IS_NULL) {
			PHALCON_OBS_NVAR(escape_char);
			phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
		}
	}
	if (Z_TYPE_P(expression) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid SQL expression");
		return;
	}
	
	if (!phalcon_array_isset_quick_string(expression, SS("type"), 276192743UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid SQL expression");
		return;
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, expression, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_STRING(type, "qualified")) {
	
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, expression, SS("name"), 268211462UL, PH_NOISY);
		if (PHALCON_GLOBAL(db).escape_identifiers) {
			PHALCON_INIT_VAR(escaped_name);
			PHALCON_CONCAT_VVV(escaped_name, escape_char, name, escape_char);
		} else {
			PHALCON_CPY_WRT(escaped_name, name);
		}
	
		if (phalcon_array_isset_quick_string(expression, SS("domain"), 542597917UL)) {
	
			PHALCON_OBS_VAR(domain);
			phalcon_array_fetch_quick_string(&domain, expression, SS("domain"), 542597917UL, PH_NOISY);
			if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_VAR(escaped_domain);
				PHALCON_CONCAT_VVVSV(escaped_domain, escape_char, domain, escape_char, ".", escaped_name);
			} else {
				PHALCON_INIT_NVAR(escaped_domain);
				PHALCON_CONCAT_VSV(escaped_domain, domain, ".", escaped_name);
			}
	
			RETURN_CTOR(escaped_domain);
		}
	
		RETURN_CTOR(escaped_name);
	}
	
	if (PHALCON_IS_STRING(type, "literal")) {
		PHALCON_OBS_VAR(value);
		phalcon_array_fetch_quick_string(&value, expression, SS("value"), 574111618UL, PH_NOISY);
		RETURN_CTOR(value);
	}
	
	if (PHALCON_IS_STRING(type, "binary-op")) {
		PHALCON_OBS_VAR(operator);
		phalcon_array_fetch_quick_string(&operator, expression, SS("op"), 193501572UL, PH_NOISY);
	
		PHALCON_OBS_VAR(left);
		phalcon_array_fetch_quick_string(&left, expression, SS("left"), 265976240UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_left, this_ptr, "getsqlexpression", left, escape_char);
	
		PHALCON_OBS_VAR(right);
		phalcon_array_fetch_quick_string(&right, expression, SS("right"), 426864067UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_right, this_ptr, "getsqlexpression", right, escape_char);
		PHALCON_CONCAT_VSVSV(return_value, expression_left, " ", operator, " ", expression_right);
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(type, "unary-op")) {
	
		PHALCON_OBS_NVAR(operator);
		phalcon_array_fetch_quick_string(&operator, expression, SS("op"), 193501572UL, PH_NOISY);
	
		if (phalcon_array_isset_quick_string(expression, SS("left"), 265976240UL)) {
			PHALCON_OBS_NVAR(left);
			phalcon_array_fetch_quick_string(&left, expression, SS("left"), 265976240UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&expression_left, this_ptr, "getsqlexpression", left, escape_char);
			PHALCON_CONCAT_VV(return_value, expression_left, operator);
			RETURN_MM();
		}
	
		if (phalcon_array_isset_quick_string(expression, SS("right"), 426864067UL)) {
			PHALCON_OBS_NVAR(right);
			phalcon_array_fetch_quick_string(&right, expression, SS("right"), 426864067UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&expression_right, this_ptr, "getsqlexpression", right, escape_char);
			PHALCON_CONCAT_VV(return_value, operator, expression_right);
			RETURN_MM();
		}
	}
	
	if (PHALCON_IS_STRING(type, "placeholder")) {
		PHALCON_OBS_NVAR(value);
		phalcon_array_fetch_quick_string(&value, expression, SS("value"), 574111618UL, PH_NOISY);
		RETURN_CTOR(value);
	}
	
	if (PHALCON_IS_STRING(type, "parentheses")) {
		PHALCON_OBS_NVAR(left);
		phalcon_array_fetch_quick_string(&left, expression, SS("left"), 265976240UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_left, this_ptr, "getsqlexpression", left, escape_char);
	
		PHALCON_INIT_VAR(expression_group);
		PHALCON_CONCAT_SVS(expression_group, "(", expression_left, ")");
		RETURN_CTOR(expression_group);
	}
	
	if (PHALCON_IS_STRING(type, "functionCall")) {
	
		PHALCON_OBS_NVAR(name);
		phalcon_array_fetch_quick_string(&name, expression, SS("name"), 268211462UL, PH_NOISY);
	
		PHALCON_INIT_VAR(sql_arguments);
		array_init(sql_arguments);
		if (phalcon_array_isset_quick_string(expression, SS("arguments"), 3751272283UL)) {
	
			PHALCON_OBS_VAR(arguments);
			phalcon_array_fetch_quick_string(&arguments, expression, SS("arguments"), 3751272283UL, PH_NOISY);
	
			phalcon_is_iterable(arguments, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(argument);
	
				PHALCON_CALL_METHOD(&argument_expression, this_ptr, "getsqlexpression", argument, escape_char);
				phalcon_array_append(&sql_arguments, argument_expression, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			PHALCON_INIT_VAR(arguments_joined);
			phalcon_fast_join_str(arguments_joined, SL(", "), sql_arguments TSRMLS_CC);
			if (phalcon_array_isset_quick_string(expression, SS("distinct"), 73581991UL)) {
				PHALCON_CONCAT_VSVS(return_value, name, "(DISTINCT ", arguments_joined, ")");
			}
			else {
				PHALCON_CONCAT_VSVS(return_value, name, "(", arguments_joined, ")");
			}
	
			RETURN_MM();
		} else {
			PHALCON_CONCAT_VS(return_value, name, "()");
			RETURN_MM();
		}
	}
	
	if (PHALCON_IS_STRING(type, "list")) {
	
		PHALCON_INIT_VAR(sql_items);
		array_init(sql_items);
	
		PHALCON_OBS_VAR(items);
		phalcon_array_fetch_long(&items, expression, 0, PH_NOISY);
	
		phalcon_is_iterable(items, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(item);
	
			PHALCON_CALL_METHOD(&item_expression, this_ptr, "getsqlexpression", item, escape_char);
			phalcon_array_append(&sql_items, item_expression, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
		PHALCON_INIT_VAR(list_expression);
		phalcon_fast_join_str(list_expression, SL(", "), sql_items TSRMLS_CC);
		PHALCON_CONCAT_SVS(return_value, "(", list_expression, ")");
	
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(type, "all")) {
		RETURN_MM_STRING("*", 1);
	}
	
	if (PHALCON_IS_STRING(type, "cast")) {
		PHALCON_OBS_NVAR(left);
		phalcon_array_fetch_quick_string(&left, expression, SS("left"), 265976240UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_left, this_ptr, "getsqlexpression", left, escape_char);
	
		PHALCON_OBS_NVAR(right);
		phalcon_array_fetch_quick_string(&right, expression, SS("right"), 426864067UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_right, this_ptr, "getsqlexpression", right, escape_char);
		PHALCON_CONCAT_SVSVS(return_value, "CAST(", expression_left, " AS ", expression_right, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(type, "convert")) {
		PHALCON_OBS_NVAR(left);
		phalcon_array_fetch_quick_string(&left, expression, SS("left"), 265976240UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_left, this_ptr, "getsqlexpression", left, escape_char);
	
		PHALCON_OBS_NVAR(right);
		phalcon_array_fetch_quick_string(&right, expression, SS("right"), 426864067UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expression_right, this_ptr, "getsqlexpression", right, escape_char);
		PHALCON_CONCAT_SVSVS(return_value, "CONVERT(", expression_left, " USING ", expression_right, ")");
		RETURN_MM();
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Invalid SQL expression type '", type, "'");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_db_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect, getSqlTable){

	zval *table, *escape_char = NULL, *table_name, *sql_table = NULL;
	zval *schema_name, *sql_schema = NULL, *alias_name;
	zval *sql_table_alias = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &escape_char);
	
	if (!escape_char) {
		PHALCON_INIT_VAR(escape_char);
	} else {
		PHALCON_SEPARATE_PARAM(escape_char);
	}
	
	if (Z_TYPE_P(escape_char) == IS_NULL) {
		PHALCON_OBS_NVAR(escape_char);
		phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
	}
	if (Z_TYPE_P(table) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(table_name);
		phalcon_array_fetch_long(&table_name, table, 0, PH_NOISY);
		if (PHALCON_GLOBAL(db).escape_identifiers) {
			PHALCON_INIT_VAR(sql_table);
			PHALCON_CONCAT_VVV(sql_table, escape_char, table_name, escape_char);
		} else {
			PHALCON_CPY_WRT(sql_table, table_name);
		}
	
		PHALCON_OBS_VAR(schema_name);
		phalcon_array_fetch_long(&schema_name, table, 1, PH_NOISY);
		if (PHALCON_IS_NOT_EMPTY(schema_name)) {
			if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_VAR(sql_schema);
				PHALCON_CONCAT_VVVSV(sql_schema, escape_char, schema_name, escape_char, ".", sql_table);
			} else {
				PHALCON_INIT_NVAR(sql_schema);
				PHALCON_CONCAT_VSV(sql_schema, schema_name, ".", sql_table);
			}
		} else {
			PHALCON_CPY_WRT(sql_schema, sql_table);
		}
	
		if (phalcon_array_isset_long(table, 2)) {
	
			PHALCON_OBS_VAR(alias_name);
			phalcon_array_fetch_long(&alias_name, table, 2, PH_NOISY);
			if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_VAR(sql_table_alias);
				PHALCON_CONCAT_VSVVV(sql_table_alias, sql_schema, " AS ", escape_char, alias_name, escape_char);
			} else {
				PHALCON_INIT_NVAR(sql_table_alias);
				PHALCON_CONCAT_VSV(sql_table_alias, sql_schema, " AS ", alias_name);
			}
		} else {
			PHALCON_CPY_WRT(sql_table_alias, sql_schema);
		}
	
		RETURN_CTOR(sql_table_alias);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_CONCAT_VVV(return_value, escape_char, table, escape_char);
		RETURN_MM();
	}
	
	RETURN_CTOR(table);
}

static PHP_METHOD(Phalcon_Db_Dialect, select){

	zval *definition, *escape_char = NULL, *columns, *selected_columns, *distinct;
	zval *column = NULL, *column_sql = NULL;
	zval *column_domain_sql = NULL, *column_alias_sql = NULL;
	zval *columns_sql = NULL, *tables, *selected_tables;
	zval *table = NULL, *sql_table = NULL, *tables_sql = NULL, *sql, *joins;
	zval *join = NULL, *type = NULL, *sql_join = NULL, *join_conditions_array = NULL;
	zval *join_expressions = NULL, *join_condition = NULL, *join_expression = NULL;
	zval *join_conditions = NULL, *where_conditions;
	zval *where_expression = NULL, *group_items, *group_fields;
	zval *group_field = NULL, *group_expression = NULL, *group_sql;
	zval *group_clause, *having_conditions, *having_expression = NULL;
	zval *order_fields, *order_items, *order_item = NULL;
	zval *order_expression = NULL, *order_sql_item = NULL, *sql_order_type = NULL;
	zval *order_sql_item_type = NULL, *order_sql, *tmp1 = NULL, *tmp2 = NULL;
	zval *limit_value;
	zval *number, *offset;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &definition);

	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid SELECT definition");
		return;
	}
	if (!phalcon_array_isset_quick_string(definition, SS("tables"), 3465666720UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'tables' is required in the definition array");
		return;
	}
	
	if (!phalcon_array_isset_string_fetch(&columns, definition, SS("columns"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'columns' is required in the definition array");
		return;
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_OBS_VAR(escape_char);
		phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(escape_char);
	}
	
	if (Z_TYPE_P(columns) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(selected_columns);
		array_init(selected_columns);
	
		phalcon_is_iterable(columns, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			zval *column_item, *column_alias, *column_domain;
	
			PHALCON_GET_HVALUE(column);
	
			if (
				    phalcon_array_isset_long_fetch(&column_item, column, 0)
				 || phalcon_array_isset_string_fetch(&column_item, column, SS("column"))
			) {
				if (Z_TYPE_P(column_item) == IS_ARRAY) {
					PHALCON_CALL_METHOD(&column_sql, this_ptr, "getsqlexpression", column_item, escape_char);
				} else if (PHALCON_IS_STRING(column_item, "*")) {
					PHALCON_CPY_WRT(column_sql, column_item);
				} else if (PHALCON_GLOBAL(db).escape_identifiers) {
					PHALCON_INIT_NVAR(column_sql);
					PHALCON_CONCAT_VVV(column_sql, escape_char, column_item, escape_char);
				} else {
					PHALCON_CPY_WRT(column_sql, column_item);
				}
			}
			else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid SELECT definition");
				return;
			}
	
			if (phalcon_array_isset_long_fetch(&column_domain, column, 1)) {
				if (zend_is_true(column_domain)) {
					if (PHALCON_GLOBAL(db).escape_identifiers) {
						PHALCON_INIT_NVAR(column_domain_sql);
						PHALCON_CONCAT_VVVSV(column_domain_sql, escape_char, column_domain, escape_char, ".", column_sql);
					} else {
						PHALCON_INIT_NVAR(column_domain_sql);
						PHALCON_CONCAT_VSV(column_domain_sql, column_domain, ".", column_sql);
					}
				} else {
					PHALCON_CPY_WRT(column_domain_sql, column_sql);
				}
			} else {
				PHALCON_CPY_WRT(column_domain_sql, column_sql);
			}
	
			if (phalcon_array_isset_long_fetch(&column_alias, column, 2)) {
	
				if (zend_is_true(column_alias)) {
					if (PHALCON_GLOBAL(db).escape_identifiers) {
						PHALCON_INIT_NVAR(column_alias_sql);
						PHALCON_CONCAT_VSVVV(column_alias_sql, column_domain_sql, " AS ", escape_char, column_alias, escape_char);
					} else {
						PHALCON_INIT_NVAR(column_alias_sql);
						PHALCON_CONCAT_VSV(column_alias_sql, column_domain_sql, " AS ", column_alias);
					}
				} else {
					PHALCON_CPY_WRT(column_alias_sql, column_domain_sql);
				}
			} else {
				PHALCON_CPY_WRT(column_alias_sql, column_domain_sql);
			}
	
			phalcon_array_append(&selected_columns, column_alias_sql, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		PHALCON_INIT_VAR(columns_sql);
		phalcon_fast_join_str(columns_sql, SL(", "), selected_columns TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(columns_sql, columns);
	}
	
	PHALCON_OBS_VAR(tables);
	phalcon_array_fetch_quick_string(&tables, definition, SS("tables"), 3465666720UL, PH_NOISY);
	if (Z_TYPE_P(tables) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(selected_tables);
		array_init(selected_tables);
	
		phalcon_is_iterable(tables, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(table);
	
			PHALCON_CALL_METHOD(&sql_table, this_ptr, "getsqltable", table, escape_char);
			phalcon_array_append(&selected_tables, sql_table, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
		PHALCON_INIT_VAR(tables_sql);
		phalcon_fast_join_str(tables_sql, SL(", "), selected_tables TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(tables_sql, tables);
	}

	PHALCON_INIT_VAR(sql);
	if (phalcon_array_isset_string_fetch(&distinct, definition, SS("distinct"))) {
		assert(Z_TYPE_P(distinct) == IS_LONG);
		if (Z_LVAL_P(distinct) == 0) {
			ZVAL_STRING(sql, "SELECT ALL ", 1);
		}
		else if (Z_LVAL_P(distinct) == 1) {
			ZVAL_STRING(sql, "SELECT DISTINCT ", 1);
		}
		else {
			ZVAL_STRING(sql, "SELECT ", 1);
		}
	}
	else {
		ZVAL_STRING(sql, "SELECT ", 1);
	}
	
	PHALCON_SCONCAT_VSV(sql, columns_sql, " FROM ", tables_sql);
	
	if (phalcon_array_isset_quick_string(definition, SS("joins"), 120974824UL)) {
	
		PHALCON_OBS_VAR(joins);
		phalcon_array_fetch_quick_string(&joins, definition, SS("joins"), 120974824UL, PH_NOISY);
	
		phalcon_is_iterable(joins, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HVALUE(join);
	
			PHALCON_OBS_NVAR(type);
			phalcon_array_fetch_quick_string(&type, join, SS("type"), 276192743UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(table);
			phalcon_array_fetch_quick_string(&table, join, SS("source"), 2744839734UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&sql_table, this_ptr, "getsqltable", table, escape_char);
			phalcon_array_append(&selected_tables, sql_table, PH_SEPARATE);
	
			PHALCON_INIT_NVAR(sql_join);
			PHALCON_CONCAT_SVSV(sql_join, " ", type, " JOIN ", sql_table);
	
			if (phalcon_array_isset_quick_string(join, SS("conditions"), 1055696255UL)) {
	
				PHALCON_OBS_NVAR(join_conditions_array);
				phalcon_array_fetch_quick_string(&join_conditions_array, join, SS("conditions"), 1055696255UL, PH_NOISY);
				if (phalcon_fast_count_ev(join_conditions_array TSRMLS_CC)) {
	
					PHALCON_INIT_NVAR(join_expressions);
					array_init(join_expressions);
	
					phalcon_is_iterable(join_conditions_array, &ah3, &hp3, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
						PHALCON_GET_HVALUE(join_condition);
	
						PHALCON_CALL_METHOD(&join_expression, this_ptr, "getsqlexpression", join_condition, escape_char);
						phalcon_array_append(&join_expressions, join_expression, PH_SEPARATE);
	
						zend_hash_move_forward_ex(ah3, &hp3);
					}
	
					PHALCON_INIT_NVAR(join_conditions);
					phalcon_fast_join_str(join_conditions, SL(" AND "), join_expressions TSRMLS_CC);
					PHALCON_SCONCAT_SVS(sql_join, " ON ", join_conditions, " ");
				}
			}
	
			phalcon_concat_self(&sql, sql_join TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
	}
	
	/* Check for a WHERE clause */
	if (phalcon_array_isset_string_fetch(&where_conditions, definition, SS("where"))) {
	
		if (Z_TYPE_P(where_conditions) == IS_ARRAY) { 
			PHALCON_CALL_METHOD(&where_expression, this_ptr, "getsqlexpression", where_conditions, escape_char);
			PHALCON_SCONCAT_SV(sql, " WHERE ", where_expression);
		} else {
			PHALCON_SCONCAT_SV(sql, " WHERE ", where_conditions);
		}
	}
	
	/* Check for a GROUP clause */
	if (phalcon_array_isset_string_fetch(&group_fields, definition, SS("group"))) {
	
		PHALCON_INIT_VAR(group_items);
		array_init(group_items);
	
		phalcon_is_iterable(group_fields, &ah4, &hp4, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {
	
			PHALCON_GET_HVALUE(group_field);
	
			PHALCON_CALL_METHOD(&group_expression, this_ptr, "getsqlexpression", group_field, escape_char);
			phalcon_array_append(&group_items, group_expression, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah4, &hp4);
		}
	
		PHALCON_INIT_VAR(group_sql);
		phalcon_fast_join_str(group_sql, SL(", "), group_items TSRMLS_CC);
	
		PHALCON_INIT_VAR(group_clause);
		PHALCON_CONCAT_SV(group_clause, " GROUP BY ", group_sql);
		phalcon_concat_self(&sql, group_clause TSRMLS_CC);
	}

	/* Check for a HAVING clause */
	if (phalcon_array_isset_string_fetch(&having_conditions, definition, SS("having"))) {
		PHALCON_CALL_METHOD(&having_expression, this_ptr, "getsqlexpression", having_conditions, escape_char);
		PHALCON_SCONCAT_SV(sql, " HAVING ", having_expression);
	}
	
	/* Check for a ORDER clause */
	if (phalcon_array_isset_string_fetch(&order_fields, definition, SS("order"))) {
		PHALCON_INIT_VAR(order_items);
		array_init(order_items);
	
		phalcon_is_iterable(order_fields, &ah5, &hp5, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) == SUCCESS) {
	
			PHALCON_GET_HVALUE(order_item);
	
			PHALCON_OBS_NVAR(order_expression);
			phalcon_array_fetch_long(&order_expression, order_item, 0, PH_NOISY);
	
			PHALCON_CALL_METHOD(&order_sql_item, this_ptr, "getsqlexpression", order_expression, escape_char);
	
			if (phalcon_array_isset_long(order_item, 1)) {
				PHALCON_OBS_NVAR(sql_order_type);
				phalcon_array_fetch_long(&sql_order_type, order_item, 1, PH_NOISY);
	
				PHALCON_INIT_NVAR(order_sql_item_type);
				PHALCON_CONCAT_VSV(order_sql_item_type, order_sql_item, " ", sql_order_type);
			} else {
				PHALCON_CPY_WRT(order_sql_item_type, order_sql_item);
			}
	
			phalcon_array_append(&order_items, order_sql_item_type, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah5, &hp5);
		}
	
		PHALCON_INIT_VAR(order_sql);
		phalcon_fast_join_str(order_sql, SL(", "), order_items TSRMLS_CC);
		PHALCON_SCONCAT_SV(sql, " ORDER BY ", order_sql);
	}
	
	if (phalcon_array_isset_string_fetch(&limit_value, definition, SS("limit"))) {
		if (likely(Z_TYPE_P(limit_value) == IS_ARRAY)) {
			if (likely(phalcon_array_isset_string_fetch(&number, limit_value, SS("number")))) {
				PHALCON_OBS_NVAR(tmp1);
				phalcon_array_fetch_quick_string(&tmp1, number, SS("value"), 574111618UL, PH_NOISY);

				if (phalcon_array_isset_string_fetch(&offset, limit_value, SS("offset"))) {
					PHALCON_OBS_NVAR(tmp2);
					phalcon_array_fetch_quick_string(&tmp2, offset, SS("value"), 574111618UL, PH_NOISY);
					PHALCON_SCONCAT_SVSV(sql, " LIMIT ", tmp1, " OFFSET ", tmp2);
				} else {
					PHALCON_SCONCAT_SV(sql, " LIMIT ", tmp1);
				}
			}
		} else {
			PHALCON_SCONCAT_SV(sql, " LIMIT ", limit_value);
		}
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect, supportsSavepoints){


	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Db_Dialect, supportsReleaseSavepoints)
{
	PHALCON_RETURN_CALL_METHODW(this_ptr, "supportssavepoints");
}

static PHP_METHOD(Phalcon_Db_Dialect, createSavepoint){

	zval *name;

	phalcon_fetch_params(0, 1, 0, &name);
	
	PHALCON_CONCAT_SV(return_value, "SAVEPOINT ", name);
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect, releaseSavepoint){

	zval *name;

	phalcon_fetch_params(0, 1, 0, &name);
	
	PHALCON_CONCAT_SV(return_value, "RELEASE SAVEPOINT ", name);
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect, rollbackSavepoint){

	zval *name;

	phalcon_fetch_params(0, 1, 0, &name);
	
	PHALCON_CONCAT_SV(return_value, "ROLLBACK TO SAVEPOINT ", name);
	return;
}





zend_class_entry *phalcon_db_dialectinterface_ce;

static const zend_function_entry phalcon_db_dialectinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, limit, arginfo_phalcon_db_dialectinterface_limit)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, forUpdate, arginfo_phalcon_db_dialectinterface_forupdate)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, sharedLock, arginfo_phalcon_db_dialectinterface_sharedlock)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, select, arginfo_phalcon_db_dialectinterface_select)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, getColumnList, arginfo_phalcon_db_dialectinterface_getcolumnlist)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, getColumnDefinition, arginfo_phalcon_db_dialectinterface_getcolumndefinition)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, addColumn, arginfo_phalcon_db_dialectinterface_addcolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, modifyColumn, arginfo_phalcon_db_dialectinterface_modifycolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropColumn, arginfo_phalcon_db_dialectinterface_dropcolumn)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, addIndex, arginfo_phalcon_db_dialectinterface_addindex)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropIndex, arginfo_phalcon_db_dialectinterface_dropindex)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, addPrimaryKey, arginfo_phalcon_db_dialectinterface_addprimarykey)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropPrimaryKey, arginfo_phalcon_db_dialectinterface_dropprimarykey)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, addForeignKey, arginfo_phalcon_db_dialectinterface_addforeignkey)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropForeignKey, arginfo_phalcon_db_dialectinterface_dropforeignkey)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, createTable, arginfo_phalcon_db_dialectinterface_createtable)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropTable, arginfo_phalcon_db_dialectinterface_droptable)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, createView, arginfo_phalcon_db_dialectinterface_createview)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, dropView, arginfo_phalcon_db_dialectinterface_dropview)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, tableExists, arginfo_phalcon_db_dialectinterface_tableexists)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, viewExists, arginfo_phalcon_db_dialectinterface_viewexists)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, describeColumns, arginfo_phalcon_db_dialectinterface_describecolumns)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, listTables, arginfo_phalcon_db_dialectinterface_listtables)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, listViews, arginfo_phalcon_db_dialectinterface_listtables)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, describeIndexes, arginfo_phalcon_db_dialectinterface_describeindexes)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, describeReferences, arginfo_phalcon_db_dialectinterface_describereferences)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, tableOptions, arginfo_phalcon_db_dialectinterface_tableoptions)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, supportsSavepoints, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, supportsReleaseSavepoints, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, createSavepoint, arginfo_phalcon_db_dialectinterface_createsavepoint)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, releaseSavepoint, arginfo_phalcon_db_dialectinterface_releasesavepoint)
	PHP_ABSTRACT_ME(Phalcon_Db_DialectInterface, rollbackSavepoint, arginfo_phalcon_db_dialectinterface_rollbacksavepoint)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_DialectInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, DialectInterface, db_dialectinterface, phalcon_db_dialectinterface_method_entry);

	return SUCCESS;
}






































zend_class_entry *phalcon_db_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Db_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db, Exception, db_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_db_index_ce;

static PHP_METHOD(Phalcon_Db_Index, __construct);
static PHP_METHOD(Phalcon_Db_Index, getName);
static PHP_METHOD(Phalcon_Db_Index, getColumns);
static PHP_METHOD(Phalcon_Db_Index, getType);
static PHP_METHOD(Phalcon_Db_Index, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_index___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, indexName)
	ZEND_ARG_INFO(0, columns)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_index_method_entry[] = {
	PHP_ME(Phalcon_Db_Index, __construct, arginfo_phalcon_db_index___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Index, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Index, getColumns, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Index, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Index, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Index){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Index, db_index, phalcon_db_index_method_entry, 0);

	zend_declare_property_null(phalcon_db_index_ce, SL("_indexName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_index_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_index_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_index_ce TSRMLS_CC, 1, phalcon_db_indexinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Index, __construct){

	zval *index_name, *columns;
	zval *type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &index_name, &columns, &type);

	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_indexName"), index_name, 3837120573UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_columns"), columns, 4004520869UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Index, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_indexName", 3837120573UL);
}

static PHP_METHOD(Phalcon_Db_Index, getColumns){


	RETURN_MEMBER_QUICK(this_ptr, "_columns", 4004520869UL);
}

static PHP_METHOD(Phalcon_Db_Index, getType){

	zval *type = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(type);
	phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(type) == IS_STRING) {
		RETVAL_ZVAL(type, 1, 0);
	} else {
		RETVAL_EMPTY_STRING();
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Index, __set_state){

	zval *data, *index_name, *columns;

	phalcon_fetch_params(0, 1, 0, &data);
	
	if (!phalcon_array_isset_string_fetch(&index_name, data, SS("_indexName"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "_indexName parameter is required");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&columns, data, SS("_columns"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "_columns parameter is required");
		return;
	}
	
	object_init_ex(return_value, phalcon_db_index_ce);
	PHALCON_CALL_METHODW(NULL, return_value, "__construct", index_name, columns);
}





zend_class_entry *phalcon_db_indexinterface_ce;

static const zend_function_entry phalcon_db_indexinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_IndexInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_IndexInterface, getColumns, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_IndexInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, IndexInterface, db_indexinterface, phalcon_db_indexinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_db_profiler_ce;

static PHP_METHOD(Phalcon_Db_Profiler, startProfile);
static PHP_METHOD(Phalcon_Db_Profiler, stopProfile);
static PHP_METHOD(Phalcon_Db_Profiler, getNumberTotalStatements);
static PHP_METHOD(Phalcon_Db_Profiler, getTotalElapsedSeconds);
static PHP_METHOD(Phalcon_Db_Profiler, getProfiles);
static PHP_METHOD(Phalcon_Db_Profiler, reset);
static PHP_METHOD(Phalcon_Db_Profiler, getLastProfile);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_startprofile, 0, 0, 1)
	ZEND_ARG_INFO(0, sqlStatement)
	ZEND_ARG_INFO(0, sqlVariables)
	ZEND_ARG_INFO(0, sqlBindTypes)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_profiler_method_entry[] = {
	PHP_ME(Phalcon_Db_Profiler, startProfile, arginfo_phalcon_db_profiler_startprofile, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, stopProfile, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, getNumberTotalStatements, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, getTotalElapsedSeconds, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, getProfiles, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, reset, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler, getLastProfile, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Profiler){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Profiler, db_profiler, phalcon_db_profiler_method_entry, 0);

	zend_declare_property_null(phalcon_db_profiler_ce, SL("_allProfiles"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_ce, SL("_activeProfile"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_profiler_ce, SL("_totalSeconds"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Profiler, startProfile){

	zval *sql_statement, *sql_variables = NULL, *sql_bindtypes = NULL, *active_profile;
	zval *time = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &sql_statement, &sql_variables, &sql_bindtypes);
	
	PHALCON_INIT_VAR(active_profile);
	object_init_ex(active_profile, phalcon_db_profiler_item_ce);
	PHALCON_CALL_METHOD(NULL, active_profile, "setsqlstatement", sql_statement);

	if (sql_variables) {
	    PHALCON_CALL_METHOD(NULL, active_profile, "setsqlvariables", sql_variables);
	}

	if (sql_bindtypes) {
	    PHALCON_CALL_METHOD(NULL, active_profile, "setsqlbindtypes", sql_bindtypes);
	}

	PHALCON_CALL_FUNCTION(&time, "microtime", PHALCON_GLOBAL(z_true));
	PHALCON_CALL_METHOD(NULL, active_profile, "setinitialtime", time);

	if (phalcon_method_quick_exists_ex(this_ptr, SS("beforestartprofile"), 1538499511UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "beforestartprofile", active_profile);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_activeProfile"), active_profile, 794883025UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Db_Profiler, stopProfile){

	zval *final_time = NULL, *active_profile, *initial_time = NULL;
	zval *difference, *total_seconds, *new_total_seconds;

	PHALCON_MM_GROW();

	PHALCON_CALL_FUNCTION(&final_time, "microtime", PHALCON_GLOBAL(z_true));
	
	active_profile = phalcon_fetch_nproperty_this(this_ptr, SL("_activeProfile"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, active_profile, "setfinaltime", final_time);
	
	PHALCON_CALL_METHOD(&initial_time, active_profile, "getinitialtime");
	
	PHALCON_INIT_VAR(difference);
	sub_function(difference, final_time, initial_time TSRMLS_CC);
	
	total_seconds = phalcon_fetch_nproperty_this(this_ptr, SL("_totalSeconds"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(new_total_seconds);
	phalcon_add_function(new_total_seconds, total_seconds, difference TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_totalSeconds"), new_total_seconds, 996888727UL TSRMLS_CC);
	phalcon_update_property_array_append(this_ptr, SL("_allProfiles"), active_profile TSRMLS_CC);
	if (phalcon_method_quick_exists_ex(this_ptr, SS("afterendprofile"), 3954247487UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "afterendprofile", active_profile);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Db_Profiler, getNumberTotalStatements){

	zval *all_profiles;

	all_profiles = phalcon_fetch_nproperty_this(this_ptr, SL("_allProfiles"), PH_NOISY TSRMLS_CC);
	phalcon_fast_count(return_value, all_profiles TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Db_Profiler, getTotalElapsedSeconds){


	RETURN_MEMBER_QUICK(this_ptr, "_totalSeconds", 996888727UL);
}

static PHP_METHOD(Phalcon_Db_Profiler, getProfiles){


	RETURN_MEMBER_QUICK(this_ptr, "_allProfiles", 1465095617UL);
}

static PHP_METHOD(Phalcon_Db_Profiler, reset){

	zval *empty_arr;

	MAKE_STD_ZVAL(empty_arr);
	array_init(empty_arr);
	phalcon_update_property_this_quick(this_ptr, SL("_allProfiles"), empty_arr, 1465095617UL TSRMLS_CC);
	zval_ptr_dtor(&empty_arr);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Db_Profiler, getLastProfile){


	RETURN_MEMBER_QUICK(this_ptr, "_activeProfile", 794883025UL);
}





zend_class_entry *phalcon_db_rawvalue_ce;

static PHP_METHOD(Phalcon_Db_RawValue, __construct);
static PHP_METHOD(Phalcon_Db_RawValue, getValue);
static PHP_METHOD(Phalcon_Db_RawValue, __toString);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_rawvalue___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_rawvalue_method_entry[] = {
	PHP_ME(Phalcon_Db_RawValue, __construct, arginfo_phalcon_db_rawvalue___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_RawValue, getValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_RawValue, __toString, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_RawValue){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, RawValue, db_rawvalue, phalcon_db_rawvalue_method_entry, 0);

	zend_declare_property_null(phalcon_db_rawvalue_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_RawValue, __construct){

	zval *value;

	phalcon_fetch_params(0, 1, 0, &value);
	
	phalcon_update_property_this_quick(this_ptr, SL("_value"), value, 2935317441UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_RawValue, getValue){


	RETURN_MEMBER_QUICK(this_ptr, "_value", 2935317441UL);
}

static PHP_METHOD(Phalcon_Db_RawValue, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_value", 2935317441UL);
}







zend_class_entry *phalcon_db_reference_ce;

static PHP_METHOD(Phalcon_Db_Reference, __construct);
static PHP_METHOD(Phalcon_Db_Reference, getName);
static PHP_METHOD(Phalcon_Db_Reference, getSchemaName);
static PHP_METHOD(Phalcon_Db_Reference, getReferencedSchema);
static PHP_METHOD(Phalcon_Db_Reference, getColumns);
static PHP_METHOD(Phalcon_Db_Reference, getReferencedTable);
static PHP_METHOD(Phalcon_Db_Reference, getReferencedColumns);
static PHP_METHOD(Phalcon_Db_Reference, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_reference___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, referenceName)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_reference_method_entry[] = {
	PHP_ME(Phalcon_Db_Reference, __construct, arginfo_phalcon_db_reference___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Reference, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, getSchemaName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, getReferencedSchema, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, getColumns, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, getReferencedTable, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, getReferencedColumns, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Reference, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Reference){

	PHALCON_REGISTER_CLASS(Phalcon\\Db, Reference, db_reference, phalcon_db_reference_method_entry, 0);

	zend_declare_property_null(phalcon_db_reference_ce, SL("_schemaName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedSchema"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referenceName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedTable"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_reference_ce, SL("_referencedColumns"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_reference_ce TSRMLS_CC, 1, phalcon_db_referenceinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Reference, __construct){

	zval *reference_name, *definition, *referenced_table;
	zval *columns, *referenced_columns, *schema;
	zval *referenced_schema;
	long int number_columns, number_referenced_columns;

	phalcon_fetch_params(0, 2, 0, &reference_name, &definition);
	
	phalcon_update_property_this_quick(this_ptr, SL("_referenceName"), reference_name, 4269393812UL TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&referenced_table, definition, SS("referencedTable"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_referencedTable"), referenced_table, 39793215UL TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Referenced table is required");
		return;
	}
	
	if (phalcon_array_isset_string_fetch(&columns, definition, SS("columns"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_columns"), columns, 4004520869UL TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Foreign key columns are required");
		return;
	}
	
	if (phalcon_array_isset_string_fetch(&referenced_columns, definition, SS("referencedColumns"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_referencedColumns"), referenced_columns, 3024201272UL TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Referenced columns of the foreign key are required");
		return;
	}
	
	if (phalcon_array_isset_string_fetch(&schema, definition, SS("schema"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_schemaName"), schema, 851420310UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&referenced_schema, definition, SS("referencedSchema"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_referencedSchema"), referenced_schema, 106854792UL TSRMLS_CC);
	}
	
	number_columns            = phalcon_fast_count_int(columns TSRMLS_CC);
	number_referenced_columns = phalcon_fast_count_int(referenced_columns TSRMLS_CC);
	
	if (number_columns != number_referenced_columns) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Number of columns is not equal to the number of referenced columns");
		return;
	}
}

static PHP_METHOD(Phalcon_Db_Reference, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_referenceName", 4269393812UL);
}

static PHP_METHOD(Phalcon_Db_Reference, getSchemaName){


	RETURN_MEMBER_QUICK(this_ptr, "_schemaName", 851420310UL);
}

static PHP_METHOD(Phalcon_Db_Reference, getReferencedSchema){


	RETURN_MEMBER_QUICK(this_ptr, "_referencedSchema", 106854792UL);
}

static PHP_METHOD(Phalcon_Db_Reference, getColumns){


	RETURN_MEMBER_QUICK(this_ptr, "_columns", 4004520869UL);
}

static PHP_METHOD(Phalcon_Db_Reference, getReferencedTable){


	RETURN_MEMBER_QUICK(this_ptr, "_referencedTable", 39793215UL);
}

static PHP_METHOD(Phalcon_Db_Reference, getReferencedColumns){


	RETURN_MEMBER_QUICK(this_ptr, "_referencedColumns", 3024201272UL);
}

static PHP_METHOD(Phalcon_Db_Reference, __set_state){

	zval *data, *constraint_name, *referenced_schema;
	zval *referenced_table, *columns, *referenced_columns;
	zval *definition;

	phalcon_fetch_params(0, 1, 0, &data);
	
	if (!phalcon_array_isset_string_fetch(&constraint_name, data, SS("_referenceName"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "_referenceName parameter is required");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&referenced_schema, data, SS("_referencedSchema"))) {
		referenced_schema = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_array_isset_string_fetch(&referenced_table, data, SS("_referencedTable"))) {
		referenced_table = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_array_isset_string_fetch(&columns, data, SS("_columns"))) {
		columns = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_array_isset_string_fetch(&referenced_columns, data, SS("_referencedColumns"))) {
		referenced_columns = PHALCON_GLOBAL(z_null);
	}

	PHALCON_ALLOC_GHOST_ZVAL(definition);
	array_init_size(definition, 4);
	phalcon_array_update_string(&definition, SL("referencedSchema"),  referenced_schema, PH_COPY);
	phalcon_array_update_string(&definition, SL("referencedTable"),   referenced_table, PH_COPY);
	phalcon_array_update_string(&definition, SL("columns"),           columns, PH_COPY);
	phalcon_array_update_string(&definition, SL("referencedColumns"), referenced_columns, PH_COPY);

	object_init_ex(return_value, phalcon_db_reference_ce);
	PHALCON_CALL_METHODW(NULL, return_value, "__construct", constraint_name, definition);
}





zend_class_entry *phalcon_db_referenceinterface_ce;

static const zend_function_entry phalcon_db_referenceinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getSchemaName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getReferencedSchema, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getColumns, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getReferencedTable, NULL)
	PHP_ABSTRACT_ME(Phalcon_Db_ReferenceInterface, getReferencedColumns, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_ReferenceInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ReferenceInterface, db_referenceinterface, phalcon_db_referenceinterface_method_entry);

	return SUCCESS;
}











zend_class_entry *phalcon_db_resultinterface_ce;

static const zend_function_entry phalcon_db_resultinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, execute, arginfo_phalcon_db_resultinterface_execute)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, fetch, arginfo_phalcon_db_resultinterface_fetch)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, fetchArray, arginfo_phalcon_db_resultinterface_fetcharray)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, fetchAll, arginfo_phalcon_db_resultinterface_fetchall)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, numRows, arginfo_phalcon_db_resultinterface_numrows)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, dataSeek, arginfo_phalcon_db_resultinterface_dataseek)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, setFetchMode, arginfo_phalcon_db_resultinterface_setfetchmode)
	PHP_ABSTRACT_ME(Phalcon_Db_ResultInterface, getInternalResult, arginfo_phalcon_db_resultinterface_getinternalresult)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_ResultInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Db, ResultInterface, db_resultinterface, phalcon_db_resultinterface_method_entry);

	return SUCCESS;
}













#include <ext/pdo/php_pdo_driver.h>


zend_class_entry *phalcon_db_adapter_pdo_ce;

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, __construct);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, connect);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, prepare);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, executePrepared);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, query);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, execute);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, affectedRows);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, close);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, escapeIdentifier);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, escapeString);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, convertBoundParams);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, lastInsertId);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, begin);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, rollback);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, commit);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, getTransactionLevel);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, isUnderTransaction);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo, getInternalHandler);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, descriptor)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo_prepare, 0, 0, 1)
	ZEND_ARG_INFO(0, sqlStatement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo_executeprepared, 0, 0, 3)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, placeholders)
	ZEND_ARG_INFO(0, dataTypes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo_begin, 0, 0, 0)
	ZEND_ARG_INFO(0, nesting)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo_rollback, 0, 0, 0)
	ZEND_ARG_INFO(0, nesting)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_adapter_pdo_commit, 0, 0, 0)
	ZEND_ARG_INFO(0, nesting)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_adapter_pdo_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter_Pdo, __construct, arginfo_phalcon_db_adapter_pdo___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Adapter_Pdo, connect, arginfo_phalcon_db_adapterinterface_connect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, prepare, arginfo_phalcon_db_adapter_pdo_prepare, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, executePrepared, arginfo_phalcon_db_adapter_pdo_executeprepared, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, query, arginfo_phalcon_db_adapterinterface_query, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, execute, arginfo_phalcon_db_adapterinterface_execute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, affectedRows, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, close, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, escapeIdentifier, arginfo_phalcon_db_adapterinterface_escapeidentifier, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, escapeString, arginfo_phalcon_db_adapterinterface_escapestring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, convertBoundParams, arginfo_phalcon_db_adapterinterface_convertboundparams, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, lastInsertId, arginfo_phalcon_db_adapterinterface_lastinsertid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, begin, arginfo_phalcon_db_adapter_pdo_begin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, rollback, arginfo_phalcon_db_adapter_pdo_rollback, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, commit, arginfo_phalcon_db_adapter_pdo_commit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, getTransactionLevel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, isUnderTransaction, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo, getInternalHandler, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter, Pdo, db_adapter_pdo, phalcon_db_adapter_ce, phalcon_db_adapter_pdo_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_db_adapter_pdo_ce, SL("_pdo"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_adapter_pdo_ce, SL("_affectedRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_adapter_pdo_ce, SL("_transactionLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, __construct){

	zval *descriptor;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &descriptor);
	
	if (Z_TYPE_P(descriptor) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The descriptor must be an array");
		return;
	}
	PHALCON_CALL_METHOD(NULL, this_ptr, "connect", descriptor);
	PHALCON_CALL_PARENT(NULL, phalcon_db_adapter_pdo_ce, this_ptr, "__construct", descriptor);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, connect){

	zval *descriptor = NULL, *username = NULL, *password = NULL, *dsn_parts;
	zval *value = NULL, *key = NULL, *dsn_attribute = NULL, *dsn_attributes = NULL;
	zval *pdo_type, *dsn, *options = NULL, *persistent, *pdo;
	zend_class_entry *ce;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|z", &descriptor) == FAILURE) {
		RETURN_MM_NULL();
	}

	if (!descriptor) {
		PHALCON_INIT_VAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}

	if (Z_TYPE_P(descriptor) == IS_NULL) {
		PHALCON_OBS_NVAR(descriptor);
		phalcon_read_property(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY TSRMLS_CC);
	}

	if (phalcon_array_isset_quick_string(descriptor, SS("username"), 3241309669UL)) {
		PHALCON_OBS_VAR(username);
		phalcon_array_fetch_quick_string(&username, descriptor, SS("username"), 3241309669UL, PH_NOISY);
		phalcon_array_unset_string(&descriptor, SS("username"), PH_SEPARATE);
	} else {
		PHALCON_INIT_NVAR(username);
	}

	if (phalcon_array_isset_quick_string(descriptor, SS("password"), 382886712UL)) {
		PHALCON_OBS_VAR(password);
		phalcon_array_fetch_quick_string(&password, descriptor, SS("password"), 382886712UL, PH_NOISY);
		phalcon_array_unset_string(&descriptor, SS("password"), PH_SEPARATE);
	} else {
		PHALCON_INIT_NVAR(password);
	}

	if (phalcon_array_isset_quick_string(descriptor, SS("options"), 2952422065UL)) {
		PHALCON_OBS_VAR(options);
		phalcon_array_fetch_quick_string(&options, descriptor, SS("options"), 2952422065UL, PH_NOISY);
		phalcon_array_unset_string(&descriptor, SS("options"), PH_SEPARATE);
	} else {
		PHALCON_INIT_NVAR(options);
		array_init(options);
	}

	if (!phalcon_array_isset_quick_string(descriptor, SS("dsn"), 2090196170UL)) {

		PHALCON_INIT_VAR(dsn_parts);
		array_init(dsn_parts);

		phalcon_is_iterable(descriptor, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);

			PHALCON_INIT_NVAR(dsn_attribute);
			PHALCON_CONCAT_VSV(dsn_attribute, key, "=", value);
			phalcon_array_append(&dsn_parts, dsn_attribute, PH_SEPARATE);

			zend_hash_move_forward_ex(ah0, &hp0);
		}

		PHALCON_INIT_VAR(dsn_attributes);
		phalcon_fast_join_str(dsn_attributes, SL(";"), dsn_parts TSRMLS_CC);
	} else {
		PHALCON_OBS_NVAR(dsn_attributes);
		phalcon_array_fetch_quick_string(&dsn_attributes, descriptor, SS("dsn"), 2090196170UL, PH_NOISY);
	}

	PHALCON_OBS_VAR(pdo_type);
	phalcon_read_property(&pdo_type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(dsn);
	PHALCON_CONCAT_VSV(dsn, pdo_type, ":", dsn_attributes);

	phalcon_array_update_long_long(&options, PDO_ATTR_ERRMODE, PDO_ERRMODE_EXCEPTION, PH_SEPARATE);
	if (phalcon_array_isset_quick_string(descriptor, SS("persistent"), 2222052598UL)) {

		PHALCON_OBS_VAR(persistent);
		phalcon_array_fetch_quick_string(&persistent, descriptor, SS("persistent"), 2222052598UL, PH_NOISY);
		if (zend_is_true(persistent)) {
			phalcon_array_update_long_bool(&options, PDO_ATTR_PERSISTENT, 1, PH_SEPARATE);
		}
	}

	ce = php_pdo_get_dbh_ce();

	PHALCON_INIT_VAR(pdo);
	object_init_ex(pdo, ce);
	PHALCON_CALL_METHOD(NULL, pdo, "__construct", dsn, username, password, options);

	phalcon_update_property_zval(this_ptr, SL("_pdo"), pdo TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, prepare){

	zval *sql_statement, *pdo;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &sql_statement);
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo, "prepare", sql_statement);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, executePrepared){

	zval *statement = NULL, *placeholders = NULL, *data_types = NULL;
	zval *z_one, *value = NULL, *wildcard = NULL, *parameter = NULL, *type = NULL, *cast_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &statement, &placeholders, &data_types) == FAILURE) {
		RETURN_NULL();
	}

	PHALCON_MM_GROW();

	z_one = PHALCON_GLOBAL(z_one);

	phalcon_is_iterable(placeholders, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HKEY(wildcard, ah0, hp0);
		PHALCON_GET_HVALUE(value);

		if (Z_TYPE_P(wildcard) == IS_LONG) {
			PHALCON_INIT_NVAR(parameter);
			phalcon_add_function(parameter, wildcard, z_one TSRMLS_CC);
		} else {
			if (Z_TYPE_P(wildcard) == IS_STRING) {
				PHALCON_CPY_WRT(parameter, wildcard);
			} else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Invalid bind parameter");
				return;
			}
		}

		if (Z_TYPE_P(data_types) == IS_ARRAY) {

			if (likely(phalcon_array_isset(data_types, wildcard))) {

				PHALCON_OBS_NVAR(type);
				phalcon_array_fetch(&type, data_types, wildcard, PH_NOISY);
				if (phalcon_compare_strict_long(type, 32 TSRMLS_CC)) {

					PHALCON_INIT_NVAR(cast_value);
					phalcon_cast(cast_value, value, IS_DOUBLE);

					PHALCON_INIT_NVAR(type);
					ZVAL_LONG(type, 1024);
				} else {
					PHALCON_CPY_WRT(cast_value, value);
				}

				Z_SET_ISREF_P(cast_value);
				if (phalcon_compare_strict_long(type, 1024 TSRMLS_CC)) {
					PHALCON_CALL_METHOD(NULL, statement, "bindvalue", parameter, cast_value);
				} else {
					PHALCON_CALL_METHOD(NULL, statement, "bindvalue", parameter, cast_value, type);
				}
				Z_UNSET_ISREF_P(cast_value);

			} else {
				PHALCON_INIT_NVAR(type);
				if (Z_TYPE_P(value) == IS_LONG) {
					ZVAL_LONG(type, 1 /* BIND_PARAM_INT */);
				}
				else {
					ZVAL_LONG(type, 2 /* BIND_PARAM_STR */);
				}
				Z_SET_ISREF_P(value);
				PHALCON_CALL_METHOD(NULL, statement, "bindvalue", parameter, value, type);
				Z_UNSET_ISREF_P(value);
			}
		} else {
			Z_SET_ISREF_P(value);
			PHALCON_CALL_METHOD(NULL, statement, "bindvalue", parameter, value);
			Z_UNSET_ISREF_P(value);
		}

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	PHALCON_CALL_METHOD(NULL, statement, "execute");

	RETURN_CTOR(statement);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, query){

	zval *sql_statement, *bind_params = NULL, *bind_types = NULL;
	zval *events_manager, *event_name = NULL, *status = NULL, *pdo;
	zval *statement = NULL, *new_statement = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &sql_statement, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "db:beforeQuery", 1);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlStatement"), sql_statement, 18972457UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlVariables"), bind_params, 3213579853UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlBindTypes"), bind_types, 3288357222UL TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, bind_params);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_CALL_METHOD(&statement, pdo, "prepare", sql_statement);
		if (Z_TYPE_P(statement) == IS_OBJECT) {
			PHALCON_CALL_METHOD(&new_statement, this_ptr, "executeprepared", statement, bind_params, bind_types);
			PHALCON_CPY_WRT(statement, new_statement);
		}
	} else {
		PHALCON_CALL_METHOD(&statement, pdo, "query", sql_statement);
	}

	if (likely(Z_TYPE_P(statement) == IS_OBJECT)) {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "db:afterQuery", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, bind_params);
		}

		object_init_ex(return_value, phalcon_db_result_pdo_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", this_ptr, statement, sql_statement, bind_params, bind_types);
	
		RETURN_MM();
	}
	
	RETURN_CTOR(statement);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, execute){

	zval *sql_statement, *bind_params = NULL, *bind_types = NULL;
	zval *events_manager, *event_name = NULL, *status = NULL, *affected_rows = NULL;
	zval *pdo, *statement = NULL, *new_statement = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &sql_statement, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "db:beforeQuery", 1);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlStatement"), sql_statement, 18972457UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlVariables"), bind_params, 3213579853UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_sqlBindTypes"), bind_types, 3288357222UL TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, bind_params);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(&statement, pdo, "prepare", sql_statement);
		if (Z_TYPE_P(statement) == IS_OBJECT) {
			PHALCON_CALL_METHOD(&new_statement, this_ptr, "executeprepared", statement, bind_params, bind_types);
			PHALCON_CALL_METHOD(&affected_rows, new_statement, "rowcount");
		}
		else {
			PHALCON_INIT_VAR(affected_rows);
			ZVAL_LONG(affected_rows, 0);
		}
	} else {
		PHALCON_CALL_METHOD(&affected_rows, pdo, "exec", sql_statement);
	}
	
	if (Z_TYPE_P(affected_rows) == IS_LONG) {
		phalcon_update_property_this_quick(this_ptr, SL("_affectedRows"), affected_rows, 3226297793UL TSRMLS_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "db:afterQuery", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, bind_params);
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, affectedRows){


	RETURN_MEMBER_QUICK(this_ptr, "_affectedRows", 3226297793UL);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, close){

	zval *pdo;

	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (likely(Z_TYPE_P(pdo) == IS_OBJECT)) {
		phalcon_update_property_this(this_ptr, SL("_pdo"), PHALCON_GLOBAL(z_null) TSRMLS_CC);
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, escapeIdentifier){

	zval *identifier, *domain, *name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &identifier);
	
	if (Z_TYPE_P(identifier) == IS_ARRAY) { 
		PHALCON_OBS_VAR(domain);
		phalcon_array_fetch_long(&domain, identifier, 0, PH_NOISY);
	
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_long(&name, identifier, 1, PH_NOISY);
		PHALCON_CONCAT_SVSVS(return_value, "\"", domain, "\".\"", name, "\"");
		RETURN_MM();
	}
	PHALCON_CONCAT_SVS(return_value, "\"", identifier, "\"");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, escapeString){

	zval *str, *pdo;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &str);
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo, "quote", str);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, convertBoundParams){

	zval *sql, *params, *query_params, *placeholders;
	zval *matches, *set_order, *bind_pattern, *status = NULL;
	zval *place_match = NULL, *numeric_place = NULL, *value = NULL, *str_place = NULL;
	zval *question, *bound_sql = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &sql, &params);
	
	PHALCON_INIT_VAR(query_params);
	array_init(query_params);
	
	PHALCON_INIT_VAR(placeholders);
	array_init(placeholders);
	
	PHALCON_INIT_VAR(matches);
	
	PHALCON_INIT_VAR(set_order);
	ZVAL_LONG(set_order, 2);
	
	PHALCON_INIT_VAR(bind_pattern);
	ZVAL_STRING(bind_pattern, "/\\?([0-9]+)|:([a-zA-Z0-9_]+):/", 1);
	Z_SET_ISREF_P(matches);
	
	PHALCON_CALL_FUNCTION(&status, "preg_match_all", bind_pattern, sql, matches, set_order);
	Z_UNSET_ISREF_P(matches);
	if (zend_is_true(status)) {
	
		phalcon_is_iterable(matches, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(place_match);
	
			PHALCON_OBS_NVAR(numeric_place);
			phalcon_array_fetch_long(&numeric_place, place_match, 1, PH_NOISY);
			if (phalcon_array_isset(params, numeric_place)) {
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch(&value, params, numeric_place, PH_NOISY);
			} else {
				if (phalcon_array_isset_long(place_match, 2)) {
	
					PHALCON_OBS_NVAR(str_place);
					phalcon_array_fetch_long(&str_place, place_match, 2, PH_NOISY);
					if (phalcon_array_isset(params, str_place)) {
						PHALCON_OBS_NVAR(value);
						phalcon_array_fetch(&value, params, str_place, PH_NOISY);
					} else {
						PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Matched parameter wasn't found in parameters list");
						return;
					}
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Matched parameter wasn't found in parameters list");
					return;
				}
			}
	
			phalcon_array_append(&placeholders, value, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		PHALCON_INIT_VAR(question);
		ZVAL_STRING(question, "?", 1);
	
		PHALCON_CALL_FUNCTION(&bound_sql, "preg_replace", bind_pattern, question, sql);
	} else {
		PHALCON_CPY_WRT(bound_sql, sql);
	}
	
	array_init_size(return_value, 2);
	phalcon_array_update_string(&return_value, SL("sql"), bound_sql, PH_COPY);
	phalcon_array_update_string(&return_value, SL("params"), placeholders, PH_COPY);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, lastInsertId){

	zval *sequence_name = NULL, *pdo;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &sequence_name);
	
	if (!sequence_name) {
		sequence_name = PHALCON_GLOBAL(z_null);
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(pdo) != IS_OBJECT) {
		RETURN_MM_FALSE;
	}
	
	PHALCON_RETURN_CALL_METHOD(pdo, "lastinsertid", sequence_name);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, begin){

	zval *nesting = NULL, *pdo, *transaction_level, *events_manager = NULL;
	zval *event_name = NULL, *ntw_savepoint = NULL, *savepoint_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &nesting);
	
	if (!nesting) {
		nesting = PHALCON_GLOBAL(z_true);
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(pdo) != IS_OBJECT) {
		RETURN_MM_FALSE;
	}
	
	phalcon_property_incr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
	
	transaction_level = phalcon_fetch_nproperty_this(this_ptr, SL("_transactionLevel"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_LONG(transaction_level, 1)) {
	
		events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "db:beginTransaction", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
	
		PHALCON_RETURN_CALL_METHOD(pdo, "begintransaction");
		RETURN_MM();
	}

	if (zend_is_true(transaction_level)) {
		if (zend_is_true(nesting)) {
			PHALCON_CALL_METHOD(&ntw_savepoint, this_ptr, "isnestedtransactionswithsavepoints");
			if (zend_is_true(ntw_savepoint)) {
				events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);

				PHALCON_CALL_METHOD(&savepoint_name, this_ptr, "getnestedtransactionsavepointname");

				if (Z_TYPE_P(events_manager) == IS_OBJECT) {
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "db:createSavepoint", 1);
					PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, savepoint_name);
				}

				PHALCON_RETURN_CALL_METHOD(this_ptr, "createsavepoint", savepoint_name);
				RETURN_MM();
			}
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, rollback){

	zval *nesting = NULL, *pdo, *transaction_level, *events_manager = NULL;
	zval *event_name = NULL, *ntw_savepoint = NULL, *savepoint_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &nesting);
	
	if (!nesting) {
		nesting = PHALCON_GLOBAL(z_true);
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(pdo) != IS_OBJECT) {
		RETURN_MM_FALSE;
	}
	
	transaction_level = phalcon_fetch_nproperty_this(this_ptr, SL("_transactionLevel"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(transaction_level)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "There is no active transaction");
		return;
	}
	
	if (PHALCON_IS_LONG(transaction_level, 1)) {
		events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "db:rollbackTransaction", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
	
		phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
		PHALCON_RETURN_CALL_METHOD(pdo, "rollback");
		RETURN_MM();
	}

	if (zend_is_true(transaction_level)) {
		if (zend_is_true(nesting)) {
			PHALCON_CALL_METHOD(&ntw_savepoint, this_ptr, "isnestedtransactionswithsavepoints");
			if (zend_is_true(ntw_savepoint)) {

				events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);

				PHALCON_CALL_METHOD(&savepoint_name, this_ptr, "getnestedtransactionsavepointname");

				if (Z_TYPE_P(events_manager) == IS_OBJECT) {
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "db:rollbackSavepoint", 1);
					PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, savepoint_name);
				}

				phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
				PHALCON_RETURN_CALL_METHOD(this_ptr, "rollbacksavepoint", savepoint_name);
				RETURN_MM();
			}
		}
	}
	
	if (PHALCON_GT_LONG(transaction_level, 0)) {
		phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, commit){

	zval *nesting = NULL, *pdo, *transaction_level, *events_manager = NULL;
	zval *event_name = NULL, *ntw_savepoint = NULL, *savepoint_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &nesting);
	
	if (!nesting) {
		nesting = PHALCON_GLOBAL(z_true);
	}
	
	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(pdo) != IS_OBJECT) {
		RETURN_MM_FALSE;
	}
	
	transaction_level = phalcon_fetch_nproperty_this(this_ptr, SL("_transactionLevel"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(transaction_level)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "There is no active transaction");
		return;
	}
	
	if (PHALCON_IS_LONG(transaction_level, 1)) {
		events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "db:commitTransaction", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
	
		phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
		PHALCON_RETURN_CALL_METHOD(pdo, "commit");
		RETURN_MM();
	}

	if (zend_is_true(transaction_level)) {
		if (zend_is_true(nesting)) {

			PHALCON_CALL_METHOD(&ntw_savepoint, this_ptr, "isnestedtransactionswithsavepoints");
			if (zend_is_true(ntw_savepoint)) {
				events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);

				PHALCON_CALL_METHOD(&savepoint_name, this_ptr, "getnestedtransactionsavepointname");

				if (Z_TYPE_P(events_manager) == IS_OBJECT) {
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "db:releaseSavepoint", 1);
					PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, savepoint_name);
				}

				phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
				PHALCON_RETURN_CALL_METHOD(this_ptr, "releasesavepoint", savepoint_name);
				RETURN_MM();
			}
		}
	}
	
	if (PHALCON_GT_LONG(transaction_level, 0)) {
		phalcon_property_decr(this_ptr, SL("_transactionLevel") TSRMLS_CC);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, getTransactionLevel){


	RETURN_MEMBER_QUICK(this_ptr, "_transactionLevel", 2789346594UL);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, isUnderTransaction){

	zval *pdo;

	PHALCON_MM_GROW();

	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	if (likely(Z_TYPE_P(pdo) == IS_OBJECT)) {
		PHALCON_RETURN_CALL_METHOD(pdo, "intransaction");
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo, getInternalHandler){

	zval *pdo;

	pdo = phalcon_fetch_nproperty_this(this_ptr, SL("_pdo"), PH_NOISY TSRMLS_CC);
	RETURN_ZVAL(pdo, 1, 0);
}






zend_class_entry *phalcon_db_adapter_pdo_mysql_ce;

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Mysql, escapeIdentifier);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Mysql, describeColumns);

static const zend_function_entry phalcon_db_adapter_pdo_mysql_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter_Pdo_Mysql, escapeIdentifier, arginfo_phalcon_db_adapterinterface_escapeidentifier, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Mysql, describeColumns, arginfo_phalcon_db_adapterinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Mysql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Mysql, db_adapter_pdo_mysql, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_mysql_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_mysql_ce, SL("_type"), "mysql", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_mysql_ce, SL("_dialectType"), "mysql", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_mysql_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Mysql, escapeIdentifier){

	zval *identifier, *domain, *name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &identifier);
	
	if (Z_TYPE_P(identifier) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(domain);
		phalcon_array_fetch_long(&domain, identifier, 0, PH_NOISY);
	
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_long(&name, identifier, 1, PH_NOISY);
		if (PHALCON_GLOBAL(db).escape_identifiers) {
			PHALCON_CONCAT_SVSVS(return_value, "`", domain, "`.`", name, "`");
			RETURN_MM();
		}
	
		PHALCON_CONCAT_VSV(return_value, domain, ".", name);
	
		RETURN_MM();
	}
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_CONCAT_SVS(return_value, "`", identifier, "`");
		RETURN_MM();
	}
	
	RETURN_CTOR(identifier);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Mysql, describeColumns){

	zval *table, *schema = NULL, *dialect, *sql = NULL, *fetch_num;
	zval *describe = NULL, *old_column = NULL, *size_pattern, *columns;
	zval *field = NULL, *definition = NULL, *column_type = NULL, *matches = NULL;
	zval *pos = NULL, *match_one = NULL, *match_two = NULL, *attribute = NULL, *column_name = NULL;
	zval *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describecolumns", table, schema);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(old_column);
	
	PHALCON_INIT_VAR(size_pattern);
	ZVAL_STRING(size_pattern, "#\\(([0-9]++)(?:,\\s*([0-9]++))?\\)#", 1);
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init_size(definition, 1);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_OBS_NVAR(column_type);
		phalcon_array_fetch_long(&column_type, field, 1, PH_NOISY);
	
		while (1) {

			if (phalcon_memnstr_str(column_type, SL("point"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("enum"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 5, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("int"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 0, 0);
				phalcon_array_update_string(&definition, SL("isNumeric"), PHALCON_GLOBAL(z_true), PH_COPY);
				phalcon_array_update_string_long(&definition, SL("bindType"), 1, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("varchar"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("datetime"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 4, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("decimal"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 3, 0);
				phalcon_array_update_string(&definition, SL("isNumeric"), PHALCON_GLOBAL(z_true), PH_COPY);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("char"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 5, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("date"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 1, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("timestamp"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 1, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("text"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("float"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 7, 0);
				phalcon_array_update_string(&definition, SL("isNumeric"), PHALCON_GLOBAL(z_true), PH_COPY);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, 0);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("double"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 9, 0);
				phalcon_array_update_string(&definition, SL("isNumeric"), PHALCON_GLOBAL(z_true), PH_COPY);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, 0);
				break;
			}

			phalcon_array_update_string_long(&definition, SL("type"), 2, 0);
			break;
		}
	
		if (phalcon_memnstr_str(column_type, SL("("))) {
	
			PHALCON_INIT_NVAR(matches);
	
			PHALCON_INIT_NVAR(pos);
			RETURN_MM_ON_FAILURE(phalcon_preg_match(pos, size_pattern, column_type, matches TSRMLS_CC));

			if (zend_is_true(pos)) {
				if (phalcon_array_isset_long(matches, 1)) {
					PHALCON_OBS_NVAR(match_one);
					phalcon_array_fetch_long(&match_one, matches, 1, PH_NOISY);
					phalcon_array_update_string(&definition, SL("size"), match_one, PH_COPY | PH_SEPARATE);
				}
				if (phalcon_array_isset_long(matches, 2)) {
					PHALCON_OBS_NVAR(match_two);
					phalcon_array_fetch_long(&match_two, matches, 2, PH_NOISY);
					phalcon_array_update_string(&definition, SL("scale"), match_two, PH_COPY | PH_SEPARATE);
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned"))) {
			phalcon_array_update_string(&definition, SL("unsigned"), PHALCON_GLOBAL(z_true), PH_COPY);
		}
	
		if (!zend_is_true(old_column)) {
			phalcon_array_update_string(&definition, SL("first"), PHALCON_GLOBAL(z_true), PH_COPY);
		} else {
			phalcon_array_update_string(&definition, SL("after"), old_column, PH_COPY);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 3, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "PRI")) {
			phalcon_array_update_string(&definition, SL("primary"), PHALCON_GLOBAL(z_true), PH_COPY);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 2, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "NO")) {
			phalcon_array_update_string(&definition, SL("notNull"), PHALCON_GLOBAL(z_true), PH_COPY);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 5, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "auto_increment")) {
			phalcon_array_update_string(&definition, SL("autoIncrement"), PHALCON_GLOBAL(z_true), PH_COPY);
		}
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, field, 0, PH_NOISY);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD(NULL, column, "__construct", column_name, definition);
	
		phalcon_array_append(&columns, column, PH_SEPARATE);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(columns);
}







zend_class_entry *phalcon_db_adapter_pdo_oracle_ce;

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, connect);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, describeColumns);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, lastInsertId);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, useExplicitIdValue);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, getDefaultIdValue);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, supportSequences);

static const zend_function_entry phalcon_db_adapter_pdo_oracle_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, connect, arginfo_phalcon_db_adapterinterface_connect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, describeColumns, arginfo_phalcon_db_adapterinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, lastInsertId, arginfo_phalcon_db_adapterinterface_lastinsertid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, useExplicitIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, getDefaultIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Oracle, supportSequences, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Oracle){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Oracle, db_adapter_pdo_oracle, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_oracle_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_oracle_ce, SL("_type"), "oci", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_oracle_ce, SL("_dialectType"), "oracle", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_oracle_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, connect){

	zval *descriptor = NULL, *startup, *value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &descriptor);
	
	if (!descriptor) {
		PHALCON_INIT_VAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_OBS_NVAR(descriptor);
		phalcon_read_property_this(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_db_adapter_pdo_oracle_ce, this_ptr, "connect", descriptor);
	
	if (phalcon_array_isset_quick_string(descriptor, SS("startup"), 1765694744UL)) {
	
		PHALCON_OBS_VAR(startup);
		phalcon_array_fetch_quick_string(&startup, descriptor, SS("startup"), 1765694744UL, PH_NOISY);
		if (Z_TYPE_P(startup) == IS_ARRAY) { 
	
			phalcon_is_iterable(startup, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(value);
	
				PHALCON_CALL_METHOD(NULL, this_ptr, "execute", value);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, describeColumns){

	zval *table, *schema = NULL, *columns, *dialect, *sql = NULL, *fetch_num;
	zval *describe = NULL, *old_column = NULL, *field = NULL, *definition = NULL;
	zval *column_size = NULL, *column_precision = NULL, *column_scale = NULL;
	zval *column_type = NULL, *attribute = NULL, *column_name = NULL;
	zval *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describecolumns", table, schema);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(old_column);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init_size(definition, 1);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_OBS_NVAR(column_size);
		phalcon_array_fetch_long(&column_size, field, 2, PH_NOISY);
	
		PHALCON_OBS_NVAR(column_precision);
		phalcon_array_fetch_long(&column_precision, field, 3, PH_NOISY);
	
		PHALCON_OBS_NVAR(column_scale);
		phalcon_array_fetch_long(&column_scale, field, 4, PH_NOISY);
	
		PHALCON_OBS_NVAR(column_type);
		phalcon_array_fetch_long(&column_type, field, 1, PH_NOISY);
	
		while (1) {
			if (phalcon_memnstr_str(column_type, SL("NUMBER"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), column_precision, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("scale"), column_scale, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("TINYINT(1)"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 8, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 5, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("INTEGER"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), column_precision, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("FLOAT"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), column_size, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("scale"), column_scale, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("TIMESTAMP"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("RAW"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("BLOB"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("CLOB"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("VARCHAR2"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), column_size, PH_COPY | PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("CHAR"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), column_size, PH_COPY | PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("text"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
				break;
			}

			phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
			break;
		}
	
		if (Z_TYPE_P(old_column) == IS_NULL) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE);
		} else {
			phalcon_array_update_string(&definition, SL("after"), old_column, PH_COPY | PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 6, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "P")) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 5, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "N")) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, field, 0, PH_NOISY);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD(NULL, column, "__construct", column_name, definition);
	
		phalcon_array_append(&columns, column, PH_SEPARATE);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(columns);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, lastInsertId){

	zval *sequence_name = NULL, *sql, *fetch_num, *ret = NULL, *insert_id;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &sequence_name);
	
	if (!sequence_name) {
		sequence_name = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "SELECT ", sequence_name, ".CURRVAL FROM dual");
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&ret, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_OBS_VAR(insert_id);
	phalcon_array_fetch_long(&insert_id, ret, 0, PH_NOISY);
	RETURN_CCTOR(insert_id);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, useExplicitIdValue){


	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, getDefaultIdValue){

	zval *null_value;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(null_value);
	ZVAL_STRING(null_value, "default", 1);
	object_init_ex(return_value, phalcon_db_rawvalue_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", null_value);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Oracle, supportSequences){


	RETURN_TRUE;
}








zend_class_entry *phalcon_db_adapter_pdo_postgresql_ce;

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, connect);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, describeColumns);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, useExplicitIdValue);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, getDefaultIdValue);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, supportSequences);

static const zend_function_entry phalcon_db_adapter_pdo_postgresql_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter_Pdo_Postgresql, connect, arginfo_phalcon_db_adapterinterface_connect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Postgresql, describeColumns, arginfo_phalcon_db_adapterinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Postgresql, useExplicitIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Postgresql, getDefaultIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Postgresql, supportSequences, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Postgresql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Postgresql, db_adapter_pdo_postgresql, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_postgresql_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_postgresql_ce, SL("_type"), "pgsql", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_postgresql_ce, SL("_dialectType"), "postgresql", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_postgresql_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, connect){

	zval *descriptor = NULL, *schema = NULL, *sql, *password;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &descriptor);
	
	if (!descriptor) {
		PHALCON_INIT_VAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_OBS_NVAR(descriptor);
		phalcon_read_property_this(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY TSRMLS_CC);
	}
	
	if (phalcon_array_isset_quick_string(descriptor, SS("schema"), 2259341622UL)) {
		PHALCON_OBS_VAR(schema);
		phalcon_array_fetch_quick_string(&schema, descriptor, SS("schema"), 2259341622UL, PH_NOISY);
		phalcon_array_unset_string(&descriptor, SS("schema"), PH_SEPARATE);
	}
	else {
		PHALCON_INIT_VAR(schema);
	}

	if (phalcon_array_isset_string_fetch(&password, descriptor, SS("password"))) {
		/* There is a bug in pdo_pgsql driver when the password is empty,
		 * the driver tries to access invalid memory:
		 *
		 * if (dbh->password[0] != '\'' && dbh->password[strlen(dbh->password) - 1] != '\'')
		 *
		 * To avoid this we set the password to null
		 */
		if (Z_TYPE_P(password) == IS_STRING && Z_STRLEN_P(password) == 0) {
			phalcon_array_update_string(&descriptor, SL("password"), PHALCON_GLOBAL(z_null), PH_SEPARATE | PH_COPY);
		}
	}

	
	PHALCON_CALL_PARENT(NULL, phalcon_db_adapter_pdo_postgresql_ce, this_ptr, "connect", descriptor);
	
	if (Z_TYPE_P(schema) == IS_STRING) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SET search_path TO '", schema, "'");
		PHALCON_CALL_METHOD(NULL, this_ptr, "execute", sql);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, describeColumns){

	zval *table, *schema = NULL, *columns, *dialect, *sql = NULL, *fetch_num;
	zval *describe = NULL, *old_column = NULL, *field = NULL, *definition = NULL;
	zval *char_size = NULL, *numeric_size = NULL, *numeric_scale = NULL, *column_type = NULL;
	zval *attribute = NULL, *column_name = NULL, *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describecolumns", table, schema);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(old_column);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init_size(definition, 1);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_OBS_NVAR(char_size);
		phalcon_array_fetch_long(&char_size, field, 2, PH_NOISY);
	
		PHALCON_OBS_NVAR(numeric_size);
		phalcon_array_fetch_long(&numeric_size, field, 3, PH_NOISY);

		PHALCON_OBS_NVAR(numeric_scale); 
		phalcon_array_fetch_long(&numeric_scale, field, 4, PH_NOISY);
	
		PHALCON_OBS_NVAR(column_type);
		phalcon_array_fetch_long(&column_type, field, 1, PH_NOISY);
	
		while (1) {
			if (phalcon_memnstr_str(column_type, SL("smallint(1)"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 8, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 5, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("int"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), numeric_size, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("varying"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), char_size, PH_COPY | PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("date"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("size"), 0, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("numeric"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), numeric_size, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("scale"), numeric_scale, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("char"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), char_size, PH_COPY | PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("timestamp"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 4, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("size"), 0, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("text"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), char_size, PH_COPY | PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("float"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE);
				phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
				phalcon_array_update_string(&definition, SL("size"), numeric_size, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("bool"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 8, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("size"), 0, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("bindType"), 5, PH_SEPARATE);
				break;
			}

			if (phalcon_memnstr_str(column_type, SL("uuid"))) {
				phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE);
				phalcon_array_update_string_long(&definition, SL("size"), 36, PH_SEPARATE);
				break;
			}

			phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
			break;
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned"))) {
			phalcon_array_update_string_bool(&definition, SL("unsigned"), 1, PH_SEPARATE);
		}
	
		if (Z_TYPE_P(old_column) == IS_NULL) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE);
		} else {
			phalcon_array_update_string(&definition, SL("after"), old_column, PH_COPY | PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 6, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "PRI")) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 5, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "NO")) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 7, PH_NOISY);
		if (PHALCON_IS_STRING(attribute, "auto_increment")) {
			phalcon_array_update_string_bool(&definition, SL("autoIncrement"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, field, 0, PH_NOISY);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD(NULL, column, "__construct", column_name, definition);
	
		phalcon_array_append(&columns, column, PH_SEPARATE);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(columns);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, useExplicitIdValue){


	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, getDefaultIdValue){

	zval *null_value, *default_value;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(null_value);
	ZVAL_STRING(null_value, "default", 1);
	
	PHALCON_INIT_VAR(default_value);
	object_init_ex(default_value, phalcon_db_rawvalue_ce);
	PHALCON_CALL_METHOD(NULL, default_value, "__construct", null_value);
	
	RETURN_CTOR(default_value);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Postgresql, supportSequences){


	RETURN_TRUE;
}







zend_class_entry *phalcon_db_adapter_pdo_sqlite_ce;

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, connect);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeColumns);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeIndexes);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeReferences);
static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, useExplicitIdValue);

static const zend_function_entry phalcon_db_adapter_pdo_sqlite_method_entry[] = {
	PHP_ME(Phalcon_Db_Adapter_Pdo_Sqlite, connect, arginfo_phalcon_db_adapterinterface_connect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Sqlite, describeColumns, arginfo_phalcon_db_adapterinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Sqlite, describeIndexes, arginfo_phalcon_db_adapterinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Sqlite, describeReferences, arginfo_phalcon_db_adapterinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Adapter_Pdo_Sqlite, useExplicitIdValue, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Adapter_Pdo_Sqlite){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Adapter\\Pdo, Sqlite, db_adapter_pdo_sqlite, phalcon_db_adapter_pdo_ce, phalcon_db_adapter_pdo_sqlite_method_entry, 0);

	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("_type"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_db_adapter_pdo_sqlite_ce, SL("_dialectType"), "sqlite", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_adapter_pdo_sqlite_ce TSRMLS_CC, 1, phalcon_db_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, connect){

	zval *descriptor = NULL, *dbname;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &descriptor);
	
	if (!descriptor) {
		PHALCON_INIT_VAR(descriptor);
	} else {
		PHALCON_SEPARATE_PARAM(descriptor);
	}
	
	if (!zend_is_true(descriptor)) {
		PHALCON_OBS_NVAR(descriptor);
		phalcon_read_property_this(&descriptor, this_ptr, SL("_descriptor"), PH_NOISY TSRMLS_CC);
	}
	if (!phalcon_array_isset_quick_string(descriptor, SS("dbname"), 35027788UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "dbname must be specified");
		return;
	} else {
		PHALCON_OBS_VAR(dbname);
		phalcon_array_fetch_quick_string(&dbname, descriptor, SS("dbname"), 35027788UL, PH_NOISY);
		phalcon_array_update_string(&descriptor, SL("dsn"), dbname, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_db_adapter_pdo_sqlite_ce, this_ptr, "connect", descriptor);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeColumns){

	zval *table, *schema = NULL, *columns, *dialect, *size_pattern;
	zval *sql = NULL, *fetch_num, *describe = NULL, *old_column = NULL, *field = NULL;
	zval *definition = NULL, *column_type = NULL, *pos = NULL, *attribute = NULL;
	zval *matches = NULL, *match_one = NULL, *match_two = NULL, *column_name = NULL, *column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(columns);
	array_init(columns);
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(size_pattern);
	ZVAL_STRING(size_pattern, "#\\(([0-9]++)(?:,\\s*([0-9]++))?\\)#", 1);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describecolumns", table, schema);

	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(old_column);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);			
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		PHALCON_INIT_NVAR(definition);
		array_init_size(definition, 1);
		add_assoc_long_ex(definition, SS("bindType"), 2);
	
		PHALCON_OBS_NVAR(column_type);
		phalcon_array_fetch_long(&column_type, field, 2, PH_NOISY);
		
	while (1) {

		if (phalcon_memnstr_str(column_type, SL("tinyint(1)"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 8, PH_SEPARATE);
			phalcon_array_update_string_long(&definition, SL("bindType"), 5, PH_SEPARATE);
			PHALCON_INIT_NVAR(column_type);
			ZVAL_STRING(column_type, "boolean", 1); // Change column type to skip size check.
			break;
		}

		PHALCON_INIT_NVAR(pos);
		phalcon_fast_stripos_str(pos, column_type, SL("int"));
		if (PHALCON_IS_NOT_FALSE(pos)) {
			phalcon_array_update_string_long(&definition, SL("type"), 0, PH_SEPARATE);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
			phalcon_array_update_string_long(&definition, SL("bindType"), 1, PH_SEPARATE);

			PHALCON_OBS_NVAR(attribute);
			phalcon_array_fetch_long(&attribute, field, 5, PH_NOISY);

			if (zend_is_true(attribute)) {
				phalcon_array_update_string_bool(&definition, SL("autoIncrement"), 1, PH_SEPARATE);
			}
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("varchar"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("date"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("timestamp"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 1, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("decimal"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 3, PH_SEPARATE);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
			phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("char"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("datetime"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 4, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("text"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 6, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("float"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 7, PH_SEPARATE);
			phalcon_array_update_string_bool(&definition, SL("isNumeric"), 1, PH_SEPARATE);
			phalcon_array_update_string_long(&definition, SL("bindType"), 32, PH_SEPARATE);
			break;
		}

		if (phalcon_memnstr_str(column_type, SL("enum"))) {
			phalcon_array_update_string_long(&definition, SL("type"), 5, PH_SEPARATE);
			break;
		}

		phalcon_array_update_string_long(&definition, SL("type"), 2, PH_SEPARATE);
		break;
	}
	
		if (phalcon_memnstr_str(column_type, SL("("))) {
	
			PHALCON_INIT_NVAR(matches);
	
			PHALCON_INIT_NVAR(pos);
			RETURN_MM_ON_FAILURE(phalcon_preg_match(pos, size_pattern, column_type, matches TSRMLS_CC));
	
			if (zend_is_true(pos)) {
				if (phalcon_array_isset_long(matches, 1)) {
					PHALCON_OBS_NVAR(match_one);
					phalcon_array_fetch_long(&match_one, matches, 1, PH_NOISY);
					phalcon_array_update_string(&definition, SL("size"), match_one, PH_COPY | PH_SEPARATE);
				}
				if (phalcon_array_isset_long(matches, 2)) {
					PHALCON_OBS_NVAR(match_two);
					phalcon_array_fetch_long(&match_two, matches, 2, PH_NOISY);
					phalcon_array_update_string(&definition, SL("scale"), match_two, PH_COPY | PH_SEPARATE);
				}
			}
		}
	
		if (phalcon_memnstr_str(column_type, SL("unsigned"))) {
			phalcon_array_update_string_bool(&definition, SL("unsigned"), 1, PH_SEPARATE);
		}
	
		if (!zend_is_true(old_column)) {
			phalcon_array_update_string_bool(&definition, SL("first"), 1, PH_SEPARATE);
		} else {
			phalcon_array_update_string(&definition, SL("after"), old_column, PH_COPY | PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 5, PH_NOISY);
		if (zend_is_true(attribute)) {
			phalcon_array_update_string_bool(&definition, SL("primary"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(attribute);
		phalcon_array_fetch_long(&attribute, field, 3, PH_NOISY);
		if (zend_is_true(attribute)) {
			phalcon_array_update_string_bool(&definition, SL("notNull"), 1, PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(column_name);
		phalcon_array_fetch_long(&column_name, field, 1, PH_NOISY);
	
		PHALCON_INIT_NVAR(column);
		object_init_ex(column, phalcon_db_column_ce);
		PHALCON_CALL_METHOD(NULL, column, "__construct", column_name, definition);
	
		phalcon_array_append(&columns, column, PH_SEPARATE);
		PHALCON_CPY_WRT(old_column, column_name);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(columns);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeIndexes){

	zval *table, *schema = NULL, *dialect, *fetch_num, *sql = NULL, *describe = NULL;
	zval *indexes, *index = NULL, *key_name = NULL, *sql_index_describe = NULL;
	zval *describe_index = NULL, *index_column = NULL, *column_name = NULL;
	zval *index_objects, *index_columns = NULL, *name = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describeindexes", table, schema);
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(indexes);
	array_init(indexes);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(index);
	
		PHALCON_OBS_NVAR(key_name);
		phalcon_array_fetch_long(&key_name, index, 1, PH_NOISY);
	
		PHALCON_CALL_METHOD(&sql_index_describe, dialect, "describeindex", key_name);
		PHALCON_CALL_METHOD(&describe_index, this_ptr, "fetchall", sql_index_describe, fetch_num);
	
		phalcon_is_iterable(describe_index, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(index_column);
	
			PHALCON_OBS_NVAR(column_name);
			phalcon_array_fetch_long(&column_name, index_column, 2, PH_NOISY);
			phalcon_array_append_multi_2(&indexes, key_name, column_name, 0);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(index_objects);
	array_init(index_objects);
	
	phalcon_is_iterable(indexes, &ah2, &hp2, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah2, hp2);
		PHALCON_GET_HVALUE(index_columns);
	
		PHALCON_INIT_NVAR(index);
		object_init_ex(index, phalcon_db_index_ce);
		PHALCON_CALL_METHOD(NULL, index, "__construct", name, index_columns);
	
		phalcon_array_update_zval(&index_objects, name, index, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah2, &hp2);
	}
	
	RETURN_CTOR(index_objects);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, describeReferences){

	zval *table, *schema = NULL, *dialect, *sql = NULL, *fetch_num, *describe = NULL;
	zval *reference_objects, *reference_describe = NULL;
	zval *number = NULL, *constraint_name = NULL, *referenced_table = NULL;
	zval *from = NULL, *to = NULL, *columns = NULL, *referenced_columns = NULL;
	zval *reference_array = NULL, *reference = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		schema = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(dialect);
	phalcon_read_property_this(&dialect, this_ptr, SL("_dialect"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&sql, dialect, "describereferences", table, schema);
	
	PHALCON_INIT_VAR(fetch_num);
	ZVAL_LONG(fetch_num, PDO_FETCH_NUM);
	
	PHALCON_CALL_METHOD(&describe, this_ptr, "fetchall", sql, fetch_num);
	
	PHALCON_INIT_VAR(reference_objects);
	array_init(reference_objects);
	
	phalcon_is_iterable(describe, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(number, ah0, hp0);
		PHALCON_GET_HVALUE(reference_describe);
	
		PHALCON_INIT_NVAR(constraint_name);
		PHALCON_CONCAT_SV(constraint_name, "foreign_key_", number);
	
		PHALCON_OBS_NVAR(referenced_table);
		phalcon_array_fetch_long(&referenced_table, reference_describe, 2, PH_NOISY);
	
		PHALCON_OBS_NVAR(from);
		phalcon_array_fetch_long(&from, reference_describe, 3, PH_NOISY);
	
		PHALCON_OBS_NVAR(to);
		phalcon_array_fetch_long(&to, reference_describe, 4, PH_NOISY);
	
		PHALCON_INIT_NVAR(columns);
		array_init_size(columns, 1);
		phalcon_array_append(&columns, from, PH_SEPARATE);
	
		PHALCON_INIT_NVAR(referenced_columns);
		array_init_size(referenced_columns, 1);
		phalcon_array_append(&referenced_columns, to, PH_SEPARATE);
	
		PHALCON_INIT_NVAR(reference_array);
		array_init_size(reference_array, 4);
		add_assoc_null_ex(reference_array, SS("referencedSchema"));
		phalcon_array_update_string(&reference_array, SL("referencedTable"), referenced_table, PH_COPY | PH_SEPARATE);
		phalcon_array_update_string(&reference_array, SL("columns"), columns, PH_COPY | PH_SEPARATE);
		phalcon_array_update_string(&reference_array, SL("referencedColumns"), referenced_columns, PH_COPY | PH_SEPARATE);
	
		PHALCON_INIT_NVAR(reference);
		object_init_ex(reference, phalcon_db_reference_ce);
		PHALCON_CALL_METHOD(NULL, reference, "__construct", constraint_name, reference_array);
	
		phalcon_array_update_zval(&reference_objects, constraint_name, reference, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(reference_objects);
}

static PHP_METHOD(Phalcon_Db_Adapter_Pdo_Sqlite, useExplicitIdValue){


	RETURN_TRUE;
}







zend_class_entry *phalcon_db_dialect_mysql_ce;

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnDefinition);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, modifyColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, _getTableOptions);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, createTable);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropTable);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, createView);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropView);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableExists);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, viewExists);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeColumns);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, listTables);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, listViews);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeIndexes);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeReferences);
static PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableOptions);

static const zend_function_entry phalcon_db_dialect_mysql_method_entry[] = {
	PHP_ME(Phalcon_Db_Dialect_Mysql, getColumnDefinition, arginfo_phalcon_db_dialectinterface_getcolumndefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, addColumn, arginfo_phalcon_db_dialectinterface_addcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, modifyColumn, arginfo_phalcon_db_dialectinterface_modifycolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropColumn, arginfo_phalcon_db_dialectinterface_dropcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, addIndex, arginfo_phalcon_db_dialectinterface_addindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropIndex, arginfo_phalcon_db_dialectinterface_dropindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, addPrimaryKey, arginfo_phalcon_db_dialectinterface_addprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropPrimaryKey, arginfo_phalcon_db_dialectinterface_dropprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, addForeignKey, arginfo_phalcon_db_dialectinterface_addforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropForeignKey, arginfo_phalcon_db_dialectinterface_dropforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, _getTableOptions, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Db_Dialect_Mysql, createTable, arginfo_phalcon_db_dialectinterface_createtable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropTable, arginfo_phalcon_db_dialectinterface_droptable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, createView, arginfo_phalcon_db_dialectinterface_createview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, dropView, arginfo_phalcon_db_dialectinterface_dropview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, tableExists, arginfo_phalcon_db_dialectinterface_tableexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, viewExists, arginfo_phalcon_db_dialectinterface_viewexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, describeColumns, arginfo_phalcon_db_dialectinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, listTables, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, listViews, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, describeIndexes, arginfo_phalcon_db_dialectinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, describeReferences, arginfo_phalcon_db_dialectinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Mysql, tableOptions, arginfo_phalcon_db_dialectinterface_tableoptions, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Mysql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Mysql, db_dialect_mysql, phalcon_db_dialect_ce, phalcon_db_dialect_mysql_method_entry, 0);

	zend_declare_property_string(phalcon_db_dialect_mysql_ce, SL("_escapeChar"), "`", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_dialect_mysql_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, getColumnDefinition){

	zval *column, *size = NULL, *column_type = NULL, *column_sql;
	zval *is_unsigned = NULL, *scale = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	PHALCON_VERIFY_INTERFACE_EX(column, phalcon_db_columninterface_ce, phalcon_db_exception_ce, 1);
	
	PHALCON_CALL_METHOD(&size, column, "getsize");
	PHALCON_CALL_METHOD(&column_type, column, "gettype");

	PHALCON_INIT_VAR(column_sql);
	switch (phalcon_get_intval(column_type)) {
		case 0:
			if (Z_LVAL_P(size) > 0) {
				PHALCON_CONCAT_SVS(column_sql, "INT(", size, ")");
			}
			else {
				ZVAL_STRING(column_sql, "INT", 1);
			}
	
			PHALCON_CALL_METHOD(&is_unsigned, column, "isunsigned");
			if (zend_is_true(is_unsigned)) {
				phalcon_concat_self_str(&column_sql, SL(" UNSIGNED") TSRMLS_CC);
			}
	
			break;
	
		case 1:
			ZVAL_STRING(column_sql, "DATE", 1);
			break;
	
		case 2:
			PHALCON_CONCAT_SVS(column_sql, "VARCHAR(", size, ")");
			break;
	
		case 3:
			PHALCON_CALL_METHOD(&scale, column, "getscale");
			PHALCON_CONCAT_SVSVS(column_sql, "DECIMAL(", size, ",", scale, ")");
	
			PHALCON_CALL_METHOD(&is_unsigned, column, "isunsigned");
			if (zend_is_true(is_unsigned)) {
				phalcon_concat_self_str(&column_sql, SL(" UNSIGNED") TSRMLS_CC);
			}
	
			break;
	
		case 4:
			ZVAL_STRING(column_sql, "DATETIME", 1);
			break;
	
		case 5:
			PHALCON_CONCAT_SVS(column_sql, "CHAR(", size, ")");
			break;
	
		case 6:
			ZVAL_STRING(column_sql, "TEXT", 1);
			break;
	
		case 7:
			ZVAL_STRING(column_sql, "FLOAT", 1);
	
			PHALCON_CALL_METHOD(&scale, column, "getscale");
			if (zend_is_true(size)) {
				PHALCON_SCONCAT_SV(column_sql, "(", size);
				if (zend_is_true(scale)) {
					PHALCON_SCONCAT_SVS(column_sql, ",", scale, ")");
				} else {
					phalcon_concat_self_str(&column_sql, SL(")") TSRMLS_CC);
				}
			}
	
			PHALCON_CALL_METHOD(&is_unsigned, column, "isunsigned");
			if (zend_is_true(is_unsigned)) {
				phalcon_concat_self_str(&column_sql, SL(" UNSIGNED") TSRMLS_CC);
			}
	
			break;
	
		case 8:
			ZVAL_STRING(column_sql, "TINYINT(1)", 1);
			break;
	
		default:
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized MySQL data type");
			return;
	
	}
	
	RETURN_CTOR(column_sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addColumn){

	zval *table_name, *schema_name, *column, *sql = NULL, *name = NULL;
	zval *column_definition = NULL, *is_not_null = NULL, *is_autoincrement = NULL, *is_first = NULL;
	zval *after_position = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_VERIFY_INTERFACE_EX(column, phalcon_db_columninterface_ce, phalcon_db_exception_ce, 1);

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD ");
	}
	
	PHALCON_CALL_METHOD(&name, column, "getname");
	PHALCON_CALL_METHOD(&column_definition, this_ptr, "getcolumndefinition", column);
	PHALCON_SCONCAT_SVSV(sql, "`", name, "` ", column_definition);
	
	PHALCON_CALL_METHOD(&is_not_null, column, "isnotnull");
	if (zend_is_true(is_not_null)) {
		phalcon_concat_self_str(&sql, SL(" NOT NULL") TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(&is_autoincrement, column, "isautoincrement");
	if (zend_is_true(is_autoincrement)) {
		phalcon_concat_self_str(&sql, SL(" PRIMARY KEY AUTO_INCREMENT") TSRMLS_CC);
	}

	PHALCON_CALL_METHOD(&is_first, column, "isfirst");
	if (zend_is_true(is_first)) {
		phalcon_concat_self_str(&sql, SL(" FIRST") TSRMLS_CC);
	} else {
		PHALCON_CALL_METHOD(&after_position, column, "getafterposition");
		if (zend_is_true(after_position)) {
			PHALCON_SCONCAT_SV(sql, " AFTER ", after_position);
		}
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, modifyColumn){

	zval *table_name, *schema_name, *column, *sql = NULL, *name = NULL;
	zval *column_definition = NULL, *is_not_null = NULL, *is_autoincrement = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_VERIFY_INTERFACE_EX(column, phalcon_db_columninterface_ce, phalcon_db_exception_ce, 1);

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` MODIFY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` MODIFY ");
	}
	
	PHALCON_CALL_METHOD(&name, column, "getname");
	
	PHALCON_CALL_METHOD(&column_definition, this_ptr, "getcolumndefinition", column);
	PHALCON_SCONCAT_SVSV(sql, "`", name, "` ", column_definition);
	
	PHALCON_CALL_METHOD(&is_not_null, column, "isnotnull");
	if (zend_is_true(is_not_null)) {
		phalcon_concat_self_str(&sql, SL(" NOT NULL") TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(&is_autoincrement, column, "isautoincrement");
	if (zend_is_true(is_autoincrement)) {
		phalcon_concat_self_str(&sql, SL(" AUTO_INCREMENT") TSRMLS_CC);
	}

	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropColumn){

	zval *table_name, *schema_name, *column_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column_name);
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP COLUMN ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP COLUMN ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", column_name, "`");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addIndex){

	zval *table_name, *schema_name, *index, *sql = NULL, *columns = NULL;
	zval *quoted_column_list = NULL, *name = NULL;
	zval *index_type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_VERIFY_INTERFACE_EX(index, phalcon_db_indexinterface_ce, phalcon_db_exception_ce, 1);

	PHALCON_CALL_METHOD(&index_type, index, "gettype");

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		if (index_type && Z_TYPE_P(index_type) == IS_STRING && Z_STRLEN_P(index_type) > 0) {
			PHALCON_CONCAT_SVSVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD ", index_type, " INDEX ");
		} else {
			PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD INDEX ");
		}
	} else if (index_type && Z_TYPE_P(index_type) == IS_STRING && Z_STRLEN_P(index_type) > 0) {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", table_name, "` ADD ", index_type, " INDEX ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD INDEX ");
	}
	
	PHALCON_CALL_METHOD(&columns, index, "getcolumns");
	PHALCON_CALL_METHOD(&quoted_column_list, this_ptr, "getcolumnlist", columns);
	PHALCON_CALL_METHOD(&name, index, "getname");
	PHALCON_SCONCAT_SVSVS(sql, "`", name, "` (", quoted_column_list, ")");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropIndex){

	zval *table_name, *schema_name, *index_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index_name);
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP INDEX ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP INDEX ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", index_name, "`");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addPrimaryKey){

	zval *table_name, *schema_name, *index, *sql = NULL, *columns = NULL;
	zval *column_list = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_VERIFY_INTERFACE_EX(index, phalcon_db_indexinterface_ce, phalcon_db_exception_ce, 1);

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ADD PRIMARY KEY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ADD PRIMARY KEY ");
	}
	
	PHALCON_CALL_METHOD(&columns, index, "getcolumns");
	PHALCON_CALL_METHOD(&column_list, this_ptr, "getcolumnlist", columns);
	PHALCON_SCONCAT_SVS(sql, "(", column_list, ")");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropPrimaryKey){

	zval *table_name, *schema_name, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &table_name, &schema_name);
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP PRIMARY KEY");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP PRIMARY KEY");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, addForeignKey){

	zval *table_name, *schema_name, *reference, *sql = NULL;
	zval *columns = NULL, *quoted_column_list = NULL, *reference_name = NULL;
	zval *referenced_schema = NULL, *referenced_columns = NULL;
	zval *quoted_columns = NULL, *referenced_table = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &reference);
	
	PHALCON_VERIFY_INTERFACE_EX(reference, phalcon_db_referenceinterface_ce, phalcon_db_exception_ce, 1);

	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` ");
	}

    PHALCON_CALL_METHOD(&reference_name, reference, "getname");
	PHALCON_SCONCAT_SVS(sql, "ADD CONSTRAINT `", reference_name, "` FOREIGN KEY ");

	PHALCON_CALL_METHOD(&columns, reference, "getcolumns");
	
	PHALCON_CALL_METHOD(&quoted_column_list, this_ptr, "getcolumnlist", columns);
	PHALCON_SCONCAT_SVS(sql, "(", quoted_column_list, ") REFERENCES ");
	
	PHALCON_CALL_METHOD(&referenced_schema, reference, "getreferencedschema");
	if (zend_is_true(referenced_schema)) {
		PHALCON_SCONCAT_SVS(sql, "`", referenced_schema, "`.");
	}
	
	PHALCON_CALL_METHOD(&referenced_columns, reference, "getreferencedcolumns");
	PHALCON_CALL_METHOD(&quoted_columns, this_ptr, "getcolumnlist", referenced_columns);
	PHALCON_CALL_METHOD(&referenced_table, reference, "getreferencedtable");
	PHALCON_SCONCAT_SVSVS(sql, "`", referenced_table, "`(", quoted_columns, ")");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &reference_name);
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE `", schema_name, "`.`", table_name, "` DROP FOREIGN KEY ");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE `", table_name, "` DROP FOREIGN KEY ");
	}
	PHALCON_SCONCAT_SVS(sql, "`", reference_name, "`");
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, _getTableOptions){

	zval *definition, *table_options, *options, *engine;
	zval *sql_engine, *auto_increment, *sql_autoincrement;
	zval *table_collation, *collation_parts, *first_part;
	zval *sql_charset, *sql_collate, *sql_table_options;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &definition);
	
	if (phalcon_array_isset_quick_string(definition, SS("options"), 2952422065UL)) {
	
		PHALCON_INIT_VAR(table_options);
		array_init(table_options);
	
		PHALCON_OBS_VAR(options);
		phalcon_array_fetch_quick_string(&options, definition, SS("options"), 2952422065UL, PH_NOISY);
	
		if (phalcon_array_isset_quick_string(options, SS("ENGINE"), 2119337627UL)) {
	
			PHALCON_OBS_VAR(engine);
			phalcon_array_fetch_quick_string(&engine, options, SS("ENGINE"), 2119337627UL, PH_NOISY);
			if (zend_is_true(engine)) {
				PHALCON_INIT_VAR(sql_engine);
				PHALCON_CONCAT_SV(sql_engine, "ENGINE=", engine);
				phalcon_array_append(&table_options, sql_engine, PH_SEPARATE);
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("AUTO_INCREMENT"), 656925090UL)) {
	
			PHALCON_OBS_VAR(auto_increment);
			phalcon_array_fetch_quick_string(&auto_increment, options, SS("AUTO_INCREMENT"), 656925090UL, PH_NOISY);
			if (zend_is_true(auto_increment)) {
				PHALCON_INIT_VAR(sql_autoincrement);
				PHALCON_CONCAT_SV(sql_autoincrement, "AUTO_INCREMENT=", auto_increment);
				phalcon_array_append(&table_options, sql_autoincrement, PH_SEPARATE);
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("TABLE_COLLATION"), 1457306353UL)) {
	
			PHALCON_OBS_VAR(table_collation);
			phalcon_array_fetch_quick_string(&table_collation, options, SS("TABLE_COLLATION"), 1457306353UL, PH_NOISY);
			if (zend_is_true(table_collation)) {
				PHALCON_INIT_VAR(collation_parts);
				phalcon_fast_explode_str(collation_parts, SL("_"), table_collation);
	
				PHALCON_OBS_VAR(first_part);
				phalcon_array_fetch_long(&first_part, collation_parts, 0, PH_NOISY);
	
				PHALCON_INIT_VAR(sql_charset);
				PHALCON_CONCAT_SV(sql_charset, "DEFAULT CHARSET=", first_part);
				phalcon_array_append(&table_options, sql_charset, PH_SEPARATE);
	
				PHALCON_INIT_VAR(sql_collate);
				PHALCON_CONCAT_SV(sql_collate, "COLLATE=", table_collation);
				phalcon_array_append(&table_options, sql_collate, PH_SEPARATE);
			}
		}
	
		if (phalcon_fast_count_ev(table_options TSRMLS_CC)) {
			PHALCON_INIT_VAR(sql_table_options);
			phalcon_fast_join_str(sql_table_options, SL(" "), table_options TSRMLS_CC);
			RETURN_CTOR(sql_table_options);
		}
	}
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, createTable){

	zval *table_name, *schema_name, *definition;
	zval *table = NULL, *temporary = NULL, *options = NULL, *sql = NULL, *create_lines;
	zval *columns = NULL, *column = NULL, *column_name = NULL, *column_definition = NULL;
	zval *column_line = NULL, *attribute = NULL, *indexes, *index = NULL;
	zval *index_name = NULL, *column_list = NULL, *referenced_column_list = NULL, *index_sql = NULL, *references;
	zval *reference = NULL, *name = NULL, *referenced_table = NULL, *referenced_columns = NULL;
	zval *constaint_sql = NULL, *reference_sql = NULL, *joined_lines;
	zval *index_type = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &definition);
	
	if (!phalcon_array_isset_quick_string(definition, SS("columns"), 1041822630UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'columns' is required in the definition array");
		return;
	}
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_NVAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	
	PHALCON_INIT_VAR(temporary);
	ZVAL_BOOL(temporary, 0);
	if (phalcon_array_isset_quick_string(definition, SS("options"), 2952422065UL)) {
	
		PHALCON_OBS_VAR(options);
		phalcon_array_fetch_quick_string(&options, definition, SS("options"), 2952422065UL, PH_NOISY);
		phalcon_array_isset_string_fetch(&temporary, options, SS("temporary"));
	}
	
	if (zend_is_true(temporary)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TEMPORARY TABLE ", table, " (\n\t");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "CREATE TABLE ", table, " (\n\t");
	}
	
	PHALCON_INIT_VAR(create_lines);
	array_init(create_lines);
	
	PHALCON_OBS_VAR(columns);
	phalcon_array_fetch_quick_string(&columns, definition, SS("columns"), 1041822630UL, PH_NOISY);
	
	phalcon_is_iterable(columns, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(column);
	
		PHALCON_CALL_METHOD(&column_name, column, "getname");
		PHALCON_CALL_METHOD(&column_definition, this_ptr, "getcolumndefinition", column);

		PHALCON_INIT_NVAR(column_line);
		PHALCON_CONCAT_SVSV(column_line, "`", column_name, "` ", column_definition);
	
		PHALCON_CALL_METHOD(&attribute, column, "isnotnull");
		if (zend_is_true(attribute)) {
			phalcon_concat_self_str(&column_line, SL(" NOT NULL") TSRMLS_CC);
		}
	
		PHALCON_CALL_METHOD(&attribute, column, "isautoincrement");
		if (zend_is_true(attribute)) {
			phalcon_concat_self_str(&column_line, SL(" AUTO_INCREMENT") TSRMLS_CC);
		}
	
		PHALCON_CALL_METHOD(&attribute, column, "isprimary");
		if (zend_is_true(attribute)) {
			phalcon_concat_self_str(&column_line, SL(" PRIMARY KEY") TSRMLS_CC);
		}
	
		phalcon_array_append(&create_lines, column_line, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (phalcon_array_isset_quick_string(definition, SS("indexes"), 1726269685UL)) {
	
		PHALCON_OBS_VAR(indexes);
		phalcon_array_fetch_quick_string(&indexes, definition, SS("indexes"), 1726269685UL, PH_NOISY);
	
		phalcon_is_iterable(indexes, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(index);
	
			PHALCON_CALL_METHOD(&index_name, index, "getname");
			PHALCON_CALL_METHOD(&columns, index, "getcolumns");
			PHALCON_CALL_METHOD(&column_list, this_ptr, "getcolumnlist", columns);
			PHALCON_CALL_METHOD(&index_type, index, "gettype");
	
			PHALCON_INIT_NVAR(index_sql);
			if (PHALCON_IS_STRING(index_name, "PRIMARY")) {
				PHALCON_CONCAT_SVS(index_sql, "PRIMARY KEY (", column_list, ")");
			} else if (index_type && Z_TYPE_P(index_type) == IS_STRING && Z_STRLEN_P(index_type) > 0) {
				PHALCON_CONCAT_VSVSVS(index_sql, index_type, " KEY `", index_name, "` (", column_list, ")");
			} else {
				PHALCON_CONCAT_SVSVS(index_sql, "KEY `", index_name, "` (", column_list, ")");
			}
	
			phalcon_array_append(&create_lines, index_sql, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
	}
	
	if (phalcon_array_isset_quick_string(definition, SS("references"), 3245500135UL)) {
	
		PHALCON_OBS_VAR(references);
		phalcon_array_fetch_quick_string(&references, definition, SS("references"), 3245500135UL, PH_NOISY);
	
		phalcon_is_iterable(references, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HVALUE(reference);
	
			PHALCON_CALL_METHOD(&name, reference, "getname");
			PHALCON_CALL_METHOD(&columns, reference, "getcolumns");
			PHALCON_CALL_METHOD(&column_list, this_ptr, "getcolumnlist", columns);
			PHALCON_CALL_METHOD(&referenced_table, reference, "getreferencedtable");
			PHALCON_CALL_METHOD(&referenced_columns, reference, "getreferencedcolumns");
			PHALCON_CALL_METHOD(&referenced_column_list, this_ptr, "getcolumnlist", referenced_columns);
	
			PHALCON_INIT_NVAR(constaint_sql);
			PHALCON_CONCAT_SVSVS(constaint_sql, "CONSTRAINT `", name, "` FOREIGN KEY (", column_list, ")");
	
			PHALCON_INIT_NVAR(reference_sql);
			PHALCON_CONCAT_VSVSVS(reference_sql, constaint_sql, " REFERENCES `", referenced_table, "`(", referenced_column_list, ")");
			phalcon_array_append(&create_lines, reference_sql, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
	}
	
	PHALCON_INIT_VAR(joined_lines);
	phalcon_fast_join_str(joined_lines, SL(",\n\t"), create_lines TSRMLS_CC);
	PHALCON_SCONCAT_VS(sql, joined_lines, "\n)");
	if (phalcon_array_isset_quick_string(definition, SS("options"), 2952422065UL)) {
		PHALCON_CALL_METHOD(&options, this_ptr, "_gettableoptions", definition);
		PHALCON_SCONCAT_SV(sql, " ", options);
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &table_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_SVSVS(table, "`", schema_name, "`.`", table_name, "`");
	} else {
		PHALCON_INIT_NVAR(table);
		PHALCON_CONCAT_SVS(table, "`", table_name, "`");
	}
	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SV(return_value, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_CONCAT_SV(return_value, "DROP TABLE ", table);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, createView){

	zval *view_name, *definition, *schema_name, *view_sql;
	zval *view = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &view_name, &definition, &schema_name);
	
	if (!phalcon_array_isset_quick_string(definition, SS("sql"), 2090732981UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'sql' is required in the definition array");
		return;
	}
	
	PHALCON_OBS_VAR(view_sql);
	phalcon_array_fetch_quick_string(&view_sql, definition, SS("sql"), 2090732981UL, PH_NOISY);
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_SVSVS(view, "`", schema_name, "`.`", view_name, "`");
	} else {
		PHALCON_INIT_NVAR(view);
		PHALCON_CONCAT_SVS(view, "`", view_name, "`");
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVSV(sql, "CREATE VIEW ", view, " AS ", view_sql);
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, dropView){

	zval *view_name, *schema_name, *if_exists = NULL, *view = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &view_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, schema_name, ".", view_name);
	} else {
		view = view_name;
	}

	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SV(return_value, "DROP VIEW IF EXISTS ", view);
	} else {
		PHALCON_CONCAT_SV(return_value, "DROP VIEW ", view);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableExists){

	zval *table_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &table_name, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`= '", table_name, "' AND `TABLE_SCHEMA`='", schema_name, "'");
	}
	else {
		PHALCON_CONCAT_SVS(return_value, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_NAME`='", table_name, "'");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, viewExists){

	zval *view_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &view_name, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`VIEWS` WHERE `TABLE_NAME`= '", view_name, "' AND `TABLE_SCHEMA`='", schema_name, "'");
	}
	else {
		PHALCON_CONCAT_SVS(return_value, "SELECT IF(COUNT(*)>0, 1 , 0) FROM `INFORMATION_SCHEMA`.`VIEWS` WHERE `TABLE_NAME`='", view_name, "'");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeColumns){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	if (schema && zend_is_true(schema)) {
		PHALCON_CONCAT_SVSVS(return_value, "DESCRIBE `", schema, "`.`", table, "`");
	}
	else {
		PHALCON_CONCAT_SVS(return_value, "DESCRIBE `", table, "`");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, listTables){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVS(return_value, "SHOW TABLES FROM `", schema_name, "`");
	}
	else {
		RETURN_STRING("SHOW TABLES", 1);
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, listViews){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVS(return_value, "SELECT `TABLE_NAME` AS view_name FROM `INFORMATION_SCHEMA`.`VIEWS` WHERE `TABLE_SCHEMA` = '", schema_name, "' ORDER BY view_name");
	}
	else {
		RETURN_STRING("SELECT `TABLE_NAME` AS view_name FROM `INFORMATION_SCHEMA`.`VIEWS` ORDER BY view_name", 1);
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeIndexes){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	if (schema && zend_is_true(schema)) {
		PHALCON_CONCAT_SVSVS(return_value, "SHOW INDEXES FROM `", schema, "`.`", table, "`");
	}
	else {
		PHALCON_CONCAT_SVS(return_value, "SHOW INDEXES FROM `", table, "`");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,REFERENCED_TABLE_SCHEMA,REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_NAME IS NOT NULL AND ", 1);
	if (schema && zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "CONSTRAINT_SCHEMA = \"", schema, "\" AND TABLE_NAME = \"", table, "\"");
	} else {
		PHALCON_SCONCAT_SVS(sql, "TABLE_NAME = \"", table, "\"");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Mysql, tableOptions){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT TABLES.TABLE_TYPE AS table_type,TABLES.AUTO_INCREMENT AS auto_increment,TABLES.ENGINE AS engine,TABLES.TABLE_COLLATION AS table_collation FROM INFORMATION_SCHEMA.TABLES WHERE ", 1);
	if (schema && zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "TABLES.TABLE_SCHEMA = \"", schema, "\" AND TABLES.TABLE_NAME = \"", table, "\"");
	} else {
		PHALCON_SCONCAT_SVS(sql, "TABLES.TABLE_NAME = \"", table, "\"");
	}
	
	RETURN_CTOR(sql);
}







zend_class_entry *phalcon_db_dialect_oracle_ce;

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, getColumnDefinition);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, modifyColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, _getTableOptions);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, createTable);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropTable);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, createView);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropView);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, tableExists);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, viewExists);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeColumns);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, listTables);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, listViews);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeIndexes);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeReferences);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, tableOptions);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, getSqlTable);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, limit);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, select);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, supportsSavepoints);
static PHP_METHOD(Phalcon_Db_Dialect_Oracle, supportsReleaseSavepoints);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_dialect_oracle_getsqltable, 0, 0, 1)
	ZEND_ARG_INFO(0, table)
	ZEND_ARG_INFO(0, escapeChar)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_dialect_oracle_method_entry[] = {
	PHP_ME(Phalcon_Db_Dialect_Oracle, getColumnDefinition, arginfo_phalcon_db_dialectinterface_getcolumndefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, addColumn, arginfo_phalcon_db_dialectinterface_addcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, modifyColumn, arginfo_phalcon_db_dialectinterface_modifycolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropColumn, arginfo_phalcon_db_dialectinterface_dropcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, addIndex, arginfo_phalcon_db_dialectinterface_addindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropIndex, arginfo_phalcon_db_dialectinterface_dropindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, addPrimaryKey, arginfo_phalcon_db_dialectinterface_addprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropPrimaryKey, arginfo_phalcon_db_dialectinterface_dropprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, addForeignKey, arginfo_phalcon_db_dialectinterface_addforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropForeignKey, arginfo_phalcon_db_dialectinterface_dropforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, _getTableOptions, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Db_Dialect_Oracle, createTable, arginfo_phalcon_db_dialectinterface_createtable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropTable, arginfo_phalcon_db_dialectinterface_droptable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, createView, arginfo_phalcon_db_dialectinterface_createview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, dropView, arginfo_phalcon_db_dialectinterface_dropview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, tableExists, arginfo_phalcon_db_dialectinterface_tableexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, viewExists, arginfo_phalcon_db_dialectinterface_viewexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, describeColumns, arginfo_phalcon_db_dialectinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, listTables, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, listViews, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, describeIndexes, arginfo_phalcon_db_dialectinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, describeReferences, arginfo_phalcon_db_dialectinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, tableOptions, arginfo_phalcon_db_dialectinterface_tableoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, getSqlTable, arginfo_phalcon_db_dialect_oracle_getsqltable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, limit, arginfo_phalcon_db_dialectinterface_limit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, select, arginfo_phalcon_db_dialectinterface_select, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, supportsSavepoints, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Oracle, supportsReleaseSavepoints, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Oracle){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Oracle, db_dialect_oracle, phalcon_db_dialect_ce, phalcon_db_dialect_oracle_method_entry, 0);

	zend_declare_property_string(phalcon_db_dialect_oracle_ce, SL("_escapeChar"), "", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_dialect_oracle_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, getColumnDefinition){

	zval *column, *size = NULL, *column_type = NULL, *column_sql = NULL;
	zval *scale = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	
	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an object compatible with Phalcon\\Db\\ColumnInterface");
		return;
	}
	
	PHALCON_CALL_METHOD(&size, column, "getsize");
	PHALCON_CALL_METHOD(&column_type, column, "gettype");
	
	switch (phalcon_get_intval(column_type)) {
	
		case 0:
			PHALCON_INIT_VAR(column_sql);
			ZVAL_STRING(column_sql, "INTEGER", 1);
			break;
	
		case 1:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "DATE", 1);
			break;
	
		case 2:
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVS(column_sql, "VARCHAR2(", size, ")");
			break;
	
		case 3:
			PHALCON_CALL_METHOD(&scale, column, "getscale");
	
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVSVS(column_sql, "NUMBER(", size, ",", scale, ")");
			break;
	
		case 4:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "TIMESTAMP", 1);
			break;
	
		case 5:
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVS(column_sql, "CHAR(", size, ")");
			break;
	
		case 6:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "TEXT", 1);
			break;
	
		case 7:
			PHALCON_CALL_METHOD(&scale, column, "getscale");
	
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVSVS(column_sql, "FLOAT(", size, ",", scale, ")");
			break;
	
		case 8:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "TINYINT(1)", 1);
			break;
	
		default:
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized Oracle data type");
			return;
	
	}
	
	RETURN_CTOR(column_sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addColumn){

	zval *table_name, *schema_name, *column;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, modifyColumn){

	zval *table_name, *schema_name, *column;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropColumn){

	zval *table_name, *schema_name, *column_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addIndex){

	zval *table_name, *schema_name, *index;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropIndex){

	zval *table_name, *schema_name, *index_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addPrimaryKey){

	zval *table_name, *schema_name, *index;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropPrimaryKey){

	zval *table_name, *schema_name;

	phalcon_fetch_params(0, 2, 0, &table_name, &schema_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, addForeignKey){

	zval *table_name, *schema_name, *reference;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &reference);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &reference_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, _getTableOptions){

	zval *definition, *empty_array;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &definition);
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	RETURN_CTOR(empty_array);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, createTable){

	zval *table_name, *schema_name, *definition;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &definition);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &table_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		PHALCON_CPY_WRT(table, table_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SV(return_value, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_CONCAT_SV(return_value, "DROP TABLE ", table);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, createView){

	zval *view_name, *definition, *schema_name, *view_sql;
	zval *view = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &view_name, &definition, &schema_name);
	
	if (!phalcon_array_isset_quick_string(definition, SS("sql"), 2090732981UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'sql' is required in the definition array");
		return;
	}
	
	PHALCON_OBS_VAR(view_sql);
	phalcon_array_fetch_quick_string(&view_sql, definition, SS("sql"), 2090732981UL, PH_NOISY);
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, view_name, ".", schema_name);
	} else {
		PHALCON_CPY_WRT(view, view_name);
	}
	
	PHALCON_CONCAT_SVSV(return_value, "CREATE VIEW ", view, " AS ", view_sql);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, dropView){

	zval *view_name, *schema_name, *if_exists = NULL, *view = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &view_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_SVSVS(view, "`", schema_name, "`.`", view_name, "`");
	} else {
		PHALCON_INIT_NVAR(view);
		PHALCON_CONCAT_SVS(view, "`", view_name, "`");
	}
	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SV(return_value, "DROP VIEW IF EXISTS ", view);
	} else {
		PHALCON_CONCAT_SV(return_value, "DROP VIEW ", view);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, tableExists){

	zval *table_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &table_name, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END RET FROM ALL_TABLES WHERE TABLE_NAME='", table_name, "' AND OWNER = '", schema_name, "'");
	} else {
		PHALCON_CONCAT_SVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END RET FROM ALL_TABLES WHERE TABLE_NAME='", table_name, "'");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, viewExists){

	zval *view_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &view_name, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END RET FROM ALL_VIEWS WHERE VIEW_NAME='", view_name, "' AND OWNER='", schema_name, "'");
	} else {
		PHALCON_CONCAT_SVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END RET FROM ALL_VIEWS WHERE VIEW_NAME='", view_name, "'");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeColumns){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	if (schema && zend_is_true(schema)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT TC.COLUMN_NAME, TC.DATA_TYPE, TC.DATA_LENGTH, TC.DATA_PRECISION, TC.DATA_SCALE, TC.NULLABLE, C.CONSTRAINT_TYPE, TC.DATA_DEFAULT, CC.POSITION FROM ALL_TAB_COLUMNS TC LEFT JOIN (ALL_CONS_COLUMNS CC JOIN ALL_CONSTRAINTS C ON (CC.CONSTRAINT_NAME = C.CONSTRAINT_NAME AND CC.TABLE_NAME = C.TABLE_NAME AND CC.OWNER = C.OWNER AND C.CONSTRAINT_TYPE = 'P')) ON TC.TABLE_NAME = CC.TABLE_NAME AND TC.COLUMN_NAME = CC.COLUMN_NAME WHERE TC.TABLE_NAME = '", table, "' AND TC.OWNER = '", schema, "' ORDER BY TC.COLUMN_ID");
	} else {
		PHALCON_CONCAT_SVS(return_value, "SELECT TC.COLUMN_NAME, TC.DATA_TYPE, TC.DATA_LENGTH, TC.DATA_PRECISION, TC.DATA_SCALE, TC.NULLABLE, C.CONSTRAINT_TYPE, TC.DATA_DEFAULT, CC.POSITION FROM ALL_TAB_COLUMNS TC LEFT JOIN (ALL_CONS_COLUMNS CC JOIN ALL_CONSTRAINTS C ON (CC.CONSTRAINT_NAME = C.CONSTRAINT_NAME AND CC.TABLE_NAME = C.TABLE_NAME AND CC.OWNER = C.OWNER AND C.CONSTRAINT_TYPE = 'P')) ON TC.TABLE_NAME = CC.TABLE_NAME AND TC.COLUMN_NAME = CC.COLUMN_NAME WHERE TC.TABLE_NAME = '", table, "' ORDER BY TC.COLUMN_ID");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, listTables){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVS(return_value, "SELECT TABLE_NAME, OWNER FROM ALL_TABLES WHERE OWNER='", schema_name, "' ORDER BY OWNER, TABLE_NAME");
	} else {
		RETURN_STRING("SELECT TABLE_NAME, OWNER FROM ALL_TABLES ORDER BY OWNER, TABLE_NAME ", 1);
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, listViews){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVS(return_value, "SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER='", schema_name, "' ORDER BY VIEW_NAME");
	} else {
		RETURN_STRING("SELECT VIEW_NAME FROM ALL_VIEWS VIEW_NAME", 1);
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeIndexes){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	if (schema && zend_is_true(schema)) {
		PHALCON_CONCAT_SVSVS(return_value, "SELECT I.TABLE_NAME, 0 AS C0, I.INDEX_NAME, IC.COLUMN_POSITION, IC.COLUMN_NAME FROM ALL_INDEXES I JOIN ALL_IND_COLUMNS IC ON I.INDEX_NAME = IC.INDEX_NAME WHERE  I.TABLE_NAME = '", table, "' AND IC.INDEX_OWNER = '", schema, "'");
	} else {
		PHALCON_CONCAT_SVS(return_value, "SELECT I.TABLE_NAME, 0 AS C0, I.INDEX_NAME, IC.COLUMN_POSITION, IC.COLUMN_NAME FROM ALL_INDEXES I JOIN ALL_IND_COLUMNS IC ON I.INDEX_NAME = IC.INDEX_NAME WHERE  I.TABLE_NAME = '", table, "'");
	}
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT AC.TABLE_NAME, CC.COLUMN_NAME, AC.CONSTRAINT_NAME, AC.R_OWNER, RCC.TABLE_NAME R_TABLE_NAME, RCC.COLUMN_NAME R_COLUMN_NAME FROM ALL_CONSTRAINTS AC JOIN ALL_CONS_COLUMNS CC ON AC.CONSTRAINT_NAME = CC.CONSTRAINT_NAME JOIN ALL_CONS_COLUMNS RCC ON AC.R_OWNER = RCC.OWNER AND AC.R_CONSTRAINT_NAME = RCC.CONSTRAINT_NAME WHERE AC.CONSTRAINT_TYPE='R' ", 1);
	if (schema && zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "AND AC.OWNER='", schema, "' AND AC.TABLE_NAME = '", table, "'");
	} else {
		PHALCON_SCONCAT_SVS(sql, "AND AC.TABLE_NAME = '", table, "'");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, tableOptions){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	RETURN_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, getSqlTable){

	zval *table, *escape_char = NULL, *table_name, *sql_table = NULL;
	zval *schema_name, *sql_schema = NULL, *alias_name;
	zval *sql_table_alias = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &escape_char);
	
	if (!escape_char) {
		PHALCON_INIT_VAR(escape_char);
	} else {
		PHALCON_SEPARATE_PARAM(escape_char);
	}
	
	if (Z_TYPE_P(escape_char) == IS_NULL) {
		PHALCON_OBS_NVAR(escape_char);
		phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
	}
	if (Z_TYPE_P(table) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(table_name);
		phalcon_array_fetch_long(&table_name, table, 0, PH_NOISY);
		if (PHALCON_GLOBAL(db).escape_identifiers) {
			PHALCON_INIT_VAR(sql_table);
			PHALCON_CONCAT_VVV(sql_table, escape_char, table_name, escape_char);
		} else {
			PHALCON_CPY_WRT(sql_table, table_name);
		}
	
		PHALCON_OBS_VAR(schema_name);
		phalcon_array_fetch_long(&schema_name, table, 1, PH_NOISY);
		if (Z_TYPE_P(schema_name) != IS_NULL) {
			if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_VAR(sql_schema);
				PHALCON_CONCAT_VVVSV(sql_schema, escape_char, schema_name, escape_char, ".", sql_table);
			} else {
				PHALCON_INIT_NVAR(sql_schema);
				PHALCON_CONCAT_VSV(sql_schema, schema_name, ".", sql_table);
			}
		} else {
			PHALCON_CPY_WRT(sql_schema, sql_table);
		}
	
		if (phalcon_array_isset_long(table, 2)) {
	
			PHALCON_OBS_VAR(alias_name);
			phalcon_array_fetch_long(&alias_name, table, 2, PH_NOISY);
			if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_VAR(sql_table_alias);
				PHALCON_CONCAT_VSVVV(sql_table_alias, sql_schema, " ", escape_char, alias_name, escape_char);
			} else {
				PHALCON_INIT_NVAR(sql_table_alias);
				PHALCON_CONCAT_VSV(sql_table_alias, sql_schema, " ", alias_name);
			}
		} else {
			PHALCON_CPY_WRT(sql_table_alias, sql_schema);
		}
	
		RETURN_CTOR(sql_table_alias);
	}
	
	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_INIT_NVAR(sql_table);
		PHALCON_CONCAT_VVV(sql_table, escape_char, table, escape_char);
		RETURN_CTOR(sql_table);
	}
	
	RETURN_CTOR(table);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, limit){

	zval *sql_query, *number, *limit, *sql_limit;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz", &sql_query, &number) == FAILURE) {
		RETURN_MM_NULL();
	}

	if (phalcon_is_numeric(number)) {

		PHALCON_INIT_VAR(limit);
		ZVAL_LONG(limit, phalcon_get_intval(number));

		PHALCON_INIT_VAR(sql_limit);
		PHALCON_CONCAT_VSV(sql_limit, sql_query, " LIMIT ", limit);
		RETURN_CTOR(sql_limit);
	}

	RETURN_CTOR(sql_query);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, select){

	zval *definition, *escape_char = NULL, *columns, *selected_columns, *distinct;
	zval *column = NULL, *column_item = NULL, *column_sql = NULL, *columns_sql = NULL;
	zval *column_domain = NULL, *column_domain_sql = NULL, *column_alias = NULL;
	zval *column_alias_sql = NULL, *tables, *selected_tables;
	zval *table = NULL, *sql_table = NULL, *tables_sql = NULL, *sql, *joins;
	zval *join = NULL, *type = NULL, *sql_join = NULL, *join_conditions_array = NULL;
	zval *join_expressions = NULL, *join_condition = NULL, *join_expression = NULL;
	zval *join_conditions = NULL, *where_conditions;
	zval *where_expression = NULL, *group_items, *group_fields;
	zval *group_field = NULL, *group_expression = NULL, *group_sql;
	zval *group_clause, *having_conditions, *having_expression = NULL;
	zval *order_fields, *order_items, *order_item = NULL;
	zval *order_expression = NULL, *order_sql_item = NULL, *sql_order_type = NULL;
	zval *order_sql_item_type = NULL, *order_sql, *limit_value;
	zval *number, *offset, *tmp1 = NULL, *tmp2 = NULL;
	zval *z_one, *ini_range, *end_range = NULL, *sql_limit;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5;
	zval **hd;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &definition) == FAILURE) {
		RETURN_NULL();
	}

	if (Z_TYPE_P(definition) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Invalid SELECT definition");
		return;
	}
	if (!phalcon_array_isset_quick_string(definition, SS("tables"), 3465666720UL)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "The index 'tables' is required in the definition array");
		return;
	}

	if (!phalcon_array_isset_quick_string(definition, SS("columns"), 1041822630UL)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "The index 'columns' is required in the definition array");
		return;
	}

	PHALCON_MM_GROW();

	if (PHALCON_GLOBAL(db).escape_identifiers) {
		PHALCON_OBS_VAR(escape_char);
		phalcon_read_property_this(&escape_char, this_ptr, SL("_escapeChar"), PH_NOISY TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(escape_char);
	}

	PHALCON_OBS_VAR(columns);
	phalcon_array_fetch_quick_string(&columns, definition, SS("columns"), 1041822630UL, PH_NOISY);
	if (Z_TYPE_P(columns) == IS_ARRAY) {

		PHALCON_INIT_VAR(selected_columns);
		array_init(selected_columns);

		phalcon_is_iterable(columns, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HVALUE(column);

			PHALCON_OBS_NVAR(column_item);
			phalcon_array_fetch_long(&column_item, column, 0, PH_NOISY);
			if (Z_TYPE_P(column_item) == IS_ARRAY) {
				PHALCON_CALL_METHOD(&column_sql, this_ptr, "getsqlexpression", column_item, escape_char);
			} else if (PHALCON_IS_STRING(column_item, "*")) {
				PHALCON_CPY_WRT(column_sql, column_item);
			} else if (PHALCON_GLOBAL(db).escape_identifiers) {
				PHALCON_INIT_NVAR(column_sql);
				PHALCON_CONCAT_VVV(column_sql, escape_char, column_item, escape_char);
			} else {
				PHALCON_CPY_WRT(columns_sql, column_item);
			}

			if (phalcon_array_isset_long(column, 1)) {

				PHALCON_OBS_NVAR(column_domain);
				phalcon_array_fetch_long(&column_domain, column, 1, PH_NOISY);
				if (zend_is_true(column_domain)) {
					if (PHALCON_GLOBAL(db).escape_identifiers) {
						PHALCON_INIT_NVAR(column_domain_sql);
						PHALCON_CONCAT_VVVSV(column_domain_sql, escape_char, column_domain, escape_char, ".", column_sql);
					} else {
						PHALCON_INIT_NVAR(column_domain_sql);
						PHALCON_CONCAT_VSV(column_domain_sql, column_domain, ".", column_sql);
					}
				} else {
					PHALCON_CPY_WRT(column_domain_sql, column_sql);
				}
			} else {
				PHALCON_CPY_WRT(column_domain_sql, column_sql);
			}

			if (phalcon_array_isset_long(column, 2)) {

				PHALCON_OBS_NVAR(column_alias);
				phalcon_array_fetch_long(&column_alias, column, 2, PH_NOISY);
				if (zend_is_true(column_alias)) {
					if (PHALCON_GLOBAL(db).escape_identifiers) {
						PHALCON_INIT_NVAR(column_alias_sql);
						PHALCON_CONCAT_VSVVV(column_alias_sql, column_domain_sql, " ", escape_char, column_alias, escape_char);
					} else {
						PHALCON_INIT_NVAR(column_alias_sql);
						PHALCON_CONCAT_VSV(column_alias_sql, column_domain_sql, " ", column_alias);
					}
				} else {
					PHALCON_CPY_WRT(column_alias_sql, column_domain_sql);
				}
			} else {
				PHALCON_CPY_WRT(column_alias_sql, column_domain_sql);
			}

			phalcon_array_append(&selected_columns, column_alias_sql, PH_SEPARATE);

			zend_hash_move_forward_ex(ah0, &hp0);
		}

		PHALCON_INIT_VAR(columns_sql);
		phalcon_fast_join_str(columns_sql, SL(", "), selected_columns TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(columns_sql, columns);
	}

	PHALCON_OBS_VAR(tables);
	phalcon_array_fetch_quick_string(&tables, definition, SS("tables"), 3465666720UL, PH_NOISY);
	if (Z_TYPE_P(tables) == IS_ARRAY) {

		PHALCON_INIT_VAR(selected_tables);
		array_init(selected_tables);

		phalcon_is_iterable(tables, &ah1, &hp1, 0, 0);

		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {

			PHALCON_GET_HVALUE(table);

			PHALCON_CALL_METHOD(&sql_table, this_ptr, "getsqltable", table, escape_char);
			phalcon_array_append(&selected_tables, sql_table, PH_SEPARATE);

			zend_hash_move_forward_ex(ah1, &hp1);
		}

		PHALCON_INIT_VAR(tables_sql);
		phalcon_fast_join_str(tables_sql, SL(", "), selected_tables TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(tables_sql, tables);
	}

	PHALCON_INIT_VAR(sql);
	if (phalcon_array_isset_string_fetch(&distinct, definition, SS("distinct"))) {
		assert(Z_TYPE_P(distinct) == IS_LONG);
		if (Z_LVAL_P(distinct) == 0) {
			ZVAL_STRING(sql, "SELECT ALL ", 1);
		}
		else if (Z_LVAL_P(distinct) == 1) {
			ZVAL_STRING(sql, "SELECT DISTINCT ", 1);
		}
		else {
			ZVAL_STRING(sql, "SELECT ", 1);
		}
	}
	else {
		ZVAL_STRING(sql, "SELECT ", 1);
	}

	PHALCON_SCONCAT_VSV(sql, columns_sql, " FROM ", tables_sql);

	if (phalcon_array_isset_quick_string(definition, SS("joins"), 120974824UL)) {

		PHALCON_OBS_VAR(joins);
		phalcon_array_fetch_quick_string(&joins, definition, SS("joins"), 120974824UL, PH_NOISY);

		phalcon_is_iterable(joins, &ah2, &hp2, 0, 0);

		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {

			PHALCON_GET_HVALUE(join);

			PHALCON_OBS_NVAR(type);
			phalcon_array_fetch_quick_string(&type, join, SS("type"), 276192743UL, PH_NOISY);

			PHALCON_OBS_NVAR(table);
			phalcon_array_fetch_quick_string(&table, join, SS("source"), 2744839734UL, PH_NOISY);

			PHALCON_CALL_METHOD(&sql_table, this_ptr, "getsqltable", table, escape_char);
			phalcon_array_append(&selected_tables, sql_table, PH_SEPARATE);

			PHALCON_INIT_NVAR(sql_join);
			PHALCON_CONCAT_SVSV(sql_join, " ", type, " JOIN ", sql_table);

			if (phalcon_array_isset_quick_string(join, SS("conditions"), 1055696255UL)) {

				PHALCON_OBS_NVAR(join_conditions_array);
				phalcon_array_fetch_quick_string(&join_conditions_array, join, SS("conditions"), 1055696255UL, PH_NOISY);
				if (phalcon_fast_count_ev(join_conditions_array TSRMLS_CC)) {

					PHALCON_INIT_NVAR(join_expressions);
					array_init(join_expressions);

					phalcon_is_iterable(join_conditions_array, &ah3, &hp3, 0, 0);

					while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {

						PHALCON_GET_HVALUE(join_condition);

						PHALCON_CALL_METHOD(&join_expression, this_ptr, "getsqlexpression", join_condition, escape_char);
						phalcon_array_append(&join_expressions, join_expression, PH_SEPARATE);

						zend_hash_move_forward_ex(ah3, &hp3);
					}

					PHALCON_INIT_NVAR(join_conditions);
					phalcon_fast_join_str(join_conditions, SL(" AND "), join_expressions TSRMLS_CC);
					PHALCON_SCONCAT_SV(sql_join, " ON ", join_conditions);
				}
			}

			phalcon_concat_self(&sql, sql_join TSRMLS_CC);

			zend_hash_move_forward_ex(ah2, &hp2);
		}

	}

	if (phalcon_array_isset_quick_string(definition, SS("where"), 621293632UL)) {

		PHALCON_OBS_VAR(where_conditions);
		phalcon_array_fetch_quick_string(&where_conditions, definition, SS("where"), 621293632UL, PH_NOISY);
		if (Z_TYPE_P(where_conditions) == IS_ARRAY) {
			PHALCON_CALL_METHOD(&where_expression, this_ptr, "getsqlexpression", where_conditions, escape_char);
			PHALCON_SCONCAT_SV(sql, " WHERE ", where_expression);
		} else {
			PHALCON_SCONCAT_SV(sql, " WHERE ", where_conditions);
		}
	}

	if (phalcon_array_isset_quick_string(definition, SS("group"), 7349554UL)) {

		PHALCON_INIT_VAR(group_items);
		array_init(group_items);

		PHALCON_OBS_VAR(group_fields);
		phalcon_array_fetch_quick_string(&group_fields, definition, SS("group"), 7349554UL, PH_NOISY);

		phalcon_is_iterable(group_fields, &ah4, &hp4, 0, 0);

		while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {

			PHALCON_GET_HVALUE(group_field);

			PHALCON_CALL_METHOD(&group_expression, this_ptr, "getsqlexpression", group_field, escape_char);
			phalcon_array_append(&group_items, group_expression, PH_SEPARATE);

			zend_hash_move_forward_ex(ah4, &hp4);
		}

		PHALCON_INIT_VAR(group_sql);
		phalcon_fast_join_str(group_sql, SL(", "), group_items TSRMLS_CC);

		PHALCON_INIT_VAR(group_clause);
		PHALCON_CONCAT_SV(group_clause, " GROUP BY ", group_sql);
		phalcon_concat_self(&sql, group_clause TSRMLS_CC);
	}

	if (phalcon_array_isset_quick_string(definition, SS("having"), 876572994UL)) {
		PHALCON_OBS_VAR(having_conditions);
		phalcon_array_fetch_quick_string(&having_conditions, definition, SS("having"), 876572994UL, PH_NOISY);

		PHALCON_CALL_METHOD(&having_expression, this_ptr, "getsqlexpression", having_conditions, escape_char);
		PHALCON_SCONCAT_SV(sql, " HAVING ", having_expression);
	}

	if (phalcon_array_isset_quick_string(definition, SS("order"), 320020033UL)) {

		PHALCON_OBS_VAR(order_fields);
		phalcon_array_fetch_quick_string(&order_fields, definition, SS("order"), 320020033UL, PH_NOISY);

		PHALCON_INIT_VAR(order_items);
		array_init(order_items);

		phalcon_is_iterable(order_fields, &ah5, &hp5, 0, 0);

		while (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) == SUCCESS) {

			PHALCON_GET_HVALUE(order_item);

			PHALCON_OBS_NVAR(order_expression);
			phalcon_array_fetch_long(&order_expression, order_item, 0, PH_NOISY);

			PHALCON_CALL_METHOD(&order_sql_item, this_ptr, "getsqlexpression", order_expression, escape_char);

			if (phalcon_array_isset_long(order_item, 1)) {
				PHALCON_OBS_NVAR(sql_order_type);
				phalcon_array_fetch_long(&sql_order_type, order_item, 1, PH_NOISY);

				PHALCON_INIT_NVAR(order_sql_item_type);
				PHALCON_CONCAT_VSV(order_sql_item_type, order_sql_item, " ", sql_order_type);
			} else {
				PHALCON_CPY_WRT(order_sql_item_type, order_sql_item);
			}

			phalcon_array_append(&order_items, order_sql_item_type, PH_SEPARATE);

			zend_hash_move_forward_ex(ah5, &hp5);
		}

		PHALCON_INIT_VAR(order_sql);
		phalcon_fast_join_str(order_sql, SL(", "), order_items TSRMLS_CC);
		PHALCON_SCONCAT_SV(sql, " ORDER BY ", order_sql);
	}

	if (phalcon_array_isset_string_fetch(&limit_value, definition, SS("limit"))) {
		if (likely(Z_TYPE_P(limit_value) == IS_ARRAY)) {
			if (likely(phalcon_array_isset_string_fetch(&number, limit_value, SS("number")))) {
				PHALCON_OBS_NVAR(tmp1);
				phalcon_array_fetch_quick_string(&tmp1, number, SS("value"), 574111618UL, PH_NOISY);

				if (phalcon_array_isset_string_fetch(&offset, limit_value, SS("offset"))) {
					PHALCON_OBS_NVAR(tmp2);
					phalcon_array_fetch_quick_string(&tmp2, offset, SS("value"), 574111618UL, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(tmp2);
					ZVAL_LONG(tmp2, 0);
				}

				z_one = PHALCON_GLOBAL(z_one);

				PHALCON_INIT_VAR(ini_range);
				phalcon_add_function(ini_range, tmp2, z_one TSRMLS_CC);

				PHALCON_INIT_VAR(end_range);
				phalcon_add_function(end_range, tmp2, tmp1 TSRMLS_CC);

				PHALCON_INIT_VAR(sql_limit);
				PHALCON_SCONCAT_SVSVSV(sql_limit,"SELECT Z2.* FROM (SELECT Z1.*, ROWNUM DB_ROWNUM FROM ( ", sql, " ) Z1 ) Z2 WHERE Z2.DB_ROWNUM BETWEEN ", ini_range , " AND ",  end_range );
				PHALCON_CPY_WRT(sql, sql_limit);
			}
		} else {

			PHALCON_INIT_VAR(ini_range);
			ZVAL_LONG(ini_range, 1);

			PHALCON_CPY_WRT(end_range, limit_value);

			PHALCON_INIT_VAR(sql_limit);
			PHALCON_SCONCAT_SVSVSV(sql_limit,"SELECT Z2.* FROM (SELECT Z1.*, ROWNUM DB_ROWNUM FROM ( ", sql, " ) Z1 ) Z2 WHERE Z2.DB_ROWNUM BETWEEN ", ini_range , " AND ",  end_range );
			PHALCON_CPY_WRT(sql, sql_limit);
		}
	}

	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, supportsSavepoints){


	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Db_Dialect_Oracle, supportsReleaseSavepoints){


	RETURN_FALSE;
}







zend_class_entry *phalcon_db_dialect_postgresql_ce;

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnDefinition);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, modifyColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, _getTableOptions);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createTable);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropTable);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createView);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropView);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableExists);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, viewExists);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeColumns);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listTables);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listViews);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeIndexes);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeReferences);
static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableOptions);

static const zend_function_entry phalcon_db_dialect_postgresql_method_entry[] = {
	PHP_ME(Phalcon_Db_Dialect_Postgresql, getColumnDefinition, arginfo_phalcon_db_dialectinterface_getcolumndefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, addColumn, arginfo_phalcon_db_dialectinterface_addcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, modifyColumn, arginfo_phalcon_db_dialectinterface_modifycolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropColumn, arginfo_phalcon_db_dialectinterface_dropcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, addIndex, arginfo_phalcon_db_dialectinterface_addindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropIndex, arginfo_phalcon_db_dialectinterface_dropindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, addPrimaryKey, arginfo_phalcon_db_dialectinterface_addprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropPrimaryKey, arginfo_phalcon_db_dialectinterface_dropprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, addForeignKey, arginfo_phalcon_db_dialectinterface_addforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropForeignKey, arginfo_phalcon_db_dialectinterface_dropforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, _getTableOptions, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, createTable, arginfo_phalcon_db_dialectinterface_createtable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropTable, arginfo_phalcon_db_dialectinterface_droptable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, createView, arginfo_phalcon_db_dialectinterface_createview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, dropView, arginfo_phalcon_db_dialectinterface_dropview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, tableExists, arginfo_phalcon_db_dialectinterface_tableexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, viewExists, arginfo_phalcon_db_dialectinterface_viewexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, describeColumns, arginfo_phalcon_db_dialectinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, listTables, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, listViews, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, describeIndexes, arginfo_phalcon_db_dialectinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, describeReferences, arginfo_phalcon_db_dialectinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Postgresql, tableOptions, arginfo_phalcon_db_dialectinterface_tableoptions, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Postgresql){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Postgresql, db_dialect_postgresql, phalcon_db_dialect_ce, phalcon_db_dialect_postgresql_method_entry, 0);

	zend_declare_property_string(phalcon_db_dialect_postgresql_ce, SL("_escapeChar"), "\"", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_dialect_postgresql_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, getColumnDefinition){

	zval *column, *size = NULL, *column_type = NULL, *column_sql = NULL;
	zval *scale = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	
	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an object compatible with Phalcon\\Db\\ColumnInterface");
		return;
	}
	
	PHALCON_CALL_METHOD(&size, column, "getsize");
	PHALCON_CALL_METHOD(&column_type, column, "gettype");

	PHALCON_INIT_VAR(column_sql);
	switch (phalcon_get_intval(column_type)) {
	
		case 0:
			ZVAL_STRING(column_sql, "INT", 1);
			break;
	
		case 1:
			ZVAL_STRING(column_sql, "DATE", 1);
			break;
	
		case 2:
			PHALCON_CONCAT_SVS(column_sql, "CHARACTER VARYING(", size, ")");
			break;
	
		case 3:
			PHALCON_CALL_METHOD(&scale, column, "getscale");
			PHALCON_CONCAT_SVSVS(column_sql, "NUMERIC(", size, ",", scale, ")");
			break;
	
		case 4:
			ZVAL_STRING(column_sql, "TIMESTAMP", 1);
			break;
	
		case 5:
			PHALCON_CONCAT_SVS(column_sql, "CHARACTER(", size, ")");
			break;
	
		case 6:
			ZVAL_STRING(column_sql, "TEXT", 1);
			break;
	
		case 7:
			ZVAL_STRING(column_sql, "FLOAT", 1);
			break;
	
		case 8:
			ZVAL_STRING(column_sql, "SMALLINT(1)", 1);
			break;
	
		default:
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized PostgreSQL data type");
			return;
	
	}
	
	RETURN_CTOR(column_sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addColumn){

	zval *table_name, *schema_name, *column;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, modifyColumn){

	zval *table_name, *schema_name, *column;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropColumn){

	zval *table_name, *schema_name, *column_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &column_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addIndex){

	zval *table_name, *schema_name, *index;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropIndex){

	zval *table_name, *schema_name, *index_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addPrimaryKey){

	zval *table_name, *schema_name, *index;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropPrimaryKey){

	zval *table_name, *schema_name;

	phalcon_fetch_params(0, 2, 0, &table_name, &schema_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, addForeignKey){

	zval *table_name, *schema_name, *reference;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &reference);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropForeignKey){

	zval *table_name, *schema_name, *reference_name;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &reference_name);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, _getTableOptions){

	zval *definition;

	phalcon_fetch_params(0, 1, 0, &definition);
	
	RETURN_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createTable){

	zval *table_name, *schema_name, *definition;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &definition);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &table_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, ".", table_name);
	} else {
		table = table_name;
	}

	PHALCON_INIT_VAR(sql);
	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SV(sql, "DROP TABLE IF EXISTS ", table);
	} else {
		PHALCON_CONCAT_SV(sql, "DROP TABLE ", table);
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, createView){

	zval *view_name, *definition, *schema_name, *view_sql;
	zval *view = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &view_name, &definition, &schema_name);
	
	if (!phalcon_array_isset_quick_string(definition, SS("sql"), 2090732981UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'sql' is required in the definition array");
		return;
	}
	
	PHALCON_OBS_VAR(view_sql);
	phalcon_array_fetch_quick_string(&view_sql, definition, SS("sql"), 2090732981UL, PH_NOISY);
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, view_name, ".", schema_name);
	} else {
		PHALCON_CPY_WRT(view, view_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVSV(sql, "CREATE VIEW ", view, " AS ", view_sql);
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, dropView){

	zval *view_name, *schema_name, *if_exists = NULL, *view = NULL;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &view_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, view_name, ".", schema_name);
	} else {
		PHALCON_CPY_WRT(view, view_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP VIEW IF EXISTS ", view);
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SV(sql, "DROP VIEW ", view);
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableExists){

	zval *table_name, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table_name, &schema_name);
	
	if (!schema_name) {
		PHALCON_INIT_VAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM information_schema.tables WHERE table_schema = '", schema_name, "' AND table_name='", table_name, "'");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM information_schema.tables WHERE table_schema = 'public' AND table_name='", table_name, "'");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, viewExists){

	zval *view_name, *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &view_name, &schema_name);
	
	if (schema_name && zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM pg_views WHERE viewname='", view_name, "' AND schemaname='", schema_name, "'");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM pg_views WHERE viewname='", view_name, "'");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeColumns){

	zval *table, *schema = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		PHALCON_INIT_VAR(schema);
	}
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVSVS(sql, "SELECT DISTINCT c.column_name AS Field, c.data_type AS Type, c.character_maximum_length AS Size, c.numeric_precision AS NumericSize, c.numeric_scale AS NumericScale, c.is_nullable AS Null, CASE WHEN pkc.column_name NOTNULL THEN 'PRI' ELSE '' END AS Key, CASE WHEN c.data_type LIKE '%int%' AND c.column_default LIKE '%nextval%' THEN 'auto_increment' ELSE '' END AS Extra, c.ordinal_position AS Position FROM information_schema.columns c LEFT JOIN ( SELECT kcu.column_name, kcu.table_name, kcu.table_schema FROM information_schema.table_constraints tc INNER JOIN information_schema.key_column_usage kcu on (kcu.constraint_name = tc.constraint_name and kcu.table_name=tc.table_name and kcu.table_schema=tc.table_schema) WHERE tc.constraint_type='PRIMARY KEY') pkc ON (c.column_name=pkc.column_name AND c.table_schema = pkc.table_schema AND c.table_name=pkc.table_name) WHERE c.table_schema='", schema, "' AND c.table_name='", table, "' ORDER BY c.ordinal_position");
	} else {
		PHALCON_INIT_NVAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT DISTINCT c.column_name AS Field, c.data_type AS Type, c.character_maximum_length AS Size, c.numeric_precision AS NumericSize, c.numeric_scale AS NumericScale, c.is_nullable AS Null, CASE WHEN pkc.column_name NOTNULL THEN 'PRI' ELSE '' END AS Key, CASE WHEN c.data_type LIKE '%int%' AND c.column_default LIKE '%nextval%' THEN 'auto_increment' ELSE '' END AS Extra, c.ordinal_position AS Position FROM information_schema.columns c LEFT JOIN ( SELECT kcu.column_name, kcu.table_name, kcu.table_schema FROM information_schema.table_constraints tc INNER JOIN information_schema.key_column_usage kcu on (kcu.constraint_name = tc.constraint_name and kcu.table_name=tc.table_name and kcu.table_schema=tc.table_schema) WHERE tc.constraint_type='PRIMARY KEY') pkc ON (c.column_name=pkc.column_name AND c.table_schema = pkc.table_schema AND c.table_name=pkc.table_name) WHERE c.table_schema='public' AND c.table_name='", table, "' ORDER BY c.ordinal_position");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listTables){

	zval *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &schema_name);
	
	if (!schema_name) {
		PHALCON_INIT_VAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT table_name FROM information_schema.tables WHERE table_schema = '", schema_name, "' ORDER BY table_name");
	} else {
		PHALCON_INIT_NVAR(sql);
		ZVAL_STRING(sql, "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name", 1);
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, listViews){

	zval *schema_name = NULL, *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &schema_name);
	
	if (!schema_name) {
		PHALCON_INIT_VAR(schema_name);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(sql);
		PHALCON_CONCAT_SVS(sql, "SELECT viewname AS view_name FROM pg_views WHERE schemaname = '", schema_name, "' ORDER BY view_name");
	} else {
		PHALCON_INIT_NVAR(sql);
		ZVAL_STRING(sql, "SELECT viewname AS view_name FROM pg_views WHERE schemaname = 'public' ORDER BY view_name", 1);
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeIndexes){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		PHALCON_INIT_VAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "SELECT 0 as c0, t.relname as table_name, i.relname as key_name, 3 as c3, a.attname as column_name FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND a.attnum = ANY(ix.indkey) AND t.relkind = 'r' AND t.relname = '", table, "' ORDER BY t.relname, i.relname;");
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, describeReferences){

	zval *table, *schema = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		PHALCON_INIT_VAR(schema);
	}
	
	PHALCON_INIT_VAR(sql);
	ZVAL_STRING(sql, "SELECT tc.table_name as TABLE_NAME, kcu.column_name as COLUMN_NAME, tc.constraint_name as CONSTRAINT_NAME, tc.table_catalog as REFERENCED_TABLE_SCHEMA, ccu.table_name AS REFERENCED_TABLE_NAME, ccu.column_name AS REFERENCED_COLUMN_NAME FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND ", 1);
	if (zend_is_true(schema)) {
		PHALCON_SCONCAT_SVSVS(sql, "tc.table_schema = '", schema, "' AND tc.table_name='", table, "'");
	} else {
		PHALCON_SCONCAT_SVS(sql, "tc.table_name='", table, "'");
	}
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Postgresql, tableOptions){

	zval *table, *schema = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &table, &schema);
	
	if (!schema) {
		PHALCON_INIT_VAR(schema);
	}
	
	RETURN_MM_EMPTY_STRING();
}






zend_class_entry *phalcon_db_dialect_sqlite_ce;

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, getColumnDefinition);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, modifyColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropColumn);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropPrimaryKey);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropForeignKey);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, _getTableOptions);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, createTable);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropTable);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, createView);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropView);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableExists);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, viewExists);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeColumns);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, listTables);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, listViews);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndexes);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndex);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeReferences);
static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableOptions);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_dialect_sqlite_describeindex, 0, 0, 1)
	ZEND_ARG_INFO(0, indexName)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_dialect_sqlite_method_entry[] = {
	PHP_ME(Phalcon_Db_Dialect_Sqlite, getColumnDefinition, arginfo_phalcon_db_dialectinterface_getcolumndefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, addColumn, arginfo_phalcon_db_dialectinterface_addcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, modifyColumn, arginfo_phalcon_db_dialectinterface_modifycolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropColumn, arginfo_phalcon_db_dialectinterface_dropcolumn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, addIndex, arginfo_phalcon_db_dialectinterface_addindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropIndex, arginfo_phalcon_db_dialectinterface_dropindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, addPrimaryKey, arginfo_phalcon_db_dialectinterface_addprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropPrimaryKey, arginfo_phalcon_db_dialectinterface_dropprimarykey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, addForeignKey, arginfo_phalcon_db_dialectinterface_addforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropForeignKey, arginfo_phalcon_db_dialectinterface_dropforeignkey, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, _getTableOptions, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, createTable, arginfo_phalcon_db_dialectinterface_createtable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropTable, arginfo_phalcon_db_dialectinterface_droptable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, createView, arginfo_phalcon_db_dialectinterface_createview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, dropView, arginfo_phalcon_db_dialectinterface_dropview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, tableExists, arginfo_phalcon_db_dialectinterface_tableexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, viewExists, arginfo_phalcon_db_dialectinterface_viewexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, describeColumns, arginfo_phalcon_db_dialectinterface_describecolumns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, listTables, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, listViews, arginfo_phalcon_db_dialectinterface_listtables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, describeIndexes, arginfo_phalcon_db_dialectinterface_describeindexes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, describeIndex, arginfo_phalcon_db_dialect_sqlite_describeindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, describeReferences, arginfo_phalcon_db_dialectinterface_describereferences, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Dialect_Sqlite, tableOptions, arginfo_phalcon_db_dialectinterface_tableoptions, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Dialect_Sqlite){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Db\\Dialect, Sqlite, db_dialect_sqlite, phalcon_db_dialect_ce, phalcon_db_dialect_sqlite_method_entry, 0);

	zend_declare_property_string(phalcon_db_dialect_sqlite_ce, SL("_escapeChar"), "\"", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_db_dialect_sqlite_ce TSRMLS_CC, 1, phalcon_db_dialectinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, getColumnDefinition){

	zval *column, *size = NULL, *column_type = NULL, *column_sql = NULL;
	zval *scale = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	
	if (Z_TYPE_P(column) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Column definition must be an instance of Phalcon\\Db\\Column");
		return;
	}
	
	PHALCON_CALL_METHOD(&size, column, "getsize");
	PHALCON_CALL_METHOD(&column_type, column, "gettype");
	
	switch (phalcon_get_intval(column_type)) {
	
		case 0:
			PHALCON_INIT_VAR(column_sql);
			ZVAL_STRING(column_sql, "INT", 1);
			break;
	
		case 1:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "DATE", 1);
			break;
	
		case 2:
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVS(column_sql, "VARCHAR(", size, ")");
			break;
	
		case 3:
			PHALCON_CALL_METHOD(&scale, column, "getscale");
	
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVSVS(column_sql, "NUMERIC(", size, ",", scale, ")");
			break;
	
		case 4:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "TIMESTAMP", 1);
			break;
	
		case 5:
			PHALCON_INIT_NVAR(column_sql);
			PHALCON_CONCAT_SVS(column_sql, "CHARACTER(", size, ")");
			break;
	
		case 6:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "TEXT", 1);
			break;
	
		case 7:
			PHALCON_INIT_NVAR(column_sql);
			ZVAL_STRING(column_sql, "FLOAT", 1);
			break;
	
		default:
			PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "Unrecognized SQLite data type");
			return;
	
	}
	
	RETURN_CTOR(column_sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addColumn){

	zval *table_name, *schema_name, *column, *sql = NULL, *name = NULL;
	zval *column_definition = NULL, *is_not_null = NULL, *is_autoincrement = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &column);

	PHALCON_VERIFY_INTERFACE_EX(column, phalcon_db_columninterface_ce, phalcon_db_exception_ce, 1);

	PHALCON_INIT_VAR(sql);
	if (zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(sql, "ALTER TABLE \"", schema_name, "\".\"", table_name, "\" ADD COLUMN ");
	}
	else {
		PHALCON_CONCAT_SVS(sql, "ALTER TABLE \"", table_name, "\" ADD COLUMN ");
	}

	PHALCON_CALL_METHOD(&name, column, "getname");
	PHALCON_CALL_METHOD(&column_definition, this_ptr, "getcolumndefinition", column);
	PHALCON_SCONCAT_SVSV(sql, "\"", name, "\" ", column_definition);

	PHALCON_CALL_METHOD(&is_not_null, column, "isnotnull");
	if (zend_is_true(is_not_null)) {
		phalcon_concat_self_str(&sql, SL(" NOT NULL") TSRMLS_CC);
	}

	PHALCON_CALL_METHOD(&is_autoincrement, column, "isautoincrement");
	if (zend_is_true(is_autoincrement)) {
		phalcon_concat_self_str(&sql, SL(" PRIMARY KEY AUTOINCREMENT") TSRMLS_CC);
	}

	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, modifyColumn){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Altering a DB column is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropColumn){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Dropping DB column is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addIndex){

	zval *table_name, *schema_name, *index, *sql = NULL, *columns = NULL;
	zval *quoted_column_list = NULL, *name = NULL;
	zval *index_type = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index);
	
	PHALCON_VERIFY_INTERFACE_EX(index, phalcon_db_indexinterface_ce, phalcon_db_exception_ce, 1);

	PHALCON_CALL_METHOD(&name, index, "getname");
	PHALCON_CALL_METHOD(&index_type, index, "gettype");

	PHALCON_INIT_VAR(sql);
	if (zend_is_true(schema_name)) {
		if (index_type && Z_TYPE_P(index_type) == IS_STRING && Z_STRLEN_P(index_type) > 0) {
			PHALCON_CONCAT_SVSVSVSVS(sql, "CREATE ", index_type, " INDEX \"", schema_name, "\".\"", name, "\" ON \"", table_name, "\" (");
		} else {
			PHALCON_CONCAT_SVSVSVS(sql, "CREATE INDEX \"", schema_name, "\".\"", name, "\" ON \"", table_name, "\" (");
		}
	} else if (index_type && Z_TYPE_P(index_type) == IS_STRING && Z_STRLEN_P(index_type) > 0) {
		PHALCON_CONCAT_SVSVSVS(sql, "CREATE ", index_type, " INDEX \"", name, "\" ON \"", table_name, "\" (");
	} else {
		PHALCON_CONCAT_SVSVS(sql, "CREATE INDEX \"", name, "\" ON \"", table_name, "\" (");
	}

	PHALCON_CALL_METHOD(&columns, index, "getcolumns");
	PHALCON_CALL_METHOD(&quoted_column_list, this_ptr, "getcolumnlist", columns);

	PHALCON_SCONCAT_VS(sql, quoted_column_list, ")");
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropIndex){

	zval *table_name, *schema_name, *index_name;
	zval *sql = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &table_name, &schema_name, &index_name);

	PHALCON_INIT_VAR(sql);
	if (zend_is_true(schema_name)) {
		PHALCON_CONCAT_SVSVS(sql, "DROP INDEX \"", schema_name, "\".\"", index_name, "\"");
	}
	else {
		PHALCON_CONCAT_SVS(sql, "DROP INDEX \"", index_name, "\"");
	}

	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addPrimaryKey){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Adding a primary key after table has been created is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropPrimaryKey){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Removing a primary key after table has been created is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, addForeignKey){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Adding a foreign key constraint to an existing table is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropForeignKey){

	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Dropping a foreign key constraint is not supported by SQLite");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, _getTableOptions){

	zval *definition;

	phalcon_fetch_params(0, 1, 0, &definition);

	array_init(return_value);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, createTable){

	zval *table_name, *schema_name, *definition;

	phalcon_fetch_params(0, 3, 0, &table_name, &schema_name, &definition);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Not implemented yet");
	return;
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropTable){

	zval *table_name, *schema_name, *if_exists = NULL, *table = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &table_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(table);
		PHALCON_CONCAT_VSV(table, schema_name, "\".\"", table_name);
	} else {
		table = table_name;
	}

	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SVS(return_value, "DROP TABLE IF EXISTS \"", table, "\"");
	} else {
		PHALCON_CONCAT_SVS(return_value, "DROP TABLE \"", table, "\"");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, createView){

	zval *view_name, *definition, *schema_name, *view_sql;
	zval *view = NULL, *sql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &view_name, &definition, &schema_name);
	
	if (!phalcon_array_isset_quick_string(definition, SS("sql"), 2090732981UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_db_exception_ce, "The index 'sql' is required in the definition array");
		return;
	}
	
	PHALCON_OBS_VAR(view_sql);
	phalcon_array_fetch_quick_string(&view_sql, definition, SS("sql"), 2090732981UL, PH_NOISY);
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, schema_name, "\".\"", view_name);
	} else {
		PHALCON_CPY_WRT(view, view_name);
	}
	
	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVSV(sql, "CREATE VIEW \"", view, "\" AS ", view_sql);
	
	RETURN_CTOR(sql);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, dropView){

	zval *view_name, *schema_name, *if_exists = NULL, *view = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &view_name, &schema_name, &if_exists);
	
	if (!if_exists) {
		if_exists = PHALCON_GLOBAL(z_true);
	}
	
	if (zend_is_true(schema_name)) {
		PHALCON_INIT_VAR(view);
		PHALCON_CONCAT_VSV(view, schema_name, "\".\"", view_name);
	} else {
		PHALCON_CPY_WRT(view, view_name);
	}
	if (zend_is_true(if_exists)) {
		PHALCON_CONCAT_SVS(return_value, "DROP VIEW IF EXISTS \"", view, "\"");
	} else {
		PHALCON_CONCAT_SVS(return_value, "DROP VIEW \"", view, "\"");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableExists){

	zval *table_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &table_name, &schema_name);
	
	PHALCON_CONCAT_SVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM sqlite_master WHERE type='table' AND tbl_name='", table_name, "'");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, viewExists){

	zval *view_name, *schema_name = NULL;

	phalcon_fetch_params(0, 1, 1, &view_name, &schema_name);
	
	PHALCON_CONCAT_SVS(return_value, "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM sqlite_master WHERE type='view' AND tbl_name='", view_name, "'");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeColumns){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	PHALCON_CONCAT_SVS(return_value, "PRAGMA table_info('", table, "')");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, listTables){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);
	
	RETURN_STRING("SELECT tbl_name FROM sqlite_master WHERE type = 'table' ORDER BY tbl_name", 1);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, listViews){

	zval *schema_name = NULL;

	phalcon_fetch_params(0, 0, 1, &schema_name);

	RETURN_STRING("SELECT tbl_name FROM sqlite_master WHERE type = 'view' ORDER BY tbl_name", 1);
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndexes){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	PHALCON_CONCAT_SVS(return_value, "PRAGMA index_list('", table, "')");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeIndex){

	zval *index_name;

	phalcon_fetch_params(0, 1, 0, &index_name);
	
	PHALCON_CONCAT_SVS(return_value, "PRAGMA index_info('", index_name, "')");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, describeReferences){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);
	
	PHALCON_CONCAT_SVS(return_value, "PRAGMA foreign_key_list('", table, "')");
}

static PHP_METHOD(Phalcon_Db_Dialect_Sqlite, tableOptions){

	zval *table, *schema = NULL;

	phalcon_fetch_params(0, 1, 1, &table, &schema);

	RETURN_EMPTY_STRING();
}





zend_class_entry *phalcon_db_profiler_item_ce;

static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLStatement);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLStatement);
static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLVariables);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLVariables);
static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLBindTypes);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLBindTypes);
static PHP_METHOD(Phalcon_Db_Profiler_Item, setInitialTime);
static PHP_METHOD(Phalcon_Db_Profiler_Item, setFinalTime);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getInitialTime);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getFinalTime);
static PHP_METHOD(Phalcon_Db_Profiler_Item, getTotalElapsedSeconds);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_item_setsqlstatement, 0, 0, 1)
	ZEND_ARG_INFO(0, sqlStatement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_item_setsqlvariables, 0, 0, 1)
	ZEND_ARG_INFO(0, sqlVariables)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_item_setsqlbindtypes, 0, 0, 1)
	ZEND_ARG_INFO(0, sqlBindTypes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_item_setinitialtime, 0, 0, 1)
	ZEND_ARG_INFO(0, initialTime)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_profiler_item_setfinaltime, 0, 0, 1)
	ZEND_ARG_INFO(0, finalTime)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_profiler_item_method_entry[] = {
	PHP_ME(Phalcon_Db_Profiler_Item, setSQLStatement, arginfo_phalcon_db_profiler_item_setsqlstatement, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getSQLStatement, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, setSQLVariables, arginfo_phalcon_db_profiler_item_setsqlvariables, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getSQLVariables, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, setSQLBindTypes, arginfo_phalcon_db_profiler_item_setsqlbindtypes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getSQLBindTypes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, setInitialTime, arginfo_phalcon_db_profiler_item_setinitialtime, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, setFinalTime, arginfo_phalcon_db_profiler_item_setfinaltime, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getInitialTime, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getFinalTime, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Profiler_Item, getTotalElapsedSeconds, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Profiler_Item){

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Profiler, Item, db_profiler_item, phalcon_db_profiler_item_method_entry, 0);

	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_sqlVariables"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_sqlBindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_initialTime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_profiler_item_ce, SL("_finalTime"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLStatement){

	zval *sql_statement;

	phalcon_fetch_params(0, 1, 0, &sql_statement);
	
	phalcon_update_property_this_quick(this_ptr, SL("_sqlStatement"), sql_statement, 18972457UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLStatement){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlStatement", 18972457UL);
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLVariables){

	zval *sql_variables;

	phalcon_fetch_params(0, 1, 0, &sql_variables);
	
	phalcon_update_property_this_quick(this_ptr, SL("_sqlVariables"), sql_variables, 3213579853UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLVariables){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlVariables", 3213579853UL);
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, setSQLBindTypes){

	zval *sql_bindtypes;

	phalcon_fetch_params(0, 1, 0, &sql_bindtypes);

	phalcon_update_property_this_quick(this_ptr, SL("_sqlBindTypes"), sql_bindtypes, 3288357222UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getSQLBindTypes){


	RETURN_MEMBER_QUICK(this_ptr, "_sqlBindTypes", 3288357222UL);
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, setInitialTime){

	zval *initial_time;

	phalcon_fetch_params(0, 1, 0, &initial_time);
	
	phalcon_update_property_this_quick(this_ptr, SL("_initialTime"), initial_time, 3347691997UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, setFinalTime){

	zval *final_time;

	phalcon_fetch_params(0, 1, 0, &final_time);
	
	phalcon_update_property_this_quick(this_ptr, SL("_finalTime"), final_time, 2101629981UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getInitialTime){


	RETURN_MEMBER_QUICK(this_ptr, "_initialTime", 3347691997UL);
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getFinalTime){


	RETURN_MEMBER_QUICK(this_ptr, "_finalTime", 2101629981UL);
}

static PHP_METHOD(Phalcon_Db_Profiler_Item, getTotalElapsedSeconds){

	zval *final_time, *initial_time;

	final_time   = phalcon_fetch_nproperty_this(this_ptr, SL("_finalTime"), PH_NOISY TSRMLS_CC);
	initial_time = phalcon_fetch_nproperty_this(this_ptr, SL("_initialTime"), PH_NOISY TSRMLS_CC);
	sub_function(return_value, final_time, initial_time TSRMLS_CC);
}





#include <ext/pdo/php_pdo_driver.h>


zend_class_entry *phalcon_db_result_pdo_ce;

static PHP_METHOD(Phalcon_Db_Result_Pdo, __construct);
static PHP_METHOD(Phalcon_Db_Result_Pdo, execute);
static PHP_METHOD(Phalcon_Db_Result_Pdo, fetch);
static PHP_METHOD(Phalcon_Db_Result_Pdo, fetchArray);
static PHP_METHOD(Phalcon_Db_Result_Pdo, fetchAll);
static PHP_METHOD(Phalcon_Db_Result_Pdo, numRows);
static PHP_METHOD(Phalcon_Db_Result_Pdo, dataSeek);
static PHP_METHOD(Phalcon_Db_Result_Pdo, setFetchMode);
static PHP_METHOD(Phalcon_Db_Result_Pdo, getInternalResult);
static PHP_METHOD(Phalcon_Db_Result_Pdo, nextRowset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_db_result___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, connection)
	ZEND_ARG_INFO(0, result)
	ZEND_ARG_INFO(0, sqlStatement)
	ZEND_ARG_INFO(0, bindParams)
	ZEND_ARG_INFO(0, bindTypes)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_db_result_pdo_method_entry[] = {
	PHP_ME(Phalcon_Db_Result_Pdo, __construct, arginfo_phalcon_db_result___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Db_Result_Pdo, execute, arginfo_phalcon_db_resultinterface_execute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, fetch, arginfo_phalcon_db_resultinterface_fetch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, fetchArray, arginfo_phalcon_db_resultinterface_fetcharray, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, fetchAll, arginfo_phalcon_db_resultinterface_fetchall, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, numRows, arginfo_phalcon_db_resultinterface_numrows, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, dataSeek, arginfo_phalcon_db_resultinterface_dataseek, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, setFetchMode, arginfo_phalcon_db_resultinterface_setfetchmode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, getInternalResult, arginfo_phalcon_db_resultinterface_getinternalresult, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Db_Result_Pdo, nextRowset, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Db_Result_Pdo){

	PHALCON_REGISTER_CLASS(Phalcon\\Db\\Result, Pdo, db_result_pdo, phalcon_db_result_pdo_method_entry, 0);

	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_db_result_pdo_ce, SL("_fetchMode"), PDO_FETCH_OBJ, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_pdoStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_sqlStatement"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_bindParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_db_result_pdo_ce, SL("_bindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_db_result_pdo_ce, SL("_rowCount"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, __construct){

	zval *connection, *result, *sql_statement = NULL, *bind_params = NULL;
	zval *bind_types = NULL;

	phalcon_fetch_params(0, 2, 3, &connection, &result, &sql_statement, &bind_params, &bind_types);
	
	if (!sql_statement) {
		sql_statement = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(result) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_db_exception_ce, "Invalid PDOStatement supplied to Phalcon\\Db\\Result\\Pdo");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_connection"), connection, 3057302292UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_pdoStatement"), result, 650036348UL TSRMLS_CC);
	if (Z_TYPE_P(sql_statement) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_sqlStatement"), sql_statement, 18972457UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_params) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), bind_params, 2293392709UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), bind_types, 514734038UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, execute){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	pdo_statement = phalcon_fetch_nproperty_this(this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo_statement, "execute");
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, fetch){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	pdo_statement = phalcon_fetch_nproperty_this(this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo_statement, "fetch");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, fetchArray){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	pdo_statement = phalcon_fetch_nproperty_this(this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo_statement, "fetch");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, fetchAll){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	pdo_statement = phalcon_fetch_nproperty_this(this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo_statement, "fetchall");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, numRows){

	zval *row_count = NULL, *connection, *type = NULL, *pdo_statement = NULL;
	zval *sql_statement, *bind_params, *bind_types;
	zval *matches, *pattern, *match, *else_clauses;
	zval *sql, *result = NULL, *row = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(row_count);
	phalcon_read_property_this(&row_count, this_ptr, SL("_rowCount"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(row_count)) {
	
		PHALCON_OBS_VAR(connection);
		phalcon_read_property_this(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&type, connection, "gettype");
	
		if (PHALCON_IS_STRING(type, "mysql") || PHALCON_IS_STRING(type, "pgsql")) {
			PHALCON_OBS_VAR(pdo_statement);
			phalcon_read_property_this(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	
			PHALCON_CALL_METHOD(&row_count, pdo_statement, "rowcount");
		}
	
		if (PHALCON_IS_FALSE(row_count)) {
	
			PHALCON_OBS_VAR(sql_statement);
			phalcon_read_property_this(&sql_statement, this_ptr, SL("_sqlStatement"), PH_NOISY TSRMLS_CC);
	
			if (!phalcon_start_with_str(sql_statement, SL("SELECT COUNT(*) "))) {
	
				PHALCON_OBS_VAR(bind_params);
				phalcon_read_property_this(&bind_params, this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);
	
				PHALCON_OBS_VAR(bind_types);
				phalcon_read_property_this(&bind_types, this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(matches);
	
				PHALCON_INIT_VAR(pattern);
				ZVAL_STRING(pattern, "/^SELECT\\s+(.*)$/i", 1);
	
				PHALCON_INIT_VAR(match);
				RETURN_MM_ON_FAILURE(phalcon_preg_match(match, pattern, sql_statement, matches TSRMLS_CC));
	
				if (zend_is_true(match)) {
					PHALCON_OBS_VAR(else_clauses);
					phalcon_array_fetch_long(&else_clauses, matches, 1, PH_NOISY);
	
					PHALCON_INIT_VAR(sql);
					PHALCON_CONCAT_SVS(sql, "SELECT COUNT(*) \"numrows\" FROM (SELECT ", else_clauses, ")");
	
					PHALCON_CALL_METHOD(&result, connection, "query", sql, bind_params, bind_types);
					PHALCON_CALL_METHOD(&row, result, "fetch");
	
					PHALCON_OBS_NVAR(row_count);
					phalcon_array_fetch_quick_string(&row_count, row, SS("numrows"), 887792640UL, PH_NOISY);
				}
			} else {
				PHALCON_INIT_NVAR(row_count);
				ZVAL_LONG(row_count, 1);
			}
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_rowCount"), row_count, 1917183365UL TSRMLS_CC);
	}
	
	RETURN_CCTOR(row_count);
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, dataSeek){

	long number = 0, n;
	zval *connection, *pdo = NULL, *sql_statement;
	zval *bind_params, *bind_types, *statement = NULL;
	zval *temp_statement = NULL;
	pdo_stmt_t *stmt;

	PHALCON_MM_GROW();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l", &number) == FAILURE) {
		RETURN_MM_NULL();
	}

	PHALCON_OBS_VAR(connection);
	phalcon_read_property(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&pdo, connection, "getinternalhandler");

	PHALCON_OBS_VAR(sql_statement);
	phalcon_read_property(&sql_statement, this_ptr, SL("_sqlStatement"), PH_NOISY TSRMLS_CC);

	PHALCON_OBS_VAR(bind_params);
	phalcon_read_property(&bind_params, this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(bind_params) == IS_ARRAY) {

		PHALCON_OBS_VAR(bind_types);
		phalcon_read_property(&bind_types, this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);

		PHALCON_CALL_METHOD(&statement, pdo, "prepare", sql_statement);
		if (Z_TYPE_P(statement) == IS_OBJECT) {
			PHALCON_CALL_METHOD(&temp_statement, connection, "executeprepared", statement, bind_params, bind_types);
			PHALCON_CPY_WRT(statement, temp_statement);
		}

	} else {
		PHALCON_CALL_METHOD(&statement, pdo, "query", sql_statement);
	}

	phalcon_update_property_zval(this_ptr, SL("_pdoStatement"), statement TSRMLS_CC);


	stmt = (pdo_stmt_t*) zend_object_store_get_object(statement TSRMLS_CC);
	if (!stmt->dbh) {
		PHALCON_MM_RESTORE();
		RETURN_FALSE;
	}

	n = -1;
	number--;
	while (n != number) {

		if(!stmt->methods->fetcher(stmt, PDO_FETCH_ORI_NEXT, 0 TSRMLS_CC)) {
			PHALCON_MM_RESTORE();
			RETURN_NULL();
		}

		n++;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, setFetchMode){

	zval *fetch_mode, *fetch_arg1 = NULL, *fetch_arg2 = NULL;
	zval *pdo_statement;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &fetch_mode, &fetch_arg1, &fetch_arg2);

	PHALCON_SEPARATE_PARAM(fetch_mode);
	if (Z_TYPE_P(fetch_mode) != IS_LONG) {
		convert_to_long(fetch_mode);
	}

	PHALCON_OBS_VAR(pdo_statement);
	phalcon_read_property(&pdo_statement, this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);

	if (Z_LVAL_P(fetch_mode) != 0) {
		if (fetch_arg1 && fetch_arg2) {
			PHALCON_CALL_METHOD(NULL, pdo_statement, "setfetchmode", fetch_mode, fetch_arg1, fetch_arg2);
		} else if (fetch_arg1) {
			PHALCON_CALL_METHOD(NULL, pdo_statement, "setfetchmode", fetch_mode, fetch_arg1);
		} else if (fetch_arg2) {
			PHALCON_CALL_METHOD(NULL, pdo_statement, "setfetchmode", fetch_mode, fetch_arg2);
		} else {
			PHALCON_CALL_METHOD(NULL, pdo_statement, "setfetchmode", fetch_mode);
		}
		
		phalcon_update_property_long(this_ptr, SL("_fetchMode"), Z_LVAL_P(fetch_mode) TSRMLS_CC);
	}

	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, getInternalResult){


	RETURN_MEMBER_QUICK(this_ptr, "_pdoStatement", 650036348UL);
}

static PHP_METHOD(Phalcon_Db_Result_Pdo, nextRowset){

	zval *pdo_statement;

	PHALCON_MM_GROW();

	pdo_statement = phalcon_fetch_nproperty_this(this_ptr, SL("_pdoStatement"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(pdo_statement, "nextrowset");

	RETURN_MM();
}





zend_class_entry *phalcon_di_exception_ce;

PHALCON_INIT_CLASS(Phalcon_DI_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI, Exception, di_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_di_factorydefault_ce;

static PHP_METHOD(Phalcon_DI_FactoryDefault, __construct);

static const zend_function_entry phalcon_di_factorydefault_method_entry[] = {
	PHP_ME(Phalcon_DI_FactoryDefault, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_DI_FactoryDefault){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI, FactoryDefault, di_factorydefault, phalcon_di_ce, phalcon_di_factorydefault_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI_FactoryDefault, __construct){

	zval *shared, *name = NULL, *definition = NULL, *router, *dispatcher;
	zval *url, *models_manager, *models_metadata;
	zval *response, *cookies, *request, *filter, *escaper;
	zval *annotations, *security, *crypt, *flash, *flash_session;
	zval *tag, *session, *session_bag, *events_manager;
	zval *transaction_manager, *assets, *services;

	PHALCON_MM_GROW();

	PHALCON_CALL_PARENT(NULL, phalcon_di_factorydefault_ce, this_ptr, "__construct");
	
	shared = PHALCON_GLOBAL(z_true);
	
	PHALCON_INIT_VAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_router);
	
	PHALCON_INIT_VAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Router", 1);
	
	PHALCON_INIT_VAR(router);
	object_init_ex(router, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, router, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_dispatcher);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	object_init_ex(dispatcher, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, dispatcher, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_url);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Url", 1);
	
	PHALCON_INIT_VAR(url);
	object_init_ex(url, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, url, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_modelsManager);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Manager", 1);
	
	PHALCON_INIT_VAR(models_manager);
	object_init_ex(models_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, models_manager, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_modelsMetadata);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\MetaData\\Memory", 1);
	
	PHALCON_INIT_VAR(models_metadata);
	object_init_ex(models_metadata, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, models_metadata, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_response);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Http\\Response", 1);
	
	PHALCON_INIT_VAR(response);
	object_init_ex(response, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, response, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "cookies", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Http\\Response\\Cookies", 1);
	
	PHALCON_INIT_VAR(cookies);
	object_init_ex(cookies, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, cookies, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_request);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Http\\Request", 1);
	
	PHALCON_INIT_VAR(request);
	object_init_ex(request, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, request, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_filter);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Filter", 1);
	
	PHALCON_INIT_VAR(filter);
	object_init_ex(filter, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, filter, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_escaper);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Escaper", 1);
	
	PHALCON_INIT_VAR(escaper);
	object_init_ex(escaper, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, escaper, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "annotations", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Annotations\\Adapter\\Memory", 1);
	
	PHALCON_INIT_VAR(annotations);
	object_init_ex(annotations, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, annotations, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "security", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Security", 1);
	
	PHALCON_INIT_VAR(security);
	object_init_ex(security, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, security, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "crypt", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Crypt", 1);
	
	PHALCON_INIT_VAR(crypt);
	object_init_ex(crypt, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, crypt, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flash", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Direct", 1);
	
	PHALCON_INIT_VAR(flash);
	object_init_ex(flash, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, flash, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "flashSession", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Flash\\Session", 1);
	
	PHALCON_INIT_VAR(flash_session);
	object_init_ex(flash_session, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, flash_session, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "tag", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Tag", 1);
	
	PHALCON_INIT_VAR(tag);
	object_init_ex(tag, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, tag, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_session);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Session\\Adapter\\Files", 1);
	
	PHALCON_INIT_VAR(session);
	object_init_ex(session, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, session, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "sessionBag", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Session\\Bag", 1);
	
	PHALCON_INIT_VAR(session_bag);
	object_init_ex(session_bag, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, session_bag, "__construct", name, definition);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "eventsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Events\\Manager", 1);
	
	PHALCON_INIT_VAR(events_manager);
	object_init_ex(events_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, events_manager, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "transactions", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Transaction\\Manager", 1);
	
	PHALCON_INIT_VAR(transaction_manager);
	object_init_ex(transaction_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, transaction_manager, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "assets", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Assets\\Manager", 1);
	
	PHALCON_INIT_VAR(assets);
	object_init_ex(assets, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, assets, "__construct", name, definition, shared);
	
	PHALCON_INIT_VAR(services);
	array_init_size(services, 21);
	phalcon_array_update_string(&services, ISL(router), router, PH_COPY);
	phalcon_array_update_string(&services, ISL(dispatcher), dispatcher, PH_COPY);
	phalcon_array_update_string(&services, ISL(url), url, PH_COPY);
	phalcon_array_update_string(&services, ISL(modelsManager), models_manager, PH_COPY);
	phalcon_array_update_string(&services, ISL(modelsMetadata), models_metadata, PH_COPY);
	phalcon_array_update_string(&services, ISL(response), response, PH_COPY);
	phalcon_array_update_string(&services, SL("cookies"), cookies, PH_COPY);
	phalcon_array_update_string(&services, ISL(request), request, PH_COPY);
	phalcon_array_update_string(&services, ISL(filter), filter, PH_COPY);
	phalcon_array_update_string(&services, ISL(escaper), escaper, PH_COPY);
	phalcon_array_update_string(&services, SL("security"), security, PH_COPY);
	phalcon_array_update_string(&services, SL("crypt"), crypt, PH_COPY);
	phalcon_array_update_string(&services, SL("annotations"), annotations, PH_COPY);
	phalcon_array_update_string(&services, SL("flash"), flash, PH_COPY);
	phalcon_array_update_string(&services, SL("flashSession"), flash_session, PH_COPY);
	phalcon_array_update_string(&services, SL("tag"), tag, PH_COPY);
	phalcon_array_update_string(&services, ISL(session), session, PH_COPY);
	phalcon_array_update_string(&services, SL("sessionBag"), session_bag, PH_COPY);
	phalcon_array_update_string(&services, SL("eventsManager"), events_manager, PH_COPY);
	phalcon_array_update_string(&services, SL("transactionManager"), transaction_manager, PH_COPY);
	phalcon_array_update_string(&services, SL("assets"), assets, PH_COPY);
	
	phalcon_di_set_services(this_ptr, services TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}







zend_class_entry *phalcon_di_injectable_ce;

static PHP_METHOD(Phalcon_DI_Injectable, setDI);
static PHP_METHOD(Phalcon_DI_Injectable, getDI);
static PHP_METHOD(Phalcon_DI_Injectable, setEventsManager);
static PHP_METHOD(Phalcon_DI_Injectable, getEventsManager);
static PHP_METHOD(Phalcon_DI_Injectable, __get);

static const zend_function_entry phalcon_di_injectable_method_entry[] = {
	PHP_ME(Phalcon_DI_Injectable, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Injectable, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Injectable, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Injectable, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Injectable, __get, arginfo___get, ZEND_ACC_PUBLIC)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_DI_Injectable){

	PHALCON_REGISTER_CLASS(Phalcon\\DI, Injectable, di_injectable, phalcon_di_injectable_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_di_injectable_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_di_injectable_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_di_injectable_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI_Injectable, setDI){

	zval **dependency_injector;

	phalcon_fetch_params_ex(1, 0, &dependency_injector);
	
	PHALCON_VERIFY_INTERFACE_OR_NULL_EX(*dependency_injector, phalcon_diinterface_ce, phalcon_di_exception_ce, 0);
	phalcon_update_property_this(this_ptr, SL("_dependencyInjector"), *dependency_injector TSRMLS_CC);
}

static PHP_METHOD(Phalcon_DI_Injectable, getDI)
{
	zval *dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_RETURN_CALL_CE_STATICW(phalcon_di_ce, "getdefault");
		return;
	}
	
	RETURN_ZVAL(dependency_injector, 1, 0);
}

static PHP_METHOD(Phalcon_DI_Injectable, setEventsManager)
{
	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	PHALCON_VERIFY_INTERFACE_OR_NULL_EX(events_manager, phalcon_events_managerinterface_ce, phalcon_di_exception_ce, 0);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_DI_Injectable, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_DI_Injectable, __get){

	zval **property_name, *dependency_injector = NULL;
	zval *has_service = NULL, *service = NULL, *class_name, *arguments, *result = NULL;

	phalcon_fetch_params_ex(1, 0, &property_name);
	PHALCON_ENSURE_IS_STRING(property_name);

	PHALCON_MM_GROW();

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		dependency_injector = NULL;
		PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");

		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "A dependency injection object is required to access the application services");
			return;
		}
	}

	PHALCON_CALL_METHOD(&has_service, dependency_injector, "has", *property_name);
	if (zend_is_true(has_service)) {
		PHALCON_CALL_METHOD(&result, dependency_injector, "getshared", *property_name);
		phalcon_update_property_zval(this_ptr, Z_STRVAL_PP(property_name), Z_STRLEN_PP(property_name), result TSRMLS_CC);
		RETURN_CTOR(result);
	}

	assert(Z_TYPE_PP(property_name) == IS_STRING);

	if (Z_STRLEN_PP(property_name) == sizeof("di")-1 && !memcmp(Z_STRVAL_PP(property_name), "di", sizeof("di")-1)) {
		zend_update_property(phalcon_di_injectable_ce, getThis(), SL("di"), dependency_injector TSRMLS_CC);
		RETURN_CTOR(dependency_injector);
	}

	if (Z_STRLEN_PP(property_name) == sizeof("persistent")-1 && !memcmp(Z_STRVAL_PP(property_name), "persistent", sizeof("persistent")-1)) {
		const char *cn = Z_OBJCE_P(getThis())->name;

		MAKE_STD_ZVAL(class_name);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(class_name, cn);

		PHALCON_INIT_VAR(arguments);
		array_init_size(arguments, 1);
		add_next_index_zval(arguments, class_name);

		PHALCON_INIT_NVAR(service);
		ZVAL_STRING(service, "sessionBag", 1);

		PHALCON_CALL_METHOD(&result, dependency_injector, "get", service, arguments);
		zend_update_property(phalcon_di_injectable_ce, getThis(), SL("persistent"), result TSRMLS_CC);
		RETURN_CTOR(result);
	}

	php_error_docref(NULL TSRMLS_CC, E_WARNING, "Access to undefined property %s::%s", Z_OBJCE_P(getThis())->name, Z_STRVAL_PP(property_name));
	RETURN_MM_NULL();
}






zend_class_entry *phalcon_di_injectionawareinterface_ce;

static const zend_function_entry phalcon_di_injectionawareinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_DI_InjectionAwareInterface, setDI, arginfo_phalcon_di_injectionawareinterface_setdi)
	PHP_ABSTRACT_ME(Phalcon_DI_InjectionAwareInterface, getDI, arginfo_phalcon_di_injectionawareinterface_getdi)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DI_InjectionAwareInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\DI, InjectionAwareInterface, di_injectionawareinterface, phalcon_di_injectionawareinterface_method_entry);

	return SUCCESS;
}








#include <Zend/zend_closures.h>



zend_class_entry *phalcon_di_service_ce;

static zend_object_handlers phalcon_di_service_object_handlers;

typedef struct _phalcon_di_service_object {
	zend_object obj;
	const char *name;
	zval *definition;
	zval *shared_instance;
	size_t name_len;
	zend_bool shared;
	zend_bool resolved;
} phalcon_di_service_object;

static PHP_METHOD(Phalcon_DI_Service, __construct);
static PHP_METHOD(Phalcon_DI_Service, getName);
static PHP_METHOD(Phalcon_DI_Service, setShared);
static PHP_METHOD(Phalcon_DI_Service, isShared);
static PHP_METHOD(Phalcon_DI_Service, setSharedInstance);
static PHP_METHOD(Phalcon_DI_Service, setDefinition);
static PHP_METHOD(Phalcon_DI_Service, getDefinition);
static PHP_METHOD(Phalcon_DI_Service, resolve);
static PHP_METHOD(Phalcon_DI_Service, setParameter);
static PHP_METHOD(Phalcon_DI_Service, getParameter);
static PHP_METHOD(Phalcon_DI_Service, isResolved);
static PHP_METHOD(Phalcon_DI_Service, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_di_service___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, definition)
	ZEND_ARG_INFO(0, shared)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_di_service_method_entry[] = {
	PHP_ME(Phalcon_DI_Service, __construct, arginfo_phalcon_di_service___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_DI_Service, getName, arginfo_phalcon_di_serviceinterface_getname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, setShared, arginfo_phalcon_di_serviceinterface_setshared, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, isShared, arginfo_phalcon_di_serviceinterface_isshared, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, setSharedInstance, arginfo_phalcon_di_service_setsharedinstance, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, setDefinition, arginfo_phalcon_di_serviceinterface_setdefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, getDefinition, arginfo_phalcon_di_serviceinterface_getdefinition, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, resolve, arginfo_phalcon_di_serviceinterface_resolve, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, setParameter, arginfo_phalcon_di_service_setparameter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, getParameter, arginfo_phalcon_di_service_getparameter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, isResolved, arginfo_phalcon_di_serviceinterface_isresolved, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_DI_Service, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

static inline phalcon_di_service_object* phalcon_di_service_get_object(zval *obj TSRMLS_DC)
{
	return (phalcon_di_service_object*)zend_objects_get_address(obj TSRMLS_CC);
}

static void phalcon_di_service_dtor(void *v TSRMLS_DC)
{
	phalcon_di_service_object *obj = v;

	if (obj->name && !IS_INTERNED(obj->name)) {
		efree((char*)obj->name);
	}

	if (obj->definition) {
		zval_ptr_dtor(&obj->definition);
	}

	if (obj->shared_instance) {
		zval_ptr_dtor(&obj->shared_instance);
	}

	zend_object_std_dtor(&obj->obj TSRMLS_CC);
	efree(obj);
}

static zend_object_value phalcon_di_service_ctor(zend_class_entry* ce TSRMLS_DC)
{
	phalcon_di_service_object *obj = ecalloc(1, sizeof(phalcon_di_service_object));
	zend_object_value retval;

	zend_object_std_init(&obj->obj, ce TSRMLS_CC);
	object_properties_init(&obj->obj, ce);

	retval.handle = zend_objects_store_put(
		obj,
		(zend_objects_store_dtor_t)zend_objects_destroy_object,
		phalcon_di_service_dtor,
		NULL TSRMLS_CC
	);

	retval.handlers = &phalcon_di_service_object_handlers;
	return retval;
}

static zend_object_value phalcon_di_service_clone_obj(zval *zobject TSRMLS_DC)
{
	zend_object_value new_obj_val;
	phalcon_di_service_object *old_object;
	phalcon_di_service_object *new_object;
	zend_object_handle handle = Z_OBJ_HANDLE_P(zobject);

	old_object  = phalcon_di_service_get_object(zobject TSRMLS_CC);
	new_obj_val = phalcon_di_service_ctor(Z_OBJCE_P(zobject) TSRMLS_CC);
	new_object  = zend_object_store_get_object_by_handle(new_obj_val.handle TSRMLS_CC);

	zend_objects_clone_members(&new_object->obj, new_obj_val, &old_object->obj, handle TSRMLS_CC);

	if (old_object->name) {
		new_object->name     = estrndup(old_object->name, old_object->name_len);
		new_object->name_len = old_object->name_len;
	}

	if (old_object->definition) {
		ZVAL_ZVAL(new_object->definition, old_object->definition, 1, 0);
	}

	if (old_object->shared_instance) {
		ZVAL_ZVAL(new_object->shared_instance, old_object->shared_instance, 1, 0);
	}

	new_object->resolved = old_object->resolved;
	new_object->shared   = old_object->shared;

	return new_obj_val;
}

static HashTable* phalcon_di_service_get_debug_info(zval *object, int *is_temp TSRMLS_DC)
{
	phalcon_di_service_object *obj = phalcon_di_service_get_object(object TSRMLS_CC);
	HashTable *props = Z_OBJPROP_P(object);
	HashTable *ht;
	zval *tmp;

	*is_temp = 1;

	ALLOC_HASHTABLE(ht);
	zend_hash_init(ht, zend_hash_num_elements(props) + 5, NULL, ZVAL_PTR_DTOR, 0);
	zend_hash_copy(ht, props, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));

	MAKE_STD_ZVAL(tmp);
	if (obj->name) {
		ZVAL_STRINGL(tmp, obj->name, obj->name_len, !IS_INTERNED(obj->name));
	}
	else {
		ZVAL_EMPTY_STRING(tmp);
	}

	zend_hash_quick_update(ht, "_name", sizeof("_name"), 3983977829UL, (void*)&tmp, sizeof(zval*), NULL);

	if (obj->definition) {
		Z_ADDREF_P(obj->definition);
		tmp = obj->definition;
	}
	else {
		ALLOC_INIT_ZVAL(tmp);
	}

	zend_hash_quick_update(ht, "_definition", sizeof("_definition"), 2496408365UL, (void*)&tmp, sizeof(zval*), NULL);

	if (obj->shared_instance) {
		Z_ADDREF_P(obj->shared_instance);
		tmp = obj->shared_instance;
	}
	else {
		ALLOC_INIT_ZVAL(tmp);
	}

	zend_hash_quick_update(ht, "_sharedInstance", sizeof("_sharedInstance"), 665278864UL, (void*)&tmp, sizeof(zval*), NULL);

	MAKE_STD_ZVAL(tmp);
	ZVAL_BOOL(tmp, obj->resolved);
	zend_hash_quick_update(ht, "_resolved", sizeof("_resolved"), 1782036456UL, (void*)&tmp, sizeof(zval*), NULL);

	MAKE_STD_ZVAL(tmp);
	ZVAL_BOOL(tmp, obj->shared);
	zend_hash_quick_update(ht, "_shared", sizeof("_shared"), 3057556539UL, (void*)&tmp, sizeof(zval*), NULL);

	return ht;
}

PHALCON_INIT_CLASS(Phalcon_DI_Service){

	PHALCON_REGISTER_CLASS(Phalcon\\DI, Service, di_service, phalcon_di_service_method_entry, 0);

	phalcon_di_service_ce->create_object = phalcon_di_service_ctor;

	phalcon_di_service_object_handlers = *zend_get_std_object_handlers();
	phalcon_di_service_object_handlers.clone_obj      = phalcon_di_service_clone_obj;
	phalcon_di_service_object_handlers.get_debug_info = phalcon_di_service_get_debug_info;

	zend_class_implements(phalcon_di_service_ce TSRMLS_CC, 1, phalcon_di_serviceinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI_Service, __construct){

	zval **name, **definition, **shared = NULL;
	phalcon_di_service_object *obj;
	char *sname;

	phalcon_fetch_params_ex(2, 1, &name, &definition, &shared);

	PHALCON_ENSURE_IS_STRING(name);
	Z_ADDREF_PP(definition);

	//sname = (char*)zend_new_interned_string(Z_STRVAL_PP(name), Z_STRLEN_PP(name), 0 TSRMLS_CC);
	//if (!IS_INTERNED(sname)) {
		sname = estrndup(Z_STRVAL_PP(name), Z_STRLEN_PP(name));
	//}

	obj                  = phalcon_di_service_get_object(getThis() TSRMLS_CC);
	obj->name            = sname;
	obj->name_len        = Z_STRLEN_PP(name);
	obj->definition      = *definition;
	obj->shared          = shared ? zend_is_true(*shared) : 0;
	obj->shared_instance = NULL;
	obj->resolved        = 0;
}

static PHP_METHOD(Phalcon_DI_Service, getName)
{
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);
	RETURN_STRINGL(obj->name, obj->name_len, !IS_INTERNED(obj->name));
}

static PHP_METHOD(Phalcon_DI_Service, setShared)
{
	zval *shared;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params(0, 1, 0, &shared);
	obj->shared = zend_is_true(shared);
}

static PHP_METHOD(Phalcon_DI_Service, isShared)
{
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);
	RETURN_BOOL(obj->shared);
}

static PHP_METHOD(Phalcon_DI_Service, setSharedInstance)
{
	zval *shared_instance;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params(0, 1, 0, &shared_instance);

	if (obj->shared_instance) {
		zval_ptr_dtor(&obj->shared_instance);
	}

	obj->shared_instance = shared_instance;
}

static PHP_METHOD(Phalcon_DI_Service, setDefinition)
{
	zval *definition;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params(0, 1, 0, &definition);

	if (obj->definition) {
		zval_ptr_dtor(&obj->definition);
	}

	obj->definition = definition;
}

static PHP_METHOD(Phalcon_DI_Service, getDefinition)
{
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);
	RETURN_ZVAL(obj->definition, 1, 0);
}

static PHP_METHOD(Phalcon_DI_Service, resolve){

	zval *parameters = NULL, *dependency_injector = NULL;
	zval *instance = NULL, *definition, *builder;
	int found;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params(0, 0, 2, &parameters, &dependency_injector);

	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (!dependency_injector) {
		dependency_injector = PHALCON_GLOBAL(z_null);
	}

	/* Check if the service is shared */
	if (obj->shared && obj->shared_instance) {
		RETURN_ZVAL(obj->shared_instance, 1, 0);
	}

	PHALCON_MM_GROW();

	definition = obj->definition;
	found      = 0;
	if (Z_TYPE_P(definition) == IS_STRING) {
		/* String definitions can be class names without implicit parameters */
		if (phalcon_class_exists(Z_STRVAL_P(definition), Z_STRLEN_P(definition), 1 TSRMLS_CC)) {
			found = 1;
			if (Z_TYPE_P(parameters) == IS_ARRAY) {
				PHALCON_INIT_VAR(instance);
				RETURN_MM_ON_FAILURE(phalcon_create_instance_params(instance, definition, parameters TSRMLS_CC));
			} else {
				PHALCON_INIT_VAR(instance);
				RETURN_MM_ON_FAILURE(phalcon_create_instance(instance, definition TSRMLS_CC));
			}
		}
	}
	else if (likely(Z_TYPE_P(definition) == IS_OBJECT)) {
		/* Object definitions can be a Closure or an already resolved instance */
		found = 1;
		if (instanceof_function_ex(Z_OBJCE_P(definition), zend_ce_closure, 0 TSRMLS_CC)) {
			PHALCON_INIT_VAR(instance);
			if (Z_TYPE_P(parameters) == IS_ARRAY) {
				PHALCON_CALL_USER_FUNC_ARRAY(instance, definition, parameters);
			}
			else {
				PHALCON_CALL_USER_FUNC(instance, definition);
			}
		}
		else {
			PHALCON_CPY_WRT(instance, definition);
		}
	}
	else if (Z_TYPE_P(definition) == IS_ARRAY) {
		/* Array definitions require a 'className' parameter */
		PHALCON_INIT_VAR(builder);
		object_init_ex(builder, phalcon_di_service_builder_ce);

		PHALCON_CALL_METHOD(&instance, builder, "build", dependency_injector, definition, parameters);
		found = 1;
	}

	if (EG(exception)) {
		return;
	}

	/* If the service can't be built, we must throw an exception */
	if (!found) {
		zend_throw_exception_ex(phalcon_di_exception_ce, 0 TSRMLS_CC, "Service '%s' cannot be resolved", obj->name);
		PHALCON_MM_RESTORE();
		return;
	}

	//if (Z_TYPE_P(instance) != IS_OBJECT) {
	//	php_error_docref0(NULL TSRMLS_CC, E_DEPRECATED, "Usage of Phalcon\\DI to store non-objects is deprecated, please use Phalcon\\Registry instead");
	//}

	/* Update the shared instance if the service is shared */
	if (obj->shared) {
		Z_ADDREF_P(instance);
		obj->shared_instance = instance;
	}

	obj->resolved = 1;

	RETURN_CTOR(instance);
}

static PHP_METHOD(Phalcon_DI_Service, setParameter){

	zval **position, **parameter, *definition, *arguments = NULL;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params_ex(2, 0, &position, &parameter);
	PHALCON_ENSURE_IS_LONG(position);

	definition = obj->definition;
	if (unlikely(Z_TYPE_P(definition) != IS_ARRAY)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_di_exception_ce, "Definition must be an array to update its parameters");
		return;
	}

	if (unlikely(Z_TYPE_PP(parameter) != IS_ARRAY)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_di_exception_ce, "The parameter must be an array");
		return;
	}

	/* Update the parameter */
	if (phalcon_array_isset_string_fetch(&arguments, definition, SS("arguments"))) {
		phalcon_array_update_zval(&arguments, *position, *parameter, PH_COPY);
	} else {
		MAKE_STD_ZVAL(arguments);
		array_init_size(arguments, 1);
		phalcon_array_update_zval(&arguments, *position, *parameter, PH_COPY);
		phalcon_array_update_string(&definition, SL("arguments"), arguments, 0);
	}

	RETURN_THISW();
}

static PHP_METHOD(Phalcon_DI_Service, getParameter){

	zval **position, *definition, *arguments, *parameter;
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);

	phalcon_fetch_params_ex(1, 0, &position);
	PHALCON_ENSURE_IS_LONG(position);

	definition = obj->definition;
	if (Z_TYPE_P(definition) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_di_exception_ce, "Definition must be an array to obtain its parameters");
		return;
	}

	/* Update the parameter */
	if (
			phalcon_array_isset_string_fetch(&arguments, definition, SS("arguments"))
		 && phalcon_array_isset_fetch(&parameter, arguments, *position)
	) {
		RETURN_ZVAL(parameter, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_DI_Service, isResolved)
{
	phalcon_di_service_object *obj = phalcon_di_service_get_object(getThis() TSRMLS_CC);
	RETURN_BOOL(obj->resolved);
}

static PHP_METHOD(Phalcon_DI_Service, __set_state){

	zval *attributes, *name, *definition, *shared;

	phalcon_fetch_params(0, 1, 0, &attributes);

	if (
			!phalcon_array_isset_string_fetch(&name, attributes, SS("_name"))
		 || !phalcon_array_isset_string_fetch(&definition, attributes, SS("_definition"))
		 || !phalcon_array_isset_string_fetch(&shared, attributes, SS("_shared"))
	) {
		PHALCON_THROW_EXCEPTION_STR(spl_ce_BadMethodCallException, "Bad parameters passed to Phalcon\\DI\\Service::__set_state()");
		return;
	}

	PHALCON_MM_GROW();
	object_init_ex(return_value, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", name, definition, shared);
	RETURN_MM();
}





zend_class_entry *phalcon_di_serviceinterface_ce;

static const zend_function_entry phalcon_di_serviceinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, getName, arginfo_phalcon_di_serviceinterface_getname)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, setShared, arginfo_phalcon_di_serviceinterface_setshared)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, isShared, arginfo_phalcon_di_serviceinterface_isshared)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, setDefinition, arginfo_phalcon_di_serviceinterface_setdefinition)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, getDefinition, arginfo_phalcon_di_serviceinterface_getdefinition)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, isResolved, arginfo_phalcon_di_serviceinterface_isresolved)
	PHP_ABSTRACT_ME(Phalcon_DI_ServiceInterface, resolve, arginfo_phalcon_di_serviceinterface_resolve)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DI_ServiceInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\DI, ServiceInterface, di_serviceinterface, phalcon_di_serviceinterface_method_entry);

	return SUCCESS;
}














zend_class_entry *phalcon_di_factorydefault_cli_ce;

static PHP_METHOD(Phalcon_DI_FactoryDefault_CLI, __construct);

static const zend_function_entry phalcon_di_factorydefault_cli_method_entry[] = {
	PHP_ME(Phalcon_DI_FactoryDefault_CLI, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DI_FactoryDefault_CLI){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\DI\\FactoryDefault, CLI, di_factorydefault_cli, phalcon_di_factorydefault_ce, phalcon_di_factorydefault_cli_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI_FactoryDefault_CLI, __construct){

	zval *shared, *name = NULL, *definition = NULL, *router, *dispatcher;
	zval *models_manager, *models_metadata, *filter;
	zval *escaper, *annotations, *security, *events_manager;
	zval *transaction_manager, *services;

	PHALCON_MM_GROW();

	PHALCON_CALL_PARENT(NULL, phalcon_di_factorydefault_cli_ce, this_ptr, "__construct");
	
	shared = PHALCON_GLOBAL(z_true);
	
	PHALCON_INIT_VAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_router);
	
	PHALCON_INIT_VAR(definition);
	ZVAL_STRING(definition, "Phalcon\\CLI\\Router", 1);
	
	PHALCON_INIT_VAR(router);
	object_init_ex(router, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, router, "__construct", name, definition);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_dispatcher);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\CLI\\Dispatcher", 1);
	
	PHALCON_INIT_VAR(dispatcher);
	object_init_ex(dispatcher, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, dispatcher, "__construct", name, definition);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_modelsManager);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Manager", 1);
	
	PHALCON_INIT_VAR(models_manager);
	object_init_ex(models_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, models_manager, "__construct", name, definition);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_modelsMetadata);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Metadata\\Memory", 1);
	
	PHALCON_INIT_VAR(models_metadata);
	object_init_ex(models_metadata, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, models_metadata, "__construct", name, definition);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_filter);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Filter", 1);
	
	PHALCON_INIT_VAR(filter);
	object_init_ex(filter, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, filter, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(name, phalcon_interned_escaper);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Escaper", 1);
	
	PHALCON_INIT_VAR(escaper);
	object_init_ex(escaper, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, escaper, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "annotations", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Annotations\\Adapter\\Memory", 1);
	
	PHALCON_INIT_VAR(annotations);
	object_init_ex(annotations, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, annotations, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "security", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Security", 1);
	
	PHALCON_INIT_VAR(security);
	object_init_ex(security, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, security, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "eventsManager", 1);
	
	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Events\\Manager", 1);
	
	PHALCON_INIT_VAR(events_manager);
	object_init_ex(events_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, events_manager, "__construct", name, definition, shared);
	
	PHALCON_INIT_NVAR(name);
	ZVAL_STRING(name, "transactions", 1);

	PHALCON_INIT_NVAR(definition);
	ZVAL_STRING(definition, "Phalcon\\Mvc\\Model\\Transaction\\Manager", 1);
	
	PHALCON_INIT_VAR(transaction_manager);
	object_init_ex(transaction_manager, phalcon_di_service_ce);
	PHALCON_CALL_METHOD(NULL, transaction_manager, "__construct", name, definition);
	
	PHALCON_INIT_VAR(services);
	array_init_size(services, 10);
	phalcon_array_update_string(&services, ISL(router), router, PH_COPY);
	phalcon_array_update_string(&services, ISL(dispatcher), dispatcher, PH_COPY);
	phalcon_array_update_string(&services, ISL(modelsManager), models_manager, PH_COPY);
	phalcon_array_update_string(&services, ISL(modelsMetadata), models_metadata, PH_COPY);
	phalcon_array_update_string(&services, ISL(filter), filter, PH_COPY);
	phalcon_array_update_string(&services, ISL(escaper), escaper, PH_COPY);
	phalcon_array_update_string(&services, SL("annotations"), annotations, PH_COPY);
	phalcon_array_update_string(&services, SL("security"), security, PH_COPY);
	phalcon_array_update_string(&services, SL("eventsManager"), events_manager, PH_COPY);
	phalcon_array_update_string(&services, SL("transactionManager"), transaction_manager, PH_COPY);
	
	phalcon_di_set_services(this_ptr, services TSRMLS_CC);

	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_di_service_builder_ce;

static PHP_METHOD(Phalcon_DI_Service_Builder, _buildParameter);
static PHP_METHOD(Phalcon_DI_Service_Builder, _buildParameters);
static PHP_METHOD(Phalcon_DI_Service_Builder, build);


static const zend_function_entry phalcon_di_service_builder_method_entry[] = {
	PHP_ME(Phalcon_DI_Service_Builder, _buildParameter, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_DI_Service_Builder, _buildParameters, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_DI_Service_Builder, build, arginfo_phalcon_di_service_builder_build, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_DI_Service_Builder){

	PHALCON_REGISTER_CLASS(Phalcon\\DI\\Service, Builder, di_service_builder, phalcon_di_service_builder_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_DI_Service_Builder, _buildParameter){

	zval *dependency_injector, *position, *argument;
	zval *exception_message = NULL, *type, *name = NULL, *value = NULL, *instance_arguments;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &dependency_injector, &position, &argument);
	
	if (Z_TYPE_P(argument) != IS_ARRAY) { 
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Argument at position ", position, " must be an array");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
		return;
	}
	
	if (!phalcon_array_isset_quick_string(argument, SS("type"), 276192743UL)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Argument at position ", position, " must have a type");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
		return;
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, argument, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_STRING(type, "service")) {
		if (!phalcon_array_isset_string_fetch(&name, argument, SS("name"))) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SV(exception_message, "Service 'name' is required in parameter on position ", position);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
			return;
		}

		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The dependency injector container is not valid");
			return;
		}
	
		PHALCON_RETURN_CALL_METHOD(dependency_injector, "get", name);
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(type, "parameter")) {
		if (!phalcon_array_isset_quick_string(argument, SS("value"), 574111618UL)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SV(exception_message, "Service 'value' is required in parameter on position ", position);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
			return;
		}
	
		PHALCON_OBS_VAR(value);
		phalcon_array_fetch_quick_string(&value, argument, SS("value"), 574111618UL, PH_NOISY);
	
		RETURN_CCTOR(value);
	}
	
	if (PHALCON_IS_STRING(type, "instance")) {
		if (!phalcon_array_isset_quick_string(argument, SS("className"), 362439804UL)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SV(exception_message, "Service 'className' is required in parameter on position ", position);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
			return;
		}
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The dependency injector container is not valid");
			return;
		}
	
		PHALCON_OBS_NVAR(name);
		phalcon_array_fetch_quick_string(&name, argument, SS("className"), 362439804UL, PH_NOISY);
		if (!phalcon_array_isset_quick_string(argument, SS("arguments"), 3751272283UL)) {
			PHALCON_CALL_METHOD(&value, dependency_injector, "get", name);
		} else {
			PHALCON_OBS_VAR(instance_arguments);
			phalcon_array_fetch_quick_string(&instance_arguments, argument, SS("arguments"), 3751272283UL, PH_NOISY);
	
			PHALCON_RETURN_CALL_METHOD(dependency_injector, "get", name, instance_arguments);
			RETURN_MM();
		}
	
		RETURN_CCTOR(value);
	}
	
	PHALCON_INIT_NVAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown service type in parameter on position ", position);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_DI_Service_Builder, _buildParameters){

	zval *dependency_injector, *arguments, *build_arguments;
	zval *argument = NULL, *position = NULL, *value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &dependency_injector, &arguments);
	
	if (Z_TYPE_P(arguments) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Definition arguments must be an array");
		return;
	}
	
	PHALCON_INIT_VAR(build_arguments);
	array_init(build_arguments);
	
	phalcon_is_iterable(arguments, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(position, ah0, hp0);
		PHALCON_GET_HVALUE(argument);
	
		PHALCON_CALL_METHOD(&value, this_ptr, "_buildparameter", dependency_injector, position, argument);
		phalcon_array_append(&build_arguments, value, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(build_arguments);
}

static PHP_METHOD(Phalcon_DI_Service_Builder, build){

	zval *dependency_injector, *definition, *parameters = NULL;
	zval *class_name, *instance = NULL, *arguments = NULL, *build_arguments = NULL;
	zval *param_calls = NULL, *method = NULL, *method_position = NULL;
	zval *exception_message = NULL, *method_name = NULL, *method_call = NULL;
	zval *status = NULL, *property = NULL, *property_position = NULL;
	zval *property_name = NULL, *property_value = NULL, *value = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &dependency_injector, &definition, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(definition) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The service definition must be an array");
		return;
	}
	
	if (!phalcon_array_isset_quick_string(definition, SS("className"), 362439804UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Invalid service definition. Missing 'className' parameter");
		return;
	}
	
	PHALCON_OBS_VAR(class_name);
	phalcon_array_fetch_quick_string(&class_name, definition, SS("className"), 362439804UL, PH_NOISY);
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(instance);
		if (phalcon_create_instance_params(instance, class_name, parameters TSRMLS_CC) == FAILURE) {
			RETURN_MM();
		}
	} else {
		if (phalcon_array_isset_quick_string(definition, SS("arguments"), 3751272283UL)) {
			PHALCON_OBS_VAR(arguments);
			phalcon_array_fetch_quick_string(&arguments, definition, SS("arguments"), 3751272283UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&build_arguments, this_ptr, "_buildparameters", dependency_injector, arguments);
	
			PHALCON_INIT_NVAR(instance);
			if (phalcon_create_instance_params(instance, class_name, build_arguments TSRMLS_CC) == FAILURE) {
				RETURN_MM();
			}
		} else {
			PHALCON_INIT_NVAR(instance);
			if (phalcon_create_instance(instance, class_name TSRMLS_CC) == FAILURE) {
				RETURN_MM();
			}
		}
	}
	
	if (phalcon_array_isset_quick_string(definition, SS("calls"), 4125497108UL)) {
		if (Z_TYPE_P(instance) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The definition has setter injection parameters but the constructor didn't return an instance");
			return;
		}
	
		PHALCON_OBS_VAR(param_calls);
		phalcon_array_fetch_quick_string(&param_calls, definition, SS("calls"), 4125497108UL, PH_NOISY);
		if (Z_TYPE_P(param_calls) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Setter injection parameters must be an array");
			return;
		}
	
		phalcon_is_iterable(param_calls, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(method_position, ah0, hp0);
			PHALCON_GET_HVALUE(method);
	
			if (Z_TYPE_P(method) != IS_ARRAY) { 
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "Method call must be an array on position ", method_position);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
				return;
			}
	
			if (!phalcon_array_isset_quick_string(method, SS("method"), 3193080326UL)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "The method name is required on position ", method_position);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_NVAR(method_name);
			phalcon_array_fetch_quick_string(&method_name, method, SS("method"), 3193080326UL, PH_NOISY);
	
			PHALCON_INIT_NVAR(method_call);
			array_init_size(method_call, 2);
			phalcon_array_append(&method_call, instance, PH_SEPARATE);
			phalcon_array_append(&method_call, method_name, PH_SEPARATE);
			if (phalcon_array_isset_quick_string(method, SS("arguments"), 3751272283UL)) {
	
				PHALCON_OBS_NVAR(arguments);
				phalcon_array_fetch_quick_string(&arguments, method, SS("arguments"), 3751272283UL, PH_NOISY);
				if (Z_TYPE_P(arguments) != IS_ARRAY) { 
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SV(exception_message, "Call arguments must be an array ", method_position);
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
					return;
				}
	
				if (phalcon_fast_count_ev(arguments TSRMLS_CC)) {
					PHALCON_CALL_METHOD(&build_arguments, this_ptr, "_buildparameters", dependency_injector, arguments);
	
					PHALCON_INIT_NVAR(status);/**/
					PHALCON_CALL_USER_FUNC_ARRAY(status, method_call, build_arguments);
	
					zend_hash_move_forward_ex(ah0, &hp0);
					continue;
				}
			}
	
			PHALCON_INIT_NVAR(status);/**/
			PHALCON_CALL_USER_FUNC(status, method_call);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	if (phalcon_array_isset_quick_string(definition, SS("properties"), 1619284338UL)) {
		if (Z_TYPE_P(instance) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "The definition has properties injection parameters but the constructor didn't return an instance");
			return;
		}
	
		PHALCON_OBS_NVAR(param_calls);
		phalcon_array_fetch_quick_string(&param_calls, definition, SS("properties"), 1619284338UL, PH_NOISY);
		if (Z_TYPE_P(param_calls) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_di_exception_ce, "Setter injection parameters must be an array");
			return;
		}
	
		phalcon_is_iterable(param_calls, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HKEY(property_position, ah1, hp1);
			PHALCON_GET_HVALUE(property);
	
			if (Z_TYPE_P(property) != IS_ARRAY) { 
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "Property must be an array on position ", property_position);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
				return;
			}
	
			if (!phalcon_array_isset_quick_string(property, SS("name"), 268211462UL)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "The property name is required on position ", property_position);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
				return;
			}
	
			if (!phalcon_array_isset_quick_string(property, SS("value"), 574111618UL)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "The property value is required on position ", property_position);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_di_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_NVAR(property_name);
			phalcon_array_fetch_quick_string(&property_name, property, SS("name"), 268211462UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(property_value);
			phalcon_array_fetch_quick_string(&property_value, property, SS("value"), 574111618UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&value, this_ptr, "_buildparameter", dependency_injector, property_position, property_value);
	
			phalcon_update_property_zval_zval(instance, property_name, value TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
	}
	
	RETURN_CTOR(instance);
}






zend_class_entry *phalcon_escaper_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Escaper_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Escaper, Exception, escaper_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_events_event_ce;

static PHP_METHOD(Phalcon_Events_Event, __construct);
static PHP_METHOD(Phalcon_Events_Event, setType);
static PHP_METHOD(Phalcon_Events_Event, getType);
static PHP_METHOD(Phalcon_Events_Event, getSource);
static PHP_METHOD(Phalcon_Events_Event, setData);
static PHP_METHOD(Phalcon_Events_Event, getData);
static PHP_METHOD(Phalcon_Events_Event, setCancelable);
static PHP_METHOD(Phalcon_Events_Event, getCancelable);
static PHP_METHOD(Phalcon_Events_Event, stop);
static PHP_METHOD(Phalcon_Events_Event, isStopped);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_event___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, source)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, cancelable)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_event_settype, 0, 0, 1)
	ZEND_ARG_INFO(0, eventType)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_event_setdata, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_event_setcancelable, 0, 0, 1)
	ZEND_ARG_INFO(0, cancelable)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_events_event_method_entry[] = {
	PHP_ME(Phalcon_Events_Event, __construct, arginfo_phalcon_events_event___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Events_Event, setType, arginfo_phalcon_events_event_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, getSource, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, setData, arginfo_phalcon_events_event_setdata, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, getData, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, setCancelable, arginfo_phalcon_events_event_setcancelable, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, getCancelable, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, stop, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Event, isStopped, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Events_Event){

	PHALCON_REGISTER_CLASS(Phalcon\\Events, Event, events_event, phalcon_events_event_method_entry, 0);

	zend_declare_property_null(phalcon_events_event_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_events_event_ce, SL("_source"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_events_event_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_event_ce, SL("_stopped"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_event_ce, SL("_cancelable"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Events_Event, __construct){

	zval *type, *source, *data = NULL, *cancelable = NULL;

	phalcon_fetch_params(0, 2, 2, &type, &source, &data, &cancelable);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!cancelable) {
		cancelable = PHALCON_GLOBAL(z_true);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_source"), source, 3355220565UL TSRMLS_CC);
	if (Z_TYPE_P(data) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);
	}
	
	if (PHALCON_IS_NOT_TRUE(cancelable)) {
		phalcon_update_property_this_quick(this_ptr, SL("_cancelable"), cancelable, 1786076446UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Events_Event, setType){

	zval *event_type;

	phalcon_fetch_params(0, 1, 0, &event_type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), event_type, 3991959110UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Events_Event, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Events_Event, getSource){


	RETURN_MEMBER_QUICK(this_ptr, "_source", 3355220565UL);
}

static PHP_METHOD(Phalcon_Events_Event, setData){

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);
	
	phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Events_Event, getData){


	RETURN_MEMBER_QUICK(this_ptr, "_data", 3972126110UL);
}

static PHP_METHOD(Phalcon_Events_Event, setCancelable){

	zval *cancelable;

	phalcon_fetch_params(0, 1, 0, &cancelable);
	
	phalcon_update_property_this_quick(this_ptr, SL("_cancelable"), cancelable, 1786076446UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Events_Event, getCancelable){


	RETURN_MEMBER_QUICK(this_ptr, "_cancelable", 1786076446UL);
}

static PHP_METHOD(Phalcon_Events_Event, stop){

	zval *cancelable;

	cancelable = phalcon_fetch_nproperty_this(this_ptr, SL("_cancelable"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(cancelable)) {
		phalcon_update_property_bool(this_ptr, SL("_stopped"), 1 TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_events_exception_ce, "Trying to cancel a non-cancelable event");
		return;
	}
}

static PHP_METHOD(Phalcon_Events_Event, isStopped){


	RETURN_MEMBER_QUICK(this_ptr, "_stopped", 978787779UL);
}





zend_class_entry *phalcon_events_eventsawareinterface_ce;

static const zend_function_entry phalcon_events_eventsawareinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Events_EventsAwareInterface, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager)
	PHP_ABSTRACT_ME(Phalcon_Events_EventsAwareInterface, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Events_EventsAwareInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Events, EventsAwareInterface, events_eventsawareinterface, phalcon_events_eventsawareinterface_method_entry);

	return SUCCESS;
}







zend_class_entry *phalcon_events_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Events_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Events, Exception, events_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}




#include <Zend/zend_closures.h>
#include <ext/spl/spl_heap.h>


zend_class_entry *phalcon_events_manager_ce;

static PHP_METHOD(Phalcon_Events_Manager, attach);
static PHP_METHOD(Phalcon_Events_Manager, enablePriorities);
static PHP_METHOD(Phalcon_Events_Manager, arePrioritiesEnabled);
static PHP_METHOD(Phalcon_Events_Manager, collectResponses);
static PHP_METHOD(Phalcon_Events_Manager, isCollecting);
static PHP_METHOD(Phalcon_Events_Manager, getResponses);
static PHP_METHOD(Phalcon_Events_Manager, detachAll);
static PHP_METHOD(Phalcon_Events_Manager, fireQueue);
static PHP_METHOD(Phalcon_Events_Manager, fire);
static PHP_METHOD(Phalcon_Events_Manager, hasListeners);
static PHP_METHOD(Phalcon_Events_Manager, getListeners);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_manager_enablepriorities, 0, 0, 1)
	ZEND_ARG_INFO(0, enablePriorities)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_manager_collectresponses, 0, 0, 1)
	ZEND_ARG_INFO(0, collect)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_manager_firequeue, 0, 0, 2)
	ZEND_ARG_INFO(0, queue)
	ZEND_ARG_INFO(0, event)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_events_manager_haslisteners, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_events_manager_method_entry[] = {
	PHP_ME(Phalcon_Events_Manager, attach, arginfo_phalcon_events_managerinterface_attach, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, enablePriorities, arginfo_phalcon_events_manager_enablepriorities, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, arePrioritiesEnabled, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, collectResponses, arginfo_phalcon_events_manager_collectresponses, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, isCollecting, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, getResponses, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, detachAll, arginfo_phalcon_events_managerinterface_detachall, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, fireQueue, arginfo_phalcon_events_manager_firequeue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, fire, arginfo_phalcon_events_managerinterface_fire, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, hasListeners, arginfo_phalcon_events_manager_haslisteners, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Events_Manager, getListeners, arginfo_phalcon_events_managerinterface_getlisteners, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Events_Manager, dettachAll, detachAll, arginfo_phalcon_events_managerinterface_detachall, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Events_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Events, Manager, events_manager, phalcon_events_manager_method_entry, 0);

	zend_declare_property_null(phalcon_events_manager_ce, SL("_events"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_manager_ce, SL("_collect"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_events_manager_ce, SL("_enablePriorities"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_events_manager_ce, SL("_responses"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_events_manager_ce TSRMLS_CC, 1, phalcon_events_managerinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Events_Manager, attach){

	zval *event_type, *handler, *priority = NULL, *events = NULL;
	zval *enable_priorities, *priority_queue = NULL;
	zval *mode;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &event_type, &handler, &priority);
	
	if (!priority) {
		PHALCON_INIT_VAR(priority);
		ZVAL_LONG(priority, 100);
	}
	
	if (unlikely(Z_TYPE_P(event_type) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event type must be a string");
		return;
	}
	if (unlikely(Z_TYPE_P(handler) != IS_OBJECT)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event handler must be an Object");
		return;
	}
	
	events = phalcon_fetch_nproperty_this(this_ptr, SL("_events"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events) != IS_ARRAY) {
		PHALCON_INIT_VAR(events);
		array_init(events);
	}
	
	if (!phalcon_array_isset(events, event_type)) {
	
		PHALCON_OBS_VAR(enable_priorities);
		phalcon_read_property_this(&enable_priorities, this_ptr, SL("_enablePriorities"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(enable_priorities)) {
			PHALCON_INIT_VAR(priority_queue);
			object_init_ex(priority_queue, spl_ce_SplPriorityQueue);
			if (phalcon_has_constructor(priority_queue TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, priority_queue, "__construct");
			}
	
			PHALCON_INIT_VAR(mode);
			ZVAL_LONG(mode, 1);
	
			PHALCON_CALL_METHOD(NULL, priority_queue, "setextractflags", mode);
	
			phalcon_array_update_zval(&events, event_type, priority_queue, PH_COPY | PH_SEPARATE);
			phalcon_update_property_this_quick(this_ptr, SL("_events"), events, 2709386425UL TSRMLS_CC);
		} else {
			PHALCON_INIT_NVAR(priority_queue);
			array_init(priority_queue);
		}
	} else {
		PHALCON_OBS_NVAR(priority_queue);
		phalcon_array_fetch(&priority_queue, events, event_type, PH_NOISY);
	}
	
	if (unlikely(Z_TYPE_P(priority_queue) == IS_OBJECT)) {
		PHALCON_CALL_METHOD(NULL, priority_queue, "insert", handler, priority);
	} else {
		phalcon_array_append(&priority_queue, handler, PH_SEPARATE);
	
		phalcon_array_update_zval(&events, event_type, priority_queue, PH_COPY | PH_SEPARATE);
		phalcon_update_property_this_quick(this_ptr, SL("_events"), events, 2709386425UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Events_Manager, enablePriorities){

	zval *enable_priorities;

	phalcon_fetch_params(0, 1, 0, &enable_priorities);
	
	phalcon_update_property_this_quick(this_ptr, SL("_enablePriorities"), enable_priorities, 914030005UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Events_Manager, arePrioritiesEnabled){


	RETURN_MEMBER_QUICK(this_ptr, "_enablePriorities", 914030005UL);
}

static PHP_METHOD(Phalcon_Events_Manager, collectResponses){

	zval *collect;

	phalcon_fetch_params(0, 1, 0, &collect);
	
	phalcon_update_property_this_quick(this_ptr, SL("_collect"), collect, 3993548138UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Events_Manager, isCollecting){


	RETURN_MEMBER_QUICK(this_ptr, "_collect", 3993548138UL);
}

static PHP_METHOD(Phalcon_Events_Manager, getResponses){


	RETURN_MEMBER_QUICK(this_ptr, "_responses", 77555686UL);
}

static PHP_METHOD(Phalcon_Events_Manager, detachAll){

	zval *type = NULL, *events = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &type);
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(events);
	phalcon_read_property_this(&events, this_ptr, SL("_events"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(type) == IS_NULL) {
		PHALCON_INIT_NVAR(events);
	} else {
		if (phalcon_array_isset(events, type)) {
			phalcon_array_unset(&events, type, PH_SEPARATE);
		}
	}

	phalcon_update_property_this_quick(this_ptr, SL("_events"), events, 2709386425UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Events_Manager, fireQueue){

	zval *queue, *event, *status = NULL, *arguments = NULL, *event_name = NULL;
	zval *source = NULL, *data = NULL, *cancelable = NULL, *collect, *iterator;
	zval *handler = NULL, *is_stopped = NULL, *handler_referenced = NULL, *handler_embeded = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	zend_class_entry **weakref_ce;

	phalcon_fetch_params(0, 2, 0, &queue, &event);

	if (unlikely(Z_TYPE_P(queue) != IS_ARRAY)) {
		if (Z_TYPE_P(queue) == IS_OBJECT) {
			zend_class_entry *ce = Z_OBJCE_P(queue);
			if (
				   !instanceof_function_ex(ce, phalcon_events_event_ce, 0 TSRMLS_CC)
				&& !instanceof_function_ex(ce, spl_ce_SplPriorityQueue, 0 TSRMLS_CC)
			) {
				zend_throw_exception_ex(phalcon_events_exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type Phalcon\\Events\\Event or SplPriorityQueue, %s given", ce->name);
				return;
			}
		}
		else {
			zend_throw_exception_ex(phalcon_events_exception_ce, 0 TSRMLS_CC, "Unexpected value type: expected object of type Phalcon\\Events\\Event or SplPriorityQueue, %s given", zend_zval_type_name(queue));
			return;
		}
	}

	PHALCON_VERIFY_CLASS_EX(event, phalcon_events_event_ce, phalcon_events_exception_ce, 0);

	if (FAILURE == zend_lookup_class_ex(SL("WeakRef") ZLK_NULL_CC, 0, &weakref_ce TSRMLS_CC)) {
		weakref_ce = NULL;
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(status);
	
	PHALCON_INIT_VAR(arguments);
	
	PHALCON_CALL_METHOD(&event_name, event, "gettype");
	if (unlikely(Z_TYPE_P(event_name) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "The event type not valid");
		return;
	}
	
	PHALCON_CALL_METHOD(&source, event, "getsource");
	
	PHALCON_CALL_METHOD(&data, event, "getdata");
	
	PHALCON_CALL_METHOD(&cancelable, event, "getcancelable");
	
	PHALCON_OBS_VAR(collect);
	phalcon_read_property_this(&collect, this_ptr, SL("_collect"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(queue) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(iterator);
		if (phalcon_clone(iterator, queue TSRMLS_CC) == FAILURE) {
			RETURN_MM();
		}
	
		PHALCON_CALL_METHOD(NULL, iterator, "top");
	
		while (1) {
			PHALCON_CALL_METHOD(&r0, iterator, "valid");
			if (!zend_is_true(r0)) {
				break;
			}
	
			PHALCON_CALL_METHOD(&handler_embeded, iterator, "current");
	
			if (Z_TYPE_P(handler_embeded) == IS_OBJECT) {

				if (weakref_ce && instanceof_function(Z_OBJCE_P(handler_embeded), *weakref_ce TSRMLS_CC)) {
					PHALCON_CALL_METHOD(&handler_referenced, handler_embeded, "valid");

					if (zend_is_true(handler_referenced)) {
						PHALCON_CALL_METHOD(&handler, handler_embeded, "get");
					} else {
						PHALCON_CALL_METHOD(NULL, iterator, "next");
						continue;
					}

				} else {
					PHALCON_CPY_WRT(handler, handler_embeded);
				}
	
				assert(Z_TYPE_P(handler) == IS_OBJECT);
				if (instanceof_function(Z_OBJCE_P(handler), zend_ce_closure TSRMLS_CC)) {
	
					if (Z_TYPE_P(arguments) == IS_NULL) {
						PHALCON_INIT_NVAR(arguments);
						array_init_size(arguments, 3);
						phalcon_array_append(&arguments, event, 0);
						phalcon_array_append(&arguments, source, 0);
						phalcon_array_append(&arguments, data, 0);
					}
	
					PHALCON_INIT_NVAR(status);/**/
					PHALCON_CALL_USER_FUNC_ARRAY(status, handler, arguments);
	
					if (zend_is_true(collect)) {
						phalcon_update_property_array_append(this_ptr, SL("_responses"), status TSRMLS_CC);
					}
	
					if (zend_is_true(cancelable)) {
	
						PHALCON_CALL_METHOD(&is_stopped, event, "isstopped");
						if (zend_is_true(is_stopped)) {
							break;
						}
					}
				} else {
					if (phalcon_method_exists(handler, event_name TSRMLS_CC) == SUCCESS) {
	
						PHALCON_CALL_METHOD(&status, handler, Z_STRVAL_P(event_name), event, source, data);
	
						if (zend_is_true(collect)) {
							phalcon_update_property_array_append(this_ptr, SL("_responses"), status TSRMLS_CC);
						}
	
						if (zend_is_true(cancelable)) {
	
							PHALCON_CALL_METHOD(&is_stopped, event, "isstopped");
							if (zend_is_true(is_stopped)) {
								break;
							}
						}
					}
				}
			}
	
			PHALCON_CALL_METHOD(NULL, iterator, "next");
		}
	} else {
	
		phalcon_is_iterable(queue, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(handler_embeded);
	
			if (Z_TYPE_P(handler_embeded) == IS_OBJECT) {

				if (weakref_ce && instanceof_function(Z_OBJCE_P(handler_embeded), *weakref_ce TSRMLS_CC)) {
					PHALCON_CALL_METHOD(&handler_referenced, handler_embeded, "valid");

					if (zend_is_true(handler_referenced)) {
						PHALCON_CALL_METHOD(&handler, handler_embeded, "get");
					} else {
						zend_hash_move_forward_ex(ah0, &hp0);
						continue;
					}

				} else {
					PHALCON_CPY_WRT(handler, handler_embeded);
				}
	
				assert(Z_TYPE_P(handler) == IS_OBJECT);
				if (instanceof_function(Z_OBJCE_P(handler), zend_ce_closure TSRMLS_CC)) {
	
					if (Z_TYPE_P(arguments) == IS_NULL) {
						PHALCON_INIT_NVAR(arguments);
						array_init_size(arguments, 3);
						phalcon_array_append(&arguments, event, 0);
						phalcon_array_append(&arguments, source, 0);
						phalcon_array_append(&arguments, data, 0);
					}
	
					PHALCON_INIT_NVAR(status);/**/
					PHALCON_CALL_USER_FUNC_ARRAY(status, handler, arguments);
	
					if (zend_is_true(collect)) {
						phalcon_update_property_array_append(this_ptr, SL("_responses"), status TSRMLS_CC);
					}
	
					if (zend_is_true(cancelable)) {
	
						PHALCON_CALL_METHOD(&is_stopped, event, "isstopped");
						if (zend_is_true(is_stopped)) {
							break;
						}
					}
				} else {
					if (phalcon_method_exists(handler, event_name TSRMLS_CC) == SUCCESS) {
	
						PHALCON_CALL_METHOD(&status, handler, Z_STRVAL_P(event_name), event, source, data);
	
						if (zend_is_true(collect)) {
							phalcon_update_property_array_append(this_ptr, SL("_responses"), status TSRMLS_CC);
						}
	
						if (zend_is_true(cancelable)) {
	
							PHALCON_CALL_METHOD(&is_stopped, event, "isstopped");
							if (zend_is_true(is_stopped)) {
								break;
							}
						}
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_CCTOR(status);
}

static PHP_METHOD(Phalcon_Events_Manager, fire){

	zval *event_type, *source, *data = NULL, *cancelable = NULL, *events;
	zval *exception_message, *event_parts, *type;
	zval *event_name, *status = NULL, *collect, *event = NULL, *fire_events = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 2, &event_type, &source, &data, &cancelable);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!cancelable) {
		cancelable = PHALCON_GLOBAL(z_true);
	}
	
	if (unlikely(Z_TYPE_P(event_type) != IS_STRING)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_events_exception_ce, "Event type must be a string");
		return;
	}
	
	events = phalcon_fetch_nproperty_this(this_ptr, SL("_events"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events) != IS_ARRAY) { 
		RETURN_MM_NULL();
	}
	
	if (!phalcon_memnstr_str(event_type, SL(":"))) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "Invalid event type ", event_type);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_events_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(event_parts);
	phalcon_fast_explode_str(event_parts, SL(":"), event_type);
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_long(&type, event_parts, 0, PH_NOISY);
	
	PHALCON_OBS_VAR(event_name);
	phalcon_array_fetch_long(&event_name, event_parts, 1, PH_NOISY);
	
	PHALCON_INIT_VAR(status);
	
	collect = phalcon_fetch_nproperty_this(this_ptr, SL("_collect"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(collect)) {
		phalcon_update_property_null(this_ptr, SL("_responses") TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(event);
	
	if (phalcon_array_isset_fetch(&fire_events, events, type)) {
		if (Z_TYPE_P(fire_events) == IS_ARRAY || Z_TYPE_P(fire_events) == IS_OBJECT) {
			object_init_ex(event, phalcon_events_event_ce);
			PHALCON_CALL_METHOD(NULL, event, "__construct", event_name, source, data, cancelable);
	
			PHALCON_CALL_METHOD(&status, this_ptr, "firequeue", fire_events, event);
		}
	}
	
	if (phalcon_array_isset_fetch(&fire_events, events, event_type)) {
		if (Z_TYPE_P(fire_events) == IS_ARRAY || Z_TYPE_P(fire_events) == IS_OBJECT) {
			if (Z_TYPE_P(event) == IS_NULL) {
				PHALCON_INIT_NVAR(event);
				object_init_ex(event, phalcon_events_event_ce);
				PHALCON_CALL_METHOD(NULL, event, "__construct", event_name, source, data, cancelable);
	
			}
	
			PHALCON_CALL_METHOD(&status, this_ptr, "firequeue", fire_events, event);
		}
	}
	
	RETURN_CCTOR(status);
}

static PHP_METHOD(Phalcon_Events_Manager, hasListeners){

	zval *type, *events;

	phalcon_fetch_params(0, 1, 0, &type);
	
	events = phalcon_fetch_nproperty_this(this_ptr, SL("_events"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(events, type)) {
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Events_Manager, getListeners){

	zval *type, *events, *fire_events;

	phalcon_fetch_params(0, 1, 0, &type);
	
	events = phalcon_fetch_nproperty_this(this_ptr, SL("_events"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&fire_events, events, type)) {
		RETURN_ZVAL(fire_events, 1, 0);
	}
	
	array_init(return_value);
}





zend_class_entry *phalcon_events_managerinterface_ce;

static const zend_function_entry phalcon_events_managerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Events_ManagerInterface, attach, arginfo_phalcon_events_managerinterface_attach)
	PHP_ABSTRACT_ME(Phalcon_Events_ManagerInterface, detachAll, arginfo_phalcon_events_managerinterface_detachall)
	PHP_ABSTRACT_ME(Phalcon_Events_ManagerInterface, fire, arginfo_phalcon_events_managerinterface_fire)
	PHP_ABSTRACT_ME(Phalcon_Events_ManagerInterface, getListeners, arginfo_phalcon_events_managerinterface_getlisteners)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Events_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Events, ManagerInterface, events_managerinterface, phalcon_events_managerinterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_filter_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Filter_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Filter, Exception, filter_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_filter_userfilterinterface_ce;

static const zend_function_entry phalcon_filter_userfilterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Filter_UserFilterInterface, filter, arginfo_phalcon_filter_userfilterinterface_filter)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Filter_UserFilterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Filter, UserFilterInterface, filter_userfilterinterface, phalcon_filter_userfilterinterface_method_entry);

	return SUCCESS;
}







zend_class_entry *phalcon_flash_direct_ce;

static PHP_METHOD(Phalcon_Flash_Direct, message);

static const zend_function_entry phalcon_flash_direct_method_entry[] = {
	PHP_ME(Phalcon_Flash_Direct, message, arginfo_phalcon_flashinterface_message, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Flash_Direct){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Direct, flash_direct, phalcon_flash_ce, phalcon_flash_direct_method_entry, 0);

	zend_class_implements(phalcon_flash_direct_ce TSRMLS_CC, 1, phalcon_flashinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Flash_Direct, message)
{
	zval *type, *message;

	phalcon_fetch_params(0, 2, 0, &type, &message);
	
	PHALCON_RETURN_CALL_METHODW(this_ptr, "outputmessage", type, message);
}






zend_class_entry *phalcon_flash_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Flash_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Exception, flash_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_flash_session_ce;

static PHP_METHOD(Phalcon_Flash_Session, setDI);
static PHP_METHOD(Phalcon_Flash_Session, getDI);
static PHP_METHOD(Phalcon_Flash_Session, _getSessionMessages);
static PHP_METHOD(Phalcon_Flash_Session, _setSessionMessages);
static PHP_METHOD(Phalcon_Flash_Session, message);
static PHP_METHOD(Phalcon_Flash_Session, getMessages);
static PHP_METHOD(Phalcon_Flash_Session, output);
static PHP_METHOD(Phalcon_Flash_Session, has);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_session_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_session_getmessages, 0, 0, 0)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, remove)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_session_output, 0, 0, 0)
	ZEND_ARG_INFO(0, remove)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_flash_session_has, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_flash_session_method_entry[] = {
	PHP_ME(Phalcon_Flash_Session, setDI, arginfo_phalcon_flash_session_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash_Session, getDI, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash_Session, _getSessionMessages, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Flash_Session, _setSessionMessages, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Flash_Session, message, arginfo_phalcon_flashinterface_message, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash_Session, getMessages, arginfo_phalcon_flash_session_getmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash_Session, output, arginfo_phalcon_flash_session_output, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Flash_Session, has, arginfo_phalcon_flash_session_has, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Flash_Session){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Flash, Session, flash_session, phalcon_flash_ce, phalcon_flash_session_method_entry, 0);

	zend_declare_property_null(phalcon_flash_session_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_flash_session_ce TSRMLS_CC, 2, phalcon_flashinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Flash_Session, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_flash_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Flash_Session, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Flash_Session, _getSessionMessages){

	zval *remove, *dependency_injector, *service;
	zval *session = NULL, *index_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &remove);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (unlikely(Z_TYPE_P(dependency_injector) != IS_OBJECT)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_flash_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);
	
	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);
	
	PHALCON_INIT_VAR(index_name);
	ZVAL_STRING(index_name, "_flashMessages", 1);
	
	PHALCON_RETURN_CALL_METHOD(session, "get", index_name);
	if (PHALCON_IS_TRUE(remove)) {
		PHALCON_CALL_METHOD(NULL, session, "remove", index_name);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Flash_Session, _setSessionMessages){

	zval *messages, *dependency_injector, *service;
	zval *session = NULL, *index_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &messages);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (unlikely(Z_TYPE_P(dependency_injector) != IS_OBJECT)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_flash_exception_ce, "A dependency injection container is required to access the 'session' service");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);
	
	PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);
	
	PHALCON_INIT_VAR(index_name);
	ZVAL_STRING(index_name, "_flashMessages", 1);
	PHALCON_CALL_METHOD(NULL, session, "set", index_name, messages);
	
	RETURN_CTOR(messages);
}

static PHP_METHOD(Phalcon_Flash_Session, message){

	zval *type, *message, *messages = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &message);
	
	PHALCON_CALL_METHOD(&messages, this_ptr, "_getsessionmessages", PHALCON_GLOBAL(z_false));
	if (Z_TYPE_P(messages) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(messages);
		array_init(messages);
	}
	
	phalcon_array_append_multi_2(&messages, type, message, 0);
	PHALCON_CALL_METHOD(NULL, this_ptr, "_setsessionmessages", messages);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Flash_Session, getMessages){

	zval *type = NULL, *remove = NULL, *messages = NULL, *return_messages;
	zval *do_remove;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &type, &remove);
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	if (!remove) {
		remove = PHALCON_GLOBAL(z_true);
	}

	if (Z_TYPE_P(type) != IS_NULL) {
		do_remove = PHALCON_GLOBAL(z_false);
	}
	else {
		do_remove = remove;
	}

	PHALCON_CALL_METHOD(&messages, this_ptr, "_getsessionmessages", do_remove);
	if (Z_TYPE_P(messages) == IS_ARRAY) {
		if (likely(Z_TYPE_P(type) != IS_NULL)) {
			if (phalcon_array_isset_fetch(&return_messages, messages, type)) {
				RETVAL_ZVAL(return_messages, 1, 0);
				if (zend_is_true(remove)) {
					phalcon_array_unset(&messages, type, 0);
					PHALCON_CALL_METHOD(NULL, this_ptr, "_setsessionmessages", messages);
				}

				PHALCON_MM_RESTORE();
				return;
			}

			RETURN_MM_EMPTY_ARRAY();
		}
	
		RETURN_CCTOR(messages);
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Flash_Session, output){

	zval *remove = NULL, *messages = NULL, *message = NULL, *type = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &remove);
	
	if (!remove) {
		remove = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_CALL_METHOD(&messages, this_ptr, "_getsessionmessages", remove);
	if (Z_TYPE_P(messages) == IS_ARRAY) { 
	
		phalcon_is_iterable(messages, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(type, ah0, hp0);
			PHALCON_GET_HVALUE(message);
	
			PHALCON_CALL_METHOD(NULL, this_ptr, "outputmessage", type, message);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Flash_Session, has) {

	zval *type, *messages = NULL;

	phalcon_fetch_params(0, 0, 1, &type);

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD(&messages, this_ptr, "_getsessionmessages", PHALCON_GLOBAL(z_false));

	RETVAL_BOOL(phalcon_array_isset(messages, type));
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_forms_element_ce;

static PHP_METHOD(Phalcon_Forms_Element, __construct);
static PHP_METHOD(Phalcon_Forms_Element, setForm);
static PHP_METHOD(Phalcon_Forms_Element, getForm);
static PHP_METHOD(Phalcon_Forms_Element, setName);
static PHP_METHOD(Phalcon_Forms_Element, getName);
static PHP_METHOD(Phalcon_Forms_Element, setFilters);
static PHP_METHOD(Phalcon_Forms_Element, addFilter);
static PHP_METHOD(Phalcon_Forms_Element, getFilters);
static PHP_METHOD(Phalcon_Forms_Element, addValidators);
static PHP_METHOD(Phalcon_Forms_Element, addValidator);
static PHP_METHOD(Phalcon_Forms_Element, getValidators);
static PHP_METHOD(Phalcon_Forms_Element, prepareAttributes);
static PHP_METHOD(Phalcon_Forms_Element, setAttribute);
static PHP_METHOD(Phalcon_Forms_Element, getAttribute);
static PHP_METHOD(Phalcon_Forms_Element, setAttributes);
static PHP_METHOD(Phalcon_Forms_Element, getAttributes);
static PHP_METHOD(Phalcon_Forms_Element, setUserOption);
static PHP_METHOD(Phalcon_Forms_Element, getUserOption);
static PHP_METHOD(Phalcon_Forms_Element, setUserOptions);
static PHP_METHOD(Phalcon_Forms_Element, getUserOptions);
static PHP_METHOD(Phalcon_Forms_Element, setLabel);
static PHP_METHOD(Phalcon_Forms_Element, getLabel);
static PHP_METHOD(Phalcon_Forms_Element, label);
static PHP_METHOD(Phalcon_Forms_Element, setDefault);
static PHP_METHOD(Phalcon_Forms_Element, getDefault);
static PHP_METHOD(Phalcon_Forms_Element, getValue);
static PHP_METHOD(Phalcon_Forms_Element, getMessages);
static PHP_METHOD(Phalcon_Forms_Element, hasMessages);
static PHP_METHOD(Phalcon_Forms_Element, setMessages);
static PHP_METHOD(Phalcon_Forms_Element, appendMessage);
static PHP_METHOD(Phalcon_Forms_Element, clear);
static PHP_METHOD(Phalcon_Forms_Element, __toString);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_element___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_element_label, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_forms_element_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element, __construct, arginfo_phalcon_forms_element___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Forms_Element, setForm, arginfo_phalcon_forms_elementinterface_setform, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getForm, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setName, arginfo_phalcon_forms_elementinterface_setname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setFilters, arginfo_phalcon_forms_elementinterface_setfilters, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, addFilter, arginfo_phalcon_forms_elementinterface_addfilter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getFilters, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, addValidators, arginfo_phalcon_forms_elementinterface_addvalidators, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, addValidator, arginfo_phalcon_forms_elementinterface_addvalidator, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getValidators, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, prepareAttributes, arginfo_phalcon_forms_elementinterface_prepareattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setAttribute, arginfo_phalcon_forms_elementinterface_setattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getAttribute, arginfo_phalcon_forms_elementinterface_getattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setAttributes, arginfo_phalcon_forms_elementinterface_setattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getAttributes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setUserOption, arginfo_phalcon_forms_elementinterface_setuseroption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getUserOption, arginfo_phalcon_forms_elementinterface_getuseroption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setUserOptions, arginfo_phalcon_forms_elementinterface_setuseroptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getUserOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setLabel, arginfo_phalcon_forms_elementinterface_setlabel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getLabel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, label, arginfo_phalcon_forms_element_label, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setDefault, arginfo_phalcon_forms_elementinterface_setdefault, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getDefault, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getValue, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, hasMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, setMessages, arginfo_phalcon_forms_elementinterface_setmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, appendMessage, arginfo_phalcon_forms_elementinterface_appendmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, clear, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element, __toString, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element){

	PHALCON_REGISTER_CLASS(Phalcon\\Forms, Element, forms_element, phalcon_forms_element_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_forms_element_ce, SL("_form"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_label"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_attributes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_validators"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_element_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_forms_element_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element, __construct){

	zval *name, *attributes = NULL;

	phalcon_fetch_params(0, 1, 1, &name, &attributes);
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "The element's name must be a string");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	if (attributes && Z_TYPE_P(attributes) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_attributes"), attributes, 1565778155UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Forms_Element, setForm){

	zval *form;

	phalcon_fetch_params(0, 1, 0, &form);
	
	phalcon_update_property_this_quick(this_ptr, SL("_form"), form, 3974999288UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getForm){


	RETURN_MEMBER_QUICK(this_ptr, "_form", 3974999288UL);
}

static PHP_METHOD(Phalcon_Forms_Element, setName){

	zval *name;

	phalcon_fetch_params(0, 1, 0, &name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Forms_Element, setFilters){

	zval *filters;

	phalcon_fetch_params(0, 1, 0, &filters);
	
	phalcon_update_property_this_quick(this_ptr, SL("_filters"), filters, 3850488637UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, addFilter){

	zval *filter, *filters, *new_filters;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &filter);
	
	PHALCON_OBS_VAR(filters);
	phalcon_read_property_this(&filters, this_ptr, SL("_filters"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		phalcon_update_property_array_append(this_ptr, SL("_filters"), filter TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(new_filters);
		array_init_size(new_filters, 2);
		if (Z_TYPE_P(filters) == IS_STRING) {
			phalcon_array_append(&new_filters, filters, 0);
		}

		phalcon_array_append(&new_filters, filter, 0);
		phalcon_update_property_this_quick(this_ptr, SL("_filters"), new_filters, 3850488637UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Forms_Element, getFilters){


	RETURN_MEMBER_QUICK(this_ptr, "_filters", 3850488637UL);
}

static PHP_METHOD(Phalcon_Forms_Element, addValidators){

	zval *validators, *merge = NULL, *current_validators;
	zval *merged_validators = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &validators, &merge);
	
	if (!merge) {
		merge = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(validators) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_forms_exception_ce, "The validators parameter must be an array");
		return;
	}

	if (zend_is_true(merge)) {
		current_validators = phalcon_fetch_nproperty_this(this_ptr, SL("_validators"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_validators) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_validators);
			phalcon_fast_array_merge(merged_validators, &current_validators, &validators TSRMLS_CC);
		} else {
			merged_validators = validators;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_validators"), merged_validators, 2342846045UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Forms_Element, addValidator){

	zval *validator;

	phalcon_fetch_params(0, 1, 0, &validator);
	
	if (Z_TYPE_P(validator) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "The validators parameter must be an object");
		return;
	}
	phalcon_update_property_array_append(this_ptr, SL("_validators"), validator TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getValidators){


	RETURN_MEMBER_QUICK(this_ptr, "_validators", 2342846045UL);
}

static PHP_METHOD(Phalcon_Forms_Element, prepareAttributes){

	zval *attributes = NULL, *use_checked = NULL, *name, *widget_attributes = NULL;
	zval *default_attributes, *merged_attributes = NULL;
	zval *value = NULL, *current_value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &attributes, &use_checked);
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	if (!use_checked) {
		use_checked = PHALCON_GLOBAL(z_false);
	}
	
	name = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_INIT_VAR(widget_attributes);
		array_init(widget_attributes);
	} else {
		PHALCON_CPY_WRT(widget_attributes, attributes);
	}
	
	phalcon_array_update_long(&widget_attributes, 0, name, PH_COPY | PH_SEPARATE);
	
	default_attributes = phalcon_fetch_nproperty_this(this_ptr, SL("_attributes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(default_attributes) == IS_ARRAY) { 
		PHALCON_INIT_VAR(merged_attributes);
		phalcon_fast_array_merge(merged_attributes, &default_attributes, &widget_attributes TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(merged_attributes, widget_attributes);
	}
	
	PHALCON_CALL_METHOD(&value, this_ptr, "getvalue");
	
	if (Z_TYPE_P(value) != IS_NULL) {
		if (zend_is_true(use_checked)) {
	
			if (phalcon_array_isset_string_fetch(&current_value, merged_attributes, SS("value"))) {
				if (PHALCON_IS_EQUAL(current_value, value)) {
					phalcon_array_update_string_string(&merged_attributes, SL("checked"), SL("checked"), PH_SEPARATE);
				}
			} else {
				if (zend_is_true(value)) {
					phalcon_array_update_string_string(&merged_attributes, SL("checked"), SL("checked"), PH_SEPARATE);
				}
				phalcon_array_update_string(&merged_attributes, SL("value"), value, PH_COPY | PH_SEPARATE);
			}
		} else {
			phalcon_array_update_string(&merged_attributes, SL("value"), value, PH_COPY | PH_SEPARATE);
		}
	}
	
	RETURN_CTOR(merged_attributes);
}

static PHP_METHOD(Phalcon_Forms_Element, setAttribute){

	zval *attribute, *value;

	phalcon_fetch_params(0, 2, 0, &attribute, &value);
	
	phalcon_update_property_array(this_ptr, SL("_attributes"), attribute, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getAttribute){

	zval *attribute, *default_value = NULL, *attributes;
	zval *value;

	phalcon_fetch_params(0, 1, 1, &attribute, &default_value);
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	attributes = phalcon_fetch_nproperty_this(this_ptr, SL("_attributes"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, attributes, attribute)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_ZVAL(default_value, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Element, setAttributes){

	zval *attributes;

	phalcon_fetch_params(0, 1, 0, &attributes);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "Parameter 'attributes' must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_attributes"), attributes, 1565778155UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getAttributes){

	zval *attributes;

	attributes = phalcon_fetch_nproperty_this(this_ptr, SL("_attributes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		array_init(return_value);
		return;
	}
	
	RETURN_ZVAL(attributes, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Element, setUserOption){

	zval *option, *value;

	phalcon_fetch_params(0, 2, 0, &option, &value);
	
	phalcon_update_property_array(this_ptr, SL("_options"), option, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getUserOption){

	zval *option, *default_value = NULL, *options, *value;

	phalcon_fetch_params(0, 1, 1, &option, &default_value);
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, options, option)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_ZVAL(default_value, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Element, setUserOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "Parameter 'options' must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getUserOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Forms_Element, setLabel){

	zval *label;

	phalcon_fetch_params(0, 1, 0, &label);
	
	phalcon_update_property_this_quick(this_ptr, SL("_label"), label, 2543586948UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getLabel){


	RETURN_MEMBER_QUICK(this_ptr, "_label", 2543586948UL);
}

static PHP_METHOD(Phalcon_Forms_Element, label){

	zval *label, *attributes = NULL, *name = NULL, *html = NULL, *key = NULL, *value = NULL;
	zval *escaped;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &attributes);

	label = phalcon_fetch_nproperty_this(this_ptr, SL("_label"), PH_NOISY TSRMLS_CC);
	
	if (!attributes || !phalcon_array_isset_string_fetch(&name, attributes, SS("id"))) {
		name = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	}

	PHALCON_INIT_VAR(escaped);
	phalcon_htmlspecialchars(escaped, name, NULL, NULL TSRMLS_CC);

	PHALCON_INIT_VAR(html);
	PHALCON_CONCAT_SVS(html, "<label for=\"", escaped, "\"");

	zval_dtor(escaped);
	ZVAL_NULL(escaped);

	if (attributes && Z_TYPE_P(attributes) == IS_ARRAY) {	
		phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
		
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);
		
			if (Z_TYPE_P(key) != IS_LONG) {
				phalcon_htmlspecialchars(escaped, value, NULL, NULL TSRMLS_CC);
				PHALCON_SCONCAT_SVSVS(html, " ", key, "=\"", escaped, "\"");
				zval_dtor(escaped);
				ZVAL_NULL(escaped);
			}
		
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}
		
	if (zend_is_true(label)) {
		PHALCON_CONCAT_VSVS(return_value, html, ">", label, "</label>");
	} else {
		PHALCON_CONCAT_VSVS(return_value, html, ">", name, "</label>");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Forms_Element, setDefault){

	zval *value;

	phalcon_fetch_params(0, 1, 0, &value);
	
	phalcon_update_property_this_quick(this_ptr, SL("_value"), value, 2935317441UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, getDefault){


	RETURN_MEMBER_QUICK(this_ptr, "_value", 2935317441UL);
}

static PHP_METHOD(Phalcon_Forms_Element, getValue){

	zval *name, *value = NULL, *form, *has_default_value = NULL;

	PHALCON_MM_GROW();

	name = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	
	form = phalcon_fetch_nproperty_this(this_ptr, SL("_form"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(form) == IS_OBJECT) {
	
		PHALCON_CALL_CE_STATIC(&has_default_value, phalcon_tag_ce, "hasvalue", name);
		if (!zend_is_true(has_default_value)) {
			PHALCON_CALL_METHOD(&value, form, "getvalue", name);
		}
		else {
			PHALCON_INIT_VAR(value);
		}
	}
	else {
		PHALCON_INIT_VAR(value);
	}
	
	if (Z_TYPE_P(value) == IS_NULL) {
		PHALCON_OBS_NVAR(value);
		phalcon_read_property_this(&value, this_ptr, SL("_value"), PH_NOISY TSRMLS_CC);
	}
	
	RETURN_CCTOR(value);
}

static PHP_METHOD(Phalcon_Forms_Element, getMessages){

	zval *messages;

	PHALCON_MM_GROW();

	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_OBJECT) {
		RETURN_CTOR(messages);
	}
	
	object_init_ex(return_value, phalcon_validation_message_group_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct");
	
	phalcon_update_property_this_quick(this_ptr, SL("_messages"), return_value, 743366684UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Forms_Element, hasMessages){

	zval *messages;

	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_OBJECT) {
		if (phalcon_fast_count_ev(messages TSRMLS_CC)) {
			RETURN_TRUE;
		}
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Forms_Element, setMessages){

	zval *group;

	phalcon_fetch_params(0, 1, 0, &group);
	
	if (Z_TYPE_P(group) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "The message group is not valid");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_messages"), group, 743366684UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, appendMessage){

	zval *message, *messages = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	PHALCON_OBS_VAR(messages);
	phalcon_read_property_this(&messages, this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) != IS_OBJECT) {
		PHALCON_INIT_NVAR(messages);
		object_init_ex(messages, phalcon_validation_message_group_ce);
		PHALCON_CALL_METHOD(NULL, messages, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_messages"), messages, 743366684UL TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(NULL, messages, "appendmessage", message);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Forms_Element, clear)
{
	zval *name = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_CE_STATICW(NULL, phalcon_tag_ce, "setdefault", name, PHALCON_GLOBAL(z_null));
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element, __toString)
{
	if (FAILURE == phalcon_return_call_method(return_value, return_value_ptr, this_ptr, "render", 0, NULL TSRMLS_CC)) {
		if (EG(exception)) {
			zval *e = EG(exception);
			zval *m = zend_read_property(Z_OBJCE_P(e), e, SL("message"), 1 TSRMLS_CC);

			Z_ADDREF_P(m);
			if (Z_TYPE_P(m) != IS_STRING) {
				convert_to_string_ex(&m);
			}

			zend_clear_exception(TSRMLS_C);
			zend_error(E_ERROR, "%s", Z_STRVAL_P(m));
			zval_ptr_dtor(&m);
		}
	}
}





zend_class_entry *phalcon_forms_elementinterface_ce;

static const zend_function_entry phalcon_forms_elementinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setForm, arginfo_phalcon_forms_elementinterface_setform)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getForm, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setName, arginfo_phalcon_forms_elementinterface_setname)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setFilters, arginfo_phalcon_forms_elementinterface_setfilters)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, addFilter, arginfo_phalcon_forms_elementinterface_addfilter)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getFilters, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, addValidators, arginfo_phalcon_forms_elementinterface_addvalidators)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, addValidator, arginfo_phalcon_forms_elementinterface_addvalidator)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getValidators, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, prepareAttributes, arginfo_phalcon_forms_elementinterface_prepareattributes)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setAttribute, arginfo_phalcon_forms_elementinterface_setattribute)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getAttribute, arginfo_phalcon_forms_elementinterface_getattribute)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setAttributes, arginfo_phalcon_forms_elementinterface_setattributes)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getAttributes, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setUserOption, arginfo_phalcon_forms_elementinterface_setuseroption)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getUserOption, arginfo_phalcon_forms_elementinterface_getuseroption)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setUserOptions, arginfo_phalcon_forms_elementinterface_setuseroptions)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getUserOptions, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setLabel, arginfo_phalcon_forms_elementinterface_setlabel)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getLabel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, label, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setDefault, arginfo_phalcon_forms_elementinterface_setdefault)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getDefault, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getValue, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, getMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, hasMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, setMessages, arginfo_phalcon_forms_elementinterface_setmessages)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, appendMessage, arginfo_phalcon_forms_elementinterface_appendmessage)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, clear, NULL)
	PHP_ABSTRACT_ME(Phalcon_Forms_ElementInterface, render, arginfo_phalcon_forms_elementinterface_render)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_ElementInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Forms, ElementInterface, forms_elementinterface, phalcon_forms_elementinterface_method_entry);

	return SUCCESS;
}





































zend_class_entry *phalcon_forms_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Forms_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms, Exception, forms_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_forms_form_ce;

static PHP_METHOD(Phalcon_Forms_Form, __construct);
static PHP_METHOD(Phalcon_Forms_Form, setAction);
static PHP_METHOD(Phalcon_Forms_Form, getAction);
static PHP_METHOD(Phalcon_Forms_Form, setUserOption);
static PHP_METHOD(Phalcon_Forms_Form, getUserOption);
static PHP_METHOD(Phalcon_Forms_Form, setUserOptions);
static PHP_METHOD(Phalcon_Forms_Form, getUserOptions);
static PHP_METHOD(Phalcon_Forms_Form, setEntity);
static PHP_METHOD(Phalcon_Forms_Form, getEntity);
static PHP_METHOD(Phalcon_Forms_Form, getElements);
static PHP_METHOD(Phalcon_Forms_Form, bind);
static PHP_METHOD(Phalcon_Forms_Form, isValid);
static PHP_METHOD(Phalcon_Forms_Form, getMessages);
static PHP_METHOD(Phalcon_Forms_Form, getMessagesFor);
static PHP_METHOD(Phalcon_Forms_Form, hasMessagesFor);
static PHP_METHOD(Phalcon_Forms_Form, add);
static PHP_METHOD(Phalcon_Forms_Form, render);
static PHP_METHOD(Phalcon_Forms_Form, get);
static PHP_METHOD(Phalcon_Forms_Form, label);
static PHP_METHOD(Phalcon_Forms_Form, getLabel);
static PHP_METHOD(Phalcon_Forms_Form, getValue);
static PHP_METHOD(Phalcon_Forms_Form, has);
static PHP_METHOD(Phalcon_Forms_Form, remove);
static PHP_METHOD(Phalcon_Forms_Form, clear);
static PHP_METHOD(Phalcon_Forms_Form, count);
static PHP_METHOD(Phalcon_Forms_Form, rewind);
static PHP_METHOD(Phalcon_Forms_Form, current);
static PHP_METHOD(Phalcon_Forms_Form, key);
static PHP_METHOD(Phalcon_Forms_Form, next);
static PHP_METHOD(Phalcon_Forms_Form, valid);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, entity)
	ZEND_ARG_INFO(0, userOptions)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_setaction, 0, 0, 1)
	ZEND_ARG_INFO(0, action)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_setuseroption, 0, 0, 2)
	ZEND_ARG_INFO(0, option)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_getuseroption, 0, 0, 1)
	ZEND_ARG_INFO(0, option)
	ZEND_ARG_INFO(0, defaultValue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_setuseroptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_setentity, 0, 0, 1)
	ZEND_ARG_INFO(0, entity)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_bind, 0, 0, 2)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, entity)
	ZEND_ARG_INFO(0, whitelist)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_isvalid, 0, 0, 0)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, entity)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_getmessages, 0, 0, 0)
	ZEND_ARG_INFO(0, byItemName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_getmessagesfor, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_hasmessagesfor, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_add, 0, 0, 1)
	ZEND_ARG_INFO(0, element)
	ZEND_ARG_INFO(0, postion)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_render, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_get, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_label, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_getlabel, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_getvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_has, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_remove, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_form_clear, 0, 0, 0)
	ZEND_ARG_INFO(0, fields)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_forms_form_method_entry[] = {
	PHP_ME(Phalcon_Forms_Form, __construct, arginfo_phalcon_forms_form___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Forms_Form, setAction, arginfo_phalcon_forms_form_setaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getAction, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, setUserOption, arginfo_phalcon_forms_form_setuseroption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getUserOption, arginfo_phalcon_forms_form_getuseroption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, setUserOptions, arginfo_phalcon_forms_form_setuseroptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getUserOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, setEntity, arginfo_phalcon_forms_form_setentity, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getEntity, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getElements, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, bind, arginfo_phalcon_forms_form_bind, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, isValid, arginfo_phalcon_forms_form_isvalid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getMessages, arginfo_phalcon_forms_form_getmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getMessagesFor, arginfo_phalcon_forms_form_getmessagesfor, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, hasMessagesFor, arginfo_phalcon_forms_form_hasmessagesfor, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, add, arginfo_phalcon_forms_form_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, render, arginfo_phalcon_forms_form_render, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, get, arginfo_phalcon_forms_form_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, label, arginfo_phalcon_forms_form_label, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getLabel, arginfo_phalcon_forms_form_getlabel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, getValue, arginfo_phalcon_forms_form_getvalue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, has, arginfo_phalcon_forms_form_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, remove, arginfo_phalcon_forms_form_remove, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, clear, arginfo_phalcon_forms_form_clear, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, count, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, rewind, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, current, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, key, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, next, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Form, valid, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

static zend_object_handlers phalcon_forms_form_object_handlers;

static void phalcon_forms_form_dtor(zend_object_iterator *it TSRMLS_DC)
{
	zval_ptr_dtor((zval**)&it->data);
	efree(it);
}

static int phalcon_forms_form_valid(zend_object_iterator *it TSRMLS_DC)
{
	zval *position, *elements;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	elements = phalcon_fetch_nproperty_this((zval*)it->data, SL("_elementsIndexed"), PH_NOISY TSRMLS_CC);
	return (phalcon_array_isset(elements, position)) ? SUCCESS : FAILURE;
}

static void phalcon_forms_form_get_current_data(zend_object_iterator *it, zval ***data TSRMLS_DC)
{
	zval *position, *elements;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	elements = phalcon_fetch_nproperty_this((zval*)it->data, SL("_elementsIndexed"), PH_NOISY TSRMLS_CC);
	*data = phalcon_hash_get(Z_ARRVAL_P(elements), position, BP_VAR_NA);
}

#if ZEND_MODULE_API_NO >= 20121212
static void phalcon_forms_form_get_current_key(zend_object_iterator *it, zval *key TSRMLS_DC)
{
	zval *position;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	ZVAL_ZVAL(key, position, 1, 0);
}
#else
static int phalcon_forms_form_get_current_key(zend_object_iterator *it, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC)
{
	zval *position;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	*int_key = (IS_LONG == Z_TYPE_P(position)) ? Z_LVAL_P(position) : phalcon_get_intval(position);
	return HASH_KEY_IS_LONG;
}
#endif

static void phalcon_forms_form_move_forward(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_property_incr((zval*)it->data, SL("_position") TSRMLS_CC);
}

static void phalcon_forms_form_rewind(zend_object_iterator *it TSRMLS_DC)
{
	zval *elements, *indexed;

	phalcon_update_property_long((zval*)it->data, SL("_position"), 0 TSRMLS_CC);

	elements = phalcon_fetch_nproperty_this((zval*)it->data, SL("_elements"), PH_NOISY TSRMLS_CC);

	PHALCON_ALLOC_GHOST_ZVAL(indexed);
	if (Z_TYPE_P(elements) == IS_ARRAY) {
		phalcon_array_values(indexed, elements);
	}
	else {
		array_init_size(indexed, 0);
	}

	phalcon_update_property_this((zval*)it->data, SL("_elementsIndexed"), indexed TSRMLS_CC);
}

static zend_object_iterator_funcs phalcon_forms_form_iterator_funcs = {
	phalcon_forms_form_dtor,
	phalcon_forms_form_valid,
	phalcon_forms_form_get_current_data,
	phalcon_forms_form_get_current_key,
	phalcon_forms_form_move_forward,
	phalcon_forms_form_rewind,
	NULL
};

static zend_object_iterator* phalcon_forms_form_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)
{
	zend_object_iterator *result;

	if (by_ref) {
		zend_throw_exception_ex(phalcon_validation_exception_ce, 0 TSRMLS_CC, "Cannot iterate Phalcon\\Froms\\Form by reference");
		return NULL;
	}

	result = emalloc(sizeof(zend_object_iterator));

	Z_ADDREF_P(object);
	result->data  = object;
	result->funcs = &phalcon_forms_form_iterator_funcs;

	return result;
}

static int phalcon_forms_form_count_elements(zval *object, long int *count TSRMLS_DC)
{
	int res;
	zval *cnt = NULL;

	if (is_phalcon_class(Z_OBJCE_P(object))) {
		zval *elements = phalcon_fetch_nproperty_this(object, SL("_elements"), PH_NOISY TSRMLS_CC);
		*count = (Z_TYPE_P(elements) == IS_ARRAY) ? zend_hash_num_elements(Z_ARRVAL_P(elements)) : 0;
		return SUCCESS;
	}

	res = phalcon_call_method(&cnt, object, "count", 0, NULL TSRMLS_CC);
	if (res == SUCCESS) {
		*count = (Z_TYPE_P(cnt) == IS_LONG) ? Z_LVAL_P(cnt) : phalcon_get_intval(cnt);
		zval_ptr_dtor(&cnt);
	}

	return res;
}

PHALCON_INIT_CLASS(Phalcon_Forms_Form){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms, Form, forms_form, phalcon_di_injectable_ce, phalcon_forms_form_method_entry, 0);

	zend_declare_property_null(phalcon_forms_form_ce, SL("_position"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_entity"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_elements"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_elementsIndexed"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_forms_form_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);

	phalcon_forms_form_ce->get_iterator         = phalcon_forms_form_get_iterator;
	phalcon_forms_form_ce->iterator_funcs.funcs = &phalcon_forms_form_iterator_funcs;

	phalcon_forms_form_object_handlers = *zend_get_std_object_handlers();
	phalcon_forms_form_object_handlers.count_elements = phalcon_forms_form_count_elements;

	zend_class_implements(phalcon_forms_form_ce TSRMLS_CC, 2, spl_ce_Countable, zend_ce_iterator);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Form, __construct){

	zval *entity = NULL, *user_options = NULL;

	Z_OBJ_HT_P(getThis()) = &phalcon_forms_form_object_handlers;

	phalcon_fetch_params(0, 0, 2, &entity, &user_options);

	if (!entity) {
		entity = PHALCON_GLOBAL(z_null);
	}

	if (!user_options) {
		user_options = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(entity) != IS_NULL) {
		if (Z_TYPE_P(entity) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "The base entity is not valid");
			return;
		}

		phalcon_update_property_this_quick(this_ptr, SL("_entity"), entity, 2413912609UL TSRMLS_CC);
	}

	if (Z_TYPE_P(user_options) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_options"), user_options, 1620153008UL TSRMLS_CC);
	}

	if (phalcon_method_quick_exists_ex(this_ptr, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, this_ptr, "initialize", entity, user_options);
		PHALCON_MM_RESTORE();
	}
}

static PHP_METHOD(Phalcon_Forms_Form, setAction){

	zval *action;

	phalcon_fetch_params(0, 1, 0, &action);

	phalcon_update_property_this_quick(this_ptr, SL("_action"), action, 1112512898UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Form, getAction){


	RETURN_MEMBER_QUICK(this_ptr, "_action", 1112512898UL);
}

static PHP_METHOD(Phalcon_Forms_Form, setUserOption){

	zval *option, *value;

	phalcon_fetch_params(0, 2, 0, &option, &value);

	phalcon_update_property_array(this_ptr, SL("_options"), option, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Form, getUserOption){

	zval *option, *default_value = NULL, *options, *value;

	phalcon_fetch_params(0, 1, 1, &option, &default_value);

	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, options, option)) {
		RETURN_ZVAL(value, 1, 0);
	}

	RETURN_ZVAL(default_value, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Form, setUserOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);

	if (Z_TYPE_P(options) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_forms_exception_ce, "Parameter 'options' must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);

	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Form, getUserOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Forms_Form, setEntity){

	zval *entity;

	phalcon_fetch_params(0, 1, 0, &entity);

	if (Z_TYPE_P(entity) != IS_NULL && Z_TYPE_P(entity) != IS_OBJECT) {
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "'%s' must be an object or NULL", "entity");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_entity"), entity, 2413912609UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Form, getEntity){


	RETURN_MEMBER_QUICK(this_ptr, "_entity", 2413912609UL);
}

static PHP_METHOD(Phalcon_Forms_Form, getElements){


	RETURN_MEMBER_QUICK(this_ptr, "_elements", 3134610529UL);
}

static PHP_METHOD(Phalcon_Forms_Form, bind){

	zval *data, *entity, *whitelist = NULL, *elements, *filter = NULL;
	zval *value = NULL, *key = NULL, *element = NULL, *filters = NULL, *service_name = NULL;
	zval *dependency_injector = NULL, *filtered_value = NULL;
	zval *method = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &data, &entity, &whitelist);

	if (!whitelist) {
		whitelist = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(data) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_forms_exception_ce, "The data must be an array");
		return;
	}

	PHALCON_OBS_VAR(elements);
	phalcon_read_property_this(&elements, this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(elements) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_forms_exception_ce, "There are no elements in the form");
		return;
	}

	PHALCON_INIT_VAR(filter);

	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);

		if (!phalcon_array_isset(elements, key)) {
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}

		if (Z_TYPE_P(whitelist) == IS_ARRAY) {
			if (!phalcon_fast_in_array(key, whitelist TSRMLS_CC)) {
				zend_hash_move_forward_ex(ah0, &hp0);
				continue;
			}
		}

		PHALCON_OBS_NVAR(element);
		phalcon_array_fetch(&element, elements, key, PH_NOISY);

		PHALCON_CALL_METHOD(&filters, element, "getfilters");
		if (zend_is_true(filters)) {

			if (Z_TYPE_P(filter) != IS_OBJECT) {

				PHALCON_INIT_NVAR(service_name);
				PHALCON_ZVAL_MAYBE_INTERNED_STRING(service_name, phalcon_interned_filter);

				PHALCON_CALL_METHOD(&dependency_injector, this_ptr, "getdi");
				PHALCON_VERIFY_INTERFACE(dependency_injector, phalcon_diinterface_ce);

				PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service_name);
				PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
			}

			PHALCON_CALL_METHOD(&filtered_value, filter, "sanitize", value, filters);
		} else {
			PHALCON_CPY_WRT(filtered_value, value);
		}

		PHALCON_INIT_NVAR(method);
		PHALCON_CONCAT_SV(method, "set", key);
		zend_str_tolower(Z_STRVAL_P(method), Z_STRLEN_P(method));

		if (phalcon_method_exists(entity, method TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(NULL, entity, Z_STRVAL_P(method), filtered_value);
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}

		phalcon_update_property_zval_zval(entity, key, filtered_value TSRMLS_CC);

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Forms_Form, isValid){

	zval *data = NULL, *entity = NULL, *elements, *status = NULL, *not_failed = NULL;
	zval *messages, *element = NULL, *validators = NULL, *name = NULL, *prepared_validators = NULL;
	zval *validator = NULL, *scope = NULL, *validation = NULL, *filters = NULL;
	zval *element_messages = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &entity);

	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}

	if (!entity) {
		entity = PHALCON_GLOBAL(z_null);
	}

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(elements) != IS_ARRAY) {
		RETURN_MM_TRUE;
	}

	if (Z_TYPE_P(entity) == IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "bind", data, entity);
	}

	if (Z_TYPE_P(data) != IS_ARRAY) {
		data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	}

	if (phalcon_method_quick_exists_ex(this_ptr, SS("beforevalidation"), 4025473891UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&status, this_ptr, "beforevalidation", data, entity);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_CTOR(status);
		}
	}

	not_failed = PHALCON_GLOBAL(z_true);

	PHALCON_INIT_VAR(messages);
	array_init(messages);

	phalcon_is_iterable(elements, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HVALUE(element);

		PHALCON_CALL_METHOD(&validators, element, "getvalidators");
		if (Z_TYPE_P(validators) == IS_ARRAY) {
			if (phalcon_fast_count_ev(validators TSRMLS_CC)) {

				PHALCON_CALL_METHOD(&name, element, "getname");

				PHALCON_INIT_NVAR(prepared_validators);
				array_init(prepared_validators);

				phalcon_is_iterable(validators, &ah1, &hp1, 0, 0);

				while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {

					PHALCON_GET_HVALUE(validator);

					PHALCON_INIT_NVAR(scope);
					array_init_size(scope, 2);
					phalcon_array_append(&scope, name, 0);
					phalcon_array_append(&scope, validator, 0);
					phalcon_array_append(&prepared_validators, scope, PH_SEPARATE);

					zend_hash_move_forward_ex(ah1, &hp1);
				}

				PHALCON_INIT_NVAR(validation);
				object_init_ex(validation, phalcon_validation_ce);
				PHALCON_CALL_METHOD(NULL, validation, "__construct", prepared_validators);

				PHALCON_CALL_METHOD(&filters, element, "getfilters");

				if (Z_TYPE_P(filters) == IS_ARRAY) {
					PHALCON_CALL_METHOD(&name, element, "getname");
					PHALCON_CALL_METHOD(NULL, validation, "setfilters", name, filters);
				}

				PHALCON_CALL_METHOD(&element_messages, validation, "validate", data, entity);
				if (phalcon_fast_count_ev(element_messages TSRMLS_CC)) {
					PHALCON_CALL_METHOD(&name, element, "getname");
					phalcon_array_update_zval(&messages, name, element_messages, PH_COPY | PH_SEPARATE);

					not_failed = PHALCON_GLOBAL(z_false);
				}
			}
		}

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	if (!zend_is_true(not_failed)) {
		phalcon_update_property_this_quick(this_ptr, SL("_messages"), messages, 743366684UL TSRMLS_CC);
	}

	if (phalcon_method_quick_exists_ex(this_ptr, SS("aftervalidation"), 1795965282UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "aftervalidation", messages);
	}


	RETURN_NCTOR(not_failed);
}

static PHP_METHOD(Phalcon_Forms_Form, getMessages){

	zval **by_item_name = NULL, *messages;

	phalcon_fetch_params_ex(0, 1, &by_item_name);

	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (by_item_name && zend_is_true(*by_item_name)) {
		if (Z_TYPE_P(messages) != IS_ARRAY) {
			object_init_ex(return_value, phalcon_validation_message_group_ce);
			phalcon_validation_group_construct_helper(return_value, NULL TSRMLS_CC);
		}
		else {
			RETURN_ZVAL(messages, 1, 0);
		}
	}
	else {
		object_init_ex(return_value, phalcon_validation_message_group_ce);
		phalcon_validation_group_construct_helper(return_value, NULL TSRMLS_CC);

		if (Z_TYPE_P(messages) == IS_ARRAY) {
			HashPosition hp;
			zval **v;

			for (
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(messages), &hp);
				zend_hash_get_current_data_ex(Z_ARRVAL_P(messages), (void**)&v, &hp) == SUCCESS;
				zend_hash_move_forward_ex(Z_ARRVAL_P(messages), &hp)
			) {
				PHALCON_CALL_METHODW(NULL, return_value, "appendmessages", *v);
			}
		}
	}
}

static PHP_METHOD(Phalcon_Forms_Form, getMessagesFor){

	zval **name, *messages, *element_messages;

	phalcon_fetch_params_ex(1, 0, &name);

	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&element_messages, messages, *name)) {
		RETURN_ZVAL(element_messages, 1, 0);
	}

	object_init_ex(return_value, phalcon_validation_message_group_ce);
	phalcon_validation_group_construct_helper(return_value, NULL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Forms_Form, hasMessagesFor){

	zval **name, *messages;

	phalcon_fetch_params_ex(1, 0, &name);

	messages = phalcon_fetch_nproperty_this(this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(messages, *name));
}

static PHP_METHOD(Phalcon_Forms_Form, add){

	zval *element, *pos = NULL, *type = NULL, *name = NULL, *values, *elements;
	zval *tmp0 = NULL, *tmp1 = NULL, *length, *offset, *preserve_keys;
	int found = 0, i = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &element, &pos, &type);

	PHALCON_VERIFY_INTERFACE_EX(element, phalcon_forms_elementinterface_ce, phalcon_forms_exception_ce, 1);

	PHALCON_CALL_METHOD(&name, element, "getname");

	PHALCON_CALL_METHOD(NULL, element, "setform", this_ptr);

	if (!pos || Z_TYPE_P(pos) == IS_NULL) {
		/* Append the element by its name */
		phalcon_update_property_array(this_ptr, SL("_elements"), name, element TSRMLS_CC);
	} else {
		if (type && zend_is_true(type)) {
			i = -1;
		}

		PHALCON_INIT_VAR(values);
		array_init_size(values, 1);

		phalcon_array_update_zval(&values, name, element, PH_COPY);

		elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);

		if (Z_TYPE_P(elements) == IS_ARRAY) {
			HashPosition hp;

			for (
				zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(elements), &hp);
				zend_hash_get_current_key_type_ex(Z_ARRVAL_P(elements), &hp) != HASH_KEY_NON_EXISTANT;
				zend_hash_move_forward_ex(Z_ARRVAL_P(elements), &hp)
			) {
				zval key = phalcon_get_current_key_w(Z_ARRVAL_P(elements), &hp);

				++i;
				if (phalcon_is_equal(&key, pos TSRMLS_CC)) {
					found = 1;
					break;
				}
			}
		}

		if (!found) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_forms_exception_ce, "Array position does not exist");
			return;
		}

		PHALCON_INIT_VAR(offset);
		ZVAL_LONG(offset, i);

		length        = PHALCON_GLOBAL(z_zero);
		preserve_keys = PHALCON_GLOBAL(z_true);

		PHALCON_CALL_FUNCTION(&tmp0, "array_slice", elements, length, offset, preserve_keys);

		length = PHALCON_GLOBAL(z_null);

		PHALCON_CALL_FUNCTION(&tmp1, "array_slice", elements, offset, length, preserve_keys);

		PHALCON_INIT_NVAR(elements);
		array_init(elements);

		phalcon_array_merge_recursive_n(&elements, tmp0);
		phalcon_array_merge_recursive_n(&elements, values);
		phalcon_array_merge_recursive_n(&elements, tmp1);

		phalcon_update_property_this_quick(this_ptr, SL("_elements"), elements, 3134610529UL TSRMLS_CC);
	}

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Forms_Form, render){

	zval **name, **attributes = NULL, *elements, *element;

	phalcon_fetch_params_ex(1, 1, &name, &attributes);

	PHALCON_ENSURE_IS_STRING(name);
	if (!attributes) {
		attributes = &PHALCON_GLOBAL(z_null);
	}

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&element, elements, *name)) {
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "Element with ID=%s is not a part of the form", Z_STRVAL_P(*name));
		return;
	}

	PHALCON_RETURN_CALL_METHODW(element, "render", *attributes);
}

static PHP_METHOD(Phalcon_Forms_Form, get){

	zval **name, *elements, *element;

	phalcon_fetch_params_ex(1, 0, &name);

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&element, elements, *name)) {
		PHALCON_ENSURE_IS_STRING(name);
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "Element with ID=%s is not a part of the form", Z_STRVAL_P(*name));
		return;
	}

	RETURN_ZVAL(element, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Form, label){

	zval **name, **attributes = NULL, *elements, *element;

	phalcon_fetch_params_ex(1, 1, &name, &attributes);

	if (!attributes) {
		attributes = &PHALCON_GLOBAL(z_null);
	}

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&element, elements, *name)) {
		PHALCON_ENSURE_IS_STRING(name);
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "Element with ID=%s is not a part of the form", Z_STRVAL_P(*name));
		return;
	}

	PHALCON_RETURN_CALL_METHODW(element, "label", *attributes);
}

static PHP_METHOD(Phalcon_Forms_Form, getLabel){

	zval **name, *elements, *element, *label = NULL;

	phalcon_fetch_params_ex(1, 0, &name);

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&element, elements, *name)) {
		PHALCON_ENSURE_IS_STRING(name);
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "Element with ID=%s is not a part of the form", Z_STRVAL_P(*name));
		return;
	}

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD(&label, element, "getlabel");

	/* Use the element's name as label if the label is not available */
	if (!zend_is_true(label)) {
		RETURN_CTOR(*name);
	}

	RETURN_CTOR(label);
}

static PHP_METHOD(Phalcon_Forms_Form, getValue){

	zval *name, *entity, *method, *value = NULL, *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);

	entity = phalcon_fetch_nproperty_this(this_ptr, SL("_entity"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(entity) == IS_OBJECT) {
		PHALCON_INIT_VAR(method);
		PHALCON_CONCAT_SV(method, "get", name);
		zend_str_tolower(Z_STRVAL_P(method), Z_STRLEN_P(method));
		if (phalcon_method_exists_ex(entity, Z_STRVAL_P(method), Z_STRLEN_P(method)+1 TSRMLS_CC) == SUCCESS) {
			PHALCON_RETURN_CALL_METHOD(entity, Z_STRVAL_P(method));
			RETURN_MM();
		}

		if (phalcon_isset_property_zval(entity, name TSRMLS_CC)) {
			PHALCON_OBS_VAR(value);
			phalcon_read_property_zval(&value, entity, name, PH_NOISY TSRMLS_CC);
			RETURN_CTOR(value);
		}
	}

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(data) == IS_ARRAY) {

		if (phalcon_array_isset_fetch(&value, data, name)) {
			RETURN_CTOR(value);
		}
	}

	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Forms_Form, has){

	zval **name, *elements;

	phalcon_fetch_params_ex(1, 0, &name);

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(elements, *name));
}

static PHP_METHOD(Phalcon_Forms_Form, remove){

	zval *name, *elements;

	phalcon_fetch_params(0, 1, 0, &name);

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);

	if (phalcon_array_isset(elements, name)) {
		phalcon_unset_property_array(this_ptr, SL("_elements"), name TSRMLS_CC);

		/* Clean the iterator index */
		phalcon_update_property_null(this_ptr, SL("_elementsIndexed") TSRMLS_CC);

		RETURN_TRUE;
	}

	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Forms_Form, clear){

	zval *fields = NULL, *elements, *element = NULL, *name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &fields);

	if (!fields) {
		fields = PHALCON_GLOBAL(z_null);
	}

	elements = phalcon_fetch_nproperty_this(this_ptr, SL("_elements"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(elements) == IS_ARRAY) {

		phalcon_is_iterable(elements, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HVALUE(element);

			if (Z_TYPE_P(fields) != IS_ARRAY) {
				PHALCON_CALL_METHOD(NULL, element, "clear");
			} else {
				PHALCON_CALL_METHOD(&name, element, "getname");
				if (phalcon_fast_in_array(name, fields TSRMLS_CC)) {
					PHALCON_CALL_METHOD(NULL, element, "clear");
				}
			}

			zend_hash_move_forward_ex(ah0, &hp0);
		}

	}

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Forms_Form, count){

	long int count;

	if (SUCCESS == phalcon_forms_form_count_elements(getThis(), &count TSRMLS_CC)) {
		RETURN_LONG(count);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Forms_Form, rewind){

	zend_object_iterator it;
	it.data = getThis();
	phalcon_forms_form_iterator_funcs.rewind(&it TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Forms_Form, current){

	zval **ret;
	zend_object_iterator it;
	it.data = getThis();

	phalcon_forms_form_iterator_funcs.get_current_data(&it, &ret TSRMLS_CC);
	if (ret) {
		RETURN_ZVAL(*ret, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Forms_Form, key){

	zend_object_iterator it;
	it.data = getThis();
#if ZEND_MODULE_API_NO >= 20121212
	phalcon_forms_form_iterator_funcs.get_current_key(&it, return_value TSRMLS_CC);
#else
	{
		char *str_key;
		uint str_key_len;
		ulong int_key;
		if (HASH_KEY_IS_STRING == phalcon_forms_form_iterator_funcs.get_current_key(&it, &str_key, &str_key_len, &int_key TSRMLS_CC)) {
			RETURN_STRINGL(str_key, str_key_len-1, 1);
		}

		RETURN_LONG(int_key);
	}
#endif
}

static PHP_METHOD(Phalcon_Forms_Form, next){

	zend_object_iterator it;
	it.data = getThis();
	phalcon_forms_form_iterator_funcs.move_forward(&it TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Forms_Form, valid){

	zend_object_iterator it;
	it.data = getThis();
	RETURN_BOOL(phalcon_forms_form_iterator_funcs.valid(&it TSRMLS_CC) == SUCCESS);
}






zend_class_entry *phalcon_forms_manager_ce;

static PHP_METHOD(Phalcon_Forms_Manager, __construct);
static PHP_METHOD(Phalcon_Forms_Manager, create);
static PHP_METHOD(Phalcon_Forms_Manager, get);
static PHP_METHOD(Phalcon_Forms_Manager, has);
static PHP_METHOD(Phalcon_Forms_Manager, set);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_manager_create, 0, 0, 0)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, entity)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_manager_get, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_manager_has, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_manager_set, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, form)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_forms_manager_method_entry[] = {
	PHP_ME(Phalcon_Forms_Manager, __construct, NULL, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Forms_Manager, create, arginfo_phalcon_forms_manager_create, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Manager, get, arginfo_phalcon_forms_manager_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Manager, has, arginfo_phalcon_forms_manager_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Manager, set, arginfo_phalcon_forms_manager_set, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

static zend_object_handlers phalcon_forms_manager_object_handlers;

static zval* phalcon_forms_manager_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval *forms, **res, tmp;

	if (UNEXPECTED(!offset)) {
		return EG(uninitialized_zval_ptr);
	}

	forms = phalcon_fetch_nproperty_this(object, SL("_forms"), PH_NOISY TSRMLS_CC);
	if (UNEXPECTED(Z_TYPE_P(forms)) != IS_ARRAY) {
		return EG(uninitialized_zval_ptr);
	}

	if (type == BP_VAR_RW) {
		type = BP_VAR_R;
	}
	else if (type == BP_VAR_W) {
		type = BP_VAR_IS;
	}

	res = phalcon_hash_get(Z_ARRVAL_P(forms), offset, type);
	if (!res || res == &EG(uninitialized_zval_ptr)) {
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_STRING)) {
			ZVAL_ZVAL(&tmp, offset, 1, 0);
			convert_to_string(&tmp);
			offset = &tmp;
		}

		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "There is no form with name='%s'", Z_STRVAL_P(offset));

		if (UNEXPECTED(offset == &tmp)) {
			zval_dtor(&tmp);
		}

		return NULL;
	}

	return *res;
}

PHALCON_INIT_CLASS(Phalcon_Forms_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Forms, Manager, forms_manager, phalcon_forms_manager_method_entry, 0);

	zend_declare_property_null(phalcon_forms_manager_ce, SL("_forms"), ZEND_ACC_PROTECTED TSRMLS_CC);

	phalcon_forms_manager_object_handlers                = *zend_get_std_object_handlers();
	phalcon_forms_manager_object_handlers.read_dimension = phalcon_forms_manager_read_dimension;

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Manager, __construct)
{
	zval *z;

	PHALCON_ALLOC_GHOST_ZVAL(z);
	array_init(z);
	phalcon_update_property_this(getThis(), SL("_forms"), z TSRMLS_CC);

	Z_OBJ_HT_P(getThis()) = &phalcon_forms_manager_object_handlers;
}

static PHP_METHOD(Phalcon_Forms_Manager, create){

	zval *name = NULL, *entity = NULL, *form;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &name, &entity);
	
	if (!name) {
		name = PHALCON_GLOBAL(z_null);
	}
	
	if (!entity) {
		entity = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_forms_exception_ce, "The form name must be string");
		return;
	}
	
	PHALCON_INIT_VAR(form);
	object_init_ex(form, phalcon_forms_form_ce);
	PHALCON_CALL_METHOD(NULL, form, "__construct", entity);
	
	phalcon_update_property_array(this_ptr, SL("_forms"), name, form TSRMLS_CC);
	
	RETURN_CTOR(form);
}

static PHP_METHOD(Phalcon_Forms_Manager, get){

	zval **name, *forms, *form;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);
	
	forms = phalcon_fetch_nproperty_this(this_ptr, SL("_forms"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&form, forms, *name)) {
		zend_throw_exception_ex(phalcon_forms_exception_ce, 0 TSRMLS_CC, "There is no form with name='%s'", Z_STRVAL_PP(name));
		return;
	}
	
	RETURN_ZVAL(form, 1, 0);
}

static PHP_METHOD(Phalcon_Forms_Manager, has){

	zval *name, *forms;

	phalcon_fetch_params(0, 1, 0, &name);
	
	forms = phalcon_fetch_nproperty_this(this_ptr, SL("_forms"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(forms, name));
}

static PHP_METHOD(Phalcon_Forms_Manager, set){

	zval **name, **form;

	phalcon_fetch_params_ex(2, 0, &name, &form);
	PHALCON_ENSURE_IS_STRING(name);
	PHALCON_VERIFY_CLASS_EX(*form, phalcon_forms_form_ce, phalcon_forms_exception_ce, 0);
	
	phalcon_update_property_array(this_ptr, SL("_forms"), *name, *form TSRMLS_CC);
	RETURN_THISW();
}





zend_class_entry *phalcon_forms_element_check_ce;

static PHP_METHOD(Phalcon_Forms_Element_Check, render);

static const zend_function_entry phalcon_forms_element_check_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Check, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Check){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Check, forms_element_check, phalcon_forms_element_ce, phalcon_forms_element_check_method_entry, 0);

	zend_class_implements(phalcon_forms_element_check_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Check, render){

	phalcon_forms_element_render_helper("checkfield", 1, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}






zend_class_entry *phalcon_forms_element_date_ce;

static PHP_METHOD(Phalcon_Forms_Element_Date, render);

static const zend_function_entry phalcon_forms_element_date_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Date, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Date){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Date, forms_element_date, phalcon_forms_element_ce, phalcon_forms_element_date_method_entry, 0);

	zend_class_implements(phalcon_forms_element_date_ce TSRMLS_CC, 0, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Date, render){

	phalcon_forms_element_render_helper("datefield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_email_ce;

static PHP_METHOD(Phalcon_Forms_Element_Email, render);

static const zend_function_entry phalcon_forms_element_email_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Email, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Email){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Email, forms_element_email, phalcon_forms_element_ce, phalcon_forms_element_email_method_entry, 0);

	zend_class_implements(phalcon_forms_element_email_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Email, render){

	phalcon_forms_element_render_helper("emailfield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_file_ce;

static PHP_METHOD(Phalcon_Forms_Element_File, render);

static const zend_function_entry phalcon_forms_element_file_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_File, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, File, forms_element_file, phalcon_forms_element_ce, phalcon_forms_element_file_method_entry, 0);

	zend_class_implements(phalcon_forms_element_file_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_File, render){

	phalcon_forms_element_render_helper("filefield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_hidden_ce;

static PHP_METHOD(Phalcon_Forms_Element_Hidden, render);

static const zend_function_entry phalcon_forms_element_hidden_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Hidden, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Hidden){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Hidden, forms_element_hidden, phalcon_forms_element_ce, phalcon_forms_element_hidden_method_entry, 0);

	zend_class_implements(phalcon_forms_element_hidden_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Hidden, render){

	phalcon_forms_element_render_helper("hiddenfield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_numeric_ce;

static PHP_METHOD(Phalcon_Forms_Element_Numeric, render);

static const zend_function_entry phalcon_forms_element_numeric_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Numeric, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Numeric){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Numeric, forms_element_numeric, phalcon_forms_element_ce, phalcon_forms_element_numeric_method_entry, 0);

	zend_class_implements(phalcon_forms_element_numeric_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Numeric, render){

	phalcon_forms_element_render_helper("numericfield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_password_ce;

static PHP_METHOD(Phalcon_Forms_Element_Password, render);

static const zend_function_entry phalcon_forms_element_password_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Password, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Password){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Password, forms_element_password, phalcon_forms_element_ce, phalcon_forms_element_password_method_entry, 0);

	zend_class_implements(phalcon_forms_element_password_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Password, render){

	phalcon_forms_element_render_helper("passwordfield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}




zend_class_entry *phalcon_forms_element_radio_ce;

static PHP_METHOD(Phalcon_Forms_Element_Radio, render);

static const zend_function_entry phalcon_forms_element_radio_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Radio, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Radio) {

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Radio, forms_element_radio, phalcon_forms_element_ce, phalcon_forms_element_radio_method_entry, 0);

	zend_class_implements(phalcon_forms_element_radio_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Radio, render){

	phalcon_forms_element_render_helper("radiofield", 1, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}






zend_class_entry *phalcon_forms_element_select_ce;

static PHP_METHOD(Phalcon_Forms_Element_Select, __construct);
static PHP_METHOD(Phalcon_Forms_Element_Select, setOptions);
static PHP_METHOD(Phalcon_Forms_Element_Select, getOptions);
static PHP_METHOD(Phalcon_Forms_Element_Select, addOption);
static PHP_METHOD(Phalcon_Forms_Element_Select, render);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_element_select___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, options)
	ZEND_ARG_INFO(0, attributes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_element_select_setoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_forms_element_select_addoption, 0, 0, 1)
	ZEND_ARG_INFO(0, option)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_forms_element_select_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Select, __construct, arginfo_phalcon_forms_element_select___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Forms_Element_Select, setOptions, arginfo_phalcon_forms_element_select_setoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element_Select, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element_Select, addOption, arginfo_phalcon_forms_element_select_addoption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Forms_Element_Select, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Select){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Select, forms_element_select, phalcon_forms_element_ce, phalcon_forms_element_select_method_entry, 0);

	zend_declare_property_null(phalcon_forms_element_select_ce, SL("_optionsValues"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_forms_element_select_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Select, __construct){

	zval *name, *options = NULL, *attributes = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &name, &options, &attributes);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_optionsValues"), options, 842653632UL TSRMLS_CC);
	PHALCON_CALL_PARENT(NULL, phalcon_forms_element_select_ce, this_ptr, "__construct", name, attributes);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Forms_Element_Select, setOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	phalcon_update_property_this_quick(this_ptr, SL("_optionsValues"), options, 842653632UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element_Select, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_optionsValues", 842653632UL);
}

static PHP_METHOD(Phalcon_Forms_Element_Select, addOption){

	zval **option, *values, *tmp;

	phalcon_fetch_params_ex(1, 0, &option);
	PHALCON_ENSURE_IS_ARRAY(option);

	values = phalcon_fetch_nproperty_this(getThis(), SL("_optionsValues"), PH_NOISY TSRMLS_CC);
	
	ALLOC_ZVAL(tmp);
	if (Z_TYPE_P(values) != IS_ARRAY) {
		MAKE_COPY_ZVAL(option, tmp);
	}
	else {
		add_function(tmp, *option, values TSRMLS_CC);
	}

	Z_SET_REFCOUNT_P(tmp, 0);
	phalcon_update_property_this(getThis(), SL("_optionsValues"), tmp TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Forms_Element_Select, render){

	zval *attributes = NULL, *options, *widget_attributes = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &attributes);
	
	if (!attributes) {
		attributes = PHALCON_GLOBAL(z_null);
	}
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_optionsValues"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&widget_attributes, this_ptr, "prepareattributes", attributes);
	PHALCON_RETURN_CALL_CE_STATIC(phalcon_tag_select_ce, "selectfield", widget_attributes, options);
	RETURN_MM();
}





zend_class_entry *phalcon_forms_element_submit_ce;

static PHP_METHOD(Phalcon_Forms_Element_Submit, render);

static const zend_function_entry phalcon_forms_element_submit_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Submit, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Submit){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Submit, forms_element_submit, phalcon_forms_element_ce, phalcon_forms_element_submit_method_entry, 0);

	zend_class_implements(phalcon_forms_element_submit_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Submit, render){

	phalcon_forms_element_render_helper("submitbutton", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_text_ce;

static PHP_METHOD(Phalcon_Forms_Element_Text, render);

static const zend_function_entry phalcon_forms_element_text_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_Text, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_Text){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, Text, forms_element_text, phalcon_forms_element_ce, phalcon_forms_element_text_method_entry, 0);

	zend_class_implements(phalcon_forms_element_text_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_Text, render){

	phalcon_forms_element_render_helper("textfield", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





zend_class_entry *phalcon_forms_element_textarea_ce;

static PHP_METHOD(Phalcon_Forms_Element_TextArea, render);

static const zend_function_entry phalcon_forms_element_textarea_method_entry[] = {
	PHP_ME(Phalcon_Forms_Element_TextArea, render, arginfo_phalcon_forms_elementinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Forms_Element_TextArea){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Forms\\Element, TextArea, forms_element_textarea, phalcon_forms_element_ce, phalcon_forms_element_textarea_method_entry, 0);

	zend_class_implements(phalcon_forms_element_textarea_ce TSRMLS_CC, 1, phalcon_forms_elementinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Forms_Element_TextArea, render){

	phalcon_forms_element_render_helper("textarea", 0, INTERNAL_FUNCTION_PARAM_PASSTHRU);
}





#include <ext/standard/head.h>



zend_class_entry *phalcon_http_cookie_ce;

static PHP_METHOD(Phalcon_Http_Cookie, __construct);
static PHP_METHOD(Phalcon_Http_Cookie, setDI);
static PHP_METHOD(Phalcon_Http_Cookie, getDI);
static PHP_METHOD(Phalcon_Http_Cookie, setValue);
static PHP_METHOD(Phalcon_Http_Cookie, getValue);
static PHP_METHOD(Phalcon_Http_Cookie, send);
static PHP_METHOD(Phalcon_Http_Cookie, restore);
static PHP_METHOD(Phalcon_Http_Cookie, delete);
static PHP_METHOD(Phalcon_Http_Cookie, useEncryption);
static PHP_METHOD(Phalcon_Http_Cookie, isUsingEncryption);
static PHP_METHOD(Phalcon_Http_Cookie, setExpiration);
static PHP_METHOD(Phalcon_Http_Cookie, getExpiration);
static PHP_METHOD(Phalcon_Http_Cookie, setPath);
static PHP_METHOD(Phalcon_Http_Cookie, getPath);
static PHP_METHOD(Phalcon_Http_Cookie, setDomain);
static PHP_METHOD(Phalcon_Http_Cookie, getDomain);
static PHP_METHOD(Phalcon_Http_Cookie, setSecure);
static PHP_METHOD(Phalcon_Http_Cookie, getSecure);
static PHP_METHOD(Phalcon_Http_Cookie, setHttpOnly);
static PHP_METHOD(Phalcon_Http_Cookie, getHttpOnly);
static PHP_METHOD(Phalcon_Http_Cookie, __toString);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, value)
	ZEND_ARG_INFO(0, expire)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, secure)
	ZEND_ARG_INFO(0, domain)
	ZEND_ARG_INFO(0, httpOnly)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_setvalue, 0, 0, 1)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_getvalue, 0, 0, 0)
	ZEND_ARG_INFO(0, filters)
	ZEND_ARG_INFO(0, defaultValue)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_useencryption, 0, 0, 1)
	ZEND_ARG_INFO(0, useEncryption)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_setexpiration, 0, 0, 1)
	ZEND_ARG_INFO(0, expire)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_setpath, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_setdomain, 0, 0, 1)
	ZEND_ARG_INFO(0, domain)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_setsecure, 0, 0, 1)
	ZEND_ARG_INFO(0, secure)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_cookie_sethttponly, 0, 0, 1)
	ZEND_ARG_INFO(0, httpOnly)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_http_cookie_method_entry[] = {
	PHP_ME(Phalcon_Http_Cookie, __construct, arginfo_phalcon_http_cookie___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Http_Cookie, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setValue, arginfo_phalcon_http_cookie_setvalue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getValue, arginfo_phalcon_http_cookie_getvalue, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, send, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, restore, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, delete, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, useEncryption, arginfo_phalcon_http_cookie_useencryption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, isUsingEncryption, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setExpiration, arginfo_phalcon_http_cookie_setexpiration, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getExpiration, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setPath, arginfo_phalcon_http_cookie_setpath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setDomain, arginfo_phalcon_http_cookie_setdomain, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getDomain, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setSecure, arginfo_phalcon_http_cookie_setsecure, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getSecure, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, setHttpOnly, arginfo_phalcon_http_cookie_sethttponly, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, getHttpOnly, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Cookie, __toString, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Cookie){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Cookie, http_cookie, phalcon_http_cookie_method_entry, 0);

	zend_declare_property_bool(phalcon_http_cookie_ce, SL("_readed"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_http_cookie_ce, SL("_restored"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_http_cookie_ce, SL("_useEncryption"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_filter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_value"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_expire"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_http_cookie_ce, SL("_path"), "/", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_domain"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_cookie_ce, SL("_secure"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_http_cookie_ce, SL("_httpOnly"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_cookie_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Cookie, __construct){

	zval **name, **value = NULL, **expire = NULL, **path = NULL, **secure = NULL, **domain = NULL;
	zval **http_only = NULL;

	phalcon_fetch_params_ex(1, 6, &name, &value, &expire, &path, &secure, &domain, &http_only);
	PHALCON_ENSURE_IS_STRING(name);

	if (!expire) {
		expire = &PHALCON_GLOBAL(z_zero);
	}
	
	phalcon_update_property_this(this_ptr, SL("_name"), *name TSRMLS_CC);

	if (value && Z_TYPE_PP(value) != IS_NULL) {
		phalcon_update_property_this(this_ptr, SL("_value"), *value TSRMLS_CC);
		phalcon_update_property_bool(this_ptr, SL("_readed"), 1 TSRMLS_CC);
	}
	
	phalcon_update_property_this(this_ptr, SL("_expire"), *expire TSRMLS_CC);

	if (path && Z_TYPE_PP(path) != IS_NULL) {
		phalcon_update_property_this(this_ptr, SL("_path"), *path TSRMLS_CC);
	}
	else {
		zval *path;
		PHALCON_ALLOC_GHOST_ZVAL(path);
		ZVAL_STRINGL(path, "/", 1, 1);
		phalcon_update_property_this_quick(this_ptr, SL("_path"), path, 3986357393UL TSRMLS_CC);
	}
	
	if (secure && Z_TYPE_PP(secure) != IS_NULL) {
		phalcon_update_property_this(this_ptr, SL("_secure"), *secure TSRMLS_CC);
	}
	
	if (domain && Z_TYPE_PP(domain) != IS_NULL) {
		phalcon_update_property_this(this_ptr, SL("_domain"), *domain TSRMLS_CC);
	}
	
	if (http_only && Z_TYPE_PP(http_only) != IS_NULL) {
		phalcon_update_property_this(this_ptr, SL("_httpOnly"), *http_only TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Http_Cookie, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_cookie_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Cookie, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Http_Cookie, setValue){

	zval *value;

	phalcon_fetch_params(0, 1, 0, &value);
	
	phalcon_update_property_this_quick(this_ptr, SL("_value"), value, 2935317441UL TSRMLS_CC);
	phalcon_update_property_bool(this_ptr, SL("_readed"), 1 TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Cookie, getValue){

	zval *filters = NULL, *default_value = NULL, *restored, *dependency_injector = NULL;
	zval *readed, *name, *_COOKIE, *value = NULL, *encryption;
	zval *service = NULL, *crypt = NULL, *decrypted_value = NULL, *filter = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &filters, &default_value);
	
	if (!filters) {
		filters = PHALCON_GLOBAL(z_null);
	}
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_INIT_VAR(dependency_injector);
	
	PHALCON_OBS_VAR(readed);
	phalcon_read_property_this(&readed, this_ptr, SL("_readed"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(readed)) {
	
		PHALCON_OBS_VAR(name);
		phalcon_read_property_this(&name, this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);

		_COOKIE = phalcon_get_global(SS("_COOKIE") TSRMLS_CC);
		if (phalcon_array_isset_fetch(&value, _COOKIE, name)) {
	
			PHALCON_OBS_VAR(encryption);
			phalcon_read_property_this(&encryption, this_ptr, SL("_useEncryption"), PH_NOISY TSRMLS_CC);
			if (zend_is_true(encryption)) {
	
				PHALCON_OBS_NVAR(dependency_injector);
				phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_http_cookie_exception_ce, "A dependency injection object is required to access the 'filter' service");
					return;
				}
	
				PHALCON_INIT_VAR(service);
				ZVAL_STRING(service, "crypt", 1);
	
				PHALCON_CALL_METHOD(&crypt, dependency_injector, "getshared", service);
				PHALCON_VERIFY_INTERFACE(crypt, phalcon_cryptinterface_ce);
	
				PHALCON_CALL_METHOD(&decrypted_value, crypt, "decryptbase64", value);
			} else {
				PHALCON_CPY_WRT(decrypted_value, value);
			}
	
			phalcon_update_property_this_quick(this_ptr, SL("_value"), decrypted_value, 2935317441UL TSRMLS_CC);
			if (Z_TYPE_P(filters) != IS_NULL) {
	
				PHALCON_OBS_VAR(filter);
				phalcon_read_property_this(&filter, this_ptr, SL("_filter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(filter) != IS_OBJECT) {
					if (Z_TYPE_P(dependency_injector) == IS_NULL) {
	
						PHALCON_OBS_NVAR(dependency_injector);
						phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
						PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_cookie_exception_ce, 1);
					}
	
					PHALCON_INIT_NVAR(service);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
					PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
					phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
				}
	
				PHALCON_RETURN_CALL_METHOD(filter, "sanitize", decrypted_value, filters);
				RETURN_MM();
			}
	
	
			RETURN_CTOR(decrypted_value);
		}
	
		RETURN_CTOR(default_value);
	}
	
	PHALCON_OBS_NVAR(value);
	phalcon_read_property_this(&value, this_ptr, SL("_value"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(value);
}

static PHP_METHOD(Phalcon_Http_Cookie, send){

	zval *name, *value, *expire, *domain, *path, *secure;
	zval *http_only, *dependency_injector, *definition;
	zval *service = NULL, *session = NULL, *key, *encryption, *crypt = NULL;
	zval *encrypt_value = NULL, *has_session = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(name);
	phalcon_read_property_this(&name, this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(value);
	phalcon_read_property_this(&value, this_ptr, SL("_value"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(expire);
	phalcon_read_property_this(&expire, this_ptr, SL("_expire"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(domain);
	phalcon_read_property_this(&domain, this_ptr, SL("_domain"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(path);
	phalcon_read_property_this(&path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(secure);
	phalcon_read_property_this(&secure, this_ptr, SL("_secure"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(http_only);
	phalcon_read_property_this(&http_only, this_ptr, SL("_httpOnly"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

		PHALCON_CALL_METHOD(&has_session, dependency_injector, "has", service);
		if (zend_is_true(has_session)) {
			PHALCON_INIT_VAR(definition);
			array_init(definition);
			if (!PHALCON_IS_LONG(expire, 0)) {
				phalcon_array_update_string(&definition, SL("expire"), expire, PH_COPY);
			}

			if (PHALCON_IS_NOT_EMPTY(path)) {
				phalcon_array_update_string(&definition, SL("path"), path, PH_COPY);
			}

			if (PHALCON_IS_NOT_EMPTY(domain)) {
				phalcon_array_update_string(&definition, ISL(domain), domain, PH_COPY);
			}

			if (PHALCON_IS_NOT_EMPTY(secure)) {
				phalcon_array_update_string(&definition, SL("secure"), secure, PH_COPY);
			}

			if (PHALCON_IS_NOT_EMPTY(http_only)) {
				phalcon_array_update_string(&definition, SL("httpOnly"), http_only, PH_COPY);
			}

			if (phalcon_fast_count_ev(definition TSRMLS_CC)) {
				PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);

				if (Z_TYPE_P(session) != IS_NULL) {
					PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);

					PHALCON_INIT_VAR(key);
					PHALCON_CONCAT_SV(key, "_PHCOOKIE_", name);
					PHALCON_CALL_METHOD(NULL, session, "set", key, definition);
				}
			}
		}
	}
	
	PHALCON_OBS_VAR(encryption);
	phalcon_read_property_this(&encryption, this_ptr, SL("_useEncryption"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(encryption) && PHALCON_IS_NOT_EMPTY(value)) {
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_http_cookie_exception_ce, "A dependency injection object is required to access the 'filter' service");
			return;
		}

		PHALCON_INIT_NVAR(service);
		ZVAL_STRING(service, "crypt", 1);

		PHALCON_CALL_METHOD(&crypt, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(crypt, phalcon_cryptinterface_ce);

		PHALCON_CALL_METHOD(&encrypt_value, crypt, "encryptbase64", value);
	} else {
		PHALCON_CPY_WRT(encrypt_value, value);
	}
	
	convert_to_string_ex(&name);
	convert_to_string_ex(&encrypt_value);
	convert_to_long_ex(&expire);
	convert_to_string_ex(&path);
	convert_to_string_ex(&domain);
	convert_to_long_ex(&secure);
	convert_to_long_ex(&http_only);

	php_setcookie(
		Z_STRVAL_P(name), Z_STRLEN_P(name),
		Z_STRVAL_P(encrypt_value), Z_STRLEN_P(encrypt_value),
		Z_LVAL_P(expire),
		Z_STRVAL_P(path), Z_STRLEN_P(path),
		Z_STRVAL_P(domain), Z_STRLEN_P(domain),
		Z_LVAL_P(secure),
		1,
		Z_LVAL_P(http_only) TSRMLS_CC
	);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, restore){

	zval *restored, *dependency_injector, *service;
	zval *session = NULL, *name, *key, *definition = NULL, *expire, *domain;
	zval *path, *secure, *http_only;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
	
			PHALCON_INIT_VAR(service);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);
	
			PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
			PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);
	
			PHALCON_OBS_VAR(name);
			phalcon_read_property_this(&name, this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_VAR(key);
			PHALCON_CONCAT_SV(key, "_PHCOOKIE_", name);
	
			PHALCON_CALL_METHOD(&definition, session, "get", key);
			if (Z_TYPE_P(definition) == IS_ARRAY) { 
				if (phalcon_array_isset_quick_string(definition, SS("expire"), 2190139186UL)) {
					PHALCON_OBS_VAR(expire);
					phalcon_array_fetch_quick_string(&expire, definition, SS("expire"), 2190139186UL, PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_expire"), expire, 2800520017UL TSRMLS_CC);
				}
				if (phalcon_array_isset_quick_string(definition, SS("domain"), 542597917UL)) {
					PHALCON_OBS_VAR(domain);
					phalcon_array_fetch_quick_string(&domain, definition, SS("domain"), 542597917UL, PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_domain"), domain, 1152978748UL TSRMLS_CC);
				}
	
				if (phalcon_array_isset_quick_string(definition, SS("path"), 270591026UL)) {
					PHALCON_OBS_VAR(path);
					phalcon_array_fetch_quick_string(&path, definition, SS("path"), 270591026UL, PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_path"), path, 3986357393UL TSRMLS_CC);
				}
	
				if (phalcon_array_isset_quick_string(definition, SS("secure"), 2332263372UL)) {
					PHALCON_OBS_VAR(secure);
					phalcon_array_fetch_quick_string(&secure, definition, SS("secure"), 2332263372UL, PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_secure"), secure, 2942644203UL TSRMLS_CC);
				}
	
				if (phalcon_array_isset_quick_string(definition, SS("httpOnly"), 1056437095UL)) {
					PHALCON_OBS_VAR(http_only);
					phalcon_array_fetch_quick_string(&http_only, definition, SS("httpOnly"), 1056437095UL, PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_httpOnly"), http_only, 41231174UL TSRMLS_CC);
				}
			}
		}
	
		phalcon_update_property_bool(this_ptr, SL("_restored"), 1 TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, delete){

	zval *name, *domain, *path, *secure, *http_only, *dependency_injector;
	zval *service, *session = NULL, *key;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(name);
	phalcon_read_property_this(&name, this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(domain);
	phalcon_read_property_this(&domain, this_ptr, SL("_domain"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(path);
	phalcon_read_property_this(&path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(secure);
	phalcon_read_property_this(&secure, this_ptr, SL("_secure"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(http_only);
	phalcon_read_property_this(&http_only, this_ptr, SL("_httpOnly"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);
	
		PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);
	
		PHALCON_INIT_VAR(key);
		PHALCON_CONCAT_SV(key, "_PHCOOKIE_", name);
		PHALCON_CALL_METHOD(NULL, session, "remove", key);
	}
	
	phalcon_update_property_null(this_ptr, SL("_value") TSRMLS_CC);

	convert_to_string_ex(&name);
	convert_to_string_ex(&path);
	convert_to_string_ex(&domain);
	convert_to_long_ex(&secure);
	convert_to_long_ex(&http_only);

	php_setcookie(
		Z_STRVAL_P(name), Z_STRLEN_P(name),
		NULL, 0,
		time(NULL) - 691200,
		Z_STRVAL_P(path), Z_STRLEN_P(path),
		Z_STRVAL_P(domain), Z_STRLEN_P(domain),
		Z_LVAL_P(secure),
		1,
		Z_LVAL_P(http_only) TSRMLS_CC
	);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Cookie, useEncryption){

	zval *use_encryption;

	phalcon_fetch_params(0, 1, 0, &use_encryption);
	
	phalcon_update_property_this_quick(this_ptr, SL("_useEncryption"), use_encryption, 2628069468UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Cookie, isUsingEncryption){


	RETURN_MEMBER_QUICK(this_ptr, "_useEncryption", 2628069468UL);
}

static PHP_METHOD(Phalcon_Http_Cookie, setExpiration){

	zval *expire, *restored;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expire);
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_expire"), expire, 2800520017UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, getExpiration){

	zval *restored, *expire;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_OBS_VAR(expire);
	phalcon_read_property_this(&expire, this_ptr, SL("_expire"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(expire);
}

static PHP_METHOD(Phalcon_Http_Cookie, setPath){

	zval *path, *restored;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &path);
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_path"), path, 3986357393UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, getPath){

	zval *restored, *path;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_OBS_VAR(path);
	phalcon_read_property_this(&path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(path);
}

static PHP_METHOD(Phalcon_Http_Cookie, setDomain){

	zval *domain, *restored;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &domain);
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_domain"), domain, 1152978748UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, getDomain){

	zval *restored, *domain;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_OBS_VAR(domain);
	phalcon_read_property_this(&domain, this_ptr, SL("_domain"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(domain);
}

static PHP_METHOD(Phalcon_Http_Cookie, setSecure){

	zval *secure, *restored;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &secure);
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_secure"), secure, 2942644203UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, getSecure){

	zval *restored, *secure;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_OBS_VAR(secure);
	phalcon_read_property_this(&secure, this_ptr, SL("_secure"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(secure);
}

static PHP_METHOD(Phalcon_Http_Cookie, setHttpOnly){

	zval *http_only, *restored;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &http_only);
	
	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_httpOnly"), http_only, 41231174UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Cookie, getHttpOnly){

	zval *restored, *http_only;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(restored);
	phalcon_read_property_this(&restored, this_ptr, SL("_restored"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(restored)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "restore");
	}
	
	PHALCON_OBS_VAR(http_only);
	phalcon_read_property_this(&http_only, this_ptr, SL("_httpOnly"), PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(http_only);
}

static PHP_METHOD(Phalcon_Http_Cookie, __toString){

	zval *value;

	value = phalcon_fetch_nproperty_this(this_ptr, SL("_value"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(value) == IS_NULL) {
		if (FAILURE == phalcon_return_call_method(return_value, return_value_ptr, this_ptr, "getvalue", 0, NULL TSRMLS_CC)) {
			if (EG(exception)) {
				zval *e = EG(exception);
				zval *m = zend_read_property(Z_OBJCE_P(e), e, SL("message"), 1 TSRMLS_CC);

				Z_ADDREF_P(m);
				if (Z_TYPE_P(m) != IS_STRING) {
					convert_to_string_ex(&m);
				}

				zend_clear_exception(TSRMLS_C);
				zend_error(E_ERROR, "%s", Z_STRVAL_P(m));
				zval_ptr_dtor(&m);
			}
		}

		convert_to_string(return_value_ptr ? *return_value_ptr : return_value);
		return;
	}
	
	RETURN_ZVAL(value, 1, 0);
}





#include <main/php_variables.h>
#include <main/SAPI.h>
#include <ext/standard/php_smart_str.h>
#include <ext/standard/file.h>



zend_class_entry *phalcon_http_request_ce;

static PHP_METHOD(Phalcon_Http_Request, setDI);
static PHP_METHOD(Phalcon_Http_Request, getDI);
static PHP_METHOD(Phalcon_Http_Request, get);
static PHP_METHOD(Phalcon_Http_Request, getPost);
static PHP_METHOD(Phalcon_Http_Request, getPut);
static PHP_METHOD(Phalcon_Http_Request, getQuery);
static PHP_METHOD(Phalcon_Http_Request, getServer);
static PHP_METHOD(Phalcon_Http_Request, has);
static PHP_METHOD(Phalcon_Http_Request, hasPost);
static PHP_METHOD(Phalcon_Http_Request, hasPut);
static PHP_METHOD(Phalcon_Http_Request, hasQuery);
static PHP_METHOD(Phalcon_Http_Request, hasServer);
static PHP_METHOD(Phalcon_Http_Request, getHeader);
static PHP_METHOD(Phalcon_Http_Request, getScheme);
static PHP_METHOD(Phalcon_Http_Request, isAjax);
static PHP_METHOD(Phalcon_Http_Request, isSoapRequested);
static PHP_METHOD(Phalcon_Http_Request, isSecureRequest);
static PHP_METHOD(Phalcon_Http_Request, getRawBody);
static PHP_METHOD(Phalcon_Http_Request, getJsonRawBody);
static PHP_METHOD(Phalcon_Http_Request, getServerAddress);
static PHP_METHOD(Phalcon_Http_Request, getServerName);
static PHP_METHOD(Phalcon_Http_Request, getHttpHost);
static PHP_METHOD(Phalcon_Http_Request, getClientAddress);
static PHP_METHOD(Phalcon_Http_Request, getMethod);
static PHP_METHOD(Phalcon_Http_Request, getURI);
static PHP_METHOD(Phalcon_Http_Request, getUserAgent);
static PHP_METHOD(Phalcon_Http_Request, isMethod);
static PHP_METHOD(Phalcon_Http_Request, isPost);
static PHP_METHOD(Phalcon_Http_Request, isGet);
static PHP_METHOD(Phalcon_Http_Request, isPut);
static PHP_METHOD(Phalcon_Http_Request, isPatch);
static PHP_METHOD(Phalcon_Http_Request, isHead);
static PHP_METHOD(Phalcon_Http_Request, isDelete);
static PHP_METHOD(Phalcon_Http_Request, isOptions);
static PHP_METHOD(Phalcon_Http_Request, hasFiles);
static PHP_METHOD(Phalcon_Http_Request, getUploadedFiles);
static PHP_METHOD(Phalcon_Http_Request, getHeaders);
static PHP_METHOD(Phalcon_Http_Request, getHTTPReferer);
static PHP_METHOD(Phalcon_Http_Request, _getQualityHeader);
static PHP_METHOD(Phalcon_Http_Request, _getBestQuality);
static PHP_METHOD(Phalcon_Http_Request, getAcceptableContent);
static PHP_METHOD(Phalcon_Http_Request, getBestAccept);
static PHP_METHOD(Phalcon_Http_Request, getClientCharsets);
static PHP_METHOD(Phalcon_Http_Request, getBestCharset);
static PHP_METHOD(Phalcon_Http_Request, getLanguages);
static PHP_METHOD(Phalcon_Http_Request, getBestLanguage);
static PHP_METHOD(Phalcon_Http_Request, getBasicAuth);
static PHP_METHOD(Phalcon_Http_Request, getDigestAuth);

static const zend_function_entry phalcon_http_request_method_entry[] = {
	PHP_ME(Phalcon_Http_Request, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, get, arginfo_phalcon_http_requestinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getPost, arginfo_phalcon_http_requestinterface_getpost, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getPut, arginfo_phalcon_http_requestinterface_getput, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getQuery, arginfo_phalcon_http_requestinterface_getquery, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getServer, arginfo_phalcon_http_requestinterface_getserver, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, has, arginfo_phalcon_http_requestinterface_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, hasPost, arginfo_phalcon_http_requestinterface_haspost, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, hasPut, arginfo_phalcon_http_requestinterface_haspost, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, hasQuery, arginfo_phalcon_http_requestinterface_hasquery, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, hasServer, arginfo_phalcon_http_requestinterface_hasserver, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getHeader, arginfo_phalcon_http_requestinterface_getheader, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getScheme, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isAjax, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isSoapRequested, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isSecureRequest, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getRawBody, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getJsonRawBody, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getServerAddress, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getServerName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getHttpHost, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getClientAddress, arginfo_phalcon_http_requestinterface_getclientaddress, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getMethod, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getURI, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getUserAgent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isMethod, arginfo_phalcon_http_requestinterface_ismethod, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isPost, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isGet, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isPut, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isPatch, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isHead, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isDelete, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, isOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, hasFiles, arginfo_phalcon_http_requestinterface_hasfiles, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getUploadedFiles, arginfo_phalcon_http_requestinterface_getuploadedfiles, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getHeaders, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getHTTPReferer, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, _getQualityHeader, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Http_Request, _getBestQuality, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Http_Request, getAcceptableContent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getBestAccept, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getClientCharsets, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getBestCharset, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getLanguages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getBestLanguage, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getBasicAuth, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request, getDigestAuth, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Request){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Request, http_request, phalcon_http_request_method_entry, 0);

	zend_declare_property_null(phalcon_http_request_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_ce, SL("_filter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_ce, SL("_rawBody"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_ce, SL("_put"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_request_ce TSRMLS_CC, 2, phalcon_http_requestinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Request, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_request_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Request, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Http_Request, get){

	zval *name = NULL, *filters = NULL, *default_value = NULL, *not_allow_empty = NULL, *norecursive = NULL, *request;
	zval *value, *filter = NULL, *dependency_injector;
	zval *service;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 5, &name, &filters, &default_value, &not_allow_empty, &norecursive);
	
	if (!name) {
		name = PHALCON_GLOBAL(z_null);
	}
	
	if (!filters) {
		filters = PHALCON_GLOBAL(z_null);
	}
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	if (!not_allow_empty) {
		not_allow_empty = PHALCON_GLOBAL(z_false);
	}
	
	if (!norecursive) {
		norecursive = PHALCON_GLOBAL(z_false);
	}
	
	request = phalcon_get_global(SS("_REQUEST") TSRMLS_CC);
	if (Z_TYPE_P(name) != IS_NULL) {
		if (phalcon_array_isset_fetch(&value, request, name)) {
			if (Z_TYPE_P(filters) != IS_NULL) {
	
				PHALCON_OBS_VAR(filter);
				phalcon_read_property_this(&filter, this_ptr, SL("_filter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(filter) != IS_OBJECT) {
	
					PHALCON_OBS_VAR(dependency_injector);
					phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
					if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
						return;
					}
	
					PHALCON_INIT_VAR(service);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
					PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
					phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
				}
	
				PHALCON_RETURN_CALL_METHOD(filter, "sanitize", value, filters, norecursive);
				if (return_value_ptr) {
					return_value = *return_value_ptr;
				}

				if ((PHALCON_IS_EMPTY(return_value) && zend_is_true(not_allow_empty)) || PHALCON_IS_FALSE(return_value)) {
					zval_dtor(return_value);
					RETURN_CTOR(default_value);
				}

				RETURN_MM();
			}

			if (PHALCON_IS_EMPTY(value) && zend_is_true(not_allow_empty)) {
				RETURN_CTOR(default_value);
			}

			RETURN_CTOR(value);
		}
	
		RETURN_CTOR(default_value);
	}
	
	RETURN_CTOR(request);
}

static PHP_METHOD(Phalcon_Http_Request, getPost){

	zval *name = NULL, *filters = NULL, *default_value = NULL, *not_allow_empty = NULL, *norecursive = NULL, *post;
	zval *value, *filter = NULL, *dependency_injector, *service;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 5, &name, &filters, &default_value, &not_allow_empty, &norecursive);
	
	if (!name) {
		name = PHALCON_GLOBAL(z_null);
	}
	
	if (!filters) {
		filters = PHALCON_GLOBAL(z_null);
	}
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	if (!not_allow_empty) {
		not_allow_empty = PHALCON_GLOBAL(z_false);
	}
	
	if (!norecursive) {
		norecursive = PHALCON_GLOBAL(z_false);
	}
	
	post = phalcon_get_global(SS("_POST") TSRMLS_CC);
	if (Z_TYPE_P(name) != IS_NULL) {
		if (phalcon_array_isset(post, name)) {
	
			PHALCON_OBS_VAR(value);
			phalcon_array_fetch(&value, post, name, PH_NOISY);
			if (Z_TYPE_P(filters) != IS_NULL) {
	
				PHALCON_OBS_VAR(filter);
				phalcon_read_property_this(&filter, this_ptr, SL("_filter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(filter) != IS_OBJECT) {
	
					PHALCON_OBS_VAR(dependency_injector);
					phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
					if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
						return;
					}
	
					PHALCON_INIT_VAR(service);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
					PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
					phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
				}
	
				PHALCON_RETURN_CALL_METHOD(filter, "sanitize", value, filters, norecursive);
				if (return_value_ptr) {
					return_value = *return_value_ptr;
				}

				if ((PHALCON_IS_EMPTY(return_value) && zend_is_true(not_allow_empty)) || PHALCON_IS_FALSE(return_value)) {
					zval_dtor(return_value);
					RETURN_CTOR(default_value);
				} else {
					RETURN_MM();
				}
			} else {
				if (PHALCON_IS_EMPTY(value) && zend_is_true(not_allow_empty)) {
					RETURN_CTOR(default_value);
				} else {
					RETURN_CTOR(value);
				}
			}
		}
	
		RETURN_CTOR(default_value);
	}
	
	RETURN_CTOR(post);
}

static PHP_METHOD(Phalcon_Http_Request, getPut){

	zval *name = NULL, *filters = NULL, *default_value = NULL, *not_allow_empty = NULL, *norecursive = NULL;
	zval *is_put = NULL, *put = NULL, *raw = NULL, *value, *filter = NULL, *dependency_injector, *service;
	char *tmp;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 5, &name, &filters, &default_value, &not_allow_empty, &norecursive);
	
	if (!name) {
		name = PHALCON_GLOBAL(z_null);
	}
	
	if (!filters) {
		filters = PHALCON_GLOBAL(z_null);
	}
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	if (!not_allow_empty) {
		not_allow_empty = PHALCON_GLOBAL(z_false);
	}
	
	if (!norecursive) {
		norecursive = PHALCON_GLOBAL(z_false);
	}

	PHALCON_CALL_METHOD(&is_put, this_ptr, "isput");

	if (!zend_is_true(is_put)) {
		put = phalcon_get_global(SS("_PUT") TSRMLS_CC);
	}
	else {
		PHALCON_OBS_VAR(put);
		phalcon_read_property_this(&put, this_ptr, SL("_put"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(put) != IS_ARRAY) {
			PHALCON_CALL_METHOD(&raw, this_ptr, "getrawbody");

			PHALCON_INIT_NVAR(put);
			array_init(put);

			PHALCON_ENSURE_IS_STRING(&raw);
			tmp = estrndup(Z_STRVAL_P(raw), Z_STRLEN_P(raw));
			sapi_module.treat_data(PARSE_STRING, tmp, put TSRMLS_CC);

			phalcon_update_property_this(getThis(), SL("_put"), put TSRMLS_CC);
		}
	}
	
	if (Z_TYPE_P(name) != IS_NULL) {
		if (phalcon_array_isset(put, name)) {
	
			PHALCON_OBS_VAR(value);
			phalcon_array_fetch(&value, put, name, PH_NOISY);
			if (Z_TYPE_P(filters) != IS_NULL) {
	
				PHALCON_OBS_VAR(filter);
				phalcon_read_property_this(&filter, this_ptr, SL("_filter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(filter) != IS_OBJECT) {
	
					PHALCON_OBS_VAR(dependency_injector);
					phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
					if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
						return;
					}
	
					PHALCON_INIT_VAR(service);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
					PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
					phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
				}
	
				PHALCON_RETURN_CALL_METHOD(filter, "sanitize", value, filters, norecursive);
				if (return_value_ptr) {
					return_value = *return_value_ptr;
				}

				if ((PHALCON_IS_EMPTY(return_value) && zend_is_true(not_allow_empty)) || PHALCON_IS_FALSE(return_value)) {
					zval_dtor(return_value);
					RETURN_CTOR(default_value);
				} else {
					RETURN_MM();
				}
			} else {
				if (PHALCON_IS_EMPTY(value) && zend_is_true(not_allow_empty)) {
					RETURN_CTOR(default_value);
				} else {
					RETURN_CTOR(value);
				}
			}
		}
	
		RETURN_CTOR(default_value);
	}
	
	RETURN_CTOR(put);
}

static PHP_METHOD(Phalcon_Http_Request, getQuery){

	zval *name = NULL, *filters = NULL, *default_value = NULL, *not_allow_empty = NULL, *norecursive = NULL, *get;
	zval *value, *filter = NULL, *dependency_injector, *service;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 5, &name, &filters, &default_value, &not_allow_empty, &norecursive);
	
	if (!name) {
		name = PHALCON_GLOBAL(z_null);
	}
	
	if (!filters) {
		filters = PHALCON_GLOBAL(z_null);
	}
	
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}
	
	if (!not_allow_empty) {
		not_allow_empty = PHALCON_GLOBAL(z_false);
	}
	
	if (!norecursive) {
		norecursive = PHALCON_GLOBAL(z_false);
	}
	
	get = phalcon_get_global(SS("_GET") TSRMLS_CC);
	if (Z_TYPE_P(name) != IS_NULL) {
		if (phalcon_array_isset(get, name)) {
	
			PHALCON_OBS_VAR(value);
			phalcon_array_fetch(&value, get, name, PH_NOISY);
			if (Z_TYPE_P(filters) != IS_NULL) {
	
				PHALCON_OBS_VAR(filter);
				phalcon_read_property_this(&filter, this_ptr, SL("_filter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(filter) != IS_OBJECT) {
	
					PHALCON_OBS_VAR(dependency_injector);
					phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
					if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
						PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "A dependency injection object is required to access the 'filter' service");
						return;
					}
	
					PHALCON_INIT_VAR(service);
					PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_filter);
	
					PHALCON_CALL_METHOD(&filter, dependency_injector, "getshared", service);
					PHALCON_VERIFY_INTERFACE(filter, phalcon_filterinterface_ce);
					phalcon_update_property_this_quick(this_ptr, SL("_filter"), filter, 3500594986UL TSRMLS_CC);
				}
	
				PHALCON_RETURN_CALL_METHOD(filter, "sanitize", value, filters, norecursive);
				if (return_value_ptr) {
					return_value = *return_value_ptr;
				}

				if ((PHALCON_IS_EMPTY(return_value) && zend_is_true(not_allow_empty)) || PHALCON_IS_FALSE(return_value)) {
					zval_dtor(return_value);
					RETURN_CTOR(default_value);
				} else {
					RETURN_MM();
				}
			} else {
				if (PHALCON_IS_EMPTY(value) && zend_is_true(not_allow_empty)) {
					RETURN_CTOR(default_value);
				} else {
					RETURN_CTOR(value);
				}
			}
		}
	
		RETURN_CTOR(default_value);
	}
	
	RETURN_CTOR(get);
}

static PHP_METHOD(Phalcon_Http_Request, getServer){

	zval *name, *_SERVER, *server_value;

	phalcon_fetch_params(0, 1, 0, &name);
	
	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_fetch(&server_value, _SERVER, name)) {
		RETURN_ZVAL(server_value, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Http_Request, has){

	zval *name, *_REQUEST;

	phalcon_fetch_params(0, 1, 0, &name);
	
	_REQUEST = phalcon_get_global(SS("_REQUEST") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_REQUEST, name));
}

static PHP_METHOD(Phalcon_Http_Request, hasPost){

	zval *name, *_POST;

	phalcon_fetch_params(0, 1, 0, &name);
	
	_POST = phalcon_get_global(SS("_POST") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_POST, name));
}

static PHP_METHOD(Phalcon_Http_Request, hasPut){

	zval *name, *is_put = NULL, *put = NULL, *raw = NULL;
	char *tmp;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	PHALCON_CALL_METHOD(&is_put, this_ptr, "isput");

	if (!zend_is_true(is_put)) {
		put = phalcon_get_global(SS("_PUT") TSRMLS_CC);
	}
	else {
		PHALCON_OBS_VAR(put);
		phalcon_read_property_this(&put, this_ptr, SL("_put"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(put) != IS_ARRAY) {
			PHALCON_CALL_METHOD(&raw, this_ptr, "getrawbody");

			PHALCON_INIT_NVAR(put);
			array_init(put);

			PHALCON_ENSURE_IS_STRING(&raw);
			tmp = estrndup(Z_STRVAL_P(raw), Z_STRLEN_P(raw));
			sapi_module.treat_data(PARSE_STRING, tmp, put TSRMLS_CC);

			phalcon_update_property_this(getThis(), SL("_put"), put TSRMLS_CC);
		}
	}

	RETVAL_BOOL(phalcon_array_isset(put, name));
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request, hasQuery){

	zval *name, *_GET;

	phalcon_fetch_params(0, 1, 0, &name);
	
	_GET = phalcon_get_global(SS("_GET") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_GET, name));
}

static PHP_METHOD(Phalcon_Http_Request, hasServer){

	zval *name, *_SERVER;

	phalcon_fetch_params(0, 1, 0, &name);
	
	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_SERVER, name));
}

static PHP_METHOD(Phalcon_Http_Request, getHeader){

	zval *header, *_SERVER, *server_value, *key;

	phalcon_fetch_params(0, 1, 0, &header);
	
	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_fetch(&server_value, _SERVER, header)) {
		RETURN_ZVAL(server_value, 1, 0);
	}

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_SV(key, "HTTP_", header);
	if (phalcon_array_isset_fetch(&server_value, _SERVER, key)) {
		RETURN_CTOR(server_value);
	}

	RETURN_MM_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Http_Request, getScheme){

	zval *https_header, *https = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(https_header);
	ZVAL_STRING(https_header, "HTTPS", 1);
	
	PHALCON_CALL_METHOD(&https, this_ptr, "getserver", https_header);
	if (zend_is_true(https)) {
		if (PHALCON_IS_STRING(https, "off")) {
			RETVAL_STRING("http", 1);
		} else {
			RETVAL_STRING("https", 1);
		}
	} else {
		RETVAL_STRING("http", 1);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request, isAjax){

	zval *requested_header, *xml_http_request;
	zval *requested_with = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(requested_header);
	ZVAL_STRING(requested_header, "HTTP_X_REQUESTED_WITH", 1);
	
	PHALCON_INIT_VAR(xml_http_request);
	ZVAL_STRING(xml_http_request, "XMLHttpRequest", 1);
	
	PHALCON_CALL_METHOD(&requested_with, this_ptr, "getheader", requested_header);
	is_equal_function(return_value, requested_with, xml_http_request TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isSoapRequested){

	zval *server, *content_type;

	server = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_quick_string(server, SS("HTTP_SOAPACTION"), 1001189845UL)) {
		RETURN_TRUE;
	}

	if (phalcon_array_isset_string_fetch(&content_type, server, SS("CONTENT_TYPE"))) {
		if (phalcon_memnstr_str(content_type, SL("application/soap+xml"))) {
			RETURN_TRUE;
		}
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Http_Request, isSecureRequest){

	zval *scheme = NULL, *https;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&scheme, this_ptr, "getscheme");
	
	PHALCON_INIT_VAR(https);
	ZVAL_STRING(https, "https", 1);
	is_identical_function(return_value, https, scheme TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getRawBody){

	zval *raw;

#if PHP_VERSION_ID < 50600
	if (SG(request_info).raw_post_data) {
		RETURN_STRINGL(SG(request_info).raw_post_data, SG(request_info).raw_post_data_length, 1);
	}
#endif

	raw = phalcon_fetch_nproperty_this(getThis(), SL("_rawBody"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(raw) == IS_STRING) {
		RETURN_ZVAL(raw, 1, 0);
	}

#if PHP_VERSION_ID < 50600
	if (sapi_module.read_post) {
		int read_bytes;
		char *buf          = emalloc(8192);
		smart_str raw_data = { NULL, 0, 0 };

		while ((read_bytes = sapi_module.read_post(buf, 8192 TSRMLS_CC)) > 0) {
			smart_str_appendl(&raw_data, buf, read_bytes);
			SG(read_post_bytes) += read_bytes;
		}

		efree(buf);
		if (raw_data.c) {
			smart_str_0(&raw_data);
			RETVAL_STRINGL(raw_data.c, raw_data.len, 0);
		}
		else {
			RETVAL_EMPTY_STRING();
		}

		phalcon_update_property_this(getThis(), SL("_rawBody"), return_value TSRMLS_CC);
		return;
	}

	RETURN_EMPTY_STRING();
#else

	{
		zval *zcontext = NULL;
		php_stream_context *context = php_stream_context_from_zval(zcontext, 0);
		php_stream *stream = php_stream_open_wrapper_ex("php://input", "rb", REPORT_ERRORS, NULL, context);
		long int maxlen    = PHP_STREAM_COPY_ALL;
		char *content;
		int len;

		if (!stream) {
			RETURN_FALSE;
		}

		len = php_stream_copy_to_mem(stream, &content, maxlen, 0);
		if (len > 0) {
			RETVAL_STRINGL(content, len, 0);
			phalcon_update_property_this(getThis(), SL("_rawBody"), return_value TSRMLS_CC);
		}
		else if (!len) {
			RETVAL_EMPTY_STRING();
			phalcon_update_property_this(getThis(), SL("_rawBody"), return_value TSRMLS_CC);
		}
		else {
			RETVAL_FALSE;
		}

		php_stream_close(stream);
	}
#endif
}

static PHP_METHOD(Phalcon_Http_Request, getJsonRawBody){

	zval *raw_body = NULL, *assoc = NULL;
	int ac = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &assoc);

	if (assoc && zend_is_true(assoc)) {
		ac = 1;
	}

	PHALCON_CALL_METHOD(&raw_body, this_ptr, "getrawbody");
	if (Z_TYPE_P(raw_body) == IS_STRING) {
		RETURN_MM_ON_FAILURE(phalcon_json_decode(return_value, raw_body, ac TSRMLS_CC));
		RETURN_MM();
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request, getServerAddress){

	zval *server, *server_addr;

	server = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&server_addr, server, SS("SERVER_ADDR"))) {
		RETURN_ZVAL(server_addr, 1, 0);
	}
	
	RETURN_STRING("127.0.0.1", 1);
}

static PHP_METHOD(Phalcon_Http_Request, getServerName){

	zval *server, *server_name = NULL;

	server = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&server_name, server, SS("SERVER_NAME"))) {
		RETURN_ZVAL(server_name, 1, 0);
	}
	
	RETURN_STRING("localhost", 1);
}

static PHP_METHOD(Phalcon_Http_Request, getHttpHost){

	zval *host, *http_host = NULL, *scheme = NULL, *server_name, *name = NULL;
	zval *server_port, *port = NULL, *http, *standard_port;
	zval *is_std_name, *is_std_port, *is_std_http;
	zval *https, *secure_port, *is_secure_scheme;
	zval *is_secure_port, *is_secure_http;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(host);
	ZVAL_STRING(host, "HTTP_HOST", 1);
	
	PHALCON_CALL_METHOD(&http_host, this_ptr, "getserver", host);
	if (zend_is_true(http_host)) {
		RETURN_CTOR(http_host);
	}
	
	PHALCON_CALL_METHOD(&scheme, this_ptr, "getscheme");
	
	PHALCON_INIT_VAR(server_name);
	ZVAL_STRING(server_name, "SERVER_NAME", 1);
	
	PHALCON_CALL_METHOD(&name, this_ptr, "getserver", server_name);
	
	PHALCON_INIT_VAR(server_port);
	ZVAL_STRING(server_port, "SERVER_PORT", 1);
	
	PHALCON_CALL_METHOD(&port, this_ptr, "getserver", server_port);
	
	PHALCON_INIT_VAR(http);
	ZVAL_STRING(http, "http", 1);
	
	PHALCON_INIT_VAR(standard_port);
	ZVAL_LONG(standard_port, 80);
	
	PHALCON_INIT_VAR(is_std_name);
	is_equal_function(is_std_name, scheme, http TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_std_port);
	is_equal_function(is_std_port, port, standard_port TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_std_http);
	phalcon_and_function(is_std_http, is_std_name, is_std_port);
	
	PHALCON_INIT_VAR(https);
	ZVAL_STRING(https, "https", 1);
	
	PHALCON_INIT_VAR(secure_port);
	ZVAL_LONG(secure_port, 443);
	
	PHALCON_INIT_VAR(is_secure_scheme);
	is_equal_function(is_secure_scheme, scheme, https TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_secure_port);
	is_equal_function(is_secure_port, port, secure_port TSRMLS_CC);
	
	PHALCON_INIT_VAR(is_secure_http);
	phalcon_and_function(is_secure_http, is_secure_scheme, is_secure_port);
	
	if (PHALCON_IS_TRUE(is_std_http)) {
		RETURN_CTOR(name);
	}
	
	if (PHALCON_IS_TRUE(is_secure_http)) {
		RETURN_CTOR(name);
	}
	
	PHALCON_CONCAT_VSV(return_value, name, ":", port);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getClientAddress){

	zval *trust_forwarded_header = NULL, *address = NULL, *_SERVER;
	zval *addresses, *first;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &trust_forwarded_header);
	
	if (!trust_forwarded_header) {
		trust_forwarded_header = PHALCON_GLOBAL(z_false);
	}
	
	PHALCON_INIT_VAR(address);
	
	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_quick_string(_SERVER, SS("HTTP_X_FORWARDED_FOR"), 243594879UL)) {
		if (zend_is_true(trust_forwarded_header)) {
			PHALCON_OBS_NVAR(address);
			phalcon_array_fetch_quick_string(&address, _SERVER, SS("HTTP_X_FORWARDED_FOR"), 243594879UL, PH_NOISY);
		}
	}

	if (Z_TYPE_P(address) == IS_NULL) {
		if (phalcon_array_isset_quick_string(_SERVER, SS("REMOTE_ADDR"), 1233979979UL)) {
			PHALCON_OBS_NVAR(address);
			phalcon_array_fetch_quick_string(&address, _SERVER, SS("REMOTE_ADDR"), 1233979979UL, PH_NOISY);
		}
	}
	
	if (Z_TYPE_P(address) == IS_STRING) {
		if (phalcon_memnstr_str(address, SL(","))) {
			PHALCON_INIT_VAR(addresses);
			phalcon_fast_explode_str(addresses, SL(","), address);
	
			PHALCON_OBS_VAR(first);
			phalcon_array_fetch_long(&first, addresses, 0, PH_NOISY);
			RETURN_CTOR(first);
		}
	
		RETURN_CTOR(address);
	}
	
	RETURN_MM_FALSE;
}

static const char* phalcon_http_request_getmethod_helper(TSRMLS_D)
{
	zval **value;
	const char *method = SG(request_info).request_method;
	if (unlikely(!method)) {
		zval *_SERVER, key;

		INIT_ZVAL(key);
		ZVAL_STRING(&key, "REQUEST_METHOD", 0);

		_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
		if (Z_TYPE_P(_SERVER) == IS_ARRAY) {
			value = phalcon_hash_get(Z_ARRVAL_P(_SERVER), &key, BP_VAR_NA);
			if (value && Z_TYPE_PP(value) == IS_STRING) {
				return Z_STRVAL_PP(value);
			}
		}

		return "";
	}

	return method;
}

static PHP_METHOD(Phalcon_Http_Request, getMethod){

	const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
	if (method) {
		RETURN_STRING(method, !IS_INTERNED(method));
	}

	RETURN_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Http_Request, getURI){

	zval **value, *_SERVER, key = zval_used_for_init;

	INIT_ZVAL(key);
	ZVAL_STRING(&key, "REQUEST_URI", 0);

	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	value = (Z_TYPE_P(_SERVER) == IS_ARRAY) ? phalcon_hash_get(Z_ARRVAL_P(_SERVER), &key, BP_VAR_NA) : NULL;
	if (value && Z_TYPE_PP(value) == IS_STRING) {
		RETURN_ZVAL(*value, 1, 0);
	}

	RETURN_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Http_Request, getUserAgent){

	zval *server, *user_agent;

	server = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&user_agent, server, SS("HTTP_USER_AGENT"))) {
		RETURN_ZVAL(user_agent, 1, 0);
	}
	
	RETURN_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Http_Request, isMethod){

	zval *methods, *http_method = NULL, *method = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &methods);
	
	PHALCON_CALL_METHOD(&http_method, this_ptr, "getmethod");

	if (Z_TYPE_P(methods) == IS_STRING) {
		is_equal_function(return_value, methods, http_method TSRMLS_CC);
		RETURN_MM();
	}
	
	phalcon_is_iterable(methods, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HVALUE(method);

		if (PHALCON_IS_EQUAL(method, http_method)) {
			RETURN_MM_TRUE;
		}

		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Http_Request, isPost){

	zval *post, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "POST"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(post);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(post, phalcon_interned_POST);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, post TSRMLS_CC);

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isGet){

	zval *get, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "GET"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(get);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(get, phalcon_interned_GET);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, get TSRMLS_CC);

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isPut){

	zval *put, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "PUT"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(put);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(put, phalcon_interned_PUT);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, put TSRMLS_CC);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isPatch){

	zval *patch, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "PATCH"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(patch);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(patch, phalcon_interned_PATCH);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, patch TSRMLS_CC);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isHead){

	zval *head, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "HEAD"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(head);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(head, phalcon_interned_HEAD);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, head TSRMLS_CC);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isDelete){

	zval *delete, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "DELETE"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(delete);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(delete, phalcon_interned_DELETE);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, delete TSRMLS_CC);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, isOptions){

	zval *options, *method = NULL;

	if (Z_OBJCE_P(getThis()) == phalcon_http_request_ce) {
		const char *method = phalcon_http_request_getmethod_helper(TSRMLS_C);
		RETURN_BOOL(!strcmp(method, "OPTIONS"));
	}

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(options);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(options, phalcon_interned_OPTIONS);

	PHALCON_CALL_METHOD(&method, this_ptr, "getmethod");
	is_equal_function(return_value, method, options TSRMLS_CC);
	
	RETURN_MM();
}

static int phalcon_http_request_hasfiles_helper(zval *arr, int only_successful)
{
	HashPosition hp;
	zval **value;
	int nfiles = 0;

	assert(Z_TYPE_P(arr) == IS_ARRAY);

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(arr), &hp);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(arr), (void**) &value, &hp) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(arr), &hp)
	) {
		if (Z_TYPE_PP(value) < IS_ARRAY) {
			if (!zend_is_true(*value) || !only_successful) {
				++nfiles;
			}
		}
		else if (Z_TYPE_PP(value) == IS_ARRAY) {
			nfiles += phalcon_http_request_hasfiles_helper(*value, only_successful);
		}
	}

	return nfiles;
}

static PHP_METHOD(Phalcon_Http_Request, hasFiles){

	zval *not_errored = NULL, *_FILES, *error = NULL;
	HashPosition hp0;
	zval **hd;
	int nfiles = 0;
	int only_successful;

	phalcon_fetch_params(0, 0, 1, &not_errored);
	
	only_successful = not_errored ? phalcon_get_intval(not_errored) : 1;
	
	_FILES = phalcon_get_global(SS("_FILES") TSRMLS_CC);
	if (unlikely(Z_TYPE_P(_FILES) != IS_ARRAY)) {
		RETURN_LONG(0);
	}

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(_FILES), &hp0);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(_FILES), (void**)&hd, &hp0) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(_FILES), &hp0)
	) {
		if (phalcon_array_isset_string_fetch(&error, *hd, SS("error"))) {
			if (Z_TYPE_P(error) < IS_ARRAY) {
				if (!zend_is_true(error) || !only_successful) {
					++nfiles;
				}
			}
			else if (Z_TYPE_P(error) == IS_ARRAY) {
				nfiles += phalcon_http_request_hasfiles_helper(error, only_successful);
			}
		}
	}

	RETURN_LONG(nfiles);
}

static void phalcon_http_request_getuploadedfiles_helper(zval **return_value, zval *name, zval *type, zval *tmp_name, zval *error, zval *size, int only_successful, smart_str *prefix TSRMLS_DC)
{
	if (
		   Z_TYPE_P(name) == IS_ARRAY && Z_TYPE_P(type) == IS_ARRAY
		&& Z_TYPE_P(tmp_name) == IS_ARRAY && Z_TYPE_P(error) == IS_ARRAY
		&& Z_TYPE_P(size) == IS_ARRAY
	) {
		HashPosition pos_name, pos_type, pos_tmp, pos_error, pos_size;
		zval **dname, **dtype, **dtmp, **derror, **dsize;
		zval *arr, *file, *key;
		size_t prefix_len = prefix->len;
		int res;

		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(name),     &pos_name);
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(type),     &pos_type);
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(tmp_name), &pos_tmp);
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(error),    &pos_error);
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(size),     &pos_size);

		while (
			   zend_hash_get_current_data_ex(Z_ARRVAL_P(name),     (void**)&dname,  &pos_name)  == SUCCESS
			&& zend_hash_get_current_data_ex(Z_ARRVAL_P(type),     (void**)&dtype,  &pos_type)  == SUCCESS
			&& zend_hash_get_current_data_ex(Z_ARRVAL_P(tmp_name), (void**)&dtmp,   &pos_tmp)   == SUCCESS
			&& zend_hash_get_current_data_ex(Z_ARRVAL_P(error),    (void**)&derror, &pos_error) == SUCCESS
			&& zend_hash_get_current_data_ex(Z_ARRVAL_P(size),     (void**)&dsize,  &pos_size)  == SUCCESS
		) {
			zval index = phalcon_get_current_key_w(Z_ARRVAL_P(name), &pos_name);

			if (Z_TYPE(index) == IS_STRING) {
				smart_str_appendl(prefix, Z_STRVAL(index), Z_STRLEN(index));
			}
			else {
				smart_str_append_long(prefix, Z_LVAL(index));
			}

			if (Z_TYPE_PP(derror) < IS_ARRAY) {
				if (!zend_is_true(*derror) || !only_successful) {
					Z_ADDREF_PP(dname);
					Z_ADDREF_PP(dtype);
					Z_ADDREF_PP(dtmp);
					Z_ADDREF_PP(derror);
					Z_ADDREF_PP(dsize);

					MAKE_STD_ZVAL(arr);
					array_init_size(arr, 5);
					add_assoc_zval_ex(arr, ISS(name),      *dname);
					add_assoc_zval_ex(arr, ISS(type),      *dtype);
					add_assoc_zval_ex(arr, SS("tmp_name"), *dtmp);
					add_assoc_zval_ex(arr, SS("error"),    *derror);
					add_assoc_zval_ex(arr, SS("size"),     *dsize);

					MAKE_STD_ZVAL(key);
					ZVAL_STRINGL(key, prefix->c, prefix->len, 1);
					prefix->len = prefix_len;

					MAKE_STD_ZVAL(file);
					object_init_ex(file, phalcon_http_request_file_ce);

					{
						zval *params[] = { arr, key };
						res = phalcon_call_method(NULL, file, "__construct", 2, params TSRMLS_CC);
					}

					zval_ptr_dtor(&arr);
					zval_ptr_dtor(&key);

					if (res != FAILURE) {
						add_next_index_zval(*return_value, file);
					}
					else {
						break;
					}
				}
			}
			else if (Z_TYPE_PP(derror) == IS_ARRAY) {
				smart_str_appendc(prefix, '.');
				phalcon_http_request_getuploadedfiles_helper(return_value, *dname, *dtype, *dtmp, *derror, *dsize, only_successful, prefix TSRMLS_CC);
				prefix->len = prefix_len;
			}

			zend_hash_move_forward_ex(Z_ARRVAL_P(name),     &pos_name);
			zend_hash_move_forward_ex(Z_ARRVAL_P(type),     &pos_type);
			zend_hash_move_forward_ex(Z_ARRVAL_P(tmp_name), &pos_tmp);
			zend_hash_move_forward_ex(Z_ARRVAL_P(error),    &pos_error);
			zend_hash_move_forward_ex(Z_ARRVAL_P(size),     &pos_size);
		}
	}
}

static PHP_METHOD(Phalcon_Http_Request, getUploadedFiles){

	zval *name = NULL, *type = NULL, *tmp_name = NULL, *error, *size = NULL;
	zval *not_errored = NULL, *_FILES, *request_file = NULL, *key = NULL;
	zval index;
	HashPosition hp0;
	zval **hd;
	int only_successful;
	smart_str prefix = { NULL, 0, 0 };

	phalcon_fetch_params(0, 0, 1, &not_errored);
	
	only_successful = not_errored ? phalcon_get_intval(not_errored) : 1;

	array_init(return_value);

	_FILES = phalcon_get_global(SS("_FILES") TSRMLS_CC);
	if (Z_TYPE_P(_FILES) != IS_ARRAY || !zend_hash_num_elements(Z_ARRVAL_P(_FILES))) {
		return;
	}

	PHALCON_MM_GROW();
	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(_FILES), &hp0);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(_FILES), (void**)&hd, &hp0) == SUCCESS && !EG(exception);
		zend_hash_move_forward_ex(Z_ARRVAL_P(_FILES), &hp0)
	) {
		if (phalcon_array_isset_string_fetch(&error, *hd, SS("error"))) {
			index = phalcon_get_current_key_w(Z_ARRVAL_P(_FILES), &hp0);

			if (Z_TYPE_P(error) < IS_ARRAY) {
				if (!zend_is_true(error) || !only_successful) {
					PHALCON_INIT_NVAR(request_file);
					object_init_ex(request_file, phalcon_http_request_file_ce);

					PHALCON_INIT_NVAR(key);
					ZVAL_STRINGL(key, Z_STRVAL(index), Z_STRLEN(index), 1);

					PHALCON_CALL_METHOD(NULL, request_file, "__construct", *hd, key);

					phalcon_array_append(&return_value, request_file, 0);
				}
			}
			else if (Z_TYPE_P(error) == IS_ARRAY) {
				PHALCON_OBS_NVAR(name);
				PHALCON_OBS_NVAR(type);
				PHALCON_OBS_NVAR(tmp_name);
				PHALCON_OBS_NVAR(size);
				phalcon_array_fetch_string(&name,     *hd, SL("name"),     PH_NOISY);
				phalcon_array_fetch_string(&type,     *hd, SL("type"),     PH_NOISY);
				phalcon_array_fetch_string(&tmp_name, *hd, SL("tmp_name"), PH_NOISY);
				phalcon_array_fetch_string(&size,     *hd, SL("size"),     PH_NOISY);

				if (prefix.len) {
					prefix.len = 0;
				}

				if (likely(Z_TYPE(index) == IS_STRING)) {
					smart_str_appendl(&prefix, Z_STRVAL(index), Z_STRLEN(index));
				}
				else {
					smart_str_append_long(&prefix, Z_LVAL(index));
				}

				smart_str_appendc(&prefix, '.');
				phalcon_http_request_getuploadedfiles_helper(&return_value, name, type, tmp_name, error, size, only_successful, &prefix TSRMLS_CC);
			}
		}
	}
	
	if (prefix.c) {
		smart_str_free(&prefix);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getHeaders){

	zval *_SERVER;
	HashPosition hp0;
	zval **hd;

	array_init(return_value);
	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (unlikely(Z_TYPE_P(_SERVER) != IS_ARRAY)) {
		return;
	}

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(_SERVER), &hp0);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(_SERVER), (void**)&hd, &hp0) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(_SERVER), &hp0)
	) {
		zval key = phalcon_get_current_key_w(Z_ARRVAL_P(_SERVER), &hp0);
	
		if (Z_TYPE(key) == IS_STRING && Z_STRLEN(key) > 5 && !memcmp(Z_STRVAL(key), "HTTP_", 5)) {
			zval *header;

			MAKE_STD_ZVAL(header);
			ZVAL_STRINGL(header, Z_STRVAL(key) + 5, Z_STRLEN(key) - 5, 1);
			phalcon_array_update_zval(&return_value, header, *hd, 0);
		}
	}
}

static PHP_METHOD(Phalcon_Http_Request, getHTTPReferer){

	zval *_SERVER, *http_referer;

	_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&http_referer, _SERVER, SS("HTTP_REFERER"))) {
		RETURN_ZVAL(http_referer, 1, 0);
	}

	RETURN_EMPTY_STRING();
}

static PHP_METHOD(Phalcon_Http_Request, _getQualityHeader){

	zval *server_index, *name, *quality_one;
	zval *http_server = NULL, *pattern, *parts = NULL, *part = NULL, *header_parts = NULL;
	zval *quality_part = NULL, *quality = NULL, *header_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &server_index, &name);
	
	PHALCON_INIT_VAR(quality_one);
	ZVAL_DOUBLE(quality_one, 1);
	
	array_init(return_value);
	
	PHALCON_CALL_METHOD(&http_server, this_ptr, "getserver", server_index);
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "/,\\s*/", 1);
	PHALCON_CALL_FUNCTION(&parts, "preg_split", pattern, http_server);
	
	phalcon_is_iterable(parts, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(part);
	
		PHALCON_INIT_NVAR(header_parts);
		phalcon_fast_explode_str(header_parts, SL(";"), part);
		if (phalcon_array_isset_long(header_parts, 1)) {
			PHALCON_OBS_NVAR(quality_part);
			phalcon_array_fetch_long(&quality_part, header_parts, 1, PH_NOISY);
	
			PHALCON_INIT_NVAR(quality);
			phalcon_substr(quality, quality_part, 2, 0);
		} else {
			PHALCON_CPY_WRT(quality, quality_one);
		}
	
		PHALCON_OBS_NVAR(header_name);
		phalcon_array_fetch_long(&header_name, header_parts, 0, PH_NOISY);
	
		PHALCON_INIT_NVAR(quality_part);
		array_init_size(quality_part, 2);
		phalcon_array_update_zval(&quality_part, name, header_name, PH_COPY);
		phalcon_array_update_string(&quality_part, SL("quality"), quality, PH_COPY);
		phalcon_array_append(&return_value, quality_part, 0);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request, _getBestQuality){

	zval *quality_parts, *name, *quality = NULL, *selected_name = NULL;
	zval *accept = NULL, *accept_quality = NULL, *best_quality = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	long int i = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &quality_parts, &name);
	
	PHALCON_INIT_VAR(quality);
	ZVAL_LONG(quality, 0);
	
	PHALCON_INIT_VAR(selected_name);
	ZVAL_EMPTY_STRING(selected_name);
	
	phalcon_is_iterable(quality_parts, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(accept);
	
		if (i == 0) {
			PHALCON_OBS_NVAR(quality);
			phalcon_array_fetch_quick_string(&quality, accept, SS("quality"), 3712111054UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(selected_name);
			phalcon_array_fetch(&selected_name, accept, name, PH_NOISY);
		} else {
			PHALCON_OBS_NVAR(accept_quality);
			phalcon_array_fetch_quick_string(&accept_quality, accept, SS("quality"), 3712111054UL, PH_NOISY);
	
			PHALCON_INIT_NVAR(best_quality);
			is_smaller_function(best_quality, quality, accept_quality TSRMLS_CC);
			if (PHALCON_IS_TRUE(best_quality)) {
				PHALCON_CPY_WRT(quality, accept_quality);
	
				PHALCON_OBS_NVAR(selected_name);
				phalcon_array_fetch(&selected_name, accept, name, PH_NOISY);
			}
		}

		++i;
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(selected_name);
}

static PHP_METHOD(Phalcon_Http_Request, getAcceptableContent){

	zval *accept_header, *quality_index;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(accept_header);
	ZVAL_STRING(accept_header, "HTTP_ACCEPT", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "accept", 1);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getqualityheader", accept_header, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getBestAccept){

	zval *quality_index, *acceptable_content = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "accept", 1);
	
	PHALCON_CALL_METHOD(&acceptable_content, this_ptr, "getacceptablecontent");
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getbestquality", acceptable_content, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getClientCharsets){

	zval *charset_header, *quality_index;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(charset_header);
	ZVAL_STRING(charset_header, "HTTP_ACCEPT_CHARSET", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "charset", 1);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getqualityheader", charset_header, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getBestCharset){

	zval *quality_index, *client_charsets = NULL;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "charset", 1);
	
	PHALCON_CALL_METHOD(&client_charsets, this_ptr, "getclientcharsets");
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getbestquality", client_charsets, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getLanguages){

	zval *language_header, *quality_index;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(language_header);
	ZVAL_STRING(language_header, "HTTP_ACCEPT_LANGUAGE", 1);
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "language", 1);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getqualityheader", language_header, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getBestLanguage){

	zval *languages = NULL, *quality_index;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&languages, this_ptr, "getlanguages");
	
	PHALCON_INIT_VAR(quality_index);
	ZVAL_STRING(quality_index, "language", 1);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getbestquality", languages, quality_index);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Http_Request, getBasicAuth){

	zval *_SERVER;
	zval **value;
	char *auth_user = SG(request_info).auth_user;
	char *auth_password = SG(request_info).auth_password;

	if (unlikely(!auth_user)) {
		_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
		if (Z_TYPE_P(_SERVER) == IS_ARRAY) {
			zval key = zval_used_for_init;

			ZVAL_STRING(&key, "PHP_AUTH_USER", 0);

			value = phalcon_hash_get(Z_ARRVAL_P(_SERVER), &key, BP_VAR_NA);
			if (value && Z_TYPE_PP(value) == IS_STRING) {
				auth_user = Z_STRVAL_PP(value);
			}

			ZVAL_STRING(&key, "PHP_AUTH_PW", 0);

			value = phalcon_hash_get(Z_ARRVAL_P(_SERVER), &key, BP_VAR_NA);
			if (value && Z_TYPE_PP(value) == IS_STRING) {
				auth_password = Z_STRVAL_PP(value);
			}
		}
	}

	if (!auth_user) {
		RETURN_NULL();
	}
	
	if (!auth_password) {
		auth_password = "";
	}

	array_init_size(return_value, 2);
	add_assoc_stringl_ex(return_value, SS("username"), auth_user, strlen(auth_user), 1);
	add_assoc_stringl_ex(return_value, SS("password"), auth_password, strlen(auth_password), 1);
}

static PHP_METHOD(Phalcon_Http_Request, getDigestAuth){

	zval *digest, *pattern, *set_order, *matches, *match = NULL, *ret = NULL, *tmp1, *tmp2;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	const char *auth_digest = SG(request_info).auth_digest;

	PHALCON_MM_GROW();

	if (unlikely(!auth_digest)) {
		zval *_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
		if (Z_TYPE_P(_SERVER) == IS_ARRAY) {
			zval key = zval_used_for_init;
			zval **value;

			ZVAL_STRING(&key, "PHP_AUTH_DIGEST", 0);

			value = phalcon_hash_get(Z_ARRVAL_P(_SERVER), &key, BP_VAR_NA);
			if (value && Z_TYPE_PP(value) == IS_STRING) {
				auth_digest = Z_STRVAL_PP(value);
			}
		}
	}

	if (auth_digest) {
		PHALCON_INIT_VAR(digest);
		ZVAL_STRING(digest, auth_digest, 1);

		PHALCON_INIT_VAR(pattern);
		ZVAL_STRING(pattern, "#(\\w+)=(['\"]?)([^'\", ]+)\\2#", 1);

		PHALCON_INIT_VAR(set_order);
		ZVAL_LONG(set_order, 2);

		PHALCON_INIT_VAR(matches);
		Z_SET_ISREF_P(matches);
		PHALCON_CALL_FUNCTION(&ret, "preg_match_all", pattern, digest, matches, set_order);
		Z_UNSET_ISREF_P(matches);

		if (zend_is_true(ret) && Z_TYPE_P(matches) == IS_ARRAY) {
			array_init(return_value);

			phalcon_is_iterable(matches, &ah0, &hp0, 0, 0);
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
				PHALCON_GET_HVALUE(match);

				if (Z_TYPE_P(match) == IS_ARRAY && phalcon_array_isset_long_fetch(&tmp1, match, 1) && phalcon_array_isset_long_fetch(&tmp2, match, 3)) {
					phalcon_array_update_zval(&return_value, tmp1, tmp2, PH_COPY);
				}
				zend_hash_move_forward_ex(ah0, &hp0);
			}

			RETURN_MM();
		}
	}

	RETURN_MM_NULL();
}





zend_class_entry *phalcon_http_requestinterface_ce;

static const zend_function_entry phalcon_http_requestinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, get, arginfo_phalcon_http_requestinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getPost, arginfo_phalcon_http_requestinterface_getpost)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getPut, arginfo_phalcon_http_requestinterface_getput)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getQuery, arginfo_phalcon_http_requestinterface_getquery)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getServer, arginfo_phalcon_http_requestinterface_getserver)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, has, arginfo_phalcon_http_requestinterface_has)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, hasPost, arginfo_phalcon_http_requestinterface_haspost)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, hasPut, arginfo_phalcon_http_requestinterface_hasput)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, hasQuery, arginfo_phalcon_http_requestinterface_hasquery)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, hasServer, arginfo_phalcon_http_requestinterface_hasserver)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getHeader, arginfo_phalcon_http_requestinterface_getheader)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getScheme, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isAjax, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isSoapRequested, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isSecureRequest, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getRawBody, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getServerAddress, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getServerName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getHttpHost, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getClientAddress, arginfo_phalcon_http_requestinterface_getclientaddress)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getMethod, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getUserAgent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isMethod, arginfo_phalcon_http_requestinterface_ismethod)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isPost, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isGet, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isPut, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isHead, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isDelete, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, isOptions, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, hasFiles, arginfo_phalcon_http_requestinterface_hasfiles)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getUploadedFiles, arginfo_phalcon_http_requestinterface_getuploadedfiles)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getHTTPReferer, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getAcceptableContent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getBestAccept, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getClientCharsets, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getBestCharset, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getLanguages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_RequestInterface, getBestLanguage, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_RequestInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http, RequestInterface, http_requestinterface, phalcon_http_requestinterface_method_entry);

	return SUCCESS;
}








































#include <ext/date/php_date.h>



zend_class_entry *phalcon_http_response_ce;

static PHP_METHOD(Phalcon_Http_Response, __construct);
static PHP_METHOD(Phalcon_Http_Response, setDI);
static PHP_METHOD(Phalcon_Http_Response, getDI);
static PHP_METHOD(Phalcon_Http_Response, setStatusCode);
static PHP_METHOD(Phalcon_Http_Response, setHeaders);
static PHP_METHOD(Phalcon_Http_Response, getHeaders);
static PHP_METHOD(Phalcon_Http_Response, setCookies);
static PHP_METHOD(Phalcon_Http_Response, getCookies);
static PHP_METHOD(Phalcon_Http_Response, setHeader);
static PHP_METHOD(Phalcon_Http_Response, setRawHeader);
static PHP_METHOD(Phalcon_Http_Response, resetHeaders);
static PHP_METHOD(Phalcon_Http_Response, setExpires);
static PHP_METHOD(Phalcon_Http_Response, setNotModified);
static PHP_METHOD(Phalcon_Http_Response, setContentType);
static PHP_METHOD(Phalcon_Http_Response, setEtag);
static PHP_METHOD(Phalcon_Http_Response, redirect);
static PHP_METHOD(Phalcon_Http_Response, setContent);
static PHP_METHOD(Phalcon_Http_Response, setJsonContent);
static PHP_METHOD(Phalcon_Http_Response, appendContent);
static PHP_METHOD(Phalcon_Http_Response, getContent);
static PHP_METHOD(Phalcon_Http_Response, isSent);
static PHP_METHOD(Phalcon_Http_Response, sendHeaders);
static PHP_METHOD(Phalcon_Http_Response, sendCookies);
static PHP_METHOD(Phalcon_Http_Response, send);
static PHP_METHOD(Phalcon_Http_Response, setFileToSend);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_response___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, content)
	ZEND_ARG_INFO(0, code)
	ZEND_ARG_INFO(0, status)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_response_setheaders, 0, 0, 1)
	ZEND_ARG_INFO(0, headers)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_response_setcookies, 0, 0, 1)
	ZEND_ARG_INFO(0, cookies)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_response_setetag, 0, 0, 1)
	ZEND_ARG_INFO(0, etag)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_http_response_method_entry[] = {
	PHP_ME(Phalcon_Http_Response, __construct, arginfo_phalcon_http_response___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Http_Response, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setStatusCode, arginfo_phalcon_http_responseinterface_setstatuscode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setHeaders, arginfo_phalcon_http_response_setheaders, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, getHeaders, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setCookies, arginfo_phalcon_http_response_setcookies, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, getCookies, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setHeader, arginfo_phalcon_http_responseinterface_setheader, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setRawHeader, arginfo_phalcon_http_responseinterface_setrawheader, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, resetHeaders, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setExpires, arginfo_phalcon_http_responseinterface_setexpires, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setNotModified, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setContentType, arginfo_phalcon_http_responseinterface_setcontenttype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setEtag, arginfo_phalcon_http_response_setetag, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, redirect, arginfo_phalcon_http_responseinterface_redirect, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setContent, arginfo_phalcon_http_responseinterface_setcontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setJsonContent, arginfo_phalcon_http_responseinterface_setjsoncontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, appendContent, arginfo_phalcon_http_responseinterface_appendcontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, getContent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, isSent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, sendHeaders, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, sendCookies, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, send, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response, setFileToSend, arginfo_phalcon_http_responseinterface_setfiletosend, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Response){

	PHALCON_REGISTER_CLASS(Phalcon\\Http, Response, http_response, phalcon_http_response_method_entry, 0);

	zend_declare_property_bool(phalcon_http_response_ce, SL("_sent"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_content"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_cookies"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_file"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_response_ce TSRMLS_CC, 2, phalcon_http_responseinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Response, __construct){

	zval *content = NULL, *code = NULL, *status = NULL;

	phalcon_fetch_params(0, 0, 3, &content, &code, &status);
	
	if (!status) {
		status = PHALCON_GLOBAL(z_null);
	}
	
	if (content && Z_TYPE_P(content) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_content"), content, 4081318271UL TSRMLS_CC);
	}

	if (code && Z_TYPE_P(code) != IS_NULL) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, this_ptr, "setstatuscode", code, status);
		PHALCON_MM_RESTORE();
	}
}

static PHP_METHOD(Phalcon_Http_Response, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_response_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Response, getDI){

	zval *dependency_injector;

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		dependency_injector = NULL;
		PHALCON_CALL_CE_STATICW(&dependency_injector, phalcon_di_ce, "getdefault");
		PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_response_exception_ce, 0);
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);

		RETURN_ZVAL(dependency_injector, 1, 1);
	}
	
	RETURN_ZVAL(dependency_injector, 1, 0);
}

static PHP_METHOD(Phalcon_Http_Response, setStatusCode){

	zval *code, *message, *headers = NULL, *header_value, *status_value;
	zval *status_header, *current_headers_raw = NULL, *header_name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &code, &message);
	
	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");

	PHALCON_CALL_METHOD(&current_headers_raw, headers, "toarray");

	if (Z_TYPE_P(current_headers_raw) == IS_ARRAY) {

		phalcon_is_iterable(current_headers_raw, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HKEY(header_name, ah0, hp0);

			if (Z_TYPE_P(header_name) == IS_STRING && (size_t)(Z_STRLEN_P(header_name)) > sizeof("HTTP/x.y ")-1 && !memcmp(Z_STRVAL_P(header_name), "HTTP/", 5)) {
				PHALCON_CALL_METHOD(NULL, headers, "remove", header_name);
			}

			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}

	PHALCON_INIT_VAR(header_value);
	PHALCON_CONCAT_SVSV(header_value, "HTTP/1.1 ", code, " ", message);
	PHALCON_CALL_METHOD(NULL, headers, "setraw", header_value);

	PHALCON_INIT_VAR(status_value);
	PHALCON_CONCAT_VSV(status_value, code, " ", message);
	
	PHALCON_INIT_VAR(status_header);
	ZVAL_STRING(status_header, "Status", 1);
	PHALCON_CALL_METHOD(NULL, headers, "set", status_header, status_value);
	phalcon_update_property_this_quick(this_ptr, SL("_headers"), headers, 1867660032UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setHeaders){

	zval *headers;

	phalcon_fetch_params(0, 1, 0, &headers);
	
	phalcon_update_property_this_quick(this_ptr, SL("_headers"), headers, 1867660032UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response, getHeaders){

	zval *headers;

	headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(headers) == IS_NULL) {
		object_init_ex(return_value, phalcon_http_response_headers_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_headers"), return_value, 1867660032UL TSRMLS_CC);
		return;
	}
	
	RETURN_ZVAL(headers, 1, 0);
}

static PHP_METHOD(Phalcon_Http_Response, setCookies){

	zval *cookies;

	phalcon_fetch_params(0, 1, 0, &cookies);
	
	if (Z_TYPE_P(cookies) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_http_response_exception_ce, "The cookies bag is not valid");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_cookies"), cookies, 4109914289UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response, getCookies){


	RETURN_MEMBER_QUICK(this_ptr, "_cookies", 4109914289UL);
}

static PHP_METHOD(Phalcon_Http_Response, setHeader){

	zval *name, *value, *headers = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &name, &value);
	
	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	PHALCON_CALL_METHOD(NULL, headers, "set", name, value);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setRawHeader){

	zval *header, *headers = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &header);
	
	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	PHALCON_CALL_METHOD(NULL, headers, "setraw", header);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, resetHeaders){

	zval *headers = NULL;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	PHALCON_CALL_METHOD(NULL, headers, "reset");
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setExpires){

	zval *datetime, *headers = NULL, *date, *utc_zone, *timezone;
	zval *format, *utc_format = NULL, *utc_date, *expires_header;
	zend_class_entry *datetime_ce, *datetimezone_ce;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &datetime);
	
	datetime_ce = php_date_get_date_ce();
	PHALCON_VERIFY_CLASS_EX(datetime, datetime_ce, phalcon_http_response_exception_ce, 1);

	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	
	PHALCON_INIT_VAR(date);
	if (phalcon_clone(date, datetime TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_INIT_VAR(utc_zone);
	ZVAL_STRING(utc_zone, "UTC", 1);
	datetimezone_ce = php_date_get_timezone_ce();
	
	PHALCON_INIT_VAR(timezone);
	object_init_ex(timezone, datetimezone_ce);
	PHALCON_CALL_METHOD(NULL, timezone, "__construct", utc_zone);
	
	PHALCON_CALL_METHOD(NULL, date, "settimezone", timezone);
	
	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "D, d M Y H:i:s", 1);
	PHALCON_CALL_METHOD(&utc_format, date, "format", format);
	
	PHALCON_INIT_VAR(utc_date);
	PHALCON_CONCAT_VS(utc_date, utc_format, " GMT");
	
	PHALCON_INIT_VAR(expires_header);
	ZVAL_STRING(expires_header, "Expires", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "setheader", expires_header, utc_date);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setNotModified){

	zval *code, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(code);
	ZVAL_LONG(code, 304);
	
	PHALCON_INIT_VAR(status);
	ZVAL_STRING(status, "Not modified", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "setstatuscode", code, status);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setContentType){

	zval *content_type, *charset = NULL, *headers = NULL, *name, *header_value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &content_type, &charset);
	
	if (!charset) {
		charset = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	
	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "Content-Type", 1);
	if (Z_TYPE_P(charset) == IS_NULL) {
		PHALCON_CALL_METHOD(NULL, headers, "set", name, content_type);
	} else {
		PHALCON_INIT_VAR(header_value);
		PHALCON_CONCAT_VSV(header_value, content_type, "; charset=", charset);
		PHALCON_CALL_METHOD(NULL, headers, "set", name, header_value);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setEtag){

	zval *etag, *name, *headers = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &etag);
	
	PHALCON_INIT_VAR(name);
	ZVAL_STRING(name, "ETag", 1);
	
	PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");
	PHALCON_CALL_METHOD(NULL, headers, "set", name, etag);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, redirect){

	zval *location = NULL, *external_redirect = NULL, *status_code = NULL;
	zval *header = NULL, *dependency_injector = NULL, *service;
	zval *url = NULL, *status_text, *header_name;
	zval *matched, *pattern;

	static const char* redirect_phrases[] = {
		/* 300 */ "Multiple Choices",
		/* 301 */ "Moved Permanently",
		/* 302 */ "Found",
		/* 303 */ "See Other",
		/* 304 */ "Not Modified",
		/* 305 */ "Use Proxy",
		/* 306 */ "Switch Proxy",
		/* 307 */ "Temporary Redirect",
		/* 308 */ "Permanent Redirect"
	};

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 3, &location, &external_redirect, &status_code);
	
	if (!location) {
		PHALCON_INIT_VAR(location);
		ZVAL_EMPTY_STRING(location);
	}
	else if (Z_TYPE_P(location) != IS_STRING && Z_TYPE_P(location) != IS_ARRAY) {
		PHALCON_SEPARATE_PARAM(location);
		convert_to_string(location);
	}
	
	if (!external_redirect) {
		external_redirect = PHALCON_GLOBAL(z_false);
	}
	
	if (!status_code) {
		PHALCON_INIT_VAR(status_code);
		ZVAL_LONG(status_code, 302);
	} else {
		if (unlikely(Z_TYPE_P(status_code) != IS_LONG)) {
			PHALCON_SEPARATE_PARAM(status_code);
			convert_to_long(status_code);			
		}
	}
	
	if (Z_TYPE_P(location) == IS_STRING && zend_is_true(external_redirect)) {
		header = location;
	} else if (Z_TYPE_P(location) == IS_STRING && strstr(Z_STRVAL_P(location), "://")) {
		PHALCON_INIT_VAR(matched);
		PHALCON_INIT_VAR(pattern);
		ZVAL_STRING(pattern, "/^[^:\\/?#]++:/", 1);
		RETURN_MM_ON_FAILURE(phalcon_preg_match(matched, pattern, location, NULL TSRMLS_CC));
		if (zend_is_true(matched)) {
			header = location;
		}
		else {
			header = NULL;
		}
	}
	else {
		header = NULL;
	}

	if (!header) {
		PHALCON_CALL_METHOD(&dependency_injector, this_ptr, "getdi");
	
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_url);
	
		PHALCON_CALL_METHOD(&url, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(url, phalcon_mvc_urlinterface_ce);
	
		PHALCON_CALL_METHOD(&header, url, "get", location);
	}
	
	/* The HTTP status is 302 by default, a temporary redirection */
	PHALCON_INIT_VAR(status_text);
	if (Z_LVAL_P(status_code) < 300 || Z_LVAL_P(status_code) > 308) {
		ZVAL_STRING(status_text, "Redirect", 1);
		if (!Z_LVAL_P(status_code)) {
			ZVAL_LONG(status_code, 302);
		}
	}
	else {
		ZVAL_STRING(status_text, redirect_phrases[Z_LVAL_P(status_code) - 300], 1);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "setstatuscode", status_code, status_text);
	
	PHALCON_INIT_VAR(header_name);
	ZVAL_STRING(header_name, "Location", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "setheader", header_name, header);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, setContent){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	phalcon_update_property_this_quick(this_ptr, SL("_content"), content, 4081318271UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response, setJsonContent){

	zval *content, *json_options = NULL, *json_content;
	int options = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &content, &json_options);
	
	if (json_options) {
		options = phalcon_get_intval(json_options);
	}
	
	PHALCON_INIT_VAR(json_content);
	RETURN_MM_ON_FAILURE(phalcon_json_encode(json_content, content, options TSRMLS_CC));
	phalcon_update_property_this_quick(this_ptr, SL("_content"), json_content, 4081318271UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, appendContent){

	zval *content, *_content;
	zval *temp_content = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &content);
	
	PHALCON_OBS_VAR(_content);
	phalcon_read_property_this(&_content, this_ptr, SL("_content"), PH_NOISY TSRMLS_CC);
	PHALCON_INIT_VAR(temp_content);
	concat_function(temp_content, _content, content TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_content"), temp_content, 4081318271UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response, getContent){


	RETURN_MEMBER_QUICK(this_ptr, "_content", 4081318271UL);
}

static PHP_METHOD(Phalcon_Http_Response, isSent){


	RETURN_MEMBER_QUICK(this_ptr, "_sent", 3990052766UL);
}

static PHP_METHOD(Phalcon_Http_Response, sendHeaders){

	zval *headers;

	headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(headers) == IS_OBJECT) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, headers, "send");
		PHALCON_MM_RESTORE();
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response, sendCookies){

	zval *cookies;

	cookies = phalcon_fetch_nproperty_this(this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(cookies) == IS_OBJECT) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, cookies, "send");
		PHALCON_MM_RESTORE();
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response, send){

	zval *sent, *headers, *cookies, *content, *file;

	PHALCON_MM_GROW();

	sent = phalcon_fetch_nproperty_this(this_ptr, SL("_sent"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(sent)) {
	
		/* Send headers */
		headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(headers) == IS_OBJECT) {
			PHALCON_CALL_METHOD(NULL, headers, "send");
		}
	
		cookies = phalcon_fetch_nproperty_this(this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(cookies) == IS_OBJECT) {
			PHALCON_CALL_METHOD(NULL, cookies, "send");
		}
	
		/* Output the response body */
		content = phalcon_fetch_nproperty_this(this_ptr, SL("_content"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(content) != IS_NULL) {
			zend_print_zval(content, 0);
		}
		else {
			file = phalcon_fetch_nproperty_this(this_ptr, SL("_file"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(file) == IS_STRING && Z_STRLEN_P(file)) {
				php_stream *stream;

				stream = php_stream_open_wrapper(Z_STRVAL_P(file), "rb", REPORT_ERRORS, NULL);
				if (stream != NULL) {
					php_stream_passthru(stream);
					php_stream_close(stream);
				}
			}
		}

		phalcon_update_property_bool(this_ptr, SL("_sent"), 1 TSRMLS_CC);
	
		RETURN_THIS();
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_http_response_exception_ce, "Response was already sent");
	return;
}

static PHP_METHOD(Phalcon_Http_Response, setFileToSend){

	zval *file_path, *attachment_name = NULL, *attachment = NULL, *base_path = NULL;
	zval *headers = NULL, *content_description, *content_disposition;
	zval *content_transfer;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &file_path, &attachment_name, &attachment);
	
	if (!attachment_name) {
		attachment_name = PHALCON_GLOBAL(z_null);
	}

	if (!attachment) {
		attachment = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(attachment_name) != IS_STRING) {
		PHALCON_INIT_VAR(base_path);
		phalcon_basename(base_path, file_path TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(base_path, attachment_name);
	}
	
	if (zend_is_true(attachment)) {
		PHALCON_CALL_METHOD(&headers, this_ptr, "getheaders");

		PHALCON_INIT_VAR(content_description);
		ZVAL_STRING(content_description, "Content-Description: File Transfer", 1);
		PHALCON_CALL_METHOD(NULL, headers, "setraw", content_description);
	
		PHALCON_INIT_VAR(content_disposition);
		PHALCON_CONCAT_SV(content_disposition, "Content-Disposition: attachment; filename=", base_path);
		PHALCON_CALL_METHOD(NULL, headers, "setraw", content_disposition);
	
		PHALCON_INIT_VAR(content_transfer);
		ZVAL_STRING(content_transfer, "Content-Transfer-Encoding: binary", 1);
		PHALCON_CALL_METHOD(NULL, headers, "setraw", content_transfer);
	}
	phalcon_update_property_this_quick(this_ptr, SL("_file"), file_path, 3974776868UL TSRMLS_CC);
	
	RETURN_THIS();
}





zend_class_entry *phalcon_http_responseinterface_ce;

static const zend_function_entry phalcon_http_responseinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setStatusCode, arginfo_phalcon_http_responseinterface_setstatuscode)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, getHeaders, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setHeader, arginfo_phalcon_http_responseinterface_setheader)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setRawHeader, arginfo_phalcon_http_responseinterface_setrawheader)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, resetHeaders, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setExpires, arginfo_phalcon_http_responseinterface_setexpires)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setNotModified, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setContentType, arginfo_phalcon_http_responseinterface_setcontenttype)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, redirect, arginfo_phalcon_http_responseinterface_redirect)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setContent, arginfo_phalcon_http_responseinterface_setcontent)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setJsonContent, arginfo_phalcon_http_responseinterface_setjsoncontent)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, appendContent, arginfo_phalcon_http_responseinterface_appendcontent)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, getContent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, sendHeaders, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, sendCookies, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, send, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_ResponseInterface, setFileToSend, arginfo_phalcon_http_responseinterface_setfiletosend)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_ResponseInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http, ResponseInterface, http_responseinterface, phalcon_http_responseinterface_method_entry);

	return SUCCESS;
}






















zend_class_entry *phalcon_http_cookie_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Http_Cookie_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Cookie, Exception, http_cookie_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_http_request_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Http_Request_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Request, Exception, http_request_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}




#include <main/SAPI.h>
#include <ext/spl/spl_directory.h>


zend_class_entry *phalcon_http_request_file_ce;

static PHP_METHOD(Phalcon_Http_Request_File, __construct);
static PHP_METHOD(Phalcon_Http_Request_File, getSize);
static PHP_METHOD(Phalcon_Http_Request_File, getName);
static PHP_METHOD(Phalcon_Http_Request_File, getTempName);
static PHP_METHOD(Phalcon_Http_Request_File, getType);
static PHP_METHOD(Phalcon_Http_Request_File, getRealType);
static PHP_METHOD(Phalcon_Http_Request_File, getError);
static PHP_METHOD(Phalcon_Http_Request_File, getKey);
static PHP_METHOD(Phalcon_Http_Request_File, isUploadedFile);
static PHP_METHOD(Phalcon_Http_Request_File, moveTo);
static PHP_METHOD(Phalcon_Http_Request_File, __set_state);
static PHP_METHOD(Phalcon_Http_Request_File, getExtension);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_request_file___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, file)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_request_file___set_state, 0, 0, 1)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_http_request_file_method_entry[] = {
	PHP_ME(Phalcon_Http_Request_File, __construct, arginfo_phalcon_http_request_file___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Http_Request_File, getSize, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getTempName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getRealType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getError, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, getKey, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, isUploadedFile, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, moveTo, arginfo_phalcon_http_request_fileinterface_moveto, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Request_File, __set_state, arginfo_phalcon_http_request_file___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Http_Request_File, getExtension, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Request_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Request, File, http_request_file, spl_ce_SplFileInfo, phalcon_http_request_file_method_entry, 0);

	zend_declare_property_null(phalcon_http_request_file_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_tmp"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_size"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_real_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_error"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_key"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_request_file_ce, SL("_extension"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_request_file_ce TSRMLS_CC, 1, phalcon_http_request_fileinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Request_File, __construct){

	zval *file, *name, *temp_name, *size, *type, *error, *key = NULL;
	zval *constant, *extension = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &file, &key);
	
	if (Z_TYPE_P(file) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_request_exception_ce, "Phalcon\\Http\\Request\\File requires a valid uploaded file");
		return;
	}
	if (phalcon_array_isset_quick_string(file, SS("name"), 268211462UL)) {
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, file, SS("name"), 268211462UL, PH_NOISY);
		phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);

		PHALCON_INIT_VAR(constant);
		if (zend_get_constant(SL("PATHINFO_EXTENSION"), constant TSRMLS_CC)) {
			PHALCON_CALL_FUNCTION(&extension, "pathinfo", name, constant);
			phalcon_update_property_this_quick(this_ptr, SL("_extension"), extension, 282305761UL TSRMLS_CC);
		}
	}
	
	if (phalcon_array_isset_quick_string(file, SS("tmp_name"), 3852050422UL)) {
		PHALCON_OBS_VAR(temp_name);
		phalcon_array_fetch_quick_string(&temp_name, file, SS("tmp_name"), 3852050422UL, PH_NOISY);
		phalcon_update_property_this_quick(this_ptr, SL("_tmp"), temp_name, 251105813UL TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(temp_name);
		ZVAL_NULL(temp_name);
 	}
	
	if (phalcon_array_isset_quick_string(file, SS("size"), 274442720UL)) {
		PHALCON_OBS_VAR(size);
		phalcon_array_fetch_quick_string(&size, file, SS("size"), 274442720UL, PH_NOISY);
		phalcon_update_property_this_quick(this_ptr, SL("_size"), size, 3990209087UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_quick_string(file, SS("type"), 276192743UL)) {
		PHALCON_OBS_VAR(type);
		phalcon_array_fetch_quick_string(&type, file, SS("type"), 276192743UL, PH_NOISY);
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	}

	if (phalcon_array_isset_quick_string(file, SS("error"), 4224147407UL)) {
		PHALCON_OBS_VAR(error);
		phalcon_array_fetch_quick_string(&error, file, SS("error"), 4224147407UL, PH_NOISY);
		phalcon_update_property_this_quick(this_ptr, SL("_error"), error, 2290385934UL TSRMLS_CC);
	}

	if (key) {
		phalcon_update_property_this_quick(this_ptr, SL("_key"), key, 250773965UL TSRMLS_CC);
	}

	PHALCON_CALL_PARENT(NULL, phalcon_http_request_file_ce, this_ptr, "__construct", temp_name);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request_File, getSize){


	RETURN_MEMBER_QUICK(this_ptr, "_size", 3990209087UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, getTempName){


	RETURN_MEMBER_QUICK(this_ptr, "_tmp", 251105813UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, getRealType){

	zval *constant, *finfo = NULL, *temp_file, *mime;

	PHALCON_MM_GROW();

	mime = phalcon_fetch_nproperty_this(this_ptr, SL("_real_type"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(mime) == IS_STRING) {
		RETURN_CTOR(mime);
	}

	PHALCON_INIT_VAR(constant);
	if (!zend_get_constant(SL("FILEINFO_MIME_TYPE"), constant TSRMLS_CC)) {
		RETURN_MM_NULL();
	}

	PHALCON_CALL_FUNCTION(&finfo, "finfo_open", constant);

	if (Z_TYPE_P(finfo) != IS_RESOURCE) {
		RETURN_MM_NULL();
	}

	temp_file = phalcon_fetch_nproperty_this(this_ptr, SL("_tmp"), PH_NOISY TSRMLS_CC);

	PHALCON_RETURN_CALL_FUNCTION("finfo_file", finfo, temp_file);
	PHALCON_CALL_FUNCTION(NULL, "finfo_close", finfo);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request_File, getError){


	RETURN_MEMBER_QUICK(this_ptr, "_error", 2290385934UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, getKey){

	RETURN_MEMBER_QUICK(this_ptr, "_key", 250773965UL);
}

static PHP_METHOD(Phalcon_Http_Request_File, isUploadedFile) {

	zval *tmp_name = NULL;

	if (!SG(rfc1867_uploaded_files)) {
		RETURN_FALSE;
	}

	if (phalcon_call_method(&tmp_name, getThis(), "gettempname", 0, NULL TSRMLS_CC) == SUCCESS) {
		if (Z_TYPE_P(tmp_name) == IS_STRING && zend_hash_exists(SG(rfc1867_uploaded_files), Z_STRVAL_P(tmp_name), Z_STRLEN_P(tmp_name) + 1)) {
			RETVAL_TRUE;
		}
		else {
			RETVAL_FALSE;
		}
	}

	zval_ptr_dtor(&tmp_name);
}

static PHP_METHOD(Phalcon_Http_Request_File, moveTo){

	zval *destination, *temp_file;

	phalcon_fetch_params(0, 1, 0, &destination);
	
	temp_file = phalcon_fetch_nproperty_this(this_ptr, SL("_tmp"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_FUNCTIONW("move_uploaded_file", temp_file, destination);
}

static PHP_METHOD(Phalcon_Http_Request_File, __set_state) {

	zval *data;

	phalcon_fetch_params(0, 1, 0, &data);

	object_init_ex(return_value, phalcon_http_request_file_ce);

	PHALCON_MM_GROW();
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", data);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Request_File, getExtension){


	RETURN_MEMBER_QUICK(this_ptr, "_extension", 282305761UL);
}





zend_class_entry *phalcon_http_request_fileinterface_ce;

static const zend_function_entry phalcon_http_request_fileinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, getSize, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, getTempName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, getRealType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Request_FileInterface, moveTo, arginfo_phalcon_http_request_fileinterface_moveto)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Request_FileInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http\\Request, FileInterface, http_request_fileinterface, phalcon_http_request_fileinterface_method_entry);

	return SUCCESS;
}











#include <main/SAPI.h>



zend_class_entry *phalcon_http_response_cookies_ce;

static PHP_METHOD(Phalcon_Http_Response_Cookies, setDI);
static PHP_METHOD(Phalcon_Http_Response_Cookies, getDI);
static PHP_METHOD(Phalcon_Http_Response_Cookies, useEncryption);
static PHP_METHOD(Phalcon_Http_Response_Cookies, isUsingEncryption);
static PHP_METHOD(Phalcon_Http_Response_Cookies, set);
static PHP_METHOD(Phalcon_Http_Response_Cookies, get);
static PHP_METHOD(Phalcon_Http_Response_Cookies, has);
static PHP_METHOD(Phalcon_Http_Response_Cookies, delete);
static PHP_METHOD(Phalcon_Http_Response_Cookies, send);
static PHP_METHOD(Phalcon_Http_Response_Cookies, reset);

static const zend_function_entry phalcon_http_response_cookies_method_entry[] = {
	PHP_ME(Phalcon_Http_Response_Cookies, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, useEncryption, arginfo_phalcon_http_response_cookiesinterface_useencryption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, isUsingEncryption, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, set, arginfo_phalcon_http_response_cookiesinterface_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, get, arginfo_phalcon_http_response_cookiesinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, has, arginfo_phalcon_http_response_cookiesinterface_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, delete, arginfo_phalcon_http_response_cookiesinterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, send, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Cookies, reset, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Response_Cookies){

	PHALCON_REGISTER_CLASS(Phalcon\\Http\\Response, Cookies, http_response_cookies, phalcon_http_response_cookies_method_entry, 0);

	zend_declare_property_null(phalcon_http_response_cookies_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_http_response_cookies_ce, SL("_registered"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_http_response_cookies_ce, SL("_useEncryption"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_http_response_cookies_ce, SL("_cookies"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_response_cookies_ce TSRMLS_CC, 2, phalcon_http_response_cookiesinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_http_cookie_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, useEncryption){

	zval *use_encryption;

	phalcon_fetch_params(0, 1, 0, &use_encryption);
	
	phalcon_update_property_this_quick(this_ptr, SL("_useEncryption"), use_encryption, 2628069468UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, isUsingEncryption){


	RETURN_MEMBER_QUICK(this_ptr, "_useEncryption", 2628069468UL);
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, set){

	zval *name, *value = NULL, *expire = NULL, *path = NULL, *secure = NULL, *domain = NULL;
	zval *http_only = NULL, *cookies, *encryption, *dependency_injector = NULL;
	zval *cookie = NULL, *registered, *service, *response = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 6, &name, &value, &expire, &path, &secure, &domain, &http_only);
	
	if (!value) {
		value = PHALCON_GLOBAL(z_null);
	}
	
	if (!expire) {
		expire = PHALCON_GLOBAL(z_zero);
	}
	
	if (!path) {
		PHALCON_INIT_VAR(path);
		ZVAL_STRING(path, "/", 1);
	}
	
	if (!secure) {
		secure = PHALCON_GLOBAL(z_null);
	}
	
	if (!domain) {
		domain = PHALCON_GLOBAL(z_null);
	}
	
	if (!http_only) {
		http_only = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_cookie_exception_ce, "The cookie name must be string");
		return;
	}
	
	PHALCON_OBS_VAR(cookies);
	phalcon_read_property_this(&cookies, this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(encryption);
	phalcon_read_property_this(&encryption, this_ptr, SL("_useEncryption"), PH_NOISY TSRMLS_CC);
	
	if (!phalcon_array_isset(cookies, name)) {
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(cookie);
		object_init_ex(cookie, phalcon_http_cookie_ce);
	
		PHALCON_CALL_METHOD(NULL, cookie, "__construct", name, value, expire, path, secure, domain, http_only);
	
		PHALCON_CALL_METHOD(NULL, cookie, "setdi", dependency_injector);
	
		if (zend_is_true(encryption)) {
			PHALCON_CALL_METHOD(NULL, cookie, "useencryption", encryption);
		}
	
		phalcon_update_property_array(this_ptr, SL("_cookies"), name, cookie TSRMLS_CC);
	} else {
		PHALCON_OBS_NVAR(cookie);
		phalcon_array_fetch(&cookie, cookies, name, PH_NOISY);
	
		PHALCON_CALL_METHOD(NULL, cookie, "setvalue", value);
		PHALCON_CALL_METHOD(NULL, cookie, "setexpiration", expire);
		PHALCON_CALL_METHOD(NULL, cookie, "setpath", path);
		PHALCON_CALL_METHOD(NULL, cookie, "setsecure", secure);
		PHALCON_CALL_METHOD(NULL, cookie, "setdomain", domain);
		PHALCON_CALL_METHOD(NULL, cookie, "sethttponly", http_only);
	}
	
	PHALCON_OBS_VAR(registered);
	phalcon_read_property_this(&registered, this_ptr, SL("_registered"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(registered)) {
	
		PHALCON_OBS_NVAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_http_cookie_exception_ce, "A dependency injection object is required to access the 'response' service");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_response);
	
		PHALCON_CALL_METHOD(&response, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(response, phalcon_http_responseinterface_ce);
	
		PHALCON_CALL_METHOD(NULL, response, "setcookies", this_ptr);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, get){

	zval *name, *cookies, *cookie = NULL, *dependency_injector;
	zval *encryption;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	if (Z_TYPE_P(name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_http_cookie_exception_ce, "The cookie name must be string");
		return;
	}
	
	PHALCON_OBS_VAR(cookies);
	phalcon_read_property_this(&cookies, this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&cookie, cookies, name)) {
		RETURN_CTOR(cookie);
	}
	
	object_init_ex(return_value, phalcon_http_cookie_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", name);
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
	
		PHALCON_CALL_METHOD(NULL, return_value, "setdi", dependency_injector);
	
		PHALCON_OBS_VAR(encryption);
		phalcon_read_property_this(&encryption, this_ptr, SL("_useEncryption"), PH_NOISY TSRMLS_CC);
	
		if (zend_is_true(encryption)) {
			PHALCON_CALL_METHOD(NULL, return_value, "useencryption", encryption);
		}
	}
	
	phalcon_update_property_array(this_ptr, SL("_cookies"), name, return_value TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, has){

	zval *name, *cookies, *_COOKIE;

	phalcon_fetch_params(0, 1, 0, &name);
	
	cookies = phalcon_fetch_nproperty_this(this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	
	/* Check the internal bag */
	if (phalcon_array_isset(cookies, name)) {
		RETURN_TRUE;
	}
	
	/* Check the superglobal */
	_COOKIE = phalcon_get_global(SS("_COOKIE") TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(_COOKIE, name));
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, delete){

	zval *name, *cookies, *cookie;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);
	
	PHALCON_OBS_VAR(cookies);
	phalcon_read_property_this(&cookies, this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset(cookies, name)) {
		PHALCON_OBS_VAR(cookie);
		phalcon_array_fetch(&cookie, cookies, name, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, cookie, "delete");
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, send){

	zval *cookies, *cookie = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	if (!SG(headers_sent)) {
	
		PHALCON_OBS_VAR(cookies);
		phalcon_read_property_this(&cookies, this_ptr, SL("_cookies"), PH_NOISY TSRMLS_CC);
	
		phalcon_is_iterable(cookies, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(cookie);
	
			PHALCON_CALL_METHOD(NULL, cookie, "send");
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Http_Response_Cookies, reset){

	zval *empty_array;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_cookies"), empty_array, 4109914289UL TSRMLS_CC);
	RETURN_THIS();
}





zend_class_entry *phalcon_http_response_cookiesinterface_ce;

static const zend_function_entry phalcon_http_response_cookiesinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, useEncryption, arginfo_phalcon_http_response_cookiesinterface_useencryption)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, isUsingEncryption, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, set, arginfo_phalcon_http_response_cookiesinterface_set)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, get, arginfo_phalcon_http_response_cookiesinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, has, arginfo_phalcon_http_response_cookiesinterface_has)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, delete, arginfo_phalcon_http_response_cookiesinterface_delete)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, send, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_CookiesInterface, reset, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Response_CookiesInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http\\Response, CookiesInterface, http_response_cookiesinterface, phalcon_http_response_cookiesinterface_method_entry);

	return SUCCESS;
}














zend_class_entry *phalcon_http_response_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Http_Response_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Http\\Response, Exception, http_response_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}




#include <main/SAPI.h>


zend_class_entry *phalcon_http_response_headers_ce;

static PHP_METHOD(Phalcon_Http_Response_Headers, set);
static PHP_METHOD(Phalcon_Http_Response_Headers, get);
static PHP_METHOD(Phalcon_Http_Response_Headers, setRaw);
static PHP_METHOD(Phalcon_Http_Response_Headers, remove);
static PHP_METHOD(Phalcon_Http_Response_Headers, send);
static PHP_METHOD(Phalcon_Http_Response_Headers, reset);
static PHP_METHOD(Phalcon_Http_Response_Headers, toArray);
static PHP_METHOD(Phalcon_Http_Response_Headers, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_http_response_headers___set_state, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_http_response_headers_method_entry[] = {
	PHP_ME(Phalcon_Http_Response_Headers, set, arginfo_phalcon_http_response_headersinterface_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, get, arginfo_phalcon_http_response_headersinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, setRaw, arginfo_phalcon_http_response_headersinterface_setraw, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, remove, arginfo_phalcon_http_response_headersinterface_remove, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, send, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, reset, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, toArray, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Http_Response_Headers, __set_state, arginfo_phalcon_http_response_headers___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Response_Headers){

	PHALCON_REGISTER_CLASS(Phalcon\\Http\\Response, Headers, http_response_headers, phalcon_http_response_headers_method_entry, 0);

	zend_declare_property_null(phalcon_http_response_headers_ce, SL("_headers"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_http_response_headers_ce TSRMLS_CC, 1, phalcon_http_response_headersinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Http_Response_Headers, set){

	zval *name, *value;

	phalcon_fetch_params(0, 2, 0, &name, &value);
	
	phalcon_update_property_array(this_ptr, SL("_headers"), name, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Http_Response_Headers, get){

	zval *name, *headers, *header_value;

	phalcon_fetch_params(0, 1, 0, &name);
	
	headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&header_value, headers, name)) {
		RETURN_ZVAL(header_value, 1, 0);
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Http_Response_Headers, setRaw){

	zval *header;

	phalcon_fetch_params(0, 1, 0, &header);
	
	phalcon_update_property_array(this_ptr, SL("_headers"), header, PHALCON_GLOBAL(z_null) TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Response_Headers, remove){

	zval *header_index, *headers;

	phalcon_fetch_params(0, 1, 0, &header_index);

	headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);

	phalcon_array_unset(&headers, header_index, 0);

	phalcon_update_property_this_quick(this_ptr, SL("_headers"), headers, 1867660032UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Http_Response_Headers, send){

	sapi_header_line ctr = { NULL, 0, 0 };

	if (!SG(headers_sent)) {
		zval *headers = phalcon_fetch_nproperty_this(this_ptr, SL("_headers"), PH_NOISY TSRMLS_CC);
		zval **value;
		HashPosition hp0;

		if (Z_TYPE_P(headers) != IS_ARRAY) {
			/* No headers to send */
			RETURN_TRUE;
		}
	
		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(headers), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(headers), (void**)&value, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(headers), &hp0)
		) {
			zval header = phalcon_get_current_key_w(Z_ARRVAL_P(headers), &hp0);

			if (PHALCON_IS_NOT_EMPTY(*value)) {
				zval *http_header;
				
				MAKE_STD_ZVAL(http_header);
				PHALCON_CONCAT_VSV(http_header, &header, ": ", *value);
				ctr.line     = Z_STRVAL_P(http_header);
				ctr.line_len = Z_STRLEN_P(http_header);
				sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
				zval_ptr_dtor(&http_header);
			}
			else if (Z_TYPE(header) == IS_STRING) {
				ctr.line     = Z_STRVAL(header);
				ctr.line_len = Z_STRLEN(header);
				sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
			}
			else {
				zval *tmp, *pheader = &header;

				MAKE_STD_ZVAL(tmp);
				ZVAL_ZVAL(tmp, pheader, 1, 0);
				convert_to_string(tmp);

				ctr.line     = Z_STRVAL_P(tmp);
				ctr.line_len = Z_STRLEN_P(tmp);
				sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);

				zval_ptr_dtor(&tmp);
			}
		}
	
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Http_Response_Headers, reset){

	zval *empty_array;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_headers"), empty_array, 1867660032UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Http_Response_Headers, toArray){


	RETURN_MEMBER_QUICK(this_ptr, "_headers", 1867660032UL);
}

static PHP_METHOD(Phalcon_Http_Response_Headers, __set_state){

	zval *data, *headers, *data_headers, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	PHALCON_INIT_VAR(headers);
	object_init_ex(headers, phalcon_http_response_headers_ce);
	if (phalcon_array_isset_quick_string(data, SS("_headers"), 1867660032UL)) {
	
		PHALCON_OBS_VAR(data_headers);
		phalcon_array_fetch_quick_string(&data_headers, data, SS("_headers"), 1867660032UL, PH_NOISY);
	
		phalcon_is_iterable(data_headers, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);
	
			PHALCON_CALL_METHOD(NULL, headers, "set", key, value);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_CTOR(headers);
}





zend_class_entry *phalcon_http_response_headersinterface_ce;

static const zend_function_entry phalcon_http_response_headersinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, set, arginfo_phalcon_http_response_headersinterface_set)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, get, arginfo_phalcon_http_response_headersinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, setRaw, arginfo_phalcon_http_response_headersinterface_setraw)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, send, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, reset, NULL)
	PHP_ABSTRACT_ME(Phalcon_Http_Response_HeadersInterface, toArray, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Http_Response_HeadersInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Http\\Response, HeadersInterface, http_response_headersinterface, phalcon_http_response_headersinterface_method_entry);

	return SUCCESS;
}










#include <ext/standard/php_math.h>



zend_class_entry *phalcon_image_adapter_ce;

static PHP_METHOD(Phalcon_Image_Adapter, getRealPath);
static PHP_METHOD(Phalcon_Image_Adapter, getWidth);
static PHP_METHOD(Phalcon_Image_Adapter, getHeight);
static PHP_METHOD(Phalcon_Image_Adapter, getType);
static PHP_METHOD(Phalcon_Image_Adapter, getMime);
static PHP_METHOD(Phalcon_Image_Adapter, getImage);
static PHP_METHOD(Phalcon_Image_Adapter, resize);
static PHP_METHOD(Phalcon_Image_Adapter, liquidRescale);
static PHP_METHOD(Phalcon_Image_Adapter, crop);
static PHP_METHOD(Phalcon_Image_Adapter, rotate);
static PHP_METHOD(Phalcon_Image_Adapter, flip);
static PHP_METHOD(Phalcon_Image_Adapter, sharpen);
static PHP_METHOD(Phalcon_Image_Adapter, reflection);
static PHP_METHOD(Phalcon_Image_Adapter, watermark);
static PHP_METHOD(Phalcon_Image_Adapter, text);
static PHP_METHOD(Phalcon_Image_Adapter, mask);
static PHP_METHOD(Phalcon_Image_Adapter, background);
static PHP_METHOD(Phalcon_Image_Adapter, blur);
static PHP_METHOD(Phalcon_Image_Adapter, pixelate);
static PHP_METHOD(Phalcon_Image_Adapter, save);
static PHP_METHOD(Phalcon_Image_Adapter, render);

static const zend_function_entry phalcon_image_adapter_method_entry[] = {
	PHP_ME(Phalcon_Image_Adapter, getRealPath,    arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, getWidth,       arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, getHeight,      arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, getType,        arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, getMime,        arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, getImage,       arginfo_empty, ZEND_ACC_PUBLIC)

	PHP_ME(Phalcon_Image_Adapter, resize,         arginfo_phalcon_image_adapterinterface_resize,        ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, liquidRescale,  arginfo_phalcon_image_adapterinterface_liquidrescale, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, crop,           arginfo_phalcon_image_adapterinterface_crop,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, rotate,         arginfo_phalcon_image_adapterinterface_rotate,        ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, flip,           arginfo_phalcon_image_adapterinterface_flip,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, sharpen,        arginfo_phalcon_image_adapterinterface_sharpen,       ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, reflection,     arginfo_phalcon_image_adapterinterface_reflection,    ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, watermark,      arginfo_phalcon_image_adapterinterface_watermark,     ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, text,           arginfo_phalcon_image_adapterinterface_text,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, mask,           arginfo_phalcon_image_adapterinterface_mask,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, background,     arginfo_phalcon_image_adapterinterface_background,    ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, blur,           arginfo_phalcon_image_adapterinterface_blur,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, pixelate,       arginfo_phalcon_image_adapterinterface_pixelate,      ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, save,           arginfo_phalcon_image_adapterinterface_save,          ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter, render,         arginfo_phalcon_image_adapterinterface_render,        ZEND_ACC_PUBLIC)

	ZEND_FENTRY(_resize,          NULL,           arginfo_phalcon_image_adapter__resize,        ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_liquidRescale,   NULL,           arginfo_phalcon_image_adapter__liquidrescale, ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_crop,            NULL,           arginfo_phalcon_image_adapter__crop,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_rotate,          NULL,           arginfo_phalcon_image_adapter__rotate,        ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_flip,            NULL,           arginfo_phalcon_image_adapter__flip,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_sharpen,         NULL,           arginfo_phalcon_image_adapter__sharpen,       ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_reflection,      NULL,           arginfo_phalcon_image_adapter__reflection,    ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_watermark,       NULL,           arginfo_phalcon_image_adapter__watermark,     ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_text,            NULL,           arginfo_phalcon_image_adapter__text,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_mask,            NULL,           arginfo_phalcon_image_adapter__mask,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_background,      NULL,           arginfo_phalcon_image_adapter__background,    ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_blur,            NULL,           arginfo_phalcon_image_adapter__blur,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_pixelate,        NULL,           arginfo_phalcon_image_adapter__pixelate,      ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_save,            NULL,           arginfo_phalcon_image_adapter__save,          ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	ZEND_FENTRY(_render,          NULL,           arginfo_phalcon_image_adapter__render,        ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)

	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Image_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Image, Adapter, image_adapter, phalcon_image_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_image_adapter_ce, SL("_image"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_checked"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_file"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_realpath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_width"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_height"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_ce, SL("_mime"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_image_adapter_ce TSRMLS_CC, 1, phalcon_image_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Image_Adapter, getRealPath){


	RETURN_MEMBER_QUICK(this_ptr, "_realpath", 4192016085UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, getWidth){


	RETURN_MEMBER_QUICK(this_ptr, "_width", 2983651716UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, getHeight){


	RETURN_MEMBER_QUICK(this_ptr, "_height", 1628000445UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, getMime){


	RETURN_MEMBER_QUICK(this_ptr, "_mime", 3983079404UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, getImage){


	RETURN_MEMBER_QUICK(this_ptr, "_image", 2440377831UL);
}

static PHP_METHOD(Phalcon_Image_Adapter, resize){

	zval *width = NULL, *height = NULL, *zmaster = NULL;
	zval *image_width, *image_height;
	long tmp_image_width, tmp_image_height, tmp_width = 0, tmp_height = 0, master;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 3, &width, &height, &zmaster);

	if (!zmaster) {
		master = PHALCON_IMAGE_AUTO;
	} else {
		master = phalcon_get_intval(zmaster);
	}

	if (width) {
		PHALCON_SEPARATE_PARAM(width);
		if (Z_TYPE_P(width) != IS_LONG && Z_TYPE_P(width) != IS_NULL) {
			convert_to_long(width);
		}
	}

	if (height) {
		PHALCON_SEPARATE_PARAM(height);
		if (Z_TYPE_P(height) != IS_LONG && Z_TYPE_P(height) != IS_NULL) {
			convert_to_long(height);
		}
	}

	if (PHALCON_IMAGE_TENSILE == master) {
		if (!width || !height) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "width and height parameters must be specified");
			return;
		}
	} else {
		if (!width) {
			PHALCON_INIT_VAR(width);
		}

		if (!height) {
			PHALCON_INIT_VAR(height);
		}

		image_width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
		image_height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

		tmp_image_width  = phalcon_get_intval(image_width);
		tmp_image_height = phalcon_get_intval(image_height);

		if ((master == PHALCON_IMAGE_WIDTH && Z_TYPE_P(width) == IS_LONG) || (master == PHALCON_IMAGE_HEIGHT && Z_TYPE_P(height) == IS_LONG)) {
			master = PHALCON_IMAGE_AUTO;
		}

		if (Z_TYPE_P(width) != IS_LONG) {
			if (master == PHALCON_IMAGE_NONE) {
				tmp_width = tmp_image_width;
			} else {
				master = PHALCON_IMAGE_HEIGHT;
			}
		} else {
			tmp_width = Z_LVAL_P(width);
		}

		if (Z_TYPE_P(height) != IS_LONG) {
			if (master == PHALCON_IMAGE_NONE) {
				tmp_height = tmp_image_height;
			} else {
				master = PHALCON_IMAGE_WIDTH;
			}
		} else {
			tmp_height = Z_LVAL_P(height);
		}

		if (tmp_width <= 0) {
			tmp_width = 1;
		}

		if (tmp_height <= 0) {
			tmp_height = 1;
		}

		switch (master) {
			case PHALCON_IMAGE_AUTO:
				if ((tmp_image_width / tmp_width) > (tmp_image_height / tmp_height)) {
					master = PHALCON_IMAGE_WIDTH;
				} else {
					master = PHALCON_IMAGE_HEIGHT;
				}
				break;

			case PHALCON_IMAGE_INVERSE:
				if ((tmp_image_width / tmp_width) > (tmp_image_height / tmp_height)) {
					master = PHALCON_IMAGE_HEIGHT;
				} else {
					master = PHALCON_IMAGE_WIDTH;
				}
				break;
		}

		if (tmp_image_width <= 0) {
			tmp_image_width = 1;
		}

		if (tmp_image_height <= 0) {
			tmp_image_height = 1;
		}

		switch (master) {
			case PHALCON_IMAGE_WIDTH:
				tmp_height = (int)((tmp_image_height * tmp_width / tmp_image_width) + 0.5);
				break;

			case PHALCON_IMAGE_HEIGHT:
				tmp_width = (int)((tmp_image_width * tmp_height / tmp_image_height) + 0.5);
				break;

			case PHALCON_IMAGE_PRECISE:
				if ((tmp_width / tmp_height) > (tmp_image_width / tmp_image_height)) {
					tmp_height = (int)((tmp_image_height * tmp_width / tmp_image_width) + 0.5);
				} else {
					tmp_width = (int)((tmp_image_width * tmp_height / tmp_image_height) + 0.5);
				}
				break;
		}

		if (tmp_width <= 0) {
			tmp_width = 1;
		}

		if (tmp_height <= 0) {
			tmp_height = 1;
		}

		PHALCON_INIT_NVAR(width);
		ZVAL_LONG(width, tmp_width);

		PHALCON_INIT_NVAR(height);
		ZVAL_LONG(height, tmp_height);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_resize", width, height);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, liquidRescale){

	zval **width, **height, **delta_x = NULL, **rigidity = NULL;

	phalcon_fetch_params_ex(2, 2, &width, &height, &delta_x, &rigidity);

	PHALCON_ENSURE_IS_LONG(width);
	PHALCON_ENSURE_IS_LONG(height);

	PHALCON_MM_GROW();

	if (!delta_x) {
		delta_x = &PHALCON_GLOBAL(z_zero);
	} else {
		PHALCON_ENSURE_IS_LONG(delta_x);
	}

	if (!rigidity) {
		rigidity = &PHALCON_GLOBAL(z_zero);
	} else {
		PHALCON_ENSURE_IS_LONG(rigidity);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_liquidrescale", *width, *height, *delta_x, *rigidity);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, crop){

	zval **w, **h, **ofs_x = NULL, **ofs_y = NULL;
	zval *image_width, *image_height;
	zval *width, *height, *offset_x, *offset_y;
	long tmp_max_width, tmp_max_height, tmp_width, tmp_height, tmp_image_width, tmp_image_height, tmp_offset_x, tmp_offset_y;

	phalcon_fetch_params_ex(2, 2, &w, &h, &ofs_x, &ofs_y);

	PHALCON_ENSURE_IS_LONG(w);
	PHALCON_ENSURE_IS_LONG(h);

	PHALCON_MM_GROW();

	image_width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	image_height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	SEPARATE_ZVAL_IF_NOT_REF(w);
	if (Z_TYPE_PP(w) != IS_LONG) {
		convert_to_long(*w);
	}

	SEPARATE_ZVAL_IF_NOT_REF(h);
	if (Z_TYPE_PP(h) != IS_LONG) {
		convert_to_long(*h);
	}

	if (ofs_x && Z_TYPE_PP(ofs_x) != IS_NULL && Z_TYPE_PP(ofs_x) != IS_BOOL && Z_TYPE_PP(ofs_x) != IS_LONG) {
		SEPARATE_ZVAL_IF_NOT_REF(ofs_x);
		convert_to_long(*ofs_x);
	}
		
	if (ofs_y && Z_TYPE_PP(ofs_y) != IS_NULL && Z_TYPE_PP(ofs_y) != IS_BOOL && Z_TYPE_PP(ofs_x) != IS_LONG) {
		SEPARATE_ZVAL_IF_NOT_REF(ofs_y);
		convert_to_long(*ofs_y);
	}

	tmp_width        = Z_LVAL_PP(w);
	tmp_height       = Z_LVAL_PP(h);
	tmp_image_width  = phalcon_get_intval(image_width);
	tmp_image_height = phalcon_get_intval(image_height);

	if (tmp_width > tmp_image_width) {
		tmp_width = tmp_image_width;
	}

	if (tmp_height > tmp_image_height) {
		tmp_height = tmp_image_height;
	}

	if (!ofs_x) {
		tmp_offset_x = (int)(((tmp_image_width - tmp_width) / 2) + 0.5);
	} else if (Z_TYPE_PP(ofs_x) == IS_BOOL && PHALCON_IS_TRUE(*ofs_x)) {
		tmp_offset_x = tmp_image_width - tmp_width;
	} else if (Z_TYPE_PP(ofs_x) == IS_LONG) {
		if (Z_LVAL_PP(ofs_x) < 0) {
			tmp_offset_x = (int)(tmp_image_width - tmp_width + Z_LVAL_PP(ofs_x) + 0.5);
		} else {
			tmp_offset_x = Z_LVAL_PP(ofs_x);
		}
	} else {
		tmp_offset_x = (int)(((tmp_image_width - tmp_width) / 2) + 0.5);
	}

	if (!ofs_y) {
		tmp_offset_y = (int)(((tmp_image_height - tmp_height) / 2) + 0.5);
	} else if (Z_TYPE_PP(ofs_x) == IS_BOOL && PHALCON_IS_TRUE(*ofs_y)) {
		tmp_offset_y = tmp_image_height - tmp_height;
	} else if (Z_TYPE_PP(ofs_y) == IS_LONG) {
		if (Z_LVAL_PP(ofs_y) < 0) {
			tmp_offset_y = tmp_image_height - tmp_height + Z_LVAL_PP(ofs_y);
		} else {
			tmp_offset_y = Z_LVAL_PP(ofs_y);
		}
	} else {
		tmp_offset_y = (int)(((tmp_image_height - tmp_height) / 2) + 0.5);
	}

	tmp_max_width  = tmp_image_width  - tmp_offset_x;
	tmp_max_height = tmp_image_height - tmp_offset_y;

	if (tmp_width > tmp_max_width) {
		tmp_width = tmp_max_width;
	}

	if (tmp_height > tmp_max_height) {
		tmp_height = tmp_max_height;
	}

	PHALCON_ALLOC_GHOST_ZVAL(width);
	PHALCON_ALLOC_GHOST_ZVAL(height);
	PHALCON_ALLOC_GHOST_ZVAL(offset_x);
	PHALCON_ALLOC_GHOST_ZVAL(offset_y);

	ZVAL_LONG(width,    tmp_width);
	ZVAL_LONG(height,   tmp_height);
	ZVAL_LONG(offset_x, tmp_offset_x);
	ZVAL_LONG(offset_y, tmp_offset_y);

	PHALCON_CALL_METHOD(NULL, this_ptr, "_crop", width, height, offset_x, offset_y);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, rotate){

	zval **degrees, *d;
	long tmp_degrees;

	phalcon_fetch_params_ex(1, 0, &degrees);

	PHALCON_ENSURE_IS_LONG(degrees);

	PHALCON_MM_GROW();

	tmp_degrees = Z_LVAL_PP(degrees);

	if (tmp_degrees > 180) {
		tmp_degrees %= 360;
		if (tmp_degrees > 180) {
			tmp_degrees -= 360;
		};
	} else if (tmp_degrees < -180) {
		do {
			tmp_degrees += 360;
		} while (tmp_degrees < -180);
	}

	PHALCON_ALLOC_GHOST_ZVAL(d);
	ZVAL_LONG(d, tmp_degrees);
	PHALCON_CALL_METHOD(NULL, this_ptr, "_rotate", d);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, flip){

	zval **direction, *dir;

	phalcon_fetch_params_ex(1, 0, &direction);
	PHALCON_ENSURE_IS_LONG(direction);

	PHALCON_MM_GROW();

	PHALCON_ALLOC_GHOST_ZVAL(dir);
	ZVAL_LONG(dir, (Z_LVAL_PP(direction) != 11) ? 12 : 11);

	PHALCON_CALL_METHOD(NULL, this_ptr, "_flip", dir);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, sharpen){

	zval **amount;

	phalcon_fetch_params_ex(1, 0, &amount);

	PHALCON_MM_GROW();

	SEPARATE_ZVAL_IF_NOT_REF(amount);
	if (Z_TYPE_PP(amount) != IS_LONG) {
		convert_to_long(*amount);
	}

	if (Z_LVAL_PP(amount) > 100) {
		ZVAL_LONG(*amount, 100);
	} else if (Z_LVAL_PP(amount) < 1) {
		ZVAL_LONG(*amount, 1);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_sharpen", *amount);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, reflection){

	zval **h = NULL, **op = NULL, **fade_in = NULL;
	zval *image_height, *height = NULL, *opacity = NULL;
	long tmp_image_height;

	phalcon_fetch_params_ex(0, 3, &h, &op, &fade_in);

	PHALCON_MM_GROW();

	image_height     = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);
	tmp_image_height = phalcon_get_intval(image_height);

	if (!h || Z_TYPE_PP(h) != IS_LONG || Z_LVAL_PP(h) > tmp_image_height) {
		PHALCON_INIT_VAR(height);
		ZVAL_LONG(height, tmp_image_height);
	} else {
		PHALCON_CPY_WRT_CTOR(height, *h);
	}

	if (!op) {
		PHALCON_INIT_VAR(opacity);
		ZVAL_LONG(opacity, 100);
	} else {
		PHALCON_ENSURE_IS_LONG(op);

		if (Z_LVAL_PP(op) > 100) {
			PHALCON_INIT_VAR(opacity);
			ZVAL_LONG(opacity, 100);
		} else if (Z_LVAL_PP(op) < 0) {
			PHALCON_INIT_VAR(opacity);
			ZVAL_LONG(opacity, 0);
		} else {
			PHALCON_CPY_WRT_CTOR(opacity, *op);
		}
	}

	if (!fade_in) {
		fade_in = &PHALCON_GLOBAL(z_false);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_reflection", height, opacity, *fade_in);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, watermark){

	zval **watermark, **ofs_x = NULL, **ofs_y = NULL, **op = NULL;
	zval *offset_x, *offset_y, *opacity;
	zval *image_width, *image_height, *watermark_width, *watermark_height;
	long tmp_image_width, tmp_image_height, tmp_watermark_width, tmp_watermark_height, tmp_offset_x, tmp_offset_y;

	phalcon_fetch_params_ex(1, 3, &watermark, &ofs_x, &ofs_y, &op);
	PHALCON_VERIFY_INTERFACE_EX(*watermark, phalcon_image_adapterinterface_ce, phalcon_image_exception_ce, 0);

	PHALCON_MM_GROW();

	image_width      = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	image_height     = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);
	watermark_width  = phalcon_fetch_nproperty_this(*watermark, SL("_width"), PH_NOISY TSRMLS_CC);
	watermark_height = phalcon_fetch_nproperty_this(*watermark, SL("_height"), PH_NOISY TSRMLS_CC);

	tmp_image_width      = phalcon_get_intval(image_width);
	tmp_image_height     = phalcon_get_intval(image_height);
	tmp_watermark_width  = phalcon_get_intval(watermark_width);
	tmp_watermark_height = phalcon_get_intval(watermark_height);

	if (!ofs_x) {
		tmp_offset_x = (int)(((tmp_image_width - tmp_watermark_width) / 2) + 0.5);
	} else if (Z_TYPE_PP(ofs_x) == IS_LONG) {
		tmp_offset_x = Z_LVAL_PP(ofs_x);
		if (tmp_offset_x < 0) {
			tmp_offset_x = (int)(tmp_image_width - tmp_watermark_width + tmp_offset_x + 0.5);
		}
	} else if (zend_is_true(*ofs_x)) {
		tmp_offset_x = (int)(tmp_image_width - tmp_watermark_width);
	} else {
		tmp_offset_x = (int)(((tmp_image_width - tmp_watermark_width) / 2) + 0.5);
	}

	PHALCON_INIT_VAR(offset_x);
	ZVAL_LONG(offset_x, tmp_offset_x);

	if (!ofs_y) {
		tmp_offset_y = (int)(((tmp_image_height - tmp_watermark_height) / 2) + 0.5);
	} else if (Z_TYPE_PP(ofs_y) == IS_LONG) {
		tmp_offset_y = Z_LVAL_PP(ofs_y);
		if (tmp_offset_y < 0) {
			tmp_offset_y = (int)(tmp_image_height - tmp_watermark_height + tmp_offset_y + 0.5);
		}
	} else if (zend_is_true(*ofs_y)) {
		tmp_offset_y = (int)(tmp_image_height - tmp_watermark_height);
	} else {
		tmp_offset_y = (int)(((tmp_image_height - tmp_watermark_height) / 2) + 0.5);
	}

	PHALCON_INIT_VAR(offset_y);
	ZVAL_LONG(offset_y, tmp_offset_y);

	PHALCON_INIT_VAR(opacity);
	if (!op) {
		ZVAL_LONG(opacity, 100);
	} else {
		PHALCON_ENSURE_IS_LONG(op);

		if (Z_LVAL_PP(op) < 1) {
			ZVAL_LONG(opacity, 1);
		} else if (Z_LVAL_PP(op) > 100) {
			ZVAL_LONG(opacity, 100);
		} else {
			ZVAL_LONG(opacity, Z_LVAL_PP(op));
		}
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_watermark", *watermark, offset_x, offset_y, opacity);

	RETURN_THIS();
}


static PHP_METHOD(Phalcon_Image_Adapter, text){

	zval **text, **ofs_x = NULL, **ofs_y = NULL, **op = NULL, **fontcolor = NULL, **fontsize = NULL, **fontfile = NULL;
	zval *offset_x = NULL, *offset_y = NULL, *opacity, *color, *size;
	zval *r, *g, *b;
	char *c;
	zval tmp;

	phalcon_fetch_params_ex(1, 6, &text, &ofs_x, &ofs_y, &op, &fontcolor, &fontsize, &fontfile);

	PHALCON_MM_GROW();

	if (!ofs_x || Z_TYPE_PP(ofs_x) == IS_NULL) {
		PHALCON_INIT_VAR(offset_x);
		ZVAL_FALSE(offset_x);
	}
	else {
		PHALCON_CPY_WRT_CTOR(offset_x, *ofs_x);
	}

	if (!ofs_y || Z_TYPE_PP(ofs_y) == IS_NULL) {
		PHALCON_INIT_VAR(offset_y);
		ZVAL_FALSE(offset_y);
	}
	else {
		PHALCON_CPY_WRT_CTOR(offset_y, *ofs_y);
	}

	PHALCON_INIT_VAR(opacity);
	if (!op || Z_TYPE_PP(op) == IS_NULL) {
		ZVAL_LONG(opacity, 100);
	} else {
		PHALCON_ENSURE_IS_LONG(op);
		if (Z_LVAL_PP(op) < 1) {
			ZVAL_LONG(opacity, 1);
		} else if (Z_LVAL_PP(op) > 100) {
			ZVAL_LONG(opacity, 100);
		} else {
			ZVAL_LONG(opacity, Z_LVAL_PP(op));
		}
	}

	PHALCON_INIT_VAR(color);
	if (!fontcolor || Z_TYPE_PP(fontcolor) == IS_NULL) {
		ZVAL_STRING(color, "000000", 1);
	}
	else {
		PHALCON_ENSURE_IS_STRING(fontcolor);
		if (Z_STRLEN_PP(fontcolor) > 1 && Z_STRVAL_PP(fontcolor)[0] == '#') {
			phalcon_substr(color, *fontcolor, 1, 0);
		}
		else {
			ZVAL_STRINGL(color, Z_STRVAL_PP(fontcolor), Z_STRLEN_PP(fontcolor), 1);
		}
	}

	PHALCON_INIT_VAR(size);
	if (!fontsize || Z_TYPE_PP(fontsize) == IS_NULL) {
		ZVAL_LONG(size, 12);
	}
	else {
		PHALCON_ENSURE_IS_LONG(fontsize);
		ZVAL_LONG(size, Z_LVAL_PP(fontsize));
	}

	if (!fontfile) {
		fontfile = &PHALCON_GLOBAL(z_null);
	}

	if (Z_STRLEN_P(color) == 3) {
		/* Convert RGB to RRGGBB */
		c = Z_STRVAL_P(color);
		assert(!IS_INTERNED(c));
		STR_REALLOC(c, 7);
		c[6] = '\0';
		c[5] = c[2];
		c[4] = c[2];
		c[3] = c[1];
		c[2] = c[1];
		c[1] = c[0];
		ZVAL_STRING(color, c, 0);
	}

	if (Z_STRLEN_P(color) < 6) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "color is not valid");
		return;
	}

	INIT_ZVAL(tmp);

	Z_TYPE(tmp) = IS_STRING;
	ZVAL_STRINGL(&tmp, Z_STRVAL_P(color), 2, 0);

	PHALCON_INIT_VAR(r);
	_php_math_basetozval(&tmp, 16, r);

	Z_STRVAL(tmp) += 2;
	PHALCON_INIT_VAR(g);
	_php_math_basetozval(&tmp, 16, g);

	Z_STRVAL(tmp) += 2;
	PHALCON_INIT_VAR(b);
	_php_math_basetozval(&tmp, 16, b);

	PHALCON_CALL_METHOD(NULL, this_ptr, "_text", *text, offset_x, offset_y, opacity, r, g, b, size, *fontfile);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, mask){

	zval *mask;

	phalcon_fetch_params(0, 1, 0, &mask);
	PHALCON_CALL_METHODW(NULL, this_ptr, "_mask", mask);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Image_Adapter, background){

	zval *color, *opacity = NULL;
	zval *tmp_color = NULL, *r = NULL, *g = NULL, *b = NULL;
	long i;
	char *c;
	zval tmp;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &color, &opacity);

	if (Z_TYPE_P(color) != IS_STRING) {
		PHALCON_SEPARATE_PARAM(color);
		convert_to_string(color);
	}

	c = Z_STRVAL_P(color);

	if (Z_STRLEN_P(color) > 0 && c[0] == '#') {
		PHALCON_INIT_NVAR(tmp_color);
		phalcon_substr(tmp_color, color, 1, 0);
	} else {
		PHALCON_CPY_WRT_CTOR(tmp_color, color);
	}

	if (Z_STRLEN_P(tmp_color) == 3) {
		/* Convert RGB to RRGGBB */
		c = Z_STRVAL_P(tmp_color);
		if (!IS_INTERNED(c)) {
			STR_REALLOC(c, 7);
		}
		else {
			char* tmp = ecalloc(7, 1);
			memcpy(tmp, c, Z_STRLEN_P(tmp_color));
			c = tmp;
		}

		c[6] = '\0';
		c[5] = c[2];
		c[4] = c[2];
		c[3] = c[1];
		c[2] = c[1];
		c[1] = c[0];
		ZVAL_STRING(tmp_color, c, 0);
	}

	if (Z_STRLEN_P(tmp_color) < 6) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Color is not valid");
		return;
	}

	INIT_ZVAL(tmp);

	Z_TYPE(tmp) = IS_STRING;
	ZVAL_STRINGL(&tmp, Z_STRVAL_P(tmp_color), 2, 0);

	PHALCON_INIT_NVAR(r);
	_php_math_basetozval(&tmp, 16, r);

	Z_STRVAL(tmp) += 2;
	PHALCON_INIT_NVAR(g);
	_php_math_basetozval(&tmp, 16, g);

	Z_STRVAL(tmp) += 2;
	PHALCON_INIT_NVAR(b);
	_php_math_basetozval(&tmp, 16, b);

	if (!opacity) {
		PHALCON_INIT_NVAR(opacity);
		ZVAL_LONG(opacity, 100);
	} else {
		PHALCON_SEPARATE_PARAM(opacity);

		i = phalcon_get_intval(opacity);

		if (i < 1) {
			PHALCON_INIT_NVAR(opacity);
			ZVAL_LONG(opacity, 1);
		} else if (i > 100) {
			PHALCON_INIT_NVAR(opacity);
			ZVAL_LONG(opacity, 100);
		}
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_background", r, g, b, opacity);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, blur){

	zval *radius = NULL;
	long r;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &radius);

	if (!radius) {
		PHALCON_INIT_VAR(radius);
		ZVAL_LONG(radius, 1);
	} else if (Z_TYPE_P(radius) != IS_LONG) {
		PHALCON_SEPARATE_PARAM(radius);

		PHALCON_INIT_NVAR(radius);
		ZVAL_LONG(radius, 1);
	} else {
		r = phalcon_get_intval(radius);
		if (r < 1) {
			PHALCON_SEPARATE_PARAM(radius);
			PHALCON_INIT_NVAR(radius);
			ZVAL_LONG(radius, 1);
		} else if (r > 100) {
			PHALCON_SEPARATE_PARAM(radius);
			PHALCON_INIT_NVAR(radius);
			ZVAL_LONG(radius, 100);
		}
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_blur", radius);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, pixelate){

	zval **amount = NULL, *amt;

	phalcon_fetch_params_ex(0, 1, &amount);

	PHALCON_MM_GROW();

	PHALCON_ALLOC_GHOST_ZVAL(amt);
	if (!amount || Z_TYPE_PP(amount) != IS_LONG) {
		ZVAL_LONG(amt, 10);
	} else {
		PHALCON_ENSURE_IS_LONG(amount);
		if (Z_LVAL_PP(amount) < 2) {
			ZVAL_LONG(amt, 2);
		} else {
			ZVAL_LONG(amt, Z_LVAL_PP(amount));
		}
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_pixelate", amt);

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Image_Adapter, save){

	zval **fname = NULL, **q = NULL;
	zval *file, *quality;
	zval *ret = NULL, *dir, *constant;

	phalcon_fetch_params_ex(0, 2, &fname, &q);

	PHALCON_MM_GROW();

	if (!fname) {
		PHALCON_OBS_VAR(file);
		phalcon_read_property_this(&file, this_ptr, SL("_realpath"), PH_NOISY TSRMLS_CC);
		convert_to_string_ex(&file);
	}
	else {
		PHALCON_ENSURE_IS_STRING(fname);
		file = *fname;
	}

	PHALCON_INIT_VAR(quality);
	if (!q || Z_TYPE_PP(q) != IS_LONG) {
		ZVAL_LONG(quality, 100);
	} else if (Z_LVAL_PP(q) > 100) {
		ZVAL_LONG(quality, 100);
	} else if (Z_LVAL_PP(q) < 1) {
		ZVAL_LONG(quality, 1);
	} else {
		ZVAL_LONG(quality, Z_LVAL_PP(q));
	}

	PHALCON_CALL_FUNCTION(&ret, "is_file", file);

	if (zend_is_true(ret)) {
		PHALCON_CALL_FUNCTION(&ret, "is_writable", file);
		if (!zend_is_true(ret)) {
			zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "File must be writable: '%s'", Z_STRVAL_P(file));
			RETURN_MM();
		}
	} else {
		PHALCON_INIT_VAR(constant);
		if (!zend_get_constant(SL("PATHINFO_DIRNAME"), constant TSRMLS_CC)) {
			RETURN_MM();
		}

		PHALCON_CALL_FUNCTION(&ret, "pathinfo", file, constant);

		PHALCON_INIT_VAR(dir);
		phalcon_realpath(dir, ret TSRMLS_CC);
		convert_to_string(dir);

		PHALCON_INIT_NVAR(ret);
		phalcon_is_dir(ret, dir TSRMLS_CC);

		if (!zend_is_true(ret)) {
			zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Directory must be writable: '%s'", Z_STRVAL_P(dir));
			RETURN_MM();
		}

		PHALCON_CALL_FUNCTION(&ret, "is_writable", dir);
		if (!zend_is_true(ret)) {
			zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Directory must be writable: '%s'", Z_STRVAL_P(dir));
			RETURN_MM();
		}
	}

	PHALCON_RETURN_CALL_METHOD(this_ptr, "_save", file, quality);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Image_Adapter, render){

	zval *ext = NULL, *quality = NULL, *constant, *file;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &ext, &quality);

	if (!ext) {
		file = phalcon_fetch_nproperty_this(this_ptr, SL("_file"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(constant);
		if (!zend_get_constant(SL("PATHINFO_EXTENSION"), constant TSRMLS_CC)) {
			RETURN_MM();
		}

		ext = NULL;
		PHALCON_CALL_FUNCTION(&ext, "pathinfo", file, constant);

		if (!PHALCON_IS_NOT_EMPTY(ext)) {
			ZVAL_STRING(ext, "png", 1);
		}
	}

	if (!quality) {
		PHALCON_INIT_VAR(quality);
		ZVAL_LONG(quality, 100);
	} else {
        if (Z_TYPE_P(quality) != IS_LONG) {
            PHALCON_SEPARATE_PARAM(quality);
            convert_to_long(quality);
        }
    }

	PHALCON_RETURN_CALL_METHOD(this_ptr, "_render", ext, quality);

	RETURN_MM();
}





zend_class_entry *phalcon_image_adapterinterface_ce;

static const zend_function_entry phalcon_image_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, resize,        arginfo_phalcon_image_adapterinterface_resize)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, liquidRescale, arginfo_phalcon_image_adapterinterface_liquidrescale)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, crop,          arginfo_phalcon_image_adapterinterface_crop)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, rotate,        arginfo_phalcon_image_adapterinterface_rotate)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, flip,          arginfo_phalcon_image_adapterinterface_flip)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, sharpen,       arginfo_phalcon_image_adapterinterface_sharpen)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, reflection,    arginfo_phalcon_image_adapterinterface_reflection)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, watermark,     arginfo_phalcon_image_adapterinterface_watermark)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, text,          arginfo_phalcon_image_adapterinterface_text)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, mask,          arginfo_phalcon_image_adapterinterface_mask)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, background,    arginfo_phalcon_image_adapterinterface_background)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, blur,          arginfo_phalcon_image_adapterinterface_blur)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, pixelate,      arginfo_phalcon_image_adapterinterface_pixelate)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, save,          arginfo_phalcon_image_adapterinterface_save)
	PHP_ABSTRACT_ME(Phalcon_Image_AdapterInterface, render,        arginfo_phalcon_image_adapterinterface_render)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Image_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Image, AdapterInterface, image_adapterinterface, phalcon_image_adapterinterface_method_entry);

	return SUCCESS;
}















zend_class_entry *phalcon_image_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Image_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Image, Exception, image_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






#include <ext/standard/php_versioning.h>


zend_class_entry *phalcon_image_adapter_gd_ce;

static PHP_METHOD(Phalcon_Image_Adapter_GD, check);
static PHP_METHOD(Phalcon_Image_Adapter_GD, __construct);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _resize);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _liquidRescale);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _crop);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _rotate);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _flip);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _sharpen);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _reflection);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _watermark);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _text);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _mask);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _background);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _blur);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _pixelate);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _save);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _render);
static PHP_METHOD(Phalcon_Image_Adapter_GD, _create);
static PHP_METHOD(Phalcon_Image_Adapter_GD, __destruct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_image_adapter_gd___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, file)
	ZEND_ARG_INFO(0, width)
	ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_image_adapter_gd__create, 0, 0, 2)
	ZEND_ARG_INFO(0, width)
	ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_image_adapter_gd_method_entry[] = {
	PHP_ME(Phalcon_Image_Adapter_GD, check, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Image_Adapter_GD, __construct, arginfo_phalcon_image_adapter_gd___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Image_Adapter_GD, _resize, arginfo_phalcon_image_adapter__resize, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _liquidRescale, arginfo_phalcon_image_adapter__liquidrescale, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _crop, arginfo_phalcon_image_adapter__crop, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _rotate, arginfo_phalcon_image_adapter__rotate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _flip, arginfo_phalcon_image_adapter__flip, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _sharpen, arginfo_phalcon_image_adapter__sharpen, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _reflection, arginfo_phalcon_image_adapter__reflection, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _watermark, arginfo_phalcon_image_adapter__watermark, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _text, arginfo_phalcon_image_adapter__text, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _mask, arginfo_phalcon_image_adapter__mask, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _background, arginfo_phalcon_image_adapter__background, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _blur, arginfo_phalcon_image_adapter__blur, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _pixelate, arginfo_phalcon_image_adapter__pixelate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _save, arginfo_phalcon_image_adapter__save, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _render, arginfo_phalcon_image_adapter__render, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, _create, arginfo_phalcon_image_adapter_gd__create, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_GD, __destruct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Image_Adapter_GD){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Image\\Adapter, GD, image_adapter_gd, phalcon_image_adapter_ce,  phalcon_image_adapter_gd_method_entry, 0);

	zend_class_implements(phalcon_image_adapter_gd_ce TSRMLS_CC, 1, phalcon_image_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, check){

	zval *ret = NULL, *gd_info = NULL, *gd_version, *version, *exception_message;
	zval *pattern, *matches;
	int rc;

	PHALCON_MM_GROW();

	if (phalcon_function_quick_exists_ex(SS("gd_info"), 2167660155UL TSRMLS_CC) == FAILURE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "GD is either not installed or not enabled, check your configuration");
		return;
	}

	PHALCON_INIT_VAR(gd_version);
	if (!zend_get_constant(SL("GD_VERSION"), gd_version TSRMLS_CC)) {
		PHALCON_CALL_FUNCTION(&gd_info, "gd_info");

		if (phalcon_array_isset_string_fetch(&gd_version, gd_info, SS("GD Version"))) {

			PHALCON_INIT_VAR(matches);
		
			PHALCON_INIT_VAR(pattern);
			ZVAL_STRING(pattern, "#\\d+\\.\\d+(?:\\.\\d+)?#", 1);

			PHALCON_INIT_VAR(ret);
			RETURN_MM_ON_FAILURE(phalcon_preg_match(ret, pattern, gd_version, matches TSRMLS_CC));

			if (zend_is_true(ret)) {
				if (!phalcon_array_isset_long_fetch(&version, matches, 0)) {
					PHALCON_INIT_VAR(version);
					ZVAL_EMPTY_STRING(version);
				}
			} else {
				PHALCON_INIT_VAR(version);
				ZVAL_EMPTY_STRING(version);
			}
		}
		else {
			version = gd_version;
		}
	}

	rc = php_version_compare(Z_STRVAL_P(gd_version), "2.0.1");

	if (-1 == rc) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "Phalcon\\Image\\Adapter\\GD requires GD version '2.0.1' or greater, you have '", gd_version);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}

	PHALCON_INIT_NVAR(ret);
	ZVAL_TRUE(ret);
	phalcon_update_static_property_ce(phalcon_image_adapter_gd_ce, SL("_checked"), ret TSRMLS_CC);

	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, __construct){

	zval *file, *width = NULL, *height = NULL, *exception_message;
	zval *checked, *realpath, *type, *mime = NULL, *image = NULL, *imageinfo = NULL;
	zval *saveflag, *blendmode;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &file, &width, &height);

	if (Z_TYPE_P(file) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "file parameter should be a string");
		return;
	}

	checked = phalcon_fetch_static_property_ce(phalcon_image_adapter_gd_ce, SL("_checked") TSRMLS_CC);

	if (!zend_is_true(checked)) {
		PHALCON_CALL_CE_STATIC(NULL, phalcon_image_adapter_gd_ce, "check");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_file"), file, 3974776868UL TSRMLS_CC);

	if (phalcon_file_exists(file TSRMLS_CC) != FAILURE) {
		PHALCON_INIT_VAR(realpath);
		phalcon_realpath(realpath, file TSRMLS_CC);
		if (unlikely(Z_TYPE_P(realpath) != IS_STRING)) {
			convert_to_string(realpath);
		}

		phalcon_update_property_this_quick(this_ptr, SL("_realpath"), realpath, 4192016085UL TSRMLS_CC);

		PHALCON_CALL_FUNCTION(&imageinfo, "getimagesize", realpath);

		if (width) {
			PHALCON_SEPARATE_PARAM(width);
		}

		if (height) {
			PHALCON_SEPARATE_PARAM(height);
		}

		if (phalcon_array_isset_long_fetch(&width, imageinfo, 0)) {
			phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
		}

		if (phalcon_array_isset_long_fetch(&height, imageinfo, 1)) {
			phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
		}

		if (phalcon_array_isset_long_fetch(&type, imageinfo, 2)) {
			convert_to_long(type);
			phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
		}
		else {
			PHALCON_INIT_VAR(type);
			ZVAL_LONG(type, -1);
		}

		if (phalcon_array_isset_string_fetch(&mime, imageinfo, SS("mime"))) {
			convert_to_string(mime);
			phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);
		}

		assert(Z_TYPE_P(type) == IS_LONG);

		switch (Z_LVAL_P(type)) {
			case 1: // GIF
				PHALCON_CALL_FUNCTION(&image, "imagecreatefromgif", realpath);
				break;

			case 2: // JPEG
				PHALCON_CALL_FUNCTION(&image, "imagecreatefromjpeg", realpath);
				break;

			case 3: // PNG
				PHALCON_CALL_FUNCTION(&image, "imagecreatefrompng", realpath);
				break;

			default:
				if (mime) {
					assert(Z_TYPE_P(mime) == IS_STRING);
					zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Installed GD does not support '%s' images", Z_STRVAL_P(mime));
				}
				else {
					zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Installed GD does not support such images");
				}

				RETURN_MM();
		}

		if (Z_TYPE_P(image) != IS_RESOURCE) {
			assert(Z_TYPE_P(realpath) == IS_STRING);
			zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Failed to create image from file '%s'", Z_STRVAL_P(realpath));
			RETURN_MM();
		}

		PHALCON_INIT_VAR(saveflag);
		ZVAL_TRUE(saveflag);

		PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", image, saveflag);
	} else if (width && height) {
		PHALCON_CALL_FUNCTION(&image, "imagecreatetruecolor", width, height);

		if (Z_TYPE_P(image) != IS_RESOURCE) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "imagecreatetruecolor() failed");
			return;
		}

		PHALCON_INIT_VAR(blendmode);
		ZVAL_TRUE(blendmode);

		PHALCON_INIT_VAR(saveflag);
		ZVAL_TRUE(saveflag);

		PHALCON_CALL_FUNCTION(NULL, "imagealphablending", image, blendmode);
		PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", image, saveflag);
		
		phalcon_update_property_this_quick(this_ptr, SL("_realpath"), file, 4192016085UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);

		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 3);

		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_INIT_VAR(mime);
		ZVAL_STRING(mime, "image/png", 1);

		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Failed to create image from file '", file, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_image"), image, 2440377831UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _resize) {

	zval *width, *height;
	zval *image = NULL, *tmp_image = NULL;
	zval *ori_width, *ori_height, *pre_width, *pre_height, *reduction_width, *reduction_height, *ret = NULL, *dst;
	int tmp_width, tmp_height, tmp_pre_width, tmp_pre_height, tmp_reduction_width, tmp_reduction_height;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &width, &height);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (PHP_VERSION_ID < 50500) {
		ori_width      = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
		ori_height     = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

		tmp_width      = phalcon_get_intval(width);
		tmp_height     = phalcon_get_intval(height);

		tmp_pre_width  = phalcon_get_intval(ori_width);
		tmp_pre_height = phalcon_get_intval(ori_height);

		PHALCON_INIT_VAR(dst);
		ZVAL_LONG(dst, 0);

		if (tmp_width > (tmp_pre_width / 2) && tmp_height > (tmp_pre_height / 2)) {
			tmp_reduction_width = (int)(tmp_width*1.1 + 0.5);

			PHALCON_INIT_VAR(reduction_width);
			ZVAL_LONG(reduction_width, tmp_reduction_width);

			tmp_reduction_height = (int)(tmp_height*1.1 + 0.5);

			PHALCON_INIT_VAR(reduction_height);
			ZVAL_LONG(reduction_height, tmp_reduction_height);

			while ((tmp_pre_width / 2 > tmp_reduction_width) && (tmp_pre_height / 2 > tmp_reduction_height)) {
				tmp_pre_width = (int)(tmp_pre_width/2);
				tmp_pre_height = (int)(tmp_pre_height/2);
			}

			PHALCON_INIT_VAR(pre_width);
			ZVAL_LONG(pre_width, tmp_pre_width);

			PHALCON_INIT_VAR(pre_height);
			ZVAL_LONG(pre_height, tmp_pre_height);

			PHALCON_CALL_METHOD(&tmp_image, this_ptr, "_create", pre_width, pre_height);

			PHALCON_CALL_FUNCTION(&ret, "imagecopyresized", tmp_image, image, dst, dst, dst, dst, pre_width, pre_height, ori_width, ori_height);

			if (zend_is_true(ret)) {
				PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
				PHALCON_CPY_WRT_CTOR(image, tmp_image);
			}
		} else {
			PHALCON_INIT_VAR(pre_width);
			ZVAL_LONG(pre_width, tmp_pre_width);

			PHALCON_INIT_VAR(pre_height);
			ZVAL_LONG(pre_height, tmp_pre_height);
		}

		PHALCON_CALL_METHOD(&tmp_image, this_ptr, "_create", width, height);
		PHALCON_CALL_FUNCTION(&ret, "imagecopyresampled", tmp_image, image, dst, dst, dst, dst, width, height, pre_width, pre_height);

		if (zend_is_true(ret)) {
			PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
			phalcon_update_property_this_quick(this_ptr, SL("_image"), tmp_image, 2440377831UL TSRMLS_CC);

			phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
		}
	}
	else {
		PHALCON_CALL_FUNCTION(&tmp_image, "imagescale", image, width, height);

		if (Z_TYPE_P(tmp_image) == IS_RESOURCE) {
			PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
			phalcon_update_property_this_quick(this_ptr, SL("_image"), tmp_image, 2440377831UL TSRMLS_CC);

			phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _liquidRescale){

	zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "The GD does not support liquidRescale");
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _crop) {
	zval *width, *height, *offset_x, *offset_y;
	zval *image, *tmp_image = NULL;
	zval *dst, *ret = NULL;
	zval *rect;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &width, &height, &offset_x, &offset_y);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (PHP_VERSION_ID < 50500) {
		PHALCON_CALL_METHOD(&tmp_image, this_ptr, "_create", width, height);

		PHALCON_INIT_VAR(dst);
		ZVAL_LONG(dst, 0);

		PHALCON_CALL_FUNCTION(&ret, "imagecopyresampled", tmp_image, image, dst, dst, offset_x, offset_y, width, height, width, height);

		if (zend_is_true(ret)) {
			PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
			phalcon_update_property_this_quick(this_ptr, SL("_image"), tmp_image, 2440377831UL TSRMLS_CC);

			phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
		}
	}
	else {
		PHALCON_INIT_VAR(rect);
		array_init_size(rect, 4);
		phalcon_array_update_string(&rect, SL("x"), offset_x, PH_COPY);
		phalcon_array_update_string(&rect, SL("y"), offset_y, PH_COPY);
		phalcon_array_update_string(&rect, SL("width"), width, PH_COPY);
		phalcon_array_update_string(&rect, SL("height"), height, PH_COPY);

		PHALCON_CALL_FUNCTION(&tmp_image, "imagecrop", image, rect);

		if (Z_TYPE_P(tmp_image) == IS_RESOURCE) {
			PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
			phalcon_update_property_this_quick(this_ptr, SL("_image"), tmp_image, 2440377831UL TSRMLS_CC);

			phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _rotate) {

	zval *degrees;
	zval *image = NULL, *tmp_image = NULL, *color, *alpha, *transparent = NULL;
	zval *ignore_transparent, *saveflag;
	zval *w = NULL, *h = NULL;
	int tmp_degrees;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &degrees);

	PHALCON_SEPARATE_PARAM(degrees);

	PHALCON_INIT_VAR(color);
	ZVAL_LONG(color, 0);

	PHALCON_INIT_VAR(alpha);
	ZVAL_LONG(alpha, 127);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_FUNCTION(&transparent, "imagecolorallocatealpha", image, color, color, color, alpha);

	tmp_degrees = phalcon_get_intval(degrees);

	PHALCON_INIT_NVAR(degrees);
	ZVAL_LONG(degrees, 360 - tmp_degrees);

	PHALCON_INIT_VAR(ignore_transparent);
	ZVAL_LONG(ignore_transparent, 1);

	PHALCON_CALL_FUNCTION(&tmp_image, "imagerotate", image, degrees, transparent, ignore_transparent);

	PHALCON_INIT_VAR(saveflag);
	ZVAL_TRUE(saveflag);

	PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", tmp_image, saveflag);
	PHALCON_CALL_FUNCTION(&w, "imagesx", tmp_image);
	PHALCON_CALL_FUNCTION(&h, "imagesy", tmp_image);
	PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
	phalcon_update_property_this_quick(this_ptr, SL("_image"), tmp_image, 2440377831UL TSRMLS_CC);

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _flip) {

	zval *direction;
	zval *image = NULL;
	zval *flipped_image = NULL;
	zval *width, *height;
	zval *dst_x = NULL, *dst_y = NULL, *src_x = NULL, *src_y = NULL, *src_width = NULL, *src_height = NULL;
	int w, h, x, y;
	zval *mode;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &direction);

	image  = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (PHP_VERSION_ID < 50500) {
		width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
		height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

		PHALCON_CALL_METHOD(&flipped_image, this_ptr, "_create", width, height);

		w = Z_LVAL_P(width);
		h = Z_LVAL_P(height);

		if (Z_LVAL_P(direction) == PHALCON_IMAGE_HORIZONTAL) {
			PHALCON_INIT_NVAR(dst_y);
			ZVAL_LONG(dst_y, 0);

			PHALCON_INIT_NVAR(src_y);
			ZVAL_LONG(src_y, 0);

			PHALCON_INIT_NVAR(src_width);
			ZVAL_LONG(src_width, 1);

			PHALCON_INIT_NVAR(src_height);
			ZVAL_LONG(src_height, h);

			for (x = 0; x < w; x++)
			{
				PHALCON_INIT_NVAR(dst_x);
				ZVAL_LONG(dst_x, x);

				PHALCON_INIT_NVAR(src_x);
				ZVAL_LONG(src_x, w - x - 1);

				PHALCON_CALL_FUNCTION(NULL, "imagecopy", flipped_image, image, dst_x, dst_y, src_x, src_y, src_width, src_height);
			}
		} else {
			PHALCON_INIT_NVAR(dst_x);
			ZVAL_LONG(dst_x, 0);

			PHALCON_INIT_NVAR(src_x);
			ZVAL_LONG(src_x, 0);

			PHALCON_INIT_NVAR(src_width);
			ZVAL_LONG(src_width, w);

			PHALCON_INIT_NVAR(src_height);
			ZVAL_LONG(src_height, 1);

			for (y = 0; y < h; y++)
			{
				PHALCON_INIT_NVAR(dst_y);
				ZVAL_LONG(dst_y, y);

				PHALCON_INIT_NVAR(src_y);
				ZVAL_LONG(src_y, h - y - 1);

				PHALCON_CALL_FUNCTION(NULL, "imagecopy", flipped_image, image, dst_x, dst_y, src_x, src_y, src_width, src_height);
			}
		}

		PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
		phalcon_update_property_this_quick(this_ptr, SL("_image"), flipped_image, 2440377831UL TSRMLS_CC);
	}
	else {
		PHALCON_INIT_VAR(mode);
		if (Z_LVAL_P(direction) == PHALCON_IMAGE_HORIZONTAL) {
			if (!zend_get_constant(SL("IMG_FLIP_HORIZONTAL"), mode TSRMLS_CC)) {
				RETURN_MM();
			}
		} else {
			if (!zend_get_constant(SL("IMG_FLIP_VERTICAL"), mode TSRMLS_CC)) {
				RETURN_MM();
			}
		}

		PHALCON_CALL_FUNCTION(NULL, "imageflip", image, mode);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _sharpen) {

	zval *amount, *tmp = NULL, *tmp_amount = NULL, *matrix, *item = NULL;
	zval *image = NULL, *ret = NULL, *width = NULL, *height = NULL;
	int a;
	double b;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &amount);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	a = phalcon_get_intval(amount);

	if (a > 100) {
		a = 100;
	} else if (a < 1) {
		a = 1;
	}

	b = -18 + (a * 0.08);

	if (b < 0) {
		b = -b;
	}

	PHALCON_INIT_NVAR(tmp_amount);
	ZVAL_LONG(tmp_amount, (long int)(floor(a*100.0+0.5)/100));

	PHALCON_INIT_VAR(matrix);
	array_init_size(matrix, 3);

	/* 1 */
	PHALCON_INIT_NVAR(item);
	array_init_size(item, 3);

	phalcon_array_append_long(&item, -1, 0);
	phalcon_array_append_long(&item, -1, 0);
	phalcon_array_append_long(&item, -1, 0);

	phalcon_array_append(&matrix, item, 0);

	/* 2 */
	PHALCON_INIT_NVAR(item);
	array_init_size(item, 3);

	phalcon_array_append_long(&item, -1, 0);
	phalcon_array_append(&item, tmp_amount, 0);
	phalcon_array_append_long(&item, -1, 0);

	phalcon_array_append(&matrix, item, 0);

	/* 3 */
	PHALCON_INIT_NVAR(item);
	array_init_size(item, 3);

	phalcon_array_append_long(&item, -1, 0);
	phalcon_array_append_long(&item, -1, 0);
	phalcon_array_append_long(&item, -1, 0);

	phalcon_array_append(&matrix, item, 9);

	b = b - 8;

	PHALCON_INIT_NVAR(tmp_amount);
	ZVAL_DOUBLE(tmp_amount, b);

	PHALCON_INIT_NVAR(tmp);
	ZVAL_LONG(tmp, 0);

	PHALCON_CALL_FUNCTION(&ret, "imageconvolution", image, matrix, tmp_amount, tmp);

	if (zend_is_true(ret)) {
		PHALCON_CALL_FUNCTION(&width, "imagesx", image);
		PHALCON_CALL_FUNCTION(&height, "imagesy", image);

		phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _reflection) {

	zval *height, *opacity, *fade_in, *tmp = NULL;
	zval *reflection = NULL, *line = NULL, *image, *image_width = NULL, *image_height = NULL;
	zval *dst, *src_y = NULL, *dst_y = NULL, *dst_opacity = NULL, *filtertype = NULL;
	int h0, h1, tmp_opacity, int_opacity, offset;
	double stepping;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &height, &opacity, &fade_in);

	PHALCON_SEPARATE_PARAM(height);

	image        = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	image_width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	image_height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(filtertype);
	if (!zend_get_constant(SL("IMG_FILTER_COLORIZE"), filtertype TSRMLS_CC)) {
		RETURN_MM();
	}

	h0 = phalcon_get_intval(height);
	h1 = phalcon_get_intval(image_height);

	if (unlikely(h0 == 0)) {
		h0 = 1;
	}

	tmp_opacity = phalcon_get_intval(opacity);

	tmp_opacity = (int)((tmp_opacity * 127 / 100) - 127 + 0.5);

	if (tmp_opacity < 0) {
		tmp_opacity = -tmp_opacity;
	}

	if (tmp_opacity < 127) {
		stepping = (127 - tmp_opacity) / h0;
	} else {
		stepping = 127 / h0;
	}

	PHALCON_INIT_NVAR(height);
	ZVAL_DOUBLE(height, h0 + h1);

	PHALCON_CALL_METHOD(&reflection, this_ptr, "_create", image_width, height);

	PHALCON_INIT_VAR(dst);
	ZVAL_LONG(dst, 0);

	PHALCON_CALL_FUNCTION(NULL, "imagecopy", reflection, image, dst, dst, dst, dst, image_width, image_height);

	PHALCON_INIT_NVAR(tmp);
	ZVAL_LONG(tmp, 1);

	for (offset = 0; h0 >= offset; offset++) {
		PHALCON_INIT_NVAR(src_y);
		ZVAL_LONG(src_y, h1 - offset - 1);

		PHALCON_INIT_NVAR(dst_y);
		ZVAL_LONG(dst_y, h1 + offset);

		if (zend_is_true(fade_in)) {

			int_opacity = (int)(tmp_opacity + (stepping * (h0 - offset)) + 0.5);

			PHALCON_INIT_NVAR(dst_opacity);
			ZVAL_LONG(dst_opacity, int_opacity);
		} else {
			int_opacity = (int)(tmp_opacity + (stepping * offset) + 0.5);

			PHALCON_INIT_NVAR(dst_opacity);
			ZVAL_LONG(dst_opacity, int_opacity);
		}

		PHALCON_CALL_METHOD(&line, this_ptr, "_create", image_width, tmp);

		PHALCON_CALL_FUNCTION(NULL, "imagecopy", line, image, dst, dst, dst, src_y, image_width, tmp);
		PHALCON_CALL_FUNCTION(NULL, "imagefilter", line, filtertype, dst, dst, dst, dst_opacity);

		PHALCON_CALL_FUNCTION(NULL, "imagecopy", reflection, line, dst, dst_y, dst, dst, image_width, tmp);
	}

	PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
	phalcon_update_property_this_quick(this_ptr, SL("_image"), reflection, 2440377831UL TSRMLS_CC);

	image_width = NULL;
	PHALCON_CALL_FUNCTION(&image_width, "imagesx", reflection);
	image_height = NULL;
	PHALCON_CALL_FUNCTION(&image_height, "imagesy", reflection);

	phalcon_update_property_this_quick(this_ptr, SL("_width"), image_width, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), image_height, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _watermark) {

	zval *watermark, *offset_x = NULL, *offset_y = NULL, *opacity = NULL, *op = NULL;
	zval *image, *overlay = NULL, *blob = NULL, *saveflag, *width = NULL, *height = NULL;
	zval *color = NULL, *tmp = NULL, *effect, *blendmode, *ret = NULL;
	int int_opacity;
	double num;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &watermark, &offset_x, &offset_y, &opacity);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&blob, watermark, "render");

	PHALCON_CALL_FUNCTION(&overlay, "imagecreatefromstring", blob);

	PHALCON_INIT_VAR(saveflag);
	ZVAL_TRUE(saveflag);

	PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", overlay, saveflag);

	PHALCON_CALL_FUNCTION(&width, "imagesx", overlay);
	PHALCON_CALL_FUNCTION(&height, "imagesy", overlay);

	int_opacity = Z_LVAL_P(opacity);
	if (int_opacity < 100) {
		num = (int_opacity * 127.0 / 100) - 127;

		if (num < 0) {
			num = -num;
		}

		int_opacity = (int)num;

		PHALCON_INIT_VAR(op);
		ZVAL_LONG(op, int_opacity);

		PHALCON_INIT_NVAR(tmp);
		ZVAL_LONG(tmp, 127);


		PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", overlay, tmp, tmp, tmp, op);

		PHALCON_INIT_VAR(effect);
		if (!zend_get_constant(SL("IMG_EFFECT_OVERLAY"), effect TSRMLS_CC)) {
			RETURN_MM();
		}

		PHALCON_CALL_FUNCTION(NULL, "imagelayereffect", overlay, effect);

		PHALCON_INIT_NVAR(tmp);
		ZVAL_LONG(tmp, 0);

		PHALCON_CALL_FUNCTION(NULL, "imagefilledrectangle", overlay, tmp, tmp, width, height, color);
	}

	PHALCON_INIT_VAR(blendmode);
	ZVAL_LONG(blendmode, 1);
	PHALCON_CALL_FUNCTION(NULL, "imagealphablending", image, blendmode);

	PHALCON_INIT_NVAR(tmp);
	ZVAL_LONG(tmp, 0);

	PHALCON_CALL_FUNCTION(&ret, "imagecopy", image, overlay, offset_x, offset_y, tmp, tmp, width, height);

	RETVAL_BOOL(zend_is_true(ret));
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _text) {
	zval *text, *offset_x, *offset_y, *opacity, *r, *g, *b, *size, *fontfile = NULL;
	zval *image, *image_width, *image_height, *tmp = NULL, *space = NULL;
	zval *s0 = NULL, *s1 = NULL, *s4 = NULL, *s5 = NULL, *width = NULL, *height = NULL, *color = NULL;
	int w, h, w1, h1, x, y, i;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 9, 0, &text, &offset_x, &offset_y, &opacity, &r, &g, &b, &size, &fontfile);

	PHALCON_SEPARATE_PARAM(offset_x);
	PHALCON_SEPARATE_PARAM(offset_y);
	PHALCON_SEPARATE_PARAM(opacity);

	PHALCON_OBS_VAR(image);
	phalcon_read_property_this(&image, this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_OBS_VAR(image_width);
	phalcon_read_property_this(&image_width, this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);

	PHALCON_OBS_VAR(image_height);
	phalcon_read_property_this(&image_height, this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);
	
	w = phalcon_get_intval(image_width);
	h = phalcon_get_intval(image_height);

	i = Z_LVAL_P(opacity);

	i = (int)((i * 127 / 100) - 127);

	if (i < 0) {
		i *= -1;
	}

	PHALCON_INIT_NVAR(opacity);
	ZVAL_LONG(opacity, i);

	PHALCON_INIT_NVAR(tmp);
	ZVAL_LONG(tmp, 0);

	if (Z_TYPE_P(fontfile) == IS_STRING) {
		PHALCON_CALL_FUNCTION(&space, "imagettfbbox", size, tmp, fontfile, text);

		phalcon_array_isset_long_fetch(&s0, space, 0);
		phalcon_array_isset_long_fetch(&s1, space, 1);
		phalcon_array_isset_long_fetch(&s4, space, 4);
		phalcon_array_isset_long_fetch(&s5, space, 5);

		if (!s0 || !s1 || !s4 || !s5) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Call to imagettfbbox() failed");
			return;
		}

		w1 = phalcon_get_intval(s4) - phalcon_get_intval(s0);
		if (w1 < 0) {
			w1 = -w1;
		}
		w1 += 10;

		PHALCON_INIT_VAR(width);
		ZVAL_LONG(width, w1);

		h1 = phalcon_get_intval(s5) - phalcon_get_intval(s1);
		if (h1 < 0) {
			h1 = -h1;
		}
		h1 += 10;

		PHALCON_INIT_VAR(height);
		ZVAL_LONG(height, h1);

		if (Z_TYPE_P(offset_x) == IS_LONG ) {
			x = phalcon_get_intval(offset_x);
			if (x < 0) {
				x = (int)(w - w1 + x + 0.5);
			}
		} else if (zend_is_true(offset_x)) {
			x = (int)(w - w1);
		} else {
			x = (int)(((w - w1) / 2) + 0.5);
		}

		PHALCON_INIT_NVAR(offset_x);
		ZVAL_LONG(offset_x, x);

		if (Z_TYPE_P(offset_y) == IS_LONG ) {
			y = phalcon_get_intval(offset_y);
			if (y < 0) {
				y = (int)(h - h1 + y + 0.5);
			}
		} else if (zend_is_true(offset_y)) {
			y = (int)(h - h1);
		} else {
			y = (int)(((h - h1) / 2) + 0.5);
		}

		PHALCON_INIT_NVAR(offset_y);
		ZVAL_LONG(offset_y, y);

		PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", image, r, g, b, opacity);
		PHALCON_CALL_FUNCTION(NULL, "imagettftext", image, size, tmp, offset_x, offset_y, color, fontfile, text);
	} else {
		PHALCON_CALL_FUNCTION(&width, "imagefontwidth", size);
		PHALCON_CALL_FUNCTION(&height, "imagefontheight", size);

		i = Z_STRLEN_P(text);

		w1 =  phalcon_get_intval(width) * i;
		h1 =  phalcon_get_intval(height);

		PHALCON_INIT_NVAR(width);
		ZVAL_LONG(width, w1);

		PHALCON_INIT_NVAR(height);
		ZVAL_LONG(height, h1);

		if (Z_TYPE_P(offset_x) == IS_LONG ) {
			x = phalcon_get_intval(offset_x);
			if (x < 0) {
				x = (int)(w - w1 + x);
			}
		} else if (zend_is_true(offset_x)) {
			x = (int)(w - w1);
		} else {
			x = (int)((w - w1) / 2);
		}

		PHALCON_INIT_NVAR(offset_x);
		ZVAL_LONG(offset_x, x);

		if (Z_TYPE_P(offset_y) == IS_LONG ) {
			y = phalcon_get_intval(offset_y);
			if (y < 0) {
				y = (int)(h - h1 + y);
			}
		} else if (zend_is_true(offset_y)) {
			y = (int)(h - h1);
		} else {
			y = (int)((h - h1) / 2);
		}

		PHALCON_INIT_NVAR(offset_y);
		ZVAL_LONG(offset_y, y);

		PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", image, r, g, b, opacity);
		PHALCON_CALL_FUNCTION(NULL, "imagestring", image, size, offset_x, offset_y, text, color);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _mask){

	zval *mask, *image, *mask_image = NULL, *blob = NULL;
	zval *mask_image_width = NULL, *mask_image_height = NULL, *newimage = NULL;
	zval *image_width, *image_height, *saveflag, *color = NULL, *c, *alpha = NULL;
	zval *r = NULL, *g = NULL, *b = NULL, *index = NULL, *index2 = NULL, *zx = NULL, *zy = NULL, *red = NULL;
	zval *temp_image = NULL;
	int x, y, w, h, i;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &mask);

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&blob, mask, "render");

	PHALCON_CALL_FUNCTION(&mask_image, "imagecreatefromstring", blob);

	PHALCON_INIT_VAR(saveflag);
	ZVAL_TRUE(saveflag);

	PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", mask_image, saveflag);

	PHALCON_CALL_FUNCTION(&mask_image_width, "imagesx", mask_image);
	PHALCON_CALL_FUNCTION(&mask_image_height, "imagesy", mask_image);

	image_width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	image_height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&newimage, this_ptr, "_create", image_width, image_height);

	PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", newimage, saveflag);

	PHALCON_INIT_VAR(c);
	ZVAL_LONG(c, 0);

	PHALCON_INIT_VAR(alpha);
	ZVAL_LONG(alpha, 127);

	PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", newimage, c, c, c, alpha);

	PHALCON_CALL_FUNCTION(NULL, "imagefill", newimage, c, c, color);

	if(!PHALCON_IS_EQUAL(image_width, mask_image_width) || !PHALCON_IS_EQUAL(image_height, mask_image_height)) {
		PHALCON_CALL_FUNCTION(&temp_image, "imagecreatetruecolor", image_width, image_height);
		PHALCON_CALL_FUNCTION(NULL, "imagecopyresampled", temp_image, mask_image, c, c, c, c, image_width, image_height, mask_image_width, mask_image_height);
		PHALCON_CALL_FUNCTION(NULL, "imagedestroy", mask_image);

		PHALCON_CPY_WRT(mask_image, temp_image);
	}
	
	w = phalcon_get_intval(image_width);
	h = phalcon_get_intval(image_height);

	for (x=0; x < w; x++) {
		PHALCON_INIT_NVAR(zx);
		ZVAL_LONG(zx, x);
		for (y=0; y < h; y++) {
			PHALCON_INIT_NVAR(zy);
			ZVAL_LONG(zy, y);

			PHALCON_CALL_FUNCTION(&index, "imagecolorat", mask_image, zx, zy);
			PHALCON_CALL_FUNCTION(&alpha, "imagecolorsforindex", mask_image, index);

			if (phalcon_array_isset_string_fetch(&red, alpha, SS("red"))) {
				i = (int)(127 - (phalcon_get_intval(red) / 2));

				PHALCON_INIT_NVAR(alpha);
				ZVAL_LONG(alpha, i);
			}

			PHALCON_CALL_FUNCTION(&index2, "imagecolorat", image, zx, zy);
			PHALCON_CALL_FUNCTION(&c, "imagecolorsforindex", image, index2);

			phalcon_array_isset_string_fetch(&r, c, SS("red"));
			phalcon_array_isset_string_fetch(&g, c, SS("green"));
			phalcon_array_isset_string_fetch(&b, c, SS("blue"));

			PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", newimage, r, g, b, alpha);
			PHALCON_CALL_FUNCTION(NULL, "imagesetpixel", newimage, zx, zy, color);
		}
	}

	PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
	PHALCON_CALL_FUNCTION(NULL, "imagedestroy", mask_image);
	phalcon_update_property_this_quick(this_ptr, SL("_image"), newimage, 2440377831UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _background) {

	zval *r, *g, *b, *opacity, *op;
	zval *image, *background = NULL, *width, *height, *color = NULL, *tmp, *blendmode, *ret = NULL;
	int int_opacity;
	double num;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &r, &g, &b, &opacity);

	image  = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	int_opacity = Z_LVAL_P(opacity);

	num = (int_opacity * 127.0 / 100) - 127;

	if (num < 0) {
		num = -num;
	}

	int_opacity = (int)num;

	PHALCON_CALL_METHOD(&background, this_ptr, "_create", width, height);

	PHALCON_INIT_VAR(op);
	ZVAL_LONG(op, int_opacity);

	PHALCON_CALL_FUNCTION(&color, "imagecolorallocatealpha", background, r, g, b, op);

	PHALCON_INIT_VAR(tmp);
	ZVAL_LONG(tmp, 0);

	PHALCON_CALL_FUNCTION(NULL, "imagefilledrectangle", background, tmp, tmp, width, height, color);

	PHALCON_INIT_VAR(blendmode);
	ZVAL_TRUE(blendmode);

	PHALCON_CALL_FUNCTION(NULL, "imagealphablending", background, blendmode);
	PHALCON_CALL_FUNCTION(&ret, "imagecopy", background, image, tmp, tmp, tmp, tmp, width, height);

	if (zend_is_true(ret)) {
		PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
		phalcon_update_property_this_quick(this_ptr, SL("_image"), background, 2440377831UL TSRMLS_CC);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _blur){

	zval *radius;
	zval *image, *constant;
	int r, i;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &radius);	

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(constant);
	if (!zend_get_constant(SL("IMG_FILTER_GAUSSIAN_BLUR"), constant TSRMLS_CC)) {
		RETURN_MM();
	}

	r = phalcon_get_intval(radius);

	for (i = 0; i < r; i++) {
		PHALCON_CALL_FUNCTION(NULL, "imagefilter", image, constant);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _pixelate){

	zval *amount;
	zval *image, *width, *height, *color = NULL, *tmp1 = NULL, *tmp2 = NULL, *tmp3 = NULL, *tmp4 = NULL;
	int a, x, y, x1, y1, w, h;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &amount);

	image  = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	a = phalcon_get_intval(amount);
	w = phalcon_get_intval(width);
	h = phalcon_get_intval(height);

	for(x = 0; x < w; x += a) {
		for (y = 0; y < h; y += a) {
			x1 = (int)(x + a/2 + 0.5);
			y1 = (int)(y + a/2 + 0.5);

			PHALCON_INIT_NVAR(tmp1);
			ZVAL_LONG(tmp1, x1)

			PHALCON_INIT_NVAR(tmp2);
			ZVAL_LONG(tmp2, y1)

			PHALCON_CALL_FUNCTION(&color, "imagecolorat", image, tmp1, tmp2);

			PHALCON_INIT_NVAR(tmp1);
			ZVAL_LONG(tmp1, x)

			PHALCON_INIT_NVAR(tmp2);
			ZVAL_LONG(tmp2, y)

			x1 = x + a;
			y1 = y + a;

			PHALCON_INIT_NVAR(tmp3);
			ZVAL_LONG(tmp3, x1)

			PHALCON_INIT_NVAR(tmp4);
			ZVAL_LONG(tmp4, y1)

			PHALCON_CALL_FUNCTION(NULL, "imagefilledrectangle", image, tmp1, tmp2, tmp3, tmp4, color);
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _save) {

	zval *file = NULL, *quality = NULL, *exception_message, *q = NULL;
	zval *ret = NULL, *extension, *type, *mime = NULL, *constant, *image;
	const char *func_name = "imagegif";
	char *ext;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &file, &quality);

	PHALCON_INIT_VAR(constant);
	if (!zend_get_constant(SL("PATHINFO_EXTENSION"), constant TSRMLS_CC)) {
		RETURN_MM();
	}

	PHALCON_CALL_FUNCTION(&ret, "pathinfo", file, constant);

	PHALCON_INIT_VAR(extension);
	phalcon_fast_strtolower(extension, ret);

	ext = Z_STRVAL_P(extension);

	if (strcmp(ext, "gif") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 1);
			
		PHALCON_INIT_NVAR(q);

		func_name = "imagegif";
	} else if (strcmp(ext, "jpg") == 0 || strcmp(ext, "jpeg") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 2);

		PHALCON_CPY_WRT(q, quality);

		func_name = "imagejpeg";
	} else if (strcmp(ext, "png") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 3);
			
		PHALCON_INIT_NVAR(q);
		ZVAL_LONG(q, 9);

		func_name = "imagepng";
	} else {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Installed GD does not support '", extension, "' images");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}
	
	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(quality) == IS_LONG) {
		PHALCON_CALL_FUNCTION(&ret, func_name, image, file, q);
	} else {
		PHALCON_CALL_FUNCTION(&ret, func_name, image, file);
	}

	if (zend_is_true(ret)) {
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_CALL_FUNCTION(&mime, "image_type_to_mime_type", type);
		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);

		RETVAL_TRUE;
	} else {
		RETVAL_FALSE;
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _render) {

	zval *extension = NULL, *quality = NULL, *exception_message, *q = NULL;
	zval *file, *ret = NULL, *type, *mime = NULL, *image;
	const char *func_name = "imagegif";
	char *ext;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &extension, &quality);

	PHALCON_INIT_VAR(file);

	PHALCON_INIT_VAR(ret);
	phalcon_fast_strtolower(ret, extension);

	ext = Z_STRVAL_P(ret);

	if (strcmp(ext, "gif") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 1);
			
		PHALCON_INIT_NVAR(q);

		func_name = "imagegif";
	} else if (strcmp(ext, "jpg") == 0 || strcmp(ext, "jpeg") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 2);

		PHALCON_CPY_WRT(q, quality);

		func_name = "imagejpeg";
	} else if (strcmp(ext, "png") == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 3);
			
		PHALCON_INIT_NVAR(q);
		ZVAL_LONG(q, 9);

		func_name = "imagepng";
	} else {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Installed GD does not support '", extension, "' images");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}
	
	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	phalcon_ob_start(TSRMLS_C);

	if (Z_TYPE_P(quality) == IS_LONG) {
		PHALCON_CALL_FUNCTION(&ret, func_name, image, file, q);
	} else {
		PHALCON_CALL_FUNCTION(&ret, func_name, image, file);
	}

	phalcon_ob_get_contents(return_value TSRMLS_CC);
	phalcon_ob_end_clean(TSRMLS_C);

	if (zend_is_true(ret)) {
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_CALL_FUNCTION(&mime, "image_type_to_mime_type", type);
		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, _create) {

	zval *width, *height, *image = NULL, *blendmode, *saveflag;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &width, &height);

	PHALCON_CALL_FUNCTION(&image, "imagecreatetruecolor", width, height);

	if (Z_TYPE_P(image) != IS_RESOURCE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "imagecreatetruecolor() failed");
		return;
	}

	PHALCON_INIT_VAR(blendmode);
	ZVAL_FALSE(blendmode);

	PHALCON_INIT_VAR(saveflag);
	ZVAL_TRUE(saveflag);

	PHALCON_CALL_FUNCTION(NULL, "imagealphablending", image, blendmode);
	PHALCON_CALL_FUNCTION(NULL, "imagesavealpha", image, saveflag);

	RETURN_CTOR(image);
}

static PHP_METHOD(Phalcon_Image_Adapter_GD, __destruct){

	zval *image;

	PHALCON_MM_GROW();

	image = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(image) == IS_RESOURCE) {
		PHALCON_CALL_FUNCTION(NULL, "imagedestroy", image);
	}
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_image_adapter_imagick_ce;

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, check);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, __construct);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _resize);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _liquidRescale);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _crop);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _rotate);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _flip);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _sharpen);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _reflection);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _watermark);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _text);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _mask);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _background);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _blur);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _pixelate);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _save);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _render);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, __destruct);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, getInternalImInstance);
static PHP_METHOD(Phalcon_Image_Adapter_Imagick, setResourceLimit);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_image_adapter_imagick___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, file)
	ZEND_ARG_INFO(0, width)
	ZEND_ARG_INFO(0, height)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_image_adapter_imagick_setresourcelimit, 0, 0, 2)
	ZEND_ARG_INFO(0, resource)
	ZEND_ARG_INFO(0, limit)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_image_adapter_imagick_method_entry[] = {
	PHP_ME(Phalcon_Image_Adapter_Imagick, check, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Image_Adapter_Imagick, __construct, arginfo_phalcon_image_adapter_imagick___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _resize, arginfo_phalcon_image_adapter__resize, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _liquidRescale, arginfo_phalcon_image_adapter__liquidrescale, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _crop, arginfo_phalcon_image_adapter__crop, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _rotate, arginfo_phalcon_image_adapter__rotate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _flip, arginfo_phalcon_image_adapter__flip, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _sharpen, arginfo_phalcon_image_adapter__sharpen, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _reflection, arginfo_phalcon_image_adapter__reflection, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _watermark, arginfo_phalcon_image_adapter__watermark, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _text, arginfo_phalcon_image_adapter__text, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _mask, arginfo_phalcon_image_adapter__mask, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _background, arginfo_phalcon_image_adapter__background, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _blur, arginfo_phalcon_image_adapter__blur, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _pixelate, arginfo_phalcon_image_adapter__pixelate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _save, arginfo_phalcon_image_adapter__save, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, _render, arginfo_phalcon_image_adapter__render, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Image_Adapter_Imagick, __destruct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)
	PHP_ME(Phalcon_Image_Adapter_Imagick, getInternalImInstance, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Image_Adapter_Imagick, setResourceLimit, arginfo_phalcon_image_adapter_imagick_setresourcelimit, ZEND_ACC_PUBLIC | ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Image_Adapter_Imagick){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Image\\Adapter, Imagick, image_adapter_imagick, phalcon_image_adapter_ce, phalcon_image_adapter_imagick_method_entry, 0);

	zend_declare_property_null(phalcon_image_adapter_imagick_ce, SL("_version"), ZEND_ACC_PROTECTED | ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_null(phalcon_image_adapter_imagick_ce, SL("_checked"), ZEND_ACC_PROTECTED | ZEND_ACC_STATIC TSRMLS_CC);

	zend_class_implements(phalcon_image_adapter_imagick_ce TSRMLS_CC, 1, phalcon_image_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, check){

	zval *version;

	if (!phalcon_class_exists(SL("imagick"), 0 TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick is not installed, or the extension is not loaded");
		return;
	}

	MAKE_STD_ZVAL(version);
	if (!zend_get_constant_ex(SL("imagick::IMAGICK_EXTNUM"), version, NULL, ZEND_FETCH_CLASS_SILENT TSRMLS_CC)) {
		zend_update_static_property_long(phalcon_image_adapter_imagick_ce, SL("_version"), 0 TSRMLS_CC);
	}
	else {
		zend_update_static_property_long(phalcon_image_adapter_imagick_ce, SL("_version"), phalcon_get_intval(version) TSRMLS_CC);
	}

	zval_ptr_dtor(&version);

	zend_update_static_property_bool(phalcon_image_adapter_imagick_ce, SL("_checked"), 1 TSRMLS_CC);
	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, __construct){

	zval **file, **w = NULL, **h = NULL;
	zval *width = NULL, *height = NULL;
	zval *checked, *realpath, *format = NULL, *type = NULL, *mime, *im, *ret = NULL, *mode, *imagickpixel, *color;
	zend_class_entry *imagick_ce, *ce1;

	phalcon_fetch_params_ex(1, 2, &file, &w, &h);

	PHALCON_ENSURE_IS_STRING(file);

	PHALCON_MM_GROW();

	imagick_ce = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	checked = phalcon_fetch_static_property_ce(phalcon_image_adapter_imagick_ce, SL("_checked") TSRMLS_CC);

	if (!zend_is_true(checked)) {
		PHALCON_CALL_CE_STATIC(NULL, phalcon_image_adapter_imagick_ce, "check");
	}

	phalcon_update_property_this(this_ptr, SL("_file"), *file TSRMLS_CC);

	PHALCON_INIT_VAR(im);
	object_init_ex(im, imagick_ce);
	if (phalcon_has_constructor(im TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, im, "__construct");
	}

	if (phalcon_file_exists(*file TSRMLS_CC) != FAILURE) {
		PHALCON_INIT_VAR(realpath);
		phalcon_realpath(realpath, *file TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_realpath"), realpath, 4192016085UL TSRMLS_CC);

		PHALCON_CALL_METHOD(NULL, im, "readImage", realpath);

		PHALCON_CALL_METHOD(&width, im, "getImageWidth");
		phalcon_update_property_this_quick(this_ptr, SL("_width"), width, 2983651716UL TSRMLS_CC);

		PHALCON_CALL_METHOD(&height, im, "getImageHeight");
		phalcon_update_property_this_quick(this_ptr, SL("_height"), height, 1628000445UL TSRMLS_CC);

		PHALCON_CALL_METHOD(&type, im, "getImageType");
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_CALL_METHOD(&format, im, "getImageFormat");

		PHALCON_INIT_VAR(mime);
		PHALCON_CONCAT_SV(mime, "image/", format);

		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);

		PHALCON_CALL_METHOD(&ret, im, "getImageAlphaChannel");

		if (!zend_is_true(ret)) {
			PHALCON_INIT_VAR(mode);
			phalcon_get_class_constant(mode, imagick_ce, SS("ALPHACHANNEL_SET") TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, im, "setImageAlphaChannel", mode);
		}

		if (phalcon_get_intval(type) == 1) {
			PHALCON_CALL_METHOD(&ret, im, "coalesceImages");

			PHALCON_CALL_METHOD(NULL, im, "clear");
			PHALCON_CALL_METHOD(NULL, im, "destroy");

			phalcon_update_property_this_quick(this_ptr, SL("_image"), ret, 2440377831UL TSRMLS_CC);
		} else {
			phalcon_update_property_this_quick(this_ptr, SL("_image"), im, 2440377831UL TSRMLS_CC);
		}
	} else if (w && h) {
		ce1 = zend_fetch_class(SL("ImagickPixel"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

		PHALCON_INIT_VAR(imagickpixel);
		object_init_ex(imagickpixel, ce1);

		if (phalcon_has_constructor(imagickpixel TSRMLS_CC)) {
			PHALCON_INIT_VAR(color);
			ZVAL_STRING(color, "transparent", 1);

			PHALCON_CALL_METHOD(NULL, imagickpixel, "__construct", color);
		}

		PHALCON_CALL_METHOD(NULL, im, "newImage", *w, *h, imagickpixel);

		PHALCON_INIT_VAR(format);
		ZVAL_STRING(format, "png", 1);

		PHALCON_CALL_METHOD(&ret, im, "setformat", format);
		PHALCON_CALL_METHOD(&ret, im, "setImageFormat", format);

		phalcon_update_property_this_quick(this_ptr, SL("_image"), im, 2440377831UL TSRMLS_CC);

		phalcon_update_property_this(this_ptr, SL("_realpath"), *file TSRMLS_CC);
		phalcon_update_property_this(this_ptr, SL("_width"), *w TSRMLS_CC);
		phalcon_update_property_this(this_ptr, SL("_height"), *h TSRMLS_CC);

		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 3);

		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_INIT_VAR(mime);
		ZVAL_STRING(mime, "image/png", 1);

		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);
	} else {
		zend_throw_exception_ex(phalcon_image_exception_ce, 0 TSRMLS_CC, "Failed to create image from file '%s'", Z_STRVAL_PP(file));
		PHALCON_MM_RESTORE();
		return;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _resize) {

	zval *width, *height;
	zval *im, *w = NULL, *h = NULL, *next = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &width, &height);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", PHALCON_GLOBAL(z_null));

	do {
		PHALCON_CALL_METHOD(NULL, im, "scaleImage", width, height);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_CALL_METHOD(&w, im, "getImageWidth");
	PHALCON_CALL_METHOD(&h, im, "getImageHeight");

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _liquidRescale){

	zval *width, *height, *delta_x = NULL, *rigidity = NULL;
	zval *im, *ret = NULL, *w = NULL, *h = NULL, *next = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &width, &height, &delta_x, &rigidity);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", PHALCON_GLOBAL(z_zero));

	do {
		PHALCON_CALL_METHOD(&ret, im, "liquidRescaleImage", width, height, delta_x, rigidity);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::liquidRescale failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_CALL_METHOD(&w, im, "getImageWidth");
	PHALCON_CALL_METHOD(&h, im, "getImageHeight");

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _crop) {

	zval *width, *height, *offset_x, *offset_y, *w = NULL, *h = NULL;
	zval *im, *next = NULL, *zero;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &width, &height, &offset_x, &offset_y);

	im   = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(NULL, im, "cropImage", width, height, offset_x, offset_y);
		PHALCON_CALL_METHOD(NULL, im, "setImagePage", width, height, zero, zero);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_CALL_METHOD(&w, im, "getImageWidth");
	PHALCON_CALL_METHOD(&h, im, "getImageHeight");

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _rotate) {

	zval *degrees;
	zval *im, *background, *color, *ret = NULL, *w = NULL, *h = NULL, *zero, *next = NULL;
	zend_class_entry *imagick_pixel_ce;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &degrees);

	imagick_pixel_ce = zend_fetch_class(SL("ImagickPixel"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_INIT_VAR(background);
	object_init_ex(background, imagick_pixel_ce);

	PHALCON_INIT_VAR(color);
	ZVAL_STRING(color, "transparent", 1);

	PHALCON_CALL_METHOD(NULL, background, "__construct", color);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(&ret, im, "rotateImage", background, degrees);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::rotate failed");
			return;
		}

		if (!w) {
			PHALCON_CALL_METHOD(&w, im, "getImageWidth");
			PHALCON_CALL_METHOD(&h, im, "getImageHeight");
		}

		PHALCON_CALL_METHOD(NULL, im, "setImagePage", w, h, zero, zero);

		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _flip) {

	zval **direction;
	zval *im, *next = NULL;
	char *method;

	phalcon_fetch_params_ex(1, 0, &direction);
	PHALCON_ENSURE_IS_LONG(direction);

	PHALCON_MM_GROW();

	im     = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	method = (Z_LVAL_PP(direction) == 11) ? "flopImage" : "flipImage";

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", PHALCON_GLOBAL(z_zero));

	do {
		PHALCON_CALL_METHOD(NULL, im, method);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _sharpen) {

	zval *amount, *a, *ret = NULL, *im, *zero, *next = NULL;
	int int_amount;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &amount);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	int_amount = phalcon_get_intval(amount);
	int_amount = (int_amount < 5) ? 5 : int_amount;

	PHALCON_INIT_VAR(a);
	ZVAL_DOUBLE(a, int_amount * 0.03);

	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(&ret, im, "sharpenImage", zero, a);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::sharpen failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _reflection) {

	zval *height, *opacity, *fade_in, *o;
	zval *im, *reflection, *image_width, *image_height, *reflection_width = NULL, *reflection_height = NULL, *zero;
	zval *fade, *pseudoString, *composite = NULL, *constant, *channel, *image;
	zval *background, *mode, *ret = NULL, *w = NULL, *h = NULL, *delay = NULL, *h0, *colorspace = NULL;
	zval *next = NULL;
	zend_class_entry *imagick_ce, *imagick_pixel_ce;
	zval *version;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &height, &opacity, &fade_in);

	imagick_ce       = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	imagick_pixel_ce = zend_fetch_class(SL("ImagickPixel"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	im           = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	image_width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	image_height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);
	version      = phalcon_fetch_static_property_ce(phalcon_image_adapter_imagick_ce, SL("_version") TSRMLS_CC);

	PHALCON_INIT_VAR(reflection);
	if (phalcon_get_intval(version) >= 30100) {
		if (FAILURE == phalcon_clone(reflection, im TSRMLS_CC)) {
			RETURN_MM();
		}
	}
	else {
		PHALCON_CALL_METHOD(&reflection, im, "clone");
	}

	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_CALL_METHOD(NULL, reflection, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(NULL, reflection, "flipImage");
		PHALCON_CALL_METHOD(NULL, reflection, "cropImage", image_width, height, zero, zero);
		PHALCON_CALL_METHOD(NULL, reflection, "setImagePage", image_width, height, zero, zero);
		PHALCON_CALL_METHOD(&next, reflection, "nextImage");
	} while (zend_is_true(next));


	PHALCON_INIT_VAR(fade);
	object_init_ex(fade, imagick_ce);
	if (phalcon_has_constructor(fade TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, fade, "__construct");
	}

	PHALCON_INIT_VAR(pseudoString);
	ZVAL_STRING(pseudoString, (zend_is_true(fade_in) ? "gradient:black-transparent" : "gradient:transparent-black"), 1);

	PHALCON_CALL_METHOD(&reflection_width, reflection, "getImageWidth");
	PHALCON_CALL_METHOD(&reflection_height, reflection, "getImageHeight");

	PHALCON_ENSURE_IS_LONG(&reflection_width);
	PHALCON_ENSURE_IS_LONG(&reflection_height);

	PHALCON_CALL_METHOD(NULL, fade, "newPseudoImage", reflection_width, reflection_height, pseudoString);

	PHALCON_INIT_VAR(composite);
	phalcon_get_class_constant(composite, imagick_ce, SS("COMPOSITE_DSTOUT") TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, reflection, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(&ret, reflection, "compositeImage", fade, composite, zero, zero);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::compositeImage failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, reflection, "nextImage");
	} while (zend_is_true(next));

	PHALCON_INIT_VAR(constant);
	phalcon_get_class_constant(constant, imagick_ce, SS("EVALUATE_MULTIPLY") TSRMLS_CC);

	PHALCON_INIT_VAR(o);
	ZVAL_DOUBLE(o, phalcon_get_intval(opacity) / 100);

	PHALCON_INIT_VAR(channel);
	phalcon_get_class_constant(channel, imagick_ce, SS("CHANNEL_ALPHA") TSRMLS_CC);
 

	PHALCON_CALL_METHOD(NULL, reflection, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(NULL, reflection, "evaluateImage", constant, o, channel);
		PHALCON_CALL_METHOD(&next, reflection, "nextImage");
	} while (zend_is_true(next));

	PHALCON_INIT_VAR(image);
	object_init_ex(image, imagick_ce);
	if (phalcon_has_constructor(image TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, image, "__construct");
	}

	PHALCON_INIT_VAR(h0);
	ZVAL_LONG(h0, phalcon_get_intval(image_height) + phalcon_get_intval(height));

	PHALCON_INIT_VAR(background);
	object_init_ex(background, imagick_pixel_ce);
	if (phalcon_has_constructor(background TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, background, "__construct");
	}

	PHALCON_INIT_VAR(mode);
	phalcon_get_class_constant(mode, imagick_ce, SS("ALPHACHANNEL_SET") TSRMLS_CC);

	PHALCON_CALL_METHOD(&colorspace, im, "getcolorspace");

	PHALCON_INIT_NVAR(composite);
	phalcon_get_class_constant(composite, imagick_ce, SS("COMPOSITE_SRC") TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	PHALCON_CALL_METHOD(&delay, im, "getImageDelay");

	do {
		PHALCON_CALL_METHOD(NULL, image, "newImage", image_width, h0, background);
		PHALCON_CALL_METHOD(NULL, image, "setImageAlphaChannel", mode);
		PHALCON_CALL_METHOD(NULL, image, "setcolorspace", colorspace);
		PHALCON_CALL_METHOD(NULL, image, "setImageDelay", delay);
		PHALCON_CALL_METHOD(&ret, image, "compositeImage", im, composite, zero, zero);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::compositeImage failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_INIT_NVAR(composite);
	phalcon_get_class_constant(composite, imagick_ce, SS("COMPOSITE_OVER") TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, image, "setIteratorIndex", zero);
	PHALCON_CALL_METHOD(NULL, reflection, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(&ret, image, "compositeImage", reflection, composite, zero, image_height);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::compositeImage failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, image, "nextImage");
		PHALCON_CALL_METHOD(NULL, reflection, "nextImage");
	} while (zend_is_true(next));

	PHALCON_CALL_METHOD(&w, image, "getImageWidth");
	PHALCON_CALL_METHOD(&h, image, "getImageHeight");

	phalcon_update_property_this_quick(this_ptr, SL("_width"), w, 2983651716UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_height"), h, 1628000445UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_image"), image, 2440377831UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _watermark) {

	zval *watermark_image, *offset_x, *offset_y, *opacity, *op =NULL;
	zval *im, *watermark, *realpath = NULL, *blob = NULL, *ret = NULL, *channel;
	zval *op_constant = NULL, *composite, *index, *next = NULL, *type;
	zend_class_entry *ce0;
	double num;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &watermark_image, &offset_x, &offset_y, &opacity);

	ce0 = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_OBS_VAR(im);
	phalcon_read_property_this(&im, this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_OBS_VAR(type);
	phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(watermark);
	object_init_ex(watermark, ce0);
	if (phalcon_has_constructor(watermark TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, watermark, "__construct");
	}

	PHALCON_CALL_METHOD(&realpath, watermark_image, "getrealpath");
	PHALCON_CALL_METHOD(&blob, watermark_image, "render");
	PHALCON_CALL_METHOD(NULL, watermark, "readImageBlob", blob, realpath);

	PHALCON_INIT_VAR(channel);
	phalcon_get_class_constant(channel, ce0, SS("ALPHACHANNEL_ACTIVATE") TSRMLS_CC);

	PHALCON_CALL_METHOD(&ret, watermark, "getImageAlphaChannel");

	if (!PHALCON_IS_EQUAL(ret, channel)) {
		PHALCON_INIT_NVAR(channel);
		phalcon_get_class_constant(channel, ce0, SS("ALPHACHANNEL_OPAQUE") TSRMLS_CC);

		PHALCON_CALL_METHOD(NULL, watermark, "setImageAlphaChannel", channel);
	}

	if (phalcon_get_intval(opacity) < 100) {
		PHALCON_INIT_NVAR(op_constant);
		phalcon_get_class_constant(op_constant, ce0, SS("EVALUATE_MULTIPLY") TSRMLS_CC);

		num = Z_LVAL_P(opacity) / 100;

		PHALCON_INIT_NVAR(op);
		ZVAL_DOUBLE(op, num);

		PHALCON_INIT_NVAR(channel);
		phalcon_get_class_constant(channel, ce0, SS("CHANNEL_ALPHA") TSRMLS_CC);

		PHALCON_CALL_METHOD(NULL, watermark, "evaluateImage", op_constant, op, channel);
	}

	PHALCON_INIT_VAR(composite);
	phalcon_get_class_constant(composite, ce0, SS("COMPOSITE_DISSOLVE") TSRMLS_CC);

	if (phalcon_get_intval(type) == 1) {
		PHALCON_INIT_VAR(index);
		ZVAL_LONG(index, 0);

		PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", index);

		do {
			PHALCON_CALL_METHOD(&ret, im, "compositeImage", watermark, composite, offset_x, offset_y);

			if (!zend_is_true(ret)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::watermark failed");
				return;
			}

			PHALCON_CALL_METHOD(&next, im, "nextImage");
		} while (zend_is_true(next));
	} else {
		PHALCON_CALL_METHOD(&ret, im, "compositeImage", watermark, composite, offset_x, offset_y);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::watermark failed");
			return;
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _text) {

	zval **text, **ofs_x = NULL, **ofs_y = NULL, **opacity = NULL, **r = NULL, **g = NULL, **b = NULL, **size = NULL, **fontfile = NULL;
	zval *im, *draw, *pixel, *format, *color = NULL, *op, *gravity, *tmp_a;
	zval *offset_x = NULL, *offset_y = NULL;
	zend_class_entry *imagick_ce, *imagick_draw_ce, *imagick_pixel_ce;
	int x, y;

	phalcon_fetch_params_ex(9, 0, &text, &ofs_x, &ofs_y, &opacity, &r, &g, &b, &size, &fontfile);

	PHALCON_MM_GROW();

	imagick_ce       = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	imagick_draw_ce  = zend_fetch_class(SL("ImagickDraw"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	imagick_pixel_ce = zend_fetch_class(SL("ImagickPixel"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	if (!ofs_x) {
		PHALCON_INIT_VAR(offset_x);
	} else {
		PHALCON_CPY_WRT_CTOR(offset_x, *ofs_x);
	}

	if (!offset_y) {
		PHALCON_INIT_VAR(offset_y);
	} else {
		PHALCON_CPY_WRT_CTOR(offset_x, *ofs_y);
	}

	if (!r) {
		r = &PHALCON_GLOBAL(z_zero);
	}

	if (!g) {
		g = &PHALCON_GLOBAL(z_zero);
	}

	if (!b) {
		b = &PHALCON_GLOBAL(z_zero);
	}

	PHALCON_INIT_VAR(op);
	if (!opacity) {
		ZVAL_DOUBLE(op, 1);
	}
	else {
		ZVAL_DOUBLE(op, phalcon_get_intval(*opacity)/100);
	}

	PHALCON_OBS_VAR(im);
	phalcon_read_property_this(&im, this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(draw);
	object_init_ex(draw, imagick_draw_ce);
	if (phalcon_has_constructor(draw TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, draw, "__construct");
	}

	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "rgb(%d, %d, %d)", 1);
	PHALCON_CALL_FUNCTION(&color, "sprintf", format, *r, *g, *b);

	PHALCON_INIT_VAR(pixel);
	object_init_ex(pixel, imagick_pixel_ce);
	if (phalcon_has_constructor(pixel TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, pixel, "__construct", color);
	}

	PHALCON_CALL_METHOD(NULL, draw, "setfillcolor", pixel);

	if (fontfile && Z_TYPE_PP(fontfile) == IS_STRING) {
		PHALCON_CALL_METHOD(NULL, draw, "setfont", *fontfile);
	}

	if (size) {
		PHALCON_CALL_METHOD(NULL, draw, "setfontsize", *size);
	}

	PHALCON_CALL_METHOD(NULL, draw, "setfillopacity", op);

	PHALCON_INIT_VAR(tmp_a);
	ZVAL_LONG(tmp_a, 0);

	PHALCON_INIT_VAR(gravity);

	if (Z_TYPE_P(offset_x) == IS_BOOL) {
		if (Z_TYPE_P(offset_y) == IS_BOOL) {
			if (zend_is_true(offset_x) && zend_is_true(offset_y)) {
				PHALCON_INIT_NVAR(offset_x);
				ZVAL_LONG(offset_x, 0);

				PHALCON_INIT_NVAR(offset_y);
				ZVAL_LONG(offset_y, 0);

				PHALCON_INIT_VAR(gravity);
				phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTHEAST") TSRMLS_CC);
			} else if (zend_is_true(offset_x)) {
				PHALCON_INIT_NVAR(offset_x);
				ZVAL_LONG(offset_x, 0);

				PHALCON_INIT_NVAR(offset_y);
				ZVAL_LONG(offset_y, 0);

				PHALCON_INIT_VAR(gravity);
				phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_EAST") TSRMLS_CC);
			} else if (zend_is_true(offset_y)) {
				PHALCON_INIT_NVAR(offset_x);
				ZVAL_LONG(offset_x, 0);

				PHALCON_INIT_NVAR(offset_y);
				ZVAL_LONG(offset_y, 0);

				PHALCON_INIT_VAR(gravity);
				phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTH") TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(offset_x);
				ZVAL_LONG(offset_x, 0);

				PHALCON_INIT_NVAR(offset_y);
				ZVAL_LONG(offset_y, 0);

				PHALCON_INIT_VAR(gravity);
				phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_CENTER") TSRMLS_CC);
			}
		} else if (Z_TYPE_P(offset_y) == IS_LONG) {
			y = phalcon_get_intval(offset_y);

			if (zend_is_true(offset_x)) {
				if (y < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, y * -1);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTHEAST") TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_NORTHEAST") TSRMLS_CC);
				}
			} else {
				if (y < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, y * -1);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTH") TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_NORTH") TSRMLS_CC);
				}
			}
		}
	} else if (Z_TYPE_P(offset_x) == IS_LONG) {
		x = phalcon_get_intval(offset_x);
		if (Z_TYPE_P(offset_y) == IS_BOOL) {
			if (zend_is_true(offset_y)) {
				if (x < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, x * -1);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTHEAST") TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTH") TSRMLS_CC);
				}
			} else {
				if (x < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, x * -1);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_EAST") TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_WEST") TSRMLS_CC);
				}
			}
		} else if (Z_TYPE_P(offset_y) == IS_LONG) {

			x = phalcon_get_intval(offset_x);
			y = phalcon_get_intval(offset_y);

			if (x < 0) {
				if (y < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, x * -1);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, y * -1);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTHEAST") TSRMLS_CC);
				} else {					
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, x * -1);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_NORTHEAST") TSRMLS_CC);
				}
			} else {
				if (y < 0) {
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_NVAR(offset_y);
					ZVAL_LONG(offset_y, y * -1);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_SOUTHWEST") TSRMLS_CC);
				} else {					
					PHALCON_INIT_NVAR(offset_x);
					ZVAL_LONG(offset_x, 0);

					PHALCON_INIT_VAR(gravity);
					phalcon_get_class_constant(gravity, imagick_ce, SS("GRAVITY_NORTHWEST") TSRMLS_CC);
				}
			}
		}
	}
	
	PHALCON_CALL_METHOD(NULL, draw, "setgravity", gravity);
	PHALCON_CALL_METHOD(NULL, im, "annotateImage", draw, offset_x, offset_y, tmp_a, *text);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _mask){

	zval *mask, *im, *mask_im, *realpath = NULL, *blob = NULL, *matte, *composite, *zero, *next = NULL;
	zend_class_entry *imagick_ce;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &mask);

	imagick_ce = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(mask_im);
	object_init_ex(mask_im, imagick_ce);
	if (phalcon_has_constructor(mask_im TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, mask_im, "__construct");
	}

	PHALCON_CALL_METHOD(&realpath, mask, "getrealpath");
	PHALCON_CALL_METHOD(&blob, mask, "render");

	PHALCON_CALL_METHOD(NULL, mask_im, "readImageBlob", blob, realpath);

	PHALCON_INIT_VAR(matte);
	ZVAL_LONG(matte, 1);

	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_INIT_VAR(composite);
	phalcon_get_class_constant(composite, imagick_ce, SS("COMPOSITE_DSTIN") TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(NULL, im, "setImageMatte", matte);
		PHALCON_CALL_METHOD(NULL, im, "compositeImage", mask_im, composite, zero, zero);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_CALL_METHOD(NULL, mask_im, "clear");

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _background) {

	zval *r, *g, *b, *opacity, *op = NULL;
	zval *im, *color = NULL, *format, *background, *imagickpixel, *width, *height, *ret = NULL;
	zval *mode, *op_constant, *channel, *composite, *zero, *next = NULL;
	zend_class_entry *imagick_ce, *imagick_pixel_ce;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &r, &g, &b, &opacity);

	imagick_ce       = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	imagick_pixel_ce = zend_fetch_class(SL("ImagickPixel"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	im     = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(format);
	ZVAL_STRING(format, "rgb(%d, %d, %d)", 1);
	PHALCON_CALL_FUNCTION(&color, "sprintf", format, r, g, b);
	
	PHALCON_INIT_VAR(background);
	object_init_ex(background, imagick_ce);
	if (phalcon_has_constructor(background TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, background, "__construct");
	}

	PHALCON_INIT_VAR(imagickpixel);
	object_init_ex(imagickpixel, imagick_pixel_ce);
	PHALCON_CALL_METHOD(NULL, imagickpixel, "__construct", color);

	PHALCON_CALL_METHOD(NULL, background, "newImage", width, height, imagickpixel);

	PHALCON_CALL_METHOD(&ret, background, "getImageAlphaChannel");

	if (!zend_is_true(ret)) {
		PHALCON_INIT_VAR(mode);
		phalcon_get_class_constant(mode, imagick_ce, SS("ALPHACHANNEL_SET") TSRMLS_CC);

		PHALCON_CALL_METHOD(NULL, background, "setImageAlphaChannel", mode);
	}

	PHALCON_INIT_NVAR(imagickpixel);
	object_init_ex(imagickpixel, imagick_pixel_ce);

	PHALCON_INIT_NVAR(color);
	ZVAL_STRING(color, "transparent", 1);

	PHALCON_CALL_METHOD(NULL, imagickpixel, "__construct", color);

	PHALCON_CALL_METHOD(NULL, background, "setImageBackgroundColor", imagickpixel);

	PHALCON_INIT_VAR(op_constant);
	phalcon_get_class_constant(op_constant, imagick_ce, SS("EVALUATE_MULTIPLY") TSRMLS_CC);

	PHALCON_INIT_NVAR(op);
	ZVAL_DOUBLE(op, phalcon_get_intval(opacity) / 100);

	PHALCON_INIT_VAR(channel);
	phalcon_get_class_constant(channel, imagick_ce, SS("CHANNEL_ALPHA") TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, background, "evaluateImage", op_constant, op, channel);

	PHALCON_CALL_METHOD(&ret, im, "getcolorspace");
	PHALCON_CALL_METHOD(NULL, background, "setcolorspace", ret);

	PHALCON_INIT_VAR(composite);
	phalcon_get_class_constant(composite, imagick_ce, SS("COMPOSITE_DISSOLVE") TSRMLS_CC);

	zero = PHALCON_GLOBAL(z_zero);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", zero);

	do {
		PHALCON_CALL_METHOD(&ret, background, "compositeImage", im, composite, zero, zero);

		if (!zend_is_true(ret)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "Imagick::background failed");
			return;
		}

		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	phalcon_update_property_this_quick(this_ptr, SL("_image"), background, 2440377831UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _blur){

	zval *radius;
	zval *im, *sigma, *next = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &radius);

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(sigma);
	ZVAL_DOUBLE(sigma, 100);

	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", PHALCON_GLOBAL(z_zero));

	do {
		PHALCON_CALL_METHOD(NULL, im, "blurImage", radius, sigma);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _pixelate){

	zval **amount, *index;
	zval *im, *width, *height, *tmp_width, *tmp_height, *next = NULL;
	int w, h;

	phalcon_fetch_params_ex(1, 0, &amount);
	PHALCON_ENSURE_IS_LONG(amount);

	if (Z_LVAL_PP(amount) < 2) {
		ZVAL_LONG(*amount, 2);
	}

	PHALCON_MM_GROW();

	im     = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);
	width  = phalcon_fetch_nproperty_this(this_ptr, SL("_width"), PH_NOISY TSRMLS_CC);
	height = phalcon_fetch_nproperty_this(this_ptr, SL("_height"), PH_NOISY TSRMLS_CC);

	w = (int)((phalcon_get_intval(width) / Z_LVAL_PP(amount)) + 0.5);
	h = (int)((phalcon_get_intval(height) / Z_LVAL_PP(amount)) + 0.5);

	PHALCON_INIT_VAR(tmp_width);
	PHALCON_INIT_VAR(tmp_height);

	ZVAL_LONG(tmp_width, w);
	ZVAL_LONG(tmp_height, h);

	index = PHALCON_GLOBAL(z_zero);
	PHALCON_CALL_METHOD(NULL, im, "setIteratorIndex", index);

	do {
		PHALCON_CALL_METHOD(NULL, im, "scaleImage", tmp_width, tmp_height);
		PHALCON_CALL_METHOD(NULL, im, "scaleImage", width, height);
		PHALCON_CALL_METHOD(&next, im, "nextImage");
	} while (zend_is_true(next));

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _save) {

	zval *file, *quality, *exception_message;
	zval *constant, *ret = NULL, *extension, *mime = NULL, *format, *type, *im, *fp = NULL, *mode, *compression;
	zend_class_entry *imagick_ce;
	char *ext;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &file, &quality);

	imagick_ce = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_INIT_VAR(constant);
	if (!zend_get_constant(SL("PATHINFO_EXTENSION"), constant TSRMLS_CC)) {
		RETURN_MM();
	}

	PHALCON_CALL_FUNCTION(&ret, "pathinfo", file, constant);

	PHALCON_INIT_VAR(extension);
	phalcon_fast_strtolower(extension, ret);

	PHALCON_INIT_VAR(format);
	phalcon_fast_strtolower(format, extension);

	ext = Z_STRVAL_P(format);

	PHALCON_INIT_VAR(type);
	if (strcmp(ext, "gif") == 0) {
		ZVAL_LONG(type, 1);
	} else if (strcmp(ext, "jpg") == 0 || strcmp(ext, "jpeg") == 0) {
		ZVAL_LONG(type, 2);
	} else if (strcmp(ext, "png") == 0) {
		ZVAL_LONG(type, 3);
	} else {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Installed ImageMagick does not support '", extension, "' images");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}

	PHALCON_OBS_VAR(im);
	phalcon_read_property_this(&im, this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setformat", format);
	PHALCON_CALL_METHOD(NULL, im, "setImageFormat", format);
	PHALCON_CALL_METHOD(NULL, im, "stripImage");

	if (phalcon_get_intval(type) == 1) {
		PHALCON_CALL_METHOD(NULL, im, "optimizeImageLayers");

		PHALCON_INIT_VAR(mode);
		ZVAL_STRING(mode, "w", 1);

		PHALCON_CALL_FUNCTION(&fp, "fopen", file, mode);
		if (Z_TYPE_P(fp) != IS_RESOURCE) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_image_exception_ce, "The image file cannot be saved");
			return;
		}

		PHALCON_CALL_METHOD(&ret, im, "writeImagesFile", fp);
		PHALCON_CALL_FUNCTION(NULL, "fclose", fp);
	} else {
		if (phalcon_get_intval(type) == 2) {
			PHALCON_INIT_VAR(compression);
			phalcon_get_class_constant(compression, imagick_ce, SS("COMPRESSION_JPEG") TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, im, "setImageCompression", compression );
		}

		PHALCON_CALL_METHOD(NULL, im, "setImageCompressionQuality", quality);
		PHALCON_CALL_METHOD(&ret, im, "writeImage", file);
	}

	if (zend_is_true(ret)) {
		phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

		PHALCON_CALL_FUNCTION(&mime, "image_type_to_mime_type", type);

		phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);

		RETVAL_TRUE;
	} else {
		RETVAL_FALSE;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, _render) {

	zval *extension, *quality, *exception_message;
	zval *mime = NULL, *format, *type, *im, *image_string = NULL, *compression;
	zend_class_entry *imagick_ce;
	char *ext;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &extension, &quality);

	imagick_ce = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);

	PHALCON_INIT_VAR(format);
	phalcon_fast_strtolower(format, extension);

	ext = Z_STRVAL_P(format);

	if (strncmp(ext, "gif", 3) == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 1);
	} else if (strncmp(ext, "jpg", 3) == 0 || strncmp(ext, "jpeg", 4) == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 2);
	} else if (strncmp(ext, "png", 3) == 0) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, 3);
	} else {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Installed ImageMagick does not support '", extension, "' images");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_image_exception_ce, exception_message);
		return;
	}

	PHALCON_OBS_VAR(im);
	phalcon_read_property_this(&im, this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, im, "setformat", format);
	PHALCON_CALL_METHOD(NULL, im, "setImageFormat", format);
	PHALCON_CALL_METHOD(NULL, im, "stripImage");

	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);

	PHALCON_CALL_FUNCTION(&mime, "image_type_to_mime_type", type);

	phalcon_update_property_this_quick(this_ptr, SL("_mime"), mime, 3983079404UL TSRMLS_CC);

	if (phalcon_get_intval(type) == 1) {
		PHALCON_CALL_METHOD(NULL, im, "optimizeImageLayers");
		PHALCON_CALL_METHOD(&image_string, im, "getImagesBlob");
	} else {
		if (phalcon_get_intval(type) == 2) {
			PHALCON_INIT_VAR(compression);
			phalcon_get_class_constant(compression, imagick_ce, SS("COMPRESSION_JPEG") TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, im, "setImageCompression", compression );
		}

		PHALCON_CALL_METHOD(NULL, im, "setImageCompressionQuality", quality);
		PHALCON_CALL_METHOD(&image_string, im, "getImageBlob");
	}
	RETURN_CTOR(image_string);
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, __destruct){

	zval *im;

	im = phalcon_fetch_nproperty_this(this_ptr, SL("_image"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(im) == IS_OBJECT) {
		PHALCON_CALL_METHODW(NULL, im, "destroy");
	}
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, getInternalImInstance)
{
	RETURN_MEMBER(getThis(), "_image");
}

static PHP_METHOD(Phalcon_Image_Adapter_Imagick, setResourceLimit)
{
	zval **resource, **limit;
	zval *im;
	zend_class_entry *imagick_ce;

	phalcon_fetch_params_ex(2, 0, &resource, &limit);

	imagick_ce = zend_fetch_class(SL("Imagick"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
	if (EXPECTED(imagick_ce != NULL)) {
		zval *params[] = { *resource, *limit };

		MAKE_STD_ZVAL(im);
		object_init_ex(im, imagick_ce);
		if (FAILURE == phalcon_call_method(NULL, im, "setresourcelimit", 2, params TSRMLS_CC)) {
			;
		}

		zval_ptr_dtor(&im);
	}
}





zend_class_entry *phalcon_loader_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Loader_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Loader, Exception, loader_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_logger_adapter_ce;

static PHP_METHOD(Phalcon_Logger_Adapter, setLogLevel);
static PHP_METHOD(Phalcon_Logger_Adapter, getLogLevel);
static PHP_METHOD(Phalcon_Logger_Adapter, setFormatter);
static PHP_METHOD(Phalcon_Logger_Adapter, isTransaction);
static PHP_METHOD(Phalcon_Logger_Adapter, begin);
static PHP_METHOD(Phalcon_Logger_Adapter, commit);
static PHP_METHOD(Phalcon_Logger_Adapter, rollback);
static PHP_METHOD(Phalcon_Logger_Adapter, emergency);
static PHP_METHOD(Phalcon_Logger_Adapter, alert);
static PHP_METHOD(Phalcon_Logger_Adapter, critical);
static PHP_METHOD(Phalcon_Logger_Adapter, error);
static PHP_METHOD(Phalcon_Logger_Adapter, warning);
static PHP_METHOD(Phalcon_Logger_Adapter, notice);
static PHP_METHOD(Phalcon_Logger_Adapter, info);
static PHP_METHOD(Phalcon_Logger_Adapter, debug);
static PHP_METHOD(Phalcon_Logger_Adapter, log);

static const zend_function_entry phalcon_logger_adapter_method_entry[] = {
	PHP_ME(Phalcon_Logger_Adapter, setLogLevel, arginfo_phalcon_logger_adapterinterface_setloglevel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, getLogLevel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, setFormatter, arginfo_phalcon_logger_adapterinterface_setformatter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, isTransaction, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, begin, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, commit, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, rollback, NULL, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Logger_Adapter, emergence, emergency, arginfo_phalcon_logger_adapterinterface_emergency, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_ME(Phalcon_Logger_Adapter, log, arginfo_phalcon_logger_adapterinterface_log, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, debug, arginfo_phalcon_logger_adapterinterface_debug, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, info, arginfo_phalcon_logger_adapterinterface_info, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, notice, arginfo_phalcon_logger_adapterinterface_notice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, warning, arginfo_phalcon_logger_adapterinterface_warning, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, error, arginfo_phalcon_logger_adapterinterface_error, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, critical, arginfo_phalcon_logger_adapterinterface_critical, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, alert, arginfo_phalcon_logger_adapterinterface_alert, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter, emergency, arginfo_phalcon_logger_adapterinterface_emergency, ZEND_ACC_PUBLIC)
	ZEND_FENTRY(logInternal, NULL, arginfo_phalcon_logger_adapter_loginternal, ZEND_ACC_PROTECTED | ZEND_ACC_ABSTRACT)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Adapter, logger_adapter, phalcon_logger_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_bool(phalcon_logger_adapter_ce, SL("_transaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_ce, SL("_queue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_ce, SL("_formatter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_logger_adapter_ce, SL("_logLevel"), PHALCON_LOGGER_SPECIAL, ZEND_ACC_PROTECTED TSRMLS_CC);

	/* Prior to PHP 5.3.9, a class could not implement two interfaces
	 * that specified a method with the same name, since it would cause
	 * ambiguity. More recent versions of PHP allow this as long as
	 * the duplicate methods have the same signature.
	 */
#if PHP_VERSION_ID >= 50309
	if (PHALCON_GLOBAL(register_psr3_classes)) {
		zend_class_implements(phalcon_logger_adapter_ce TSRMLS_CC, 2, phalcon_logger_adapterinterface_ce, psr_log_loggerinterface_ce);
	}
	else {
		zend_class_implements(phalcon_logger_adapter_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);
	}
#else
	zend_class_implements(phalcon_logger_adapter_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);
#endif
	return SUCCESS;
}

static int phalcon_logger_adapter_string_level_to_int(const zval *level)
{
	const char *s = Z_STRVAL_P(level);
	size_t len    = (size_t)(Z_STRLEN_P(level));
	size_t i;

	struct sl {
		const char *str;
		size_t len;
		int level;
	};

	static struct sl lookup_table[] = {
		{ ZEND_STRL("emergency"), PHALCON_LOGGER_EMERGENCY },
		{ ZEND_STRL("alert"),     PHALCON_LOGGER_ALERT     },
		{ ZEND_STRL("critical"),  PHALCON_LOGGER_CRITICAL  },
		{ ZEND_STRL("error"),     PHALCON_LOGGER_ERROR     },
		{ ZEND_STRL("warning"),   PHALCON_LOGGER_WARNING   },
		{ ZEND_STRL("notice"),    PHALCON_LOGGER_NOTICE    },
		{ ZEND_STRL("info"),      PHALCON_LOGGER_INFO      },
		{ ZEND_STRL("debug"),     PHALCON_LOGGER_DEBUG     }
	};

	assert(Z_TYPE_P(level) == IS_STRING);

	for (i=0; i<sizeof(lookup_table)/sizeof(lookup_table[0]); ++i) {
		if (lookup_table[i].len == len && !memcmp(lookup_table[i].str, s, len)) {
			return lookup_table[i].level;
		}
	}

	{
		TSRMLS_FETCH();
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Unrecognized log level '%s'", s);
		return PHALCON_LOGGER_CUSTOM;
	}
}

static PHP_METHOD(Phalcon_Logger_Adapter, setLogLevel){

	zval **level, *lvl;

	phalcon_fetch_params_ex(1, 0, &level);
	if (Z_TYPE_PP(level) == IS_STRING) {
		PHALCON_ALLOC_GHOST_ZVAL(lvl);
		ZVAL_LONG(lvl, phalcon_logger_adapter_string_level_to_int(*level));
	}
	else if (Z_TYPE_PP(level) != IS_LONG) {
		PHALCON_ENSURE_IS_LONG(level);
		lvl = *level;
	}
	else {
		lvl = *level;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_logLevel"), lvl, 4227944734UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Logger_Adapter, getLogLevel){


	RETURN_MEMBER_QUICK(this_ptr, "_logLevel", 4227944734UL);
}

static PHP_METHOD(Phalcon_Logger_Adapter, setFormatter){

	zval *formatter;
	zend_class_entry *exception = PHALCON_GLOBAL(register_psr3_classes) ? psr_log_invalidargumentexception_ce : phalcon_logger_exception_ce;

	phalcon_fetch_params(0, 1, 0, &formatter);
	PHALCON_VERIFY_INTERFACE_EX(formatter, phalcon_logger_formatterinterface_ce, exception, 0);

	phalcon_update_property_this_quick(this_ptr, SL("_formatter"), formatter, 1838243768UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Logger_Adapter, isTransaction){

	RETURN_MEMBER_QUICK(this_ptr, "_transaction", 1141465066UL);
}

static PHP_METHOD(Phalcon_Logger_Adapter, begin){


	phalcon_update_property_bool(this_ptr, SL("_transaction"), 1 TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Logger_Adapter, commit){

	zval *transaction, *queue, *message_str = NULL;
	zval *type = NULL, *time = NULL, *context = NULL;

	transaction = phalcon_fetch_nproperty_this(this_ptr, SL("_transaction"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(transaction)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	/* Check if the queue has something to log */
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(queue) == IS_ARRAY) { 
		HashPosition hp;
		zval **message;

		PHALCON_MM_GROW();

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(queue), &hp);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(queue), (void**)&message, &hp) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(queue), &hp)
		) {
			PHALCON_CALL_METHOD(&message_str, *message, "getmessage");
			PHALCON_CALL_METHOD(&type, *message, "gettype");
			PHALCON_CALL_METHOD(&time, *message, "gettime");
			PHALCON_CALL_METHOD(&context, *message, "getcontext");
			PHALCON_CALL_METHOD(NULL, this_ptr, "loginternal", message_str, type, time, context);
		}

		if (Z_REFCOUNT_P(queue) == 1 || Z_ISREF_P(queue)) {
			zend_hash_clean(Z_ARRVAL_P(queue));
		}
		else {
			PHALCON_ALLOC_GHOST_ZVAL(queue);
			array_init(queue);
			phalcon_update_property_this(getThis(), SL("_queue"), queue TSRMLS_CC);
		}

		PHALCON_MM_RESTORE();
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Logger_Adapter, rollback){

	zval *transaction, *queue;

	transaction = phalcon_fetch_nproperty_this(this_ptr, SL("_transaction"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(transaction)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_logger_exception_ce, "There is no active transaction");
		return;
	}
	
	phalcon_update_property_bool(this_ptr, SL("_transaction"), 0 TSRMLS_CC);
	
	PHALCON_ALLOC_GHOST_ZVAL(queue);
	array_init_size(queue, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_queue"), queue, 2763107337UL TSRMLS_CC);
	
	RETURN_THISW();
}

static void phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAMETERS, int level)
{
	zval **message, **context = NULL, *type;

	phalcon_fetch_params_ex(1, 1, &message, &context);
	PHALCON_ENSURE_IS_STRING(message);

	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, level);

	if (!context) {
		context = &PHALCON_GLOBAL(z_null);
	}

	PHALCON_CALL_METHODW(NULL, getThis(), "log", type, *message, *context);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Logger_Adapter, emergency){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_EMERGENCY);
}

static PHP_METHOD(Phalcon_Logger_Adapter, debug){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_DEBUG);
}

static PHP_METHOD(Phalcon_Logger_Adapter, error){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_ERROR);
}

static PHP_METHOD(Phalcon_Logger_Adapter, info){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_INFO);
}

static PHP_METHOD(Phalcon_Logger_Adapter, notice){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_NOTICE);
}

static PHP_METHOD(Phalcon_Logger_Adapter, warning){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_WARNING);
}

static PHP_METHOD(Phalcon_Logger_Adapter, alert){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_ALERT);
}

static PHP_METHOD(Phalcon_Logger_Adapter, critical){

	phalcon_logger_adapter_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHALCON_LOGGER_CRITICAL);
}

static PHP_METHOD(Phalcon_Logger_Adapter, log){

	zval **message = NULL, **type, **context = NULL, *timestamp, *transaction;
	zval *queue_item, *log_level, *level;
	int i_level;

	phalcon_fetch_params_ex(1, 2, &type, &message, &context);

	if (message == NULL) {
		message = type;
		type    = NULL;
	}
	else if (Z_TYPE_PP(message) == IS_LONG && Z_TYPE_PP(type) == IS_STRING) {
		zval **tmp = message;
		message    = type;
		type       = tmp;
	}

	if (!context) {
		context = &PHALCON_GLOBAL(z_null);
	}

	if (!type) {
		i_level = PHALCON_LOGGER_DEBUG;
	}
	else if (Z_TYPE_PP(type) == IS_STRING) {
		i_level = phalcon_logger_adapter_string_level_to_int(*type);
	}
	else {
		PHALCON_ENSURE_IS_LONG(type);
		i_level = Z_LVAL_PP(type);
	}

	log_level = phalcon_fetch_nproperty_this(this_ptr, SL("_logLevel"), PH_NOISY TSRMLS_CC);

	/* Only log the message if this is allowed by the current log level */
	if (phalcon_get_intval(log_level) >= i_level) {
		PHALCON_MM_GROW();

		PHALCON_INIT_VAR(timestamp);
		ZVAL_LONG(timestamp, (long)time(NULL));

		PHALCON_INIT_VAR(level);
		ZVAL_LONG(level, i_level);

		transaction = phalcon_fetch_nproperty_this(this_ptr, SL("_transaction"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(transaction)) {
			PHALCON_INIT_VAR(queue_item);
			object_init_ex(queue_item, phalcon_logger_item_ce);
			PHALCON_CALL_METHOD(NULL, queue_item, "__construct", *message, level, timestamp, *context);

			phalcon_update_property_array_append(this_ptr, SL("_queue"), queue_item TSRMLS_CC);
		}
		else {
			PHALCON_CALL_METHOD(NULL, this_ptr, "loginternal", *message, level, timestamp, *context);
		}

		PHALCON_MM_RESTORE();
	}

	RETURN_THISW();
}





zend_class_entry *phalcon_logger_adapterinterface_ce;

static const zend_function_entry phalcon_logger_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, setFormatter, arginfo_phalcon_logger_adapterinterface_setformatter)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, getFormatter, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, setLogLevel, arginfo_phalcon_logger_adapterinterface_setloglevel)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, getLogLevel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, begin, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, commit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, rollback, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, close, NULL)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, log, arginfo_phalcon_logger_adapterinterface_log)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, debug, arginfo_phalcon_logger_adapterinterface_debug)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, info, arginfo_phalcon_logger_adapterinterface_info)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, notice, arginfo_phalcon_logger_adapterinterface_notice)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, warning, arginfo_phalcon_logger_adapterinterface_warning)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, error, arginfo_phalcon_logger_adapterinterface_error)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, critical, arginfo_phalcon_logger_adapterinterface_critical)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, alert, arginfo_phalcon_logger_adapterinterface_alert)
	PHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, emergency, arginfo_phalcon_logger_adapterinterface_emergency)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Logger, AdapterInterface, logger_adapterinterface, phalcon_logger_adapterinterface_method_entry);

	return SUCCESS;
}






















zend_class_entry *phalcon_logger_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Logger_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger, Exception, logger_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}




#include <main/spprintf.h>


zend_class_entry *phalcon_logger_formatter_ce;

static PHP_METHOD(Phalcon_Logger_Formatter, getTypeString);
static PHP_METHOD(Phalcon_Logger_Formatter, interpolate);

static const zend_function_entry phalcon_logger_formatter_method_entry[] = {
	PHP_ME(Phalcon_Logger_Formatter, getTypeString, arginfo_phalcon_logger_formatter_gettypestring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter, interpolate, arginfo_phalcon_logger_formatter_interpolate, ZEND_ACC_PROTECTED)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Formatter){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Formatter, logger_formatter, phalcon_logger_formatter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_class_implements(phalcon_logger_formatter_ce TSRMLS_CC, 1, phalcon_logger_formatterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Formatter, getTypeString){

	static const char *lut[10] = {
		"EMERGENCY", "CRITICAL", "ALERT", "ERROR",  "WARNING",
		"NOTICE",    "INFO",     "DEBUG", "CUSTOM", "SPECIAL"
	};

	zval **type;
	int itype;

	phalcon_fetch_params_ex(1, 0, &type);
	PHALCON_ENSURE_IS_LONG(type);
	
	itype = Z_LVAL_PP(type);
	if (itype >= 0 && itype < 10) {
		RETURN_STRING(lut[itype], 1);
	}
	
	RETURN_STRING("CUSTOM", 1);
}

static PHP_METHOD(Phalcon_Logger_Formatter, interpolate)
{
	zval **message, **context;

	phalcon_fetch_params_ex(2, 0, &message, &context);

	if (Z_TYPE_PP(context) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_PP(context)) > 0) {
		HashTable *ht = Z_ARRVAL_PP(context);
		HashPosition hp;
		zval *replace, **val;

		PHALCON_ALLOC_GHOST_ZVAL(replace);
		array_init_size(replace, zend_hash_num_elements(ht));

		for (
			zend_hash_internal_pointer_reset_ex(ht, &hp);
			zend_hash_get_current_data_ex(ht, (void**)&val, &hp) == SUCCESS;
			zend_hash_move_forward_ex(ht, &hp)
		) {
			char *str_index, *idx;
			uint str_length;
			ulong num_index;
			int type = zend_hash_get_current_key_ex(ht, &str_index, &str_length, &num_index, 0, &hp);

			if (HASH_KEY_IS_STRING == type) {
				str_length       += 2;
				idx               = emalloc(str_length);
				idx[0]            = '{';
				idx[str_length-2] = '}';
				idx[str_length-1] = '\0';
				memcpy(idx + 1, str_index, str_length - 3);
			}
			else if (HASH_KEY_IS_LONG == type) {
				str_length = spprintf(&idx, 0, "{%ld}", num_index);
			}
			else { /* Better safe than sorry */
				continue;
			}

			Z_ADDREF_PP(val);
			zend_hash_add(Z_ARRVAL_P(replace), idx, str_length, (void*)val, sizeof(zval*), NULL);
			efree(idx);
		}

		PHALCON_RETURN_CALL_FUNCTIONW("strtr", *message, replace);
		return;
	}

	RETURN_ZVAL(*message, 1, 0);
}





zend_class_entry *phalcon_logger_formatterinterface_ce;

static const zend_function_entry phalcon_logger_formatterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Logger_FormatterInterface, format, arginfo_phalcon_logger_formatterinterface_format)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_FormatterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Logger, FormatterInterface, logger_formatterinterface, phalcon_logger_formatterinterface_method_entry);

	return SUCCESS;
}







zend_class_entry *phalcon_logger_item_ce;

static PHP_METHOD(Phalcon_Logger_Item, __construct);
static PHP_METHOD(Phalcon_Logger_Item, getMessage);
static PHP_METHOD(Phalcon_Logger_Item, getType);
static PHP_METHOD(Phalcon_Logger_Item, getTime);
static PHP_METHOD(Phalcon_Logger_Item, getContext);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_item___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, message)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, time)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_item_method_entry[] = {
	PHP_ME(Phalcon_Logger_Item, __construct, arginfo_phalcon_logger_item___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Logger_Item, getMessage, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Item, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Item, getTime, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Item, getContext, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Item){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Item, logger_item, phalcon_logger_item_method_entry, 0);

	zend_declare_property_null(phalcon_logger_item_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_time"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_item_ce, SL("_context"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Item, __construct){

	zval *message, *type, *time = NULL, *context = NULL;

	phalcon_fetch_params(0, 2, 2, &message, &type, &time, &context);
	
	if (!time) {
		time = PHALCON_GLOBAL(z_zero);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_time"), time, 3991380851UL TSRMLS_CC);

	if (context && Z_TYPE_P(context) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_context"), context, 4081329161UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Logger_Item, getMessage){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Logger_Item, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Logger_Item, getTime){


	RETURN_MEMBER_QUICK(this_ptr, "_time", 3991380851UL);
}

static PHP_METHOD(Phalcon_Logger_Item, getContext) {

	zval *context = phalcon_fetch_nproperty_this(getThis(), SL("_context"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(context) == IS_ARRAY) {
		RETURN_ZVAL(context, 1, 0);
	}

	array_init(return_value);
}






zend_class_entry *phalcon_logger_multiple_ce;

static PHP_METHOD(Phalcon_Logger_Multiple, push);
static PHP_METHOD(Phalcon_Logger_Multiple, getLoggers);
static PHP_METHOD(Phalcon_Logger_Multiple, setFormatter);
static PHP_METHOD(Phalcon_Logger_Multiple, getFormatter);
static PHP_METHOD(Phalcon_Logger_Multiple, log);
static PHP_METHOD(Phalcon_Logger_Multiple, emergency);
static PHP_METHOD(Phalcon_Logger_Multiple, debug);
static PHP_METHOD(Phalcon_Logger_Multiple, error);
static PHP_METHOD(Phalcon_Logger_Multiple, info);
static PHP_METHOD(Phalcon_Logger_Multiple, notice);
static PHP_METHOD(Phalcon_Logger_Multiple, warning);
static PHP_METHOD(Phalcon_Logger_Multiple, alert);
static PHP_METHOD(Phalcon_Logger_Multiple, critical); 

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_multiple_push, 0, 0, 1)
	ZEND_ARG_INFO(0, logger)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_multiple_method_entry[] = {
	PHP_ME(Phalcon_Logger_Multiple, push, arginfo_phalcon_logger_multiple_push, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, getLoggers, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, setFormatter, arginfo_phalcon_logger_adapterinterface_setformatter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, getFormatter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, log, arginfo_phalcon_logger_adapterinterface_log, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, emergency, arginfo_phalcon_logger_adapterinterface_emergency, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Logger_Multiple, emergence, emergency, arginfo_phalcon_logger_adapterinterface_emergency, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_ME(Phalcon_Logger_Multiple, debug, arginfo_phalcon_logger_adapterinterface_debug, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, error, arginfo_phalcon_logger_adapterinterface_error, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, info, arginfo_phalcon_logger_adapterinterface_info, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, notice, arginfo_phalcon_logger_adapterinterface_notice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, warning, arginfo_phalcon_logger_adapterinterface_warning, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Multiple, alert, arginfo_phalcon_logger_adapterinterface_alert, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Multiple){

	PHALCON_REGISTER_CLASS(Phalcon\\Logger, Multiple, logger_multiple, phalcon_logger_multiple_method_entry, 0);

	zend_declare_property_null(phalcon_logger_multiple_ce, SL("_loggers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_multiple_ce, SL("_formatter"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Multiple, push){

	zval *logger;
	zend_class_entry *exception = PHALCON_GLOBAL(register_psr3_classes) ? psr_log_invalidargumentexception_ce : phalcon_logger_exception_ce;

	phalcon_fetch_params(0, 1, 0, &logger);
	
	PHALCON_VERIFY_INTERFACE_EX(logger, phalcon_logger_adapterinterface_ce, exception, 0)
	phalcon_update_property_array_append(this_ptr, SL("_loggers"), logger TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Logger_Multiple, getLoggers){


	RETURN_MEMBER_QUICK(this_ptr, "_loggers", 810888023UL);
}

static PHP_METHOD(Phalcon_Logger_Multiple, setFormatter){

	zval *formatter, *loggers, *logger = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &formatter);
	
	PHALCON_OBS_VAR(loggers);
	phalcon_read_property_this(&loggers, this_ptr, SL("_loggers"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(loggers) == IS_ARRAY) { 
	
		phalcon_is_iterable(loggers, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(logger);
	
			PHALCON_CALL_METHOD(NULL, logger, "setformatter", formatter);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_formatter"), formatter, 1838243768UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, getFormatter){


	RETURN_MEMBER_QUICK(this_ptr, "_formatter", 1838243768UL);
}

static PHP_METHOD(Phalcon_Logger_Multiple, log){

	zval *message, *type = NULL, *context = NULL, *loggers, *logger = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &message, &type, &context);
	
	if (!type) {
		PHALCON_INIT_VAR(type);
		ZVAL_LONG(type, PHALCON_LOGGER_DEBUG);
	}

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}

	PHALCON_OBS_VAR(loggers);
	phalcon_read_property_this(&loggers, this_ptr, SL("_loggers"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(loggers) == IS_ARRAY) { 
	
		phalcon_is_iterable(loggers, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(logger);
	
			PHALCON_CALL_METHOD(NULL, logger, "log", message, type, context);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, emergency){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_EMERGENCY);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, debug){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_DEBUG);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, error){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_ERROR);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, info){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_INFO);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, notice){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_NOTICE);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, warning){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_WARNING);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, alert){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_ALERT);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Multiple, critical){

	zval *message, *type, *context = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &context);

	if (!context) {
		context = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(type);
	ZVAL_LONG(type, PHALCON_LOGGER_CRITICAL);
	PHALCON_CALL_METHOD(NULL, this_ptr, "log", message, type, context);
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_logger_adapter_file_ce;

static PHP_METHOD(Phalcon_Logger_Adapter_File, __construct);
static PHP_METHOD(Phalcon_Logger_Adapter_File, getFormatter);
static PHP_METHOD(Phalcon_Logger_Adapter_File, logInternal);
static PHP_METHOD(Phalcon_Logger_Adapter_File, close);
static PHP_METHOD(Phalcon_Logger_Adapter_File, getPath);
static PHP_METHOD(Phalcon_Logger_Adapter_File, __wakeup);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_adapter_file___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_adapter_file_method_entry[] = {
	PHP_ME(Phalcon_Logger_Adapter_File, __construct, arginfo_phalcon_logger_adapter_file___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Logger_Adapter_File, getFormatter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_File, logInternal, arginfo_phalcon_logger_adapter_loginternal, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Logger_Adapter_File, close, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_File, getPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_File, __wakeup, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Adapter_File){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Adapter, File, logger_adapter_file, phalcon_logger_adapter_ce, phalcon_logger_adapter_file_method_entry, 0);

	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_fileHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_path"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_logger_adapter_file_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_adapter_file_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, __construct){

	zval **name, **options = NULL, *mode = NULL, *handler = NULL;
	zend_class_entry *exception = PHALCON_GLOBAL(register_psr3_classes) ? psr_log_invalidargumentexception_ce : phalcon_logger_exception_ce;

	phalcon_fetch_params_ex(1, 1, &name, &options);
	PHALCON_ENSURE_IS_STRING(name);

	PHALCON_MM_GROW();

	if (!options) {
		options = &PHALCON_GLOBAL(z_null);
	}
	
	if (phalcon_array_isset_string_fetch(&mode, *options, SS("mode"))) {
		if (phalcon_memnstr_str(mode, SL("r"))) {
			PHALCON_THROW_EXCEPTION_STR(exception, "Logger must be opened in append or write mode");
			return;
		}
	} else {
		PHALCON_INIT_VAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}
	
	PHALCON_CALL_FUNCTION(&handler, "fopen", *name, mode);
	if (Z_TYPE_P(handler) != IS_RESOURCE) {
		zend_throw_exception_ex(exception, 0 TSRMLS_CC, "Cannot open log file '%s'", Z_STRVAL_PP(name));
	}
	else {
		phalcon_update_property_this(this_ptr, SL("_path"), *name TSRMLS_CC);
		phalcon_update_property_this(this_ptr, SL("_options"), *options TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_fileHandler"), handler, 1678121186UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, getFormatter){

	zval *formatter = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(formatter);
	phalcon_read_property_this(&formatter, this_ptr, SL("_formatter"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(formatter) != IS_OBJECT) {
		PHALCON_INIT_NVAR(formatter);
		object_init_ex(formatter, phalcon_logger_formatter_line_ce);
		PHALCON_CALL_METHOD(NULL, formatter, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_formatter"), formatter, 1838243768UL TSRMLS_CC);
	}
	
	RETURN_CTOR(formatter);
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, logInternal){

	zval *message, *type, *time, *file_handler, *formatter = NULL, *context;
	zval *applied_format = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &time, &context);
	
	file_handler = phalcon_fetch_nproperty_this(this_ptr, SL("_fileHandler"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(file_handler) != IS_RESOURCE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "Cannot send message to the log because it is invalid");
		return;
	}
	
	PHALCON_CALL_METHOD(&formatter, this_ptr, "getformatter");
	PHALCON_CALL_METHOD(&applied_format, formatter, "format", message, type, time, context);
	PHALCON_CALL_FUNCTION(NULL, "fwrite", file_handler, applied_format);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, close){

	zval *file_handler;

	PHALCON_MM_GROW();

	file_handler = phalcon_fetch_nproperty_this(this_ptr, SL("_fileHandler"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_FUNCTION("fclose", file_handler);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, getPath) {

	RETURN_MEMBER(getThis(), "_path");
}

static PHP_METHOD(Phalcon_Logger_Adapter_File, __wakeup){

	zval *path, *options, *mode = NULL, *file_handler = NULL;
	zend_class_entry *exception = PHALCON_GLOBAL(register_psr3_classes) ? psr_log_invalidargumentexception_ce : phalcon_logger_exception_ce;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(path);
	phalcon_read_property_this(&path, this_ptr, SL("_path"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(path) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(exception, "Invalid data passed to Phalcon\\Logger\\Adapter\\File::__wakeup()");
		return;
	}

	PHALCON_OBS_VAR(options);
	phalcon_read_property_this(&options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(options, SS("mode"), 267518858UL)) {
		PHALCON_OBS_VAR(mode);
		phalcon_array_fetch_quick_string(&mode, options, SS("mode"), 267518858UL, PH_NOISY);
		if (Z_TYPE_P(mode) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(exception, "Invalid data passed to Phalcon\\Logger\\Adapter\\File::__wakeup()");
			return;
		}
	} else {
		PHALCON_INIT_NVAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}

	PHALCON_CALL_FUNCTION(&file_handler, "fopen", path, mode);
	phalcon_update_property_this_quick(this_ptr, SL("_fileHandler"), file_handler, 1678121186UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}





#include <main/SAPI.h>
#include <ext/standard/php_smart_str.h>


zend_class_entry *phalcon_logger_adapter_firephp_ce;

static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, getFormatter);
static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, logInternal);
static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, close);

static const zend_function_entry phalcon_logger_adapter_firephp_method_entry[] = {
	PHP_ME(Phalcon_Logger_Adapter_Firephp, getFormatter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_Firephp, logInternal, arginfo_phalcon_logger_adapter_loginternal, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Logger_Adapter_Firephp, close, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Adapter_Firephp){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Adapter, Firephp, logger_adapter_firephp, phalcon_logger_adapter_ce, phalcon_logger_adapter_firephp_method_entry, 0);

	zend_declare_property_bool(phalcon_logger_adapter_firephp_ce, SL("_initialized"), 0, ZEND_ACC_PRIVATE | ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_long(phalcon_logger_adapter_firephp_ce, SL("_index"), 1, ZEND_ACC_PRIVATE | ZEND_ACC_STATIC TSRMLS_CC);

	zend_class_implements(phalcon_logger_adapter_firephp_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, getFormatter){

	zval *formatter;

	formatter = phalcon_fetch_nproperty_this(this_ptr, SL("_formatter"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(formatter) != IS_OBJECT) {
		object_init_ex(return_value, phalcon_logger_formatter_firephp_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_formatter"), return_value, 1838243768UL TSRMLS_CC);
		return;
	}

	RETURN_ZVAL(formatter, 1, 0);
}

static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, logInternal){

	zval *message, *type, *time, *context, *formatter = NULL, *applied_format = NULL;
	zval *initialized, *index;
	sapi_header_line h = { NULL, 0, 0 };
	smart_str str      = { NULL, 0, 0 };
	int size, offset;
	int separate_index = 0;
	size_t num_bytes;
	const int chunk = 4500;

	/* If headers has already been sent, we can do nothing. Exit early. */
	if (SG(headers_sent)) {
		RETURN_FALSE;
	}

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &time, &context);

	PHALCON_CALL_METHOD(&formatter, this_ptr, "getformatter");

	initialized = phalcon_fetch_static_property_ce(phalcon_logger_adapter_firephp_ce, SL("_initialized") TSRMLS_CC);
	if (!zend_is_true(initialized)) {
		h.line     = "X-Wf-Protocol-1: http://meta.wildfirehq.org/Protocol/JsonStream/0.2";
		h.line_len = sizeof("X-Wf-Protocol-1: http://meta.wildfirehq.org/Protocol/JsonStream/0.2")-1;
		sapi_header_op(SAPI_HEADER_REPLACE, &h TSRMLS_CC);

		h.line     = "X-Wf-1-Plugin-1: http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/0.3";
		h.line_len = sizeof("X-Wf-1-Plugin-1: http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/0.3")-1;
		sapi_header_op(SAPI_HEADER_REPLACE, &h TSRMLS_CC);

		h.line     = "X-Wf-1-Structure-1: http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1";
		h.line_len = sizeof("X-Wf-1-Structure-1: http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1")-1;
		sapi_header_op(SAPI_HEADER_REPLACE, &h TSRMLS_CC);

		ZVAL_TRUE(initialized); /* This will also update the property because "initialized" was not separated */
	}

	PHALCON_CALL_METHOD(&applied_format, formatter, "format", message, type, time, context);
	convert_to_string(applied_format);

	index = phalcon_fetch_static_property_ce(phalcon_logger_adapter_firephp_ce, SL("_index") TSRMLS_CC);
	assert(Z_TYPE_P(index) == IS_LONG);

	if (Z_REFCOUNT_P(index) > 1) {
		PHALCON_INIT_VAR(index);
		separate_index = 1;
	}

	size   = Z_STRLEN_P(applied_format);
	offset = 0;

	smart_str_alloc4(&str, (uint)(size > chunk ? chunk : size), 0, num_bytes);

	while (size > 0) {
		smart_str_appends(&str, "X-Wf-1-1-1-");
		smart_str_append_long(&str, Z_LVAL_P(index));
		smart_str_appends(&str, ": ");
		num_bytes = size > chunk ? chunk : size;

		if (offset) {
			/* This is not the first chunk, prepend the payload with "|" */
			smart_str_appendc(&str, '|');
		}

		/* Grab the chunk from the encoded string */
		smart_str_appendl(&str, Z_STRVAL_P(applied_format) + offset, num_bytes);

		size   -= num_bytes;
		offset += num_bytes;

		if (size) {
			/* If we have more data to send, append "|/" */
			smart_str_appendl(&str, "|\\", 2);
		}

		smart_str_0(&str); /* Not strictly necessary but just to be safe */

		/* Send the result */
		h.line     = str.c;
		h.line_len = str.len;
		sapi_header_op(SAPI_HEADER_REPLACE, &h TSRMLS_CC);

		ZVAL_LONG(index, Z_LVAL_P(index)+1);

		str.len = 0;
	}

	if (separate_index) {
		phalcon_update_static_property_ce(phalcon_logger_adapter_firephp_ce, SL("_index"), index TSRMLS_CC);
	}

	/* Deallocate the smnart string if it is not empty */
	if (str.c) {
		smart_str_free(&str);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_Firephp, close){

	RETURN_TRUE;
}







zend_class_entry *phalcon_logger_adapter_stream_ce;

static PHP_METHOD(Phalcon_Logger_Adapter_Stream, __construct);
static PHP_METHOD(Phalcon_Logger_Adapter_Stream, getFormatter);
static PHP_METHOD(Phalcon_Logger_Adapter_Stream, logInternal);
static PHP_METHOD(Phalcon_Logger_Adapter_Stream, close);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_adapter_stream___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_adapter_stream_method_entry[] = {
	PHP_ME(Phalcon_Logger_Adapter_Stream, __construct, arginfo_phalcon_logger_adapter_stream___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Logger_Adapter_Stream, getFormatter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_Stream, logInternal, arginfo_phalcon_logger_adapter_loginternal, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Logger_Adapter_Stream, close, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Adapter_Stream){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Adapter, Stream, logger_adapter_stream, phalcon_logger_adapter_ce, phalcon_logger_adapter_stream_method_entry, 0);

	zend_declare_property_null(phalcon_logger_adapter_stream_ce, SL("_stream"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_adapter_stream_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Adapter_Stream, __construct){

	zval **name, **options = NULL, *mode = NULL, *stream = NULL;
	zend_class_entry *exception = PHALCON_GLOBAL(register_psr3_classes) ? psr_log_invalidargumentexception_ce : phalcon_logger_exception_ce;

	phalcon_fetch_params_ex(1, 1, &name, &options);
	PHALCON_ENSURE_IS_STRING(name);

	PHALCON_MM_GROW();
	
	if (!options) {
		options = &PHALCON_GLOBAL(z_null);
	}
	
	if (phalcon_array_isset_string_fetch(&mode, *options, SS("mode"))) {
		if (phalcon_memnstr_str(mode, SL("r"))) {
			PHALCON_THROW_EXCEPTION_STR(exception, "Stream must be opened in append or write mode");
			return;
		}
	} else {
		PHALCON_INIT_VAR(mode);
		ZVAL_STRING(mode, "ab", 1);
	}
	
	PHALCON_CALL_FUNCTION(&stream, "fopen", *name, mode);
	if (Z_TYPE_P(stream) != IS_RESOURCE) {
		zend_throw_exception_ex(exception, 0 TSRMLS_CC, "Cannot open stream '%s'", Z_STRVAL_PP(name));
	}
	else {
		phalcon_update_property_this_quick(this_ptr, SL("_stream"), stream, 3546870672UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_Stream, getFormatter){

	zval *formatter = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(formatter);
	phalcon_read_property_this(&formatter, this_ptr, SL("_formatter"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(formatter) != IS_OBJECT) {
		PHALCON_INIT_NVAR(formatter);
		object_init_ex(formatter, phalcon_logger_formatter_line_ce);
		PHALCON_CALL_METHOD(NULL, formatter, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_formatter"), formatter, 1838243768UL TSRMLS_CC);
	}
	
	RETURN_CTOR(formatter);
}

static PHP_METHOD(Phalcon_Logger_Adapter_Stream, logInternal){

	zval *message, *type, *time, *context, *stream, *formatter = NULL, *applied_format = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &time, &context);
	
	stream = phalcon_fetch_nproperty_this(this_ptr, SL("_stream"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(stream) != IS_RESOURCE) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_logger_exception_ce, "Cannot send message to the log because it is invalid");
		return;
	}
	
	PHALCON_CALL_METHOD(&formatter, this_ptr, "getformatter");
	PHALCON_CALL_METHOD(&applied_format, formatter, "format", message, type, time, context);
	PHALCON_CALL_FUNCTION(NULL, "fwrite", stream, applied_format);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_Stream, close)
{
	zval *stream = phalcon_fetch_nproperty_this(this_ptr, SL("_stream"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_FUNCTIONW("fclose", stream);
}






zend_class_entry *phalcon_logger_adapter_syslog_ce;

static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, __construct);
static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, getFormatter);
static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, logInternal);
static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, close);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_adapter_syslog___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_adapter_syslog_method_entry[] = {
	PHP_ME(Phalcon_Logger_Adapter_Syslog, __construct, arginfo_phalcon_logger_adapter_syslog___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Logger_Adapter_Syslog, getFormatter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Adapter_Syslog, logInternal, arginfo_phalcon_logger_adapter_loginternal, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Logger_Adapter_Syslog, close, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Adapter_Syslog){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Adapter, Syslog, logger_adapter_syslog, phalcon_logger_adapter_ce, phalcon_logger_adapter_syslog_method_entry, 0);

	zend_declare_property_bool(phalcon_logger_adapter_syslog_ce, SL("_opened"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_adapter_syslog_ce TSRMLS_CC, 1, phalcon_logger_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, __construct){

	zval *name, *options = NULL, *option = NULL, *facility = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &name, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (zend_is_true(name)) {
		if (phalcon_array_isset_quick_string(options, SS("option"), 1911574558UL)) {
			PHALCON_OBS_VAR(option);
			phalcon_array_fetch_quick_string(&option, options, SS("option"), 1911574558UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(option);
			ZVAL_LONG(option, 4);
		}
		if (phalcon_array_isset_quick_string(options, SS("facility"), 2721335866UL)) {
			PHALCON_OBS_VAR(facility);
			phalcon_array_fetch_quick_string(&facility, options, SS("facility"), 2721335866UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(facility);
			ZVAL_LONG(facility, 8);
		}
	
		PHALCON_CALL_FUNCTION(NULL, "openlog", name, option, facility);
		phalcon_update_property_bool(this_ptr, SL("_opened"), 1 TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, getFormatter){

	zval *formatter = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(formatter);
	phalcon_read_property_this(&formatter, this_ptr, SL("_formatter"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(formatter) != IS_OBJECT) {
		PHALCON_INIT_NVAR(formatter);
		object_init_ex(formatter, phalcon_logger_formatter_syslog_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_formatter"), formatter, 1838243768UL TSRMLS_CC);
	}
	
	RETURN_CTOR(formatter);
}

static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, logInternal){

	zval *message, *type, *time, *context, *formatter = NULL, *applied_format = NULL;
	zval *syslog_type, *syslog_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &time, &context);
	
	PHALCON_CALL_METHOD(&formatter, this_ptr, "getformatter");
	PHALCON_CALL_METHOD(&applied_format, formatter, "format", message, type, time, context);
	if (Z_TYPE_P(applied_format) != IS_ARRAY) { 
		syslog_type    = type;
		syslog_message = applied_format;
	}
	else {
		PHALCON_OBS_VAR(syslog_type);
		phalcon_array_fetch_long(&syslog_type, applied_format, 0, PH_NOISY);

		PHALCON_OBS_VAR(syslog_message);
		phalcon_array_fetch_long(&syslog_message, applied_format, 1, PH_NOISY);
	}

	PHALCON_CALL_FUNCTION(NULL, "syslog", syslog_type, syslog_message);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Logger_Adapter_Syslog, close){

	zval *opened;

	opened = phalcon_fetch_nproperty_this(this_ptr, SL("_opened"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(opened)) {
		PHALCON_CALL_FUNCTIONW(NULL, "closelog");
	}
	
	RETURN_TRUE;
}





#include <ext/standard/php_smart_str.h>
#include <Zend/zend_builtin_functions.h>



zend_class_entry *phalcon_logger_formatter_firephp_ce;

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, getTypeString);
static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, getShowBacktrace);
static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, setShowBacktrace);
static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, enableLabels);
static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, labelsEnabled);
static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, format);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_firephp_empty, 0, 0, 0)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_firephp_setshowbacktrace, 0, 0, 0)
	ZEND_ARG_INFO(0, show)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_firephp_enablelabels, 0, 0, 0)
	ZEND_ARG_INFO(0, enable)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_formatter_firephp_method_entry[] = {
	PHP_ME(Phalcon_Logger_Formatter_Firephp, getTypeString, arginfo_phalcon_logger_formatter_gettypestring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Firephp, getShowBacktrace, arginfo_phalcon_logger_formatter_firephp_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Firephp, setShowBacktrace, arginfo_phalcon_logger_formatter_firephp_setshowbacktrace, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Firephp, enableLabels, arginfo_phalcon_logger_formatter_firephp_enablelabels, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Firephp, labelsEnabled, arginfo_phalcon_logger_formatter_firephp_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Firephp, format, arginfo_phalcon_logger_formatterinterface_format, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Formatter_Firephp){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Formatter, Firephp, logger_formatter_firephp, phalcon_logger_formatter_ce, phalcon_logger_formatter_firephp_method_entry, 0);

	zend_declare_property_bool(phalcon_logger_formatter_firephp_ce, SL("_showBacktrace"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_logger_formatter_firephp_ce, SL("_enableLabels"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_formatter_firephp_ce TSRMLS_CC, 1, phalcon_logger_formatterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, getShowBacktrace) {

	RETURN_MEMBER(getThis(), "_showBacktrace");
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, setShowBacktrace) {

	zval **show;

	phalcon_fetch_params_ex(1, 0, &show);

	PHALCON_ENSURE_IS_BOOL(show);
	phalcon_update_property_this(getThis(), SL("_showBacktrace"), *show TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, enableLabels) {

	zval **enable;

	phalcon_fetch_params_ex(1, 0, &enable);

	PHALCON_ENSURE_IS_BOOL(enable);
	phalcon_update_property_this(getThis(), SL("_enableLabels"), *enable TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, labelsEnabled) {

	RETURN_MEMBER(getThis(), "_enableLabels");
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, getTypeString) {

	static const char* lut[10] = {
		"ERROR", "ERROR", "WARN", "ERROR", "WARN",
		"INFO",  "INFO",  "LOG",  "INFO",  "LOG"
	};

	zval **type;
	int itype;

	phalcon_fetch_params_ex(1, 0, &type);
	PHALCON_ENSURE_IS_LONG(type);

	itype = Z_LVAL_PP(type);
	if (itype > 0 && itype < 10) {
		RETURN_STRING(lut[itype], 1);
	}

	RETURN_STRING("CUSTOM", 1);
}

static PHP_METHOD(Phalcon_Logger_Formatter_Firephp, format) {

	zval *message, *type, *type_str = NULL, *timestamp, *context, *interpolated = NULL;
	zval *payload, *body, *backtrace = NULL, *meta, *encoded;
	zval *show_backtrace, *enable_labels;
	int i_show_backtrace, i_enable_labels;
	smart_str result = { NULL, 0, 0 };
	uint i;
	Bucket *p;

	phalcon_fetch_params(0, 4, 0, &message, &type, &timestamp, &context);


	if (Z_TYPE_P(context) == IS_ARRAY) {
		PHALCON_CALL_METHODW(&interpolated, this_ptr, "interpolate", message, context);
	}
	else {
		interpolated = message;
		Z_ADDREF_P(interpolated);
	}

	{
		zval *params[] = { type };
		if (FAILURE == phalcon_call_method(&type_str, this_ptr, "gettypestring", 1, params TSRMLS_CC)) {
			zval_ptr_dtor(&interpolated);
			return;
		}
	}

	show_backtrace   = phalcon_fetch_nproperty_this(getThis(), SL("_showBacktrace"), PH_NOISY TSRMLS_CC);
	enable_labels    = phalcon_fetch_nproperty_this(getThis(), SL("_enableLabels"), PH_NOISY TSRMLS_CC);
	i_show_backtrace = zend_is_true(show_backtrace);
	i_enable_labels  = zend_is_true(enable_labels);

	if (i_show_backtrace) {
		ALLOC_INIT_ZVAL(backtrace);

#if PHP_VERSION_ID < 50306
		zend_fetch_debug_backtrace(backtrace, 1, 0 TSRMLS_CC);
#elif PHP_VERSION_ID < 50400
		zend_fetch_debug_backtrace(backtrace, 1, DEBUG_BACKTRACE_IGNORE_ARGS TSRMLS_CC);
#else
		zend_fetch_debug_backtrace(backtrace, 1, DEBUG_BACKTRACE_IGNORE_ARGS, 0 TSRMLS_CC);
#endif

		if (Z_TYPE_P(backtrace) == IS_ARRAY) {
			HashPosition pos;
			HashTable *ht = Z_ARRVAL_P(backtrace);
			zval **ppzval;
			int found = 0;
			ulong idx;
			char *key;
			uint key_len;


			for (
				zend_hash_internal_pointer_reset_ex(ht, &pos);
				zend_hash_has_more_elements_ex(ht, &pos) == SUCCESS;
			) {
				zend_hash_get_current_data_ex(ht, (void**)&ppzval, &pos);
				zend_hash_get_current_key_ex(ht, &key, &key_len, &idx, 0, &pos);
				zend_hash_move_forward_ex(ht, &pos);

				if (Z_TYPE_PP(ppzval) == IS_ARRAY) {
					if (!found && !zend_hash_quick_exists(Z_ARRVAL_PP(ppzval), SS("file"), 259010501UL)) {
						zend_hash_index_del(ht, idx);
					}
					else {
						zend_hash_quick_del(Z_ARRVAL_PP(ppzval), "args", sizeof("args"), 253399346UL);
						zend_hash_quick_del(Z_ARRVAL_PP(ppzval), "object", sizeof("object"), 1351663228UL);
						found = 1;
					}
				}
			}

			p = ht->pListHead;
			i = 0;
			while (p != NULL) {
				p->nKeyLength = 0;
				p->h = i++;
				p = p->pListNext;
			}

			ht->nNextFreeElement = i;
			zend_hash_rehash(ht);
		}
	}

	MAKE_STD_ZVAL(payload);
	array_init_size(payload, 2);

	MAKE_STD_ZVAL(meta);
	array_init_size(meta, 4);
	add_assoc_zval_ex(meta, SS("Type"), type_str);

	if (i_show_backtrace && Z_TYPE_P(backtrace) == IS_ARRAY) {
		zval **ppzval;

		if (likely(SUCCESS == zend_hash_index_find(Z_ARRVAL_P(backtrace), 0, (void**)&ppzval)) && likely(Z_TYPE_PP(ppzval) == IS_ARRAY)) {
			zval **file = NULL, **line = NULL;

			zend_hash_quick_find(Z_ARRVAL_PP(ppzval), SS("file"), 259010501UL, (void**)&file);
			zend_hash_quick_find(Z_ARRVAL_PP(ppzval), SS("line"), 266128205UL, (void**)&line);

			if (likely(file != NULL)) {
				Z_ADDREF_PP(file);
				add_assoc_zval_ex(meta, SS("File"), *file);
			}

			if (likely(line != NULL)) {
				Z_ADDREF_PP(line);
				add_assoc_zval_ex(meta, SS("Line"), *line);
			}
		}
	}

	if (i_enable_labels) {
		add_assoc_zval_ex(meta, SS("Label"), interpolated);
	}

	if (!i_enable_labels && !i_show_backtrace) {
		body = interpolated;
	}
	else if (i_enable_labels && !i_show_backtrace) {
		MAKE_STD_ZVAL(body);
		ZVAL_EMPTY_STRING(body);
	}
	else {
		MAKE_STD_ZVAL(body);
		array_init_size(body, 2);

		if (i_show_backtrace) {
			add_assoc_zval_ex(body, SS("backtrace"), backtrace);
		}

		if (!i_enable_labels) {
			add_assoc_zval_ex(body, SS("message"), interpolated);
		}
	}

	add_next_index_zval(payload, meta);
	add_next_index_zval(payload, body);

	/* Convert everything to JSON */
	ALLOC_INIT_ZVAL(encoded);
	if (FAILURE == phalcon_json_encode(encoded, payload, 0 TSRMLS_CC)) {
		zval_ptr_dtor(&payload);
		zval_ptr_dtor(&encoded);
		return;
	}

	/* As promised, kill the payload and all associated elements */
	zval_ptr_dtor(&payload);

	if (Z_TYPE_P(encoded) == IS_STRING && Z_STRVAL_P(encoded) != NULL) {
		smart_str_alloc4(&result, (uint)(Z_STRLEN_P(encoded) + 2 + 5), 0, i);

		smart_str_append_long(&result, Z_STRLEN_P(encoded));
		smart_str_appendc(&result, '|');
		smart_str_appendl(&result, Z_STRVAL_P(encoded), Z_STRLEN_P(encoded));
		smart_str_appendc(&result, '|');
		smart_str_0(&result);
	}

	/* We don't need the JSON message anymore */
	zval_ptr_dtor(&encoded);
	/* Do not free the smart string because we steal its data for zval */
	RETURN_STRINGL(result.c, result.len, 0);
}






zend_class_entry *phalcon_logger_formatter_json_ce;

static PHP_METHOD(Phalcon_Logger_Formatter_Json, format);

static const zend_function_entry phalcon_logger_formatter_json_method_entry[] = {
	PHP_ME(Phalcon_Logger_Formatter_Json, format, arginfo_phalcon_logger_formatterinterface_format, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Formatter_Json){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Formatter, Json, logger_formatter_json, phalcon_logger_formatter_ce, phalcon_logger_formatter_json_method_entry, 0);

	zend_class_implements(phalcon_logger_formatter_json_ce TSRMLS_CC, 1, phalcon_logger_formatterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Formatter_Json, format){

	zval *message, *type, *timestamp, *context, *interpolated = NULL, *type_str = NULL, *log;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &timestamp, &context);
	
	if (Z_TYPE_P(context) == IS_ARRAY) {
		PHALCON_CALL_METHOD(&interpolated, this_ptr, "interpolate", message, context);
	}
	else {
		interpolated = message;
	}

	PHALCON_CALL_METHOD(&type_str, this_ptr, "gettypestring", type);
	
	PHALCON_INIT_VAR(log);
	array_init_size(log, 3);
	phalcon_array_update_string(&log, SL("type"), type_str, PH_COPY);
	phalcon_array_update_string(&log, SL("message"), interpolated, PH_COPY);
	phalcon_array_update_string(&log, SL("timestamp"), timestamp, PH_COPY);
	RETURN_MM_ON_FAILURE(phalcon_json_encode(return_value, log, 0 TSRMLS_CC));
	RETURN_MM();
}





#include <ext/date/php_date.h>


zend_class_entry *phalcon_logger_formatter_line_ce;

static PHP_METHOD(Phalcon_Logger_Formatter_Line, __construct);
static PHP_METHOD(Phalcon_Logger_Formatter_Line, setFormat);
static PHP_METHOD(Phalcon_Logger_Formatter_Line, getFormat);
static PHP_METHOD(Phalcon_Logger_Formatter_Line, setDateFormat);
static PHP_METHOD(Phalcon_Logger_Formatter_Line, getDateFormat);
static PHP_METHOD(Phalcon_Logger_Formatter_Line, format);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_line___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, format)
	ZEND_ARG_INFO(0, dateFormat)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_line_setformat, 0, 0, 1)
	ZEND_ARG_INFO(0, format)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_logger_formatter_line_setdateformat, 0, 0, 1)
	ZEND_ARG_INFO(0, date)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_logger_formatter_line_method_entry[] = {
	PHP_ME(Phalcon_Logger_Formatter_Line, __construct, arginfo_phalcon_logger_formatter_line___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Logger_Formatter_Line, setFormat, arginfo_phalcon_logger_formatter_line_setformat, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Line, getFormat, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Line, setDateFormat, arginfo_phalcon_logger_formatter_line_setdateformat, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Line, getDateFormat, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Logger_Formatter_Line, format, arginfo_phalcon_logger_formatterinterface_format, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Formatter_Line){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Formatter, Line, logger_formatter_line, phalcon_logger_formatter_ce, phalcon_logger_formatter_line_method_entry, 0);

	zend_declare_property_string(phalcon_logger_formatter_line_ce, SL("_dateFormat"), "D, d M y H:i:s O", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_logger_formatter_line_ce, SL("_format"), "[%date%][%type%] %message%", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_logger_formatter_line_ce TSRMLS_CC, 1, phalcon_logger_formatterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, __construct){

	zval *format = NULL, *date_format = NULL;

	phalcon_fetch_params(0, 0, 2, &format, &date_format);
	
	if (format && Z_TYPE_P(format) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_format"), format, 3742267021UL TSRMLS_CC);
	}

	if (date_format && Z_TYPE_P(date_format) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_dateFormat"), date_format, 959184011UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, setFormat){

	zval *format;

	phalcon_fetch_params(0, 1, 0, &format);
	
	phalcon_update_property_this_quick(this_ptr, SL("_format"), format, 3742267021UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, getFormat){


	RETURN_MEMBER_QUICK(this_ptr, "_format", 3742267021UL);
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, setDateFormat){

	zval *date;

	phalcon_fetch_params(0, 1, 0, &date);
	
	phalcon_update_property_this_quick(this_ptr, SL("_dateFormat"), date, 959184011UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, getDateFormat){


	RETURN_MEMBER_QUICK(this_ptr, "_dateFormat", 959184011UL);
}

static PHP_METHOD(Phalcon_Logger_Formatter_Line, format){

	zval *message, *type, *timestamp, *context, *format = NULL, *date_format;
	zval *date, *date_wildcard, *new_format = NULL, *type_string = NULL;
	zval *type_wildcard, *message_wildcard;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &message, &type, &timestamp, &context);
	
	PHALCON_OBS_VAR(format);
	phalcon_read_property_this(&format, this_ptr, SL("_format"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_memnstr_str(format, SL("%date%"))) {
		date_format = phalcon_fetch_nproperty_this(this_ptr, SL("_dateFormat"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(date);
		phalcon_date(date, date_format, timestamp TSRMLS_CC);
	
		PHALCON_INIT_VAR(date_wildcard);
		ZVAL_STRING(date_wildcard, "%date%", 1);
	
		PHALCON_INIT_VAR(new_format);
		phalcon_fast_str_replace(new_format, date_wildcard, date, format);
	} else {
		PHALCON_CPY_WRT(new_format, format);
	}
	
	if (phalcon_memnstr_str(format, SL("%type%"))) {
		PHALCON_CALL_METHOD(&type_string, this_ptr, "gettypestring", type);
	
		PHALCON_INIT_VAR(type_wildcard);
		ZVAL_STRING(type_wildcard, "%type%", 1);
	
		PHALCON_INIT_NVAR(format);
		phalcon_fast_str_replace(format, type_wildcard, type_string, new_format);
	} else {
		PHALCON_CPY_WRT(format, new_format);
	}
	
	PHALCON_INIT_VAR(message_wildcard);
	ZVAL_STRING(message_wildcard, "%message%", 1);
	
	PHALCON_INIT_NVAR(new_format);
	phalcon_fast_str_replace(new_format, message_wildcard, message, format);
	
	if (Z_TYPE_P(context) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(context)) > 0) {
		PHALCON_CALL_METHOD(&format, this_ptr, "interpolate", new_format, context);
	}
	else {
		PHALCON_CPY_WRT(format, new_format);
	}

	PHALCON_CONCAT_VS(return_value, format, PHP_EOL);
	RETURN_MM();
}






zend_class_entry *phalcon_logger_formatter_syslog_ce;

static PHP_METHOD(Phalcon_Logger_Formatter_Syslog, format);

static const zend_function_entry phalcon_logger_formatter_syslog_method_entry[] = {
	PHP_ME(Phalcon_Logger_Formatter_Syslog, format, arginfo_phalcon_logger_formatterinterface_format, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Logger_Formatter_Syslog){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Logger\\Formatter, Syslog, logger_formatter_syslog, phalcon_logger_formatter_ce, phalcon_logger_formatter_syslog_method_entry, 0);

	zend_class_implements(phalcon_logger_formatter_syslog_ce TSRMLS_CC, 1, phalcon_logger_formatterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Logger_Formatter_Syslog, format){

	zval *message, *type, *timestamp, *context, *interpolated = NULL;

	phalcon_fetch_params(0, 4, 0, &message, &type, &timestamp, &context);
	
	if (Z_TYPE_P(context) == IS_ARRAY) {
		PHALCON_CALL_METHODW(&interpolated, this_ptr, "interpolate", message, context);
	}
	else {
		interpolated = message;
		Z_ADDREF_P(interpolated);
	}

	array_init_size(return_value, 2);
	phalcon_array_append(&return_value, type, 0);
	add_next_index_zval(return_value, interpolated);
	return;
}





#include <Zend/zend_closures.h>



zend_class_entry *phalcon_mvc_application_ce;

static PHP_METHOD(Phalcon_Mvc_Application, __construct);
static PHP_METHOD(Phalcon_Mvc_Application, useImplicitView);
static PHP_METHOD(Phalcon_Mvc_Application, registerModules);
static PHP_METHOD(Phalcon_Mvc_Application, getModules);
static PHP_METHOD(Phalcon_Mvc_Application, setDefaultModule);
static PHP_METHOD(Phalcon_Mvc_Application, getDefaultModule);
static PHP_METHOD(Phalcon_Mvc_Application, handle);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_application___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_application_useimplicitview, 0, 0, 1)
	ZEND_ARG_INFO(0, implicitView)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_application_registermodules, 0, 0, 1)
	ZEND_ARG_INFO(0, modules)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_application_setdefaultmodule, 0, 0, 1)
	ZEND_ARG_INFO(0, defaultModule)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_application_handle, 0, 0, 0)
	ZEND_ARG_INFO(0, uri)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_application_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Application, __construct, arginfo_phalcon_mvc_application___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Application, useImplicitView, arginfo_phalcon_mvc_application_useimplicitview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Application, registerModules, arginfo_phalcon_mvc_application_registermodules, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Application, getModules, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Application, setDefaultModule, arginfo_phalcon_mvc_application_setdefaultmodule, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Application, getDefaultModule, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Application, handle, arginfo_phalcon_mvc_application_handle, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Application){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Application, mvc_application, phalcon_di_injectable_ce, phalcon_mvc_application_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_application_ce, SL("_defaultModule"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_application_ce, SL("_modules"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_application_ce, SL("_moduleObject"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_application_ce, SL("_implicitView"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Application, __construct){

	zval *dependency_injector = NULL;

	phalcon_fetch_params(0, 0, 1, &dependency_injector);
	
	if (dependency_injector && Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_application_exception_ce, 0);
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Mvc_Application, useImplicitView){

	zval *implicit_view;

	phalcon_fetch_params(0, 1, 0, &implicit_view);
	
	phalcon_update_property_this_quick(this_ptr, SL("_implicitView"), implicit_view, 1205999546UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Application, registerModules){

	zval *modules, *merge = NULL, *registered_modules, *merged_modules = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &modules, &merge);
	
	if (!merge) {
		merge = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(modules) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "Modules must be an Array");
		return;
	}
	if (PHALCON_IS_FALSE(merge)) {
		phalcon_update_property_this_quick(this_ptr, SL("_modules"), modules, 379092157UL TSRMLS_CC);
	} else {
		PHALCON_OBS_VAR(registered_modules);
		phalcon_read_property_this(&registered_modules, this_ptr, SL("_modules"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(registered_modules) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_modules);
			phalcon_fast_array_merge(merged_modules, &registered_modules, &modules TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_modules, modules);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_modules"), merged_modules, 379092157UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Application, getModules){


	RETURN_MEMBER_QUICK(this_ptr, "_modules", 379092157UL);
}

static PHP_METHOD(Phalcon_Mvc_Application, setDefaultModule){

	zval *default_module;

	phalcon_fetch_params(0, 1, 0, &default_module);
	
	phalcon_update_property_this_quick(this_ptr, SL("_defaultModule"), default_module, 3959488399UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Application, getDefaultModule){


	RETURN_MEMBER_QUICK(this_ptr, "_defaultModule", 3959488399UL);
}

static int phalcon_mvc_application_fire_event(zval *mgr, const char *event, zval *this_ptr, zval *params TSRMLS_DC)
{
	if (mgr) {
		zval *event_name;
		zval *status = NULL;
		uint params_cnt = 2 + (params != NULL ? 1 : 0);
		zval *p[3];

		PHALCON_ALLOC_GHOST_ZVAL(event_name);
		ZVAL_STRING(event_name, event, 1);

		p[0] = event_name;
		p[1] = this_ptr;
		p[2] = params;

		if (FAILURE == phalcon_call_method(&status, mgr, "fire", params_cnt, p TSRMLS_CC)) {
			return FAILURE;
		}

		return (Z_TYPE_P(status) == IS_BOOL && !Z_BVAL_P(status)) ? FAILURE : SUCCESS;
	}

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Application, handle){

	zval *uri = NULL, *dependency_injector, *events_manager;
	zval *status = NULL, *service = NULL, *router = NULL, *module_name = NULL;
	zval *module_object = NULL, *modules;
	zval *module, *class_name = NULL, *module_params;
	zval *implicit_view, *view = NULL, *namespace_name = NULL;
	zval *controller_name = NULL, *action_name = NULL, *params = NULL, *exact = NULL;
	zval *dispatcher = NULL, *controller = NULL, *returned_response = NULL;
	zval *possible_response = NULL, *render_status = NULL, *response = NULL;
	zval *content = NULL, *path;
	int f_implicit_view;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &uri);
	
	if (!uri) {
		uri = PHALCON_GLOBAL(z_null);
	}
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "A dependency injection object is required to access internal services");
		return;
	}
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) != IS_OBJECT) {
		events_manager = NULL;
	}
	else {
		PHALCON_VERIFY_INTERFACE_EX(events_manager, phalcon_events_managerinterface_ce, phalcon_mvc_application_exception_ce, 1);
	}

	/* Call boot event, this allows the developer to perform initialization actions */
	if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:boot", getThis(), NULL TSRMLS_CC)) {
		RETURN_MM_FALSE;
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_router);
	PHALCON_CALL_METHOD(&router, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(router, phalcon_mvc_routerinterface_ce);
	
	/* Handle the URI pattern (if any) */
	PHALCON_CALL_METHOD(NULL, router, "handle", uri);
	
	/* Load module config */
	PHALCON_CALL_METHOD(&module_name, router, "getmodulename");
	
	/* If the router doesn't return a valid module we use the default module */
	if (!zend_is_true(module_name)) {
		PHALCON_OBS_NVAR(module_name);
		phalcon_read_property_this(&module_name, this_ptr, SL("_defaultModule"), PH_NOISY TSRMLS_CC);
	}
	
	if (zend_is_true(module_name)) {
		if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:beforeStartModule", getThis(), module_name TSRMLS_CC)) {
			RETURN_MM_FALSE;
		}

		PHALCON_OBS_VAR(modules);
		phalcon_read_property_this(&modules, this_ptr, SL("_modules"), PH_NOISY TSRMLS_CC);
		if (!phalcon_array_isset_fetch(&module, modules, module_name)) {
			convert_to_string(module_name);
			zend_throw_exception_ex(phalcon_mvc_application_exception_ce, 0 TSRMLS_CC, "Module %s is not registered in the application container", Z_STRVAL_P(module_name));
			RETURN_MM();
		}
	
		if (Z_TYPE_P(module) != IS_ARRAY && Z_TYPE_P(module) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "Invalid module definition");
			return;
		}
	
		/* An array module definition contains a path to a module definition class */
		if (Z_TYPE_P(module) == IS_ARRAY) { 
			/* Class name used to load the module definition */
			if (phalcon_array_isset_quick_string(module, SS("className"), 362439804UL)) {
				PHALCON_OBS_VAR(class_name);
				phalcon_array_fetch_quick_string(&class_name, module, SS("className"), 362439804UL, PH_NOISY);
			} else {
				PHALCON_INIT_NVAR(class_name);
				ZVAL_STRING(class_name, "Module", 1);
			}
	
			/* If the developer has specified a path, try to include the file */
			if (phalcon_array_isset_quick_string(module, SS("path"), 270591026UL)) {
	
				PHALCON_OBS_VAR(path);
				phalcon_array_fetch_quick_string(&path, module, SS("path"), 270591026UL, PH_NOISY);
				convert_to_string_ex(&path);
				if (Z_TYPE_P(class_name) != IS_STRING || !phalcon_class_exists(Z_STRVAL_P(class_name), Z_STRLEN_P(class_name), 0 TSRMLS_CC)) {
					if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
						RETURN_MM_ON_FAILURE(phalcon_require(Z_STRVAL_P(path) TSRMLS_CC));
					} else {
						zend_throw_exception_ex(phalcon_mvc_application_exception_ce, 0 TSRMLS_CC, "Module definition path '%s' does not exist", Z_STRVAL_P(path));
						RETURN_MM();
					}
				}
			}
	
			PHALCON_CALL_METHOD(&module_object, dependency_injector, "get", class_name);
	
			PHALCON_CALL_METHOD(NULL, module_object, "registerautoloaders", dependency_injector);
			PHALCON_CALL_METHOD(NULL, module_object, "registerservices", dependency_injector);
		} else if (Z_TYPE_P(module) == IS_OBJECT && instanceof_function(Z_OBJCE_P(module), zend_ce_closure TSRMLS_CC)) {
			/* A module definition object, can be a Closure instance */
			PHALCON_INIT_VAR(module_params);
			array_init_size(module_params, 1);
			phalcon_array_append(&module_params, dependency_injector, 0);

			PHALCON_INIT_NVAR(status);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(status, module, module_params);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_application_exception_ce, "Invalid module definition");
			return;
		}
	
		/* Calling afterStartModule event */
		if (events_manager) {
			if (!module_object) {
				module_object = PHALCON_GLOBAL(z_null);
			}

			phalcon_update_property_this_quick(this_ptr, SL("_moduleObject"), module_object, 121977121UL TSRMLS_CC);
			if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:afterStartModule", getThis(), module_name TSRMLS_CC)) {
				RETURN_MM_FALSE;
			}
		}
	}
	
	implicit_view = phalcon_fetch_nproperty_this(this_ptr, SL("_implicitView"), PH_NOISY TSRMLS_CC);

	f_implicit_view = PHALCON_IS_TRUE(implicit_view);

	if (f_implicit_view) {
		PHALCON_INIT_NVAR(service);
		ZVAL_STRING(service, "view", 1);
	
		PHALCON_CALL_METHOD(&view, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(view, phalcon_mvc_viewinterface_ce);
	}
	
	/* We get the parameters from the router and assign them to the dispatcher */
	PHALCON_CALL_METHOD(&module_name, router, "getmodulename");
	PHALCON_CALL_METHOD(&namespace_name, router, "getnamespacename");
	PHALCON_CALL_METHOD(&controller_name, router, "getcontrollername");
	PHALCON_CALL_METHOD(&action_name, router, "getactionname");
	PHALCON_CALL_METHOD(&params, router, "getparams");
	PHALCON_CALL_METHOD(&exact, router, "isexactcontrollername");

	PHALCON_INIT_NVAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_dispatcher);
	
	PHALCON_CALL_METHOD(&dispatcher, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(dispatcher, phalcon_dispatcherinterface_ce);
	
	/* Assign the values passed from the router */
	PHALCON_CALL_METHOD(NULL, dispatcher, "setmodulename", module_name);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setnamespacename", namespace_name);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setcontrollername", controller_name, exact);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setactionname", action_name);
	PHALCON_CALL_METHOD(NULL, dispatcher, "setparams", params);
	
	if (f_implicit_view) {
		PHALCON_CALL_METHOD(NULL, view, "start");
	}
	
	/* Calling beforeHandleRequest */
	RETURN_MM_ON_FAILURE(phalcon_mvc_application_fire_event(events_manager, "application:beforeHandleRequest", getThis(), dispatcher TSRMLS_CC));
	
	/* The dispatcher must return an object */
	PHALCON_CALL_METHOD(&controller, dispatcher, "dispatch");
	
	PHALCON_INIT_VAR(returned_response);
	
	/* Get the latest value returned by an action */
	PHALCON_CALL_METHOD(&possible_response, dispatcher, "getreturnedvalue");
	if (Z_TYPE_P(possible_response) == IS_OBJECT) {
		/* Check if the returned object is already a response */
		ZVAL_BOOL(returned_response, instanceof_function_ex(Z_OBJCE_P(possible_response), phalcon_http_responseinterface_ce, 1 TSRMLS_CC));
	}
	else {
		ZVAL_FALSE(returned_response);
	}
	
	/* Calling afterHandleRequest */
	if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:afterHandleRequest", getThis(), controller TSRMLS_CC) && EG(exception)) {
		RETURN_MM();
	}
	
	/* If the dispatcher returns an object we try to render the view in auto-rendering mode */
	if (PHALCON_IS_FALSE(returned_response)) {
		if (f_implicit_view) {
	
			if (Z_TYPE_P(controller) == IS_OBJECT) {
	
				PHALCON_INIT_VAR(render_status);
	
				if (events_manager) {
					if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:viewRender", getThis(), view TSRMLS_CC)) {
						if (EG(exception)) {
							RETURN_MM();
						}

						ZVAL_FALSE(render_status);
					}
					else {
						ZVAL_TRUE(render_status);
					}
				}
				else {
					ZVAL_TRUE(render_status);
				}
	
				/* Check if the view process has been treated by the developer */
				if (PHALCON_IS_NOT_FALSE(render_status)) {
					PHALCON_CALL_METHOD(&controller_name, dispatcher, "getcontrollername");
					PHALCON_CALL_METHOD(&action_name, dispatcher, "getactionname");
					PHALCON_CALL_METHOD(&params, dispatcher, "getparams");
	
					/* Automatic render based on the latest controller executed */
					PHALCON_CALL_METHOD(NULL, view, "render", controller_name, action_name, params);
				}
			}
		}
	}
	
	/* Finish the view component (stop output buffering) */
	if (f_implicit_view) {
		PHALCON_CALL_METHOD(NULL, view, "finish");
	}
	
	if (PHALCON_IS_FALSE(returned_response)) {
		PHALCON_INIT_NVAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_response);
	
		PHALCON_CALL_METHOD(&response, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(response, phalcon_http_responseinterface_ce);
		if (f_implicit_view) {
			/* The content returned by the view is passed to the response service */
			PHALCON_CALL_METHOD(&content, view, "getcontent");
			PHALCON_CALL_METHOD(NULL, response, "setcontent", content);
		}
	} else {
		/* We don't need to create a response because there is a one already created */
		PHALCON_CPY_WRT(response, possible_response);
	}
	

	/* Calling beforeSendResponse */
	if (FAILURE == phalcon_mvc_application_fire_event(events_manager, "application:beforeSendResponse", getThis(), response TSRMLS_CC) && EG(exception)) {
		RETURN_MM();
	}
	
	/* Headers are automatically sent */
	PHALCON_CALL_METHOD(NULL, response, "sendheaders");
	
	/* Cookies are automatically sent */
	PHALCON_CALL_METHOD(NULL, response, "sendcookies");
	
	/* Return the response */
	RETURN_CCTOR(response);
}







zend_class_entry *phalcon_mvc_collection_ce;

static PHP_METHOD(Phalcon_Mvc_Collection, __construct);
static PHP_METHOD(Phalcon_Mvc_Collection, setId);
static PHP_METHOD(Phalcon_Mvc_Collection, getId);
static PHP_METHOD(Phalcon_Mvc_Collection, setDI);
static PHP_METHOD(Phalcon_Mvc_Collection, getDI);
static PHP_METHOD(Phalcon_Mvc_Collection, setEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection, getEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection, getCollectionManager);
static PHP_METHOD(Phalcon_Mvc_Collection, getReservedAttributes);
static PHP_METHOD(Phalcon_Mvc_Collection, useImplicitObjectIds);
static PHP_METHOD(Phalcon_Mvc_Collection, setSource);
static PHP_METHOD(Phalcon_Mvc_Collection, getSource);
static PHP_METHOD(Phalcon_Mvc_Collection, setConnectionService);
static PHP_METHOD(Phalcon_Mvc_Collection, getConnectionService);
static PHP_METHOD(Phalcon_Mvc_Collection, getConnection);
static PHP_METHOD(Phalcon_Mvc_Collection, readAttribute);
static PHP_METHOD(Phalcon_Mvc_Collection, writeAttribute);
static PHP_METHOD(Phalcon_Mvc_Collection, cloneResult);
static PHP_METHOD(Phalcon_Mvc_Collection, _getResultset);
static PHP_METHOD(Phalcon_Mvc_Collection, _getGroupResultset);
static PHP_METHOD(Phalcon_Mvc_Collection, _preSave);
static PHP_METHOD(Phalcon_Mvc_Collection, _postSave);
static PHP_METHOD(Phalcon_Mvc_Collection, validate);
static PHP_METHOD(Phalcon_Mvc_Collection, validationHasFailed);
static PHP_METHOD(Phalcon_Mvc_Collection, fireEvent);
static PHP_METHOD(Phalcon_Mvc_Collection, fireEventCancel);
static PHP_METHOD(Phalcon_Mvc_Collection, _cancelOperation);
static PHP_METHOD(Phalcon_Mvc_Collection, _exists);
static PHP_METHOD(Phalcon_Mvc_Collection, getMessages);
static PHP_METHOD(Phalcon_Mvc_Collection, appendMessage);
static PHP_METHOD(Phalcon_Mvc_Collection, save);
static PHP_METHOD(Phalcon_Mvc_Collection, findById);
static PHP_METHOD(Phalcon_Mvc_Collection, findFirst);
static PHP_METHOD(Phalcon_Mvc_Collection, find);
static PHP_METHOD(Phalcon_Mvc_Collection, count);
static PHP_METHOD(Phalcon_Mvc_Collection, aggregate);
static PHP_METHOD(Phalcon_Mvc_Collection, summatory);
static PHP_METHOD(Phalcon_Mvc_Collection, create);
static PHP_METHOD(Phalcon_Mvc_Collection, update);
static PHP_METHOD(Phalcon_Mvc_Collection, delete);
static PHP_METHOD(Phalcon_Mvc_Collection, toArray);
static PHP_METHOD(Phalcon_Mvc_Collection, serialize);
static PHP_METHOD(Phalcon_Mvc_Collection, unserialize);
static PHP_METHOD(Phalcon_Mvc_Collection, execute);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_aggregate, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_summatory, 0, 0, 1)
	ZEND_ARG_INFO(0, field)
	ZEND_ARG_INFO(0, conditions)
	ZEND_ARG_INFO(0, finalize)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_execute, 0, 0, 1)
	ZEND_ARG_INFO(0, code)
	ZEND_ARG_INFO(0, args)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_collection_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Collection, __construct, arginfo_phalcon_mvc_collection___construct, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Collection, setId, arginfo_phalcon_mvc_collectioninterface_setid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, getId, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, getCollectionManager, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, getReservedAttributes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, useImplicitObjectIds, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, setSource, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, getSource, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, setConnectionService, arginfo_phalcon_mvc_collectioninterface_setconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, getConnectionService, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, getConnection, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, readAttribute, arginfo_phalcon_mvc_collectioninterface_readattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, writeAttribute, arginfo_phalcon_mvc_collectioninterface_writeattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, cloneResult, arginfo_phalcon_mvc_collectioninterface_cloneresult, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, _getResultset, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, _getGroupResultset, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, _preSave, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, _postSave, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, validate, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, validationHasFailed, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, fireEvent, arginfo_phalcon_mvc_collectioninterface_fireevent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, fireEventCancel, arginfo_phalcon_mvc_collectioninterface_fireeventcancel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, _cancelOperation, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, _exists, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Collection, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, appendMessage, arginfo_phalcon_mvc_collectioninterface_appendmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, save, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, findById, arginfo_phalcon_mvc_collectioninterface_findbyid, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, findFirst, arginfo_phalcon_mvc_collectioninterface_findfirst, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, find, arginfo_phalcon_mvc_collectioninterface_find, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, count, arginfo_phalcon_mvc_collectioninterface_count, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, aggregate, arginfo_phalcon_mvc_collection_aggregate, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, summatory, arginfo_phalcon_mvc_collection_summatory, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Collection, create, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, update, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, delete, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, toArray, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, serialize, arginfo_serializable_serialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, unserialize, arginfo_serializable_unserialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection, execute, arginfo_phalcon_mvc_collection_execute, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Collection, mvc_collection, phalcon_mvc_collection_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_id"), ZEND_ACC_PUBLIC TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_collectionManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_source"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_collection_ce, SL("_operationMade"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_ce, SL("_reserved"), ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_collection_ce, SL("_disableEvents"), 0, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_NONE"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_CREATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_UPDATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_collection_ce, SL("OP_DELETE"), 3 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_collection_ce TSRMLS_CC, 3, phalcon_mvc_collectioninterface_ce, phalcon_di_injectionawareinterface_ce, zend_ce_serializable);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Collection, __construct){

	zval **dependency_injector = NULL, **collection_manager = NULL;
	zval *di = NULL, *mm = NULL;
	zval *service_name;

	phalcon_fetch_params_ex(0, 2, &dependency_injector, &collection_manager);

	PHALCON_MM_GROW();

	if (!dependency_injector || Z_TYPE_PP(dependency_injector) != IS_OBJECT) {
		PHALCON_CALL_CE_STATIC(&di, phalcon_di_ce, "getdefault");
	}
	else {
		di = *dependency_injector;
	}

	PHALCON_VERIFY_INTERFACE_EX(di, phalcon_diinterface_ce, phalcon_mvc_collection_exception_ce, 1);

	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), di, 765199457UL TSRMLS_CC);

	if (!collection_manager || Z_TYPE_PP(collection_manager) != IS_OBJECT) {
		PHALCON_ALLOC_GHOST_ZVAL(service_name);
		ZVAL_STRING(service_name, "collectionManager", 1);

		PHALCON_CALL_METHOD(&mm, di, "getshared", service_name);
		if (Z_TYPE_P(mm) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "The injected service 'collectionManager' is not valid");
			return;
		}
	}
	else {
		mm = *collection_manager;
	}

	PHALCON_VERIFY_INTERFACE_EX(mm, phalcon_mvc_collection_managerinterface_ce, phalcon_mvc_collection_exception_ce, 1);

	phalcon_update_property_this_quick(this_ptr, SL("_collectionManager"), mm, 2683361163UL TSRMLS_CC);

	PHALCON_CALL_METHOD(NULL, mm, "initialize", this_ptr);

	if (phalcon_method_quick_exists_ex(this_ptr, SS("onconstruct"), 564344039UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "onconstruct");
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, setId){

	zval *id, *use_implicit_ids = NULL, *collection_manager;
	zval *mongo_id = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &id);

	if (Z_TYPE_P(id) != IS_OBJECT) {
		collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);

		PHALCON_CALL_METHOD(&use_implicit_ids, collection_manager, "isusingimplicitobjectids", this_ptr);
		if (zend_is_true(use_implicit_ids)) {
			ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_VAR(mongo_id);
			object_init_ex(mongo_id, ce0);
			if (phalcon_has_constructor(mongo_id TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, mongo_id, "__construct", id);
			}
		} else {
			mongo_id = id;
		}
	} else {
		mongo_id = id;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_id"), mongo_id, 2090005265UL TSRMLS_CC);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, getId){


	RETURN_MEMBER_QUICK(this_ptr, "_id", 2090005265UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_collection_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Collection, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection, setEventsManager){

	zval *events_manager, *collection_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &events_manager);

	collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, collection_manager, "setcustomeventsmanager", this_ptr, events_manager);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, getEventsManager){

	zval *collection_manager;

	collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(collection_manager, "getcustomeventsmanager", this_ptr);
}

static PHP_METHOD(Phalcon_Mvc_Collection, getCollectionManager){


	RETURN_MEMBER_QUICK(this_ptr, "_collectionManager", 2683361163UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection, getReservedAttributes){

	zval *reserved;

	reserved = phalcon_fetch_static_property_ce(phalcon_mvc_collection_ce, SL("_reserved") TSRMLS_CC);
	if (Z_TYPE_P(reserved) == IS_NULL) {
		zval *dummy = PHALCON_GLOBAL(z_true);

		array_init_size(return_value, 5);
		Z_ADDREF_P(dummy); add_assoc_zval_ex(return_value, SS("_connection"), dummy);
		Z_ADDREF_P(dummy); add_assoc_zval_ex(return_value, SS("_dependencyInjector"), dummy);
		Z_ADDREF_P(dummy); add_assoc_zval_ex(return_value, SS("_source"), dummy);
		Z_ADDREF_P(dummy); add_assoc_zval_ex(return_value, SS("_operationMade"), dummy);
		Z_ADDREF_P(dummy); add_assoc_zval_ex(return_value, SS("_errorMessages"), dummy);

		phalcon_update_static_property_ce(phalcon_mvc_collection_ce, SL("_reserved"), return_value TSRMLS_CC);
		return;
	}

	RETURN_ZVAL(reserved, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Collection, useImplicitObjectIds){

	zval *use_implicit_object_ids, *collection_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &use_implicit_object_ids);

	collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, collection_manager, "useimplicitobjectids", this_ptr, use_implicit_object_ids);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, setSource){

	zval *source;

	phalcon_fetch_params(0, 1, 0, &source);

	phalcon_update_property_this_quick(this_ptr, SL("_source"), source, 3355220565UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection, getSource){

	zval *source = NULL, *class_name;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(source);
	phalcon_read_property_this(&source, this_ptr, SL("_source"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(source)) {
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class_ns(class_name, this_ptr, 0 TSRMLS_CC);

		PHALCON_INIT_NVAR(source);
		phalcon_uncamelize(source, class_name);
		phalcon_update_property_this_quick(this_ptr, SL("_source"), source, 3355220565UL TSRMLS_CC);
	}

	RETURN_CTOR(source);
}

static PHP_METHOD(Phalcon_Mvc_Collection, setConnectionService){

	zval *connection_service, *collection_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &connection_service);

	collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, collection_manager, "setconnectionservice", this_ptr, connection_service);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Collection, getConnectionService){

	zval *collection_manager;

	collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(collection_manager, "getconnectionservice", this_ptr);
}

static PHP_METHOD(Phalcon_Mvc_Collection, getConnection){

	zval *connection = NULL, *collection_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(connection);
	phalcon_read_property_this(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		collection_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);

		PHALCON_CALL_METHOD(&connection, collection_manager, "getconnection", this_ptr);
		phalcon_update_property_this_quick(this_ptr, SL("_connection"), connection, 3057302292UL TSRMLS_CC);
	}

	RETURN_CTOR(connection);
}

static PHP_METHOD(Phalcon_Mvc_Collection, readAttribute){

	zval *attribute, *attribute_value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &attribute);

	if (phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC)) {
		PHALCON_OBS_VAR(attribute_value);
		phalcon_read_property_zval(&attribute_value, this_ptr, attribute, PH_NOISY TSRMLS_CC);
		RETURN_CTOR(attribute_value);
	}
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Collection, writeAttribute){

	zval *attribute, *value;

	phalcon_fetch_params(0, 2, 0, &attribute, &value);

	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Mvc_Collection, cloneResult){

	zval *collection, *document, *cloned_collection;
	zval *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &collection, &document);

	if (Z_TYPE_P(collection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid collection");
		return;
	}
	if (Z_TYPE_P(document) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid document");
		return;
	}

	PHALCON_INIT_VAR(cloned_collection);
	if (phalcon_clone(cloned_collection, collection TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}

	phalcon_is_iterable(document, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);

		PHALCON_CALL_METHOD(NULL, cloned_collection, "writeattribute", key, value);

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	RETURN_CTOR(cloned_collection);
}

static PHP_METHOD(Phalcon_Mvc_Collection, _getResultset){

	zval *params, *collection, *connection, *unique;
	zval *source = NULL, *mongo_collection = NULL, *conditions = NULL;
	zval *fields, *documents_cursor = NULL, *limit, *sort = NULL;
	zval *base = NULL, *document = NULL, *collections, *documents_array = NULL;
	zval *collection_cloned = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &params, &collection, &connection, &unique);

	PHALCON_CALL_METHOD(&source, collection, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&mongo_collection, connection, "selectcollection", source);
	if (Z_TYPE_P(mongo_collection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Couldn't select mongo collection");
		return;
	}

	if (phalcon_array_isset_long(params, 0)) {
		PHALCON_OBS_VAR(conditions);
		phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY);
	} else {
		if (phalcon_array_isset_quick_string(params, SS("conditions"), 1055696255UL)) {
			PHALCON_OBS_NVAR(conditions);
			phalcon_array_fetch_quick_string(&conditions, params, SS("conditions"), 1055696255UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(conditions);
			array_init(conditions);
		}
	}

	if (Z_TYPE_P(conditions) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Find parameters must be an array");
		return;
	}

	PHALCON_INIT_VAR(documents_cursor);
	if (phalcon_array_isset_quick_string(params, SS("fields"), 2881624156UL)) {
		PHALCON_OBS_VAR(fields);
		phalcon_array_fetch_quick_string(&fields, params, SS("fields"), 2881624156UL, PH_NOISY);

		PHALCON_CALL_METHOD(&documents_cursor, mongo_collection, "find", conditions, fields);
	} else {
		PHALCON_CALL_METHOD(&documents_cursor, mongo_collection, "find", conditions);
	}

	if (phalcon_array_isset_quick_string(params, SS("limit"), 192268420UL)) {
		PHALCON_OBS_VAR(limit);
		phalcon_array_fetch_quick_string(&limit, params, SS("limit"), 192268420UL, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, documents_cursor, "limit", limit);
	}

	if (phalcon_array_isset_quick_string(params, SS("sort"), 274650125UL)) {
		PHALCON_OBS_VAR(sort);
		phalcon_array_fetch_quick_string(&sort, params, SS("sort"), 274650125UL, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, documents_cursor, "sort", sort);
	}

	if (phalcon_array_isset_quick_string(params, SS("skip"), 274496444UL)) {
		PHALCON_OBS_NVAR(sort);
		phalcon_array_fetch_quick_string(&sort, params, SS("skip"), 274496444UL, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, documents_cursor, "skip", sort);
	}

	if (phalcon_array_isset_quick_string(params, SS("fields"), 2881624156UL)) {
		PHALCON_INIT_VAR(base);
		object_init_ex(base, phalcon_mvc_collection_document_ce);
	} else {
		PHALCON_CPY_WRT(base, collection);
	}

	if (PHALCON_IS_TRUE(unique)) {

		PHALCON_CALL_METHOD(NULL, documents_cursor, "rewind");
		PHALCON_CALL_METHOD(&document, documents_cursor, "current");
		if (Z_TYPE_P(document) == IS_ARRAY) {
			PHALCON_RETURN_CALL_SELF("cloneresult", base, document);
			RETURN_MM();
		}

		RETURN_MM_FALSE;
	}

	PHALCON_INIT_VAR(collections);
	array_init(collections);

	PHALCON_CALL_FUNCTION(&documents_array, "iterator_to_array", documents_cursor);

	phalcon_is_iterable(documents_array, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HVALUE(document);

		PHALCON_CALL_SELF(&collection_cloned, "cloneresult", base, document);
		phalcon_array_append(&collections, collection_cloned, PH_SEPARATE);

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	RETURN_CTOR(collections);
}

static PHP_METHOD(Phalcon_Mvc_Collection, _getGroupResultset){

	zval *params, *collection, *connection, *source = NULL;
	zval *mongo_collection = NULL, *conditions = NULL, *simple = NULL;
	zval *documents_cursor = NULL, *limit, *sort = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &params, &collection, &connection);

	PHALCON_CALL_METHOD(&source, collection, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&mongo_collection, connection, "selectcollection", source);

	if (phalcon_array_isset_long(params, 0)) {
		PHALCON_OBS_VAR(conditions);
		phalcon_array_fetch_long(&conditions, params, 0, PH_NOISY);
	} else {
		if (phalcon_array_isset_quick_string(params, SS("conditions"), 1055696255UL)) {
			PHALCON_OBS_NVAR(conditions);
			phalcon_array_fetch_quick_string(&conditions, params, SS("conditions"), 1055696255UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(conditions);
			array_init(conditions);
		}
	}

	PHALCON_INIT_VAR(simple);
	ZVAL_BOOL(simple, 1);
	if (phalcon_array_isset_quick_string(params, SS("limit"), 192268420UL)) {
		ZVAL_BOOL(simple, 0);
	} else {
		if (phalcon_array_isset_quick_string(params, SS("sort"), 274650125UL)) {
			PHALCON_INIT_NVAR(simple);
			ZVAL_BOOL(simple, 0);
		} else {
			if (phalcon_array_isset_quick_string(params, SS("skip"), 274496444UL)) {
				PHALCON_INIT_NVAR(simple);
				ZVAL_BOOL(simple, 0);
			}
		}
	}

	if (PHALCON_IS_FALSE(simple)) {

		PHALCON_CALL_METHOD(&documents_cursor, mongo_collection, "find", conditions);

		if (phalcon_array_isset_quick_string(params, SS("limit"), 192268420UL)) {
			PHALCON_OBS_VAR(limit);
			phalcon_array_fetch_quick_string(&limit, params, SS("limit"), 192268420UL, PH_NOISY);
			PHALCON_CALL_METHOD(NULL, documents_cursor, "limit", limit);
		}

		if (phalcon_array_isset_quick_string(params, SS("sort"), 274650125UL)) {
			PHALCON_OBS_VAR(sort);
			phalcon_array_fetch_quick_string(&sort, params, SS("sort"), 274650125UL, PH_NOISY);
			PHALCON_CALL_METHOD(NULL, documents_cursor, "sort", sort);
		}

		if (phalcon_array_isset_quick_string(params, SS("skip"), 274496444UL)) {
			PHALCON_OBS_NVAR(sort);
			phalcon_array_fetch_quick_string(&sort, params, SS("skip"), 274496444UL, PH_NOISY);
			PHALCON_CALL_METHOD(NULL, documents_cursor, "skip", sort);
		}

		phalcon_fast_count(return_value, documents_cursor TSRMLS_CC);
		RETURN_MM();
	}

	PHALCON_RETURN_CALL_METHOD(mongo_collection, "count", conditions);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, _preSave){

	zval *dependency_injector, *disable_events;
	zval *exists, *event_name = NULL, *status = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &dependency_injector, &disable_events, &exists);

	if (!zend_is_true(disable_events)) {

		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeValidation", 1);

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}

		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnUpdate", 1);
		}

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}

	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "validation", 1);

	PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
	if (PHALCON_IS_FALSE(status)) {
		if (!zend_is_true(disable_events)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
		}
		RETURN_MM_FALSE;
	}

	if (!zend_is_true(disable_events)) {

		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnUpdate", 1);
		}

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}

		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterValidation", 1);

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}

		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "beforeSave", 1);

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}

		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeCreate", 1);
		}

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}

	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, _postSave){

	zval *disable_events, *success, *exists, *event_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &disable_events, &success, &exists);

	if (PHALCON_IS_TRUE(success)) {
		if (!zend_is_true(disable_events)) {
			if (PHALCON_IS_TRUE(exists)) {
				PHALCON_INIT_VAR(event_name);
				ZVAL_STRING(event_name, "afterUpdate", 1);
			} else {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "afterCreate", 1);
			}
			PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);

			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterSave", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
		}

		RETURN_CTOR(success);
	}
	if (!zend_is_true(disable_events)) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "notSave", 1);
		PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	}

	PHALCON_CALL_METHOD(NULL, this_ptr, "_canceloperation", disable_events);
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, validate){

	zval *validator, *status = NULL, *messages = NULL, *message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &validator);

	if (Z_TYPE_P(validator) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Validator must be an Object");
		return;
	}

	PHALCON_CALL_METHOD(&status, validator, "validate", this_ptr);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_CALL_METHOD(&messages, validator, "getmessages");

		phalcon_is_iterable(messages, &ah0, &hp0, 0, 0);

		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

			PHALCON_GET_HVALUE(message);

			phalcon_update_property_array_append(this_ptr, SL("_errorMessages"), message TSRMLS_CC);

			zend_hash_move_forward_ex(ah0, &hp0);
		}

	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, validationHasFailed){

	zval *error_messages;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(error_messages);
	phalcon_read_property_this(&error_messages, this_ptr, SL("_errorMessages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(error_messages) == IS_ARRAY) {
		if (phalcon_fast_count_ev(error_messages TSRMLS_CC)) {
			RETURN_MM_TRUE;
		}
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, fireEvent){

	zval **event_name, *collection_manager;

	zval *lower;
	char *tmp;

	phalcon_fetch_params_ex(1, 0, &event_name);
	PHALCON_ENSURE_IS_STRING(event_name);

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(lower);
	tmp = zend_str_tolower_dup(Z_STRVAL_PP(event_name), Z_STRLEN_PP(event_name));
	ZVAL_STRINGL(lower, tmp, Z_STRLEN_PP(event_name), 0);

	if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(lower), Z_STRLEN_P(lower)+1  TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, Z_STRVAL_P(lower));
	}

	PHALCON_OBS_VAR(collection_manager);
	phalcon_read_property_this(&collection_manager, this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(collection_manager, "notifyevent", *event_name, this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, fireEventCancel){

	zval **event_name, *status = NULL, *collection_manager;
	zval *lower;
	char *tmp;

	phalcon_fetch_params_ex(1, 0, &event_name);
	PHALCON_ENSURE_IS_STRING(event_name);

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(lower);
	tmp = zend_str_tolower_dup(Z_STRVAL_PP(event_name), Z_STRLEN_PP(event_name));
	ZVAL_STRINGL(lower, tmp, Z_STRLEN_PP(event_name), 0);

	if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(lower), Z_STRLEN_P(lower)+1  TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&status, this_ptr, Z_STRVAL_P(lower));
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}

	PHALCON_OBS_VAR(collection_manager);
	phalcon_read_property_this(&collection_manager, this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&status, collection_manager, "notifyevent", *event_name, this_ptr);
	if (PHALCON_IS_FALSE(status)) {
		RETURN_MM_FALSE;
	}

	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, _cancelOperation){

	zval *disable_events, *operation_made, *event_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &disable_events);

	if (!zend_is_true(disable_events)) {

		PHALCON_OBS_VAR(operation_made);
		phalcon_read_property_this(&operation_made, this_ptr, SL("_operationMade"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_LONG(operation_made, 3)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "notDeleted", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "notSaved", 1);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	}
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, _exists){

	zval *collection, *id, *mongo_id = NULL, *collection_manager;
	zval *use_implicit_ids = NULL, *parameters, *document_count = NULL;
	zval *z_zero;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &collection);

	if (phalcon_isset_property(this_ptr, SS("_id") TSRMLS_CC)) {

		PHALCON_OBS_VAR(id);
		phalcon_read_property_this(&id, this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(id) == IS_OBJECT) {
			PHALCON_CPY_WRT(mongo_id, id);
		} else {
			PHALCON_OBS_VAR(collection_manager);
			phalcon_read_property_this(&collection_manager, this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);

			PHALCON_CALL_METHOD(&use_implicit_ids, collection_manager, "isusingimplicitobjectids", this_ptr);
			if (zend_is_true(use_implicit_ids)) {
				ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
				PHALCON_INIT_NVAR(mongo_id);
				object_init_ex(mongo_id, ce0);
				if (phalcon_has_constructor(mongo_id TSRMLS_CC)) {
					PHALCON_CALL_METHOD(NULL, mongo_id, "__construct", id);
				}
				phalcon_update_property_this_quick(this_ptr, SL("_id"), mongo_id, 2090005265UL TSRMLS_CC);
			} else {
				PHALCON_CPY_WRT(mongo_id, id);
			}
		}

		PHALCON_INIT_VAR(parameters);
		array_init_size(parameters, 1);
		phalcon_array_update_string(&parameters, SL("_id"), mongo_id, PH_COPY);

		PHALCON_CALL_METHOD(&document_count, collection, "count", parameters);

		z_zero = PHALCON_GLOBAL(z_zero);
		is_smaller_function(return_value, z_zero, document_count TSRMLS_CC);

		RETURN_MM();
	}
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Collection, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_errorMessages", 1019066246UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection, appendMessage){

	zval *message, *type = NULL, *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);

	if (Z_TYPE_P(message) != IS_OBJECT) {
		PHALCON_CALL_FUNCTION(&type, "gettype", message);

		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid message format '", type, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_collection_exception_ce, exception_message);
		return;
	}
	phalcon_update_property_array_append(this_ptr, SL("_errorMessages"), message TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, save){

	zval *source = NULL, *connection = NULL;
	zval *collection = NULL, *exists = NULL, *empty_array, *disable_events;
	zval *status = NULL, *data, *reserved = NULL, *properties = NULL;
	zval *success = NULL, *options;
	zval *arr = NULL, *white_list = NULL, *mode = NULL, *value = NULL;
	HashPosition hp0;
	zval **hd;
	zval *dependency_injector, *ok, *id;
	zval *params[2];
	zval func;

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_collection_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 3, &arr, &white_list, &mode);

	if (!arr) {
		arr = PHALCON_GLOBAL(z_null);
	}

	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}

	if (!mode) {
		mode = PHALCON_GLOBAL(z_null);
	}

	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&connection, this_ptr, "getconnection");

	PHALCON_CALL_METHOD(&collection, connection, "selectcollection", source);

	if (Z_TYPE_P(mode) == IS_NULL) {
		PHALCON_SEPARATE_PARAM(mode);
		PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", collection);

		PHALCON_INIT_NVAR(mode);

		ZVAL_BOOL(mode, (PHALCON_IS_FALSE(exists) ? 1 : 0));
		phalcon_update_property_long(this_ptr, SL("_operationMade"), (PHALCON_IS_FALSE(exists) ? 1 : 2) TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(exists);
		ZVAL_BOOL(exists, (PHALCON_IS_FALSE(mode) ? 1 : 0));

		phalcon_update_property_long(this_ptr, SL("_operationMade"), (PHALCON_IS_FALSE(exists) ? 1 : 2) TSRMLS_CC);
	}

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);

	phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), empty_array, 1019066246UL TSRMLS_CC);

	disable_events = phalcon_fetch_static_property_ce(phalcon_mvc_collection_ce, SL("_disableEvents") TSRMLS_CC);

	PHALCON_CALL_METHOD(&status, this_ptr, "_presave", dependency_injector, disable_events, exists);
	if (PHALCON_IS_FALSE(status)) {
		RETURN_MM_FALSE;
	}

	PHALCON_CALL_METHOD(&reserved, this_ptr, "getreservedattributes");
	PHALCON_CALL_FUNCTION(&properties, "get_object_vars", this_ptr);

	MAKE_STD_ZVAL(data);
	if (Z_TYPE_P(properties) == IS_ARRAY) {
		array_init_size(data, zend_hash_num_elements(Z_ARRVAL_P(properties)));

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(properties), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(properties), (void**) &hd, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(properties), &hp0)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(properties), &hp0);

			if ((PHALCON_IS_STRING(&key, "_id") && Z_TYPE_PP(hd) != IS_NULL) || !phalcon_array_isset(reserved, &key)) {
				if (Z_TYPE_P(arr) == IS_ARRAY && phalcon_array_isset(arr, &key)) {
					if (Z_TYPE_P(white_list) != IS_ARRAY || phalcon_fast_in_array(&key, white_list TSRMLS_CC)) {
						PHALCON_OBS_NVAR(value);
						phalcon_array_fetch(&value, arr, &key, PH_NOISY);

						Z_ADDREF_P(value);
						if (likely(Z_TYPE(key) == IS_STRING)) {
							add_assoc_zval_ex(data, Z_STRVAL(key), Z_STRLEN(key)+1, value);
						}
						else {
							add_index_zval(data, Z_LVAL(key), value);
						}
						continue;
					}
				}

				Z_ADDREF_PP(hd);
				if (likely(Z_TYPE(key) == IS_STRING)) {
					add_assoc_zval_ex(data, Z_STRVAL(key), Z_STRLEN(key)+1, *hd);
				}
				else {
					add_index_zval(data, Z_LVAL(key), *hd);
				}
			}
		}
	}
	else {
		array_init(data);
	}

	PHALCON_INIT_NVAR(status);

	if (PHALCON_IS_FALSE(mode)){
		ZVAL_STRING(&func, "save", 0);
	} else {
		ZVAL_STRING(&func, "insert", 0);
	}

	MAKE_STD_ZVAL(options);
	array_init_size(options, 1);

	add_assoc_long_ex(options, SS("w"), 1);

	params[0] = data;
	params[1] = options;

	call_user_function(NULL, &collection, &func, status, 2, params TSRMLS_CC);
	zval_ptr_dtor(&options);
	if (EG(exception)) {
		zval_ptr_dtor(&data);
		RETURN_MM();
	}

	PHALCON_INIT_NVAR(success);
	ZVAL_FALSE(success);

	if (phalcon_array_isset_string_fetch(&ok, status, SS("ok"))) {
		if (zend_is_true(ok)) {
			ZVAL_TRUE(success);
			if (PHALCON_IS_FALSE(exists) && phalcon_array_isset_string_fetch(&id, data, SS("_id"))) {
				phalcon_update_property_this_quick(this_ptr, SL("_id"), id, 2090005265UL TSRMLS_CC);
			}
		}
	}

	zval_ptr_dtor(&data);

	PHALCON_RETURN_CALL_METHOD(this_ptr, "_postsave", disable_events, success, exists);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, findById){

	zval *id, *class_name, *collection, *collection_manager = NULL;
	zval *use_implicit_ids = NULL, *mongo_id = NULL, *conditions;
	zval *parameters;
	zend_class_entry *ce0, *ce1;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &id);

	if (Z_TYPE_P(id) != IS_OBJECT) {

		PHALCON_INIT_VAR(class_name);
		phalcon_get_called_class(class_name  TSRMLS_CC);
		ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

		PHALCON_INIT_VAR(collection);
		object_init_ex(collection, ce0);
		if (phalcon_has_constructor(collection TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, collection, "__construct");
		}

		PHALCON_CALL_METHOD(&collection_manager, collection, "getcollectionmanager");

		PHALCON_CALL_METHOD(&use_implicit_ids, collection_manager, "isusingimplicitobjectids", collection);
		if (zend_is_true(use_implicit_ids)) {
			ce1 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_VAR(mongo_id);
			object_init_ex(mongo_id, ce1);
			if (phalcon_has_constructor(mongo_id TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, mongo_id, "__construct", id);
			}
		} else {
			PHALCON_CPY_WRT(mongo_id, id);
		}
	} else {
		PHALCON_CPY_WRT(mongo_id, id);
	}

	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 1);
	phalcon_array_update_string(&conditions, SL("_id"), mongo_id, PH_COPY);

	PHALCON_INIT_VAR(parameters);
	array_init_size(parameters, 1);
	phalcon_array_append(&parameters, conditions, 0);
	PHALCON_RETURN_CALL_SELF("findfirst", parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, findFirst){

	zval *parameters = NULL, *class_name, *collection, *connection = NULL;
	zval *unique;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);

	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for findFirst");
			return;
		}
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");

	unique = PHALCON_GLOBAL(z_true);
	PHALCON_RETURN_CALL_SELF("_getresultset", parameters, collection, connection, unique);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, find){

	zval *parameters = NULL, *class_name, *collection, *connection = NULL;
	zval *unique;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);

	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for find");
			return;
		}
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");

	unique = PHALCON_GLOBAL(z_false);
	PHALCON_RETURN_CALL_SELF("_getresultset", parameters, collection, connection, unique);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, count){

	zval *parameters = NULL, *class_name, *collection, *connection = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);

	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for count");
			return;
		}
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");
	PHALCON_RETURN_CALL_SELF("_getgroupresultset", parameters, collection, connection);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, aggregate){

	zval *parameters, *class_name, *connection = NULL;
	zval *source = NULL, *collection = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &parameters);

	if (Z_TYPE_P(parameters) != IS_NULL) {
		if (Z_TYPE_P(parameters) != IS_ARRAY) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid parameters for aggregate");
			return;
		}
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");

	PHALCON_CALL_METHOD(&source, collection, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&collection, connection, "selectcollection", source);
	PHALCON_RETURN_CALL_METHOD(collection, "aggregate", parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, summatory){

	zval *field, *conditions = NULL, *finalize = NULL, *class_name;
	zval *connection = NULL, *source = NULL, *collection = NULL;
	zval *keys, *empty_array, *initial, *reduce, *group = NULL;
	zval *retval, *first_retval, *summatory;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &field, &conditions, &finalize);

	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}

	if (!finalize) {
		finalize = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid field name for group");
		return;
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");

	PHALCON_CALL_METHOD(&source, collection, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&collection, connection, "selectcollection", source);

	PHALCON_INIT_VAR(keys);
	array_init(keys);

	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);

	PHALCON_INIT_VAR(initial);
	array_init_size(initial, 1);
	phalcon_array_update_string(&initial, SL("summatory"), empty_array, PH_COPY);

	PHALCON_INIT_VAR(reduce);
	PHALCON_CONCAT_SVSVSVS(reduce, "function (curr, result) { if (typeof result.summatory[curr.", field, "] === \"undefined\") { result.summatory[curr.", field, "] = 1; } else { result.summatory[curr.", field, "]++; } }");

	PHALCON_CALL_METHOD(&group, collection, "group", keys, initial, reduce);
	if (phalcon_array_isset_quick_string(group, SS("retval"), 1060973715UL)) {

		PHALCON_OBS_VAR(retval);
		phalcon_array_fetch_quick_string(&retval, group, SS("retval"), 1060973715UL, PH_NOISY);
		if (phalcon_array_isset_long(retval, 0)) {

			PHALCON_OBS_VAR(first_retval);
			phalcon_array_fetch_long(&first_retval, retval, 0, PH_NOISY);
			if (phalcon_array_isset_quick_string(first_retval, SS("summatory"), 2358676118UL)) {
				PHALCON_OBS_VAR(summatory);
				phalcon_array_fetch_quick_string(&summatory, first_retval, SS("summatory"), 2358676118UL, PH_NOISY);
				RETURN_CTOR(summatory);
			}

			RETURN_CTOR(first_retval);
		}

		RETURN_CTOR(retval);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection, create){

	zval *data = NULL, *white_list = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &white_list);

	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}

	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}

	PHALCON_RETURN_CALL_METHOD(this_ptr, "save", data, white_list, PHALCON_GLOBAL(z_true));
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, update){

	zval *source = NULL, *connection = NULL, *collection = NULL, *exists = NULL;
	zval *type, *message, *collection_message, *messages;
	zval *data = NULL, *white_list = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &white_list);

	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}

	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}

	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&connection, this_ptr, "getconnection");

	PHALCON_CALL_METHOD(&collection, connection, "selectcollection", source);

	PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", collection);

	if (!zend_is_true(exists)) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "InvalidUpdateAttempt", 1);

		PHALCON_INIT_VAR(message);
		ZVAL_STRING(message, "Document cannot be updated because it does not exist", 1);

		PHALCON_INIT_VAR(collection_message);
		object_init_ex(collection_message, phalcon_mvc_collection_message_ce);
		PHALCON_CALL_METHOD(NULL, collection_message, "__construct", message, PHALCON_GLOBAL(z_null), type);

		PHALCON_INIT_VAR(messages);
		array_init_size(messages, 1);
		phalcon_array_append(&messages, collection_message, PH_SEPARATE);
		phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), messages, 1019066246UL TSRMLS_CC);
		RETURN_MM_FALSE;
	}

	PHALCON_RETURN_CALL_METHOD(this_ptr, "save", data, white_list, PHALCON_GLOBAL(z_false));
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, delete){

	zval *disable_events, *event_name = NULL, *status = NULL, *id;
	zval *connection = NULL, *source = NULL, *collection = NULL, *mongo_id = NULL;
	zval *collection_manager, *use_implicit_ids = NULL, *id_condition;
	zval *success = NULL, *options, *ok;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	if (!phalcon_isset_property(this_ptr, SS("_id") TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "The document cannot be deleted because it doesn't exist");
		return;
	}

	disable_events = phalcon_fetch_static_property_ce(phalcon_mvc_collection_ce, SL("_disableEvents") TSRMLS_CC);
	if (!zend_is_true(disable_events)) {

		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeDelete", 1);

		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}

	PHALCON_OBS_VAR(id);
	phalcon_read_property_this(&id, this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);

	PHALCON_CALL_METHOD(&connection, this_ptr, "getconnection");

	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (PHALCON_IS_EMPTY(source)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Method getSource() returns empty string");
		return;
	}

	PHALCON_CALL_METHOD(&collection, connection, "selectcollection", source);
	if (Z_TYPE_P(id) == IS_OBJECT || Z_TYPE_P(id) == IS_NULL) {
		PHALCON_CPY_WRT(mongo_id, id);
	} else {
		PHALCON_OBS_VAR(collection_manager);
		phalcon_read_property_this(&collection_manager, this_ptr, SL("_collectionManager"), PH_NOISY TSRMLS_CC);

		PHALCON_CALL_METHOD(&use_implicit_ids, collection_manager, "isusingimplicitobjectids", this_ptr);
		if (zend_is_true(use_implicit_ids)) {
			ce0 = zend_fetch_class(SL("MongoId"), ZEND_FETCH_CLASS_AUTO TSRMLS_CC);
			PHALCON_INIT_NVAR(mongo_id);
			object_init_ex(mongo_id, ce0);
			if (phalcon_has_constructor(mongo_id TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, mongo_id, "__construct", id);
			}
		} else {
			PHALCON_CPY_WRT(mongo_id, id);
		}
	}

	PHALCON_INIT_VAR(id_condition);
	array_init_size(id_condition, 1);
	phalcon_array_update_string(&id_condition, SL("_id"), mongo_id, PH_COPY);

	PHALCON_INIT_VAR(success);
	ZVAL_BOOL(success, 0);

	PHALCON_INIT_VAR(options);
	array_init_size(options, 1);
	add_assoc_long_ex(options, SS("w"), 1);

	PHALCON_CALL_METHOD(&status, collection, "remove", id_condition, options);
	if (Z_TYPE_P(status) != IS_ARRAY) {
		RETURN_MM_FALSE;
	}

	if (phalcon_array_isset_quick_string(status, SS("ok"), 193501407UL)) {

		PHALCON_OBS_VAR(ok);
		phalcon_array_fetch_quick_string(&ok, status, SS("ok"), 193501407UL, PH_NOISY);
		if (zend_is_true(ok)) {

			ZVAL_BOOL(success, 1);
			if (!zend_is_true(disable_events)) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "afterDelete", 1);
				PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
			}
		}
	} else {
		PHALCON_INIT_NVAR(success);
		ZVAL_BOOL(success, 0);
	}

	RETURN_NCTOR(success);
}

static PHP_METHOD(Phalcon_Mvc_Collection, toArray){

	zval *data, *reserved = NULL, *properties = NULL, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(data);
	array_init(data);

	PHALCON_CALL_METHOD(&reserved, this_ptr, "getreservedattributes");

	PHALCON_CALL_FUNCTION(&properties, "get_object_vars", this_ptr);

	phalcon_is_iterable(properties, &ah0, &hp0, 0, 0);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);

		if (PHALCON_IS_STRING(key, "_id")) {

			if (Z_TYPE_P(value) != IS_NULL) {
				phalcon_array_update_zval(&data, key, value, PH_COPY);
			}
		} else {
			if (!phalcon_array_isset(reserved, key)) {
				phalcon_array_update_zval(&data, key, value, PH_COPY);
			}
		}

		zend_hash_move_forward_ex(ah0, &hp0);
	}

	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Collection, serialize){

	zval *data = NULL;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&data, this_ptr, "toarray");

	phalcon_serialize(return_value, &data TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Collection, unserialize){

	zval *data, *attributes, *dependency_injector = NULL;
	zval *service, *manager = NULL, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);

	if (Z_TYPE_P(data) == IS_STRING) {

		PHALCON_INIT_VAR(attributes);
		phalcon_unserialize(attributes, data TSRMLS_CC);
		if (Z_TYPE_P(attributes) == IS_ARRAY) {

			PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");

			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A dependency injector container is required to obtain the services related to the ODM");
				return;
			}

			phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);

			PHALCON_INIT_VAR(service);
			ZVAL_STRING(service, "collectionManager", 1);

			PHALCON_CALL_METHOD(&manager, dependency_injector, "getshared", service);
			if (Z_TYPE_P(manager) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "The injected service 'collectionManager' is not valid");
				return;
			}

			PHALCON_VERIFY_INTERFACE(manager, phalcon_mvc_collection_managerinterface_ce);

			phalcon_update_property_this_quick(this_ptr, SL("_collectionManager"), manager, 2683361163UL TSRMLS_CC);

			phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);

			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

				PHALCON_GET_HKEY(key, ah0, hp0);
				PHALCON_GET_HVALUE(value);

				phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);

				zend_hash_move_forward_ex(ah0, &hp0);
			}

			RETURN_MM_NULL();
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid serialization data");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Collection, execute){

	zval *code, *args = NULL, *class_name, *collection, *connection = NULL;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &code, &args);

	if (args && Z_TYPE_P(args) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid args for execute");
		return;
	}

	PHALCON_INIT_VAR(class_name);
	phalcon_get_called_class(class_name  TSRMLS_CC);
	ce0 = phalcon_fetch_class(class_name TSRMLS_CC);

	PHALCON_INIT_VAR(collection);
	object_init_ex(collection, ce0);
	if (phalcon_has_constructor(collection TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, collection, "__construct");
	}

	PHALCON_CALL_METHOD(&connection, collection, "getconnection");

	if (args) {
		PHALCON_RETURN_CALL_METHOD(connection, "execute", code, args);
	} else {
		PHALCON_RETURN_CALL_METHOD(connection, "execute", code);
	}

	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_mvc_collectioninterface_ce;

static const zend_function_entry phalcon_mvc_collectioninterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, setId, arginfo_phalcon_mvc_collectioninterface_setid)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, getId, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, getReservedAttributes, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, getSource, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, setConnectionService, arginfo_phalcon_mvc_collectioninterface_setconnectionservice)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, getConnection, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, readAttribute, arginfo_phalcon_mvc_collectioninterface_readattribute)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, writeAttribute, arginfo_phalcon_mvc_collectioninterface_writeattribute)
	ZEND_FENTRY(cloneResult, NULL, arginfo_phalcon_mvc_collectioninterface_cloneresult, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, fireEvent, arginfo_phalcon_mvc_collectioninterface_fireevent)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, fireEventCancel, arginfo_phalcon_mvc_collectioninterface_fireeventcancel)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, validationHasFailed, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, getMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, appendMessage, arginfo_phalcon_mvc_collectioninterface_appendmessage)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, save, NULL)
	ZEND_FENTRY(findById, NULL, arginfo_phalcon_mvc_collectioninterface_findbyid, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(findFirst, NULL, arginfo_phalcon_mvc_collectioninterface_findfirst, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(find, NULL, arginfo_phalcon_mvc_collectioninterface_find, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(count, NULL, arginfo_phalcon_mvc_collectioninterface_count, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, create, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, update, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_CollectionInterface, delete, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_CollectionInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, CollectionInterface, mvc_collectioninterface, phalcon_mvc_collectioninterface_method_entry);

	return SUCCESS;
}




























zend_class_entry *phalcon_mvc_controller_ce;

static PHP_METHOD(Phalcon_Mvc_Controller, __construct);

static const zend_function_entry phalcon_mvc_controller_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Controller, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL|ZEND_ACC_CTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Controller){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Controller, mvc_controller, phalcon_di_injectable_ce, phalcon_mvc_controller_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_class_implements(phalcon_mvc_controller_ce TSRMLS_CC, 1, phalcon_mvc_controllerinterface_ce);
	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Controller, __construct){

	if (phalcon_method_quick_exists_ex(this_ptr, SS("onconstruct"), 564344039UL TSRMLS_CC) == SUCCESS) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, this_ptr, "onconstruct");
		PHALCON_MM_RESTORE();
	}
}





zend_class_entry *phalcon_mvc_controllerinterface_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_ControllerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ControllerInterface, mvc_controllerinterface, NULL);

	return SUCCESS;
}







zend_class_entry *phalcon_mvc_dispatcher_ce;

static PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerSuffix);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, setDefaultController);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerName);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getControllerName);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, _throwDispatchException);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, _handleException);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getControllerClass);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getLastController);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getActiveController);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getPreviousControllerName);
static PHP_METHOD(Phalcon_Mvc_Dispatcher, getPreviousActionName);

static const zend_function_entry phalcon_mvc_dispatcher_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Dispatcher, setControllerSuffix, arginfo_phalcon_mvc_dispatcherinterface_setcontrollersuffix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, setDefaultController, arginfo_phalcon_mvc_dispatcherinterface_setdefaultcontroller, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, setControllerName, arginfo_phalcon_mvc_dispatcherinterface_setcontrollername, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, getControllerName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, _throwDispatchException, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Dispatcher, _handleException, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Dispatcher, getControllerClass, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, getLastController, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, getActiveController, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, getPreviousControllerName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Dispatcher, getPreviousActionName, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Dispatcher){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Dispatcher, mvc_dispatcher, phalcon_dispatcher_ce, phalcon_mvc_dispatcher_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_handlerSuffix"), "Controller", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_defaultHandler"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_dispatcher_ce, SL("_defaultAction"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_dispatcher_ce TSRMLS_CC, 2, phalcon_dispatcherinterface_ce, phalcon_mvc_dispatcherinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerSuffix){

	zval *controller_suffix;

	phalcon_fetch_params(0, 1, 0, &controller_suffix);

	phalcon_update_property_this_quick(this_ptr, SL("_handlerSuffix"), controller_suffix, 1659190583UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, setDefaultController){

	zval *controller_name;

	phalcon_fetch_params(0, 1, 0, &controller_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultHandler"), controller_name, 2940762855UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, setControllerName){

	zval *controller_name, *is_exact = NULL;

	phalcon_fetch_params(0, 1, 1, &controller_name, &is_exact);

	if (is_exact && zend_is_true(is_exact)) {
		zval *name;
		MAKE_STD_ZVAL(name);
		PHALCON_CONCAT_SV(name, "\\", controller_name);
		phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), name, 2743819555UL TSRMLS_CC);
		zval_ptr_dtor(&name);
		phalcon_update_property_this(this_ptr, SL("_isExactHandler"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
	}
	else {
		phalcon_update_property_this_quick(this_ptr, SL("_handlerName"), controller_name, 2743819555UL TSRMLS_CC);
		phalcon_update_property_this(this_ptr, SL("_isExactHandler"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getControllerName){

	zval *is_exact;

	is_exact = phalcon_fetch_nproperty_this(getThis(), SL("_isExactHandler"), PH_NOISY TSRMLS_CC);

	if (!zend_is_true(is_exact)) {
		RETURN_MEMBER_QUICK(this_ptr, "_handlerName", 2743819555UL);
	}

	phalcon_return_property_quick(return_value, NULL, getThis(), SL("_handlerName"), 2743819555UL TSRMLS_CC);
	if (likely(Z_TYPE_P(return_value) == IS_STRING) && Z_STRLEN_P(return_value) > 1) {
		if (Z_STRVAL_P(return_value)[0] == '\\') {
			char *c = Z_STRVAL_P(return_value);
			int len = Z_STRLEN_P(return_value);
			memmove(c, c+1, len); /* This will include the trailing zero */
			RETVAL_STRINGL(c, len - 1, 0);
		}
	}
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, _throwDispatchException){

	zval *message, *exception_code = NULL, *dependency_injector;
	zval *exception_message, *exception = NULL, *service;
	zval *response = NULL, *status_code, *status_message;
	zval *events_manager, *event_name, *status = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &message, &exception_code);

	if (!exception_code) {
		PHALCON_INIT_VAR(exception_code);
		ZVAL_LONG(exception_code, 0);
	} else {
		PHALCON_SEPARATE_PARAM(exception_code);
	}

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_NVAR(exception_code);
		ZVAL_LONG(exception_code, 0);

		PHALCON_INIT_VAR(exception_message);
		ZVAL_STRING(exception_message, "A dependency injection container is required to access the 'response' service", 1);

		PHALCON_INIT_VAR(exception);
		object_init_ex(exception, phalcon_mvc_dispatcher_exception_ce);
		PHALCON_CALL_METHOD(NULL, exception, "__construct", exception_message, exception_code);

		phalcon_throw_exception(exception TSRMLS_CC);
		RETURN_MM();
	}

	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_response);

	PHALCON_CALL_METHOD(&response, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(response, phalcon_http_responseinterface_ce);

	PHALCON_INIT_VAR(status_code);
	ZVAL_LONG(status_code, 404);

	PHALCON_INIT_VAR(status_message);
	ZVAL_STRING(status_message, "Not Found", 1);
	PHALCON_CALL_METHOD(NULL, response, "setstatuscode", status_code, status_message);

	PHALCON_INIT_NVAR(exception);
	object_init_ex(exception, phalcon_mvc_dispatcher_exception_ce);
	PHALCON_CALL_METHOD(NULL, exception, "__construct", message, exception_code);

	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {

		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);

		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, exception);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}

	phalcon_throw_exception(exception TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, _handleException){

	zval *exception, *events_manager, *event_name;

	phalcon_fetch_params(0, 1, 0, &exception);

	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_ALLOC_GHOST_ZVAL(event_name);
		ZVAL_STRING(event_name, "dispatch:beforeException", 1);

		PHALCON_RETURN_CALL_METHODW(events_manager, "fire", event_name, this_ptr, exception);
	}
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getControllerClass)
{
	PHALCON_RETURN_CALL_METHODW(this_ptr, "gethandlerclass");
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getLastController){


	RETURN_MEMBER_QUICK(this_ptr, "_lastHandler", 1315517974UL);
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getActiveController){


	RETURN_MEMBER_QUICK(this_ptr, "_activeHandler", 2923197278UL);
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getPreviousControllerName){


	RETURN_MEMBER_QUICK(this_ptr, "_previousHandlerName", 1385015136UL);
}

static PHP_METHOD(Phalcon_Mvc_Dispatcher, getPreviousActionName){


	RETURN_MEMBER_QUICK(this_ptr, "_previousActionName", 3455223264UL);
}






zend_class_entry *phalcon_mvc_dispatcherinterface_ce;

static const zend_function_entry phalcon_mvc_dispatcherinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, setControllerSuffix, arginfo_phalcon_mvc_dispatcherinterface_setcontrollersuffix)
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, setDefaultController, arginfo_phalcon_mvc_dispatcherinterface_setdefaultcontroller)
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, setControllerName, arginfo_phalcon_mvc_dispatcherinterface_setcontrollername)
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, getControllerName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, getLastController, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_DispatcherInterface, getActiveController, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_DispatcherInterface){

	PHALCON_REGISTER_INTERFACE_EX(Phalcon\\Mvc, DispatcherInterface, mvc_dispatcherinterface, phalcon_dispatcherinterface_ce, phalcon_mvc_dispatcherinterface_method_entry);

	return SUCCESS;
}













zend_class_entry *phalcon_mvc_micro_ce;

static PHP_METHOD(Phalcon_Mvc_Micro, __construct);
static PHP_METHOD(Phalcon_Mvc_Micro, setDI);
static PHP_METHOD(Phalcon_Mvc_Micro, map);
static PHP_METHOD(Phalcon_Mvc_Micro, get);
static PHP_METHOD(Phalcon_Mvc_Micro, post);
static PHP_METHOD(Phalcon_Mvc_Micro, put);
static PHP_METHOD(Phalcon_Mvc_Micro, patch);
static PHP_METHOD(Phalcon_Mvc_Micro, head);
static PHP_METHOD(Phalcon_Mvc_Micro, delete);
static PHP_METHOD(Phalcon_Mvc_Micro, options);
static PHP_METHOD(Phalcon_Mvc_Micro, mount);
static PHP_METHOD(Phalcon_Mvc_Micro, notFound);
static PHP_METHOD(Phalcon_Mvc_Micro, getRouter);
static PHP_METHOD(Phalcon_Mvc_Micro, setService);
static PHP_METHOD(Phalcon_Mvc_Micro, hasService);
static PHP_METHOD(Phalcon_Mvc_Micro, getService);
static PHP_METHOD(Phalcon_Mvc_Micro, getSharedService);
static PHP_METHOD(Phalcon_Mvc_Micro, handle);
static PHP_METHOD(Phalcon_Mvc_Micro, stop);
static PHP_METHOD(Phalcon_Mvc_Micro, setActiveHandler);
static PHP_METHOD(Phalcon_Mvc_Micro, getActiveHandler);
static PHP_METHOD(Phalcon_Mvc_Micro, getReturnedValue);
static PHP_METHOD(Phalcon_Mvc_Micro, offsetUnset);
static PHP_METHOD(Phalcon_Mvc_Micro, before);
static PHP_METHOD(Phalcon_Mvc_Micro, after);
static PHP_METHOD(Phalcon_Mvc_Micro, finish);
static PHP_METHOD(Phalcon_Mvc_Micro, getHandlers);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_setdi, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_map, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_get, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_post, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_put, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_patch, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_head, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_delete, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_options, 0, 0, 2)
	ZEND_ARG_INFO(0, routePattern)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_mount, 0, 0, 1)
	ZEND_ARG_INFO(0, collection)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_notfound, 0, 0, 1)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_setservice, 0, 0, 2)
	ZEND_ARG_INFO(0, serviceName)
	ZEND_ARG_INFO(0, definition)
	ZEND_ARG_INFO(0, shared)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_hasservice, 0, 0, 1)
	ZEND_ARG_INFO(0, serviceName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_getservice, 0, 0, 1)
	ZEND_ARG_INFO(0, serviceName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_getsharedservice, 0, 0, 1)
	ZEND_ARG_INFO(0, serviceName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_handle, 0, 0, 0)
	ZEND_ARG_INFO(0, uri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_setactivehandler, 0, 0, 1)
	ZEND_ARG_INFO(0, activeHandler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_offsetunset, 0, 0, 1)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_before, 0, 0, 1)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_after, 0, 0, 1)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_finish, 0, 0, 1)
	ZEND_ARG_INFO(0, handler)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_micro_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Micro, __construct, arginfo_phalcon_mvc_micro___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Micro, setDI, arginfo_phalcon_mvc_micro_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, map, arginfo_phalcon_mvc_micro_map, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, get, arginfo_phalcon_mvc_micro_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, post, arginfo_phalcon_mvc_micro_post, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, put, arginfo_phalcon_mvc_micro_put, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, patch, arginfo_phalcon_mvc_micro_patch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, head, arginfo_phalcon_mvc_micro_head, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, delete, arginfo_phalcon_mvc_micro_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, options, arginfo_phalcon_mvc_micro_options, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, mount, arginfo_phalcon_mvc_micro_mount, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, notFound, arginfo_phalcon_mvc_micro_notfound, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getRouter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, setService, arginfo_phalcon_mvc_micro_setservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, hasService, arginfo_phalcon_mvc_micro_hasservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getService, arginfo_phalcon_mvc_micro_getservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getSharedService, arginfo_phalcon_mvc_micro_getsharedservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, handle, arginfo_phalcon_mvc_micro_handle, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, stop, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, setActiveHandler, arginfo_phalcon_mvc_micro_setactivehandler, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getActiveHandler, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getReturnedValue, NULL, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_Micro, offsetExists, hasService, arginfo_phalcon_mvc_micro_hasservice, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_Micro, offsetSet, setService, arginfo_phalcon_mvc_micro_setservice, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_Micro, offsetGet, getService, arginfo_phalcon_mvc_micro_getservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, offsetUnset, arginfo_phalcon_mvc_micro_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, before, arginfo_phalcon_mvc_micro_before, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, after, arginfo_phalcon_mvc_micro_after, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, finish, arginfo_phalcon_mvc_micro_finish, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro, getHandlers, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, Micro, mvc_micro, phalcon_di_injectable_ce, phalcon_mvc_micro_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_handlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_router"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_stopped"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_notFoundHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_activeHandler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_beforeHandlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_afterHandlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_finishHandlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_ce, SL("_returnedValue"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_micro_ce TSRMLS_CC, 1, zend_ce_arrayaccess);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Micro, __construct){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &dependency_injector);
	
	if (dependency_injector && Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		PHALCON_VERIFY_INTERFACE(dependency_injector, phalcon_diinterface_ce);
		PHALCON_CALL_METHOD(NULL, this_ptr, "setdi", dependency_injector);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Micro, setDI){

	zval *dependency_injector, *service, *exists = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_micro_exception_ce, 1);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "application", 1);
	
	PHALCON_CALL_METHOD(&exists, dependency_injector, "has", service);
	if (!zend_is_true(exists)) {
		PHALCON_CALL_METHOD(NULL, dependency_injector, "set", service, this_ptr);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static void phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAMETERS, const char *method)
{
	zval *route_pattern, *handler, *router = NULL, *route_id = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler);
	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&router, this_ptr, "getrouter");

	PHALCON_RETURN_CALL_METHOD(router, method, route_pattern);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	PHALCON_CALL_METHOD(&route_id, return_value, "getrouteid");
	phalcon_update_property_array(this_ptr, SL("_handlers"), route_id, handler TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Micro, map){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "add");
}

static PHP_METHOD(Phalcon_Mvc_Micro, get){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addget");
}

static PHP_METHOD(Phalcon_Mvc_Micro, post){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addpost");
}

static PHP_METHOD(Phalcon_Mvc_Micro, put){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addput");
}

static PHP_METHOD(Phalcon_Mvc_Micro, patch){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addpatch");
}

static PHP_METHOD(Phalcon_Mvc_Micro, head){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addhead");
}

static PHP_METHOD(Phalcon_Mvc_Micro, delete){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "adddelete");
}

static PHP_METHOD(Phalcon_Mvc_Micro, options){

	phalcon_mvc_micro_generic_add(INTERNAL_FUNCTION_PARAM_PASSTHRU, "addoptions");
}

static PHP_METHOD(Phalcon_Mvc_Micro, mount){

	zval *collection, *main_handler = NULL, *handlers = NULL, *lazy = NULL;
	zval *lazy_handler = NULL, *prefix = NULL, *handler = NULL;
	zval *real_handler = NULL, *prefixed_pattern = NULL;
	zval *route = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &collection);
	PHALCON_VERIFY_INTERFACE_EX(collection, phalcon_mvc_micro_collectioninterface_ce, phalcon_mvc_micro_exception_ce, 1);
	
	/* Get the main handler */
	PHALCON_CALL_METHOD(&main_handler, collection, "gethandler");
	if (PHALCON_IS_EMPTY(main_handler)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "The collection requires a main handler");
		return;
	}
	
	PHALCON_CALL_METHOD(&handlers, collection, "gethandlers");
	if (!phalcon_fast_count_ev(handlers TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "There are no handlers to mount");
		return;
	}
	
	if (Z_TYPE_P(handlers) == IS_ARRAY) { 
	
		/* Check if handler is lazy */
		PHALCON_CALL_METHOD(&lazy, collection, "islazy");
		if (zend_is_true(lazy)) {
			PHALCON_INIT_VAR(lazy_handler);
			object_init_ex(lazy_handler, phalcon_mvc_micro_lazyloader_ce);
			PHALCON_CALL_METHOD(NULL, lazy_handler, "__construct", main_handler);
	
		} else {
			PHALCON_CPY_WRT(lazy_handler, main_handler);
		}
	
		/* Get the main prefix for the collection */
		PHALCON_CALL_METHOD(&prefix, collection, "getprefix");
	
		phalcon_is_iterable(handlers, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			zval *methods, *pattern, *sub_handler, *name;

			PHALCON_GET_HVALUE(handler);
	
			if (Z_TYPE_P(handler) != IS_ARRAY) { 
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "One of the registered handlers is invalid");
				return;
			}

			if (
				    !phalcon_array_isset_long_fetch(&methods, handler, 0)
				 || !phalcon_array_isset_long_fetch(&pattern, handler, 1)
				 || !phalcon_array_isset_long_fetch(&sub_handler, handler, 2)
				 || !phalcon_array_isset_long_fetch(&name, handler, 3)
			) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "One of the registered handlers is invalid");
				return;
			}
	
			/* Create a real handler */
			PHALCON_INIT_NVAR(real_handler);
			array_init_size(real_handler, 2);
			phalcon_array_append(&real_handler, lazy_handler, 0);
			phalcon_array_append(&real_handler, sub_handler, 0);
			if (PHALCON_IS_NOT_EMPTY(prefix)) {
				if (PHALCON_IS_STRING(pattern, "/")) {
					PHALCON_CPY_WRT(prefixed_pattern, prefix);
				} else {
					PHALCON_INIT_NVAR(prefixed_pattern);
					PHALCON_CONCAT_VV(prefixed_pattern, prefix, pattern);
				}
			} else {
				PHALCON_CPY_WRT(prefixed_pattern, pattern);
			}
	
			/* Map the route manually */
			PHALCON_CALL_METHOD(&route, this_ptr, "map", prefixed_pattern, real_handler);
			if (Z_TYPE_P(methods) != IS_NULL) {
				PHALCON_CALL_METHOD(NULL, route, "via", methods);
			}

			if (Z_TYPE_P(name) != IS_NULL) {
				PHALCON_CALL_METHOD(NULL, route, "setname", name);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Micro, notFound){

	zval *handler;

	phalcon_fetch_params(0, 1, 0, &handler);
	
	phalcon_update_property_this_quick(this_ptr, SL("_notFoundHandler"), handler, 2638317359UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro, getRouter){

	zval *router, *service_name, *tmp = NULL;

	router = phalcon_fetch_nproperty_this(this_ptr, SL("_router"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(router) != IS_OBJECT) {
		PHALCON_MM_GROW();

		PHALCON_INIT_VAR(service_name);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service_name, phalcon_interned_router);
	
		PHALCON_CALL_METHOD(&tmp, this_ptr, "getsharedservice", service_name);
		PHALCON_VERIFY_INTERFACE(tmp, phalcon_mvc_routerinterface_ce);
	
		PHALCON_CALL_METHOD(NULL, tmp, "clear");
	
		PHALCON_CALL_METHOD(NULL, tmp, "removeextraslashes", PHALCON_GLOBAL(z_true));
	
		phalcon_update_property_this_quick(this_ptr, SL("_router"), tmp, 2063827077UL TSRMLS_CC);
		RETURN_CTOR(tmp);
	}

	RETURN_ZVAL(router, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro, setService){

	zval *service_name, *definition, *shared = NULL, *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &service_name, &definition, &shared);
	
	if (!shared) {
		shared = PHALCON_GLOBAL(z_false);
	}
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD(NULL, dependency_injector, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(dependency_injector, "set", service_name, definition, shared);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Micro, hasService){

	zval *service_name, *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &service_name);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD(NULL, dependency_injector, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(dependency_injector, "has", service_name);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Micro, getService){

	zval *service_name, *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &service_name);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD(NULL, dependency_injector, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(dependency_injector, "get", service_name);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Micro, getSharedService){

	zval *service_name, *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &service_name);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_INIT_VAR(dependency_injector);
		object_init_ex(dependency_injector, phalcon_di_factorydefault_ce);
		PHALCON_CALL_METHOD(NULL, dependency_injector, "__construct");
	
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(dependency_injector, "getshared", service_name);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Micro, handle){

	zval *uri = NULL, *dependency_injector, *events_manager = NULL;
	zval *event_name = NULL, *status = NULL, *service, *router = NULL, *matched_route = NULL;
	zval *handlers, *route_id = NULL, *handler = NULL, *before_handlers;
	zval *before = NULL, *stopped = NULL, *params = NULL;
	zval *returned_value = NULL, *after_handlers, *after = NULL;
	zval *not_found_handler, *finish_handlers;
	zval *finish = NULL, *returned_response_sent = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &uri);
	
	if (!uri) {
		uri = PHALCON_GLOBAL(z_null);
	}
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "A dependency injection container is required to access related dispatching services");
		return;
	}
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "micro:beforeHandleRoute", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_router);
	
	PHALCON_CALL_METHOD(&router, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(router, phalcon_mvc_routerinterface_ce);
	
	PHALCON_CALL_METHOD(NULL, router, "handle", uri);
	
	PHALCON_CALL_METHOD(&matched_route, router, "getmatchedroute");
	if (Z_TYPE_P(matched_route) == IS_OBJECT) {
	
		handlers = phalcon_fetch_nproperty_this(this_ptr, SL("_handlers"), PH_NOISY TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&route_id, matched_route, "getrouteid");
		if (!phalcon_array_isset_fetch(&handler, handlers, route_id)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "Matched route doesn't have an associate handler");
			return;
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_activeHandler"), handler, 2923197278UL TSRMLS_CC);
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:beforeExecuteRoute", 1);
	
			PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_MM_FALSE;
			} else {
				handler = phalcon_fetch_nproperty_this(this_ptr, SL("_activeHandler"), PH_NOISY TSRMLS_CC);
			}
		}
	
		before_handlers = phalcon_fetch_nproperty_this(this_ptr, SL("_beforeHandlers"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(before_handlers) == IS_ARRAY) { 
			phalcon_update_property_this(this_ptr, SL("_stopped"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	
			phalcon_is_iterable(before_handlers, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(before);
	
				if (Z_TYPE_P(before) == IS_OBJECT) {
					int is_middleware = instanceof_function_ex(Z_OBJCE_P(before), phalcon_mvc_micro_middlewareinterface_ce, 1 TSRMLS_CC);
	
					if (is_middleware) {
	
						PHALCON_CALL_METHOD(&status, before, "call", this_ptr);
	
						stopped = phalcon_fetch_nproperty_this(this_ptr, SL("_stopped"), PH_NOISY TSRMLS_CC);
	
						if (zend_is_true(stopped)) {
							break;
						}
	
						zend_hash_move_forward_ex(ah0, &hp0);
						continue;
					}
				}
				if (!phalcon_is_callable(before TSRMLS_CC)) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "The before handler is not callable");
					return;
				}
	
				PHALCON_INIT_NVAR(status);/**/
				PHALCON_CALL_USER_FUNC(status, before);
				if (PHALCON_IS_FALSE(status)) {
					RETURN_MM_FALSE;
				}
	
				stopped = phalcon_fetch_nproperty_this(this_ptr, SL("_stopped"), PH_NOISY TSRMLS_CC);
				if (zend_is_true(stopped)) {
					RETURN_CCTOR(status);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		PHALCON_CALL_METHOD(&params, router, "getparams");
	
		PHALCON_INIT_VAR(returned_value);/**/
		PHALCON_CALL_USER_FUNC_ARRAY(returned_value, handler, params);
	
		phalcon_update_property_this_quick(this_ptr, SL("_returnedValue"), returned_value, 4143876906UL TSRMLS_CC);
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:afterExecuteRoute", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
	
		after_handlers = phalcon_fetch_nproperty_this(this_ptr, SL("_afterHandlers"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(after_handlers) == IS_ARRAY) { 
			phalcon_update_property_bool(this_ptr, SL("_stopped"), 0 TSRMLS_CC);
	
			phalcon_is_iterable(after_handlers, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HVALUE(after);
	
				if (Z_TYPE_P(after) == IS_OBJECT) {
					int is_middleware = instanceof_function_ex(Z_OBJCE_P(after), phalcon_mvc_micro_middlewareinterface_ce, 1 TSRMLS_CC);
					if (is_middleware) {
	
						PHALCON_CALL_METHOD(&status, after, "call", this_ptr);
	
						stopped = phalcon_fetch_nproperty_this(this_ptr, SL("_stopped"), PH_NOISY TSRMLS_CC);
	
						if (zend_is_true(stopped)) {
							break;
						}
	
						zend_hash_move_forward_ex(ah1, &hp1);
						continue;
					}
				}
				if (!phalcon_is_callable(after TSRMLS_CC)) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "One of the 'after' handlers is not callable");
					return;
				}
	
				PHALCON_INIT_NVAR(status);/**/
				PHALCON_CALL_USER_FUNC(status, after);
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
		}
	} else {
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "micro:beforeNotFound", 1);
	
			PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_MM_FALSE;
			}
		}
	
		not_found_handler = phalcon_fetch_nproperty_this(this_ptr, SL("_notFoundHandler"), PH_NOISY TSRMLS_CC);
		if (!phalcon_is_callable(not_found_handler TSRMLS_CC)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "The Not-Found handler is not callable or is not defined");
			return;
		}
	
		PHALCON_CALL_USER_FUNC(return_value, not_found_handler);
	
		phalcon_update_property_this_quick(this_ptr, SL("_returnedValue"), return_value, 4143876906UL TSRMLS_CC);
	
		PHALCON_MM_RESTORE();
		return;
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "micro:afterHandleRoute", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
	}
	
	finish_handlers = phalcon_fetch_nproperty_this(this_ptr, SL("_finishHandlers"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(finish_handlers) == IS_ARRAY) { 
		phalcon_update_property_this(this_ptr, SL("_stopped"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	
		PHALCON_INIT_NVAR(params);
	
		phalcon_is_iterable(finish_handlers, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HVALUE(finish);
	
			if (Z_TYPE_P(finish) == IS_OBJECT) {
				int is_middleware = instanceof_function_ex(Z_OBJCE_P(finish), phalcon_mvc_micro_middlewareinterface_ce, 1 TSRMLS_CC);
				if (is_middleware) {
	
					PHALCON_CALL_METHOD(&status, finish, "call", this_ptr);
	
					stopped = phalcon_fetch_nproperty_this(this_ptr, SL("_stopped"), PH_NOISY TSRMLS_CC);
	
					if (zend_is_true(stopped)) {
						break;
					}
	
					zend_hash_move_forward_ex(ah2, &hp2);
					continue;
				}
			}
			if (!phalcon_is_callable(finish TSRMLS_CC)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_micro_exception_ce, "One of finish handlers is not callable");
				return;
			}
	
			if (Z_TYPE_P(params) == IS_NULL) {
				PHALCON_INIT_NVAR(params);
				array_init_size(params, 1);
				phalcon_array_append(&params, this_ptr, PH_SEPARATE);
			}
	
			PHALCON_INIT_NVAR(status);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(status, finish, params);
	
			stopped = phalcon_fetch_nproperty_this(this_ptr, SL("_stopped"), PH_NOISY TSRMLS_CC);
	
			if (zend_is_true(stopped)) {
				break;
			}
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
	}
	
	if (Z_TYPE_P(returned_value) == IS_OBJECT) {
		int returned_response =
				(Z_TYPE_P(returned_value) == IS_OBJECT)
			 && (instanceof_function_ex(Z_OBJCE_P(returned_value), phalcon_http_responseinterface_ce, 1 TSRMLS_CC))
		;

		PHALCON_CALL_METHOD(&returned_response_sent, returned_value, "issent");
		
		if (returned_response && PHALCON_IS_FALSE(returned_response_sent)) {
			PHALCON_CALL_METHOD(NULL, returned_value, "send");
		}
	}
	
	RETURN_CCTOR(returned_value);
}

static PHP_METHOD(Phalcon_Mvc_Micro, stop){


	phalcon_update_property_this(this_ptr, SL("_stopped"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Micro, setActiveHandler){

	zval *active_handler;

	phalcon_fetch_params(0, 1, 0, &active_handler);
	
	phalcon_update_property_this_quick(this_ptr, SL("_activeHandler"), active_handler, 2923197278UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Micro, getActiveHandler){


	RETURN_MEMBER_QUICK(this_ptr, "_activeHandler", 2923197278UL);
}

static PHP_METHOD(Phalcon_Mvc_Micro, getReturnedValue){


	RETURN_MEMBER_QUICK(this_ptr, "_returnedValue", 4143876906UL);
}




static PHP_METHOD(Phalcon_Mvc_Micro, offsetUnset){

	zval *alias;

	phalcon_fetch_params(0, 1, 0, &alias);
	
	RETURN_ZVAL(alias, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro, before){

	zval *handler;

	phalcon_fetch_params(0, 1, 0, &handler);
	
	phalcon_update_property_array_append(this_ptr, SL("_beforeHandlers"), handler TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro, after){

	zval *handler;

	phalcon_fetch_params(0, 1, 0, &handler);
	
	phalcon_update_property_array_append(this_ptr, SL("_afterHandlers"), handler TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro, finish){

	zval *handler;

	phalcon_fetch_params(0, 1, 0, &handler);
	
	phalcon_update_property_array_append(this_ptr, SL("_finishHandlers"), handler TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro, getHandlers){


	RETURN_MEMBER_QUICK(this_ptr, "_handlers", 2445210229UL);
}




#include <ext/pdo/php_pdo_driver.h>



zend_class_entry *phalcon_mvc_model_ce;

static PHP_METHOD(Phalcon_Mvc_Model, __construct);
static PHP_METHOD(Phalcon_Mvc_Model, setDI);
static PHP_METHOD(Phalcon_Mvc_Model, getDI);
static PHP_METHOD(Phalcon_Mvc_Model, setEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model, getEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model, getModelsMetaData);
static PHP_METHOD(Phalcon_Mvc_Model, getModelsManager);
static PHP_METHOD(Phalcon_Mvc_Model, setTransaction);
static PHP_METHOD(Phalcon_Mvc_Model, setSource);
static PHP_METHOD(Phalcon_Mvc_Model, getSource);
static PHP_METHOD(Phalcon_Mvc_Model, setSchema);
static PHP_METHOD(Phalcon_Mvc_Model, getSchema);
static PHP_METHOD(Phalcon_Mvc_Model, setConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model, setReadConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model, setWriteConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model, getReadConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model, getWriteConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model, setDirtyState);
static PHP_METHOD(Phalcon_Mvc_Model, getDirtyState);
static PHP_METHOD(Phalcon_Mvc_Model, getReadConnection);
static PHP_METHOD(Phalcon_Mvc_Model, getWriteConnection);
static PHP_METHOD(Phalcon_Mvc_Model, assign);
static PHP_METHOD(Phalcon_Mvc_Model, cloneResultMap);
static PHP_METHOD(Phalcon_Mvc_Model, cloneResultMapHydrate);
static PHP_METHOD(Phalcon_Mvc_Model, cloneResult);
static PHP_METHOD(Phalcon_Mvc_Model, find);
static PHP_METHOD(Phalcon_Mvc_Model, findFirst);
static PHP_METHOD(Phalcon_Mvc_Model, query);
static PHP_METHOD(Phalcon_Mvc_Model, _exists);
static PHP_METHOD(Phalcon_Mvc_Model, _groupResult);
static PHP_METHOD(Phalcon_Mvc_Model, count);
static PHP_METHOD(Phalcon_Mvc_Model, sum);
static PHP_METHOD(Phalcon_Mvc_Model, maximum);
static PHP_METHOD(Phalcon_Mvc_Model, minimum);
static PHP_METHOD(Phalcon_Mvc_Model, average);
static PHP_METHOD(Phalcon_Mvc_Model, fireEvent);
static PHP_METHOD(Phalcon_Mvc_Model, fireEventCancel);
static PHP_METHOD(Phalcon_Mvc_Model, _cancelOperation);
static PHP_METHOD(Phalcon_Mvc_Model, appendMessage);
static PHP_METHOD(Phalcon_Mvc_Model, validate);
static PHP_METHOD(Phalcon_Mvc_Model, validationHasFailed);
static PHP_METHOD(Phalcon_Mvc_Model, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysRestrict);
static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysReverseRestrict);
static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysReverseCascade);
static PHP_METHOD(Phalcon_Mvc_Model, _preSave);
static PHP_METHOD(Phalcon_Mvc_Model, _postSave);
static PHP_METHOD(Phalcon_Mvc_Model, _doLowInsert);
static PHP_METHOD(Phalcon_Mvc_Model, _doLowUpdate);
static PHP_METHOD(Phalcon_Mvc_Model, _preSaveRelatedRecords);
static PHP_METHOD(Phalcon_Mvc_Model, _postSaveRelatedRecords);
static PHP_METHOD(Phalcon_Mvc_Model, save);
static PHP_METHOD(Phalcon_Mvc_Model, create);
static PHP_METHOD(Phalcon_Mvc_Model, update);
static PHP_METHOD(Phalcon_Mvc_Model, delete);
static PHP_METHOD(Phalcon_Mvc_Model, getOperationMade);
static PHP_METHOD(Phalcon_Mvc_Model, refresh);
static PHP_METHOD(Phalcon_Mvc_Model, skipOperation);
static PHP_METHOD(Phalcon_Mvc_Model, readAttribute);
static PHP_METHOD(Phalcon_Mvc_Model, writeAttribute);
static PHP_METHOD(Phalcon_Mvc_Model, skipAttributes);
static PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnCreate);
static PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnUpdate);
static PHP_METHOD(Phalcon_Mvc_Model, hasOne);
static PHP_METHOD(Phalcon_Mvc_Model, belongsTo);
static PHP_METHOD(Phalcon_Mvc_Model, hasMany);
static PHP_METHOD(Phalcon_Mvc_Model, hasManyToMany);
static PHP_METHOD(Phalcon_Mvc_Model, addBehavior);
static PHP_METHOD(Phalcon_Mvc_Model, keepSnapshots);
static PHP_METHOD(Phalcon_Mvc_Model, setSnapshotData);
static PHP_METHOD(Phalcon_Mvc_Model, hasSnapshotData);
static PHP_METHOD(Phalcon_Mvc_Model, getSnapshotData);
static PHP_METHOD(Phalcon_Mvc_Model, hasChanged);
static PHP_METHOD(Phalcon_Mvc_Model, getChangedFields);
static PHP_METHOD(Phalcon_Mvc_Model, useDynamicUpdate);
static PHP_METHOD(Phalcon_Mvc_Model, getRelated);
static PHP_METHOD(Phalcon_Mvc_Model, _getRelatedRecords);
static PHP_METHOD(Phalcon_Mvc_Model, __call);
static PHP_METHOD(Phalcon_Mvc_Model, __callStatic);
static PHP_METHOD(Phalcon_Mvc_Model, __set);
static PHP_METHOD(Phalcon_Mvc_Model, __get);
static PHP_METHOD(Phalcon_Mvc_Model, __isset);
static PHP_METHOD(Phalcon_Mvc_Model, serialize);
static PHP_METHOD(Phalcon_Mvc_Model, unserialize);
static PHP_METHOD(Phalcon_Mvc_Model, dump);
static PHP_METHOD(Phalcon_Mvc_Model, toArray);
static PHP_METHOD(Phalcon_Mvc_Model, setup);
static PHP_METHOD(Phalcon_Mvc_Model, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
	ZEND_ARG_INFO(0, modelsManager)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_setsource, 0, 0, 1)
	ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_setschema, 0, 0, 1)
	ZEND_ARG_INFO(0, schema)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_setdirtystate, 0, 0, 1)
	ZEND_ARG_INFO(0, dirtyState)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_validate, 0, 0, 1)
	ZEND_ARG_INFO(0, validator)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_skipoperation, 0, 0, 1)
	ZEND_ARG_INFO(0, skip)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_skipattributes, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
	ZEND_ARG_INFO(0, replace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_skipattributesoncreate, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
	ZEND_ARG_INFO(0, replace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_skipattributesonupdate, 0, 0, 1)
	ZEND_ARG_INFO(0, attributes)
	ZEND_ARG_INFO(0, replace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_hasone, 0, 0, 3)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, referenceModel)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_belongsto, 0, 0, 3)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, referenceModel)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_hasmany, 0, 0, 3)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, referenceModel)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_hasmanytomany, 0, 0, 6)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, intermediateModel)
	ZEND_ARG_INFO(0, intermediateFields)
	ZEND_ARG_INFO(0, intermediateReferencedFields)
	ZEND_ARG_INFO(0, referenceModel)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_addbehavior, 0, 0, 1)
	ZEND_ARG_INFO(0, behavior)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_keepsnapshots, 0, 0, 1)
	ZEND_ARG_INFO(0, keepSnapshots)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_setsnapshotdata, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, columnMap)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_haschanged, 0, 0, 0)
	ZEND_ARG_INFO(0, fieldName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_usedynamicupdate, 0, 0, 1)
	ZEND_ARG_INFO(0, dynamicUpdate)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___call, 0, 0, 1)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___callstatic, 0, 0, 1)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___set, 0, 0, 2)
	ZEND_ARG_INFO(0, property)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___get, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model___isset, 0, 0, 1)
	ZEND_ARG_INFO(0, property)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_unserialize, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_setup, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_toarray, 0, 0, 0)
	ZEND_ARG_INFO(0, columns)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model, __construct, arginfo_phalcon_mvc_model___construct, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setEventsManager, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, getEventsManager, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, getModelsMetaData, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getModelsManager, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setTransaction, arginfo_phalcon_mvc_modelinterface_settransaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setSource, arginfo_phalcon_mvc_model_setsource, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, getSource, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setSchema, arginfo_phalcon_mvc_model_setschema, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, getSchema, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setConnectionService, arginfo_phalcon_mvc_modelinterface_setconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setReadConnectionService, arginfo_phalcon_mvc_modelinterface_setreadconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setWriteConnectionService, arginfo_phalcon_mvc_modelinterface_setwriteconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getReadConnectionService, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getWriteConnectionService, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setDirtyState, arginfo_phalcon_mvc_model_setdirtystate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getDirtyState, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getReadConnection, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getWriteConnection, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, assign, arginfo_phalcon_mvc_modelinterface_assign, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, cloneResultMap, arginfo_phalcon_mvc_modelinterface_cloneresultmap, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, cloneResultMapHydrate, arginfo_phalcon_mvc_modelinterface_cloneresultmaphydrate, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, cloneResult, arginfo_phalcon_mvc_modelinterface_cloneresult, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, find, arginfo_phalcon_mvc_modelinterface_find, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, findFirst, arginfo_phalcon_mvc_modelinterface_findfirst, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, query, arginfo_phalcon_mvc_modelinterface_query, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, _exists, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _groupResult, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, count, arginfo_phalcon_mvc_modelinterface_count, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, sum, arginfo_phalcon_mvc_modelinterface_sum, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, maximum, arginfo_phalcon_mvc_modelinterface_maximum, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, minimum, arginfo_phalcon_mvc_modelinterface_minimum, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, average, arginfo_phalcon_mvc_modelinterface_average, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, fireEvent, arginfo_phalcon_mvc_modelinterface_fireevent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, fireEventCancel, arginfo_phalcon_mvc_modelinterface_fireeventcancel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, _cancelOperation, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, appendMessage, arginfo_phalcon_mvc_modelinterface_appendmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, validate, arginfo_phalcon_mvc_model_validate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, validationHasFailed, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getMessages, arginfo_phalcon_mvc_modelinterface_getmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, _checkForeignKeysRestrict, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _checkForeignKeysReverseRestrict, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _checkForeignKeysReverseCascade, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _preSave, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _postSave, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _doLowInsert, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _doLowUpdate, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _preSaveRelatedRecords, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, _postSaveRelatedRecords, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, save, arginfo_phalcon_mvc_modelinterface_save, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, create, arginfo_phalcon_mvc_modelinterface_create, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, update, arginfo_phalcon_mvc_modelinterface_update, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, delete, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getOperationMade, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, refresh, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, skipOperation, arginfo_phalcon_mvc_model_skipoperation, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, readAttribute, arginfo_phalcon_mvc_modelinterface_readattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, writeAttribute, arginfo_phalcon_mvc_modelinterface_writeattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, skipAttributes, arginfo_phalcon_mvc_model_skipattributes, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, skipAttributesOnCreate, arginfo_phalcon_mvc_model_skipattributesoncreate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, skipAttributesOnUpdate, arginfo_phalcon_mvc_model_skipattributesonupdate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, hasOne, arginfo_phalcon_mvc_model_hasone, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, belongsTo, arginfo_phalcon_mvc_model_belongsto, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, hasMany, arginfo_phalcon_mvc_model_hasmany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, hasManyToMany, arginfo_phalcon_mvc_model_hasmanytomany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, addBehavior, arginfo_phalcon_mvc_model_addbehavior, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, keepSnapshots, arginfo_phalcon_mvc_model_keepsnapshots, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, setSnapshotData, arginfo_phalcon_mvc_model_setsnapshotdata, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, hasSnapshotData, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getSnapshotData, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, hasChanged, arginfo_phalcon_mvc_model_haschanged, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, getChangedFields, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, useDynamicUpdate, arginfo_phalcon_mvc_model_usedynamicupdate, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, getRelated, arginfo_phalcon_mvc_modelinterface_getrelated, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, _getRelatedRecords, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model, __call, arginfo_phalcon_mvc_model___call, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, __callStatic, arginfo_phalcon_mvc_model___callstatic, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, __set, arginfo_phalcon_mvc_model___set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, __get, arginfo_phalcon_mvc_model___get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, __isset, arginfo_phalcon_mvc_model___isset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, serialize, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, unserialize, arginfo_phalcon_mvc_model_unserialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, dump, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, toArray, arginfo_phalcon_mvc_model_toarray, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model, setup, arginfo_phalcon_mvc_model_setup, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model, reset, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Model, mvc_model, phalcon_mvc_model_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_modelsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_modelsMetaData"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_ce, SL("_operationMade"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_ce, SL("_dirtyState"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_transaction"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_uniqueKey"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_uniqueParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_uniqueTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_skipped"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_related"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_ce, SL("_snapshot"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_NONE"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_CREATE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_UPDATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("OP_DELETE"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("DIRTY_STATE_PERSISTENT"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("DIRTY_STATE_TRANSIENT"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_ce, SL("DIRTY_STATE_DETACHED"), 2 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_ce TSRMLS_CC, 4, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_resultinterface_ce, phalcon_di_injectionawareinterface_ce, zend_ce_serializable);

	return SUCCESS;
}

static int phalcon_mvc_model_get_messages_from_model(zval *this_ptr, zval *model, zval *target TSRMLS_DC)
{
	zval *messages = NULL, **message;
	HashPosition hp;

	if (
		   phalcon_call_method(&messages, model, "getmessages", 0, NULL TSRMLS_CC) == FAILURE
		|| Z_TYPE_P(messages) != IS_ARRAY
	) {
		if (messages) {
			zval_ptr_dtor(&messages);
		}

		return FAILURE;
	}

	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(messages), &hp);
		zend_hash_get_current_data_ex(Z_ARRVAL_P(messages), (void**)&message, &hp) == SUCCESS;
		zend_hash_move_forward_ex(Z_ARRVAL_P(messages), &hp)
	) {
		if (Z_TYPE_PP(message) == IS_OBJECT) {
			zval *params[] = { target };
			if (FAILURE == phalcon_call_method(NULL, *message, "setmodel", 1, params TSRMLS_CC)) {
				break;
			}
		}

		{
			zval *params[] = { *message };
			if (FAILURE == phalcon_call_method(NULL, this_ptr, "appendmessage", 1, params TSRMLS_CC)) {
				break;
			}
		}
	}

	zval_ptr_dtor(&messages);
	return likely(!EG(exception)) ? SUCCESS : FAILURE;
}

static PHP_METHOD(Phalcon_Mvc_Model, __construct){

	zval *dependency_injector = NULL, *models_manager = NULL;
	zval *service_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &dependency_injector, &models_manager);
	
	if (!dependency_injector) {
		PHALCON_INIT_VAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	if (!models_manager) {
		PHALCON_INIT_VAR(models_manager);
	} else {
		PHALCON_SEPARATE_PARAM(models_manager);
	}
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
	}
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	
	if (Z_TYPE_P(models_manager) != IS_OBJECT) {
	
		PHALCON_INIT_VAR(service_name);
		ZVAL_STRING(service_name, "modelsManager", 1);
	
		PHALCON_CALL_METHOD(&models_manager, dependency_injector, "getshared", service_name);
		if (Z_TYPE_P(models_manager) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The injected service 'modelsManager' is not valid");
			return;
		}

		PHALCON_VERIFY_INTERFACE(models_manager, phalcon_mvc_model_managerinterface_ce);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_modelsManager"), models_manager, 3699347875UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(NULL, models_manager, "initialize", this_ptr);
	
	if (phalcon_method_quick_exists_ex(this_ptr, SS("onconstruct"), 564344039UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "onconstruct");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model, setEventsManager){

	zval *events_manager, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &events_manager);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setcustomeventsmanager", this_ptr, events_manager);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, getEventsManager){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getcustomeventsmanager", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, getModelsMetaData){

	zval *meta_data = NULL, *dependency_injector, *service;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_modelsMetaData"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(meta_data) != IS_OBJECT) {
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
			return;
		}
	
		PHALCON_INIT_VAR(service);
		ZVAL_STRING(service, "modelsMetadata", 1);
	
		PHALCON_CALL_METHOD(&meta_data, dependency_injector, "getshared", service);
		if (Z_TYPE_P(meta_data) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The injected service 'modelsMetadata' is not valid");
			return;
		}
	
		PHALCON_VERIFY_INTERFACE(meta_data, phalcon_mvc_model_metadatainterface_ce);

		phalcon_update_property_this_quick(this_ptr, SL("_modelsMetaData"), meta_data, 3906670569UL TSRMLS_CC);
	}
	
	RETURN_CTOR(meta_data);
}

static PHP_METHOD(Phalcon_Mvc_Model, getModelsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_modelsManager", 3699347875UL);
}

static PHP_METHOD(Phalcon_Mvc_Model, setTransaction){

	zval *transaction;

	phalcon_fetch_params(0, 1, 0, &transaction);
	
	if (Z_TYPE_P(transaction) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_transaction"), transaction, 1141465066UL TSRMLS_CC);
		RETURN_THISW();
	}
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Transaction should be an object");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model, setSource){

	zval *source, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &source);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setmodelsource", this_ptr, source);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, getSource){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getmodelsource", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, setSchema){

	zval *schema, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &schema);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setmodelschema", this_ptr, schema);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, getSchema){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getmodelschema", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, setConnectionService){

	zval *connection_service, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &connection_service);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setconnectionservice", this_ptr, connection_service);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, setReadConnectionService){

	zval *connection_service, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &connection_service);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setreadconnectionservice", this_ptr, connection_service);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, setWriteConnectionService){

	zval *connection_service, *models_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &connection_service);
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, models_manager, "setwriteconnectionservice", this_ptr, connection_service);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, getReadConnectionService){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getreadconnectionservice", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, getWriteConnectionService){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getwriteconnectionservice", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, setDirtyState){

	zval *dirty_state;

	phalcon_fetch_params(0, 1, 0, &dirty_state);
	
	phalcon_update_property_this_quick(this_ptr, SL("_dirtyState"), dirty_state, 1560981745UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model, getDirtyState){


	RETURN_MEMBER_QUICK(this_ptr, "_dirtyState", 1560981745UL);
}

static PHP_METHOD(Phalcon_Mvc_Model, getReadConnection){

	zval *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getreadconnection", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, getWriteConnection){

	zval *transaction, *models_manager;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(transaction);
	phalcon_read_property_this(&transaction, this_ptr, SL("_transaction"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(transaction) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(transaction, "getconnection");
		RETURN_MM();
	}
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(models_manager, "getwriteconnection", this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, assign){

	zval *data, *column_map = NULL, *value = NULL, *key = NULL, *attribute = NULL;
	zval *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &data, &column_map);
	
	if (!column_map) {
		column_map = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data to dump in the object must be an Array");
		return;
	}
	
	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
	
			if (phalcon_array_isset(column_map, key)) {
				PHALCON_OBS_NVAR(attribute);
				phalcon_array_fetch(&attribute, column_map, key, PH_NOISY);
				phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
			} else {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column \"", key, "\" doesn't make part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, cloneResultMap){

	zval *base, *data, *column_map, *dirty_state = NULL, *keep_snapshots = NULL;
	zval *object, *value = NULL, *key = NULL, *attribute = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 2, &base, &data, &column_map, &dirty_state, &keep_snapshots);
	
	if (!dirty_state) {
		dirty_state = PHALCON_GLOBAL(z_zero);
	}
	
	if (!keep_snapshots) {
		keep_snapshots = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data to dump in the object must be an Array");
		return;
	}
	
	PHALCON_INIT_VAR(object);
	if (phalcon_clone(object, base TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(NULL, object, "setdirtystate", dirty_state);
	
	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (Z_TYPE_P(key) == IS_STRING) {
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
	
				if (phalcon_array_isset(column_map, key)) {
					PHALCON_OBS_NVAR(attribute);
					phalcon_array_fetch(&attribute, column_map, key, PH_NOISY);
					phalcon_update_property_zval_zval(object, attribute, value TSRMLS_CC);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column \"", key, "\" doesn't make part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				phalcon_update_property_zval_zval(object, key, value TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (zend_is_true(keep_snapshots)) {
		PHALCON_CALL_METHOD(NULL, object, "setsnapshotdata", data, column_map);
	}
	
	if (phalcon_method_quick_exists_ex(object, SS("afterfetch"), 1256108385UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, object, "afterfetch");
	}
	
	RETURN_CTOR(object);
}

static PHP_METHOD(Phalcon_Mvc_Model, cloneResultMapHydrate){

	zval *data, *column_map, *hydration_mode, *hydrate = NULL;
	zval *value = NULL, *key = NULL, *exception_message = NULL, *attribute = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &data, &column_map, &hydration_mode);
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data to hidrate must be an Array");
		return;
	}
	
	if (Z_TYPE_P(column_map) != IS_ARRAY) { 
		if (PHALCON_IS_LONG(hydration_mode, 1)) {
			RETURN_CTOR(data);
		}
	}
	
	if (PHALCON_IS_LONG(hydration_mode, 1)) {
		PHALCON_INIT_VAR(hydrate);
		array_init(hydrate);
	} else {
		PHALCON_INIT_NVAR(hydrate);
		object_init(hydrate);
	}
	
	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (Z_TYPE_P(key) == IS_STRING) {
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
	
				if (!phalcon_array_isset(column_map, key)) {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column \"", key, "\" doesn't make part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
	
				PHALCON_OBS_NVAR(attribute);
				phalcon_array_fetch(&attribute, column_map, key, PH_NOISY);
				if (PHALCON_IS_LONG(hydration_mode, 1)) {
					phalcon_array_update_zval(&hydrate, attribute, value, PH_COPY | PH_SEPARATE);
				} else {
					phalcon_update_property_zval_zval(hydrate, attribute, value TSRMLS_CC);
				}
			} else {
				if (PHALCON_IS_LONG(hydration_mode, 1)) {
					phalcon_array_update_zval(&hydrate, key, value, PH_COPY | PH_SEPARATE);
				} else {
					phalcon_update_property_zval_zval(hydrate, key, value TSRMLS_CC);
				}
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(hydrate);
}

static PHP_METHOD(Phalcon_Mvc_Model, cloneResult){

	zval *base, *data, *dirty_state = NULL, *object, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &base, &data, &dirty_state);
	
	if (!dirty_state) {
		dirty_state = PHALCON_GLOBAL(z_zero);
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data to dump in the object must be an Array");
		return;
	}
	
	PHALCON_INIT_VAR(object);
	if (phalcon_clone(object, base TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(NULL, object, "setdirtystate", dirty_state);
	
	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(key, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		if (Z_TYPE_P(key) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid key in array data provided to dumpResult()");
			return;
		}
		phalcon_update_property_zval_zval(object, key, value TSRMLS_CC);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (phalcon_method_quick_exists_ex(object, SS("afterfetch"), 1256108385UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, object, "afterfetch");
	}
	
	RETURN_CTOR(object);
}

static PHP_METHOD(Phalcon_Mvc_Model, find){

	zval *parameters = NULL, *model_name, *params = NULL, *builder;
	zval *query = NULL, *bind_params = NULL, *bind_types = NULL, *cache;
	zval *resultset = NULL, *hydration;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_called_class(model_name  TSRMLS_CC);
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
	
		PHALCON_INIT_VAR(params);
		array_init(params);
		if (Z_TYPE_P(parameters) != IS_NULL) {
			phalcon_array_append(&params, parameters, PH_SEPARATE);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(builder);
	object_init_ex(builder, phalcon_mvc_model_query_builder_ce);
	PHALCON_CALL_METHOD(NULL, builder, "__construct", params);
	
	PHALCON_CALL_METHOD(NULL, builder, "from", model_name);
	PHALCON_CALL_METHOD(&query, builder, "getquery");
	
	PHALCON_INIT_VAR(bind_params);
	
	PHALCON_INIT_VAR(bind_types);
	
	if (phalcon_array_isset_quick_string(params, SS("bind"), 254268962UL)) {
	
		PHALCON_OBS_NVAR(bind_params);
		phalcon_array_fetch_quick_string(&bind_params, params, SS("bind"), 254268962UL, PH_NOISY);
		if (phalcon_array_isset_quick_string(params, SS("bindTypes"), 3951758359UL)) {
			PHALCON_OBS_NVAR(bind_types);
			phalcon_array_fetch_quick_string(&bind_types, params, SS("bindTypes"), 3951758359UL, PH_NOISY);
		}
	}
	
	if (phalcon_array_isset_quick_string(params, SS("cache"), 4125168857UL)) {
		PHALCON_OBS_VAR(cache);
		phalcon_array_fetch_quick_string(&cache, params, SS("cache"), 4125168857UL, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, query, "cache", cache);
	}
	
	PHALCON_CALL_METHOD(&resultset, query, "execute", bind_params, bind_types);
	
	if (Z_TYPE_P(resultset) == IS_OBJECT) {
		if (phalcon_array_isset_quick_string(params, SS("hydration"), 1688432023UL)) {
			PHALCON_OBS_VAR(hydration);
			phalcon_array_fetch_quick_string(&hydration, params, SS("hydration"), 1688432023UL, PH_NOISY);
			PHALCON_CALL_METHOD(NULL, resultset, "sethydratemode", hydration);
		}
	}
	
	RETURN_CTOR(resultset);
}

static PHP_METHOD(Phalcon_Mvc_Model, findFirst){

	zval *parameters = NULL, *model_name, *params = NULL, *builder;
	zval *query = NULL, *bind_params = NULL, *bind_types = NULL, *cache;
	zval *unique, *index, tmp = zval_used_for_init;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_called_class(model_name  TSRMLS_CC);
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
	
		PHALCON_INIT_VAR(params);
		array_init(params);
		if (Z_TYPE_P(parameters) != IS_NULL) {
			phalcon_array_append(&params, parameters, 0);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	PHALCON_INIT_VAR(builder);
	object_init_ex(builder, phalcon_mvc_model_query_builder_ce);
	PHALCON_CALL_METHOD(NULL, builder, "__construct", params);
	
	PHALCON_CALL_METHOD(NULL, builder, "from", model_name);
	
	PHALCON_OBS_VAR(bind_params);
	PHALCON_OBS_VAR(bind_types);
	if (phalcon_array_isset_string_fetch(&bind_params, params, SS("bind"))) {
		Z_ADDREF_P(bind_params);
		SEPARATE_ZVAL(&bind_params);
		if (Z_TYPE_P(bind_params) != IS_ARRAY) {
			zval_dtor(bind_params);
			array_init_size(bind_params, 1);
		}

		if (phalcon_array_isset_string_fetch(&bind_types, params, SS("bindTypes"))) {
			Z_ADDREF_P(bind_types);
			SEPARATE_ZVAL(&bind_types);
			if (Z_TYPE_P(bind_types) != IS_ARRAY) {
				zval_dtor(bind_types);
				array_init_size(bind_types, 1);
			}
		}
		else {
			MAKE_STD_ZVAL(bind_types);
			array_init_size(bind_types, 1);
		}
	}
	else {
		MAKE_STD_ZVAL(bind_params);
		MAKE_STD_ZVAL(bind_types);
		array_init_size(bind_params, 1);
		array_init_size(bind_types, 1);
	}

	ZVAL_LONG(&tmp, zend_hash_num_elements(Z_ARRVAL_P(bind_params)) + 1);
	PHALCON_INIT_VAR(index);
	/*PHALCON_CONCAT_SV(index, "?", &tmp);*/
	ZVAL_LONG(index, 1);
    

	PHALCON_CALL_METHOD(NULL, builder, "limit", index);
	PHALCON_CALL_METHOD(&query, builder, "getquery");

	/*add_index_long(bind_params, Z_LVAL(tmp), 1);*/
	/*add_index_long(bind_types, Z_LVAL(tmp), 1 [> BIND_PARAM_INT <]);*/

	if (phalcon_array_isset_string_fetch(&cache, params, SS("cache"))) {
		PHALCON_CALL_METHOD(NULL, query, "cache", cache);
	}
	
	unique = PHALCON_GLOBAL(z_true);
	
	PHALCON_CALL_METHOD(NULL, query, "setuniquerow", unique);
	
	PHALCON_RETURN_CALL_METHOD(query, "execute", bind_params, bind_types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, query){

	zval *dependency_injector = NULL, *model_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &dependency_injector);
	
	if (!dependency_injector) {
		PHALCON_INIT_VAR(dependency_injector);
	} else {
		PHALCON_SEPARATE_PARAM(dependency_injector);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_called_class(model_name TSRMLS_CC);
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
	}
	
	object_init_ex(return_value, phalcon_mvc_model_criteria_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "setdi", dependency_injector);
	PHALCON_CALL_METHOD(NULL, return_value, "setmodelname", model_name);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, _exists){

	zval *meta_data, *connection, *table = NULL, *unique_params = NULL;
	zval *unique_types = NULL, *unique_key = NULL, *primary_keys = NULL;
	zval *bind_data_types = NULL, *number_primary, *column_map = NULL;
	zval *null_value, *number_empty, *where_pk, *field = NULL;
	zval *attribute_field = NULL, *exception_message = NULL;
	zval *value = NULL, *escaped_field = NULL, *pk_condition = NULL, *type = NULL;
	zval *join_where, *dirty_state, *schema = NULL, *source = NULL;
	zval *escaped_table = NULL, *null_mode, *select, *num = NULL;
	zval *row_count, *v;
	int seen_rawvalues = 0;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &meta_data, &connection, &table);
	
	if (!table) {
		PHALCON_INIT_VAR(table);
	} else {
		PHALCON_SEPARATE_PARAM(table);
	}
	
	PHALCON_INIT_VAR(unique_params);
	
	PHALCON_INIT_VAR(unique_types);
	
	PHALCON_OBS_VAR(unique_key);
	phalcon_read_property_this(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(unique_key) == IS_NULL) {
		PHALCON_CALL_METHOD(&primary_keys, meta_data, "getprimarykeyattributes", this_ptr);
		PHALCON_CALL_METHOD(&bind_data_types, meta_data, "getbindtypes", this_ptr);
	
		PHALCON_INIT_VAR(number_primary);
		phalcon_fast_count(number_primary, primary_keys TSRMLS_CC);
		if (!zend_is_true(number_primary)) {
			RETURN_MM_FALSE;
		}
	
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		PHALCON_INIT_VAR(null_value);
	
		PHALCON_INIT_VAR(number_empty);
		ZVAL_LONG(number_empty, 0);
	
		PHALCON_INIT_VAR(where_pk);
		array_init(where_pk);
	
		array_init(unique_params);
	
		array_init(unique_types);
	
		phalcon_is_iterable(primary_keys, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(field);
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, field)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, field);
			}
	
			if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
	
				PHALCON_OBS_NVAR(value);
				phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
	
				if (PHALCON_IS_EMPTY(value)) {
					phalcon_increment(number_empty);
				}
	
				v = value;
			} else {
				v = null_value;
				phalcon_increment(number_empty);
			}
	
			PHALCON_CALL_METHOD(&escaped_field, connection, "escapeidentifier", field);
	
			PHALCON_INIT_NVAR(pk_condition);

			if (Z_TYPE_P(v) == IS_OBJECT && instanceof_function(Z_OBJCE_P(v), phalcon_db_rawvalue_ce TSRMLS_CC)) {
				PHALCON_CONCAT_VSV(pk_condition, escaped_field, " = ", v);
				seen_rawvalues = 1;
			}
			else {
				PHALCON_CONCAT_VS(pk_condition, escaped_field, " = ?");
				phalcon_array_append(&unique_params, v, 0);
				v = NULL;
			}

			if (!phalcon_array_isset(bind_data_types, field)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't a part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			if (v) {
				PHALCON_OBS_NVAR(type);
				phalcon_array_fetch(&type, bind_data_types, field, PH_NOISY);
				phalcon_array_append(&unique_types, type, PH_SEPARATE);
			}

			phalcon_array_append(&where_pk, pk_condition, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (PHALCON_IS_EQUAL(number_primary, number_empty)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_INIT_VAR(join_where);
		phalcon_fast_join_str(join_where, SL(" AND "), where_pk TSRMLS_CC);
	
		phalcon_update_property_this_quick(this_ptr, SL("_uniqueKey"), join_where, 1221404964UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_uniqueParams"), unique_params, 1065564063UL TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_uniqueTypes"), unique_types, 3340838640UL TSRMLS_CC);
		PHALCON_CPY_WRT(unique_key, join_where);
	}
	
	PHALCON_OBS_VAR(dirty_state);
	phalcon_read_property_this(&dirty_state, this_ptr, SL("_dirtyState"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(dirty_state)) {
		RETURN_MM_TRUE;
	}
	
	if (Z_TYPE_P(unique_key) == IS_NULL) {
		PHALCON_OBS_NVAR(unique_key);
		phalcon_read_property_this(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY TSRMLS_CC);
	}
	
	if (Z_TYPE_P(unique_params) == IS_NULL) {
		PHALCON_OBS_NVAR(unique_params);
		phalcon_read_property_this(&unique_params, this_ptr, SL("_uniqueParams"), PH_NOISY TSRMLS_CC);
	}
	
	if (Z_TYPE_P(unique_types) == IS_NULL) {
		PHALCON_OBS_NVAR(unique_types);
		phalcon_read_property_this(&unique_types, this_ptr, SL("_uniqueTypes"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_CALL_METHOD(&schema, this_ptr, "getschema");
	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (zend_is_true(schema)) {
		PHALCON_INIT_NVAR(table);
		array_init_size(table, 2);
		phalcon_array_append(&table, schema, PH_SEPARATE);
		phalcon_array_append(&table, source, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_CALL_METHOD(&escaped_table, connection, "escapeidentifier", table);
	
	PHALCON_INIT_VAR(null_mode);
	
	PHALCON_INIT_VAR(select);
	PHALCON_CONCAT_SVSV(select, "SELECT COUNT(*) \"rowcount\" FROM ", escaped_table, " WHERE ", unique_key);
	
	PHALCON_CALL_METHOD(&num, connection, "fetchone", select, null_mode, unique_params, unique_types);
	
	if (seen_rawvalues) {
		phalcon_update_property_this(this_ptr, SL("_uniqueKey"), PHALCON_GLOBAL(z_null) TSRMLS_CC);
	}

	PHALCON_OBS_VAR(row_count);
	phalcon_array_fetch_quick_string(&row_count, num, SS("rowcount"), 4184721862UL, PH_NOISY);
	if (zend_is_true(row_count)) {
		phalcon_update_property_long(this_ptr, SL("_dirtyState"), 0 TSRMLS_CC);
		RETURN_MM_TRUE;
	} else {
		phalcon_update_property_long(this_ptr, SL("_dirtyState"), 1 TSRMLS_CC);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _groupResult){

	zval *function, *alias, *parameters, *params = NULL, *group_column = NULL;
	zval *distinct_column, *columns = NULL, *group_columns;
	zval *model_name, *builder, *query = NULL, *bind_params = NULL;
	zval *bind_types = NULL, *resultset = NULL, *cache, *number_rows;
	zval *first_row = NULL, *value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &function, &alias, &parameters);
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) {
		PHALCON_INIT_VAR(params);
		if (Z_TYPE_P(parameters) != IS_NULL) {
			array_init_size(params, 1);
			phalcon_array_append(&params, parameters, 0);
		} else {
			array_init(params);
		}
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	if (phalcon_array_isset_quick_string(params, SS("column"), 3545634419UL)) {
		PHALCON_OBS_VAR(group_column);
		phalcon_array_fetch_quick_string(&group_column, params, SS("column"), 3545634419UL, PH_NOISY);
	} else {
		PHALCON_INIT_NVAR(group_column);
		ZVAL_STRING(group_column, "*", 1);
	}
	
	if (phalcon_array_isset_quick_string(params, SS("distinct"), 73581991UL)) {
		PHALCON_OBS_VAR(distinct_column);
		phalcon_array_fetch_quick_string(&distinct_column, params, SS("distinct"), 73581991UL, PH_NOISY);
	
		PHALCON_INIT_VAR(columns);
		PHALCON_CONCAT_VSVSV(columns, function, "(DISTINCT ", distinct_column, ") AS ", alias);
	} else {
		if (phalcon_array_isset_quick_string(params, SS("group"), 7349554UL)) {
			PHALCON_OBS_VAR(group_columns);
			phalcon_array_fetch_quick_string(&group_columns, params, SS("group"), 7349554UL, PH_NOISY);
	
			PHALCON_INIT_NVAR(columns);
			PHALCON_CONCAT_VSVSVSV(columns, group_columns, ", ", function, "(", group_column, ") AS ", alias);
		} else {
			PHALCON_INIT_NVAR(columns);
			PHALCON_CONCAT_VSVSV(columns, function, "(", group_column, ") AS ", alias);
		}
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_called_class(model_name  TSRMLS_CC);
	
	PHALCON_INIT_VAR(builder);
	object_init_ex(builder, phalcon_mvc_model_query_builder_ce);
	PHALCON_CALL_METHOD(NULL, builder, "__construct", params);
	
	PHALCON_CALL_METHOD(NULL, builder, "columns", columns);
	PHALCON_CALL_METHOD(NULL, builder, "from", model_name);
	PHALCON_CALL_METHOD(&query, builder, "getquery");
	
	PHALCON_INIT_VAR(bind_params);
	
	PHALCON_INIT_VAR(bind_types);
	if (phalcon_array_isset_quick_string(params, SS("bind"), 254268962UL)) {
	
		PHALCON_OBS_NVAR(bind_params);
		phalcon_array_fetch_quick_string(&bind_params, params, SS("bind"), 254268962UL, PH_NOISY);
		if (phalcon_array_isset_quick_string(params, SS("bindTypes"), 3951758359UL)) {
			PHALCON_OBS_NVAR(bind_types);
			phalcon_array_fetch_quick_string(&bind_types, params, SS("bindTypes"), 3951758359UL, PH_NOISY);
		}
	}
	
	if (phalcon_array_isset_quick_string(params, SS("cache"), 4125168857UL)) {
		PHALCON_OBS_VAR(cache);
		phalcon_array_fetch_quick_string(&cache, params, SS("cache"), 4125168857UL, PH_NOISY);
		PHALCON_CALL_METHOD(NULL, query, "cache", cache);
	}
	
	PHALCON_CALL_METHOD(&resultset, query, "execute", bind_params, bind_types);
	
	if (phalcon_array_isset_quick_string(params, SS("group"), 7349554UL)) {
		RETURN_CTOR(resultset);
	}
	
	PHALCON_INIT_VAR(number_rows);
	phalcon_fast_count(number_rows, resultset TSRMLS_CC);
	PHALCON_CALL_METHOD(&first_row, resultset, "getfirst");
	
	PHALCON_OBS_VAR(value);
	phalcon_read_property_zval(&value, first_row, alias, PH_NOISY TSRMLS_CC);
	
	RETURN_CTOR(value);
}

static PHP_METHOD(Phalcon_Mvc_Model, count){

	zval *parameters = NULL, *function, *alias;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "COUNT", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "rowcount", 1);
	PHALCON_RETURN_CALL_SELF("_groupresult", function, alias, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, sum){

	zval *parameters = NULL, *function, *alias;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "SUM", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "sumatory", 1);
	PHALCON_RETURN_CALL_SELF("_groupresult", function, alias, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, maximum){

	zval *parameters = NULL, *function, *alias;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "MAX", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "maximum", 1);
	PHALCON_RETURN_CALL_SELF("_groupresult", function, alias, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, minimum){

	zval *parameters = NULL, *function, *alias;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "MIN", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "minimum", 1);
	PHALCON_RETURN_CALL_SELF("_groupresult", function, alias, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, average){

	zval *parameters = NULL, *function, *alias;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(function);
	ZVAL_STRING(function, "AVG", 1);
	
	PHALCON_INIT_VAR(alias);
	ZVAL_STRING(alias, "average", 1);
	PHALCON_RETURN_CALL_SELF("_groupresult", function, alias, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, fireEvent){

	zval **event_name, *models_manager;
	zval *lower;
	char *tmp;

	phalcon_fetch_params_ex(1, 0, &event_name);
	PHALCON_ENSURE_IS_STRING(event_name);

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(lower);
	tmp = zend_str_tolower_dup(Z_STRVAL_PP(event_name), Z_STRLEN_PP(event_name));
	ZVAL_STRINGL(lower, tmp, Z_STRLEN_PP(event_name), 0);

	if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(lower), Z_STRLEN_P(lower)+1  TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, this_ptr, Z_STRVAL_P(lower));
	}
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_RETURN_CALL_METHOD(models_manager, "notifyevent", *event_name, this_ptr);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, fireEventCancel){

	zval **event_name, *status = NULL, *models_manager;
	zval *lower;
	char *tmp;

	phalcon_fetch_params_ex(1, 0, &event_name);
	PHALCON_ENSURE_IS_STRING(event_name);

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(lower);
	tmp = zend_str_tolower_dup(Z_STRVAL_PP(event_name), Z_STRLEN_PP(event_name));
	ZVAL_STRINGL(lower, tmp, Z_STRLEN_PP(event_name), 0);

	if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(lower), Z_STRLEN_P(lower)+1  TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&status, this_ptr, Z_STRVAL_P(lower));
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&status, models_manager, "notifyevent", *event_name, this_ptr);
	if (PHALCON_IS_FALSE(status)) {
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _cancelOperation){

	zval *operation_made, *event_name = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(operation_made);
	phalcon_read_property_this(&operation_made, this_ptr, SL("_operationMade"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_LONG(operation_made, 3)) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "notDeleted", 1);
	} else {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "notSaved", 1);
	}
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, appendMessage){

	zval *message, *type, *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	if (Z_TYPE_P(message) != IS_OBJECT) {
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, zend_zval_type_name(message), 1);
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Invalid message format '", type, "'");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	phalcon_update_property_array_append(this_ptr, SL("_errorMessages"), message TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, validate){

	zval *validator, *status = NULL, *messages = NULL, *errors, *new_errors;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &validator);
	
	PHALCON_VERIFY_INTERFACE_EX(validator, phalcon_mvc_model_validatorinterface_ce, phalcon_mvc_model_exception_ce, 1);
	
	PHALCON_CALL_METHOD(&status, validator, "validate", this_ptr);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_CALL_METHOD(&messages, validator, "getmessages");

		if (Z_TYPE_P(messages) == IS_ARRAY) {
			PHALCON_INIT_VAR(new_errors);
			errors = phalcon_fetch_nproperty_this(this_ptr, SL("_errorMessages"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(errors) == IS_ARRAY) {
				phalcon_fast_array_merge(new_errors, &errors, &messages TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), new_errors, 1019066246UL TSRMLS_CC);
			} else {
				phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), messages, 1019066246UL TSRMLS_CC);
			}
		}
		else {
			int dup;
#if PHP_VERSION_ID >= 50400
			const
#endif
			char *name = "";
			zend_uint name_len = 0;

			dup = zend_get_object_classname(validator, &name, &name_len TSRMLS_CC);
			zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, "Validator '%s' returned false but did not call appendMessage()", name);
			if (!dup) {
				efree((char*)name);
			}
		}
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model, validationHasFailed){

	zval *error_messages;

	error_messages = phalcon_fetch_nproperty_this(this_ptr, SL("_errorMessages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(error_messages) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(error_messages))) {
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, getMessages){

	zval *filter = NULL, *messages;

	phalcon_fetch_params(0, 0, 1, &filter);
	if (!filter || Z_TYPE_P(filter) != IS_STRING) {
		RETURN_MEMBER_QUICK(this_ptr, "_errorMessages", 1019066246UL);
	}

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(messages);
	phalcon_read_property_this(&messages, this_ptr, SL("_errorMessages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_ARRAY) {
		HashPosition pos;
		zval **value, *field = NULL;

		array_init(return_value);

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(messages), &pos);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(messages), (void**)&value, &pos) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(messages), &pos)
		) {
			PHALCON_CALL_METHOD(&field, *value, "getfield");

			if (PHALCON_IS_EQUAL(filter, field)) {
				phalcon_array_append(&return_value, *value, PH_COPY);
			}
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysRestrict){

	zval *manager, *belongs_to = NULL, *error = NULL, *relation = NULL, *foreign_key = NULL;
	zval *action = NULL, *relation_class = NULL, *referenced_model = NULL;
	zval *conditions = NULL, *bind_params = NULL, *fields = NULL, *referenced_fields = NULL;
	zval *field = NULL, *position = NULL, *value = NULL, *referenced_field = NULL;
	zval *condition = NULL, *extra_conditions = NULL, *join_conditions = NULL;
	zval *parameters = NULL, *rowcount = NULL, *user_message = NULL, *joined_fields = NULL;
	zval *type = NULL, *message = NULL, *event_name;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&belongs_to, manager, "getbelongsto", this_ptr);
	if (phalcon_fast_count_ev(belongs_to TSRMLS_CC)) {
	
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
	
		phalcon_is_iterable(belongs_to, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(relation);
	
			PHALCON_CALL_METHOD(&foreign_key, relation, "getforeignkey");
			if (PHALCON_IS_NOT_FALSE(foreign_key)) {
	
				PHALCON_INIT_NVAR(action);
				ZVAL_LONG(action, 1);
	
				if (Z_TYPE_P(foreign_key) == IS_ARRAY) { 
					if (phalcon_array_isset_quick_string(foreign_key, SS("action"), 502132067UL)) {
						PHALCON_OBS_NVAR(action);
						phalcon_array_fetch_quick_string(&action, foreign_key, SS("action"), 502132067UL, PH_NOISY);
					}
				}
	
				if (PHALCON_IS_LONG(action, 1)) {
					PHALCON_CALL_METHOD(&relation_class, relation, "getreferencedmodel");
	
					PHALCON_CALL_METHOD(&referenced_model, manager, "load", relation_class);
	
					PHALCON_INIT_NVAR(conditions);
					array_init(conditions);
	
					PHALCON_INIT_NVAR(bind_params);
					array_init(bind_params);
	
					PHALCON_CALL_METHOD(&fields, relation, "getfields");
					PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
					if (Z_TYPE_P(fields) == IS_ARRAY) { 
	
						phalcon_is_iterable(fields, &ah1, &hp1, 0, 0);
	
						while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
							PHALCON_GET_HKEY(position, ah1, hp1);
							PHALCON_GET_HVALUE(field);
	
							if (phalcon_isset_property_zval(this_ptr, field TSRMLS_CC)) {
								PHALCON_OBS_NVAR(value);
								phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY TSRMLS_CC);
							} else {
								PHALCON_INIT_NVAR(value);
							}
	
							PHALCON_OBS_NVAR(referenced_field);
							phalcon_array_fetch(&referenced_field, referenced_fields, position, PH_NOISY);
	
							PHALCON_INIT_NVAR(condition);
							PHALCON_CONCAT_SVSV(condition, "[", referenced_field, "] = ?", position);
							phalcon_array_append(&conditions, condition, PH_SEPARATE);
							phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
							zend_hash_move_forward_ex(ah1, &hp1);
						}
	
					} else {
						if (phalcon_isset_property_zval(this_ptr, fields TSRMLS_CC)) {
							PHALCON_OBS_NVAR(value);
							phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY TSRMLS_CC);
						} else {
							PHALCON_INIT_NVAR(value);
						}
	
						PHALCON_INIT_NVAR(condition);
						PHALCON_CONCAT_SVS(condition, "[", referenced_fields, "] = ?0");
						phalcon_array_append(&conditions, condition, PH_SEPARATE);
						phalcon_array_append(&bind_params, value, PH_SEPARATE);
					}
	
					if (phalcon_array_isset_quick_string(foreign_key, SS("conditions"), 1055696255UL)) {
						PHALCON_OBS_NVAR(extra_conditions);
						phalcon_array_fetch_quick_string(&extra_conditions, foreign_key, SS("conditions"), 1055696255UL, PH_NOISY);
						phalcon_array_append(&conditions, extra_conditions, PH_SEPARATE);
					}
	
					PHALCON_INIT_NVAR(join_conditions);
					phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
					PHALCON_INIT_NVAR(parameters);
					array_init_size(parameters, 2);
					phalcon_array_append(&parameters, join_conditions, 0);
					phalcon_array_update_string(&parameters, SL("bind"), bind_params, PH_COPY);
	
					PHALCON_CALL_METHOD(&rowcount, referenced_model, "count", parameters);
					if (!zend_is_true(rowcount)) {
	
						if (phalcon_array_isset_quick_string(foreign_key, SS("message"), 2265848874UL)) {
							PHALCON_OBS_NVAR(user_message);
							phalcon_array_fetch_quick_string(&user_message, foreign_key, SS("message"), 2265848874UL, PH_NOISY);
						} else {
							if (Z_TYPE_P(fields) == IS_ARRAY) { 
								PHALCON_INIT_NVAR(joined_fields);
								phalcon_fast_join_str(joined_fields, SL(", "), fields TSRMLS_CC);
	
								PHALCON_INIT_NVAR(user_message);
								PHALCON_CONCAT_SVS(user_message, "Value of fields \"", joined_fields, "\" does not exist on referenced table");
							} else {
								PHALCON_INIT_NVAR(user_message);
								PHALCON_CONCAT_SVS(user_message, "Value of field \"", fields, "\" does not exist on referenced table");
							}
						}
	
						PHALCON_INIT_NVAR(type);
						ZVAL_STRING(type, "ConstraintViolation", 1);
	
						PHALCON_INIT_NVAR(message);
						object_init_ex(message, phalcon_mvc_model_message_ce);
						PHALCON_CALL_METHOD(NULL, message, "__construct", user_message, fields, type);
	
						PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message);
	
						PHALCON_INIT_NVAR(error);
						ZVAL_BOOL(error, 1);
						break;
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (PHALCON_IS_TRUE(error)) {
			if (PHALCON_GLOBAL(orm).events) {
				PHALCON_INIT_VAR(event_name);
				ZVAL_STRING(event_name, "onValidationFails", 1);
				PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_canceloperation");
			}
			RETURN_MM_FALSE;
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysReverseRestrict){

	zval *manager, *relations = NULL, *error = NULL, *relation = NULL, *foreign_key = NULL;
	zval *action = NULL, *relation_class = NULL, *referenced_model = NULL;
	zval *fields = NULL, *referenced_fields = NULL, *conditions = NULL;
	zval *bind_params = NULL, *field = NULL, *position = NULL, *value = NULL, *referenced_field = NULL;
	zval *condition = NULL, *extra_conditions = NULL, *join_conditions = NULL;
	zval *parameters = NULL, *rowcount = NULL, *user_message = NULL, *type = NULL;
	zval *message = NULL, *event_name;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&relations, manager, "gethasoneandhasmany", this_ptr);
	if (phalcon_fast_count_ev(relations TSRMLS_CC)) {
	
		PHALCON_INIT_VAR(error);
		ZVAL_BOOL(error, 0);
	
		phalcon_is_iterable(relations, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(relation);
	
			PHALCON_CALL_METHOD(&foreign_key, relation, "getforeignkey");
			if (PHALCON_IS_NOT_FALSE(foreign_key)) {
	
				PHALCON_INIT_NVAR(action);
				ZVAL_LONG(action, 1);
	
				if (Z_TYPE_P(foreign_key) == IS_ARRAY) { 
					if (phalcon_array_isset_quick_string(foreign_key, SS("action"), 502132067UL)) {
						PHALCON_OBS_NVAR(action);
						phalcon_array_fetch_quick_string(&action, foreign_key, SS("action"), 502132067UL, PH_NOISY);
					}
				}
	
				if (PHALCON_IS_LONG(action, 1)) {
	
					PHALCON_CALL_METHOD(&relation_class, relation, "getreferencedmodel");
	
					PHALCON_CALL_METHOD(&referenced_model, manager, "load", relation_class);
					PHALCON_CALL_METHOD(&fields, relation, "getfields");
					PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
	
					PHALCON_INIT_NVAR(conditions);
					array_init(conditions);
	
					PHALCON_INIT_NVAR(bind_params);
					array_init(bind_params);
					if (Z_TYPE_P(fields) == IS_ARRAY) { 
	
						phalcon_is_iterable(fields, &ah1, &hp1, 0, 0);
	
						while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
							PHALCON_GET_HKEY(position, ah1, hp1);
							PHALCON_GET_HVALUE(field);
	
							if (phalcon_isset_property_zval(this_ptr, field TSRMLS_CC)) {
								PHALCON_OBS_NVAR(value);
								phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY TSRMLS_CC);
							} else {
								PHALCON_INIT_NVAR(value);
							}
	
							PHALCON_OBS_NVAR(referenced_field);
							phalcon_array_fetch(&referenced_field, referenced_fields, position, PH_NOISY);
	
							PHALCON_INIT_NVAR(condition);
							PHALCON_CONCAT_SVSV(condition, "[", referenced_field, "] = ?", position);
							phalcon_array_append(&conditions, condition, PH_SEPARATE);
							phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
							zend_hash_move_forward_ex(ah1, &hp1);
						}
	
					} else {
						if (phalcon_isset_property_zval(this_ptr, fields TSRMLS_CC)) {
							PHALCON_OBS_NVAR(value);
							phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY TSRMLS_CC);
						} else {
							PHALCON_INIT_NVAR(value);
						}
	
						PHALCON_INIT_NVAR(condition);
						PHALCON_CONCAT_SVS(condition, "[", referenced_fields, "] = ?0");
						phalcon_array_append(&conditions, condition, PH_SEPARATE);
						phalcon_array_append(&bind_params, value, PH_SEPARATE);
					}
	
					if (phalcon_array_isset_quick_string(foreign_key, SS("conditions"), 1055696255UL)) {
						PHALCON_OBS_NVAR(extra_conditions);
						phalcon_array_fetch_quick_string(&extra_conditions, foreign_key, SS("conditions"), 1055696255UL, PH_NOISY);
						phalcon_array_append(&conditions, extra_conditions, PH_SEPARATE);
					}
	
					PHALCON_INIT_NVAR(join_conditions);
					phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
					PHALCON_INIT_NVAR(parameters);
					array_init_size(parameters, 2);
					phalcon_array_append(&parameters, join_conditions, 0);
					phalcon_array_update_string(&parameters, SL("bind"), bind_params, PH_COPY);
	
					PHALCON_CALL_METHOD(&rowcount, referenced_model, "count", parameters);
					if (zend_is_true(rowcount)) {
	
						if (phalcon_array_isset_quick_string(foreign_key, SS("message"), 2265848874UL)) {
							PHALCON_OBS_NVAR(user_message);
							phalcon_array_fetch_quick_string(&user_message, foreign_key, SS("message"), 2265848874UL, PH_NOISY);
						} else {
							PHALCON_INIT_NVAR(user_message);
							PHALCON_CONCAT_SV(user_message, "Record is referenced by model ", relation_class);
						}
	
						PHALCON_INIT_NVAR(type);
						ZVAL_STRING(type, "ConstraintViolation", 1);
	
						PHALCON_INIT_NVAR(message);
						object_init_ex(message, phalcon_mvc_model_message_ce);
						PHALCON_CALL_METHOD(NULL, message, "__construct", user_message, fields, type);
	
						PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message);
	
						PHALCON_INIT_NVAR(error);
						ZVAL_BOOL(error, 1);
						break;
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (PHALCON_IS_TRUE(error)) {
			if (PHALCON_GLOBAL(orm).events) {
				PHALCON_INIT_VAR(event_name);
				ZVAL_STRING(event_name, "onValidationFails", 1);
				PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_canceloperation");
			}
			RETURN_MM_FALSE;
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _checkForeignKeysReverseCascade){

	zval *manager, *relations = NULL, *relation = NULL, *foreign_key = NULL;
	zval *action = NULL, *relation_class = NULL, *referenced_model = NULL;
	zval *fields = NULL, *referenced_fields = NULL, *conditions = NULL;
	zval *bind_params = NULL, *field = NULL, *position = NULL, *value = NULL, *referenced_field = NULL;
	zval *condition = NULL, *extra_conditions = NULL, *join_conditions = NULL;
	zval *parameters = NULL, *resulset = NULL, *status = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&relations, manager, "gethasoneandhasmany", this_ptr);
	if (phalcon_fast_count_ev(relations TSRMLS_CC)) {
	
		phalcon_is_iterable(relations, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(relation);
	
			PHALCON_CALL_METHOD(&foreign_key, relation, "getforeignkey");
			if (PHALCON_IS_NOT_FALSE(foreign_key)) {
	
				PHALCON_INIT_NVAR(action);
				ZVAL_LONG(action, 0);
	
				if (Z_TYPE_P(foreign_key) == IS_ARRAY) { 
					if (phalcon_array_isset_quick_string(foreign_key, SS("action"), 502132067UL)) {
						PHALCON_OBS_NVAR(action);
						phalcon_array_fetch_quick_string(&action, foreign_key, SS("action"), 502132067UL, PH_NOISY);
					}
				}
	
				if (PHALCON_IS_LONG(action, 2)) {
	
					PHALCON_CALL_METHOD(&relation_class, relation, "getreferencedmodel");
	
					PHALCON_CALL_METHOD(&referenced_model, manager, "load", relation_class);
					PHALCON_CALL_METHOD(&fields, relation, "getfields");
					PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
	
					PHALCON_INIT_NVAR(conditions);
					array_init(conditions);
	
					PHALCON_INIT_NVAR(bind_params);
					array_init(bind_params);
					if (Z_TYPE_P(fields) == IS_ARRAY) { 
	
						phalcon_is_iterable(fields, &ah1, &hp1, 0, 0);
	
						while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
							PHALCON_GET_HKEY(position, ah1, hp1);
							PHALCON_GET_HVALUE(field);
	
							if (phalcon_isset_property_zval(this_ptr, field TSRMLS_CC)) {
								PHALCON_OBS_NVAR(value);
								phalcon_read_property_zval(&value, this_ptr, field, PH_NOISY TSRMLS_CC);
							} else {
								PHALCON_INIT_NVAR(value);
							}
	
							PHALCON_OBS_NVAR(referenced_field);
							phalcon_array_fetch(&referenced_field, referenced_fields, position, PH_NOISY);
	
							PHALCON_INIT_NVAR(condition);
							PHALCON_CONCAT_SVSV(condition, "[", referenced_field, "] = ?", position);
							phalcon_array_append(&conditions, condition, PH_SEPARATE);
							phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
							zend_hash_move_forward_ex(ah1, &hp1);
						}
	
					} else {
						if (phalcon_isset_property_zval(this_ptr, fields TSRMLS_CC)) {
							PHALCON_OBS_NVAR(value);
							phalcon_read_property_zval(&value, this_ptr, fields, PH_NOISY TSRMLS_CC);
						} else {
							PHALCON_INIT_NVAR(value);
						}
	
						PHALCON_INIT_NVAR(condition);
						PHALCON_CONCAT_SVS(condition, "[", referenced_fields, "] = ?0");
						phalcon_array_append(&conditions, condition, PH_SEPARATE);
						phalcon_array_append(&bind_params, value, PH_SEPARATE);
					}
	
					if (phalcon_array_isset_quick_string(foreign_key, SS("conditions"), 1055696255UL)) {
						PHALCON_OBS_NVAR(extra_conditions);
						phalcon_array_fetch_quick_string(&extra_conditions, foreign_key, SS("conditions"), 1055696255UL, PH_NOISY);
						phalcon_array_append(&conditions, extra_conditions, PH_SEPARATE);
					}
	
					PHALCON_INIT_NVAR(join_conditions);
					phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
					PHALCON_INIT_NVAR(parameters);
					array_init_size(parameters, 2);
					phalcon_array_append(&parameters, join_conditions, 0);
					phalcon_array_update_string(&parameters, SL("bind"), bind_params, PH_COPY);
	
					PHALCON_CALL_METHOD(&resulset, referenced_model, "find", parameters);
	
					PHALCON_CALL_METHOD(&status, resulset, "delete");
	
					if (PHALCON_IS_FALSE(status)) {
						RETURN_MM_FALSE;
					}
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _preSave){

	zval *meta_data, *exists, *identity_field, *event_name = NULL;
	zval *status = NULL, *not_null = NULL, *data_type_numeric = NULL;
	zval *column_map = NULL, *automatic_attributes = NULL, *error = NULL;
	zval *null_value, *field = NULL, *is_null = NULL, *attribute_field = NULL;
	zval *exception_message = NULL, *value = NULL, *message = NULL, *type = NULL;
	zval *model_message = NULL, *skipped;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &meta_data, &exists, &identity_field);
	
	if (PHALCON_GLOBAL(orm).events) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeValidation", 1);
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeValidationOnUpdate", 1);
		}
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	if (PHALCON_GLOBAL(orm).virtual_foreign_keys) {
		PHALCON_CALL_METHOD(&status, this_ptr, "_checkforeignkeysrestrict");
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	if (PHALCON_GLOBAL(orm).not_null_validations) {
		PHALCON_CALL_METHOD(&not_null, meta_data, "getnotnullattributes", this_ptr);
		if (Z_TYPE_P(not_null) == IS_ARRAY) { 
	
			PHALCON_CALL_METHOD(&data_type_numeric, meta_data, "getdatatypesnumeric", this_ptr);
			if (PHALCON_GLOBAL(orm).column_renaming) {
				PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
			} else {
				PHALCON_INIT_VAR(column_map);
			}
	
			if (zend_is_true(exists)) {
				PHALCON_CALL_METHOD(&automatic_attributes, meta_data, "getautomaticupdateattributes", this_ptr);
			} else {
				PHALCON_CALL_METHOD(&automatic_attributes, meta_data, "getautomaticcreateattributes", this_ptr);
			}
	
			PHALCON_INIT_VAR(error);
			ZVAL_BOOL(error, 0);
	
			PHALCON_INIT_VAR(null_value);
	
			phalcon_is_iterable(not_null, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(field);
	
				if (!phalcon_array_isset(automatic_attributes, field)) {
	
					PHALCON_INIT_NVAR(is_null);
					ZVAL_BOOL(is_null, 0);
					if (Z_TYPE_P(column_map) == IS_ARRAY) { 
						if (phalcon_array_isset(column_map, field)) {
							PHALCON_OBS_NVAR(attribute_field);
							phalcon_array_fetch(&attribute_field, column_map, field, PH_NOISY);
						} else {
							PHALCON_INIT_NVAR(exception_message);
							PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't part of the column map");
							PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
							return;
						}
					} else {
						PHALCON_CPY_WRT(attribute_field, field);
					}
	
					if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
	
						PHALCON_OBS_NVAR(value);
						phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
	
						if (Z_TYPE_P(value) != IS_OBJECT) {
							if (!phalcon_array_isset(data_type_numeric, field)) {
								if (PHALCON_IS_EMPTY(value)) {
									PHALCON_INIT_NVAR(is_null);
									ZVAL_BOOL(is_null, 1);
								}
							} else {
								if (!phalcon_is_numeric(value)) {
									PHALCON_INIT_NVAR(is_null);
									ZVAL_BOOL(is_null, 1);
								}
							}
						}
					} else {
						PHALCON_INIT_NVAR(is_null);
						ZVAL_BOOL(is_null, 1);
					}
	
					if (PHALCON_IS_TRUE(is_null)) {
						if (!zend_is_true(exists)) {
	
							if (PHALCON_IS_EQUAL(field, identity_field)) {
								zend_hash_move_forward_ex(ah0, &hp0);
								continue;
							}
						}
	
						PHALCON_INIT_NVAR(message);
						PHALCON_CONCAT_VS(message, attribute_field, " is required");
	
						PHALCON_INIT_NVAR(type);
						ZVAL_STRING(type, "PresenceOf", 1);
	
						PHALCON_INIT_NVAR(model_message);
						object_init_ex(model_message, phalcon_mvc_model_message_ce);
						PHALCON_CALL_METHOD(NULL, model_message, "__construct", message, attribute_field, type);
	
						phalcon_update_property_array_append(this_ptr, SL("_errorMessages"), model_message TSRMLS_CC);
	
						PHALCON_INIT_NVAR(error);
						ZVAL_BOOL(error, 1);
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			if (PHALCON_IS_TRUE(error)) {
				if (PHALCON_GLOBAL(orm).events) {
					PHALCON_INIT_NVAR(event_name);
					ZVAL_STRING(event_name, "onValidationFails", 1);
					PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
					PHALCON_CALL_METHOD(NULL, this_ptr, "_canceloperation");
				}
				RETURN_MM_FALSE;
			}
		}
	}
	
	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "validation", 1);
	
	PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
	if (PHALCON_IS_FALSE(status)) {
		if (PHALCON_GLOBAL(orm).events) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "onValidationFails", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
		}
		RETURN_MM_FALSE;
	}
	
	if (PHALCON_GLOBAL(orm).events) {
		if (!zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnCreate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterValidationOnUpdate", 1);
		}
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterValidation", 1);
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "beforeSave", 1);
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	
		if (zend_is_true(exists)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "beforeCreate", 1);
		}
	
		phalcon_update_property_bool(this_ptr, SL("_skipped"), 0 TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_OBS_VAR(skipped);
		phalcon_read_property_this(&skipped, this_ptr, SL("_skipped"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_TRUE(skipped)) {
			RETURN_MM_TRUE;
		}
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _postSave){

	zval *success, *exists, *event_name = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &success, &exists);
	
	if (PHALCON_IS_TRUE(success)) {
		if (zend_is_true(exists)) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "afterUpdate", 1);
		} else {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterCreate", 1);
		}
		PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "afterSave", 1);
		PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	
		RETURN_CTOR(success);
	}
	
	PHALCON_INIT_NVAR(event_name);
	ZVAL_STRING(event_name, "notSave", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
	PHALCON_CALL_METHOD(NULL, this_ptr, "_canceloperation");
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _doLowInsert){

	zval *meta_data, *connection, *table, *identity_field;
	zval *null_value, *bind_skip, *fields, *values;
	zval *bind_types, *attributes = NULL, *bind_data_types = NULL;
	zval *automatic_attributes = NULL, *column_map = NULL, *field = NULL;
	zval *attribute_field = NULL, *exception_message = NULL;
	zval *value = NULL, *bind_type = NULL, *default_value = NULL, *use_explicit_identity = NULL;
	zval *success = NULL, *sequence_name = NULL, *support_sequences = NULL;
	zval *schema = NULL, *source = NULL, *last_insert_id = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int identity_field_is_not_false; /* scan-build insists on using flags */

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &meta_data, &connection, &table, &identity_field);

	null_value = PHALCON_GLOBAL(z_null);
	
	PHALCON_INIT_VAR(bind_skip);
	ZVAL_LONG(bind_skip, 1024);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	PHALCON_CALL_METHOD(&bind_data_types, meta_data, "getbindtypes", this_ptr);
	PHALCON_CALL_METHOD(&automatic_attributes, meta_data, "getautomaticcreateattributes", this_ptr);

	if (PHALCON_GLOBAL(orm).column_renaming) {
		PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
	}
	else {
		PHALCON_INIT_VAR(column_map);
	}
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		if (!phalcon_array_isset(automatic_attributes, field)) {
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, field)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, field);
			}
	
			if (!PHALCON_IS_EQUAL(field, identity_field)) {
				phalcon_array_append(&fields, field, PH_SEPARATE);
	
				if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
	
					if (!phalcon_array_isset(bind_data_types, field)) {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' has not defined a bind data type");
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
	
					PHALCON_OBS_NVAR(value);
					phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
					phalcon_array_append(&values, value, PH_SEPARATE);
	
					PHALCON_OBS_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY);
					phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
				} else {
					phalcon_array_append(&values, null_value, PH_SEPARATE);
					phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE);
				}
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	identity_field_is_not_false = PHALCON_IS_NOT_FALSE(identity_field);
	if (identity_field_is_not_false) {
		PHALCON_CALL_METHOD(&default_value, connection, "getdefaultidvalue");
	
		PHALCON_CALL_METHOD(&use_explicit_identity, connection, "useexplicitidvalue");
		if (zend_is_true(use_explicit_identity)) {
			phalcon_array_append(&fields, identity_field, PH_SEPARATE);
		}
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (phalcon_array_isset(column_map, identity_field)) {
				PHALCON_OBS_NVAR(attribute_field);
				phalcon_array_fetch(&attribute_field, column_map, identity_field, PH_NOISY);
			} else {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Identity column '", identity_field, "' isn't part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_CPY_WRT(attribute_field, identity_field);
		}
	
		if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
	
			PHALCON_OBS_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_EMPTY(value)) {
				if (zend_is_true(use_explicit_identity)) {
					phalcon_array_append(&values, default_value, PH_SEPARATE);
					phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE);
				}
			} else {
				if (!zend_is_true(use_explicit_identity)) {
					phalcon_array_append(&fields, identity_field, PH_SEPARATE);
				}
	
				if (!phalcon_array_isset(bind_data_types, identity_field)) {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Identity column '", identity_field, "' isn't part of the table columns");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
	
				phalcon_array_append(&values, value, PH_SEPARATE);
	
				PHALCON_OBS_NVAR(bind_type);
				phalcon_array_fetch(&bind_type, bind_data_types, identity_field, PH_NOISY);
				phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
			}
		} else {
			if (zend_is_true(use_explicit_identity)) {
				phalcon_array_append(&values, default_value, PH_SEPARATE);
				phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE);
			}
		}
	}
	
	PHALCON_CALL_METHOD(&success, connection, "insert", table, values, fields, bind_types);
	if (identity_field_is_not_false) {
	
		PHALCON_CALL_METHOD(&support_sequences, connection, "supportsequences");
		if (PHALCON_IS_TRUE(support_sequences)) {
			if (phalcon_method_quick_exists_ex(this_ptr, SS("getsequencename"), 3416900031UL TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD(&sequence_name, this_ptr, "getsequencename");
			} else {
				PHALCON_CALL_METHOD(&schema, this_ptr, "getschema"); 
				PHALCON_CALL_METHOD(&source, this_ptr, "getsource");

				PHALCON_INIT_VAR(sequence_name);
				if (PHALCON_IS_EMPTY(schema)) {	
					PHALCON_CONCAT_VSVS(sequence_name, source, "_", identity_field, "_seq");
				} else {
					PHALCON_CONCAT_VSVSVS(sequence_name, schema, ".", source, "_", identity_field, "_seq");
				}
			}
		}
		else {
			PHALCON_INIT_VAR(sequence_name);
		}
	
		PHALCON_CALL_METHOD(&last_insert_id, connection, "lastinsertid", sequence_name);
		phalcon_update_property_zval_zval(this_ptr, attribute_field, last_insert_id TSRMLS_CC);
	
		phalcon_update_property_null(this_ptr, SL("_uniqueParams") TSRMLS_CC);
	}
	
	RETURN_CTOR(success);
}

static PHP_METHOD(Phalcon_Mvc_Model, _doLowUpdate){

	zval *meta_data, *connection, *table, *null_value;
	zval *bind_skip, *fields, *values, *bind_types;
	zval *manager, *use_dynamic_update = NULL, *snapshot;
	zval *bind_data_types = NULL, *non_primary = NULL, *automatic_attributes = NULL;
	zval *column_map = NULL, *field = NULL, *exception_message = NULL;
	zval *attribute_field = NULL, *value = NULL, *bind_type = NULL, *changed = NULL;
	zval *snapshot_value = NULL, *unique_key, *unique_params = NULL;
	zval *unique_types, *primary_keys = NULL, *conditions;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int i_use_dynamic_update; /* To keep static code analyzer happy */

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &meta_data, &connection, &table);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(bind_skip);
	ZVAL_LONG(bind_skip, 1024);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&use_dynamic_update, manager, "isusingdynamicupdate", this_ptr);
	i_use_dynamic_update = zend_is_true(use_dynamic_update);
	if (i_use_dynamic_update) {
	
		PHALCON_OBS_VAR(snapshot);
		phalcon_read_property_this(&snapshot, this_ptr, SL("_snapshot"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(snapshot) != IS_ARRAY) { 
			i_use_dynamic_update = 0;
		}
	}
	
	PHALCON_CALL_METHOD(&bind_data_types, meta_data, "getbindtypes", this_ptr);
	PHALCON_CALL_METHOD(&non_primary, meta_data, "getnonprimarykeyattributes", this_ptr);
	PHALCON_CALL_METHOD(&automatic_attributes, meta_data, "getautomaticupdateattributes", this_ptr);
	if (PHALCON_GLOBAL(orm).column_renaming) {
		PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
	} else {
		PHALCON_INIT_VAR(column_map);
	}
	
	phalcon_is_iterable(non_primary, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(field);
	
		if (!phalcon_array_isset(automatic_attributes, field)) {
	
			if (!phalcon_array_isset(bind_data_types, field)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' have not defined a bind data type");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, field)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, field);
			}
	
			if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
	
				PHALCON_OBS_NVAR(value);
				phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
	
				if (!i_use_dynamic_update) {
					phalcon_array_append(&fields, field, PH_SEPARATE);
					phalcon_array_append(&values, value, PH_SEPARATE);
	
					PHALCON_OBS_NVAR(bind_type);
					phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY);
					phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
				} else {
					if (!phalcon_array_isset(snapshot, attribute_field)) {
						PHALCON_INIT_NVAR(changed);
						ZVAL_BOOL(changed, 1);
					} else {
						PHALCON_OBS_NVAR(snapshot_value);
						phalcon_array_fetch(&snapshot_value, snapshot, attribute_field, PH_NOISY);
						if (!PHALCON_IS_EQUAL(value, snapshot_value)) {
							PHALCON_INIT_NVAR(changed);
							ZVAL_BOOL(changed, 1);
						} else {
							PHALCON_INIT_NVAR(changed);
							ZVAL_BOOL(changed, 0);
						}
					}
	
					if (zend_is_true(changed)) {
						phalcon_array_append(&fields, field, PH_SEPARATE);
						phalcon_array_append(&values, value, PH_SEPARATE);
	
						PHALCON_OBS_NVAR(bind_type);
						phalcon_array_fetch(&bind_type, bind_data_types, field, PH_NOISY);
						phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
					}
				}
			} else {
				phalcon_array_append(&fields, field, PH_SEPARATE);
				phalcon_array_append(&values, null_value, PH_SEPARATE);
				phalcon_array_append(&bind_types, bind_skip, PH_SEPARATE);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (!phalcon_fast_count_ev(fields TSRMLS_CC)) {
		RETURN_MM_TRUE;
	}
	
	PHALCON_OBS_VAR(unique_key);
	phalcon_read_property_this(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(unique_params);
	phalcon_read_property_this(&unique_params, this_ptr, SL("_uniqueParams"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(unique_types);
	phalcon_read_property_this(&unique_types, this_ptr, SL("_uniqueTypes"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(unique_params) != IS_ARRAY) { 
	
		PHALCON_INIT_NVAR(unique_params);
		array_init(unique_params);
	
		PHALCON_CALL_METHOD(&primary_keys, meta_data, "getprimarykeyattributes", this_ptr);
	
		if (!phalcon_fast_count_ev(primary_keys TSRMLS_CC)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A primary key must be defined in the model in order to perform the operation");
			return;
		}
	
		phalcon_is_iterable(primary_keys, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(field);
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, field)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", field, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, field);
			}
			if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
				PHALCON_OBS_NVAR(value);
				phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
				phalcon_array_append(&unique_params, value, PH_SEPARATE);
			} else {
				phalcon_array_append(&unique_params, null_value, PH_SEPARATE);
			}
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
	}
	
	PHALCON_INIT_VAR(conditions);
	array_init_size(conditions, 3);
	phalcon_array_update_string(&conditions, ISL(conditions), unique_key, PH_COPY);
	phalcon_array_update_string(&conditions, SL("bind"), unique_params, PH_COPY);
	phalcon_array_update_string(&conditions, SL("bindTypes"), unique_types, PH_COPY);

	PHALCON_RETURN_CALL_METHOD(connection, "update", table, fields, values, conditions, bind_types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, _preSaveRelatedRecords){

	zval *connection, *related, *nesting, *class_name;
	zval *manager = NULL, *record = NULL, *name = NULL, *relation = NULL, *type = NULL, *columns = NULL;
	zval *referenced_model = NULL, *referenced_fields = NULL;
	zval *status = NULL, *referenced_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &connection, &related);
	
	nesting = PHALCON_GLOBAL(z_false);
	
	PHALCON_CALL_METHOD(NULL, connection, "begin", nesting);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&manager, this_ptr, "getmodelsmanager");
	
	phalcon_is_iterable(related, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah0, hp0);
		PHALCON_GET_HVALUE(record);
	
		PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", class_name, name);
		if (Z_TYPE_P(relation) == IS_OBJECT) {
	
			PHALCON_CALL_METHOD(&type, relation, "gettype");
	
			if (PHALCON_IS_LONG(type, 0)) {
	
				if (Z_TYPE_P(record) != IS_OBJECT) {
					PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Only objects can be stored as part of belongs-to relations");
					return;
				}
	
				PHALCON_CALL_METHOD(&columns, relation, "getfields");
				PHALCON_CALL_METHOD(&referenced_model, relation, "getreferencedmodel");
				PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
				if (Z_TYPE_P(columns) == IS_ARRAY) { 
					PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Not implemented");
					return;
				}
	
				PHALCON_CALL_METHOD(&status, record, "save");
				if (!zend_is_true(status)) {
	
					if (phalcon_mvc_model_get_messages_from_model(this_ptr, record, record TSRMLS_CC) == FAILURE) {
						RETURN_MM();
					}
	
					PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
					RETURN_MM_FALSE;
				}
	
				PHALCON_CALL_METHOD(&referenced_value, record, "readattribute", referenced_fields);
	
				phalcon_update_property_zval_zval(this_ptr, columns, referenced_value TSRMLS_CC);
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, _postSaveRelatedRecords){

	zval *connection, *related, *nesting, *class_name;
	zval *manager = NULL, *record = NULL, *name = NULL, *relation = NULL, *type = NULL, *columns = NULL;
	zval *referenced_model = NULL, *referenced_fields = NULL;
	zval *related_records = NULL, *exception_message = NULL;
	zval *value = NULL, *is_through = NULL, *new_instance, *intermediate_model_name = NULL;
	zval *intermediate_fields = NULL, *intermediate_referenced_fields = NULL;
	zval *record_after = NULL, *intermediate_model = NULL, *intermediate_value = NULL;
	zval *status = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	phalcon_fetch_params(0, 2, 0, &connection, &related);

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(nesting);
	ZVAL_FALSE(nesting);
	
	PHALCON_INIT_VAR(new_instance);
	ZVAL_TRUE(new_instance);

	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&manager, this_ptr, "getmodelsmanager");
	
	phalcon_is_iterable(related, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah0, hp0);
		PHALCON_GET_HVALUE(record);
	
		PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", class_name, name);
		if (Z_TYPE_P(relation) == IS_OBJECT) {
	
			PHALCON_CALL_METHOD(&type, relation, "gettype");
	
			if (PHALCON_IS_LONG(type, 0)) {
				zend_hash_move_forward_ex(ah0, &hp0);
				continue;
			}
	
			if (Z_TYPE_P(record) != IS_OBJECT && Z_TYPE_P(record) != IS_ARRAY) {
				PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Only objects/arrays can be stored as part of has-many/has-one/has-many-to-many relations");
				return;
			}
	
			PHALCON_CALL_METHOD(&columns, relation, "getfields");
			PHALCON_CALL_METHOD(&referenced_model, relation, "getreferencedmodel");
			PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");

			if (Z_TYPE_P(columns) == IS_ARRAY) { 
				PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Not implemented");
				return;
			}
	
			if (Z_TYPE_P(record) == IS_OBJECT) {
				PHALCON_INIT_NVAR(related_records);
				array_init_size(related_records, 1);
				phalcon_array_append(&related_records, record, 0);
			} else {
				PHALCON_CPY_WRT(related_records, record);
			}
	
			if (!phalcon_isset_property_zval(this_ptr, columns TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "The column '", columns, "' needs to be present in the model");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, columns, PH_NOISY TSRMLS_CC);
	
			PHALCON_CALL_METHOD(&is_through, relation, "isthrough");
	
			if (zend_is_true(is_through)) {
				PHALCON_CALL_METHOD(&intermediate_model_name, relation, "getintermediatemodel");
				PHALCON_CALL_METHOD(&intermediate_fields, relation, "getintermediatefields");
				PHALCON_CALL_METHOD(&intermediate_referenced_fields, relation, "getintermediatereferencedfields");
			}
	
			phalcon_is_iterable(related_records, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HVALUE(record_after);
	
				if (!zend_is_true(is_through)) {
					PHALCON_CALL_METHOD(NULL, record_after, "writeattribute", referenced_fields, value);
				}

				PHALCON_CALL_METHOD(&status, record_after, "save");
				if (!zend_is_true(status)) {

					if (phalcon_mvc_model_get_messages_from_model(this_ptr, record_after, record TSRMLS_CC) == FAILURE) {
						RETURN_MM();
					}

					PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
					RETURN_MM_FALSE;
				}

				if (zend_is_true(is_through)) {
					PHALCON_CALL_METHOD(&intermediate_model, manager, "load", intermediate_model_name, new_instance);
	
					PHALCON_CALL_METHOD(NULL, intermediate_model, "writeattribute", intermediate_fields, value);
	
					PHALCON_OBS_NVAR(intermediate_value);
					phalcon_read_property_zval(&intermediate_value, record_after, referenced_fields, PH_NOISY TSRMLS_CC);
	
					PHALCON_CALL_METHOD(NULL, intermediate_model, "writeattribute", intermediate_referenced_fields, intermediate_value);
	
					PHALCON_CALL_METHOD(&status, intermediate_model, "save");
					if (!zend_is_true(status)) {
	
						if (phalcon_mvc_model_get_messages_from_model(this_ptr, intermediate_model, record TSRMLS_CC) == FAILURE) {
							RETURN_MM();
						}

						PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
						RETURN_MM_FALSE;
					}
				}
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
		} else {
			if (Z_TYPE_P(record) != IS_ARRAY) { 
				PHALCON_CALL_METHOD(NULL, connection, "rollback", nesting);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "There are no defined relations for the model \"", class_name, "\" using alias \"", name, "\"");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(NULL, connection, "commit", nesting);
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model, save){

	zval *data = NULL, *white_list = NULL, *meta_data = NULL, *attributes = NULL;
	zval *attribute = NULL, *value = NULL, *possible_setter = NULL, *write_connection = NULL;
	zval *related, *status = NULL, *schema = NULL, *source = NULL, *table = NULL, *read_connection = NULL;
	zval *exists = NULL, *error_messages = NULL, *identity_field = NULL;
	zval *nesting = NULL, *exception, *success = NULL, *new_success = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &white_list);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	if (Z_TYPE_P(data) != IS_NULL) {
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data passed to save() must be an array");
			return;
		}
	
		PHALCON_CALL_METHOD(&attributes, meta_data, "getcolumnmap", this_ptr);
		if (Z_TYPE_P(attributes) != IS_ARRAY) { 
			PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
		}
	
		phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(attribute);
	
			if (phalcon_array_isset(data, attribute)) {
	
				if (Z_TYPE_P(white_list) == IS_ARRAY) { 
					if (!phalcon_fast_in_array(attribute, white_list TSRMLS_CC)) {
						zend_hash_move_forward_ex(ah0, &hp0);
						continue;
					}
				}
	
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch(&value, data, attribute, PH_NOISY);
	
				PHALCON_INIT_NVAR(possible_setter);
				PHALCON_CONCAT_SV(possible_setter, "set", attribute);
				zend_str_tolower(Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter));
				if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter)+1 TSRMLS_CC) == SUCCESS) {
					PHALCON_CALL_METHOD(NULL, this_ptr, Z_STRVAL_P(possible_setter), value);
				} else {
					phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_CALL_METHOD(&write_connection, this_ptr, "getwriteconnection");
	
	PHALCON_OBS_VAR(related);
	phalcon_read_property_this(&related, this_ptr, SL("_related"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(related) == IS_ARRAY) { 
	
		PHALCON_CALL_METHOD(&status, this_ptr, "_presaverelatedrecords", write_connection, related);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_CALL_METHOD(&schema, this_ptr, "getschema");
	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		array_init_size(table, 2);
		phalcon_array_append(&table, schema, 0);
		phalcon_array_append(&table, source, 0);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_CALL_METHOD(&read_connection, this_ptr, "getreadconnection");
	
	PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", meta_data, read_connection, table);
	if (zend_is_true(exists)) {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 2 TSRMLS_CC);
	} else {
		phalcon_update_property_long(this_ptr, SL("_operationMade"), 1 TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(error_messages);
	array_init(error_messages);
	phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), error_messages, 1019066246UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&identity_field, meta_data, "getidentityfield", this_ptr);
	
	PHALCON_CALL_METHOD(&status, this_ptr, "_presave", meta_data, exists, identity_field);
	if (PHALCON_IS_FALSE(status)) {
	
		if (Z_TYPE_P(related) == IS_ARRAY) { 
			PHALCON_INIT_VAR(nesting);
			ZVAL_BOOL(nesting, 0);
			PHALCON_CALL_METHOD(NULL, write_connection, "rollback", nesting);
		}
	
		if (PHALCON_GLOBAL(orm).exception_on_failed_save) {
			PHALCON_OBS_NVAR(error_messages);
			phalcon_read_property_this(&error_messages, this_ptr, SL("_errorMessages"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_VAR(exception);
			object_init_ex(exception, phalcon_mvc_model_validationfailed_ce);
			PHALCON_CALL_METHOD(NULL, exception, "__construct", this_ptr, error_messages);
	
			phalcon_throw_exception(exception TSRMLS_CC);
			RETURN_MM();
		}
	
		RETURN_MM_FALSE;
	}
	
	if (zend_is_true(exists)) {
		PHALCON_CALL_METHOD(&success, this_ptr, "_dolowupdate", meta_data, write_connection, table);
	} else {
		PHALCON_CALL_METHOD(&success, this_ptr, "_dolowinsert", meta_data, write_connection, table, identity_field);
	}
	
	if (zend_is_true(success)) {
		phalcon_update_property_long(this_ptr, SL("_dirtyState"), 0 TSRMLS_CC);
	}
	
	if (PHALCON_GLOBAL(orm).events) {
		PHALCON_CALL_METHOD(&new_success, this_ptr, "_postsave", success, exists);
	} else {
		PHALCON_CPY_WRT(new_success, success);
	}
	
	if (Z_TYPE_P(related) == IS_ARRAY) { 
	
		if (PHALCON_IS_FALSE(new_success)) {
			PHALCON_INIT_NVAR(nesting);
			ZVAL_BOOL(nesting, 0);
			PHALCON_CALL_METHOD(NULL, write_connection, "rollback", nesting);
			RETURN_MM_FALSE;
		}
	
		PHALCON_CALL_METHOD(&status, this_ptr, "_postsaverelatedrecords", write_connection, related);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	RETURN_CTOR(new_success);
}

static PHP_METHOD(Phalcon_Mvc_Model, create){

	zval *data = NULL, *white_list = NULL, *meta_data = NULL, *column_map = NULL;
	zval *attributes = NULL, *attribute = NULL, *attribute_field = NULL;
	zval *exception_message = NULL, *value = NULL, *possible_setter = NULL;
	zval *read_connection = NULL, *exists = NULL, *field, *type, *message;
	zval *model_message, *messages;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &white_list);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	if (Z_TYPE_P(data) != IS_NULL) {
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data passed to create() must be an array");
			return;
		}
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	
		phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(attribute);
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, attribute)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, attribute, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", attribute, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, attribute);
			}
	
			if (phalcon_array_isset(data, attribute_field)) {
	
				if (Z_TYPE_P(white_list) == IS_ARRAY) { 
					if (!phalcon_fast_in_array(attribute_field, white_list TSRMLS_CC)) {
						zend_hash_move_forward_ex(ah0, &hp0);
						continue;
					}
				}
	
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch(&value, data, attribute_field, PH_NOISY);
	
				PHALCON_INIT_NVAR(possible_setter);
				PHALCON_CONCAT_SV(possible_setter, "set", attribute_field);
				zend_str_tolower(Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter));
				if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter)+1 TSRMLS_CC) == SUCCESS) {
					PHALCON_CALL_METHOD(NULL, this_ptr, Z_STRVAL_P(possible_setter), value);
				} else {
					phalcon_update_property_zval_zval(this_ptr, attribute_field, value TSRMLS_CC);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_CALL_METHOD(&read_connection, this_ptr, "getreadconnection");
	
	PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", meta_data, read_connection);
	
	if (zend_is_true(exists)) {
		PHALCON_INIT_VAR(field);
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "InvalidCreateAttempt", 1);
	
		PHALCON_INIT_VAR(message);
		ZVAL_STRING(message, "Record cannot be created because it already exists", 1);
	
		PHALCON_INIT_VAR(model_message);
		object_init_ex(model_message, phalcon_mvc_model_message_ce);
		PHALCON_CALL_METHOD(NULL, model_message, "__construct", message, field, type);
	
		PHALCON_INIT_VAR(messages);
		array_init_size(messages, 1);
		phalcon_array_append(&messages, model_message, PH_SEPARATE);
		phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), messages, 1019066246UL TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "save");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, update){

	zval *data = NULL, *white_list = NULL, *meta_data = NULL, *column_map = NULL;
	zval *attributes = NULL, *attribute = NULL, *attribute_field = NULL;
	zval *exception_message = NULL, *value = NULL, *possible_setter = NULL;
	zval *dirty_state, *read_connection = NULL, *exists = NULL;
	zval *field, *type, *message, *model_message, *messages;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &data, &white_list);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (!white_list) {
		white_list = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(meta_data);
	
	if (Z_TYPE_P(data) != IS_NULL) {
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Data passed to update() must be an array");
			return;
		}
	
		PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	
		phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(attribute);
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, attribute)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, attribute, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", attribute, "' isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, attribute);
			}
	
			if (phalcon_array_isset(data, attribute_field)) {
	
				if (Z_TYPE_P(white_list) == IS_ARRAY) { 
					if (!phalcon_fast_in_array(attribute_field, white_list TSRMLS_CC)) {
						zend_hash_move_forward_ex(ah0, &hp0);
						continue;
					}
				}
	
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch(&value, data, attribute_field, PH_NOISY);
	
				PHALCON_INIT_NVAR(possible_setter);
				PHALCON_CONCAT_SV(possible_setter, "set", attribute_field);
				zend_str_tolower(Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter));
				if (phalcon_method_exists_ex(this_ptr, Z_STRVAL_P(possible_setter), Z_STRLEN_P(possible_setter)+1 TSRMLS_CC) == SUCCESS) {
					PHALCON_CALL_METHOD(NULL, this_ptr, Z_STRVAL_P(possible_setter), value);
				} else {
					phalcon_update_property_zval_zval(this_ptr, attribute_field, value TSRMLS_CC);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_OBS_VAR(dirty_state);
	phalcon_read_property_this(&dirty_state, this_ptr, SL("_dirtyState"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(dirty_state)) {
		if (Z_TYPE_P(meta_data) == IS_NULL) {
			PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
		}
	
		PHALCON_CALL_METHOD(&read_connection, this_ptr, "getreadconnection");

		PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", meta_data, read_connection);
		if (!zend_is_true(exists)) {
			PHALCON_INIT_VAR(field);
	
			PHALCON_INIT_VAR(type);
			ZVAL_STRING(type, "InvalidUpdateAttempt", 1);
	
			PHALCON_INIT_VAR(message);
			ZVAL_STRING(message, "Record cannot be updated because it does not exist", 1);
	
			PHALCON_INIT_VAR(model_message);
			object_init_ex(model_message, phalcon_mvc_model_message_ce);
			PHALCON_CALL_METHOD(NULL, model_message, "__construct", message, field, type);
	
			PHALCON_INIT_VAR(messages);
			array_init_size(messages, 1);
			phalcon_array_append(&messages, model_message, 0);
			phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), messages, 1019066246UL TSRMLS_CC);
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "save");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, delete){

	zval *meta_data = NULL, *write_connection = NULL, *empty_array;
	zval *check_foreign_keys = NULL, *values, *bind_types;
	zval *conditions, *primary_keys = NULL, *bind_data_types = NULL;
	zval *column_map = NULL, *primary_key = NULL, *exception_message = NULL;
	zval *attribute_field = NULL, *value = NULL, *escaped_field = NULL;
	zval *primary_condition = NULL, *bind_type = NULL, *delete_conditions;
	zval *event_name = NULL, *status = NULL, *skipped, *schema = NULL, *source = NULL;
	zval *table = NULL, *success = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	PHALCON_CALL_METHOD(&write_connection, this_ptr, "getwriteconnection");
	
	phalcon_update_property_long(this_ptr, SL("_operationMade"), 3 TSRMLS_CC);
	
	PHALCON_INIT_VAR(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), empty_array, 1019066246UL TSRMLS_CC);
	
	if (PHALCON_GLOBAL(orm).virtual_foreign_keys) {
		PHALCON_CALL_METHOD(&check_foreign_keys, this_ptr, "_checkforeignkeysreverserestrict");
		if (PHALCON_IS_FALSE(check_foreign_keys)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_INIT_VAR(values);
	array_init(values);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	
	PHALCON_CALL_METHOD(&primary_keys, meta_data, "getprimarykeyattributes", this_ptr);
	PHALCON_CALL_METHOD(&bind_data_types, meta_data, "getbindtypes", this_ptr);
	if (PHALCON_GLOBAL(orm).column_renaming) {
		PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
	} else {
		PHALCON_INIT_VAR(column_map);
	}
	
	if (!phalcon_fast_count_ev(primary_keys TSRMLS_CC)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A primary key must be defined in the model in order to perform the operation");
		return;
	}
	
	phalcon_is_iterable(primary_keys, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(primary_key);
	
		if (!phalcon_array_isset(bind_data_types, primary_key)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Column '", primary_key, "' have not defined a bind data type");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (phalcon_array_isset(column_map, primary_key)) {
				PHALCON_OBS_NVAR(attribute_field);
				phalcon_array_fetch(&attribute_field, column_map, primary_key, PH_NOISY);
			} else {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", primary_key, "' isn't part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_CPY_WRT(attribute_field, primary_key);
		}
	
		if (!phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Cannot delete the record because the primary key attribute: '", attribute_field, "' wasn't set");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_OBS_NVAR(value);
		phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
		phalcon_array_append(&values, value, PH_SEPARATE);
	
		PHALCON_CALL_METHOD(&escaped_field, write_connection, "escapeidentifier", primary_key);
	
		PHALCON_INIT_NVAR(primary_condition);
		PHALCON_CONCAT_VS(primary_condition, escaped_field, " = ?");
		phalcon_array_append(&conditions, primary_condition, PH_SEPARATE);
	
		PHALCON_OBS_NVAR(bind_type);
		phalcon_array_fetch(&bind_type, bind_data_types, primary_key, PH_NOISY);
		phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(delete_conditions);
	phalcon_fast_join_str(delete_conditions, SL(" AND "), conditions TSRMLS_CC);
	if (PHALCON_GLOBAL(orm).events) {
		phalcon_update_property_bool(this_ptr, SL("_skipped"), 0 TSRMLS_CC);
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "beforeDelete", 1);
	
		PHALCON_CALL_METHOD(&status, this_ptr, "fireeventcancel", event_name);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		} else {
			PHALCON_OBS_VAR(skipped);
			phalcon_read_property_this(&skipped, this_ptr, SL("_skipped"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_TRUE(skipped)) {
				RETURN_MM_TRUE;
			}
		}
	}
	
	PHALCON_CALL_METHOD(&schema, this_ptr, "getschema");
	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		array_init_size(table, 2);
		phalcon_array_append(&table, schema, 0);
		phalcon_array_append(&table, source, 0);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_CALL_METHOD(&success, write_connection, "delete", table, delete_conditions, values, bind_types);
	
	if (PHALCON_GLOBAL(orm).virtual_foreign_keys) {
		PHALCON_CALL_METHOD(&check_foreign_keys, this_ptr, "_checkforeignkeysreversecascade");
		if (PHALCON_IS_FALSE(check_foreign_keys)) {
			RETURN_MM_FALSE;
		}
	}
	
	if (PHALCON_GLOBAL(orm).events) {
		if (zend_is_true(success)) {
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "afterDelete", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "fireevent", event_name);
		}
	}
	
	phalcon_update_property_long(this_ptr, SL("_dirtyState"), 2 TSRMLS_CC);
	
	RETURN_CTOR(success);
}

static PHP_METHOD(Phalcon_Mvc_Model, getOperationMade){


	RETURN_MEMBER_QUICK(this_ptr, "_operationMade", 3968152972UL);
}

static PHP_METHOD(Phalcon_Mvc_Model, refresh){

	zval *dirty_state, *meta_data = NULL, *read_connection = NULL;
	zval *schema = NULL, *source = NULL, *table = NULL, *unique_key = NULL, *exists = NULL;
	zval *unique_params, *unique_types, *attributes = NULL;
	zval *fields, *escaped_table = NULL;
	zval *select, *dialect = NULL, *sql = NULL, *fetch_type, *row = NULL, *column_map = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(dirty_state);
	phalcon_read_property_this(&dirty_state, this_ptr, SL("_dirtyState"), PH_NOISY TSRMLS_CC);
	if (!PHALCON_IS_LONG(dirty_state, 0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The record cannot be refreshed because it does not exist or is deleted");
		return;
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	PHALCON_CALL_METHOD(&read_connection, this_ptr, "getreadconnection");
	PHALCON_CALL_METHOD(&schema, this_ptr, "getschema");
	PHALCON_CALL_METHOD(&source, this_ptr, "getsource");
	
	if (zend_is_true(schema)) {
		PHALCON_INIT_VAR(table);
		array_init_size(table, 2);
		phalcon_array_append(&table, schema, 0);
		phalcon_array_append(&table, source, 0);
	} else {
		PHALCON_CPY_WRT(table, source);
	}
	
	PHALCON_OBS_VAR(unique_key);
	phalcon_read_property_this(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(unique_key)) {
	
		PHALCON_CALL_METHOD(&exists, this_ptr, "_exists", meta_data, read_connection, table);
		if (!zend_is_true(exists)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The record cannot be refreshed because it does not exist or is deleted");
			return;
		}
	
		PHALCON_OBS_NVAR(unique_key);
		phalcon_read_property_this(&unique_key, this_ptr, SL("_uniqueKey"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(unique_params);
	phalcon_read_property_this(&unique_params, this_ptr, SL("_uniqueParams"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(unique_params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The record cannot be refreshed because it does not exist or is deleted");
		return;
	}
	
	PHALCON_OBS_VAR(unique_types);
	phalcon_read_property_this(&unique_types, this_ptr, SL("_uniqueTypes"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	
	PHALCON_INIT_VAR(fields);
	array_init(fields);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
		zval *field_item;

		MAKE_STD_ZVAL(field_item);
		array_init_size(field_item, 1);
		phalcon_array_append(&field_item, *hd, 0);

		add_next_index_zval(fields, field_item);

		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&escaped_table, read_connection, "escapeidentifier", table);
	
	PHALCON_INIT_VAR(select);
	array_init_size(select, 3);
	phalcon_array_update_string(&select, ISL(columns), fields, PH_COPY);
	phalcon_array_update_string(&select, ISL(tables), escaped_table, PH_COPY);
	phalcon_array_update_string(&select, ISL(where), unique_key, PH_COPY);
	
	PHALCON_CALL_METHOD(&dialect, read_connection, "getdialect");
	PHALCON_CALL_METHOD(&sql, dialect, "select", select);
	
	PHALCON_INIT_VAR(fetch_type);
	ZVAL_LONG(fetch_type, PDO_FETCH_ASSOC);
	
	PHALCON_CALL_METHOD(&row, read_connection, "fetchone", sql, fetch_type, unique_params, unique_types);
	
	PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
	
	if (Z_TYPE_P(row) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(NULL, this_ptr, "assign", row, column_map);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, skipOperation){

	zval *skip;

	phalcon_fetch_params(0, 1, 0, &skip);
	
	phalcon_update_property_this_quick(this_ptr, SL("_skipped"), skip, 2005665588UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model, readAttribute){

	zval *attribute, *attribute_value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &attribute);
	
	if (phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC)) {
		PHALCON_OBS_VAR(attribute_value);
		phalcon_read_property_zval(&attribute_value, this_ptr, attribute, PH_NOISY TSRMLS_CC);
		RETURN_CTOR(attribute_value);
	}
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model, writeAttribute){

	zval *attribute, *value;

	phalcon_fetch_params(0, 2, 0, &attribute, &value);
	
	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model, skipAttributes){

	zval *attributes, *replace = NULL, *null_value, *keys_attributes;
	zval *attribute = NULL, *meta_data = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &attributes, &replace);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}

	if (!replace) {
		replace = PHALCON_GLOBAL(z_false);
	}
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, null_value, PH_COPY);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	PHALCON_CALL_METHOD(NULL, meta_data, "setautomaticcreateattributes", this_ptr, keys_attributes, replace);
	PHALCON_CALL_METHOD(NULL, meta_data, "setautomaticupdateattributes", this_ptr, keys_attributes, replace);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnCreate){

	zval *attributes, *replace = NULL, *null_value, *keys_attributes;
	zval *attribute = NULL, *meta_data = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &attributes, &replace);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}

	if (!replace) {
		replace = PHALCON_GLOBAL(z_false);
		ZVAL_FALSE(replace);
	}
	
	null_value = PHALCON_GLOBAL(z_null);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, null_value, PH_COPY);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	PHALCON_CALL_METHOD(NULL, meta_data, "setautomaticcreateattributes", this_ptr, keys_attributes, replace);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, skipAttributesOnUpdate){

	zval *attributes, *replace = NULL, *null_value, *keys_attributes;
	zval *attribute = NULL, *meta_data = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &attributes, &replace);
	
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attributes must be an array");
		return;
	}

	if (!replace) {
		replace = PHALCON_GLOBAL(z_false);
	}
	
	null_value = PHALCON_GLOBAL(z_null);
	
	PHALCON_INIT_VAR(keys_attributes);
	array_init(keys_attributes);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(attribute);
	
		phalcon_array_update_zval(&keys_attributes, attribute, null_value, PH_COPY);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	PHALCON_CALL_METHOD(NULL, meta_data, "setautomaticupdateattributes", this_ptr, keys_attributes, replace);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, hasOne){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 1, &fields, &reference_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(manager, "addhasone", this_ptr, fields, reference_model, referenced_fields, options);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, belongsTo){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 1, &fields, &reference_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(manager, "addbelongsto", this_ptr, fields, reference_model, referenced_fields, options);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, hasMany){

	zval *fields, *reference_model, *referenced_fields;
	zval *options = NULL, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 1, &fields, &reference_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(manager, "addhasmany", this_ptr, fields, reference_model, referenced_fields, options);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, hasManyToMany){

	zval *fields, *intermediate_model, *intermediate_fields;
	zval *intermediate_referenced_fields, *reference_model;
	zval *referenced_fields, *options = NULL, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 6, 1, &fields, &intermediate_model, &intermediate_fields, &intermediate_referenced_fields, &reference_model, &referenced_fields, &options);
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_RETURN_CALL_METHOD(manager, "addhasmanytomany", this_ptr, fields, intermediate_model, intermediate_fields, intermediate_referenced_fields, reference_model, referenced_fields, options ? options : PHALCON_GLOBAL(z_null));
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, addBehavior){

	zval *behavior, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &behavior);
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, manager, "addbehavior", this_ptr, behavior);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, keepSnapshots){

	zval *keep_snapshot, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &keep_snapshot);
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, manager, "keepsnapshots", this_ptr, keep_snapshot);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, setSnapshotData){

	zval *data, *column_map = NULL, *snapshot, *value = NULL, *key = NULL, *exception_message = NULL;
	zval *attribute = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &data, &column_map);
	
	if (!column_map) {
		column_map = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The snapshot data must be an array");
		return;
	}
	
	if (Z_TYPE_P(column_map) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(snapshot);
		array_init(snapshot);
	
		phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);
	
			if (Z_TYPE_P(key) != IS_STRING) {
				zend_hash_move_forward_ex(ah0, &hp0);
				continue;
			}
	
			if (!phalcon_array_isset(column_map, key)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column \"", key, "\" doesn't make part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_NVAR(attribute);
			phalcon_array_fetch(&attribute, column_map, key, PH_NOISY);
			phalcon_array_update_zval(&snapshot, attribute, value, PH_COPY);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_snapshot"), snapshot, 3325604532UL TSRMLS_CC);
		RETURN_MM_NULL();
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_snapshot"), data, 3325604532UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, hasSnapshotData){

	zval *snapshot;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(snapshot);
	phalcon_read_property_this(&snapshot, this_ptr, SL("_snapshot"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(snapshot) == IS_ARRAY) { 
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, getSnapshotData){


	RETURN_MEMBER_QUICK(this_ptr, "_snapshot", 3325604532UL);
}

static PHP_METHOD(Phalcon_Mvc_Model, hasChanged){

	zval *field_name = NULL, *snapshot, *dirty_state, *meta_data = NULL;
	zval *column_map = NULL, *attributes = NULL, *all_attributes = NULL;
	zval *exception_message = NULL, *value = NULL, *original_value = NULL;
	zval *type = NULL, *name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &field_name);
	
	if (!field_name) {
		field_name = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(snapshot);
	phalcon_read_property_this(&snapshot, this_ptr, SL("_snapshot"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(snapshot) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The record doesn't have a valid data snapshot");
		return;
	}
	
	if (Z_TYPE_P(field_name) != IS_STRING) {
		if (Z_TYPE_P(field_name) != IS_NULL) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The field name must be string");
			return;
		}
	}
	
	PHALCON_OBS_VAR(dirty_state);
	phalcon_read_property_this(&dirty_state, this_ptr, SL("_dirtyState"), PH_NOISY TSRMLS_CC);
	
	if (!PHALCON_IS_LONG(dirty_state, 0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Change checking cannot be performed because the object has not been persisted or is deleted");
		return;
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", this_ptr);
	
	if (Z_TYPE_P(column_map) != IS_ARRAY) { 
		PHALCON_CALL_METHOD(&attributes, meta_data, "getdatatypes", this_ptr);
		PHALCON_CPY_WRT(all_attributes, attributes);
	} else {
		PHALCON_CPY_WRT(all_attributes, column_map);
	}
	
	if (Z_TYPE_P(field_name) == IS_STRING) {
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (!phalcon_array_isset(column_map, field_name)) {
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "The field '", field_name, "' is not part of the model");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			if (!phalcon_array_isset(attributes, field_name)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "The field '", field_name, "' is not part of the model");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		}
	
		if (!phalcon_isset_property_zval(this_ptr, field_name TSRMLS_CC)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "The field '", field_name, "' is not defined on the model");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		if (!phalcon_array_isset(snapshot, field_name)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "The field '", field_name, "' was not found in the snapshot");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_OBS_VAR(value);
		phalcon_read_property_zval(&value, this_ptr, field_name, PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(original_value);
		phalcon_array_fetch(&original_value, snapshot, field_name, PH_NOISY);
	
		if (PHALCON_IS_EQUAL(value, original_value)) {
			RETURN_MM_FALSE;
		} else {
			RETURN_MM_TRUE;
		}
	}
	
	phalcon_is_iterable(all_attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah0, hp0);
		PHALCON_GET_HVALUE(type);
	
		if (!phalcon_array_isset(snapshot, name)) {
			RETURN_MM_TRUE;
		}
	
		if (!phalcon_isset_property_zval(this_ptr, name TSRMLS_CC)) {
			RETURN_MM_TRUE;
		}
	
		PHALCON_OBS_NVAR(value);
		phalcon_read_property_zval(&value, this_ptr, name, PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_NVAR(original_value);
		phalcon_array_fetch(&original_value, snapshot, name, PH_NOISY);
	
		if (!PHALCON_IS_EQUAL(value, original_value)) {
			RETURN_MM_TRUE;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, getChangedFields){

	zval *snapshot, *dirty_state, *meta_data = NULL, *column_map = NULL;
	zval *attributes = NULL, *all_attributes = NULL, *changed;
	zval *type = NULL, *name = NULL, *value = NULL, *original_value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(snapshot);
	phalcon_read_property_this(&snapshot, this_ptr, SL("_snapshot"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(snapshot) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The record doesn't have a valid data snapshot");
		return;
	}
	
	PHALCON_OBS_VAR(dirty_state);
	phalcon_read_property_this(&dirty_state, this_ptr, SL("_dirtyState"), PH_NOISY TSRMLS_CC);
	
	if (!PHALCON_IS_LONG(dirty_state, 0)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Change checking cannot be performed because the object has not been persisted or is deleted");
		return;
	}
	
	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", this_ptr);
	
	if (Z_TYPE_P(column_map) != IS_ARRAY) { 
		PHALCON_CALL_METHOD(&attributes, meta_data, "getdatatypes", this_ptr);
		PHALCON_CPY_WRT(all_attributes, attributes);
	} else {
		PHALCON_CPY_WRT(all_attributes, column_map);
	}
	
	PHALCON_INIT_VAR(changed);
	array_init(changed);
	
	phalcon_is_iterable(all_attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(name, ah0, hp0);
		PHALCON_GET_HVALUE(type);
	
		if (!phalcon_array_isset(snapshot, name)) {
			phalcon_array_append(&changed, name, PH_SEPARATE);
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}
	
		if (!phalcon_isset_property_zval(this_ptr, name TSRMLS_CC)) {
			phalcon_array_append(&changed, name, PH_SEPARATE);
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}
	
		PHALCON_OBS_NVAR(value);
		phalcon_read_property_zval(&value, this_ptr, name, PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_NVAR(original_value);
		phalcon_array_fetch(&original_value, snapshot, name, PH_NOISY);
	
		if (!PHALCON_IS_EQUAL(value, original_value)) {
			phalcon_array_append(&changed, name, PH_SEPARATE);
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(changed);
}

static PHP_METHOD(Phalcon_Mvc_Model, useDynamicUpdate){

	zval *dynamic_update, *manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &dynamic_update);
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, manager, "usedynamicupdate", this_ptr, dynamic_update);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, getRelated){

	zval *alias, *arguments = NULL, *manager, *class_name;
	zval *relation = NULL, *exception_message, *call_object;
	zval *model_args;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &alias, &arguments);
	
	if (!arguments) {
		arguments = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", class_name, alias);
	if (Z_TYPE_P(relation) != IS_OBJECT) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVSVS(exception_message, "There is no defined relations for the model \"", class_name, "\" using alias \"", alias, "\"");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(call_object);
	array_init_size(call_object, 2);
	phalcon_array_append(&call_object, manager, PH_SEPARATE);
	add_next_index_stringl(call_object, SL("getRelationRecords"), 1);
	
	PHALCON_INIT_VAR(model_args);
	array_init_size(model_args, 4);
	phalcon_array_append(&model_args, relation, PH_SEPARATE);
	add_next_index_null(model_args);
	phalcon_array_append(&model_args, this_ptr, PH_SEPARATE);
	phalcon_array_append(&model_args, arguments, PH_SEPARATE);
	PHALCON_CALL_USER_FUNC_ARRAY(return_value, call_object, model_args);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, _getRelatedRecords){

	zval *model_name, *method, *arguments, *manager;
	zval *relation = NULL, *query_method = NULL, *alias = NULL, *extra_args = NULL;
	zval *call_args, *call_object;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &model_name, &method, &arguments);
	
	PHALCON_OBS_VAR(manager);
	phalcon_read_property_this(&manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(relation);
	ZVAL_BOOL(relation, 0);
	
	PHALCON_INIT_VAR(query_method);
	
	if (phalcon_start_with_str(method, SL("get"))) {
		PHALCON_INIT_VAR(alias);
		phalcon_substr(alias, method, 3, 0);
	
		PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", model_name, alias);
	}
	
	if (Z_TYPE_P(relation) != IS_OBJECT) {
		if (phalcon_start_with_str(method, SL("count"))) {
			ZVAL_STRING(query_method, "count", 1);
	
			PHALCON_INIT_NVAR(alias);
			phalcon_substr(alias, method, 5, 0);
	
			PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", model_name, alias);
		}
	}
	
	if (Z_TYPE_P(relation) == IS_OBJECT) {
		if (phalcon_array_isset_long(arguments, 0)) {
			PHALCON_OBS_VAR(extra_args);
			phalcon_array_fetch_long(&extra_args, arguments, 0, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(extra_args);
		}
	
		PHALCON_INIT_VAR(call_args);
		array_init_size(call_args, 4);
		phalcon_array_append(&call_args, relation, PH_SEPARATE);
		phalcon_array_append(&call_args, query_method, PH_SEPARATE);
		phalcon_array_append(&call_args, this_ptr, PH_SEPARATE);
		phalcon_array_append(&call_args, extra_args, PH_SEPARATE);
	
		PHALCON_INIT_VAR(call_object);
		array_init_size(call_object, 2);
		phalcon_array_append(&call_object, manager, PH_SEPARATE);
		add_next_index_stringl(call_object, SL("getRelationRecords"), 1);
		PHALCON_CALL_USER_FUNC_ARRAY(return_value, call_object, call_args);
		RETURN_MM();
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model, __call){

	zval *method, *arguments = NULL, *model_name, *records = NULL;
	zval *models_manager, *status = NULL, *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &method, &arguments);
	
	if (!arguments) {
		PHALCON_INIT_VAR(arguments);
		array_init(arguments);
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&records, this_ptr, "_getrelatedrecords", model_name, method, arguments);
	if (Z_TYPE_P(records) != IS_NULL) {
		RETURN_CTOR(records);
	}
	
	PHALCON_OBS_VAR(models_manager);
	phalcon_read_property_this(&models_manager, this_ptr, SL("_modelsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&status, models_manager, "missingmethod", this_ptr, method, arguments);
	if (Z_TYPE_P(status) != IS_NULL) {
		RETURN_CTOR(status);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVSVS(exception_message, "The method \"", method, "\" doesn't exist on model \"", model_name, "\"");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model, __callStatic){

	zval *method, *arguments = NULL, *extra_method = NULL;
	zval *model_name, *exception_message = NULL, *value;
	zval *model, *meta_data = NULL, *attributes = NULL, *field = NULL, *extra_method_first;
	zval *conditions, *bind_params, *parameters;
	zend_class_entry *ce0;
	const char *type;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &method, &arguments);
	
	if (!arguments) {
		arguments = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(extra_method);
	
	if (phalcon_start_with_str(method, SL("findFirstBy"))) {
		type = "findfirst";
		phalcon_substr(extra_method, method, 11, 0);
	}
	
	if (Z_TYPE_P(extra_method) == IS_NULL) {
		if (phalcon_start_with_str(method, SL("findBy"))) {
			type = "find";
			phalcon_substr(extra_method, method, 6, 0);
		}
	}
	
	if (Z_TYPE_P(extra_method) == IS_NULL) {
		if (phalcon_start_with_str(method, SL("countBy"))) {
			type = "count";
			phalcon_substr(extra_method, method, 7, 0);
		}
	}
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_called_class(model_name  TSRMLS_CC);
	if (!zend_is_true(extra_method)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVSVS(exception_message, "The static method \"", method, "\" doesn't exist on model \"", model_name, "\"");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	if (!phalcon_array_isset_long(arguments, 0)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "The static method \"", method, "\" requires one argument");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_OBS_VAR(value);
	phalcon_array_fetch_long(&value, arguments, 0, PH_NOISY);
	ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
	
	PHALCON_INIT_VAR(model);
	object_init_ex(model, ce0);
	if (phalcon_has_constructor(model TSRMLS_CC)) {
		PHALCON_CALL_METHOD(NULL, model, "__construct");
	}
	
	PHALCON_CALL_METHOD(&meta_data, model, "getmodelsmetadata");
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getreversecolumnmap", model);
	if (Z_TYPE_P(attributes) != IS_ARRAY) { 
		PHALCON_CALL_METHOD(&attributes, meta_data, "getdatatypes", model);
	}
	
	if (phalcon_array_isset(attributes, extra_method)) {
		PHALCON_CPY_WRT(field, extra_method);
	} else {
		PHALCON_INIT_VAR(extra_method_first);
		phalcon_lcfirst(extra_method_first, extra_method);
		if (phalcon_array_isset(attributes, extra_method_first)) {
			PHALCON_CPY_WRT(field, extra_method_first);
		} else {
			PHALCON_INIT_NVAR(field);
			phalcon_uncamelize(field, extra_method);
			if (!phalcon_array_isset(attributes, field)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Cannot resolve attribute \"", extra_method, "' in the model");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		}
	}
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VS(conditions, field, " = ?0");
	
	PHALCON_INIT_VAR(bind_params);
	array_init_size(bind_params, 1);
	phalcon_array_append(&bind_params, value, 0);
	
	PHALCON_INIT_VAR(parameters);
	array_init_size(parameters, 2);
	phalcon_array_update_string(&parameters, ISL(conditions), conditions, PH_COPY);
	phalcon_array_update_string(&parameters, SL("bind"), bind_params, PH_COPY);
	
	PHALCON_RETURN_CALL_CE_STATIC(ce0, type, parameters);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, __set){

	zval *property, *value, *lower_property = NULL;
	zval *meta_data = NULL, *column_map = NULL, *attributes = NULL;
	zval *related, *key = NULL, *lower_key = NULL, *item = NULL, *model_name, *manager = NULL;
	zval *relation = NULL, *referenced_model_name = NULL, *referenced_model = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int i = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &property, &value);

	if (Z_TYPE_P(property) == IS_STRING) {
		PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
		PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", this_ptr);
		if (Z_TYPE_P(column_map) != IS_ARRAY) {
			PHALCON_CALL_METHOD(&attributes, meta_data, "getdatatypes", this_ptr);

			if (phalcon_array_isset(attributes, property)) {
				phalcon_update_property_zval_zval(this_ptr, property, value TSRMLS_CC);
				RETURN_CTOR(value);
			}
		} else {
			if (phalcon_array_isset(column_map, property)) {
				phalcon_update_property_zval_zval(this_ptr, property, value TSRMLS_CC);
				RETURN_CTOR(value);
			}
		}
	}
	
	if (Z_TYPE_P(value) == IS_OBJECT) {
	
		if (instanceof_function_ex(Z_OBJCE_P(value), phalcon_mvc_modelinterface_ce, 1 TSRMLS_CC)) {
			PHALCON_INIT_VAR(lower_property);
			phalcon_fast_strtolower(lower_property, property);
			phalcon_update_property_zval_zval(this_ptr, lower_property, value TSRMLS_CC);
			phalcon_update_property_array(this_ptr, SL("_related"), lower_property, value TSRMLS_CC);
			phalcon_update_property_long(this_ptr, SL("_dirtyState"), 1 TSRMLS_CC);
			RETURN_CTOR(value);
		}
	}
	
	if (Z_TYPE_P(value) == IS_ARRAY) {
		PHALCON_INIT_VAR(related);
		array_init(related);

		PHALCON_INIT_VAR(lower_property);
		phalcon_fast_strtolower(lower_property, property);

		PHALCON_INIT_VAR(model_name);
		phalcon_get_class(model_name, this_ptr, 0 TSRMLS_CC);
		
		PHALCON_CALL_METHOD(&manager, this_ptr, "getmodelsmanager");

		phalcon_is_iterable(value, &ah0, &hp0, 0, 0);
		
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
		
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(item);

			if (Z_TYPE_P(item) == IS_OBJECT) {
				if (instanceof_function_ex(Z_OBJCE_P(item), phalcon_mvc_modelinterface_ce, 1 TSRMLS_CC)) {
					i++;
					phalcon_array_append(&related, item, 0);
				}
			} else if (Z_TYPE_P(key) == IS_STRING) {
				PHALCON_INIT_NVAR(lower_key);
				phalcon_fast_strtolower(lower_key, key);

				phalcon_update_property_zval_zval(this_ptr, lower_key, item TSRMLS_CC);

				PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", model_name, lower_property);
				if (Z_TYPE_P(relation) == IS_OBJECT) {
					PHALCON_CALL_METHOD(&referenced_model_name, relation, "getreferencedmodel");
					PHALCON_CALL_METHOD(&referenced_model, manager, "load", referenced_model_name, PHALCON_GLOBAL(z_false));
					PHALCON_CALL_METHOD(NULL, referenced_model, "writeattribute", lower_key, item);	
				}
			}

			zend_hash_move_forward_ex(ah0, &hp0);
		}

		if (i > 0) {
			phalcon_update_property_zval_zval(this_ptr, lower_property, related TSRMLS_CC);
			phalcon_update_property_array(this_ptr, SL("_related"), lower_property, related TSRMLS_CC);
			phalcon_update_property_long(this_ptr, SL("_dirtyState"), 1 TSRMLS_CC);
		}

		RETURN_CTOR(value);
	}
	
	phalcon_update_property_zval_zval(this_ptr, property, value TSRMLS_CC);
	
	RETURN_CTOR(value);
}

static PHP_METHOD(Phalcon_Mvc_Model, __get){

	zval *property, *model_name, *manager = NULL, *lower_property;
	zval *relation = NULL, *call_args, *call_object, *result;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &property);
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&manager, this_ptr, "getmodelsmanager");
	
	PHALCON_INIT_VAR(lower_property);
	phalcon_fast_strtolower(lower_property, property);
	
	PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", model_name, lower_property);
	if (Z_TYPE_P(relation) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(call_args);
		array_init_size(call_args, 4);
		phalcon_array_append(&call_args, relation, 0);
		add_next_index_null(call_args);
		phalcon_array_append(&call_args, this_ptr, 0);
		add_next_index_null(call_args);
	
		PHALCON_INIT_VAR(call_object);
		array_init_size(call_object, 2);
		phalcon_array_append(&call_object, manager, 0);
		add_next_index_stringl(call_object, SL("getRelationRecords"), 1);
	
		PHALCON_INIT_VAR(result);/**/
		PHALCON_CALL_USER_FUNC_ARRAY(result, call_object, call_args);
	
		if (Z_TYPE_P(result) == IS_OBJECT) {
	
			phalcon_update_property_zval_zval(this_ptr, lower_property, result TSRMLS_CC);
	
			if (instanceof_function_ex(Z_OBJCE_P(result), phalcon_mvc_modelinterface_ce, 1 TSRMLS_CC)) {
				phalcon_update_property_array(this_ptr, SL("_related"), lower_property, result TSRMLS_CC);
			}
		}
	
		RETURN_CTOR(result);
	}
	
	/* TODO see if segfault is possible */
	zend_error(E_NOTICE, "Access to undefined property %s::%s", Z_STRVAL_P(model_name), Z_STRVAL_P(property));
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model, __isset){

	zval *property, *model_name, *manager = NULL, *relation = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &property);
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, this_ptr, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&manager, this_ptr, "getmodelsmanager");
	
	PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", model_name, property);
	if (Z_TYPE_P(relation) == IS_OBJECT) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model, serialize){

	zval *meta_data = NULL, *attributes = NULL, *null_value, *data;
	zval *attribute = NULL, *value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(attribute);
	
		if (phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC)) {
			PHALCON_OBS_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, attribute, PH_NOISY TSRMLS_CC);
			phalcon_array_update_zval(&data, attribute, value, PH_COPY);
		} else {
			phalcon_array_update_zval(&data, attribute, null_value, PH_COPY);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_serialize(return_value, &data TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model, unserialize){

	zval *data, *attributes, *dependency_injector = NULL;
	zval *service, *manager = NULL, *value = NULL, *key = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	if (Z_TYPE_P(data) == IS_STRING) {
	
		PHALCON_INIT_VAR(attributes);
		phalcon_unserialize(attributes, data TSRMLS_CC);
		if (Z_TYPE_P(attributes) == IS_ARRAY) { 
	
			PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
	
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
				return;
			}
	
			phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	
			PHALCON_INIT_VAR(service);
			ZVAL_STRING(service, "modelsManager", 1);
	
			PHALCON_CALL_METHOD(&manager, dependency_injector, "getshared", service);
			if (Z_TYPE_P(manager) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The injected service 'modelsManager' is not valid");
				return;
			}

			PHALCON_VERIFY_INTERFACE(manager, phalcon_mvc_model_managerinterface_ce);
	
			phalcon_update_property_this_quick(this_ptr, SL("_modelsManager"), manager, 3699347875UL TSRMLS_CC);
	
			PHALCON_CALL_METHOD(NULL, manager, "initialize", this_ptr);
	
			phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(key, ah0, hp0);
				PHALCON_GET_HVALUE(value);
	
				phalcon_update_property_zval_zval(this_ptr, key, value TSRMLS_CC);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			RETURN_MM_NULL();
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model, dump){

	PHALCON_RETURN_CALL_FUNCTIONW("get_object_vars", this_ptr);
}

static PHP_METHOD(Phalcon_Mvc_Model, toArray){

	zval *columns = NULL, *meta_data = NULL, *data, *null_value, *attributes = NULL;
	zval *column_map = NULL, *attribute = NULL, *exception_message = NULL;
	zval *attribute_field = NULL, *value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &columns);

	PHALCON_CALL_METHOD(&meta_data, this_ptr, "getmodelsmetadata");
	
	PHALCON_INIT_VAR(data);
	array_init(data);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", this_ptr);
	
	PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", this_ptr);
	
	phalcon_is_iterable(attributes, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(attribute);

		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (!phalcon_array_isset(column_map, attribute)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column \"", attribute, "\" doesn't make part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_NVAR(attribute_field);
			phalcon_array_fetch(&attribute_field, column_map, attribute, PH_NOISY);
		} else {
			PHALCON_CPY_WRT(attribute_field, attribute);
		}

		if (columns && Z_TYPE_P(columns) == IS_ARRAY) {
			if (!phalcon_fast_in_array(attribute_field, columns TSRMLS_CC) && !phalcon_fast_in_array(attribute, columns TSRMLS_CC)) {
				zend_hash_move_forward_ex(ah0, &hp0);
				continue;
			}
		}

		if (phalcon_isset_property_zval(this_ptr, attribute_field TSRMLS_CC)) {
			PHALCON_OBS_NVAR(value);
			phalcon_read_property_zval(&value, this_ptr, attribute_field, PH_NOISY TSRMLS_CC);
			phalcon_array_update_zval(&data, attribute_field, value, PH_COPY);
		} else {
			phalcon_array_update_zval(&data, attribute_field, null_value, PH_COPY);
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model, setup){

	zval *options, *disable_events, *virtual_foreign_keys;
	zval *column_renaming, *not_null_validations;
	zval *exception_on_failed_save, *phql_literals;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Options must be an array");
		return;
	}
	
	if (phalcon_array_isset_quick_string(options, SS("events"), 2099005594UL)) {
		PHALCON_OBS_VAR(disable_events);
		phalcon_array_fetch_quick_string(&disable_events, options, SS("events"), 2099005594UL, PH_NOISY);
		PHALCON_GLOBAL(orm).events = zend_is_true(disable_events);
	}
	
	if (phalcon_array_isset_quick_string(options, SS("virtualForeignKeys"), 3101162738UL)) {
		PHALCON_OBS_VAR(virtual_foreign_keys);
		phalcon_array_fetch_quick_string(&virtual_foreign_keys, options, SS("virtualForeignKeys"), 3101162738UL, PH_NOISY);
		PHALCON_GLOBAL(orm).virtual_foreign_keys = zend_is_true(virtual_foreign_keys);
	}
	
	if (phalcon_array_isset_quick_string(options, SS("columnRenaming"), 1384279140UL)) {
		PHALCON_OBS_VAR(column_renaming);
		phalcon_array_fetch_quick_string(&column_renaming, options, SS("columnRenaming"), 1384279140UL, PH_NOISY);
		PHALCON_GLOBAL(orm).column_renaming = zend_is_true(column_renaming);
	}
	
	if (phalcon_array_isset_quick_string(options, SS("notNullValidations"), 3404663535UL)) {
		PHALCON_OBS_VAR(not_null_validations);
		phalcon_array_fetch_quick_string(&not_null_validations, options, SS("notNullValidations"), 3404663535UL, PH_NOISY);
		PHALCON_GLOBAL(orm).not_null_validations = zend_is_true(not_null_validations);
	}
	
	if (phalcon_array_isset_quick_string(options, SS("exceptionOnFailedSave"), 2203913893UL)) {
		PHALCON_OBS_VAR(exception_on_failed_save);
		phalcon_array_fetch_quick_string(&exception_on_failed_save, options, SS("exceptionOnFailedSave"), 2203913893UL, PH_NOISY);
		PHALCON_GLOBAL(orm).exception_on_failed_save = zend_is_true(exception_on_failed_save);
	}
	
	if (phalcon_array_isset_quick_string(options, SS("phqlLiterals"), 3976399002UL)) {
		PHALCON_OBS_VAR(phql_literals);
		phalcon_array_fetch_quick_string(&phql_literals, options, SS("phqlLiterals"), 3976399002UL, PH_NOISY);
		PHALCON_GLOBAL(orm).enable_literals = zend_is_true(phql_literals);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model, reset){

	phalcon_update_property_null(this_ptr, SL("_uniqueParams") TSRMLS_CC);
	phalcon_update_property_null(this_ptr, SL("_snapshot") TSRMLS_CC);
}





zend_class_entry *phalcon_mvc_modelinterface_ce;

static const zend_function_entry phalcon_mvc_modelinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, setTransaction, arginfo_phalcon_mvc_modelinterface_settransaction)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getSource, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getSchema, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, setConnectionService, arginfo_phalcon_mvc_modelinterface_setconnectionservice)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, setWriteConnectionService, arginfo_phalcon_mvc_modelinterface_setwriteconnectionservice)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, setReadConnectionService, arginfo_phalcon_mvc_modelinterface_setreadconnectionservice)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getReadConnectionService, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getWriteConnectionService, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getReadConnection, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getWriteConnection, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, assign, arginfo_phalcon_mvc_modelinterface_assign)
	ZEND_FENTRY(cloneResultMap, NULL, arginfo_phalcon_mvc_modelinterface_cloneresultmap, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(cloneResult, NULL, arginfo_phalcon_mvc_modelinterface_cloneresult, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(cloneResultMapHydrate, NULL, arginfo_phalcon_mvc_modelinterface_cloneresultmaphydrate, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(find, NULL, arginfo_phalcon_mvc_modelinterface_find, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(findFirst, NULL, arginfo_phalcon_mvc_modelinterface_findfirst, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(query, NULL, arginfo_phalcon_mvc_modelinterface_query, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(count, NULL, arginfo_phalcon_mvc_modelinterface_count, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(sum, NULL, arginfo_phalcon_mvc_modelinterface_sum, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(maximum, NULL, arginfo_phalcon_mvc_modelinterface_maximum, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(minimum, NULL, arginfo_phalcon_mvc_modelinterface_minimum, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	ZEND_FENTRY(average, NULL, arginfo_phalcon_mvc_modelinterface_average, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, fireEvent, arginfo_phalcon_mvc_modelinterface_fireevent)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, fireEventCancel, arginfo_phalcon_mvc_modelinterface_fireeventcancel)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, appendMessage, arginfo_phalcon_mvc_modelinterface_appendmessage)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, validationHasFailed, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getMessages, arginfo_phalcon_mvc_modelinterface_getmessages)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, save, arginfo_phalcon_mvc_modelinterface_save)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, create, arginfo_phalcon_mvc_modelinterface_create)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, update, arginfo_phalcon_mvc_modelinterface_update)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, delete, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getOperationMade, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, refresh, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, readAttribute, arginfo_phalcon_mvc_modelinterface_readattribute)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, writeAttribute, arginfo_phalcon_mvc_modelinterface_writeattribute)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, getRelated, arginfo_phalcon_mvc_modelinterface_getrelated)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModelInterface, reset, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_ModelInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ModelInterface, mvc_modelinterface, phalcon_mvc_modelinterface_method_entry);

	return SUCCESS;
}










































zend_class_entry *phalcon_mvc_moduledefinitioninterface_ce;

static const zend_function_entry phalcon_mvc_moduledefinitioninterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModuleDefinitionInterface, registerAutoloaders, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ModuleDefinitionInterface, registerServices, arginfo_phalcon_mvc_moduledefinitioninterface_registerservices)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Mvc_ModuleDefinitionInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ModuleDefinitionInterface, mvc_moduledefinitioninterface, phalcon_mvc_moduledefinitioninterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_mvc_router_ce;

static PHP_METHOD(Phalcon_Mvc_Router, __construct);
static PHP_METHOD(Phalcon_Mvc_Router, setDI);
static PHP_METHOD(Phalcon_Mvc_Router, getDI);
static PHP_METHOD(Phalcon_Mvc_Router, getRewriteUri);
static PHP_METHOD(Phalcon_Mvc_Router, setUriSource);
static PHP_METHOD(Phalcon_Mvc_Router, removeExtraSlashes);
static PHP_METHOD(Phalcon_Mvc_Router, setDefaultNamespace);
static PHP_METHOD(Phalcon_Mvc_Router, getDefaultNamespace);
static PHP_METHOD(Phalcon_Mvc_Router, setDefaultModule);
static PHP_METHOD(Phalcon_Mvc_Router, getDefaultModule);
static PHP_METHOD(Phalcon_Mvc_Router, setDefaultController);
static PHP_METHOD(Phalcon_Mvc_Router, getDefaultController);
static PHP_METHOD(Phalcon_Mvc_Router, setDefaultAction);
static PHP_METHOD(Phalcon_Mvc_Router, getDefaultAction);
static PHP_METHOD(Phalcon_Mvc_Router, setDefaults);
static PHP_METHOD(Phalcon_Mvc_Router, getDefaults);
static PHP_METHOD(Phalcon_Mvc_Router, handle);
static PHP_METHOD(Phalcon_Mvc_Router, add);
static PHP_METHOD(Phalcon_Mvc_Router, addGet);
static PHP_METHOD(Phalcon_Mvc_Router, addPost);
static PHP_METHOD(Phalcon_Mvc_Router, addPut);
static PHP_METHOD(Phalcon_Mvc_Router, addPatch);
static PHP_METHOD(Phalcon_Mvc_Router, addDelete);
static PHP_METHOD(Phalcon_Mvc_Router, addOptions);
static PHP_METHOD(Phalcon_Mvc_Router, addHead);
static PHP_METHOD(Phalcon_Mvc_Router, mount);
static PHP_METHOD(Phalcon_Mvc_Router, notFound);
static PHP_METHOD(Phalcon_Mvc_Router, clear);
static PHP_METHOD(Phalcon_Mvc_Router, getNamespaceName);
static PHP_METHOD(Phalcon_Mvc_Router, getModuleName);
static PHP_METHOD(Phalcon_Mvc_Router, getControllerName);
static PHP_METHOD(Phalcon_Mvc_Router, getActionName);
static PHP_METHOD(Phalcon_Mvc_Router, getParams);
static PHP_METHOD(Phalcon_Mvc_Router, getMatchedRoute);
static PHP_METHOD(Phalcon_Mvc_Router, getMatches);
static PHP_METHOD(Phalcon_Mvc_Router, wasMatched);
static PHP_METHOD(Phalcon_Mvc_Router, getRoutes);
static PHP_METHOD(Phalcon_Mvc_Router, getRouteById);
static PHP_METHOD(Phalcon_Mvc_Router, getRouteByName);
static PHP_METHOD(Phalcon_Mvc_Router, isExactControllerName);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, defaultRoutes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_seturisource, 0, 0, 1)
	ZEND_ARG_INFO(0, uriSource)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_removeextraslashes, 0, 0, 1)
	ZEND_ARG_INFO(0, remove)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_setdefaultnamespace, 0, 0, 1)
	ZEND_ARG_INFO(0, namespaceName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_mount, 0, 0, 1)
	ZEND_ARG_INFO(0, group)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_notfound, 0, 0, 1)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_router_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Router, __construct, arginfo_phalcon_mvc_router___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Router, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getRewriteUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setUriSource, arginfo_phalcon_mvc_router_seturisource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, removeExtraSlashes, arginfo_phalcon_mvc_router_removeextraslashes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setDefaultNamespace, arginfo_phalcon_mvc_router_setdefaultnamespace, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDefaultNamespace, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setDefaultModule, arginfo_phalcon_mvc_routerinterface_setdefaultmodule, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDefaultModule, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setDefaultController, arginfo_phalcon_mvc_routerinterface_setdefaultcontroller, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDefaultController, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setDefaultAction, arginfo_phalcon_mvc_routerinterface_setdefaultaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDefaultAction, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, setDefaults, arginfo_phalcon_mvc_routerinterface_setdefaults, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getDefaults, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, handle, arginfo_phalcon_mvc_routerinterface_handle, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, add, arginfo_phalcon_mvc_routerinterface_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addGet, arginfo_phalcon_mvc_routerinterface_addget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addPost, arginfo_phalcon_mvc_routerinterface_addpost, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addPut, arginfo_phalcon_mvc_routerinterface_addput, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addPatch, arginfo_phalcon_mvc_routerinterface_addpatch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addDelete, arginfo_phalcon_mvc_routerinterface_adddelete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addOptions, arginfo_phalcon_mvc_routerinterface_addoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, addHead, arginfo_phalcon_mvc_routerinterface_addhead, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, mount, arginfo_phalcon_mvc_router_mount, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, notFound, arginfo_phalcon_mvc_router_notfound, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, clear, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getNamespaceName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getModuleName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getControllerName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getActionName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getParams, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getMatchedRoute, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getMatches, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, wasMatched, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getRoutes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getRouteById, arginfo_phalcon_mvc_routerinterface_getroutebyid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, getRouteByName, arginfo_phalcon_mvc_routerinterface_getroutebyname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router, isExactControllerName, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Router){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Router, mvc_router, phalcon_mvc_router_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_uriSource"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_namespace"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_module"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_controller"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_action"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_routes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_routesNameLookup"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_matchedRoute"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_matches"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_router_ce, SL("_wasMatched"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultNamespace"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultModule"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultController"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultAction"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_defaultParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_removeExtraSlashes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_ce, SL("_notFoundPaths"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_router_ce, SL("_isExactControllerName"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_router_ce, SL("URI_SOURCE_GET_URL"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_router_ce, SL("URI_SOURCE_SERVER_REQUEST_URI"), 1 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_router_ce TSRMLS_CC, 2, phalcon_mvc_routerinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Router, __construct){

	zval *default_routes = NULL, *routes, *paths = NULL, *action_pattern;
	zval *route = NULL, *params_pattern;

	PHALCON_MM_GROW();

	phalcon_update_property_empty_array(this_ptr, SL("_defaultParams") TSRMLS_CC);

	phalcon_fetch_params(1, 0, 1, &default_routes);

	if (!default_routes) {
		default_routes = PHALCON_GLOBAL(z_true);
	}

	PHALCON_INIT_VAR(routes);
	array_init(routes);
	if (PHALCON_IS_TRUE(default_routes)) {

		PHALCON_INIT_VAR(paths);
		array_init_size(paths, 1);
		add_assoc_long_ex(paths, ISS(controller), 1);

		PHALCON_INIT_VAR(action_pattern);
		ZVAL_STRING(action_pattern, "#^/([a-zA-Z0-9_-]++)/?+$#", 1);

		PHALCON_INIT_VAR(route);
		object_init_ex(route, phalcon_mvc_router_route_ce);
		PHALCON_CALL_METHOD(NULL, route, "__construct", action_pattern, paths);

		phalcon_array_append(&routes, route, 0);

		PHALCON_INIT_NVAR(paths);
		array_init_size(paths, 3);
		add_assoc_long_ex(paths, ISS(controller), 1);
		add_assoc_long_ex(paths, ISS(action), 2);
		add_assoc_long_ex(paths, ISS(params), 3);

		PHALCON_INIT_VAR(params_pattern);
		ZVAL_STRING(params_pattern, "#^/([a-zA-Z0-9_-]++)/([a-zA-Z0-9\\._]++)(/.*+)?+$#", 1);

		PHALCON_INIT_NVAR(route);
		object_init_ex(route, phalcon_mvc_router_route_ce);
		PHALCON_CALL_METHOD(NULL, route, "__construct", params_pattern, paths);

		phalcon_array_append(&routes, route, 0);
	}

	phalcon_update_property_empty_array(this_ptr, SL("_params") TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_routes"), routes, 2063827110UL TSRMLS_CC);
	phalcon_update_property_empty_array(this_ptr, SL("_routesNameLookup") TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_router_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Router, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getRewriteUri){

	zval *uri_source, *_GET, *url = NULL, *_SERVER, *url_parts;
	zval *real_uri;

	uri_source = phalcon_fetch_nproperty_this(this_ptr, SL("_uriSource"), PH_NOISY TSRMLS_CC);

	if (!zend_is_true(uri_source)) { /* FIXME: Compare with URI_SOURCE_SERVER_REQUEST_URI */
		_GET = phalcon_get_global(SS("_GET") TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&url, _GET, SS("_url"))) {
			if (PHALCON_IS_NOT_EMPTY(url)) {
				RETURN_ZVAL(url, 1, 0);
			}
		}
	} else {
		_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&url, _SERVER, SS("REQUEST_URI"))) {
			ALLOC_INIT_ZVAL(url_parts);
			phalcon_fast_explode_str(url_parts, SL("?"), url);

			phalcon_array_fetch_long(&real_uri, url_parts, 0, PH_NOISY);
			zval_ptr_dtor(&url_parts);
			if (PHALCON_IS_NOT_EMPTY(real_uri)) {
				RETURN_ZVAL(real_uri, 1, 1);
			}

			zval_ptr_dtor(&real_uri);
		}
	}

	RETURN_STRING("/", 1);
}

static PHP_METHOD(Phalcon_Mvc_Router, setUriSource){

	zval *uri_source;

	phalcon_fetch_params(0, 1, 0, &uri_source);

	phalcon_update_property_this_quick(this_ptr, SL("_uriSource"), uri_source, 144947845UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, removeExtraSlashes){

	zval *remove;

	phalcon_fetch_params(0, 1, 0, &remove);

	phalcon_update_property_this_quick(this_ptr, SL("_removeExtraSlashes"), remove, 1065444329UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, setDefaultNamespace){

	zval *namespace_name;

	phalcon_fetch_params(0, 1, 0, &namespace_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultNamespace"), namespace_name, 761145590UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, getDefaultNamespace){

	RETURN_MEMBER_QUICK(this_ptr, "_defaultNamespace", 761145590UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, setDefaultModule){

	zval *module_name;

	phalcon_fetch_params(0, 1, 0, &module_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultModule"), module_name, 3959488399UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, getDefaultModule){

	RETURN_MEMBER_QUICK(this_ptr, "_defaultModule", 3959488399UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, setDefaultController){

	zval *controller_name;

	phalcon_fetch_params(0, 1, 0, &controller_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultController"), controller_name, 1418722861UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, getDefaultController){

	RETURN_MEMBER_QUICK(this_ptr, "_defaultController", 1418722861UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, setDefaultAction){

	zval *action_name;

	phalcon_fetch_params(0, 1, 0, &action_name);

	phalcon_update_property_this_quick(this_ptr, SL("_defaultAction"), action_name, 895696999UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, getDefaultAction){

	RETURN_MEMBER_QUICK(this_ptr, "_defaultAction", 895696999UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, setDefaults){

	zval *defaults, *namespace_name, *module_name;
	zval *controller_name, *action_name, *params;

	phalcon_fetch_params(0, 1, 0, &defaults);

	if (Z_TYPE_P(defaults) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_router_exception_ce, "Defaults must be an array");
		return;
	}

	/* Set the default namespace */
	if (phalcon_array_isset_string_fetch(&namespace_name, defaults, SS("namespace"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_defaultNamespace"), namespace_name, 761145590UL TSRMLS_CC);
	}

	/* Set the default module */
	if (phalcon_array_isset_string_fetch(&module_name, defaults, SS("module"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_defaultModule"), module_name, 3959488399UL TSRMLS_CC);
	}

	/* Set the default controller */
	if (phalcon_array_isset_string_fetch(&controller_name, defaults, SS("controller"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_defaultController"), controller_name, 1418722861UL TSRMLS_CC);
	}

	/* Set the default action */
	if (phalcon_array_isset_string_fetch(&action_name, defaults, SS("action"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_defaultAction"), action_name, 895696999UL TSRMLS_CC);
	}

	/* Set default parameters */
	if (phalcon_array_isset_string_fetch(&params, defaults, SS("params"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_defaultParams"), params, 3006915213UL TSRMLS_CC);
	}

	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, getDefaults){

	zval *namespace_name, *module_name;
	zval *controller_name, *action_name, *params;

	namespace_name  = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultNamespace"), PH_NOISY TSRMLS_CC);
	module_name     = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultModule"), PH_NOISY TSRMLS_CC);
	controller_name = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultController"), PH_NOISY TSRMLS_CC);
	action_name     = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAction"), PH_NOISY TSRMLS_CC);
	params          = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultParams"), PH_NOISY TSRMLS_CC);

	array_init_size(return_value, 5);

	phalcon_array_update_string(&return_value, ISL(namespace),  namespace_name,  PH_COPY);
	phalcon_array_update_string(&return_value, ISL(module),     module_name,     PH_COPY);
	phalcon_array_update_string(&return_value, ISL(controller), controller_name, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(action),     action_name,     PH_COPY);
	phalcon_array_update_string(&return_value, ISL(params),     params,          PH_COPY);
}

static PHP_METHOD(Phalcon_Mvc_Router, handle){

	zval *uri = NULL, *real_uri = NULL;
	zval *handled_uri = NULL, *request = NULL, *current_host_name = NULL;
	zval *route_found = NULL, *parts = NULL, *params = NULL, *matches, *routes;
	zval *route = NULL, *methods = NULL;
	zval *service, *match_method = NULL, *hostname = NULL, *regex_host_name = NULL;
	zval *matched = NULL, *pattern = NULL, *before_match = NULL, *before_match_params = NULL;
	zval *paths = NULL, *converters = NULL, *position = NULL, *part = NULL;
	zval *parameters = NULL, *converted_part = NULL;
	zval *namespace, *module, *controller;
	zval *action, *params_str, *str_params;
	zval *params_merge = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	zval *dependency_injector, *tmp;
	zval *match_position = NULL, *converter = NULL;
	zval *exact = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &uri);

	if (!uri || !zend_is_true(uri)) {
		PHALCON_CALL_METHOD(&real_uri, this_ptr, "getrewriteuri");
	} else {
		real_uri = uri;
	}

	tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_removeExtraSlashes"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(tmp)) {
		PHALCON_INIT_VAR(handled_uri);
		phalcon_remove_extra_slashes(handled_uri, real_uri);
	} else {
		handled_uri = real_uri;
	}

	PHALCON_INIT_VAR(current_host_name);

	PHALCON_INIT_VAR(route_found);
	ZVAL_FALSE(route_found);

	PHALCON_INIT_VAR(parts);
	array_init(parts);

	PHALCON_INIT_VAR(params);
	array_init(params);

	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_request);

	PHALCON_INIT_VAR(matches);
	phalcon_update_property_bool(this_ptr, SL("_wasMatched"), 0 TSRMLS_CC);
	phalcon_update_property_null(this_ptr, SL("_matchedRoute") TSRMLS_CC);

	routes = phalcon_fetch_nproperty_this(this_ptr, SL("_routes"), PH_NOISY TSRMLS_CC);

	phalcon_is_iterable(routes, &ah0, &hp0, 0, 1);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {

		PHALCON_GET_HVALUE(route);

		PHALCON_CALL_METHOD(&methods, route, "gethttpmethods");
		if (Z_TYPE_P(methods) != IS_NULL) {

			if (!request) {
				dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
				PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_router_exception_ce, 1);

				PHALCON_CALL_METHOD(&request, dependency_injector, "getshared", service);
				PHALCON_VERIFY_INTERFACE_EX(request, phalcon_http_requestinterface_ce, phalcon_mvc_router_exception_ce, 1);
			}

			PHALCON_CALL_METHOD(&match_method, request, "ismethod", methods);
			if (PHALCON_IS_FALSE(match_method)) {
				zend_hash_move_backwards_ex(ah0, &hp0);
				continue;
			}
		}

		PHALCON_CALL_METHOD(&hostname, route, "gethostname");
		if (Z_TYPE_P(hostname) != IS_NULL) {

			if (!request) {
				dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
				PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_router_exception_ce, 1);

				PHALCON_CALL_METHOD(&request, dependency_injector, "getshared", service);
				PHALCON_VERIFY_INTERFACE_EX(request, phalcon_http_requestinterface_ce, phalcon_mvc_router_exception_ce, 1);
			}

			if (Z_TYPE_P(current_host_name) == IS_NULL) {
				PHALCON_CALL_METHOD(&current_host_name, request, "gethttphost");
			}

			if (Z_TYPE_P(current_host_name) == IS_NULL) {
				zend_hash_move_backwards_ex(ah0, &hp0);
				continue;
			}

			PHALCON_INIT_NVAR(matched);
			if (phalcon_memnstr_str(hostname, SL("("))) {
				if (!phalcon_memnstr_str(hostname, SL("#"))) {
					PHALCON_INIT_NVAR(regex_host_name);
					/* FIXME: handle mixed case */
					PHALCON_CONCAT_SVS(regex_host_name, "#^", hostname, "$#");
				} else {
					PHALCON_CPY_WRT(regex_host_name, hostname);
				}

				RETURN_MM_ON_FAILURE(phalcon_preg_match(matched, regex_host_name, current_host_name, NULL TSRMLS_CC));
			} else {
				/* FIXME: handle mixed case */
				is_equal_function(matched, current_host_name, hostname TSRMLS_CC);
			}

			if (!zend_is_true(matched)) {
				zend_hash_move_backwards_ex(ah0, &hp0);
				continue;
			}
		}

		PHALCON_CALL_METHOD(&pattern, route, "getcompiledpattern");

		PHALCON_INIT_NVAR(route_found);
		if (Z_TYPE_P(pattern) == IS_STRING && Z_STRLEN_P(pattern) > 3 && Z_STRVAL_P(pattern)[1] == '^') {
			RETURN_MM_ON_FAILURE(phalcon_preg_match(route_found, pattern, handled_uri, matches TSRMLS_CC));
		} else {
			is_equal_function(route_found, pattern, handled_uri TSRMLS_CC);
		}

		if (zend_is_true(route_found)) {

			PHALCON_CALL_METHOD(&before_match, route, "getbeforematch");
			if (Z_TYPE_P(before_match) != IS_NULL) {

				if (!phalcon_is_callable(before_match TSRMLS_CC)) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "Before-Match callback is not callable in matched route");
					return;
				}

				PHALCON_INIT_NVAR(before_match_params);
				array_init_size(before_match_params, 3);
				phalcon_array_append(&before_match_params, handled_uri, 0);
				phalcon_array_append(&before_match_params, route, 0);
				phalcon_array_append(&before_match_params, this_ptr, 0);

				PHALCON_INIT_NVAR(route_found);/**/
				PHALCON_CALL_USER_FUNC_ARRAY(route_found, before_match, before_match_params);
			}
		}

		if (zend_is_true(route_found)) {

			PHALCON_CALL_METHOD(&paths, route, "getpaths");
			PHALCON_CPY_WRT(parts, paths);

			if (Z_TYPE_P(matches) == IS_ARRAY) {

				PHALCON_CALL_METHOD(&converters, route, "getconverters");

				phalcon_is_iterable(paths, &ah1, &hp1, 0, 0);

				while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {

					PHALCON_GET_HKEY(part, ah1, hp1);
					PHALCON_GET_HVALUE(position);

					if (Z_TYPE_P(part) != IS_STRING || Z_STRVAL_P(part)[0] != '\0') {
						if (phalcon_array_isset_fetch(&match_position, matches, position)) {
							/* Check if the part has a converter */
							if (phalcon_array_isset_fetch(&converter, converters, part)) {
								PHALCON_INIT_NVAR(parameters);
								array_init_size(parameters, 1);
								phalcon_array_append(&parameters, match_position, 0);

								PHALCON_INIT_NVAR(converted_part);/**/
								PHALCON_CALL_USER_FUNC_ARRAY(converted_part, converter, parameters);
								phalcon_array_update_zval(&parts, part, converted_part, PH_COPY);
								zend_hash_move_forward_ex(ah1, &hp1);
								continue;
							}

							/* Update the parts if there is no converter */
							phalcon_array_update_zval(&parts, part, match_position, PH_COPY);
						} else {
							/* Apply the converters anyway */
							if (phalcon_array_isset_fetch(&converter, converters, part)) {
								PHALCON_INIT_NVAR(parameters);
								array_init_size(parameters, 1);
								phalcon_array_append(&parameters, position, 0);

								PHALCON_INIT_NVAR(converted_part);/**/
								PHALCON_CALL_USER_FUNC_ARRAY(converted_part, converter, parameters);
								phalcon_array_update_zval(&parts, part, converted_part, PH_COPY);
							}
						}
					}

					zend_hash_move_forward_ex(ah1, &hp1);
				}

				phalcon_update_property_this_quick(this_ptr, SL("_matches"), matches, 83085737UL TSRMLS_CC);
			}

			phalcon_update_property_this_quick(this_ptr, SL("_matchedRoute"), route, 3232330313UL TSRMLS_CC);
			break;
		}

		zend_hash_move_backwards_ex(ah0, &hp0);
	}

	phalcon_update_property_bool(this_ptr, SL("_wasMatched"), zend_is_true(route_found) TSRMLS_CC);

	if (!zend_is_true(route_found)) {

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_notFoundPaths"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(tmp) != IS_NULL) {
			PHALCON_CPY_WRT(parts, tmp);

			PHALCON_INIT_NVAR(route_found);
			ZVAL_TRUE(route_found);
		}
	}

	if (zend_is_true(route_found)) {

		if (phalcon_array_isset_string_fetch(&namespace, parts, SS("namespace"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_namespace"), namespace, 1403433009UL TSRMLS_CC);
			phalcon_array_unset_string(&parts, SS("namespace"), PH_SEPARATE);
		} else {
			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultNamespace"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_namespace"), tmp, 1403433009UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&module, parts, SS("module"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_module"), module, 4176304298UL TSRMLS_CC);
			phalcon_array_unset_string(&parts, SS("module"), PH_SEPARATE);
		} else {
			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultModule"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_module"), tmp, 4176304298UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&exact, parts, SS("\0exact"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_isExactControllerName"), exact, 2089390682UL TSRMLS_CC);
			phalcon_array_unset_string(&parts, SS("\0exact"), PH_SEPARATE);
		}
		else {
			PHALCON_INIT_VAR(exact);
			ZVAL_FALSE(exact);
			phalcon_update_property_this_quick(this_ptr, SL("_isExactControllerName"), exact, 2089390682UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&controller, parts, SS("controller"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_controller"), controller, 1139371208UL TSRMLS_CC);
			phalcon_array_unset_string(&parts, SS("controller"), PH_SEPARATE);
		} else {
			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultController"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_controller"), tmp, 1139371208UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&action, parts, SS("action"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_action"), action, 1112512898UL TSRMLS_CC);
			phalcon_array_unset_string(&parts, SS("action"), PH_SEPARATE);
		} else {
			tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAction"), PH_NOISY TSRMLS_CC);
			phalcon_update_property_this_quick(this_ptr, SL("_action"), tmp, 1112512898UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&params_str, parts, SS("params"))) {
			PHALCON_INIT_VAR(str_params);
			phalcon_substr(str_params, params_str, 1, 0);
			if (zend_is_true(str_params)) {
				zval slash;
				ZVAL_STRINGL(&slash, "/", 1, 0);

				PHALCON_INIT_NVAR(params);
				phalcon_fast_explode(params, &slash, str_params);
			}

			phalcon_array_unset_string(&parts, SS("params"), PH_SEPARATE);
		}

		if (zend_hash_num_elements(Z_ARRVAL_P(params))) {
			PHALCON_INIT_VAR(params_merge);
			phalcon_fast_array_merge(params_merge, &params, &parts TSRMLS_CC);
		} else {
			params_merge = parts;
		}

		phalcon_update_property_this_quick(this_ptr, SL("_params"), params_merge, 3223731112UL TSRMLS_CC);
	} else {
		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultNamespace"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_namespace"), tmp, 1403433009UL TSRMLS_CC);

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultModule"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_module"), tmp, 4176304298UL TSRMLS_CC);

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultController"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_controller"), tmp, 1139371208UL TSRMLS_CC);

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultAction"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_action"), tmp, 1112512898UL TSRMLS_CC);

		tmp = phalcon_fetch_nproperty_this(this_ptr, SL("_defaultParams"), PH_NOISY TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_params"), tmp, 3223731112UL TSRMLS_CC);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router, add){

	zval *pattern, *paths = NULL, *http_methods = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &pattern, &paths, &http_methods);

	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}

	if (!http_methods) {
		http_methods = PHALCON_GLOBAL(z_null);
	}

	object_init_ex(return_value, phalcon_mvc_router_route_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", pattern, paths, http_methods);

	phalcon_update_property_array_append(this_ptr, SL("_routes"), return_value TSRMLS_CC);
	RETURN_MM();
}

static void phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAMETERS, const char *method)
{
	zval *pattern, *paths = NULL, *http_method;

	phalcon_fetch_params(0, 1, 1, &pattern, &paths);

	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}

	PHALCON_ALLOC_GHOST_ZVAL(http_method);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(http_method, method);
	PHALCON_RETURN_CALL_METHODW(getThis(), "add", pattern, paths, http_method);
}

static PHP_METHOD(Phalcon_Mvc_Router, addGet){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_GET);
}

static PHP_METHOD(Phalcon_Mvc_Router, addPost){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_POST);
}

static PHP_METHOD(Phalcon_Mvc_Router, addPut){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_PUT);
}

static PHP_METHOD(Phalcon_Mvc_Router, addPatch){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_PATCH);
}

static PHP_METHOD(Phalcon_Mvc_Router, addDelete){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_DELETE);
}

static PHP_METHOD(Phalcon_Mvc_Router, addOptions){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_OPTIONS);
}

static PHP_METHOD(Phalcon_Mvc_Router, addHead){

	phalcon_mvc_router_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_HEAD);
}

static int phalcon_router_call_convert(void *pDest TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)
{
	zval *route, key = zval_used_for_init;
	zval *params[2];

	assert(num_args == 1);

	route = va_arg(args, zval*);
	if (hash_key->nKeyLength) {
		ZVAL_STRINGL(&key, hash_key->arKey, hash_key->nKeyLength-1, 0);
	}
	else {
		ZVAL_LONG(&key, hash_key->h);
	}

	params[0] = &key;
	params[1] = *((zval**)pDest);

	if (FAILURE == phalcon_call_method(NULL, route, "convert", 2, params TSRMLS_CC)) {
		return ZEND_HASH_APPLY_STOP;
	}

	return ZEND_HASH_APPLY_KEEP;
}

static PHP_METHOD(Phalcon_Mvc_Router, mount){

	zval *group, *group_routes = NULL, *before_match = NULL;
	zval *hostname = NULL, *converters = NULL, *routes, *new_routes;
	HashPosition hp0;
	zval **route;

	phalcon_fetch_params(0, 1, 0, &group);
	PHALCON_VERIFY_CLASS_EX(group, phalcon_mvc_router_group_ce, phalcon_mvc_router_exception_ce, 0);

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&group_routes, group, "getroutes");
	if (Z_TYPE_P(group_routes) != IS_ARRAY || !zend_hash_num_elements(Z_ARRVAL_P(group_routes))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "The group of routes does not contain any routes");
		return;
	}

	/* Get the before-match condition */
	PHALCON_CALL_METHOD(&before_match, group, "getbeforematch");

	/* Get the hostname restriction */
	PHALCON_CALL_METHOD(&hostname, group, "gethostname");

	/* Get converters */
	PHALCON_CALL_METHOD(&converters, group, "getconverters");

	if (Z_TYPE_P(before_match) != IS_NULL || Z_TYPE_P(hostname) != IS_NULL || Z_TYPE_P(converters) != IS_NULL) {
		int has_before_match = (Z_TYPE_P(before_match) != IS_NULL);
		int has_hostname     = (Z_TYPE_P(hostname) != IS_NULL);
		int has_converters   = (Z_TYPE_P(converters) != IS_NULL);

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(group_routes), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(group_routes), (void**)&route, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(group_routes), &hp0)
		) {
			if (has_before_match) {
				PHALCON_CALL_METHOD(NULL, *route, "beforematch", before_match);
			}

			if (has_hostname) {
				PHALCON_CALL_METHOD(NULL, *route, "sethostname", hostname);
			}

			if (has_converters) {
				zend_hash_apply_with_arguments(Z_ARRVAL_P(converters) TSRMLS_CC, phalcon_router_call_convert, 1, *route);
			}
		}
	}

	routes = phalcon_fetch_nproperty_this(this_ptr, SL("_routes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(routes) == IS_ARRAY) {
		PHALCON_INIT_VAR(new_routes);
		phalcon_fast_array_merge(new_routes, &routes, &group_routes TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_routes"), new_routes, 2063827110UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_routes"), group_routes, 2063827110UL TSRMLS_CC);
	}

	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Router, notFound){

	zval *paths;

	phalcon_fetch_params(0, 1, 0, &paths);

	if (Z_TYPE_P(paths) != IS_ARRAY) {
		if (Z_TYPE_P(paths) != IS_STRING) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_router_exception_ce, "The not-found paths must be an array or string");
			return;
		}
	}
	phalcon_update_property_this_quick(this_ptr, SL("_notFoundPaths"), paths, 189519377UL TSRMLS_CC);

	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router, clear){

	zval *empty_routes;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(empty_routes);
	array_init(empty_routes);
	phalcon_update_property_this_quick(this_ptr, SL("_routes"), empty_routes, 2063827110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_routesNameLookup"), empty_routes, 235031905UL TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router, getNamespaceName){


	RETURN_MEMBER_QUICK(this_ptr, "_namespace", 1403433009UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getModuleName){


	RETURN_MEMBER_QUICK(this_ptr, "_module", 4176304298UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getControllerName){


	RETURN_MEMBER_QUICK(this_ptr, "_controller", 1139371208UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getActionName){


	RETURN_MEMBER_QUICK(this_ptr, "_action", 1112512898UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getParams){


	RETURN_MEMBER_QUICK(this_ptr, "_params", 3223731112UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getMatchedRoute){


	RETURN_MEMBER_QUICK(this_ptr, "_matchedRoute", 3232330313UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getMatches){


	RETURN_MEMBER_QUICK(this_ptr, "_matches", 83085737UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, wasMatched){


	RETURN_MEMBER_QUICK(this_ptr, "_wasMatched", 2908823365UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getRoutes){


	RETURN_MEMBER_QUICK(this_ptr, "_routes", 2063827110UL);
}

static PHP_METHOD(Phalcon_Mvc_Router, getRouteById){

	zval *id, *routes, **route, *route_id = NULL;
	HashPosition hp0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &id);

	routes = phalcon_fetch_nproperty_this(this_ptr, SL("_routes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(routes) == IS_ARRAY) {
		for(
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(routes), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(routes), (void**)&route, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(routes), &hp0)
		) {
			PHALCON_CALL_METHOD(&route_id, *route, "getrouteid");
			if (phalcon_is_equal(route_id, id TSRMLS_CC)) {
				RETURN_CTOR(*route);
			}
		}
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Router, getRouteByName){

	zval *name, *routes, **route, *routes_name_lookup, *route_name = NULL;
	HashPosition hp0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &name);

	if (UNEXPECTED(Z_TYPE_P(name) != IS_STRING)) {
		PHALCON_SEPARATE_PARAM(name);
		convert_to_string(name);
	}

	routes_name_lookup = phalcon_fetch_nproperty_this(this_ptr, SL("_routesNameLookup"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_NOT_EMPTY(name) && phalcon_hash_find(Z_ARRVAL_P(routes_name_lookup), Z_STRVAL_P(name), Z_STRLEN_P(name) + 1, (void **)&route) == SUCCESS) {
		RETURN_CTOR(*route);
	}

	routes = phalcon_fetch_nproperty_this(this_ptr, SL("_routes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(routes) == IS_ARRAY) {
		for(
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(routes), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(routes), (void**)&route, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(routes), &hp0)
		) {
			PHALCON_CALL_METHOD(&route_name, *route, "getname");
			convert_to_string(route_name);
			if (PHALCON_IS_NOT_EMPTY(route_name)) {
				phalcon_update_property_array_string(this_ptr, SL("_routesNameLookup"), Z_STRVAL_P(route_name), Z_STRLEN_P(route_name) + 1, *route TSRMLS_CC);
			}

			if (phalcon_is_equal(route_name, name TSRMLS_CC)) {
				RETURN_CTOR(*route);
			}
		}
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Router, isExactControllerName) {
	RETURN_MEMBER_QUICK(this_ptr, "_isExactControllerName", 2089390682UL);
}





zend_class_entry *phalcon_mvc_routerinterface_ce;

static const zend_function_entry phalcon_mvc_routerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, setDefaultModule, arginfo_phalcon_mvc_routerinterface_setdefaultmodule)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, setDefaultController, arginfo_phalcon_mvc_routerinterface_setdefaultcontroller)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, setDefaultAction, arginfo_phalcon_mvc_routerinterface_setdefaultaction)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, setDefaults, arginfo_phalcon_mvc_routerinterface_setdefaults)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, handle, arginfo_phalcon_mvc_routerinterface_handle)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, add, arginfo_phalcon_mvc_routerinterface_add)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addGet, arginfo_phalcon_mvc_routerinterface_addget)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addPost, arginfo_phalcon_mvc_routerinterface_addpost)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addPut, arginfo_phalcon_mvc_routerinterface_addput)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addDelete, arginfo_phalcon_mvc_routerinterface_adddelete)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addOptions, arginfo_phalcon_mvc_routerinterface_addoptions)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addPatch, arginfo_phalcon_mvc_routerinterface_addpatch)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, addHead, arginfo_phalcon_mvc_routerinterface_addhead)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, clear, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getModuleName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getControllerName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getActionName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getParams, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getMatchedRoute, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getMatches, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, wasMatched, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getRoutes, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getRouteById, arginfo_phalcon_mvc_routerinterface_getroutebyid)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, getRouteByName, arginfo_phalcon_mvc_routerinterface_getroutebyname)
	PHP_ABSTRACT_ME(Phalcon_Mvc_RouterInterface, isExactControllerName, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_RouterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, RouterInterface, mvc_routerinterface, phalcon_mvc_routerinterface_method_entry);

	return SUCCESS;
}
































zend_class_entry *phalcon_mvc_url_ce;

static PHP_METHOD(Phalcon_Mvc_Url, setDI);
static PHP_METHOD(Phalcon_Mvc_Url, getDI);
static PHP_METHOD(Phalcon_Mvc_Url, setBaseUri);
static PHP_METHOD(Phalcon_Mvc_Url, setStaticBaseUri);
static PHP_METHOD(Phalcon_Mvc_Url, getBaseUri);
static PHP_METHOD(Phalcon_Mvc_Url, getStaticBaseUri);
static PHP_METHOD(Phalcon_Mvc_Url, setBasePath);
static PHP_METHOD(Phalcon_Mvc_Url, getBasePath);
static PHP_METHOD(Phalcon_Mvc_Url, get);
static PHP_METHOD(Phalcon_Mvc_Url, getStatic);
static PHP_METHOD(Phalcon_Mvc_Url, path);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_url_setstaticbaseuri, 0, 0, 1)
	ZEND_ARG_INFO(0, staticBaseUri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_url_getstatic, 0, 0, 0)
	ZEND_ARG_INFO(0, uri)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_url_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Url, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, setBaseUri, arginfo_phalcon_mvc_urlinterface_setbaseuri, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, setStaticBaseUri, arginfo_phalcon_mvc_url_setstaticbaseuri, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, getBaseUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, getStaticBaseUri, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, setBasePath, arginfo_phalcon_mvc_urlinterface_setbasepath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, getBasePath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, get, arginfo_phalcon_mvc_urlinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, getStatic, arginfo_phalcon_mvc_url_getstatic, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Url, path, arginfo_phalcon_mvc_urlinterface_path, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Url){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc, Url, mvc_url, phalcon_mvc_url_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_url_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_baseUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_staticBaseUri"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_basePath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_url_ce, SL("_router"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_url_ce TSRMLS_CC, 2, phalcon_mvc_urlinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Url, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_url_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Url, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Url, setBaseUri){

	zval *base_uri, *static_base_uri;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &base_uri);
	
	phalcon_update_property_this_quick(this_ptr, SL("_baseUri"), base_uri, 3689183023UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(static_base_uri);
	phalcon_read_property_this(&static_base_uri, this_ptr, SL("_staticBaseUri"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(static_base_uri) == IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_staticBaseUri"), base_uri, 2610838775UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Url, setStaticBaseUri){

	zval *static_base_uri;

	phalcon_fetch_params(0, 1, 0, &static_base_uri);
	
	phalcon_update_property_this_quick(this_ptr, SL("_staticBaseUri"), static_base_uri, 2610838775UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Url, getBaseUri){

	zval *base_uri = NULL, *slash, *_SERVER, *php_self, *uri = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(base_uri);
	phalcon_read_property_this(&base_uri, this_ptr, SL("_baseUri"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(base_uri) == IS_NULL) {
	
		PHALCON_INIT_VAR(slash);
		ZVAL_STRING(slash, "/", 1);
		_SERVER = phalcon_get_global(SS("_SERVER") TSRMLS_CC);
		if (phalcon_array_isset_string_fetch(&php_self, _SERVER, SS("PHP_SELF"))) {
			PHALCON_INIT_VAR(uri);
			phalcon_get_uri(uri, php_self);
		} else {
			PHALCON_INIT_NVAR(uri);
		}
	
		if (!zend_is_true(uri)) {
			PHALCON_CPY_WRT(base_uri, slash);
		} else {
			PHALCON_INIT_NVAR(base_uri);
			PHALCON_CONCAT_VVV(base_uri, slash, uri, slash);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_baseUri"), base_uri, 3689183023UL TSRMLS_CC);
	}
	
	RETURN_CCTOR(base_uri);
}

static PHP_METHOD(Phalcon_Mvc_Url, getStaticBaseUri){

	zval *static_base_uri;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(static_base_uri);
	phalcon_read_property_this(&static_base_uri, this_ptr, SL("_staticBaseUri"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(static_base_uri) != IS_NULL) {
		RETURN_CCTOR(static_base_uri);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "getbaseuri");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Url, setBasePath){

	zval *base_path;

	phalcon_fetch_params(0, 1, 0, &base_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_basePath"), base_path, 1477430348UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Url, getBasePath){


	RETURN_MEMBER_QUICK(this_ptr, "_basePath", 1477430348UL);
}

static PHP_METHOD(Phalcon_Mvc_Url, get){

	zval **uri = NULL, *base_uri = NULL, *router = NULL, *dependency_injector;
	zval *service, *route_name, *route = NULL, *exception_message;
	zval *pattern = NULL, *paths = NULL, *processed_uri, **args = NULL, *query_string;
	zval *matched, *regexp;
	zval **z_local = NULL;
	int local = 1;

	phalcon_fetch_params_ex(0, 3, &uri, &args, &z_local);

	PHALCON_MM_GROW();

	if (!uri) {
		uri = &PHALCON_GLOBAL(z_null);
	}
	else if (z_local && Z_TYPE_PP(z_local) != IS_NULL) {
		if (!zend_is_true(*z_local)) {
			local = 0;
		}
	}
	else if (Z_TYPE_PP(uri) == IS_STRING && strstr(Z_STRVAL_PP(uri), ":")) {
		PHALCON_INIT_VAR(matched);
		PHALCON_INIT_VAR(regexp);
		ZVAL_STRING(regexp, "/^[^:\\/?#]++:/", 1);
		RETURN_MM_ON_FAILURE(phalcon_preg_match(matched, regexp, *uri, NULL TSRMLS_CC));
		if (zend_is_true(matched)) {
			local = 0;
		}
	}

	PHALCON_CALL_METHOD(&base_uri, this_ptr, "getbaseuri");

	if (Z_TYPE_PP(uri) == IS_ARRAY) {
		if (!phalcon_array_isset_string_fetch(&route_name, *uri, SS("for"))) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_url_exception_ce, "It's necessary to define the route name with the parameter \"for\"");
			return;
		}
	
		router = phalcon_fetch_nproperty_this(this_ptr, SL("_router"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(router) != IS_OBJECT) {
			dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
			if (!zend_is_true(dependency_injector)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_url_exception_ce, "A dependency injector container is required to obtain the \"url\" service");
				return;
			}
	
			PHALCON_INIT_VAR(service);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_router);
	
			router = NULL;
			PHALCON_CALL_METHOD(&router, dependency_injector, "getshared", service);
			PHALCON_VERIFY_INTERFACE(router, phalcon_mvc_routerinterface_ce);
			phalcon_update_property_this_quick(this_ptr, SL("_router"), router, 2063827077UL TSRMLS_CC);
		}
	
		PHALCON_CALL_METHOD(&route, router, "getroutebyname", route_name);
		if (Z_TYPE_P(route) != IS_OBJECT) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Cannot obtain a route using the name \"", route_name, "\"");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_url_exception_ce, exception_message);
			return;
		}

		PHALCON_CALL_METHOD(&pattern, route, "getpattern");
	
		PHALCON_CALL_METHOD(&paths, route, "getreversedpaths");

		PHALCON_INIT_VAR(processed_uri);
		phalcon_replace_paths(processed_uri, pattern, paths, *uri TSRMLS_CC);

		PHALCON_CONCAT_VV(return_value, base_uri, processed_uri);
	}
	else {
		if (local) {
			PHALCON_CONCAT_VV(return_value, base_uri, *uri);
		}
		else {
			ZVAL_ZVAL(return_value, *uri, 1, 0);
		}
	}
	
	if (args) {
		PHALCON_INIT_VAR(query_string);
		phalcon_http_build_query(query_string, *args, "&" TSRMLS_CC);
		if (Z_TYPE_P(query_string) == IS_STRING && Z_STRLEN_P(query_string)) {
			if (phalcon_memnstr_str(return_value, "?", 1)) {
				PHALCON_SCONCAT_SV(return_value, "&", query_string);
			}
			else {
				PHALCON_SCONCAT_SV(return_value, "?", query_string);
			}
		}
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Url, getStatic){

	zval **uri = NULL, *static_base_uri, *base_uri = NULL;
	zval *matched, *pattern;

	phalcon_fetch_params_ex(0, 1, &uri);

	PHALCON_MM_GROW();

	if (!uri) {
		uri = &PHALCON_GLOBAL(z_null);
	}
	else {
		PHALCON_ENSURE_IS_STRING(uri);

		if (strstr(Z_STRVAL_PP(uri), "://")) {
			PHALCON_INIT_VAR(matched);
			PHALCON_INIT_VAR(pattern);
			ZVAL_STRING(pattern, "/^[^:\\/?#]++:/", 1);
			RETURN_MM_ON_FAILURE(phalcon_preg_match(matched, pattern, *uri, NULL TSRMLS_CC));
			if (zend_is_true(matched)) {
				RETURN_CTOR(*uri);
			}
		}
	}
	
	static_base_uri = phalcon_fetch_nproperty_this(this_ptr, SL("_staticBaseUri"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(static_base_uri) != IS_NULL) {
		PHALCON_CONCAT_VV(return_value, static_base_uri, *uri);
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(&base_uri, this_ptr, "getbaseuri");
	PHALCON_CONCAT_VV(return_value, base_uri, *uri);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Url, path){

	zval *path = NULL, *base_path;

	phalcon_fetch_params(0, 0, 1, &path);
	
	if (!path) {
		path = PHALCON_GLOBAL(z_null);
	}
	
	base_path = phalcon_fetch_nproperty_this(this_ptr, SL("_basePath"), PH_NOISY TSRMLS_CC);
	PHALCON_CONCAT_VV(return_value, base_path, path);
}





zend_class_entry *phalcon_mvc_urlinterface_ce;

static const zend_function_entry phalcon_mvc_urlinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, setBaseUri, arginfo_phalcon_mvc_urlinterface_setbaseuri)
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, getBaseUri, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, setBasePath, arginfo_phalcon_mvc_urlinterface_setbasepath)
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, getBasePath, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, get, arginfo_phalcon_mvc_urlinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Mvc_UrlInterface, path, arginfo_phalcon_mvc_urlinterface_path)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_UrlInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, UrlInterface, mvc_urlinterface, phalcon_mvc_urlinterface_method_entry);

	return SUCCESS;
}










#include <Zend/zend_closures.h>



zend_class_entry *phalcon_mvc_view_ce;

static PHP_METHOD(Phalcon_Mvc_View, __construct);
static PHP_METHOD(Phalcon_Mvc_View, setViewsDir);
static PHP_METHOD(Phalcon_Mvc_View, getViewsDir);
static PHP_METHOD(Phalcon_Mvc_View, setLayoutsDir);
static PHP_METHOD(Phalcon_Mvc_View, getLayoutsDir);
static PHP_METHOD(Phalcon_Mvc_View, setPartialsDir);
static PHP_METHOD(Phalcon_Mvc_View, getPartialsDir);
static PHP_METHOD(Phalcon_Mvc_View, setBasePath);
static PHP_METHOD(Phalcon_Mvc_View, getCurrentRenderLevel);
static PHP_METHOD(Phalcon_Mvc_View, getRenderLevel);
static PHP_METHOD(Phalcon_Mvc_View, setRenderLevel);
static PHP_METHOD(Phalcon_Mvc_View, disableLevel);
static PHP_METHOD(Phalcon_Mvc_View, getDisabledLevels);
static PHP_METHOD(Phalcon_Mvc_View, setMainView);
static PHP_METHOD(Phalcon_Mvc_View, getMainView);
static PHP_METHOD(Phalcon_Mvc_View, setLayout);
static PHP_METHOD(Phalcon_Mvc_View, getLayout);
static PHP_METHOD(Phalcon_Mvc_View, setTemplateBefore);
static PHP_METHOD(Phalcon_Mvc_View, cleanTemplateBefore);
static PHP_METHOD(Phalcon_Mvc_View, setTemplateAfter);
static PHP_METHOD(Phalcon_Mvc_View, cleanTemplateAfter);
static PHP_METHOD(Phalcon_Mvc_View, setParamToView);
static PHP_METHOD(Phalcon_Mvc_View, setVars);
static PHP_METHOD(Phalcon_Mvc_View, setVar);
static PHP_METHOD(Phalcon_Mvc_View, getVar);
static PHP_METHOD(Phalcon_Mvc_View, getParamsToView);
static PHP_METHOD(Phalcon_Mvc_View, getControllerName);
static PHP_METHOD(Phalcon_Mvc_View, getActionName);
static PHP_METHOD(Phalcon_Mvc_View, getParams);
static PHP_METHOD(Phalcon_Mvc_View, start);
static PHP_METHOD(Phalcon_Mvc_View, _loadTemplateEngines);
static PHP_METHOD(Phalcon_Mvc_View, _engineRender);
static PHP_METHOD(Phalcon_Mvc_View, registerEngines);
static PHP_METHOD(Phalcon_Mvc_View, getRegisteredEngines);
static PHP_METHOD(Phalcon_Mvc_View, exists);
static PHP_METHOD(Phalcon_Mvc_View, render);
static PHP_METHOD(Phalcon_Mvc_View, pick);
static PHP_METHOD(Phalcon_Mvc_View, partial);
static PHP_METHOD(Phalcon_Mvc_View, getRender);
static PHP_METHOD(Phalcon_Mvc_View, finish);
static PHP_METHOD(Phalcon_Mvc_View, _createCache);
static PHP_METHOD(Phalcon_Mvc_View, isCaching);
static PHP_METHOD(Phalcon_Mvc_View, getCache);
static PHP_METHOD(Phalcon_Mvc_View, cache);
static PHP_METHOD(Phalcon_Mvc_View, setContent);
static PHP_METHOD(Phalcon_Mvc_View, getContent);
static PHP_METHOD(Phalcon_Mvc_View, getActiveRenderPath);
static PHP_METHOD(Phalcon_Mvc_View, disable);
static PHP_METHOD(Phalcon_Mvc_View, enable);
static PHP_METHOD(Phalcon_Mvc_View, isDisabled);
static PHP_METHOD(Phalcon_Mvc_View, reset);
static PHP_METHOD(Phalcon_Mvc_View, __set);
static PHP_METHOD(Phalcon_Mvc_View, __get);
static PHP_METHOD(Phalcon_Mvc_View, __isset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_disablelevel, 0, 0, 1)
	ZEND_ARG_INFO(0, level)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_setvars, 0, 0, 1)
	ZEND_ARG_INFO(0, params)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_getvar, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_exists, 0, 0, 1)
	ZEND_ARG_INFO(0, view)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_getrender, 0, 0, 2)
	ZEND_ARG_INFO(0, controllerName)
	ZEND_ARG_INFO(0, actionName)
	ZEND_ARG_INFO(0, params)
	ZEND_ARG_INFO(0, configCallback)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_view_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View, __construct, arginfo_phalcon_mvc_view___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_View, setViewsDir, arginfo_phalcon_mvc_viewinterface_setviewsdir, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getViewsDir, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setLayoutsDir, arginfo_phalcon_mvc_viewinterface_setlayoutsdir, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getLayoutsDir, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setPartialsDir, arginfo_phalcon_mvc_viewinterface_setpartialsdir, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getPartialsDir, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setBasePath, arginfo_phalcon_mvc_viewinterface_setbasepath, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getCurrentRenderLevel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getRenderLevel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setRenderLevel, arginfo_phalcon_mvc_viewinterface_setrenderlevel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, disableLevel, arginfo_phalcon_mvc_view_disablelevel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getDisabledLevels, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setMainView, arginfo_phalcon_mvc_viewinterface_setmainview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getMainView, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setLayout, arginfo_phalcon_mvc_viewinterface_setlayout, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getLayout, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setTemplateBefore, arginfo_phalcon_mvc_viewinterface_settemplatebefore, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, cleanTemplateBefore, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setTemplateAfter, arginfo_phalcon_mvc_viewinterface_settemplateafter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, cleanTemplateAfter, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setParamToView, arginfo_phalcon_mvc_viewinterface_setparamtoview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setVars, arginfo_phalcon_mvc_view_setvars, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setVar, arginfo_phalcon_mvc_viewinterface_setvar, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getVar, arginfo_phalcon_mvc_view_getvar, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getParamsToView, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getControllerName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getActionName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getParams, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, start, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, _loadTemplateEngines, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View, _engineRender, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View, registerEngines, arginfo_phalcon_mvc_viewinterface_registerengines, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getRegisteredEngines, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, exists, arginfo_phalcon_mvc_view_exists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, render, arginfo_phalcon_mvc_viewinterface_render, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, pick, arginfo_phalcon_mvc_viewinterface_pick, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, partial, arginfo_phalcon_mvc_viewinterface_partial, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getRender, arginfo_phalcon_mvc_view_getrender, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, finish, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, _createCache, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View, isCaching, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getCache, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, cache, arginfo_phalcon_mvc_viewinterface_cache, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, setContent, arginfo_phalcon_mvc_viewinterface_setcontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getContent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, getActiveRenderPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, disable, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, enable, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, isDisabled, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, reset, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, __set, arginfo___set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, __get, arginfo___get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View, __isset, arginfo___isset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc, View, mvc_view, phalcon_di_injectable_ce, phalcon_mvc_view_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_basePath"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_content"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_ce, SL("_renderLevel"), 5, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_ce, SL("_currentRenderLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_disabledLevels"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_viewParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_layout"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_layoutsDir"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_partialsDir"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_viewsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_templatesBefore"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_templatesAfter"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_ce, SL("_engines"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_registeredEngines"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_view_ce, SL("_mainView"), "index", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_controllerName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_actionName"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_pickView"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_ce, SL("_cacheLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_ce, SL("_activeRenderPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_ce, SL("_disabled"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_MAIN_LAYOUT"), 5 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_AFTER_TEMPLATE"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_LAYOUT"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_BEFORE_TEMPLATE"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_ACTION_VIEW"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_view_ce, SL("LEVEL_NO_RENDER"), 0 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_ce TSRMLS_CC, 1, phalcon_mvc_viewinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Mvc_View, setViewsDir){

	zval **views_dir;

	phalcon_fetch_params_ex(1, 0, &views_dir);
	phalcon_add_trailing_slash(views_dir);
	phalcon_update_property_this(this_ptr, SL("_viewsDir"), *views_dir TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getViewsDir){


	RETURN_MEMBER_QUICK(this_ptr, "_viewsDir", 3398309201UL);
}

static PHP_METHOD(Phalcon_Mvc_View, setLayoutsDir){

	zval **layouts_dir;

	phalcon_fetch_params_ex(1, 0, &layouts_dir);
	phalcon_add_trailing_slash(layouts_dir);
	phalcon_update_property_this(this_ptr, SL("_layoutsDir"), *layouts_dir TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getLayoutsDir){


	RETURN_MEMBER_QUICK(this_ptr, "_layoutsDir", 313056692UL);
}

static PHP_METHOD(Phalcon_Mvc_View, setPartialsDir){

	zval **partials_dir;

	phalcon_fetch_params_ex(1, 0, &partials_dir);
	phalcon_add_trailing_slash(partials_dir);
	phalcon_update_property_this(this_ptr, SL("_partialsDir"), *partials_dir TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getPartialsDir){


	RETURN_MEMBER_QUICK(this_ptr, "_partialsDir", 2130168739UL);
}

static PHP_METHOD(Phalcon_Mvc_View, setBasePath){

	zval **base_path;

	phalcon_fetch_params_ex(1, 0, &base_path);

	phalcon_add_trailing_slash(base_path);
	phalcon_update_property_this(this_ptr, SL("_basePath"), *base_path TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getCurrentRenderLevel) {

	RETURN_MEMBER(getThis(), "_currentRenderLevel");
}

static PHP_METHOD(Phalcon_Mvc_View, getRenderLevel) {

	RETURN_MEMBER(getThis(), "_renderLevel");
}

static PHP_METHOD(Phalcon_Mvc_View, setRenderLevel){

	zval *level;

	phalcon_fetch_params(0, 1, 0, &level);
	
	phalcon_update_property_this_quick(this_ptr, SL("_renderLevel"), level, 3194989084UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, disableLevel){

	zval *level;

	phalcon_fetch_params(0, 1, 0, &level);
	
	if (Z_TYPE_P(level) == IS_ARRAY) { 
		phalcon_update_property_this_quick(this_ptr, SL("_disabledLevels"), level, 1575004551UL TSRMLS_CC);
	} else {
		phalcon_update_property_array(this_ptr, SL("_disabledLevels"), level, PHALCON_GLOBAL(z_true) TSRMLS_CC);
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getDisabledLevels) {

	RETURN_MEMBER(getThis(), "_disabledLevels");
}

static PHP_METHOD(Phalcon_Mvc_View, setMainView){

	zval *view_path;

	phalcon_fetch_params(0, 1, 0, &view_path);
	
	phalcon_update_property_this_quick(this_ptr, SL("_mainView"), view_path, 1829858724UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getMainView){


	RETURN_MEMBER_QUICK(this_ptr, "_mainView", 1829858724UL);
}

static PHP_METHOD(Phalcon_Mvc_View, setLayout){

	zval *layout;

	phalcon_fetch_params(0, 1, 0, &layout);
	
	phalcon_update_property_this_quick(this_ptr, SL("_layout"), layout, 2361639842UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getLayout){


	RETURN_MEMBER_QUICK(this_ptr, "_layout", 2361639842UL);
}

static PHP_METHOD(Phalcon_Mvc_View, setTemplateBefore){

	zval *template_before, *array_template;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &template_before);
	
	if (Z_TYPE_P(template_before) != IS_ARRAY) { 
		PHALCON_INIT_VAR(array_template);
		array_init_size(array_template, 1);
		phalcon_array_append(&array_template, template_before, 0);
		phalcon_update_property_this_quick(this_ptr, SL("_templatesBefore"), array_template, 3273177030UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_templatesBefore"), template_before, 3273177030UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, cleanTemplateBefore){


	phalcon_update_property_null(this_ptr, SL("_templatesBefore") TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, setTemplateAfter){

	zval *template_after, *array_template;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &template_after);
	
	if (Z_TYPE_P(template_after) != IS_ARRAY) { 
		PHALCON_INIT_VAR(array_template);
		array_init_size(array_template, 1);
		phalcon_array_append(&array_template, template_after, 0);
		phalcon_update_property_this_quick(this_ptr, SL("_templatesAfter"), array_template, 3575793989UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_templatesAfter"), template_after, 3575793989UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, cleanTemplateAfter){


	phalcon_update_property_null(this_ptr, SL("_templatesAfter") TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, setParamToView){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, setVars){

	zval *params, *merge = NULL, *view_params, *merged_params = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &params, &merge);
	
	if (!merge) {
		merge = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The render parameters must be an array");
		return;
	}
	if (zend_is_true(merge)) {
	
		PHALCON_OBS_VAR(view_params);
		phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(view_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &view_params, &params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, params);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), merged_params, 1685283331UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), params, 1685283331UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, setVar){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getVar){

	zval *key, *params, *value;

	phalcon_fetch_params(0, 1, 0, &key);
	
	params = phalcon_fetch_nproperty_this(this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, params, key)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_View, getParamsToView){


	RETURN_MEMBER_QUICK(this_ptr, "_viewParams", 1685283331UL);
}

static PHP_METHOD(Phalcon_Mvc_View, getControllerName){


	RETURN_MEMBER_QUICK(this_ptr, "_controllerName", 3332183433UL);
}

static PHP_METHOD(Phalcon_Mvc_View, getActionName){


	RETURN_MEMBER_QUICK(this_ptr, "_actionName", 2975797059UL);
}

static PHP_METHOD(Phalcon_Mvc_View, getParams){


	RETURN_MEMBER_QUICK(this_ptr, "_params", 3223731112UL);
}

static PHP_METHOD(Phalcon_Mvc_View, start){

	phalcon_update_property_null(this_ptr, SL("_content") TSRMLS_CC);
	phalcon_ob_start(TSRMLS_C);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, _loadTemplateEngines){

	zval *engines = NULL, *dependency_injector, *registered_engines;
	zval *php_engine, *arguments, *engine_service = NULL;
	zval *extension = NULL, *engine_object = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(engines);
	phalcon_read_property_this(&engines, this_ptr, SL("_engines"), PH_NOISY TSRMLS_CC);
	
	if (PHALCON_IS_FALSE(engines)) {
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(engines);
		array_init(engines);
	
		PHALCON_OBS_VAR(registered_engines);
		phalcon_read_property_this(&registered_engines, this_ptr, SL("_registeredEngines"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(registered_engines) != IS_ARRAY) { 
			PHALCON_INIT_VAR(php_engine);
			object_init_ex(php_engine, phalcon_mvc_view_engine_php_ce);
			PHALCON_CALL_METHOD(NULL, php_engine, "__construct", this_ptr, dependency_injector);
	
			phalcon_array_update_string(&engines, SL(".phtml"), php_engine, PH_COPY);
		} else {
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the application services");
				return;
			}
	
			PHALCON_INIT_VAR(arguments);
			array_init_size(arguments, 2);
			phalcon_array_append(&arguments, this_ptr, 0);
			phalcon_array_append(&arguments, dependency_injector, 0);
	
			phalcon_is_iterable(registered_engines, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(extension, ah0, hp0);
				PHALCON_GET_HVALUE(engine_service);
	
				if (Z_TYPE_P(engine_service) == IS_OBJECT) {
	
					if (instanceof_function(Z_OBJCE_P(engine_service), zend_ce_closure TSRMLS_CC)) {
						PHALCON_INIT_NVAR(engine_object); /**/
						PHALCON_CALL_USER_FUNC_ARRAY(engine_object, engine_service, arguments);
					} else {
						PHALCON_CPY_WRT(engine_object, engine_service);
					}
				} else {
					if (Z_TYPE_P(engine_service) == IS_STRING) {
						PHALCON_CALL_METHOD(&engine_object, dependency_injector, "getshared", engine_service, arguments);
						PHALCON_VERIFY_INTERFACE(engine_object, phalcon_mvc_view_engineinterface_ce);
					} else {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SV(exception_message, "Invalid template engine registration for extension: ", extension);
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
						return;
					}
				}
				phalcon_array_update_zval(&engines, extension, engine_object, PH_COPY | 0);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_engines"), engines, 1840711053UL TSRMLS_CC);
	} else {
		PHALCON_OBS_NVAR(engines);
		phalcon_read_property_this(&engines, this_ptr, SL("_engines"), PH_NOISY TSRMLS_CC);
	}
	
	RETURN_CCTOR(engines);
}

static PHP_METHOD(Phalcon_Mvc_View, _engineRender){

	zval *engines, *view_path, *silence, *must_clean;
	zval *cache, *not_exists = NULL, *views_dir, *base_path;
	zval *views_dir_path, *render_level, *cache_level;
	zval *is_started = NULL, *key = NULL, *lifetime = NULL, *view_options;
	zval *cache_options, *cached_view = NULL, *is_fresh = NULL;
	zval *view_params, *events_manager, *engine = NULL;
	zval *extension = NULL, *view_engine_path = NULL, *event_name = NULL;
	zval *status = NULL, *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 5, 0, &engines, &view_path, &silence, &must_clean, &cache);
	
	PHALCON_INIT_VAR(not_exists);
	ZVAL_TRUE(not_exists);
	
	PHALCON_OBS_VAR(views_dir);
	phalcon_read_property_this(&views_dir, this_ptr, SL("_viewsDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(base_path);
	phalcon_read_property_this(&base_path, this_ptr, SL("_basePath"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(views_dir_path);
	PHALCON_CONCAT_VVV(views_dir_path, base_path, views_dir, view_path);
	
	if (Z_TYPE_P(cache) == IS_OBJECT) {
	
		PHALCON_OBS_VAR(render_level);
		phalcon_read_property_this(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(cache_level);
		phalcon_read_property_this(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY TSRMLS_CC);
		if (PHALCON_GE(render_level, cache_level)) {
	
			PHALCON_CALL_METHOD(&is_started, cache, "isstarted");
			if (PHALCON_IS_FALSE(is_started)) {
	
				PHALCON_INIT_VAR(key);
	
				PHALCON_INIT_VAR(lifetime);
	
				PHALCON_OBS_VAR(view_options);
				phalcon_read_property_this(&view_options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
				if (Z_TYPE_P(view_options) == IS_ARRAY) { 
					if (phalcon_array_isset_quick_string(view_options, SS("cache"), 4125168857UL)) {
	
						PHALCON_OBS_VAR(cache_options);
						phalcon_array_fetch_quick_string(&cache_options, view_options, SS("cache"), 4125168857UL, PH_NOISY);
						if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
							if (phalcon_array_isset_quick_string(cache_options, SS("key"), 2090432846UL)) {
								PHALCON_OBS_NVAR(key);
								phalcon_array_fetch_quick_string(&key, cache_options, SS("key"), 2090432846UL, PH_NOISY);
							}
							if (phalcon_array_isset_quick_string(cache_options, SS("lifetime"), 2639810228UL)) {
								PHALCON_OBS_NVAR(lifetime);
								phalcon_array_fetch_quick_string(&lifetime, cache_options, SS("lifetime"), 2639810228UL, PH_NOISY);
							}
						}
					}
				}
	
				if (Z_TYPE_P(key) == IS_NULL) {
					PHALCON_INIT_NVAR(key);
					phalcon_md5(key, view_path);
				}
	
				PHALCON_CALL_METHOD(&cached_view, cache, "start", key, lifetime);
				if (Z_TYPE_P(cached_view) != IS_NULL) {
					phalcon_update_property_this_quick(this_ptr, SL("_content"), cached_view, 4081318271UL TSRMLS_CC);
					RETURN_MM_NULL();
				}
			}
	
			PHALCON_CALL_METHOD(&is_fresh, cache, "isfresh");
			if (!zend_is_true(is_fresh)) {
				RETURN_MM_NULL();
			}
		}
	}
	
	PHALCON_OBS_VAR(view_params);
	phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(view_engine_path);
	phalcon_is_iterable(engines, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(extension, ah0, hp0);
		PHALCON_GET_HVALUE(engine);
	
		PHALCON_INIT_NVAR(view_engine_path);
		PHALCON_CONCAT_VV(view_engine_path, views_dir_path, extension);
	
		if (phalcon_file_exists(view_engine_path TSRMLS_CC) == SUCCESS) {
	
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				phalcon_update_property_this_quick(this_ptr, SL("_activeRenderPath"), view_engine_path, 1528023309UL TSRMLS_CC);
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:beforeRenderView", 1);
	
				PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, view_engine_path);
				if (PHALCON_IS_FALSE(status)) {
					zend_hash_move_forward_ex(ah0, &hp0);
					continue;
				}
			}
			PHALCON_CALL_METHOD(NULL, engine, "render", view_engine_path, view_params, must_clean);
	
			PHALCON_INIT_NVAR(not_exists);
			ZVAL_FALSE(not_exists);

			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:afterRenderView", 1);
				PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
			}
	
			break;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (PHALCON_IS_TRUE(not_exists)) {
	
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			phalcon_update_property_this_quick(this_ptr, SL("_activeRenderPath"), view_engine_path, 1528023309UL TSRMLS_CC);
	
			PHALCON_INIT_NVAR(event_name);
			ZVAL_STRING(event_name, "view:notFoundView", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
		if (!zend_is_true(silence)) {
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "View '", views_dir_path, "' was not found in the views directory");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
			return;
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View, registerEngines){

	zval *engines;

	phalcon_fetch_params(0, 1, 0, &engines);
	
	if (Z_TYPE_P(engines) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Engines to register must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_registeredEngines"), engines, 3326968731UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getRegisteredEngines) {

	RETURN_MEMBER(getThis(), "_registeredEngines")
}

static PHP_METHOD(Phalcon_Mvc_View, exists) {

	zval **view, *base_dir, *view_dir, *engines;
	HashPosition pos;
	zval *path;
	int exists = 0;

	phalcon_fetch_params_ex(1, 0, &view);
	PHALCON_ENSURE_IS_STRING(view);

	base_dir = phalcon_fetch_nproperty_this(getThis(), SL("_basePath"), PH_NOISY TSRMLS_CC);
	view_dir = phalcon_fetch_nproperty_this(getThis(), SL("_viewsDir"), PH_NOISY TSRMLS_CC);
	engines  = phalcon_fetch_nproperty_this(getThis(), SL("_registeredEngines"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(engines) != IS_ARRAY) {
		MAKE_STD_ZVAL(engines);
		array_init_size(engines, 1);
		add_assoc_stringl_ex(engines, SS(".phtml"), (char*)phalcon_mvc_view_engine_php_ce->name, phalcon_mvc_view_engine_php_ce->name_length, !IS_INTERNED(phalcon_mvc_view_engine_php_ce->name));
		phalcon_update_property_this(getThis(), SL("_registeredEngines"), engines TSRMLS_CC);
		assert(Z_REFCOUNT_P(engines) > 1);
		zval_ptr_dtor(&engines);
	}

	MAKE_STD_ZVAL(path);
	for (
		zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(engines), &pos);
		!exists && HASH_KEY_NON_EXISTANT != zend_hash_get_current_key_type_ex(Z_ARRVAL_P(engines), &pos);
		zend_hash_move_forward_ex(Z_ARRVAL_P(engines), &pos)
	) {
		zval ext = phalcon_get_current_key_w(Z_ARRVAL_P(engines), &pos);

		PHALCON_CONCAT_VVVV(path, base_dir, view_dir, *view, &ext);
		exists = (SUCCESS == phalcon_file_exists(path TSRMLS_CC));
		zval_dtor(path);
	}

	ZVAL_NULL(path);
	zval_ptr_dtor(&path);

	RETURN_BOOL(exists);
}

static PHP_METHOD(Phalcon_Mvc_View, render){

	zval *controller_name, *action_name, *params = NULL;
	zval *disabled, *contents = NULL, *layouts_dir = NULL, *layout;
	zval *layout_name = NULL, *engines = NULL, *pick_view, *render_view = NULL;
	zval *pick_view_action, *cache = NULL, *cache_level;
	zval *events_manager, *event_name = NULL, *status = NULL;
	zval *silence = NULL, *disabled_levels, *render_level;
	zval *templates_before, *template_before = NULL;
	zval *view_temp_path = NULL, *templates_after, *template_after = NULL;
	zval *main_view, *is_started = NULL, *is_fresh = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &controller_name, &action_name, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this(this_ptr, SL("_currentRenderLevel"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);

	PHALCON_OBS_VAR(disabled);
	phalcon_read_property_this(&disabled, this_ptr, SL("_disabled"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_NOT_FALSE(disabled)) {
		PHALCON_INIT_VAR(contents);
		phalcon_ob_get_contents(contents TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_content"), contents, 4081318271UL TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_controllerName"), controller_name, 3332183433UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_actionName"), action_name, 2975797059UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_params"), params, 3223731112UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(layouts_dir);
	phalcon_read_property_this(&layouts_dir, this_ptr, SL("_layoutsDir"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(layouts_dir)) {
		PHALCON_INIT_NVAR(layouts_dir);
		ZVAL_STRING(layouts_dir, "layouts/", 1);
	}
	
	PHALCON_OBS_VAR(layout);
	phalcon_read_property_this(&layout, this_ptr, SL("_layout"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(layout)) {
		PHALCON_CPY_WRT(layout_name, layout);
	} else {
		PHALCON_CPY_WRT(layout_name, controller_name);
	}
	
	PHALCON_CALL_METHOD(&engines, this_ptr, "_loadtemplateengines");
	
	PHALCON_OBS_VAR(pick_view);
	phalcon_read_property_this(&pick_view, this_ptr, SL("_pickView"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(pick_view) == IS_NULL) {
		PHALCON_INIT_VAR(render_view);
		PHALCON_CONCAT_VSV(render_view, controller_name, "/", action_name);
	} else {
		PHALCON_OBS_NVAR(render_view);
		phalcon_array_fetch_long(&render_view, pick_view, 0, PH_NOISY);
		if (phalcon_array_isset_long(pick_view, 1)) {
			PHALCON_OBS_VAR(pick_view_action);
			phalcon_array_fetch_long(&pick_view_action, pick_view, 1, PH_NOISY);
			PHALCON_CPY_WRT(layout_name, pick_view_action);
		}
	}
	
	PHALCON_OBS_VAR(cache_level);
	phalcon_read_property_this(&cache_level, this_ptr, SL("_cacheLevel"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(cache_level)) {
		PHALCON_CALL_METHOD(&cache, this_ptr, "getcache");
	}
	else {
		PHALCON_INIT_VAR(cache);
	}
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	
	phalcon_create_symbol_table(TSRMLS_C);
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "view:beforeRender", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_FALSE;
		}
	}
	
	PHALCON_INIT_NVAR(contents);
	phalcon_ob_get_contents(contents TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_content"), contents, 4081318271UL TSRMLS_CC);
	
	PHALCON_INIT_VAR(silence);
	ZVAL_BOOL(silence, 1);
	
	PHALCON_OBS_VAR(disabled_levels);
	phalcon_read_property_this(&disabled_levels, this_ptr, SL("_disabledLevels"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(render_level);
	phalcon_read_property_this(&render_level, this_ptr, SL("_renderLevel"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(render_level)) {
	
		if (PHALCON_GE_LONG(render_level, 1)) {
			if (!phalcon_array_isset_long(disabled_levels, 1)) {
				phalcon_update_property_long(this_ptr, SL("_currentRenderLevel"), 1 TSRMLS_CC);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, render_view, silence, PHALCON_GLOBAL(z_true), cache);
			}
		}
	
		if (PHALCON_GE_LONG(render_level, 2)) {
			if (!phalcon_array_isset_long(disabled_levels, 2)) {
				phalcon_update_property_long(this_ptr, SL("_currentRenderLevel"), 2 TSRMLS_CC);
	
				PHALCON_OBS_VAR(templates_before);
				phalcon_read_property_this(&templates_before, this_ptr, SL("_templatesBefore"), PH_NOISY TSRMLS_CC);
	
				if (Z_TYPE_P(templates_before) == IS_ARRAY) { 
	
					ZVAL_BOOL(silence, 0);
	
					phalcon_is_iterable(templates_before, &ah0, &hp0, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
						PHALCON_GET_HVALUE(template_before);
	
						PHALCON_INIT_NVAR(view_temp_path);
						PHALCON_CONCAT_VV(view_temp_path, layouts_dir, template_before);
						PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, view_temp_path, silence, PHALCON_GLOBAL(z_true), cache);
	
						zend_hash_move_forward_ex(ah0, &hp0);
					}
	
					PHALCON_INIT_NVAR(silence);
					ZVAL_BOOL(silence, 1);
				}
			}
		}
	
		if (PHALCON_GE_LONG(render_level, 3)) {
			if (!phalcon_array_isset_long(disabled_levels, 3)) {
				phalcon_update_property_long(this_ptr, SL("_currentRenderLevel"), 3 TSRMLS_CC);

				PHALCON_INIT_NVAR(view_temp_path);
				PHALCON_CONCAT_VV(view_temp_path, layouts_dir, layout_name);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, view_temp_path, silence, PHALCON_GLOBAL(z_true), cache);
			}
		}
	
		if (PHALCON_GE_LONG(render_level, 4)) {
			if (!phalcon_array_isset_long(disabled_levels, 4)) {
				phalcon_update_property_long(this_ptr, SL("_currentRenderLevel"), 4 TSRMLS_CC);
	
				PHALCON_OBS_VAR(templates_after);
				phalcon_read_property_this(&templates_after, this_ptr, SL("_templatesAfter"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(templates_after) == IS_ARRAY) { 
	
					PHALCON_INIT_NVAR(silence);
					ZVAL_BOOL(silence, 0);
	
					phalcon_is_iterable(templates_after, &ah1, &hp1, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
						PHALCON_GET_HVALUE(template_after);
	
						PHALCON_INIT_NVAR(view_temp_path);
						PHALCON_CONCAT_VV(view_temp_path, layouts_dir, template_after);
						PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, view_temp_path, silence, PHALCON_GLOBAL(z_true), cache);
	
						zend_hash_move_forward_ex(ah1, &hp1);
					}
	
					PHALCON_INIT_NVAR(silence);
					ZVAL_BOOL(silence, 1);
				}
			}
		}
	
		if (PHALCON_GE_LONG(render_level, 5)) {
			if (!phalcon_array_isset_long(disabled_levels, 5)) {
				phalcon_update_property_long(this_ptr, SL("_currentRenderLevel"), 5 TSRMLS_CC);

				PHALCON_OBS_VAR(main_view);
				phalcon_read_property_this(&main_view, this_ptr, SL("_mainView"), PH_NOISY TSRMLS_CC);
				PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, main_view, silence, PHALCON_GLOBAL(z_true), cache);
			}
		}

		phalcon_update_property_this(this_ptr, SL("_currentRenderLevel"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);
	
		if (Z_TYPE_P(cache) == IS_OBJECT) {
			PHALCON_CALL_METHOD(&is_started, cache, "isstarted");
			if (PHALCON_IS_TRUE(is_started)) {
				PHALCON_CALL_METHOD(&is_fresh, cache, "isfresh");
				if (PHALCON_IS_TRUE(is_fresh)) {
					PHALCON_CALL_METHOD(NULL, cache, "save");
				} else {
					PHALCON_CALL_METHOD(NULL, cache, "stop");
				}
			} else {
				PHALCON_CALL_METHOD(NULL, cache, "stop");
			}
		}
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "view:afterRender", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, pick){

	zval *render_view, *pick_view = NULL, *layout = NULL, *parts;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &render_view);
	
	if (Z_TYPE_P(render_view) == IS_ARRAY) { 
		PHALCON_CPY_WRT(pick_view, render_view);
	} else {
		PHALCON_INIT_VAR(layout);
		if (phalcon_memnstr_str(render_view, SL("/"))) {
			PHALCON_INIT_VAR(parts);
			phalcon_fast_explode_str(parts, SL("/"), render_view);
	
			PHALCON_OBS_NVAR(layout);
			phalcon_array_fetch_long(&layout, parts, 0, PH_NOISY);
		}
	
		PHALCON_INIT_NVAR(pick_view);
		array_init_size(pick_view, 2);
		phalcon_array_append(&pick_view, render_view, 0);
		if (Z_TYPE_P(layout) != IS_NULL) {
			phalcon_array_append(&pick_view, layout, 0);
		}
	}
	phalcon_update_property_this_quick(this_ptr, SL("_pickView"), pick_view, 1471709510UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, partial){

	zval *partial_path, *params = NULL, *view_params, *new_params = NULL;
	zval *partials_dir, *real_path, *engines = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &partial_path, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(view_params);
		phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(view_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(new_params);
			phalcon_fast_array_merge(new_params, &view_params, &params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(new_params, params);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), new_params, 1685283331UL TSRMLS_CC);
	
		phalcon_create_symbol_table(TSRMLS_C);
	
	}
	
	PHALCON_OBS_VAR(partials_dir);
	phalcon_read_property_this(&partials_dir, this_ptr, SL("_partialsDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(real_path);
	PHALCON_CONCAT_VV(real_path, partials_dir, partial_path);
	
	PHALCON_CALL_METHOD(&engines, this_ptr, "_loadtemplateengines");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "_enginerender", engines, real_path, PHALCON_GLOBAL(z_false), PHALCON_GLOBAL(z_false), PHALCON_GLOBAL(z_false));
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), view_params, 1685283331UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View, getRender){

	zval *controller_name, *action_name, *params = NULL;
	zval *config_callback = NULL, *view, *status;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 2, &controller_name, &action_name, &params, &config_callback);
	
	if (!params) {
		PHALCON_INIT_VAR(params);
	} else {
		PHALCON_SEPARATE_PARAM(params);
	}
	
	if (!config_callback) {
		config_callback = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(view);
	if (phalcon_clone(view, this_ptr TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(NULL, view, "reset");
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(NULL, view, "setvars", params);
	}
	
	if (Z_TYPE_P(config_callback) == IS_OBJECT) {
		PHALCON_INIT_NVAR(params);
		array_init_size(params, 1);
		phalcon_array_append(&params, view, 0);
	
		PHALCON_INIT_VAR(status);/**/
		PHALCON_CALL_USER_FUNC_ARRAY(status, config_callback, params);
	}
	
	PHALCON_CALL_METHOD(NULL, view, "start");
	
	PHALCON_CALL_METHOD(NULL, view, "render", controller_name, action_name);
	
	phalcon_ob_end_clean(TSRMLS_C);
	
	PHALCON_RETURN_CALL_METHOD(view, "getcontent");
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View, finish){

	phalcon_ob_end_clean(TSRMLS_C);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, _createCache){

	zval *dependency_injector, *cache_service = NULL;
	zval *view_options, *cache_options, *view_cache = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the view cache services");
		return;
	}
	
	PHALCON_INIT_VAR(cache_service);
	ZVAL_STRING(cache_service, "viewCache", 1);
	
	PHALCON_OBS_VAR(view_options);
	phalcon_read_property_this(&view_options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(view_options) == IS_ARRAY) { 
		if (phalcon_array_isset_quick_string(view_options, SS("cache"), 4125168857UL)) {
	
			PHALCON_OBS_VAR(cache_options);
			phalcon_array_fetch_quick_string(&cache_options, view_options, SS("cache"), 4125168857UL, PH_NOISY);
			if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
				if (phalcon_array_isset_quick_string(cache_options, SS("service"), 243174486UL)) {
					PHALCON_OBS_NVAR(cache_service);
					phalcon_array_fetch_quick_string(&cache_service, cache_options, SS("service"), 243174486UL, PH_NOISY);
				}
			}
		}
	}
	
	PHALCON_CALL_METHOD(&view_cache, dependency_injector, "getshared", cache_service);
	if (Z_TYPE_P(view_cache) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The injected caching service is invalid");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(view_cache, phalcon_cache_backendinterface_ce);
	RETURN_CCTOR(view_cache);
}

static PHP_METHOD(Phalcon_Mvc_View, isCaching){

	zval *z_zero, *cache_level;

	z_zero = PHALCON_GLOBAL(z_zero);
	
	cache_level = phalcon_fetch_nproperty_this(this_ptr, SL("_cacheLevel"), PH_NOISY TSRMLS_CC);
	is_smaller_function(return_value, z_zero, cache_level TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_View, getCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(cache);
	phalcon_read_property_this(&cache, this_ptr, SL("_cache"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(cache)) {
		if (Z_TYPE_P(cache) != IS_OBJECT) {
			PHALCON_CALL_METHOD(&cache, this_ptr, "_createcache");
			phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
		}
	} else {
		PHALCON_CALL_METHOD(&cache, this_ptr, "_createcache");
		phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
	}
	
	RETURN_CCTOR(cache);
}

static PHP_METHOD(Phalcon_Mvc_View, cache){

	zval *options = NULL, *view_options = NULL, *cache_options = NULL;
	zval *value = NULL, *key = NULL, *cache_level;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(view_options);
		phalcon_read_property_this(&view_options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(view_options) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(view_options);
			array_init(view_options);
		}
	
		if (phalcon_array_isset_quick_string(view_options, SS("cache"), 4125168857UL)) {
			PHALCON_OBS_VAR(cache_options);
			phalcon_array_fetch_quick_string(&cache_options, view_options, SS("cache"), 4125168857UL, PH_NOISY);
		} else {
			PHALCON_INIT_NVAR(cache_options);
			array_init(cache_options);
		}
	
		phalcon_is_iterable(options, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);
	
			phalcon_array_update_zval(&cache_options, key, value, PH_COPY | PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (phalcon_array_isset_quick_string(cache_options, SS("level"), 187843549UL)) {
			PHALCON_OBS_VAR(cache_level);
			phalcon_array_fetch_quick_string(&cache_level, cache_options, SS("level"), 187843549UL, PH_NOISY);
			phalcon_update_property_this_quick(this_ptr, SL("_cacheLevel"), cache_level, 3155415824UL TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		}
	
		phalcon_array_update_string(&view_options, SL("cache"), cache_options, PH_COPY | PH_SEPARATE);
		phalcon_update_property_this_quick(this_ptr, SL("_options"), view_options, 1620153008UL TSRMLS_CC);
	} else {
		if (zend_is_true(options)) {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 5 TSRMLS_CC);
		} else {
			phalcon_update_property_long(this_ptr, SL("_cacheLevel"), 0 TSRMLS_CC);
		}
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View, setContent){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	if (Z_TYPE_P(content) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Content must be a string");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_content"), content, 4081318271UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, getContent){


	RETURN_MEMBER_QUICK(this_ptr, "_content", 4081318271UL);
}

static PHP_METHOD(Phalcon_Mvc_View, getActiveRenderPath){


	RETURN_MEMBER_QUICK(this_ptr, "_activeRenderPath", 1528023309UL);
}

static PHP_METHOD(Phalcon_Mvc_View, disable){


	phalcon_update_property_bool(this_ptr, SL("_disabled"), 1 TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, enable){


	phalcon_update_property_bool(this_ptr, SL("_disabled"), 0 TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, isDisabled){

	RETURN_MEMBER_QUICK(this_ptr, "_disabled", 2601399228UL);
}


static PHP_METHOD(Phalcon_Mvc_View, reset){

	zval *z_null  = PHALCON_GLOBAL(z_null);
	zval *z_false = PHALCON_GLOBAL(z_false);
	zval *z_zero  = PHALCON_GLOBAL(z_zero);

	phalcon_update_property_this_quick(this_ptr, SL("_disabled"), z_false, 2601399228UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_engines"), z_false, 1840711053UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_cache"), z_null, 2191407384UL TSRMLS_CC);
	phalcon_update_property_long(this_ptr, SL("_renderLevel"), 5 TSRMLS_CC);
	phalcon_update_property_zval(this_ptr, SL("_cacheLevel"), z_zero TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_content"), z_null, 4081318271UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_templatesBefore"), z_null, 3273177030UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_templatesAfter"), z_null, 3575793989UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View, __set){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View, __get){

	zval *key, *params, *value;

	phalcon_fetch_params(0, 1, 0, &key);
	
	params = phalcon_fetch_nproperty_this(this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, params, key)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_NULL();
}


static PHP_METHOD(Phalcon_Mvc_View, __isset){

	zval *key, *params;

	phalcon_fetch_params(0, 1, 0, &key);

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(params, key)) {
		RETURN_TRUE;
	}

	RETURN_FALSE;
}





zend_class_entry *phalcon_mvc_viewinterface_ce;

static const zend_function_entry phalcon_mvc_viewinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setViewsDir, arginfo_phalcon_mvc_viewinterface_setviewsdir)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getViewsDir, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setLayoutsDir, arginfo_phalcon_mvc_viewinterface_setlayoutsdir)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getLayoutsDir, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setPartialsDir, arginfo_phalcon_mvc_viewinterface_setpartialsdir)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getPartialsDir, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setBasePath, arginfo_phalcon_mvc_viewinterface_setbasepath)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getCurrentRenderLevel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getRenderLevel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setRenderLevel, arginfo_phalcon_mvc_viewinterface_setrenderlevel)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setMainView, arginfo_phalcon_mvc_viewinterface_setmainview)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getMainView, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setLayout, arginfo_phalcon_mvc_viewinterface_setlayout)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getLayout, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setTemplateBefore, arginfo_phalcon_mvc_viewinterface_settemplatebefore)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, cleanTemplateBefore, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setTemplateAfter, arginfo_phalcon_mvc_viewinterface_settemplateafter)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, cleanTemplateAfter, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setParamToView, arginfo_phalcon_mvc_viewinterface_setparamtoview)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setVar, arginfo_phalcon_mvc_viewinterface_setvar)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getParamsToView, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getControllerName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getActionName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getParams, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, start, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, registerEngines, arginfo_phalcon_mvc_viewinterface_registerengines)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, render, arginfo_phalcon_mvc_viewinterface_render)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, pick, arginfo_phalcon_mvc_viewinterface_pick)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, partial, arginfo_phalcon_mvc_viewinterface_partial)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, finish, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getCache, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, cache, arginfo_phalcon_mvc_viewinterface_cache)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, setContent, arginfo_phalcon_mvc_viewinterface_setcontent)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getContent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, getActiveRenderPath, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, disable, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, enable, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, reset, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_ViewInterface, isDisabled, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_ViewInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc, ViewInterface, mvc_viewinterface, phalcon_mvc_viewinterface_method_entry);

	return SUCCESS;
}













































zend_class_entry *phalcon_mvc_application_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Application_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Application, Exception, mvc_application_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_collection_document_ce;

static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetExists);
static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetGet);
static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetSet);
static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetUnset);
static PHP_METHOD(Phalcon_Mvc_Collection_Document, readAttribute);
static PHP_METHOD(Phalcon_Mvc_Collection_Document, writeAttribute);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_offsetexists, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_offsetget, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_offsetset, 0, 0, 2)
	ZEND_ARG_INFO(0, index)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_offsetunset, 0, 0, 1)
	ZEND_ARG_INFO(0, offset)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_readattribute, 0, 0, 1)
	ZEND_ARG_INFO(0, attribute)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_document_writeattribute, 0, 0, 2)
	ZEND_ARG_INFO(0, attribute)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_collection_document_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Collection_Document, offsetExists, arginfo_phalcon_mvc_collection_document_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Document, offsetGet, arginfo_phalcon_mvc_collection_document_offsetget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Document, offsetSet, arginfo_phalcon_mvc_collection_document_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Document, offsetUnset, arginfo_phalcon_mvc_collection_document_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Document, readAttribute, arginfo_phalcon_mvc_collection_document_readattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Document, writeAttribute, arginfo_phalcon_mvc_collection_document_writeattribute, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Document){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Collection, Document, mvc_collection_document, phalcon_mvc_collection_document_method_entry, 0);

	zend_class_implements(phalcon_mvc_collection_document_ce TSRMLS_CC, 1, zend_ce_arrayaccess);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetExists){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	
	if (phalcon_isset_property_zval(this_ptr, index TSRMLS_CC)) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetGet){

	zval *index, *value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &index);
	
	if (phalcon_isset_property_zval(this_ptr, index TSRMLS_CC)) {
		PHALCON_OBS_VAR(value);
		phalcon_read_property_zval(&value, this_ptr, index, PH_NOISY TSRMLS_CC);
		RETURN_CTOR(value);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "The index does not exist in the row");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetSet){

	zval *index, *value;

	phalcon_fetch_params(0, 2, 0, &index, &value);
	
	phalcon_update_property_zval_zval(this_ptr, index, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, offsetUnset){

	zval *offset;

	phalcon_fetch_params(0, 1, 0, &offset);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_collection_exception_ce, "The index does not exist in the row");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, readAttribute){

	zval *attribute, *attribute_value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &attribute);
	
	if (phalcon_isset_property_zval(this_ptr, attribute TSRMLS_CC)) {
		PHALCON_OBS_VAR(attribute_value);
		phalcon_read_property_zval(&attribute_value, this_ptr, attribute, PH_NOISY TSRMLS_CC);
		RETURN_CTOR(attribute_value);
	}
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Document, writeAttribute){

	zval *attribute, *value;

	phalcon_fetch_params(0, 2, 0, &attribute, &value);
	
	phalcon_update_property_zval_zval(this_ptr, attribute, value TSRMLS_CC);
	
}





zend_class_entry *phalcon_mvc_collection_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Collection, Exception, mvc_collection_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_collection_manager_ce;

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setDI);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getDI);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setCustomEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getCustomEventsManager);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, initialize);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, isInitialized);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getLastInitialized);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setConnectionService);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, useImplicitObjectIds);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, isUsingImplicitObjectIds);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getConnection);
static PHP_METHOD(Phalcon_Mvc_Collection_Manager, notifyEvent);

static const zend_function_entry phalcon_mvc_collection_manager_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Collection_Manager, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, setCustomEventsManager, arginfo_phalcon_mvc_collection_managerinterface_setcustomeventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, getCustomEventsManager, arginfo_phalcon_mvc_collection_managerinterface_getcustomeventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, initialize, arginfo_phalcon_mvc_collection_managerinterface_initialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, isInitialized, arginfo_phalcon_mvc_collection_managerinterface_isinitialized, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, getLastInitialized, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, setConnectionService, arginfo_phalcon_mvc_collection_managerinterface_setconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, useImplicitObjectIds, arginfo_phalcon_mvc_collection_managerinterface_useimplicitobjectids, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, isUsingImplicitObjectIds, arginfo_phalcon_mvc_collection_managerinterface_isusingimplicitobjectids, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, getConnection, arginfo_phalcon_mvc_collection_managerinterface_getconnection, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Manager, notifyEvent, arginfo_phalcon_mvc_collection_managerinterface_notifyevent, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Collection, Manager, mvc_collection_manager, phalcon_mvc_collection_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_initialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_lastInitialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_customEventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_connectionServices"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_manager_ce, SL("_implicitObjectsIds"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_collection_manager_ce TSRMLS_CC, 3, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce, phalcon_mvc_collection_managerinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_collection_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setCustomEventsManager){

	zval *model, *events_manager, *class_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &events_manager);
	PHALCON_VERIFY_INTERFACE_EX(model, phalcon_mvc_collectioninterface_ce, phalcon_mvc_collection_exception_ce, 1);
	PHALCON_VERIFY_INTERFACE_OR_NULL_EX(events_manager, phalcon_events_managerinterface_ce, phalcon_mvc_collection_exception_ce, 1);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_customEventsManager"), class_name, events_manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getCustomEventsManager){

	zval *model, *custom_events_manager, *class_name;
	zval *events_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	custom_events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_customEventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(custom_events_manager) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset_fetch(&events_manager, custom_events_manager, class_name)) {
			RETURN_CTOR(events_manager);
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, initialize){

	zval *model, *class_name, *initialized, *events_manager;
	zval *event_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	if (!phalcon_array_isset(initialized, class_name)) {
	
		if (phalcon_method_quick_exists_ex(model, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
			PHALCON_CALL_METHOD(NULL, model, "initialize");
		}
	
		PHALCON_OBS_VAR(events_manager);
		phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(events_manager) == IS_OBJECT) {
			PHALCON_INIT_VAR(event_name);
			ZVAL_STRING(event_name, "collectionManager:afterInitialize", 1);
			PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
		}
	
		phalcon_update_property_array(this_ptr, SL("_initialized"), class_name, model TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_lastInitialized"), model, 1491101038UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, isInitialized){

	zval *model_name, *initialized, *lowercased;

	phalcon_fetch_params(0, 1, 0, &model_name);
	
	initialized = phalcon_fetch_nproperty_this(this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	ALLOC_INIT_ZVAL(lowercased);
	phalcon_fast_strtolower(lowercased, model_name);
	
	RETVAL_BOOL(phalcon_array_isset(initialized, lowercased));
	zval_ptr_dtor(&lowercased);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getLastInitialized){


	RETURN_MEMBER_QUICK(this_ptr, "_lastInitialized", 1491101038UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, setConnectionService){

	zval *model, *connection_service, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &connection_service);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A valid collection instance is required");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_connectionServices"), entity_name, connection_service TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, useImplicitObjectIds){

	zval *model, *use_implicit_object_ids, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &use_implicit_object_ids);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A valid collection instance is required");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_implicitObjectsIds"), entity_name, use_implicit_object_ids TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, isUsingImplicitObjectIds){

	zval *model, *entity_name, *implicit_objects_ids;
	zval *implicit;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A valid collection instance is required");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(implicit_objects_ids);
	phalcon_read_property_this(&implicit_objects_ids, this_ptr, SL("_implicitObjectsIds"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&implicit, implicit_objects_ids, entity_name)) {
		RETURN_CTOR(implicit);
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, getConnection){

	zval *model, *service = NULL, *connection_services;
	zval *entity_name, *dependency_injector, *connection = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A valid collection instance is required");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "mongo", 1);
	
	PHALCON_OBS_VAR(connection_services);
	phalcon_read_property_this(&connection_services, this_ptr, SL("_connectionServices"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection_services) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
		if (phalcon_array_isset(connection_services, entity_name)) {
			PHALCON_OBS_NVAR(service);
			phalcon_array_fetch(&service, connection_services, entity_name, PH_NOISY);
		}
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_CALL_METHOD(&connection, dependency_injector, "getshared", service);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_collection_exception_ce, "Invalid injected connection service");
		return;
	}
	
	/* PHALCON_VERIFY_INTERFACE(connection, phalcon_db_adapterinterface_ce); */
	RETURN_CCTOR(connection);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Manager, notifyEvent){

	zval *event_name, *model, *status = NULL, *events_manager;
	zval *fire_event_name = NULL, *custom_events_manager;
	zval *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &event_name, &model);
	
	PHALCON_INIT_VAR(status);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "collection:", event_name);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", fire_event_name, model);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_CCTOR(status);
		}
	}
	
	PHALCON_OBS_VAR(custom_events_manager);
	phalcon_read_property_this(&custom_events_manager, this_ptr, SL("_customEventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(custom_events_manager) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(custom_events_manager, entity_name)) {
	
			PHALCON_INIT_NVAR(fire_event_name);
			PHALCON_CONCAT_SV(fire_event_name, "collection:", event_name);
	
			PHALCON_CALL_METHOD(&status, custom_events_manager, "fire", fire_event_name, model);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_CCTOR(status);
			}
		}
	}
	
	RETURN_CCTOR(status);
}






zend_class_entry *phalcon_mvc_collection_managerinterface_ce;

static const zend_function_entry phalcon_mvc_collection_managerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, setCustomEventsManager, arginfo_phalcon_mvc_collection_managerinterface_setcustomeventsmanager)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, getCustomEventsManager, arginfo_phalcon_mvc_collection_managerinterface_getcustomeventsmanager)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, initialize, arginfo_phalcon_mvc_collection_managerinterface_initialize)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, isInitialized, arginfo_phalcon_mvc_collection_managerinterface_isinitialized)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, getLastInitialized, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, setConnectionService, arginfo_phalcon_mvc_collection_managerinterface_setconnectionservice)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, useImplicitObjectIds, arginfo_phalcon_mvc_collection_managerinterface_useimplicitobjectids)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, isUsingImplicitObjectIds, arginfo_phalcon_mvc_collection_managerinterface_isusingimplicitobjectids)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, getConnection, arginfo_phalcon_mvc_collection_managerinterface_getconnection)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_ManagerInterface, notifyEvent, arginfo_phalcon_mvc_collection_managerinterface_notifyevent)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Collection, ManagerInterface, mvc_collection_managerinterface, phalcon_mvc_collection_managerinterface_method_entry);

	return SUCCESS;
}

















zend_class_entry *phalcon_mvc_collection_message_ce;

static PHP_METHOD(Phalcon_Mvc_Collection_Message, __construct);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, setType);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, getType);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, setCode);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, getCode);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, setMessage);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, getMessage);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, setField);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, getField);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, setCollection);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, getCollection);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, __toString);
static PHP_METHOD(Phalcon_Mvc_Collection_Message, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_message___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
	ZEND_ARG_INFO(0, field)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_message_setcollection, 0, 0, 1)
	ZEND_ARG_INFO(0, collection)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_collection_message_setcode, 0, 0, 1)
	ZEND_ARG_INFO(0, code)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_collection_message_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Collection_Message, __construct, arginfo_phalcon_mvc_collection_message___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Collection_Message, setType, arginfo_phalcon_mvc_collection_messageinterface_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, setCode, arginfo_phalcon_mvc_collection_message_setcode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, getCode, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, setMessage, arginfo_phalcon_mvc_collection_messageinterface_setmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, getMessage, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, setField, arginfo_phalcon_mvc_collection_messageinterface_setfield, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, getField, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, setCollection, arginfo_phalcon_mvc_collection_message_setcollection, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, getCollection, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, __toString, arginfo___tostring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Collection_Message, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_Message){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Collection, Message, mvc_collection_message, phalcon_mvc_collection_message_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_collection_message_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_message_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_message_ce, SL("_field"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_collection_message_ce, SL("_collection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_collection_message_ce, SL("_code"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_collection_message_ce TSRMLS_CC, 1, phalcon_mvc_collection_messageinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, __construct){

	zval *message, *field = NULL, *type = NULL, *collection = NULL, *code = NULL;

	phalcon_fetch_params(0, 1, 4, &message, &field, &type, &code, &collection);
	
	if (!field) {
		field = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	if (!collection) {
		collection = PHALCON_GLOBAL(z_null);
	}

	if (!code) {
		code = PHALCON_GLOBAL(z_zero);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	if (Z_TYPE_P(collection) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_collection"), collection, 4106104656UL TSRMLS_CC);
	}
	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, setType){

	zval *type;

	phalcon_fetch_params(0, 1, 0, &type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, setCode){

	zval *code;

	phalcon_fetch_params(0, 1, 0, &code);

	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, getCode){

	RETURN_MEMBER_QUICK(this_ptr, "_code", 3971426015UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, setMessage){

	zval *message;

	phalcon_fetch_params(0, 1, 0, &message);
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, getMessage){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, setField){

	zval *field;

	phalcon_fetch_params(0, 1, 0, &field);
	
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, getField){


	RETURN_MEMBER_QUICK(this_ptr, "_field", 2318377128UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, setCollection){

	zval *collection;

	phalcon_fetch_params(0, 1, 0, &collection);
	
	phalcon_update_property_this_quick(this_ptr, SL("_collection"), collection, 4106104656UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, getCollection){


	RETURN_MEMBER_QUICK(this_ptr, "_collection", 4106104656UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Mvc_Collection_Message, __set_state){

	zval *message, *message_text, *field, *type, *code;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	PHALCON_OBS_VAR(message_text);
	phalcon_array_fetch_quick_string(&message_text, message, SS("_message"), 933579817UL, PH_NOISY);

	PHALCON_OBS_VAR(field);
	phalcon_array_fetch_quick_string(&field, message, SS("_field"), 2318377128UL, PH_NOISY);

	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, message, SS("_type"), 3991959110UL, PH_NOISY);

	PHALCON_OBS_VAR(code);
	phalcon_array_fetch_quick_string(&code, message, SS("_code"), 3971426015UL, PH_NOISY);

	object_init_ex(return_value, phalcon_mvc_collection_message_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", message_text, field, type, code);
	
	RETURN_MM();
}






zend_class_entry *phalcon_mvc_collection_messageinterface_ce;

static const zend_function_entry phalcon_mvc_collection_messageinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, setType, arginfo_phalcon_mvc_collection_messageinterface_settype)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, setMessage, arginfo_phalcon_mvc_collection_messageinterface_setmessage)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, getMessage, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, setField, arginfo_phalcon_mvc_collection_messageinterface_setfield)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Collection_MessageInterface, getField, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Collection_MessageInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Collection, MessageInterface, mvc_collection_messageinterface, phalcon_mvc_collection_messageinterface_method_entry);

	return SUCCESS;
}











zend_class_entry *phalcon_mvc_dispatcher_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Dispatcher_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Dispatcher, Exception, mvc_dispatcher_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_micro_collection_ce;

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setPrefix);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getPrefix);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getHandlers);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setHandler);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setLazy);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, isLazy);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getHandler);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, map);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, get);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, post);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, put);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, patch);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, head);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, delete);
static PHP_METHOD(Phalcon_Mvc_Micro_Collection, options);

static const zend_function_entry phalcon_mvc_micro_collection_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Micro_Collection, setPrefix, arginfo_phalcon_mvc_micro_collectioninterface_setprefix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, getPrefix, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, getHandlers, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, setHandler, arginfo_phalcon_mvc_micro_collectioninterface_sethandler, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, setLazy, arginfo_phalcon_mvc_micro_collectioninterface_setlazy, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, isLazy, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, getHandler, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, map, arginfo_phalcon_mvc_micro_collectioninterface_map, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, get, arginfo_phalcon_mvc_micro_collectioninterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, post, arginfo_phalcon_mvc_micro_collectioninterface_post, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, put, arginfo_phalcon_mvc_micro_collectioninterface_put, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, patch, arginfo_phalcon_mvc_micro_collectioninterface_patch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, head, arginfo_phalcon_mvc_micro_collectioninterface_head, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, delete, arginfo_phalcon_mvc_micro_collectioninterface_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Micro_Collection, options, arginfo_phalcon_mvc_micro_collectioninterface_options, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_Collection){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Micro, Collection, mvc_micro_collection, phalcon_mvc_micro_collection_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_micro_collection_ce, SL("_prefix"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_collection_ce, SL("_lazy"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_collection_ce, SL("_handler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_collection_ce, SL("_handlers"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_micro_collection_ce TSRMLS_CC, 1, phalcon_mvc_micro_collectioninterface_ce);

	return SUCCESS;
}

static void phalcon_mvc_collection_addmap(zval *this_ptr, const char *method, zval *route_pattern, zval *handler, zval *name TSRMLS_DC)
{
	zval *handler_definition;
	zval *z_method;

	MAKE_STD_ZVAL(z_method);
	if (method) {
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(z_method, method);
	}
	else {
		ZVAL_NULL(z_method);
	}

	Z_ADDREF_P(route_pattern);
	Z_ADDREF_P(handler);

	PHALCON_ALLOC_GHOST_ZVAL(handler_definition);
	array_init_size(handler_definition, 3 + (name != NULL ? 1 : 0));
	add_next_index_zval(handler_definition, z_method);
	add_next_index_zval(handler_definition, route_pattern);
	add_next_index_zval(handler_definition, handler);
	if (name) {
		Z_ADDREF_P(name);
		add_next_index_zval(handler_definition, name);
	}
	else {
		add_next_index_null(handler_definition);
	}

	phalcon_update_property_array_append(this_ptr, SL("_handlers"), handler_definition TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setPrefix){

	zval *prefix;

	phalcon_fetch_params(0, 1, 0, &prefix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getPrefix){


	RETURN_MEMBER_QUICK(this_ptr, "_prefix", 3873791314UL);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getHandlers){


	RETURN_MEMBER_QUICK(this_ptr, "_handlers", 2445210229UL);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setHandler){

	zval *handler, *lazy = NULL;

	phalcon_fetch_params(0, 1, 1, &handler, &lazy);
	
	if (!lazy) {
		lazy = PHALCON_GLOBAL(z_false);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_handler"), handler, 1505752930UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_lazy"), lazy, 3981620804UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, setLazy){

	zval *lazy;

	phalcon_fetch_params(0, 1, 0, &lazy);
	
	phalcon_update_property_this_quick(this_ptr, SL("_lazy"), lazy, 3981620804UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, isLazy){


	RETURN_MEMBER_QUICK(this_ptr, "_lazy", 3981620804UL);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, getHandler){


	RETURN_MEMBER_QUICK(this_ptr, "_handler", 1505752930UL);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, map){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 1, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), NULL, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, get){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 1, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_GET, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, post){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_POST, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, put){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_PUT, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, patch){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_PATCH, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, head){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_HEAD, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, delete){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_DELETE, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Micro_Collection, options){

	zval *route_pattern, *handler, *name = NULL;

	phalcon_fetch_params(0, 2, 0, &route_pattern, &handler, &name);
	
	phalcon_mvc_collection_addmap(getThis(), phalcon_interned_OPTIONS, route_pattern, handler, name TSRMLS_CC);
	RETURN_ZVAL(getThis(), 1, 0);
}





zend_class_entry *phalcon_mvc_micro_collectioninterface_ce;

static const zend_function_entry phalcon_mvc_micro_collectioninterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, setPrefix, arginfo_phalcon_mvc_micro_collectioninterface_setprefix)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, getPrefix, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, getHandlers, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, setHandler, arginfo_phalcon_mvc_micro_collectioninterface_sethandler)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, setLazy, arginfo_phalcon_mvc_micro_collectioninterface_setlazy)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, isLazy, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, getHandler, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, map, arginfo_phalcon_mvc_micro_collectioninterface_map)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, get, arginfo_phalcon_mvc_micro_collectioninterface_get)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, post, arginfo_phalcon_mvc_micro_collectioninterface_post)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, put, arginfo_phalcon_mvc_micro_collectioninterface_put)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, patch, arginfo_phalcon_mvc_micro_collectioninterface_patch)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, head, arginfo_phalcon_mvc_micro_collectioninterface_head)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, delete, arginfo_phalcon_mvc_micro_collectioninterface_delete)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_CollectionInterface, options, arginfo_phalcon_mvc_micro_collectioninterface_options)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_CollectionInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Micro, CollectionInterface, mvc_micro_collectioninterface, phalcon_mvc_micro_collectioninterface_method_entry);

	return SUCCESS;
}





















zend_class_entry *phalcon_mvc_micro_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Micro, Exception, mvc_micro_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_micro_lazyloader_ce;

static PHP_METHOD(Phalcon_Mvc_Micro_LazyLoader, __construct);
static PHP_METHOD(Phalcon_Mvc_Micro_LazyLoader, __call);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_lazyloader___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_micro_lazyloader___call, 0, 0, 2)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_micro_lazyloader_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Micro_LazyLoader, __construct, arginfo_phalcon_mvc_micro_lazyloader___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Micro_LazyLoader, __call, arginfo_phalcon_mvc_micro_lazyloader___call, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_LazyLoader){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Micro, LazyLoader, mvc_micro_lazyloader, phalcon_mvc_micro_lazyloader_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_micro_lazyloader_ce, SL("_handler"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_micro_lazyloader_ce, SL("_definition"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Micro_LazyLoader, __construct){

	zval **definition;

	phalcon_fetch_params_ex(1, 0, &definition);
	PHALCON_ENSURE_IS_STRING(definition);
	
	phalcon_update_property_this(this_ptr, SL("_definition"), *definition TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Micro_LazyLoader, __call){

	zval *method, *arguments, *handler = NULL, *definition;
	zval *call_handler;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &method, &arguments);
	
	PHALCON_OBS_VAR(handler);
	phalcon_read_property_this(&handler, this_ptr, SL("_handler"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(handler) != IS_OBJECT) {
		PHALCON_OBS_VAR(definition);
		phalcon_read_property_this(&definition, this_ptr, SL("_definition"), PH_NOISY TSRMLS_CC);
		ce0 = phalcon_fetch_class(definition TSRMLS_CC);
	
		PHALCON_INIT_NVAR(handler);
		object_init_ex(handler, ce0);
		if (phalcon_has_constructor(handler TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, handler, "__construct");
		}
		phalcon_update_property_this_quick(this_ptr, SL("_handler"), handler, 1505752930UL TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(call_handler);
	array_init_size(call_handler, 2);
	phalcon_array_append(&call_handler, handler, 0);
	phalcon_array_append(&call_handler, method, 0);
	
	PHALCON_CALL_USER_FUNC_ARRAY(return_value, call_handler, arguments);
	RETURN_MM();
}





zend_class_entry *phalcon_mvc_micro_middlewareinterface_ce;

static const zend_function_entry phalcon_mvc_micro_middlewareinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Micro_MiddlewareInterface, call, arginfo_phalcon_mvc_micro_middlewareinterface_call)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Micro_MiddlewareInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Micro, MiddlewareInterface, mvc_micro_middlewareinterface, phalcon_mvc_micro_middlewareinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_mvc_model_behavior_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Behavior, mustTakeAction);
static PHP_METHOD(Phalcon_Mvc_Model_Behavior, getOptions);
static PHP_METHOD(Phalcon_Mvc_Model_Behavior, notify);
static PHP_METHOD(Phalcon_Mvc_Model_Behavior, missingMethod);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_behavior___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()


static const zend_function_entry phalcon_mvc_model_behavior_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Behavior, __construct, arginfo_phalcon_mvc_model_behavior___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Behavior, mustTakeAction, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Behavior, getOptions, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Behavior, notify, arginfo_phalcon_mvc_model_behaviorinterface_notify, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Behavior, missingMethod, arginfo_phalcon_mvc_model_behaviorinterface_missingmethod, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Behavior){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Behavior, mvc_model_behavior, phalcon_mvc_model_behavior_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_behavior_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_behavior_ce TSRMLS_CC, 1, phalcon_mvc_model_behaviorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, mustTakeAction){

	zval *event_name, *options;

	phalcon_fetch_params(0, 1, 0, &event_name);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(options, event_name)) {
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, getOptions){

	zval *event_name = NULL, *options, *event_options;

	phalcon_fetch_params(0, 0, 1, &event_name);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (event_name && Z_TYPE_P(event_name) != IS_NULL) {
		if (phalcon_array_isset_fetch(&event_options, options, event_name)) {
			RETURN_ZVAL(event_options, 1, 0);
		}
		RETURN_NULL();
	}
	
	RETURN_ZVAL(options, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, notify){

	zval *type, *model;

	phalcon_fetch_params(0, 2, 0, &type, &model);
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior, missingMethod){

	zval *model, *method, *arguments = NULL;

	phalcon_fetch_params(0, 2, 1, &model, &method, &arguments);
	
	RETURN_NULL();
}





zend_class_entry *phalcon_mvc_model_behaviorinterface_ce;

static const zend_function_entry phalcon_mvc_model_behaviorinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_BehaviorInterface, notify, arginfo_phalcon_mvc_model_behaviorinterface_notify)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_BehaviorInterface, missingMethod, arginfo_phalcon_mvc_model_behaviorinterface_missingmethod)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_BehaviorInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, BehaviorInterface, mvc_model_behaviorinterface, phalcon_mvc_model_behaviorinterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_mvc_model_criteria_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, setModelName);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getModelName);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, bind);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, bindTypes);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, columns);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, join);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, innerJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, leftJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, rightJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, where);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, andWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, orWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, betweenWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, notBetweenWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, inWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, notInWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, conditions);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, orderBy);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, limit);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, forUpdate);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, sharedLock);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getColumns);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getConditions);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getLimit);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getOrder);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getParams);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, fromInput);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, execute);
static PHP_METHOD(Phalcon_Mvc_Model_Criteria, cache);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_criteria_innerjoin, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, conditions)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_criteria_leftjoin, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, conditions)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_criteria_rightjoin, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, conditions)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_criteria_cache, 0, 0, 1)
	ZEND_ARG_INFO(0, option)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_criteria_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Criteria, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, setModelName, arginfo_phalcon_mvc_model_criteriainterface_setmodelname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getModelName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, bind, arginfo_phalcon_mvc_model_criteriainterface_bind, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, bindTypes, arginfo_phalcon_mvc_model_criteriainterface_bindtypes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, columns, arginfo_phalcon_mvc_model_criteriainterface_columns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, join, arginfo_phalcon_mvc_model_criteriainterface_join, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, innerJoin, arginfo_phalcon_mvc_model_criteria_innerjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, leftJoin, arginfo_phalcon_mvc_model_criteria_leftjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, rightJoin, arginfo_phalcon_mvc_model_criteria_rightjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, where, arginfo_phalcon_mvc_model_criteriainterface_where, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_Model_Criteria, addWhere, andWhere, arginfo_phalcon_mvc_model_criteriainterface_andwhere, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_ME(Phalcon_Mvc_Model_Criteria, andWhere, arginfo_phalcon_mvc_model_criteriainterface_andwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, orWhere, arginfo_phalcon_mvc_model_criteriainterface_orwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, betweenWhere, arginfo_phalcon_mvc_model_criteriainterface_betweenwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, notBetweenWhere, arginfo_phalcon_mvc_model_criteriainterface_notbetweenwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, inWhere, arginfo_phalcon_mvc_model_criteriainterface_inwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, notInWhere, arginfo_phalcon_mvc_model_criteriainterface_notinwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, conditions, arginfo_phalcon_mvc_model_criteriainterface_conditions, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_Model_Criteria, order, orderBy, arginfo_phalcon_mvc_model_criteriainterface_orderby, ZEND_ACC_PUBLIC | ZEND_ACC_DEPRECATED)
	PHP_ME(Phalcon_Mvc_Model_Criteria, orderBy, arginfo_phalcon_mvc_model_criteriainterface_orderby, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, limit, arginfo_phalcon_mvc_model_criteriainterface_limit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, forUpdate, arginfo_phalcon_mvc_model_criteriainterface_forupdate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, sharedLock, arginfo_phalcon_mvc_model_criteriainterface_sharedlock, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getWhere, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getColumns, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getConditions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getLimit, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getOrder, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, getParams, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, fromInput, arginfo_phalcon_mvc_model_criteriainterface_frominput, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, execute, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Criteria, cache, arginfo_phalcon_mvc_model_criteria_cache, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Criteria){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Criteria, mvc_model_criteria, phalcon_mvc_model_criteria_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_criteria_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_criteria_ce, SL("_params"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_criteria_ce, SL("_hiddenParamNumber"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_criteria_ce TSRMLS_CC, 2, phalcon_mvc_model_criteriainterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 0);
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("di"), dependency_injector TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getDI){

	zval *params, *dependency_injector;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&dependency_injector, params, SS("di"))) {
		RETURN_ZVAL(dependency_injector, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, setModelName){

	zval *model_name;

	phalcon_fetch_params(0, 1, 0, &model_name);
	
	if (Z_TYPE_P(model_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Model name must be string");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model_name, 2599397109UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getModelName){

	zval *model;

	model = phalcon_fetch_nproperty_this(this_ptr, SL("_model"), PH_NOISY TSRMLS_CC);
	RETURN_ZVAL(model, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, bind){

	zval *bind_params;

	phalcon_fetch_params(0, 1, 0, &bind_params);
	
	if (Z_TYPE_P(bind_params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Bound parameters must be an Array");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bind"), bind_params TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, bindTypes){

	zval *bind_types;

	phalcon_fetch_params(0, 1, 0, &bind_types);
	
	if (Z_TYPE_P(bind_types) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Bind types parameters must be an Array");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bindTypes"), bind_types TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, columns){

	zval *columns;

	phalcon_fetch_params(0, 1, 0, &columns);
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("columns"), columns TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, join){

	zval *model, *conditions = NULL, *alias = NULL, *type = NULL, *new_join, *params;
	zval *current_joins, *merged_joins = NULL, *new_join_array = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &model, &conditions, &alias, &type);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(new_join);
	array_init_size(new_join, 4);
	phalcon_array_append(&new_join, model, 0);
	phalcon_array_append(&new_join, conditions, 0);
	phalcon_array_append(&new_join, alias, 0);
	phalcon_array_append(&new_join, type, 0);
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("joins"), 120974824UL)) {
		
		PHALCON_INIT_VAR(new_join_array);
		array_init_size(new_join_array, 1);
		phalcon_array_append(&new_join_array, new_join, 0);

		PHALCON_OBS_VAR(current_joins);
		phalcon_array_fetch_quick_string(&current_joins, params, SS("joins"), 120974824UL, PH_NOISY);
		if (Z_TYPE_P(current_joins) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_joins);
			phalcon_fast_array_merge(merged_joins, &current_joins, &new_join_array TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_joins, new_join_array);
		}
	} else {
		PHALCON_INIT_NVAR(merged_joins);
		array_init_size(merged_joins, 1);
		phalcon_array_append(&merged_joins, new_join, 0);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("joins"), merged_joins TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, innerJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *new_join, *params;
	zval *current_joins, *merged_joins = NULL, *new_join_array = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "INNER", 1);
	
	PHALCON_INIT_VAR(new_join);
	array_init_size(new_join, 4);
	phalcon_array_append(&new_join, model, 0);
	phalcon_array_append(&new_join, conditions, 0);
	phalcon_array_append(&new_join, alias, 0);
	phalcon_array_append(&new_join, type, 0);
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("joins"), 120974824UL)) {
		
		PHALCON_INIT_VAR(new_join_array);
		array_init_size(new_join_array, 1);
		phalcon_array_append(&new_join_array, new_join, 0);

		PHALCON_OBS_VAR(current_joins);
		phalcon_array_fetch_quick_string(&current_joins, params, SS("joins"), 120974824UL, PH_NOISY);
		if (Z_TYPE_P(current_joins) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_joins);
			phalcon_fast_array_merge(merged_joins, &current_joins, &new_join_array TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_joins, new_join_array);
		}
	} else {
		PHALCON_INIT_NVAR(merged_joins);
		array_init_size(merged_joins, 1);
		phalcon_array_append(&merged_joins, new_join, PH_SEPARATE);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("joins"), merged_joins TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, leftJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *new_join, *params;
	zval *current_joins, *merged_joins = NULL, *new_join_array = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "LEFT", 1);
	
	PHALCON_INIT_VAR(new_join);
	array_init_size(new_join, 4);
	phalcon_array_append(&new_join, model, 0);
	phalcon_array_append(&new_join, conditions, 0);
	phalcon_array_append(&new_join, alias, 0);
	phalcon_array_append(&new_join, type, 0);
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("joins"), 120974824UL)) {

		PHALCON_INIT_VAR(new_join_array);
		array_init_size(new_join_array, 1);
		phalcon_array_append(&new_join_array, new_join, 0);

		PHALCON_OBS_VAR(current_joins);
		phalcon_array_fetch_quick_string(&current_joins, params, SS("joins"), 120974824UL, PH_NOISY);
		if (Z_TYPE_P(current_joins) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_joins);
			phalcon_fast_array_merge(merged_joins, &current_joins, &new_join_array TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_joins, new_join_array);
		}
	} else {
		PHALCON_INIT_NVAR(merged_joins);
		array_init_size(merged_joins, 1);
		phalcon_array_append(&merged_joins, new_join, PH_SEPARATE);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("joins"), merged_joins TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, rightJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *new_join, *params;
	zval *current_joins, *merged_joins = NULL, *new_join_array = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "RIGHT", 1);
	
	PHALCON_INIT_VAR(new_join);
	array_init_size(new_join, 4);
	phalcon_array_append(&new_join, model, 0);
	phalcon_array_append(&new_join, conditions, 0);
	phalcon_array_append(&new_join, alias, 0);
	phalcon_array_append(&new_join, type, 0);
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("joins"), 120974824UL)) {

		PHALCON_INIT_VAR(new_join_array);
		array_init_size(new_join_array, 1);
		phalcon_array_append(&new_join_array, new_join, 0);

		PHALCON_OBS_VAR(current_joins);
		phalcon_array_fetch_quick_string(&current_joins, params, SS("joins"), 120974824UL, PH_NOISY);
		if (Z_TYPE_P(current_joins) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_joins);
			phalcon_fast_array_merge(merged_joins, &current_joins, &new_join_array TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_joins, new_join_array);
		}
	} else {
		PHALCON_INIT_NVAR(merged_joins);
		array_init_size(merged_joins, 1);
		phalcon_array_append(&merged_joins, new_join, PH_SEPARATE);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("joins"), merged_joins TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, where){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;
	zval *params = NULL, *current_bind_params, *merged_params = NULL;
	zval *current_bind_types, *merged_params_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("conditions"), conditions TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bind"), 254268962UL)) {
			PHALCON_OBS_VAR(current_bind_params);
			phalcon_array_fetch_quick_string(&current_bind_params, params, SS("bind"), 254268962UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &current_bind_params, &bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, bind_params);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bind"), merged_params TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bindTypes"), 3951758359UL)) {
			PHALCON_OBS_VAR(current_bind_types);
			phalcon_array_fetch_quick_string(&current_bind_types, params, SS("bindTypes"), 3951758359UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params_types);
			phalcon_fast_array_merge(merged_params_types, &current_bind_types, &bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params_types, bind_types);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bindTypes"), merged_params_types TSRMLS_CC);
	}
	
	RETURN_THIS();
}


static PHP_METHOD(Phalcon_Mvc_Model_Criteria, andWhere){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;
	zval *params = NULL, *current_conditions, *new_conditions = NULL;
	zval *current_bind_params, *merged_params = NULL;
	zval *current_bind_types, *merged_params_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("conditions"), 1055696255UL)) {
		PHALCON_OBS_VAR(current_conditions);
		phalcon_array_fetch_quick_string(&current_conditions, params, SS("conditions"), 1055696255UL, PH_NOISY);
	
		PHALCON_INIT_VAR(new_conditions);
		PHALCON_CONCAT_SVSVS(new_conditions, "(", current_conditions, ") AND (", conditions, ")");
	} else {
		PHALCON_CPY_WRT(new_conditions, conditions);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("conditions"), new_conditions TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bind"), 254268962UL)) {
			PHALCON_OBS_VAR(current_bind_params);
			phalcon_array_fetch_quick_string(&current_bind_params, params, SS("bind"), 254268962UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &current_bind_params, &bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, bind_params);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bind"), merged_params TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bindTypes"), 3951758359UL)) {
			PHALCON_OBS_VAR(current_bind_types);
			phalcon_array_fetch_quick_string(&current_bind_types, params, SS("bindTypes"), 3951758359UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params_types);
			phalcon_fast_array_merge(merged_params_types, &current_bind_types, &bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params_types, bind_types);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bindTypes"), merged_params_types TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, orWhere){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;
	zval *params = NULL, *current_conditions, *new_conditions = NULL;
	zval *current_bind_params, *merged_params = NULL;
	zval *current_bind_types, *merged_params_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	
	PHALCON_OBS_VAR(params);
	phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_quick_string(params, SS("conditions"), 1055696255UL)) {
		PHALCON_OBS_VAR(current_conditions);
		phalcon_array_fetch_quick_string(&current_conditions, params, SS("conditions"), 1055696255UL, PH_NOISY);
	
		PHALCON_INIT_VAR(new_conditions);
		PHALCON_CONCAT_SVSVS(new_conditions, "(", current_conditions, ") OR (", conditions, ")");
	} else {
		PHALCON_CPY_WRT(new_conditions, conditions);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("conditions"), new_conditions TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bind"), 254268962UL)) {
			PHALCON_OBS_VAR(current_bind_params);
			phalcon_array_fetch_quick_string(&current_bind_params, params, SS("bind"), 254268962UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &current_bind_params, &bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, bind_params);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bind"), merged_params TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_OBS_NVAR(params);
		phalcon_read_property_this(&params, this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset_quick_string(params, SS("bindTypes"), 3951758359UL)) {
			PHALCON_OBS_VAR(current_bind_types);
			phalcon_array_fetch_quick_string(&current_bind_types, params, SS("bindTypes"), 3951758359UL, PH_NOISY);
	
			PHALCON_INIT_VAR(merged_params_types);
			phalcon_fast_array_merge(merged_params_types, &current_bind_types, &bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params_types, bind_types);
		}
	
		phalcon_update_property_array_string(this_ptr, SL("_params"), SS("bindTypes"), merged_params_types TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, betweenWhere){

	zval *expr, *minimum, *maximum, *hidden_param;
	zval *next_hidden_param, *minimum_key, *maximum_key;
	zval *conditions, *bind_params;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &expr, &minimum, &maximum);
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(next_hidden_param);
	phalcon_add_function(next_hidden_param, hidden_param, PHALCON_GLOBAL(z_one) TSRMLS_CC);
	
	PHALCON_INIT_VAR(minimum_key);
	PHALCON_CONCAT_SV(minimum_key, "phb", hidden_param);
	
	PHALCON_INIT_VAR(maximum_key);
	PHALCON_CONCAT_SV(maximum_key, "phb", next_hidden_param);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVSVS(conditions, expr, " BETWEEN :", minimum_key, ": AND :", maximum_key, ":");
	
	PHALCON_INIT_VAR(bind_params);
	array_init_size(bind_params, 2);
	phalcon_array_update_zval(&bind_params, minimum_key, minimum, PH_COPY);
	phalcon_array_update_zval(&bind_params, maximum_key, maximum, PH_COPY);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_increment(next_hidden_param);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), next_hidden_param, 3119958698UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, notBetweenWhere){

	zval *expr, *minimum, *maximum, *hidden_param;
	zval *next_hidden_param, *minimum_key, *maximum_key;
	zval *conditions, *bind_params;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &expr, &minimum, &maximum);
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(next_hidden_param);
	phalcon_add_function(next_hidden_param, hidden_param, PHALCON_GLOBAL(z_one) TSRMLS_CC);
	
	PHALCON_INIT_VAR(minimum_key);
	PHALCON_CONCAT_SV(minimum_key, "phb", hidden_param);
	
	PHALCON_INIT_VAR(maximum_key);
	PHALCON_CONCAT_SV(maximum_key, "phb", next_hidden_param);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVSVS(conditions, expr, " NOT BETWEEN :", minimum_key, ": AND :", maximum_key, ":");
	
	PHALCON_INIT_VAR(bind_params);
	array_init_size(bind_params, 2);
	phalcon_array_update_zval(&bind_params, minimum_key, minimum, PH_COPY);
	phalcon_array_update_zval(&bind_params, maximum_key, maximum, PH_COPY);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_increment(next_hidden_param);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), next_hidden_param, 3119958698UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, inWhere){

	zval *expr, *values, *hidden_param, *bind_params;
	zval *bind_keys, *value = NULL, *key = NULL, *query_key = NULL, *joined_keys;
	zval *conditions;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &expr, &values);
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Values must be an array");
		return;
	}
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	SEPARATE_ZVAL(&hidden_param);
	
	PHALCON_INIT_VAR(bind_params);
	array_init(bind_params);
	
	PHALCON_INIT_VAR(bind_keys);
	array_init(bind_keys);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(value);
	
		PHALCON_INIT_NVAR(key);
		PHALCON_CONCAT_SV(key, "phi", hidden_param);
	
		PHALCON_INIT_NVAR(query_key);
		PHALCON_CONCAT_SVS(query_key, ":", key, ":");
		phalcon_array_append(&bind_keys, query_key, 0);
		phalcon_array_update_zval(&bind_params, key, value, PH_COPY);
		phalcon_increment(hidden_param);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(joined_keys);
	phalcon_fast_join_str(joined_keys, SL(", "), bind_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVS(conditions, expr, " IN (", joined_keys, ")");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), hidden_param, 3119958698UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, notInWhere){

	zval *expr, *values, *hidden_param, *bind_params;
	zval *bind_keys, *value = NULL, *key = NULL, *query_key = NULL, *joined_keys;
	zval *conditions;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &expr, &values);
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Values must be an array");
		return;
	}
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	SEPARATE_ZVAL(&hidden_param);
	
	PHALCON_INIT_VAR(bind_params);
	array_init(bind_params);
	
	PHALCON_INIT_VAR(bind_keys);
	array_init(bind_keys);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(value);
	
		PHALCON_INIT_NVAR(key);
		PHALCON_CONCAT_SV(key, "phi", hidden_param);
	
		PHALCON_INIT_NVAR(query_key);
		PHALCON_CONCAT_SVS(query_key, ":", key, ":");
		phalcon_array_append(&bind_keys, query_key, 0);
		phalcon_array_update_zval(&bind_params, key, value, PH_COPY);
		phalcon_increment(hidden_param);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(joined_keys);
	phalcon_fast_join_str(joined_keys, SL(", "), bind_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVS(conditions, expr, " NOT IN (", joined_keys, ")");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), hidden_param, 3119958698UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, conditions){

	zval *conditions;

	phalcon_fetch_params(0, 1, 0, &conditions);
	
	if (Z_TYPE_P(conditions) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Conditions must be string");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("conditions"), conditions TSRMLS_CC);
	
	RETURN_THISW();
}


static PHP_METHOD(Phalcon_Mvc_Model_Criteria, orderBy){

	zval *order_columns;

	phalcon_fetch_params(0, 1, 0, &order_columns);
	
	if (Z_TYPE_P(order_columns) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Order columns must be string");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), ISS(order), order_columns TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, limit){

	zval *limit, *offset = NULL, *limit_clause;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &limit, &offset);
	
	if (!offset) {
		offset = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_is_numeric(limit)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Row limit parameter must be integer");
		return;
	}
	if (Z_TYPE_P(offset) == IS_NULL) {
		phalcon_update_property_array_string(this_ptr, SL("_params"), ISS(limit), limit TSRMLS_CC);
	} else {
		PHALCON_INIT_VAR(limit_clause);
		array_init_size(limit_clause, 2);
		phalcon_array_update_string(&limit_clause, ISL(number), limit, PH_COPY);
		phalcon_array_update_string(&limit_clause, ISL(offset), offset, PH_COPY);
		phalcon_update_property_array_string(this_ptr, SL("_params"), ISS(limit), limit_clause TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, forUpdate){

	zval *for_update = NULL;

	phalcon_fetch_params(0, 0, 1, &for_update);
	
	if (!for_update) {
		for_update = PHALCON_GLOBAL(z_true);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("for_update"), for_update TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, sharedLock){

	zval *shared_lock = NULL;

	phalcon_fetch_params(0, 0, 1, &shared_lock);
	
	if (!shared_lock) {
		shared_lock = PHALCON_GLOBAL(z_true);
	}
	
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("shared_lock"), shared_lock TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getWhere){

	zval *params, *conditions;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&conditions, params, SS("conditions"))) {
		RETURN_ZVAL(conditions, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getColumns){

	zval *params, *columns;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&columns, params, SS("columns"))) {
		RETURN_ZVAL(columns, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getConditions){

	zval *params, *conditions;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&conditions, params, SS("conditions"))) {
		RETURN_ZVAL(conditions, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getLimit){

	zval *params, *limit;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&limit, params, SS("limit"))) {
		RETURN_ZVAL(limit, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getOrder){

	zval *params, *order;

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_params"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&order, params, SS("order"))) {
		RETURN_ZVAL(order, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, getParams){


	RETURN_MEMBER_QUICK(this_ptr, "_params", 3223731112UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, fromInput){

	zval *dependency_injector, *model_name, *data;
	zval *conditions, *service, *meta_data = NULL, *model;
	zval *data_types = NULL, *bind, *value = NULL, *field = NULL, *type, *condition = NULL;
	zval *value_pattern = NULL, *join_conditions;
	zval *column_map = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &dependency_injector, &model_name, &data);
	
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Input data must be an Array");
		return;
	}

	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the ORM services");
		return;
	}
	
	object_init_ex(return_value, phalcon_mvc_model_criteria_ce);

	if (zend_hash_num_elements(Z_ARRVAL_P(data))) {
	
		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_modelsMetadata);
	
		PHALCON_CALL_METHOD(&meta_data, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(meta_data, phalcon_mvc_model_metadatainterface_ce);
		ce0 = phalcon_fetch_class(model_name TSRMLS_CC);
	
		PHALCON_INIT_VAR(model);
		object_init_ex(model, ce0);
		if (phalcon_has_constructor(model TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, model, "__construct");
		}

		PHALCON_VERIFY_INTERFACE_EX(model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 1);

		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", model);
			if (Z_TYPE_P(column_map) != IS_ARRAY) {
				PHALCON_INIT_NVAR(column_map);
			}
		}
		else {
			column_map = PHALCON_GLOBAL(z_null);
		}

		PHALCON_CALL_METHOD(&data_types, meta_data, "getdatatypes", model);
	
		PHALCON_INIT_VAR(bind);
		array_init(bind);
	
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);

		phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			zval *real_field;
	
			PHALCON_GET_HKEY(field, ah0, hp0);
			PHALCON_GET_HVALUE(value);

			if (Z_TYPE_P(column_map) != IS_ARRAY || !phalcon_array_isset_fetch(&real_field, column_map, field)) {
				real_field = field;
			}
	
			if (phalcon_array_isset_fetch(&type, data_types, real_field)) {
				if (Z_TYPE_P(value) != IS_NULL && !PHALCON_IS_STRING(value, "")) {
					if (PHALCON_IS_LONG(type, 2)) {
						PHALCON_INIT_NVAR(condition);
						PHALCON_CONCAT_VSVS(condition, field, " LIKE :", field, ":");

						PHALCON_INIT_NVAR(value_pattern);
						PHALCON_CONCAT_SVS(value_pattern, "%", value, "%");
						phalcon_array_update_zval(&bind, field, value_pattern, PH_COPY);
					} else {
						PHALCON_INIT_NVAR(condition);
						PHALCON_CONCAT_VSVS(condition, field, "=:", field, ":");
						phalcon_array_update_zval(&bind, field, value, PH_COPY);
					}

					phalcon_array_append(&conditions, condition, 0);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (zend_hash_num_elements(Z_ARRVAL_P(conditions))) {
			PHALCON_INIT_VAR(join_conditions);
			phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, return_value, "where", join_conditions, bind);
		}
	}
	
	PHALCON_CALL_METHOD(NULL, return_value, "setmodelname", model_name);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, execute){

	zval *model, *params = NULL;
	zend_class_entry *ce;

	PHALCON_MM_GROW();

	model = phalcon_fetch_nproperty_this(this_ptr, SL("_model"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(model) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model name must be string");
		return;
	}
	
	PHALCON_CALL_METHOD(&params, this_ptr, "getparams");
	
	ce = phalcon_fetch_class(model TSRMLS_CC);
	if (!ce) {
		zend_throw_exception_ex(phalcon_mvc_model_exception_ce, 0 TSRMLS_CC, "Class '%s' does not exist", Z_STRVAL_P(model));
		RETURN_MM();
	}

	PHALCON_RETURN_CALL_CE_STATIC(ce, "find", params);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Criteria, cache){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Cache options must be an Array");
		return;
	}
	phalcon_update_property_array_string(this_ptr, SL("_params"), SS("cache"), options TSRMLS_CC);
	
	RETURN_THISW();
}






zend_class_entry *phalcon_mvc_model_criteriainterface_ce;

static const zend_function_entry phalcon_mvc_model_criteriainterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, setModelName, arginfo_phalcon_mvc_model_criteriainterface_setmodelname)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getModelName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, bind, arginfo_phalcon_mvc_model_criteriainterface_bind)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, bindTypes, arginfo_phalcon_mvc_model_criteriainterface_bindtypes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, columns, arginfo_phalcon_mvc_model_criteriainterface_columns)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, join, arginfo_phalcon_mvc_model_criteriainterface_join)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, where, arginfo_phalcon_mvc_model_criteriainterface_where)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, conditions, arginfo_phalcon_mvc_model_criteriainterface_conditions)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, orderBy, arginfo_phalcon_mvc_model_criteriainterface_orderby)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, limit, arginfo_phalcon_mvc_model_criteriainterface_limit)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, forUpdate, arginfo_phalcon_mvc_model_criteriainterface_forupdate)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, sharedLock, arginfo_phalcon_mvc_model_criteriainterface_sharedlock)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, andWhere, arginfo_phalcon_mvc_model_criteriainterface_andwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, orWhere, arginfo_phalcon_mvc_model_criteriainterface_orwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, betweenWhere, arginfo_phalcon_mvc_model_criteriainterface_betweenwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, notBetweenWhere, arginfo_phalcon_mvc_model_criteriainterface_notbetweenwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, inWhere, arginfo_phalcon_mvc_model_criteriainterface_inwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, notInWhere, arginfo_phalcon_mvc_model_criteriainterface_notinwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getWhere, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getConditions, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getLimit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getOrder, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, getParams, NULL)
	ZEND_FENTRY(fromInput, NULL, arginfo_phalcon_mvc_model_criteriainterface_frominput, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_CriteriaInterface, execute, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_CriteriaInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, CriteriaInterface, mvc_model_criteriainterface, phalcon_mvc_model_criteriainterface_method_entry);

	return SUCCESS;
}






























zend_class_entry *phalcon_mvc_model_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model, Exception, mvc_model_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_model_manager_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setCustomEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getCustomEventsManager);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, initialize);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, isInitialized);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getLastInitialized);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, load);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setModelSource);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getModelSource);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setModelSchema);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getModelSchema);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setWriteConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setReadConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getWriteConnection);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReadConnection);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReadConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getWriteConnectionService);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, notifyEvent);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, missingMethod);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, addBehavior);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, keepSnapshots);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, isKeepingSnapshots);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, useDynamicUpdate);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, isUsingDynamicUpdate);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasOne);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, addBelongsTo);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasManyToMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsBelongsTo);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasOne);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasManyToMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationByAlias);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReusableRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, setReusableRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, clearReusableObjects);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsToRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasManyRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsTo);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOne);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasManyToMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneAndHasMany);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelations);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationsBetween);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, createQuery);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, executeQuery);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, createBuilder);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getLastQuery);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, registerNamespaceAlias);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getNamespaceAlias);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, getNamespaceAliases);
static PHP_METHOD(Phalcon_Mvc_Model_Manager, __destruct);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setcustomeventsmanager, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, eventsManager)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getcustomeventsmanager, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setmodelsource, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, source)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getmodelsource, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setmodelschema, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, schema)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getmodelschema, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setconnectionservice, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, connectionService)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setwriteconnectionservice, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, connectionService)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setreadconnectionservice, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, connectionService)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getwriteconnection, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getreadconnection, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getreadconnectionservice, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getwriteconnectionservice, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_keepsnapshots, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, keepSnapshots)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_iskeepingsnapshots, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_usedynamicupdate, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, dynamicUpdate)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_isusingdynamicupdate, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_addhasmanytomany, 0, 0, 7)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, intermediateModel)
	ZEND_ARG_INFO(0, intermediateFields)
	ZEND_ARG_INFO(0, intermediateReferencedFields)
	ZEND_ARG_INFO(0, referencedModel)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_existshasmanytomany, 0, 0, 2)
	ZEND_ARG_INFO(0, modelName)
	ZEND_ARG_INFO(0, modelRelation)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getrelationbyalias, 0, 0, 2)
	ZEND_ARG_INFO(0, modelName)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getrelationrecords, 0, 0, 3)
	ZEND_ARG_INFO(0, relation)
	ZEND_ARG_INFO(0, method)
	ZEND_ARG_INFO(0, record)
	ZEND_ARG_INFO(0, parameters)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getreusablerecords, 0, 0, 2)
	ZEND_ARG_INFO(0, modelName)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_setreusablerecords, 0, 0, 3)
	ZEND_ARG_INFO(0, modelName)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, records)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_gethasmanytomany, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_registernamespacealias, 0, 0, 2)
	ZEND_ARG_INFO(0, alias)
	ZEND_ARG_INFO(0, namespace)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_manager_getnamespacealias, 0, 0, 1)
	ZEND_ARG_INFO(0, alias)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_manager_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Manager, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setEventsManager, arginfo_phalcon_events_eventsawareinterface_seteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getEventsManager, arginfo_phalcon_events_eventsawareinterface_geteventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setCustomEventsManager, arginfo_phalcon_mvc_model_manager_setcustomeventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getCustomEventsManager, arginfo_phalcon_mvc_model_manager_getcustomeventsmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, initialize, arginfo_phalcon_mvc_model_managerinterface_initialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, isInitialized, arginfo_phalcon_mvc_model_managerinterface_isinitialized, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getLastInitialized, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, load, arginfo_phalcon_mvc_model_managerinterface_load, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setModelSource, arginfo_phalcon_mvc_model_manager_setmodelsource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getModelSource, arginfo_phalcon_mvc_model_manager_getmodelsource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setModelSchema, arginfo_phalcon_mvc_model_manager_setmodelschema, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getModelSchema, arginfo_phalcon_mvc_model_manager_getmodelschema, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setConnectionService, arginfo_phalcon_mvc_model_manager_setconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setWriteConnectionService, arginfo_phalcon_mvc_model_manager_setwriteconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setReadConnectionService, arginfo_phalcon_mvc_model_manager_setreadconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getWriteConnection, arginfo_phalcon_mvc_model_manager_getwriteconnection, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getReadConnection, arginfo_phalcon_mvc_model_manager_getreadconnection, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getReadConnectionService, arginfo_phalcon_mvc_model_manager_getreadconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getWriteConnectionService, arginfo_phalcon_mvc_model_manager_getwriteconnectionservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, notifyEvent, arginfo_phalcon_mvc_model_managerinterface_notifyevent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, missingMethod, arginfo_phalcon_mvc_model_managerinterface_missingmethod, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, addBehavior, arginfo_phalcon_mvc_model_managerinterface_addbehavior, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, keepSnapshots, arginfo_phalcon_mvc_model_manager_keepsnapshots, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, isKeepingSnapshots, arginfo_phalcon_mvc_model_manager_iskeepingsnapshots, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, useDynamicUpdate, arginfo_phalcon_mvc_model_manager_usedynamicupdate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, isUsingDynamicUpdate, arginfo_phalcon_mvc_model_manager_isusingdynamicupdate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, addHasOne, arginfo_phalcon_mvc_model_managerinterface_addhasone, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, addBelongsTo, arginfo_phalcon_mvc_model_managerinterface_addbelongsto, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, addHasMany, arginfo_phalcon_mvc_model_managerinterface_addhasmany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, addHasManyToMany, arginfo_phalcon_mvc_model_manager_addhasmanytomany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, existsBelongsTo, arginfo_phalcon_mvc_model_managerinterface_existsbelongsto, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, existsHasMany, arginfo_phalcon_mvc_model_managerinterface_existshasmany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, existsHasOne, arginfo_phalcon_mvc_model_managerinterface_existshasone, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, existsHasManyToMany, arginfo_phalcon_mvc_model_manager_existshasmanytomany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getRelationByAlias, arginfo_phalcon_mvc_model_manager_getrelationbyalias, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getRelationRecords, arginfo_phalcon_mvc_model_manager_getrelationrecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getReusableRecords, arginfo_phalcon_mvc_model_manager_getreusablerecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, setReusableRecords, arginfo_phalcon_mvc_model_manager_setreusablerecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, clearReusableObjects, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getBelongsToRecords, arginfo_phalcon_mvc_model_managerinterface_getbelongstorecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasManyRecords, arginfo_phalcon_mvc_model_managerinterface_gethasmanyrecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasOneRecords, arginfo_phalcon_mvc_model_managerinterface_gethasonerecords, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getBelongsTo, arginfo_phalcon_mvc_model_managerinterface_getbelongsto, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasMany, arginfo_phalcon_mvc_model_managerinterface_gethasmany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasOne, arginfo_phalcon_mvc_model_managerinterface_gethasone, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasManyToMany, arginfo_phalcon_mvc_model_manager_gethasmanytomany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getHasOneAndHasMany, arginfo_phalcon_mvc_model_managerinterface_gethasoneandhasmany, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getRelations, arginfo_phalcon_mvc_model_managerinterface_getrelations, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getRelationsBetween, arginfo_phalcon_mvc_model_managerinterface_getrelationsbetween, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, createQuery, arginfo_phalcon_mvc_model_managerinterface_createquery, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, executeQuery, arginfo_phalcon_mvc_model_managerinterface_executequery, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, createBuilder, arginfo_phalcon_mvc_model_managerinterface_createbuilder, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getLastQuery, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, registerNamespaceAlias, arginfo_phalcon_mvc_model_manager_registernamespacealias, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getNamespaceAlias, arginfo_phalcon_mvc_model_manager_getnamespacealias, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, getNamespaceAliases, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Manager, __destruct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Manager, mvc_model_manager, phalcon_mvc_model_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_eventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_customEventsManager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_readConnectionServices"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_writeConnectionServices"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_aliases"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasMany"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasManySingle"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasOne"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasOneSingle"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_belongsTo"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_belongsToSingle"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasManyToMany"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_hasManyToManySingle"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_initialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_sources"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_schemas"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_behaviors"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_lastInitialized"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_lastQuery"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_reusable"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_keepSnapshots"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_dynamicUpdate"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_manager_ce, SL("_namespaceAliases"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_manager_ce TSRMLS_CC, 3, phalcon_mvc_model_managerinterface_ce, phalcon_di_injectionawareinterface_ce, phalcon_events_eventsawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setEventsManager){

	zval *events_manager;

	phalcon_fetch_params(0, 1, 0, &events_manager);
	
	phalcon_update_property_this_quick(this_ptr, SL("_eventsManager"), events_manager, 799100116UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getEventsManager){


	RETURN_MEMBER_QUICK(this_ptr, "_eventsManager", 799100116UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setCustomEventsManager){

	zval *model, *events_manager, *class_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &events_manager);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_customEventsManager"), class_name, events_manager TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getCustomEventsManager){

	zval *model, *custom_events_manager, *class_name;
	zval *events_manager;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(custom_events_manager);
	phalcon_read_property_this(&custom_events_manager, this_ptr, SL("_customEventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(custom_events_manager) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(custom_events_manager, class_name)) {
			PHALCON_OBS_VAR(events_manager);
			phalcon_array_fetch(&events_manager, custom_events_manager, class_name, PH_NOISY);
			RETURN_CTOR(events_manager);
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, initialize){

	zval *model, *class_name, *initialized, *events_manager;
	zval *event_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset(initialized, class_name)) {
		RETURN_MM_FALSE;
	}
	
	phalcon_update_property_array(this_ptr, SL("_initialized"), class_name, model TSRMLS_CC);
	
	if (phalcon_method_quick_exists_ex(model, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(NULL, model, "initialize");
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_lastInitialized"), model, 1491101038UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "modelsManager:afterInitialize", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr, model);
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, isInitialized){

	zval *model_name, *initialized, *lowercased;

	phalcon_fetch_params(0, 1, 0, &model_name);
	
	initialized = phalcon_fetch_nproperty_this(this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	ALLOC_INIT_ZVAL(lowercased);
	phalcon_fast_strtolower(lowercased, model_name);
	
	RETVAL_BOOL(phalcon_array_isset(initialized, lowercased));
	zval_ptr_dtor(&lowercased);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getLastInitialized){


	RETURN_MEMBER_QUICK(this_ptr, "_lastInitialized", 1491101038UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, load){

	zval **model_name, **new_instance = NULL, *initialized;
	zval *lowercased, *model, *dependency_injector;
	zend_class_entry *ce0;

	phalcon_fetch_params_ex(1, 1, &model_name, &new_instance);

	PHALCON_MM_GROW();
	PHALCON_ENSURE_IS_STRING(model_name);

	if (!new_instance) {
		new_instance = &PHALCON_GLOBAL(z_false);
	}
	
	initialized = phalcon_fetch_nproperty_this(this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(lowercased);
	ZVAL_STRINGL(lowercased, zend_str_tolower_dup(Z_STRVAL_PP(model_name), Z_STRLEN_PP(model_name)), Z_STRLEN_PP(model_name), 0);
	
	if (phalcon_array_isset_fetch(&model, initialized, lowercased)) {
		if (zend_is_true(*new_instance)) {
			dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(model) != IS_OBJECT) {
				/* This shouls never happen but better safe than sorry */
				RETURN_MM_NULL();
			}

			object_init_ex(return_value, Z_OBJCE_P(model));

			if (phalcon_has_constructor(return_value TSRMLS_CC)) {
				PHALCON_CALL_METHOD(NULL, return_value, "__construct", dependency_injector, this_ptr);
			}

			RETURN_MM();
		} else {
			PHALCON_CALL_METHOD(NULL, model, "reset");
		}
	
		RETURN_CTOR(model);
	}
	
	if (phalcon_class_exists_ex(&ce0, *model_name, 1 TSRMLS_CC)) {
		dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);

		object_init_ex(return_value, ce0);
		if (phalcon_has_constructor(return_value TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", dependency_injector, this_ptr);
		}
		RETURN_MM();
	}
	
	zend_throw_exception_ex(phalcon_mvc_model_exception_ce, 0 TSRMLS_CC, "Model '%s' could not be loaded", Z_STRVAL_PP(model_name));
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setModelSource){

	zval *model, *source, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &source);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model is not an object");
		return;
	}
	if (Z_TYPE_P(source) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Source must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_sources"), entity_name, source TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getModelSource){

	zval *model, *entity_name, *sources, *source = NULL, *class_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model is not an object");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(sources);
	phalcon_read_property_this(&sources, this_ptr, SL("_sources"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(sources) == IS_ARRAY) { 
		if (phalcon_array_isset(sources, entity_name)) {
			PHALCON_OBS_VAR(source);
			phalcon_array_fetch(&source, sources, entity_name, PH_NOISY);
			RETURN_CTOR(source);
		}
	}
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class_ns(class_name, model, 0 TSRMLS_CC);
	
	PHALCON_INIT_NVAR(source);
	phalcon_uncamelize(source, class_name);
	phalcon_update_property_array(this_ptr, SL("_sources"), entity_name, source TSRMLS_CC);
	
	RETURN_CTOR(source);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setModelSchema){

	zval *model, *schema, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &schema);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model is not an object");
		return;
	}
	if (Z_TYPE_P(schema) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Schema must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_schemas"), entity_name, schema TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getModelSchema){

	zval *model, *entity_name, *schemas, *schema;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	if (Z_TYPE_P(model) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Model is not an object");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(schemas);
	phalcon_read_property_this(&schemas, this_ptr, SL("_schemas"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(schemas) == IS_ARRAY) { 
		if (phalcon_array_isset(schemas, entity_name)) {
			PHALCON_OBS_VAR(schema);
			phalcon_array_fetch(&schema, schemas, entity_name, PH_NOISY);
			RETURN_CTOR(schema);
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setConnectionService){

	zval *model, *connection_service, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &connection_service);
	
	if (Z_TYPE_P(connection_service) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The connection service must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_readConnectionServices"), entity_name, connection_service TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_writeConnectionServices"), entity_name, connection_service TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setWriteConnectionService){

	zval *model, *connection_service, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &connection_service);
	
	if (Z_TYPE_P(connection_service) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The connection service must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_writeConnectionServices"), entity_name, connection_service TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setReadConnectionService){

	zval *model, *connection_service, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &connection_service);
	
	if (Z_TYPE_P(connection_service) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The connection service must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_readConnectionServices"), entity_name, connection_service TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getWriteConnection){

	zval *model, *service = NULL, *connection_services;
	zval *entity_name, *dependency_injector, *connection = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "db", 1);
	
	PHALCON_OBS_VAR(connection_services);
	phalcon_read_property_this(&connection_services, this_ptr, SL("_writeConnectionServices"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection_services) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
		if (phalcon_array_isset(connection_services, entity_name)) {
			PHALCON_OBS_NVAR(service);
			phalcon_array_fetch(&service, connection_services, entity_name, PH_NOISY);
		}
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_CALL_METHOD(&connection, dependency_injector, "getshared", service);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid injected connection service");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(connection, phalcon_db_adapterinterface_ce);
	RETURN_CTOR(connection);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReadConnection){

	zval *model, *service = NULL, *connection_services;
	zval *entity_name, *dependency_injector, *connection = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "db", 1);
	
	PHALCON_OBS_VAR(connection_services);
	phalcon_read_property_this(&connection_services, this_ptr, SL("_readConnectionServices"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection_services) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
		if (phalcon_array_isset(connection_services, entity_name)) {
			PHALCON_OBS_NVAR(service);
			phalcon_array_fetch(&service, connection_services, entity_name, PH_NOISY);
		}
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_CALL_METHOD(&connection, dependency_injector, "getshared", service);
	if (Z_TYPE_P(connection) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid injected connection service");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(connection, phalcon_db_adapterinterface_ce);
	RETURN_CTOR(connection);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReadConnectionService){

	zval *model, *connection_services, *entity_name;
	zval *connection;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(connection_services);
	phalcon_read_property_this(&connection_services, this_ptr, SL("_readConnectionServices"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection_services) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
		if (phalcon_array_isset(connection_services, entity_name)) {
			PHALCON_OBS_VAR(connection);
			phalcon_array_fetch(&connection, connection_services, entity_name, PH_NOISY);
			RETURN_CTOR(connection);
		}
	}
	
	RETURN_MM_STRING("db", 1);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getWriteConnectionService){

	zval *model, *connection_services, *entity_name;
	zval *connection;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(connection_services);
	phalcon_read_property_this(&connection_services, this_ptr, SL("_writeConnectionServices"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection_services) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
		if (phalcon_array_isset(connection_services, entity_name)) {
			PHALCON_OBS_VAR(connection);
			phalcon_array_fetch(&connection, connection_services, entity_name, PH_NOISY);
			RETURN_CTOR(connection);
		}
	}
	
	RETURN_MM_STRING("db", 1);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, notifyEvent){

	zval *event_name, *model, *status = NULL, *behaviors, *entity_name = NULL;
	zval *models_behaviors, *behavior = NULL, *events_manager, *mgr;
	zval *fire_event_name = NULL, *custom_events_manager;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &event_name, &model);
	
	PHALCON_INIT_VAR(status);
	
	behaviors = phalcon_fetch_nproperty_this(this_ptr, SL("_behaviors"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(behaviors) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset_fetch(&models_behaviors, behaviors, entity_name)) {
	
			phalcon_is_iterable(models_behaviors, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(behavior);
	
				PHALCON_CALL_METHOD(&status, behavior, "notify", event_name, model);
				if (PHALCON_IS_FALSE(status)) {
					RETURN_CTOR(status);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "model:", event_name);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", fire_event_name, model);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_CTOR(status);
		}
	}
	
	custom_events_manager = phalcon_fetch_nproperty_this(this_ptr, SL("_customEventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(custom_events_manager) == IS_ARRAY) { 
	
		PHALCON_INIT_NVAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset_fetch(&mgr, custom_events_manager, entity_name)) {
	
			PHALCON_INIT_NVAR(fire_event_name);
			PHALCON_CONCAT_SV(fire_event_name, "model:", event_name);
	
			PHALCON_CALL_METHOD(&status, mgr, "fire", fire_event_name, model);
			if (PHALCON_IS_FALSE(status)) {
				RETURN_CTOR(status);
			}
		}
	}
	
	RETURN_CTOR(status);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, missingMethod){

	zval *model, *event_name, *data, *behaviors, *entity_name;
	zval *models_behaviors, *behavior = NULL, *result = NULL, *events_manager;
	zval *fire_event_name;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &model, &event_name, &data);
	
	PHALCON_OBS_VAR(behaviors);
	phalcon_read_property_this(&behaviors, this_ptr, SL("_behaviors"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(behaviors) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(behaviors, entity_name)) {
	
			PHALCON_OBS_VAR(models_behaviors);
			phalcon_array_fetch(&models_behaviors, behaviors, entity_name, PH_NOISY);
	
			phalcon_is_iterable(models_behaviors, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(behavior);
	
				PHALCON_CALL_METHOD(&result, behavior, "missingmethod", model, event_name, data);
				if (Z_TYPE_P(result) != IS_NULL) {
					RETURN_CTOR(result);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_VAR(fire_event_name);
		PHALCON_CONCAT_SV(fire_event_name, "model:", event_name);
		PHALCON_RETURN_CALL_METHOD(events_manager, "fire", fire_event_name, model, data);
		RETURN_MM();
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, addBehavior){

	zval *model, *behavior, *entity_name, *behaviors;
	zval *models_behaviors = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &behavior);
	
	if (Z_TYPE_P(behavior) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The behavior is invalid");
		return;
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(behaviors);
	phalcon_read_property_this(&behaviors, this_ptr, SL("_behaviors"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(behaviors, entity_name)) {
		PHALCON_OBS_VAR(models_behaviors);
		phalcon_array_fetch(&models_behaviors, behaviors, entity_name, PH_NOISY);
	} else {
		PHALCON_INIT_NVAR(models_behaviors);
		array_init(models_behaviors);
	}
	
	phalcon_array_append(&models_behaviors, behavior, PH_SEPARATE);
	
	phalcon_update_property_array(this_ptr, SL("_behaviors"), entity_name, models_behaviors TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, keepSnapshots){

	zval *model, *keep_snapshots, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &keep_snapshots);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_keepSnapshots"), entity_name, keep_snapshots TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, isKeepingSnapshots){

	zval *model, *keep_snapshots, *entity_name, *is_keeping;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(keep_snapshots);
	phalcon_read_property_this(&keep_snapshots, this_ptr, SL("_keepSnapshots"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(keep_snapshots) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(keep_snapshots, entity_name)) {
			PHALCON_OBS_VAR(is_keeping);
			phalcon_array_fetch(&is_keeping, keep_snapshots, entity_name, PH_NOISY);
			RETURN_CTOR(is_keeping);
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, useDynamicUpdate){

	zval *model, *dynamic_update, *entity_name;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &dynamic_update);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_dynamicUpdate"), entity_name, dynamic_update TSRMLS_CC);
	phalcon_update_property_array(this_ptr, SL("_keepSnapshots"), entity_name, dynamic_update TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, isUsingDynamicUpdate){

	zval *model, *dynamic_update, *entity_name, *is_using;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(dynamic_update);
	phalcon_read_property_this(&dynamic_update, this_ptr, SL("_dynamicUpdate"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dynamic_update) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(dynamic_update, entity_name)) {
			PHALCON_OBS_VAR(is_using);
			phalcon_array_fetch(&is_using, dynamic_update, entity_name, PH_NOISY);
			RETURN_CTOR(is_using);
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasOne){

	zval *model, *fields, *referenced_model, *referenced_fields;
	zval *options = NULL, *entity_name, *referenced_entity;
	zval *key_relation, *has_one, *relations = NULL, *number_fields;
	zval *number_referenced, *type, *relation, *alias;
	zval *lower_alias = NULL, *key_alias, *has_one_single;
	zval *single_relations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &model, &fields, &referenced_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_entity);
	phalcon_fast_strtolower(referenced_entity, referenced_model);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", referenced_entity);
	
	PHALCON_OBS_VAR(has_one);
	phalcon_read_property_this(&has_one, this_ptr, SL("_hasOne"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_one, key_relation)) {
		PHALCON_INIT_VAR(relations);
		array_init(relations);
	} else {
		PHALCON_OBS_NVAR(relations);
		phalcon_array_fetch(&relations, has_one, key_relation, PH_NOISY);
	}
	
	if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(number_fields);
		phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(number_referenced);
		phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
		if (!PHALCON_IS_EQUAL(number_fields, number_referenced)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
			return;
		}
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_LONG(type, 1);
	
	PHALCON_INIT_VAR(relation);
	object_init_ex(relation, phalcon_mvc_model_relation_ce);
	PHALCON_CALL_METHOD(NULL, relation, "__construct", type, referenced_model, fields, referenced_fields, options);
	
	if (phalcon_array_isset_quick_string(options, SS("alias"), 4060151663UL)) {
		PHALCON_OBS_VAR(alias);
		phalcon_array_fetch_quick_string(&alias, options, SS("alias"), 4060151663UL, PH_NOISY);
	
		PHALCON_INIT_VAR(lower_alias);
		phalcon_fast_strtolower(lower_alias, alias);
	} else {
		PHALCON_CPY_WRT(lower_alias, referenced_entity);
	}
	
	phalcon_array_append(&relations, relation, PH_SEPARATE);
	
	PHALCON_INIT_VAR(key_alias);
	PHALCON_CONCAT_VSV(key_alias, entity_name, "$", lower_alias);
	phalcon_update_property_array(this_ptr, SL("_aliases"), key_alias, relation TSRMLS_CC);
	
	phalcon_update_property_array(this_ptr, SL("_hasOne"), key_relation, relations TSRMLS_CC);
	
	PHALCON_OBS_VAR(has_one_single);
	phalcon_read_property_this(&has_one_single, this_ptr, SL("_hasOneSingle"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_one_single, entity_name)) {
		PHALCON_INIT_VAR(single_relations);
		array_init(single_relations);
	} else {
		PHALCON_OBS_NVAR(single_relations);
		phalcon_array_fetch(&single_relations, has_one_single, entity_name, PH_NOISY);
	}
	
	phalcon_array_append(&single_relations, relation, PH_SEPARATE);
	
	phalcon_update_property_array(this_ptr, SL("_hasOneSingle"), entity_name, single_relations TSRMLS_CC);
	
	RETURN_CTOR(relation);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, addBelongsTo){

	zval *model, *fields, *referenced_model, *referenced_fields;
	zval *options = NULL, *entity_name, *referenced_entity;
	zval *key_relation, *belongs_to, *relations = NULL;
	zval *number_fields, *number_referenced, *type;
	zval *relation, *alias, *lower_alias = NULL, *key_alias;
	zval *belongs_to_single, *single_relations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &model, &fields, &referenced_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_entity);
	phalcon_fast_strtolower(referenced_entity, referenced_model);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", referenced_entity);
	
	PHALCON_OBS_VAR(belongs_to);
	phalcon_read_property_this(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(belongs_to, key_relation)) {
		PHALCON_INIT_VAR(relations);
		array_init(relations);
	} else {
		PHALCON_OBS_NVAR(relations);
		phalcon_array_fetch(&relations, belongs_to, key_relation, PH_NOISY);
	}
	
	if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(number_fields);
		phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(number_referenced);
		phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
		if (!PHALCON_IS_EQUAL(number_fields, number_referenced)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
			return;
		}
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_LONG(type, 0);
	
	PHALCON_INIT_VAR(relation);
	object_init_ex(relation, phalcon_mvc_model_relation_ce);
	PHALCON_CALL_METHOD(NULL, relation, "__construct", type, referenced_model, fields, referenced_fields, options);
	
	if (phalcon_array_isset_quick_string(options, SS("alias"), 4060151663UL)) {
		PHALCON_OBS_VAR(alias);
		phalcon_array_fetch_quick_string(&alias, options, SS("alias"), 4060151663UL, PH_NOISY);
	
		PHALCON_INIT_VAR(lower_alias);
		phalcon_fast_strtolower(lower_alias, alias);
	} else {
		PHALCON_CPY_WRT(lower_alias, referenced_entity);
	}
	
	phalcon_array_append(&relations, relation, PH_SEPARATE);
	
	PHALCON_INIT_VAR(key_alias);
	PHALCON_CONCAT_VSV(key_alias, entity_name, "$", lower_alias);
	phalcon_update_property_array(this_ptr, SL("_aliases"), key_alias, relation TSRMLS_CC);
	
	phalcon_update_property_array(this_ptr, SL("_belongsTo"), key_relation, relations TSRMLS_CC);
	
	PHALCON_OBS_VAR(belongs_to_single);
	phalcon_read_property_this(&belongs_to_single, this_ptr, SL("_belongsToSingle"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(belongs_to_single, entity_name)) {
		PHALCON_INIT_VAR(single_relations);
		array_init(single_relations);
	} else {
		PHALCON_OBS_NVAR(single_relations);
		phalcon_array_fetch(&single_relations, belongs_to_single, entity_name, PH_NOISY);
	}
	
	phalcon_array_append(&single_relations, relation, PH_SEPARATE);
	
	phalcon_update_property_array(this_ptr, SL("_belongsToSingle"), entity_name, single_relations TSRMLS_CC);
	
	RETURN_CTOR(relation);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasMany){

	zval *model, *fields, *referenced_model, *referenced_fields;
	zval *options = NULL, *entity_name, *referenced_entity;
	zval *key_relation, *has_many, *relations = NULL, *number_fields;
	zval *number_referenced, *type, *relation, *alias;
	zval *lower_alias = NULL, *key_alias, *has_many_single;
	zval *single_relations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &model, &fields, &referenced_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(referenced_entity);
	phalcon_fast_strtolower(referenced_entity, referenced_model);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", referenced_entity);
	
	PHALCON_OBS_VAR(has_many);
	phalcon_read_property_this(&has_many, this_ptr, SL("_hasMany"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_many, key_relation)) {
		PHALCON_INIT_VAR(relations);
		array_init(relations);
	} else {
		PHALCON_OBS_NVAR(relations);
		phalcon_array_fetch(&relations, has_many, key_relation, PH_NOISY);
	}
	
	if (Z_TYPE_P(referenced_fields) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(number_fields);
		phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(number_referenced);
		phalcon_fast_count(number_referenced, referenced_fields TSRMLS_CC);
		if (!PHALCON_IS_EQUAL(number_fields, number_referenced)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
			return;
		}
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_LONG(type, 2);
	
	PHALCON_INIT_VAR(relation);
	object_init_ex(relation, phalcon_mvc_model_relation_ce);
	PHALCON_CALL_METHOD(NULL, relation, "__construct", type, referenced_model, fields, referenced_fields, options);
	
	if (phalcon_array_isset_quick_string(options, SS("alias"), 4060151663UL)) {
		PHALCON_OBS_VAR(alias);
		phalcon_array_fetch_quick_string(&alias, options, SS("alias"), 4060151663UL, PH_NOISY);
	
		PHALCON_INIT_VAR(lower_alias);
		phalcon_fast_strtolower(lower_alias, alias);
	} else {
		PHALCON_CPY_WRT(lower_alias, referenced_entity);
	}
	
	phalcon_array_append(&relations, relation, PH_SEPARATE);
	
	PHALCON_INIT_VAR(key_alias);
	PHALCON_CONCAT_VSV(key_alias, entity_name, "$", lower_alias);
	phalcon_update_property_array(this_ptr, SL("_aliases"), key_alias, relation TSRMLS_CC);
	
	phalcon_update_property_array(this_ptr, SL("_hasMany"), key_relation, relations TSRMLS_CC);
	
	PHALCON_OBS_VAR(has_many_single);
	phalcon_read_property_this(&has_many_single, this_ptr, SL("_hasManySingle"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_many_single, entity_name)) {
		PHALCON_INIT_VAR(single_relations);
		array_init(single_relations);
	} else {
		PHALCON_OBS_NVAR(single_relations);
		phalcon_array_fetch(&single_relations, has_many_single, entity_name, PH_NOISY);
	}
	
	phalcon_array_append(&single_relations, relation, PH_SEPARATE);
	
	phalcon_update_property_array(this_ptr, SL("_hasManySingle"), entity_name, single_relations TSRMLS_CC);
	
	RETURN_CTOR(relation);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, addHasManyToMany){

	zval *model, *fields, *intermediate_model, *intermediate_fields;
	zval *intermediate_referenced_fields, *referenced_model;
	zval *referenced_fields, *options = NULL, *entity_name;
	zval *intermediate_entity, *referenced_entity;
	zval *key_relation, *has_many_to_many, *relations = NULL;
	zval *number_fields = NULL, *number_referenced = NULL, *type;
	zval *relation, *alias, *lower_alias = NULL, *key_alias;
	zval *has_many_to_many_single, *single_relations = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 7, 1, &model, &fields, &intermediate_model, &intermediate_fields, &intermediate_referenced_fields, &referenced_model, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_get_class(entity_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(intermediate_entity);
	phalcon_fast_strtolower(intermediate_entity, intermediate_model);
	
	PHALCON_INIT_VAR(referenced_entity);
	phalcon_fast_strtolower(referenced_entity, referenced_model);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", referenced_entity);
	
	PHALCON_OBS_VAR(has_many_to_many);
	phalcon_read_property_this(&has_many_to_many, this_ptr, SL("_hasManyToMany"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_many_to_many, key_relation)) {
		PHALCON_INIT_VAR(relations);
		array_init(relations);
	} else {
		PHALCON_OBS_NVAR(relations);
		phalcon_array_fetch(&relations, has_many_to_many, key_relation, PH_NOISY);
	}
	
	if (Z_TYPE_P(intermediate_fields) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(number_fields);
		phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
		PHALCON_INIT_VAR(number_referenced);
		phalcon_fast_count(number_referenced, intermediate_fields TSRMLS_CC);
		if (!PHALCON_IS_EQUAL(number_fields, number_referenced)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
			return;
		}
	}
	
	if (Z_TYPE_P(intermediate_referenced_fields) == IS_ARRAY) { 
	
		PHALCON_INIT_NVAR(number_fields);
		phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
		PHALCON_INIT_NVAR(number_referenced);
		phalcon_fast_count(number_referenced, intermediate_fields TSRMLS_CC);
		if (!PHALCON_IS_EQUAL(number_fields, number_referenced)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Number of referenced fields are not the same");
			return;
		}
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_LONG(type, 4);
	
	PHALCON_INIT_VAR(relation);
	object_init_ex(relation, phalcon_mvc_model_relation_ce);
	PHALCON_CALL_METHOD(NULL, relation, "__construct", type, referenced_model, fields, referenced_fields, options);
	
	PHALCON_CALL_METHOD(NULL, relation, "setintermediaterelation", intermediate_fields, intermediate_model, intermediate_referenced_fields);
	
	if (phalcon_array_isset_quick_string(options, SS("alias"), 4060151663UL)) {
		PHALCON_OBS_VAR(alias);
		phalcon_array_fetch_quick_string(&alias, options, SS("alias"), 4060151663UL, PH_NOISY);
	
		PHALCON_INIT_VAR(lower_alias);
		phalcon_fast_strtolower(lower_alias, alias);
	} else {
		PHALCON_CPY_WRT(lower_alias, referenced_entity);
	}
	
	phalcon_array_append(&relations, relation, PH_SEPARATE);
	
	PHALCON_INIT_VAR(key_alias);
	PHALCON_CONCAT_VSV(key_alias, entity_name, "$", lower_alias);
	phalcon_update_property_array(this_ptr, SL("_aliases"), key_alias, relation TSRMLS_CC);
	
	phalcon_update_property_array(this_ptr, SL("_hasManyToMany"), key_relation, relations TSRMLS_CC);
	
	PHALCON_OBS_VAR(has_many_to_many_single);
	phalcon_read_property_this(&has_many_to_many_single, this_ptr, SL("_hasManyToManySingle"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(has_many_to_many_single, entity_name)) {
		PHALCON_INIT_VAR(single_relations);
		array_init(single_relations);
	} else {
		PHALCON_OBS_NVAR(single_relations);
		phalcon_array_fetch(&single_relations, has_many_to_many_single, entity_name, PH_NOISY);
	}
	
	phalcon_array_append(&single_relations, relation, PH_SEPARATE);
	
	phalcon_update_property_array(this_ptr, SL("_hasManyToManySingle"), entity_name, single_relations TSRMLS_CC);
	
	RETURN_CTOR(relation);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsBelongsTo){

	zval *model_name, *model_relation, *initialized;
	zval *entity_name, *entity_relation, *key_relation;
	zval *belongs_to;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &model_relation);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_fast_strtolower(entity_name, model_name);
	
	PHALCON_INIT_VAR(entity_relation);
	phalcon_fast_strtolower(entity_relation, model_relation);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
	
	if (!phalcon_array_isset(initialized, entity_name)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "load", model_name);
	}
	
	PHALCON_OBS_VAR(belongs_to);
	phalcon_read_property_this(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(belongs_to, key_relation)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasMany){

	zval *model_name, *model_relation, *initialized;
	zval *entity_name, *entity_relation, *key_relation;
	zval *has_many;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &model_relation);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_fast_strtolower(entity_name, model_name);
	
	PHALCON_INIT_VAR(entity_relation);
	phalcon_fast_strtolower(entity_relation, model_relation);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
	
	if (!phalcon_array_isset(initialized, entity_name)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "load", model_name);
	}
	
	PHALCON_OBS_VAR(has_many);
	phalcon_read_property_this(&has_many, this_ptr, SL("_hasMany"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(has_many, key_relation)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasOne){

	zval *model_name, *model_relation, *initialized;
	zval *entity_name, *entity_relation, *key_relation;
	zval *has_one;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &model_relation);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_fast_strtolower(entity_name, model_name);
	
	PHALCON_INIT_VAR(entity_relation);
	phalcon_fast_strtolower(entity_relation, model_relation);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
	
	if (!phalcon_array_isset(initialized, entity_name)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "load", model_name);
	}
	
	PHALCON_OBS_VAR(has_one);
	phalcon_read_property_this(&has_one, this_ptr, SL("_hasOne"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(has_one, key_relation)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, existsHasManyToMany){

	zval *model_name, *model_relation, *initialized;
	zval *entity_name, *entity_relation, *key_relation;
	zval *has_many_to_many;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &model_relation);
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_fast_strtolower(entity_name, model_name);
	
	PHALCON_INIT_VAR(entity_relation);
	phalcon_fast_strtolower(entity_relation, model_relation);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
	
	if (!phalcon_array_isset(initialized, entity_name)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "load", model_name);
	}
	
	PHALCON_OBS_VAR(has_many_to_many);
	phalcon_read_property_this(&has_many_to_many, this_ptr, SL("_hasManyToMany"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(has_many_to_many, key_relation)) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationByAlias){

	zval *model_name, *alias, *aliases, *key_alias;
	zval *key_lower, *relation;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &alias);
	
	PHALCON_OBS_VAR(aliases);
	phalcon_read_property_this(&aliases, this_ptr, SL("_aliases"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(aliases) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(key_alias);
		PHALCON_CONCAT_VSV(key_alias, model_name, "$", alias);
	
		PHALCON_INIT_VAR(key_lower);
		phalcon_fast_strtolower(key_lower, key_alias);
		if (phalcon_array_isset(aliases, key_lower)) {
			PHALCON_OBS_VAR(relation);
			phalcon_array_fetch(&relation, aliases, key_lower, PH_NOISY);
			RETURN_CTOR(relation);
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationRecords){

	zval *relation, *method, *record, *parameters = NULL, *pre_conditions = NULL;
	zval *placeholders = NULL, *referenced_model = NULL, *is_through = NULL;
	zval *conditions = NULL, *intermediate_model = NULL, *intermediate_fields = NULL;
	zval *fields = NULL, *value = NULL, *condition = NULL, *join_conditions;
	zval *referenced_fields = NULL, *joined_join_conditions;
	zval *joined_conditions = NULL, *builder = NULL, *query = NULL, *referenced_field = NULL;
	zval *field = NULL, *ref_position = NULL, *dependency_injector = NULL;
	zval *find_params, *find_arguments = NULL, *arguments;
	zval *type = NULL, *retrieve_method = NULL, *reusable = NULL, *unique_key;
	zval *records = NULL, *referenced_entity = NULL, *call_object;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int f_reusable;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 1, &relation, &method, &record, &parameters);
	
	if (!parameters) {
		PHALCON_INIT_VAR(parameters);
	} else {
		PHALCON_SEPARATE_PARAM(parameters);
	}
	
	PHALCON_INIT_VAR(pre_conditions);
	
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		if (phalcon_array_isset_long(parameters, 0)) {
			PHALCON_OBS_NVAR(pre_conditions);
			phalcon_array_fetch_long(&pre_conditions, parameters, 0, PH_NOISY);
			phalcon_array_unset_long(&parameters, 0, PH_SEPARATE);
		} else {
			if (phalcon_array_isset_quick_string(parameters, SS("conditions"), 1055696255UL)) {
				PHALCON_OBS_NVAR(pre_conditions);
				phalcon_array_fetch_quick_string(&pre_conditions, parameters, SS("conditions"), 1055696255UL, PH_NOISY);
				phalcon_array_unset_string(&parameters, SS("conditions"), PH_SEPARATE);
			}
		}
	} else {
		if (Z_TYPE_P(parameters) == IS_STRING) {
			PHALCON_CPY_WRT(pre_conditions, parameters);
		}
	}
	
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		if (phalcon_array_isset_quick_string(parameters, SS("bind"), 254268962UL)) {
			PHALCON_OBS_VAR(placeholders);
			phalcon_array_fetch_quick_string(&placeholders, parameters, SS("bind"), 254268962UL, PH_NOISY);
			phalcon_array_unset_string(&parameters, SS("bind"), PH_SEPARATE);
		} else {
			PHALCON_INIT_NVAR(placeholders);
			array_init(placeholders);
		}
	} else {
		PHALCON_INIT_NVAR(placeholders);
		array_init(placeholders);
	}
	
	PHALCON_CALL_METHOD(&referenced_model, relation, "getreferencedmodel");
	
	PHALCON_CALL_METHOD(&is_through, relation, "isthrough");
	if (zend_is_true(is_through)) {
	
		PHALCON_INIT_VAR(conditions);
		array_init(conditions);
	
		PHALCON_CALL_METHOD(&intermediate_model, relation, "getintermediatemodel");
		PHALCON_CALL_METHOD(&intermediate_fields, relation, "getintermediatefields");
	
		PHALCON_CALL_METHOD(&fields, relation, "getfields");
		if (Z_TYPE_P(fields) != IS_ARRAY) { 
			PHALCON_CALL_METHOD(&value, record, "readattribute", fields);
	
			PHALCON_INIT_VAR(condition);
			PHALCON_CONCAT_SVSVS(condition, "[", intermediate_model, "].[", intermediate_fields, "] = ?0");
			phalcon_array_append(&conditions, condition, 0);
			phalcon_array_append(&placeholders, value, PH_SEPARATE);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Not supported");
			return;
		}
	
		PHALCON_INIT_VAR(join_conditions);
		array_init(join_conditions);
	
		PHALCON_CALL_METHOD(&intermediate_fields, relation, "getintermediatereferencedfields");
		if (Z_TYPE_P(intermediate_fields) != IS_ARRAY) { 
			PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
	
			PHALCON_INIT_NVAR(condition);
			PHALCON_CONCAT_SVSV(condition, "[", intermediate_model, "].[", intermediate_fields);
			PHALCON_SCONCAT_SVSVS(condition, "] = [", referenced_model, "].[", referenced_fields, "]");
			phalcon_array_append(&join_conditions, condition, PH_SEPARATE);
		} else {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Not supported");
			return;
		}
	
		PHALCON_INIT_VAR(joined_join_conditions);
		phalcon_fast_join_str(joined_join_conditions, SL(" AND "), join_conditions TSRMLS_CC);
	
		if (PHALCON_IS_NOT_EMPTY(pre_conditions)) {
			phalcon_array_append(&conditions, pre_conditions, PH_SEPARATE);
		}
	
		PHALCON_INIT_VAR(joined_conditions);
		phalcon_fast_join_str(joined_conditions, SL(" AND "), conditions TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&builder, this_ptr, "createbuilder", parameters);
		PHALCON_CALL_METHOD(NULL, builder, "from", referenced_model);
		PHALCON_CALL_METHOD(NULL, builder, "innerjoin", intermediate_model, joined_join_conditions);
		PHALCON_CALL_METHOD(NULL, builder, "andwhere", joined_conditions, placeholders);
	
		PHALCON_CALL_METHOD(&query, builder, "getquery");
	
		PHALCON_RETURN_CALL_METHOD(query, "execute");
		RETURN_MM();
	}
	
	if (PHALCON_IS_NOT_EMPTY(pre_conditions)) {
		PHALCON_INIT_NVAR(conditions);
		array_init_size(conditions, 1);
		phalcon_array_append(&conditions, pre_conditions, PH_SEPARATE);
	} else {
		PHALCON_INIT_NVAR(conditions);
		array_init(conditions);
	}
	
	PHALCON_CALL_METHOD(&fields, relation, "getfields");
	if (Z_TYPE_P(fields) != IS_ARRAY) { 
		PHALCON_CALL_METHOD(&value, record, "readattribute", fields);
	
		PHALCON_CALL_METHOD(&referenced_field, relation, "getreferencedfields");
	
		PHALCON_INIT_NVAR(condition);
		PHALCON_CONCAT_SVS(condition, "[", referenced_field, "] = ?0");
		phalcon_array_append(&conditions, condition, PH_SEPARATE);
		phalcon_array_append(&placeholders, value, PH_SEPARATE);
	} else {
		PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
	
		phalcon_is_iterable(fields, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(ref_position, ah0, hp0);
			PHALCON_GET_HVALUE(field);
	
			PHALCON_CALL_METHOD(&value, record, "readattribute", field);
	
			PHALCON_OBS_NVAR(referenced_field);
			phalcon_array_fetch(&referenced_field, referenced_fields, ref_position, PH_NOISY);
	
			PHALCON_INIT_NVAR(condition);
			PHALCON_CONCAT_SVSV(condition, "[", referenced_field, "] = ?", ref_position);
			phalcon_array_append(&conditions, condition, PH_SEPARATE);
			phalcon_array_append(&placeholders, value, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_CALL_METHOD(&dependency_injector, record, "getdi");
	
	PHALCON_INIT_NVAR(joined_conditions);
	phalcon_fast_join_str(joined_conditions, SL(" AND "), conditions TSRMLS_CC);
	
	PHALCON_INIT_VAR(find_params);
	array_init_size(find_params, 3);
	phalcon_array_append(&find_params, joined_conditions, 0);
	phalcon_array_update_string(&find_params, SL("bind"), placeholders, PH_COPY);
	phalcon_array_update_string(&find_params, SL("di"), dependency_injector, PH_COPY);
	if (Z_TYPE_P(parameters) == IS_ARRAY) { 
		PHALCON_INIT_VAR(find_arguments);
		phalcon_fast_array_merge(find_arguments, &find_params, &parameters TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(find_arguments, find_params);
	}
	
	PHALCON_INIT_VAR(arguments);
	array_init_size(arguments, 1);
	phalcon_array_append(&arguments, find_arguments, PH_SEPARATE);
	
	if (Z_TYPE_P(method) == IS_NULL) {
		PHALCON_CALL_METHOD(&type, relation, "gettype");
	
		PHALCON_INIT_VAR(retrieve_method);
		switch (phalcon_get_intval(type)) {
	
			case 0:
				ZVAL_STRING(retrieve_method, "findFirst", 1);
				break;
	
			case 1:
				ZVAL_STRING(retrieve_method, "findFirst", 1);
				break;
	
			case 2:
				ZVAL_STRING(retrieve_method, "find", 1);
				break;
	
		}
	} else {
		PHALCON_CPY_WRT(retrieve_method, method);
	}
	
	PHALCON_CALL_METHOD(&reusable, relation, "isreusable");
	if (zend_is_true(reusable)) {
		f_reusable = 1;
	
		PHALCON_INIT_VAR(unique_key);
		phalcon_unique_key(unique_key, referenced_model, arguments TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&records, this_ptr, "getreusablerecords", referenced_model, unique_key);
		if (Z_TYPE_P(records) == IS_ARRAY || Z_TYPE_P(records) == IS_OBJECT) {
			RETURN_CTOR(records);
		}
	}
	else {
		/* Use int variable in order not to confuse static code analysers */
		f_reusable = 0;
	}
	
	PHALCON_CALL_METHOD(&referenced_entity, this_ptr, "load", referenced_model);
	
	PHALCON_INIT_VAR(call_object);
	array_init_size(call_object, 2);
	phalcon_array_append(&call_object, referenced_entity, 0);
	phalcon_array_append(&call_object, retrieve_method, 0);
	
	PHALCON_INIT_NVAR(records);/**/
	PHALCON_CALL_USER_FUNC_ARRAY(records, call_object, arguments);
	
	if (f_reusable) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "setreusablerecords", referenced_model, unique_key, records);
	}
	
	RETURN_CTOR(records);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getReusableRecords){

	zval *model_name, *key, *reusable, *records;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model_name, &key);
	
	PHALCON_OBS_VAR(reusable);
	phalcon_read_property_this(&reusable, this_ptr, SL("_reusable"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(reusable, key)) {
		PHALCON_OBS_VAR(records);
		phalcon_array_fetch(&records, reusable, key, PH_NOISY);
		RETURN_CTOR(records);
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, setReusableRecords){

	zval *model_name, *key, *records;

	phalcon_fetch_params(0, 3, 0, &model_name, &key, &records);
	
	phalcon_update_property_array(this_ptr, SL("_reusable"), key, records TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, clearReusableObjects){


	phalcon_update_property_null(this_ptr, SL("_reusable") TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsToRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *belongs_to, *entity_name;
	zval *entity_relation, *key_relation, *relations;
	zval *relation;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &method, &model_name, &model_relation, &record, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(belongs_to);
	phalcon_read_property_this(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(belongs_to) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_fast_strtolower(entity_name, model_name);
	
		PHALCON_INIT_VAR(entity_relation);
		phalcon_fast_strtolower(entity_relation, model_relation);
	
		PHALCON_INIT_VAR(key_relation);
		PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
		if (!phalcon_array_isset(belongs_to, key_relation)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_OBS_VAR(relations);
		phalcon_array_fetch(&relations, belongs_to, key_relation, PH_NOISY);
	
		PHALCON_OBS_VAR(relation);
		phalcon_array_fetch_long(&relation, relations, 0, PH_NOISY);
	
		PHALCON_RETURN_CALL_METHOD(this_ptr, "getrelationrecords", relation, method, record, parameters);
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasManyRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *has_many, *entity_name, *entity_relation;
	zval *key_relation, *relations, *relation;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &method, &model_name, &model_relation, &record, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(has_many);
	phalcon_read_property_this(&has_many, this_ptr, SL("_hasMany"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_many) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_fast_strtolower(entity_name, model_name);
	
		PHALCON_INIT_VAR(entity_relation);
		phalcon_fast_strtolower(entity_relation, model_relation);
	
		PHALCON_INIT_VAR(key_relation);
		PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
		if (!phalcon_array_isset(has_many, key_relation)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_OBS_VAR(relations);
		phalcon_array_fetch(&relations, has_many, key_relation, PH_NOISY);
	
		PHALCON_OBS_VAR(relation);
		phalcon_array_fetch_long(&relation, relations, 0, PH_NOISY);
	
		PHALCON_RETURN_CALL_METHOD(this_ptr, "getrelationrecords", relation, method, record, parameters);
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneRecords){

	zval *method, *model_name, *model_relation, *record;
	zval *parameters = NULL, *has_one, *entity_name, *entity_relation;
	zval *key_relation, *relations, *relation;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 1, &method, &model_name, &model_relation, &record, &parameters);
	
	if (!parameters) {
		parameters = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(has_one);
	phalcon_read_property_this(&has_one, this_ptr, SL("_hasOne"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_one) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(entity_name);
		phalcon_fast_strtolower(entity_name, model_name);
	
		PHALCON_INIT_VAR(entity_relation);
		phalcon_fast_strtolower(entity_relation, model_relation);
	
		PHALCON_INIT_VAR(key_relation);
		PHALCON_CONCAT_VSV(key_relation, entity_name, "$", entity_relation);
		if (!phalcon_array_isset(has_one, key_relation)) {
			RETURN_MM_FALSE;
		}
	
		PHALCON_OBS_VAR(relations);
		phalcon_array_fetch(&relations, has_one, key_relation, PH_NOISY);
	
		PHALCON_OBS_VAR(relation);
		phalcon_array_fetch_long(&relation, relations, 0, PH_NOISY);
	
		PHALCON_RETURN_CALL_METHOD(this_ptr, "getrelationrecords", relation, method, record, parameters);
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getBelongsTo){

	zval *model, *belongs_to_single, *lower_name;
	zval *relations;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(belongs_to_single);
	phalcon_read_property_this(&belongs_to_single, this_ptr, SL("_belongsToSingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(belongs_to_single) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(lower_name);
		phalcon_get_class(lower_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(belongs_to_single, lower_name)) {
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, belongs_to_single, lower_name, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasMany){

	zval *model, *has_many_single, *lower_name, *relations;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(has_many_single);
	phalcon_read_property_this(&has_many_single, this_ptr, SL("_hasManySingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_many_single) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(lower_name);
		phalcon_get_class(lower_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(has_many_single, lower_name)) {
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, has_many_single, lower_name, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOne){

	zval *model, *has_one_single, *lower_name, *relations;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(has_one_single);
	phalcon_read_property_this(&has_one_single, this_ptr, SL("_hasOneSingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_one_single) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(lower_name);
		phalcon_get_class(lower_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(has_one_single, lower_name)) {
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, has_one_single, lower_name, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasManyToMany){

	zval *model, *has_many_to_many_single, *lower_name;
	zval *relations;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_OBS_VAR(has_many_to_many_single);
	phalcon_read_property_this(&has_many_to_many_single, this_ptr, SL("_hasManyToManySingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_many_to_many_single) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(lower_name);
		phalcon_get_class(lower_name, model, 1 TSRMLS_CC);
		if (phalcon_array_isset(has_many_to_many_single, lower_name)) {
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, has_many_to_many_single, lower_name, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	RETURN_MM_EMPTY_ARRAY();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getHasOneAndHasMany){

	zval *model, *has_one = NULL, *has_many = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_CALL_METHOD(&has_one, this_ptr, "gethasone", model);
	PHALCON_CALL_METHOD(&has_many, this_ptr, "gethasmany", model);
	phalcon_fast_array_merge(return_value, &has_one, &has_many TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelations){

	zval *model_name, *entity_name, *all_relations;
	zval *belongs_to, *relations = NULL, *relation = NULL, *has_many;
	zval *has_one;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model_name);
	
	PHALCON_INIT_VAR(entity_name);
	phalcon_fast_strtolower(entity_name, model_name);
	
	PHALCON_INIT_VAR(all_relations);
	array_init(all_relations);
	
	PHALCON_OBS_VAR(belongs_to);
	phalcon_read_property_this(&belongs_to, this_ptr, SL("_belongsToSingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(belongs_to) == IS_ARRAY) { 
		if (phalcon_array_isset(belongs_to, entity_name)) {
	
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, belongs_to, entity_name, PH_NOISY);
	
			phalcon_is_iterable(relations, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(relation);
	
				phalcon_array_append(&all_relations, relation, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	}
	
	PHALCON_OBS_VAR(has_many);
	phalcon_read_property_this(&has_many, this_ptr, SL("_hasManySingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_many) == IS_ARRAY) { 
		if (phalcon_array_isset(has_many, entity_name)) {
	
			PHALCON_OBS_NVAR(relations);
			phalcon_array_fetch(&relations, has_many, entity_name, PH_NOISY);
	
			phalcon_is_iterable(relations, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HVALUE(relation);
	
				phalcon_array_append(&all_relations, relation, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
		}
	}
	
	PHALCON_OBS_VAR(has_one);
	phalcon_read_property_this(&has_one, this_ptr, SL("_hasOneSingle"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_one) == IS_ARRAY) { 
		if (phalcon_array_isset(has_one, entity_name)) {
	
			PHALCON_OBS_NVAR(relations);
			phalcon_array_fetch(&relations, has_one, entity_name, PH_NOISY);
	
			phalcon_is_iterable(relations, &ah2, &hp2, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
				PHALCON_GET_HVALUE(relation);
	
				phalcon_array_append(&all_relations, relation, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah2, &hp2);
			}
	
		}
	}
	
	RETURN_CTOR(all_relations);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getRelationsBetween){

	zval *first, *second, *first_name, *second_name;
	zval *key_relation, *belongs_to, *relations = NULL;
	zval *has_many, *has_one;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &first, &second);
	
	PHALCON_INIT_VAR(first_name);
	phalcon_fast_strtolower(first_name, first);
	
	PHALCON_INIT_VAR(second_name);
	phalcon_fast_strtolower(second_name, second);
	
	PHALCON_INIT_VAR(key_relation);
	PHALCON_CONCAT_VSV(key_relation, first_name, "$", second_name);
	
	PHALCON_OBS_VAR(belongs_to);
	phalcon_read_property_this(&belongs_to, this_ptr, SL("_belongsTo"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(belongs_to) == IS_ARRAY) { 
		if (phalcon_array_isset(belongs_to, key_relation)) {
			PHALCON_OBS_VAR(relations);
			phalcon_array_fetch(&relations, belongs_to, key_relation, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	PHALCON_OBS_VAR(has_many);
	phalcon_read_property_this(&has_many, this_ptr, SL("_hasMany"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_many) == IS_ARRAY) { 
		if (phalcon_array_isset(has_many, key_relation)) {
			PHALCON_OBS_NVAR(relations);
			phalcon_array_fetch(&relations, has_many, key_relation, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	PHALCON_OBS_VAR(has_one);
	phalcon_read_property_this(&has_one, this_ptr, SL("_hasOne"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(has_one) == IS_ARRAY) { 
		if (phalcon_array_isset(has_one, key_relation)) {
			PHALCON_OBS_NVAR(relations);
			phalcon_array_fetch(&relations, has_one, key_relation, PH_NOISY);
			RETURN_CTOR(relations);
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, createQuery){

	zval *phql, *dependency_injector, *query;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &phql);
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 1);
	
	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD(NULL, query, "__construct", phql);
	
	PHALCON_CALL_METHOD(NULL, query, "setdi", dependency_injector);
	phalcon_update_property_this_quick(this_ptr, SL("_lastQuery"), query, 148087694UL TSRMLS_CC);
	
	RETURN_CTOR(query);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, executeQuery){

	zval *phql, *placeholders = NULL, *types = NULL, *dependency_injector;
	zval *query;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &phql, &placeholders, &types);
	
	if (!placeholders) {
		placeholders = PHALCON_GLOBAL(z_null);
	}
	
	if (!types) {
		types = PHALCON_GLOBAL(z_null);
	}

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injection object is required to access ORM services");
		return;
	}
	
	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD(NULL, query, "__construct", phql);
	
	PHALCON_CALL_METHOD(NULL, query, "setdi", dependency_injector);
	phalcon_update_property_this_quick(this_ptr, SL("_lastQuery"), query, 148087694UL TSRMLS_CC);
	
	PHALCON_RETURN_CALL_METHOD(query, "execute", placeholders, types);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, createBuilder){

	zval *params = NULL, *dependency_injector;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A dependency injection object is required to access ORM services");
		return;
	}
	
	object_init_ex(return_value, phalcon_mvc_model_query_builder_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", params, dependency_injector);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getLastQuery){


	RETURN_MEMBER_QUICK(this_ptr, "_lastQuery", 148087694UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, registerNamespaceAlias){

	zval *alias, *namespace;

	phalcon_fetch_params(0, 2, 0, &alias, &namespace);
	
	if (Z_TYPE_P(alias) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "The namespace alias must be a string");
		return;
	}
	if (Z_TYPE_P(namespace) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "The namespace must be a string");
		return;
	}
	
	phalcon_update_property_array(this_ptr, SL("_namespaceAliases"), alias, namespace TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getNamespaceAlias){

	zval *alias, *namespace_aliases, *namespace;
	zval *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &alias);
	
	PHALCON_OBS_VAR(namespace_aliases);
	phalcon_read_property_this(&namespace_aliases, this_ptr, SL("_namespaceAliases"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(namespace_aliases, alias)) {
		PHALCON_OBS_VAR(namespace);
		phalcon_array_fetch(&namespace, namespace_aliases, alias, PH_NOISY);
		RETURN_CTOR(namespace);
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SVS(exception_message, "Namespace alias '", alias, "' is not registered");
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, getNamespaceAliases){


	RETURN_MEMBER_QUICK(this_ptr, "_namespaceAliases", 3928808595UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Manager, __destruct){

	phalcon_orm_destroy_cache(TSRMLS_C);
}





zend_class_entry *phalcon_mvc_model_managerinterface_ce;

static const zend_function_entry phalcon_mvc_model_managerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, initialize, arginfo_phalcon_mvc_model_managerinterface_initialize)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, isInitialized, arginfo_phalcon_mvc_model_managerinterface_isinitialized)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getLastInitialized, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, load, arginfo_phalcon_mvc_model_managerinterface_load)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, addHasOne, arginfo_phalcon_mvc_model_managerinterface_addhasone)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, addBelongsTo, arginfo_phalcon_mvc_model_managerinterface_addbelongsto)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, addHasMany, arginfo_phalcon_mvc_model_managerinterface_addhasmany)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, existsBelongsTo, arginfo_phalcon_mvc_model_managerinterface_existsbelongsto)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, existsHasMany, arginfo_phalcon_mvc_model_managerinterface_existshasmany)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, existsHasOne, arginfo_phalcon_mvc_model_managerinterface_existshasone)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getBelongsToRecords, arginfo_phalcon_mvc_model_managerinterface_getbelongstorecords)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getHasManyRecords, arginfo_phalcon_mvc_model_managerinterface_gethasmanyrecords)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getHasOneRecords, arginfo_phalcon_mvc_model_managerinterface_gethasonerecords)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getBelongsTo, arginfo_phalcon_mvc_model_managerinterface_getbelongsto)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getHasMany, arginfo_phalcon_mvc_model_managerinterface_gethasmany)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getHasOne, arginfo_phalcon_mvc_model_managerinterface_gethasone)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getHasOneAndHasMany, arginfo_phalcon_mvc_model_managerinterface_gethasoneandhasmany)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getRelations, arginfo_phalcon_mvc_model_managerinterface_getrelations)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getRelationsBetween, arginfo_phalcon_mvc_model_managerinterface_getrelationsbetween)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, createQuery, arginfo_phalcon_mvc_model_managerinterface_createquery)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, executeQuery, arginfo_phalcon_mvc_model_managerinterface_executequery)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, createBuilder, arginfo_phalcon_mvc_model_managerinterface_createbuilder)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, addBehavior, arginfo_phalcon_mvc_model_managerinterface_addbehavior)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, notifyEvent, arginfo_phalcon_mvc_model_managerinterface_notifyevent)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, missingMethod, arginfo_phalcon_mvc_model_managerinterface_missingmethod)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ManagerInterface, getLastQuery, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ManagerInterface, mvc_model_managerinterface, phalcon_mvc_model_managerinterface_method_entry);

	return SUCCESS;
}

































zend_class_entry *phalcon_mvc_model_message_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Message, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Message, setType);
static PHP_METHOD(Phalcon_Mvc_Model_Message, getType);
static PHP_METHOD(Phalcon_Mvc_Model_Message, setCode);
static PHP_METHOD(Phalcon_Mvc_Model_Message, getCode);
static PHP_METHOD(Phalcon_Mvc_Model_Message, setMessage);
static PHP_METHOD(Phalcon_Mvc_Model_Message, getMessage);
static PHP_METHOD(Phalcon_Mvc_Model_Message, setField);
static PHP_METHOD(Phalcon_Mvc_Model_Message, getField);
static PHP_METHOD(Phalcon_Mvc_Model_Message, setModel);
static PHP_METHOD(Phalcon_Mvc_Model_Message, getModel);
static PHP_METHOD(Phalcon_Mvc_Model_Message, __toString);
static PHP_METHOD(Phalcon_Mvc_Model_Message, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_message___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
	ZEND_ARG_INFO(0, field)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_message_setmodel, 0, 0, 1)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_message_setcode, 0, 0, 1)
	ZEND_ARG_INFO(0, code)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_message_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Message, __construct, arginfo_phalcon_mvc_model_message___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Message, setType, arginfo_phalcon_mvc_model_messageinterface_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, setCode, arginfo_phalcon_mvc_model_message_setcode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, getCode, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, setMessage, arginfo_phalcon_mvc_model_messageinterface_setmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, getMessage, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, setField, arginfo_phalcon_mvc_model_messageinterface_setfield, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, getField, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, setModel, arginfo_phalcon_mvc_model_message_setmodel, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, getModel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, __toString, arginfo___tostring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Message, __set_state, arginfo___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Message){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Message, mvc_model_message, phalcon_mvc_model_message_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_field"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_message_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_message_ce, SL("_code"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_message_ce TSRMLS_CC, 1, phalcon_mvc_model_messageinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, __construct){

	zval *message, *field = NULL, *type = NULL, *model = NULL, *code = NULL;

	phalcon_fetch_params(0, 1, 4, &message, &field, &type, &code, &model);
	
	if (!field) {
		field = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	if (!model) {
		model = PHALCON_GLOBAL(z_null);
	}

	if (!code) {
		code = PHALCON_GLOBAL(z_zero);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	if (Z_TYPE_P(model) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	}
	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, setType){

	zval *type;

	phalcon_fetch_params(0, 1, 0, &type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, setCode){

	zval *code;

	phalcon_fetch_params(0, 1, 0, &code);

	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, getCode){

	RETURN_MEMBER_QUICK(this_ptr, "_code", 3971426015UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, setMessage){

	zval *message;

	phalcon_fetch_params(0, 1, 0, &message);
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, getMessage){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, setField){

	zval *field;

	phalcon_fetch_params(0, 1, 0, &field);
	
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, getField){


	RETURN_MEMBER_QUICK(this_ptr, "_field", 2318377128UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, setModel){

	zval *model;

	phalcon_fetch_params(0, 1, 0, &model);
	
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, getModel){


	RETURN_MEMBER_QUICK(this_ptr, "_model", 2599397109UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Message, __set_state){

	zval *message, *message_text, *field, *type, *code;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	PHALCON_OBS_VAR(message_text);
	phalcon_array_fetch_quick_string(&message_text, message, SS("_message"), 933579817UL, PH_NOISY);

	PHALCON_OBS_VAR(field);
	phalcon_array_fetch_quick_string(&field, message, SS("_field"), 2318377128UL, PH_NOISY);

	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, message, SS("_type"), 3991959110UL, PH_NOISY);

	PHALCON_OBS_VAR(code);
	phalcon_array_fetch_quick_string(&code, message, SS("_code"), 3971426015UL, PH_NOISY);

	object_init_ex(return_value, phalcon_mvc_model_message_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", message_text, field, type, code);
	
	RETURN_MM();
}






zend_class_entry *phalcon_mvc_model_messageinterface_ce;

static const zend_function_entry phalcon_mvc_model_messageinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, setType, arginfo_phalcon_mvc_model_messageinterface_settype)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, setMessage, arginfo_phalcon_mvc_model_messageinterface_setmessage)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, getMessage, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, setField, arginfo_phalcon_mvc_model_messageinterface_setfield)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MessageInterface, getField, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MessageInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, MessageInterface, mvc_model_messageinterface, phalcon_mvc_model_messageinterface_method_entry);

	return SUCCESS;
}











zend_class_entry *phalcon_mvc_model_metadata_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, _initialize);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setStrategy);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getStrategy);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readMetaData);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readMetaDataIndex);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, writeMetaDataIndex);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readColumnMap);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readColumnMapIndex);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getPrimaryKeyAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNonPrimaryKeyAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNotNullAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypesNumeric);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getIdentityField);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getBindTypes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticCreateAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticUpdateAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticCreateAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticUpdateAttributes);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getColumnMap);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getReverseColumnMap);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, hasAttribute);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, isEmpty);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData, reset);

static const zend_function_entry phalcon_mvc_model_metadata_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData, _initialize, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_MetaData, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, setStrategy, arginfo_phalcon_mvc_model_metadatainterface_setstrategy, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getStrategy, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, readMetaData, arginfo_phalcon_mvc_model_metadatainterface_readmetadata, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, readMetaDataIndex, arginfo_phalcon_mvc_model_metadatainterface_readmetadataindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, writeMetaDataIndex, arginfo_phalcon_mvc_model_metadatainterface_writemetadataindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, readColumnMap, arginfo_phalcon_mvc_model_metadatainterface_readcolumnmap, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, readColumnMapIndex, arginfo_phalcon_mvc_model_metadatainterface_readcolumnmapindex, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getAttributes, arginfo_phalcon_mvc_model_metadatainterface_getattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getPrimaryKeyAttributes, arginfo_phalcon_mvc_model_metadatainterface_getprimarykeyattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getNonPrimaryKeyAttributes, arginfo_phalcon_mvc_model_metadatainterface_getnonprimarykeyattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getNotNullAttributes, arginfo_phalcon_mvc_model_metadatainterface_getnotnullattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getDataTypes, arginfo_phalcon_mvc_model_metadatainterface_getdatatypes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getDataTypesNumeric, arginfo_phalcon_mvc_model_metadatainterface_getdatatypesnumeric, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getIdentityField, arginfo_phalcon_mvc_model_metadatainterface_getidentityfield, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getBindTypes, arginfo_phalcon_mvc_model_metadatainterface_getbindtypes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getAutomaticCreateAttributes, arginfo_phalcon_mvc_model_metadatainterface_getautomaticcreateattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getAutomaticUpdateAttributes, arginfo_phalcon_mvc_model_metadatainterface_getautomaticupdateattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, setAutomaticCreateAttributes, arginfo_phalcon_mvc_model_metadatainterface_setautomaticcreateattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, setAutomaticUpdateAttributes, arginfo_phalcon_mvc_model_metadatainterface_setautomaticupdateattributes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getColumnMap, arginfo_phalcon_mvc_model_metadatainterface_getcolumnmap, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, getReverseColumnMap, arginfo_phalcon_mvc_model_metadatainterface_getreversecolumnmap, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, hasAttribute, arginfo_phalcon_mvc_model_metadatainterface_hasattribute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, isEmpty, arginfo_phalcon_mvc_model_metadatainterface_isempty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData, reset, arginfo_phalcon_mvc_model_metadatainterface_reset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, MetaData, mvc_model_metadata, phalcon_mvc_model_metadata_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_metadata_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_metadata_ce, SL("_strategy"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_metadata_ce, SL("_metaData"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_metadata_ce, SL("_columnMap"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_ATTRIBUTES"),               PHALCON_MVC_MODEL_METADATA_MODELS_ATTRIBUTES               TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_PRIMARY_KEY"),              PHALCON_MVC_MODEL_METADATA_MODELS_PRIMARY_KEY              TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_NON_PRIMARY_KEY"),          PHALCON_MVC_MODEL_METADATA_MODELS_NON_PRIMARY_KEY          TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_NOT_NULL"),                 PHALCON_MVC_MODEL_METADATA_MODELS_NOT_NULL                 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES"),               PHALCON_MVC_MODEL_METADATA_MODELS_DATA_TYPES               TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES_NUMERIC"),       PHALCON_MVC_MODEL_METADATA_MODELS_DATA_TYPES_NUMERIC       TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATE_AT"),                  PHALCON_MVC_MODEL_METADATA_MODELS_DATE_AT                  TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATE_IN"),                  PHALCON_MVC_MODEL_METADATA_MODELS_DATE_IN                  TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_IDENTITY_COLUMN"),          PHALCON_MVC_MODEL_METADATA_MODELS_IDENTITY_COLUMN          TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_DATA_TYPES_BIND"),          PHALCON_MVC_MODEL_METADATA_MODELS_DATA_TYPES_BIND          TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_AUTOMATIC_DEFAULT_INSERT"), PHALCON_MVC_MODEL_METADATA_MODELS_AUTOMATIC_DEFAULT_INSERT TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_AUTOMATIC_DEFAULT_UPDATE"), PHALCON_MVC_MODEL_METADATA_MODELS_AUTOMATIC_DEFAULT_UPDATE TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_COLUMN_MAP"),         PHALCON_MVC_MODEL_METADATA_MODELS_COLUMN_MAP         TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_metadata_ce, SL("MODELS_REVERSE_COLUMN_MAP"), PHALCON_MVC_MODEL_METADATA_MODELS_REVERSE_COLUMN_MAP TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_ce TSRMLS_CC, 2, phalcon_di_injectionawareinterface_ce, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, _initialize){

	zval *model, *key, *table, *schema, *strategy = NULL, *class_name;
	zval *meta_data = NULL, *prefix_key = NULL, *data = NULL, *model_metadata = NULL;
	zval *exception_message, *dependency_injector;
	zval *key_name, *column_map = NULL, *model_column_map = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &model, &key, &table, &schema);
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(strategy);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 0 TSRMLS_CC);
	if (Z_TYPE_P(key) != IS_NULL) {
	
		PHALCON_OBS_VAR(meta_data);
		phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
		if (!phalcon_array_isset(meta_data, key)) {
	
			PHALCON_INIT_VAR(prefix_key);
			PHALCON_CONCAT_SV(prefix_key, "meta-", key);
	
			PHALCON_CALL_METHOD(&data, this_ptr, "read", prefix_key);
			if (Z_TYPE_P(data) != IS_NULL) {
				if (Z_TYPE_P(meta_data) != IS_ARRAY) { 
					PHALCON_INIT_NVAR(meta_data);
					array_init(meta_data);
				}
				phalcon_array_update_zval(&meta_data, key, data, PH_COPY | PH_SEPARATE);
				phalcon_update_property_this_quick(this_ptr, SL("_metaData"), meta_data, 1295805989UL TSRMLS_CC);
			} else {
				if (phalcon_method_quick_exists_ex(model, SS("metadata"), 2348961382UL TSRMLS_CC) == SUCCESS) {
					PHALCON_CALL_METHOD(&model_metadata, model, "metadata");
					if (Z_TYPE_P(model_metadata) != IS_ARRAY) { 
						PHALCON_INIT_VAR(exception_message);
						PHALCON_CONCAT_SV(exception_message, "Invalid meta-data for model ", class_name);
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
				} else {

					PHALCON_CALL_METHOD(&strategy, this_ptr, "getstrategy");
	
					PHALCON_CALL_METHOD(&model_metadata, strategy, "getmetadata", model, dependency_injector);
				}
	
				phalcon_update_property_array(this_ptr, SL("_metaData"), key, model_metadata TSRMLS_CC);
	
				PHALCON_CALL_METHOD(NULL, this_ptr, "write", prefix_key, model_metadata);
			}
		}
	}
	
	if (!PHALCON_GLOBAL(orm).column_renaming) {
		RETURN_MM_NULL();
	}
	
	PHALCON_INIT_VAR(key_name);
	phalcon_fast_strtolower(key_name, class_name);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(column_map, key_name)) {
		RETURN_MM_NULL();
	}
	
	if (Z_TYPE_P(column_map) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(column_map);
		array_init(column_map);
	}
	
	PHALCON_INIT_NVAR(prefix_key);
	PHALCON_CONCAT_SV(prefix_key, "map-", key_name);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "read", prefix_key);
	if (Z_TYPE_P(data) != IS_NULL) {
		phalcon_array_update_zval(&column_map, key_name, data, PH_COPY | PH_SEPARATE);
		phalcon_update_property_this_quick(this_ptr, SL("_columnMap"), column_map, 1530164624UL TSRMLS_CC);
		RETURN_MM_NULL();
	}
	
	if (Z_TYPE_P(strategy) != IS_OBJECT) {
		PHALCON_CALL_METHOD(&strategy, this_ptr, "getstrategy");
	}
	
	PHALCON_CALL_METHOD(&model_column_map, strategy, "getcolumnmaps", model, dependency_injector);
	
	phalcon_update_property_array(this_ptr, SL("_columnMap"), key_name, model_column_map TSRMLS_CC);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", prefix_key, model_column_map);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setStrategy){

	zval *strategy;

	phalcon_fetch_params(0, 1, 0, &strategy);
	
	if (Z_TYPE_P(strategy) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "The meta-data extraction strategy is not valid");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_strategy"), strategy, 1232382295UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getStrategy){

	zval *strategy;

	strategy = phalcon_fetch_nproperty_this(this_ptr, SL("_strategy"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(strategy) == IS_NULL) {
		PHALCON_ALLOC_GHOST_ZVAL(strategy);
		object_init_ex(strategy, phalcon_mvc_model_metadata_strategy_introspection_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_strategy"), strategy, 1232382295UL TSRMLS_CC);
	}
	
	RETURN_ZVAL(strategy, 1, 0);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readMetaData){

	zval *model, *table = NULL, *schema = NULL, *class_name, *key, *meta_data = NULL;
	zval *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	PHALCON_VERIFY_INTERFACE_EX(model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 1);
	
	PHALCON_CALL_METHOD(&table, model, "getsource");
	PHALCON_CALL_METHOD(&schema, model, "getschema");
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VSVV(key, class_name, "-", schema, table);
	
	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(meta_data, key)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_initialize", model, key, table, schema);
	
		PHALCON_OBS_NVAR(meta_data);
		phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(data);
	phalcon_array_fetch(&data, meta_data, key, PH_NOISY);
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readMetaDataIndex){

	zval **model, **index, *table = NULL, *schema = NULL, *class_name;
	zval *key, *meta_data = NULL, *meta_data_index, *attributes;

	phalcon_fetch_params_ex(2, 0, &model, &index);

	PHALCON_VERIFY_INTERFACE_EX(*model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 0);
	PHALCON_ENSURE_IS_LONG(index);

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&table, *model, "getsource");
	PHALCON_CALL_METHOD(&schema, *model, "getschema");
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, *model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VSVV(key, class_name, "-", schema, table);
	
	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(meta_data, key)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_initialize", *model, key, table, schema);
	
		PHALCON_OBS_NVAR(meta_data);
		phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(meta_data_index);
	phalcon_array_fetch(&meta_data_index, meta_data, key, PH_NOISY);
	
	PHALCON_OBS_VAR(attributes);
	phalcon_array_fetch(&attributes, meta_data_index, *index, PH_NOISY);
	
	RETURN_CTOR(attributes);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, writeMetaDataIndex){

	zval *model, *index, *data, *replace, *table = NULL, *schema = NULL, *class_name;
	zval *key, *meta_data = NULL, *arr, *value;
	HashTable *ah2;
	HashPosition hp2;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &model, &index, &data, &replace);
	PHALCON_VERIFY_INTERFACE_EX(model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 1);

	if (Z_TYPE_P(index) != IS_LONG) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Index must be a valid integer constant");
		return;
	}
	
	if (Z_TYPE_P(data) != IS_ARRAY && Z_TYPE_P(data) != IS_STRING && Z_TYPE_P(data) != IS_BOOL) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid data for index");
		return;
	}
	
	PHALCON_CALL_METHOD(&table, model, "getsource");
	PHALCON_CALL_METHOD(&schema, model, "getschema");
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 1 TSRMLS_CC);
	
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VSVV(key, class_name, "-", schema, table);
	
	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(meta_data, key)) {
		PHALCON_CALL_METHOD(NULL, this_ptr, "_initialize", model, key, table, schema);
	
		PHALCON_OBS_NVAR(meta_data);
		phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	} else if (!zend_is_true(replace)) {
		PHALCON_OBS_VAR(arr);
		phalcon_array_fetch(&arr, meta_data, key, PH_NOISY);

		PHALCON_OBS_VAR(value);
		phalcon_array_fetch(&value, arr, index, PH_NOISY);

		PHALCON_SEPARATE_PARAM(data);
		phalcon_is_iterable(value, &ah2, &hp2, 0, 0);

		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
			zval key2 = phalcon_get_current_key_w(ah2, &hp2);

			if (!phalcon_array_isset(data, &key2)) {
				phalcon_array_update_zval(&data, &key2, *hd, PH_COPY | PH_SEPARATE);
			}

			zend_hash_move_forward_ex(ah2, &hp2);
		}
	}
	
	phalcon_array_update_multi_2(&meta_data, key, index, data, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), meta_data, 1295805989UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readColumnMap){

	zval *model, *key_name, *column_map = NULL, *null_value;
	zval *data;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	PHALCON_VERIFY_INTERFACE_EX(model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 1);
	
	if (!PHALCON_GLOBAL(orm).column_renaming) {
		RETURN_MM();
	}

	PHALCON_INIT_VAR(key_name);
	phalcon_get_class(key_name, model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(column_map, key_name)) {
		null_value = PHALCON_GLOBAL(z_null);
		PHALCON_CALL_METHOD(NULL, this_ptr, "_initialize", model, null_value, null_value, null_value);
	
		PHALCON_OBS_NVAR(column_map);
		phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(data);
	phalcon_array_fetch(&data, column_map, key_name, PH_NOISY);
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, readColumnMapIndex){

	zval **model, **index, *key_name, *column_map = NULL, *null_value;
	zval *column_map_model, *attributes;

	phalcon_fetch_params_ex(2, 0, &model, &index);
	PHALCON_VERIFY_CLASS_EX(*model, phalcon_mvc_modelinterface_ce, phalcon_mvc_model_exception_ce, 0);
	PHALCON_ENSURE_IS_LONG(index);

	PHALCON_MM_GROW();

	if (!PHALCON_GLOBAL(orm).column_renaming) {
		RETURN_MM();
	}

	PHALCON_INIT_VAR(key_name);
	phalcon_get_class(key_name, *model, 1 TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset(column_map, key_name)) {
		null_value = PHALCON_GLOBAL(z_null);
		PHALCON_CALL_METHOD(NULL, this_ptr, "_initialize", *model, null_value, null_value, null_value);
	
		PHALCON_OBS_NVAR(column_map);
		phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	}
	
	PHALCON_OBS_VAR(column_map_model);
	phalcon_array_fetch(&column_map_model, column_map, key_name, PH_NOISY);
	
	PHALCON_OBS_VAR(attributes);
	phalcon_array_fetch(&attributes, column_map_model, *index, PH_NOISY);
	
	RETURN_CTOR(attributes);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAttributes){

	zval *model, *what;

	phalcon_fetch_params(0, 1, 0, &model);

	PHALCON_MM_GROW();

	PHALCON_ALLOC_GHOST_ZVAL(what);
	ZVAL_LONG(what, PHALCON_MVC_MODEL_METADATA_MODELS_ATTRIBUTES);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "readmetadataindex", model, what);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_TYPE_P(return_value) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupted");
		return;
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getPrimaryKeyAttributes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 1);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNonPrimaryKeyAttributes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 2);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getNotNullAttributes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 3);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 4);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getDataTypesNumeric){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 5);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getIdentityField){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 8);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getBindTypes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 9);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticCreateAttributes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 10);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getAutomaticUpdateAttributes){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 11);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readmetadataindex", model, index);
	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
		return;
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticCreateAttributes){

	zval *model, *attributes, *replace, *create_index;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &model, &attributes, &replace);
	
	PHALCON_INIT_VAR(create_index);
	ZVAL_LONG(create_index, 10);
	PHALCON_CALL_METHOD(NULL, this_ptr, "writemetadataindex", model, create_index, attributes, replace);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, setAutomaticUpdateAttributes){

	zval *model, *attributes, *replace, *create_index;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &model, &attributes, &replace);
	
	PHALCON_INIT_VAR(create_index);
	ZVAL_LONG(create_index, 11);
	PHALCON_CALL_METHOD(NULL, this_ptr, "writemetadataindex", model, create_index, attributes, replace);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getColumnMap){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 0);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readcolumnmapindex", model, index);
	if (Z_TYPE_P(data) != IS_NULL) {
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
			return;
		}
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, getReverseColumnMap){

	zval *model, *index, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &model);
	
	PHALCON_INIT_VAR(index);
	ZVAL_LONG(index, 1);
	
	PHALCON_CALL_METHOD(&data, this_ptr, "readcolumnmapindex", model, index);
	if (Z_TYPE_P(data) != IS_NULL) {
		if (Z_TYPE_P(data) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The meta-data is invalid or is corrupt");
			return;
		}
	}
	
	RETURN_CTOR(data);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, hasAttribute){

	zval *model, *attribute, *column_map = NULL, *meta_data = NULL;
	zval *data_types;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &attribute);
	
	if (Z_TYPE_P(attribute) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Attribute must be a string");
		return;
	}
	
	PHALCON_CALL_METHOD(&column_map, this_ptr, "getreversecolumnmap", model);
	if (Z_TYPE_P(column_map) == IS_ARRAY) { 
		if (phalcon_array_isset(column_map, attribute)) {
			RETURN_MM_TRUE;
		}
	} else {
		PHALCON_CALL_METHOD(&meta_data, this_ptr, "readmetadata", model);
	
		PHALCON_OBS_VAR(data_types);
		phalcon_array_fetch_long(&data_types, meta_data, 4, PH_NOISY);
		if (phalcon_array_isset(data_types, attribute)) {
			RETURN_MM_TRUE;
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, isEmpty){

	zval *meta_data;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	if (phalcon_fast_count_ev(meta_data TSRMLS_CC)) {
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData, reset){

	zval *empty_array;

	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_columnMap"), empty_array, 1530164624UL TSRMLS_CC);
}





zend_class_entry *phalcon_mvc_model_metadatainterface_ce;

static const zend_function_entry phalcon_mvc_model_metadatainterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, setStrategy, arginfo_phalcon_mvc_model_metadatainterface_setstrategy)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getStrategy, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, readMetaData, arginfo_phalcon_mvc_model_metadatainterface_readmetadata)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, readMetaDataIndex, arginfo_phalcon_mvc_model_metadatainterface_readmetadataindex)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, writeMetaDataIndex, arginfo_phalcon_mvc_model_metadatainterface_writemetadataindex)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, readColumnMap, arginfo_phalcon_mvc_model_metadatainterface_readcolumnmap)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, readColumnMapIndex, arginfo_phalcon_mvc_model_metadatainterface_readcolumnmapindex)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getAttributes, arginfo_phalcon_mvc_model_metadatainterface_getattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getPrimaryKeyAttributes, arginfo_phalcon_mvc_model_metadatainterface_getprimarykeyattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getNonPrimaryKeyAttributes, arginfo_phalcon_mvc_model_metadatainterface_getnonprimarykeyattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getNotNullAttributes, arginfo_phalcon_mvc_model_metadatainterface_getnotnullattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getDataTypes, arginfo_phalcon_mvc_model_metadatainterface_getdatatypes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getDataTypesNumeric, arginfo_phalcon_mvc_model_metadatainterface_getdatatypesnumeric)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getIdentityField, arginfo_phalcon_mvc_model_metadatainterface_getidentityfield)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getBindTypes, arginfo_phalcon_mvc_model_metadatainterface_getbindtypes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getAutomaticCreateAttributes, arginfo_phalcon_mvc_model_metadatainterface_getautomaticcreateattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getAutomaticUpdateAttributes, arginfo_phalcon_mvc_model_metadatainterface_getautomaticupdateattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, setAutomaticCreateAttributes, arginfo_phalcon_mvc_model_metadatainterface_setautomaticcreateattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, setAutomaticUpdateAttributes, arginfo_phalcon_mvc_model_metadatainterface_setautomaticupdateattributes)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getColumnMap, arginfo_phalcon_mvc_model_metadatainterface_getcolumnmap)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, getReverseColumnMap, arginfo_phalcon_mvc_model_metadatainterface_getreversecolumnmap)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, hasAttribute, arginfo_phalcon_mvc_model_metadatainterface_hasattribute)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, isEmpty, arginfo_phalcon_mvc_model_metadatainterface_isempty)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, reset, arginfo_phalcon_mvc_model_metadatainterface_reset)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, read, arginfo_phalcon_mvc_model_metadatainterface_read)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_MetaDataInterface, write, arginfo_phalcon_mvc_model_metadatainterface_write)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaDataInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, MetaDataInterface, mvc_model_metadatainterface, phalcon_mvc_model_metadatainterface_method_entry);

	return SUCCESS;
}

































zend_class_entry *phalcon_mvc_model_query_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Query, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setUniqueRow);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getUniqueRow);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getQualified);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getCallArgument);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getFunctionCall);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getExpression);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getSelectColumn);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getTable);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoinType);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getSingleJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getMultiJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoins);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getOrderClause);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getGroupClause);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getLimitClause);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareSelect);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareInsert);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareUpdate);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareDelete);
static PHP_METHOD(Phalcon_Mvc_Model_Query, parse);
static PHP_METHOD(Phalcon_Mvc_Model_Query, cache);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getCacheOptions);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getCache);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeSelect);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeInsert);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _getRelatedRecords);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeUpdate);
static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeDelete);
static PHP_METHOD(Phalcon_Mvc_Model_Query, execute);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getSingleResult);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setType);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getType);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setBindParams);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getBindParams);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setBindTypes);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getBindTypes);
static PHP_METHOD(Phalcon_Mvc_Model_Query, setIntermediate);
static PHP_METHOD(Phalcon_Mvc_Model_Query, getIntermediate);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, phql)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_setuniquerow, 0, 0, 1)
	ZEND_ARG_INFO(0, uniqueRow)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_cache, 0, 0, 1)
	ZEND_ARG_INFO(0, cacheOptions)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_getsingleresult, 0, 0, 0)
	ZEND_ARG_INFO(0, bindParams)
	ZEND_ARG_INFO(0, bindTypes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_settype, 0, 0, 1)
	ZEND_ARG_INFO(0, type)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_setbindparams, 0, 0, 1)
	ZEND_ARG_INFO(0, bindParams)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_setbindtypes, 0, 0, 1)
	ZEND_ARG_INFO(0, bindTypes)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_setintermediate, 0, 0, 1)
	ZEND_ARG_INFO(0, intermediate)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_query_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Query, __construct, arginfo_phalcon_mvc_model_query___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Query, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, setUniqueRow, arginfo_phalcon_mvc_model_query_setuniquerow, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getUniqueRow, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, _getQualified, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getCallArgument, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getFunctionCall, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getExpression, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getSelectColumn, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getTable, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getJoin, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getJoinType, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getSingleJoin, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getMultiJoin, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getJoins, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getOrderClause, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getGroupClause, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getLimitClause, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _prepareSelect, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _prepareInsert, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _prepareUpdate, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _prepareDelete, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, parse, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, cache, arginfo_phalcon_mvc_model_query_cache, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getCacheOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getCache, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, _executeSelect, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _executeInsert, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _getRelatedRecords, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _executeUpdate, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, _executeDelete, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Query, execute, arginfo_phalcon_mvc_model_queryinterface_execute, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getSingleResult, arginfo_phalcon_mvc_model_query_getsingleresult, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, setType, arginfo_phalcon_mvc_model_query_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, setBindParams, arginfo_phalcon_mvc_model_query_setbindparams, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getBindParams, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, setBindTypes, arginfo_phalcon_mvc_model_query_setbindtypes, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getBindTypes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, setIntermediate, arginfo_phalcon_mvc_model_query_setintermediate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query, getIntermediate, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Query, mvc_model_query, phalcon_mvc_model_query_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_metaData"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_phql"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_ast"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_intermediate"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_models"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_sqlAliases"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_sqlAliasesModels"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_sqlModelsAliases"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_sqlAliasesModelsInstances"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_sqlColumnAliases"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_modelsInstances"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_cacheOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_uniqueRow"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_bindParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_bindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_ce, SL("_irPhqlCache"), ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_query_ce, SL("TYPE_SELECT"), 309 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_query_ce, SL("TYPE_INSERT"), 306 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_query_ce, SL("TYPE_UPDATE"), 300 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_query_ce, SL("TYPE_DELETE"), 303 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_query_ce TSRMLS_CC, 2, phalcon_mvc_model_queryinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, __construct){

	zval *phql = NULL, *dependency_injector = NULL;

	phalcon_fetch_params(0, 0, 2, &phql, &dependency_injector);
	
	if (phql && Z_TYPE_P(phql) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_phql"), phql, 3986605817UL TSRMLS_CC);
	}

	if (dependency_injector && Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, this_ptr, "setdi", dependency_injector);
		PHALCON_MM_RESTORE();
	}
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setDI){

	zval *dependency_injector, *service = NULL, *manager = NULL;
	zval *meta_data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 1);
	
	PHALCON_INIT_VAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_modelsManager);
	
	PHALCON_CALL_METHOD(&manager, dependency_injector, "getshared", service);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Injected service 'modelsManager' is invalid");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(manager, phalcon_mvc_model_managerinterface_ce);

	PHALCON_INIT_NVAR(service);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_modelsMetadata);
	
	PHALCON_CALL_METHOD(&meta_data, dependency_injector, "getshared", service);
	if (Z_TYPE_P(meta_data) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Injected service 'modelsMetadata' is invalid");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(meta_data, phalcon_mvc_model_metadatainterface_ce);

	phalcon_update_property_this_quick(this_ptr, SL("_manager"), manager, 4140832863UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), meta_data, 1295805989UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setUniqueRow){

	zval *unique_row;

	phalcon_fetch_params(0, 1, 0, &unique_row);
	
	phalcon_update_property_this_quick(this_ptr, SL("_uniqueRow"), unique_row, 1221667347UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getUniqueRow){


	RETURN_MEMBER_QUICK(this_ptr, "_uniqueRow", 1221667347UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getQualified){

	zval *expr, *column_name, *sql_column_aliases;
	zval *meta_data, *column_domain;
	zval *source, *exception_message = NULL;
	zval *model = NULL, *column_map = NULL, *real_column_name = NULL;
	zval *has_model = NULL, *models_instances;
	zval *has_attribute = NULL, *models, *class_name;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	zval *s_qualified;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	PHALCON_OBS_VAR(column_name);
	phalcon_array_fetch_string(&column_name, expr, ISL(name), PH_NOISY);
	
	sql_column_aliases = phalcon_fetch_nproperty_this(this_ptr, SL("_sqlColumnAliases"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset(sql_column_aliases, column_name)) {
		array_init_size(return_value, 2);
		MAKE_STD_ZVAL(s_qualified);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(s_qualified, phalcon_interned_qualified);
		add_assoc_zval_ex(return_value, ISS(type), s_qualified);
		phalcon_array_update_string(&return_value, ISL(name), column_name, PH_COPY);
		RETURN_MM();
	}
	
	meta_data = phalcon_fetch_nproperty_this(this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset_quick_string(expr, SS("domain"), 542597917UL)) {
		zval *sql_aliases;

		PHALCON_OBS_VAR(column_domain);
		phalcon_array_fetch_string(&column_domain, expr, ISL(domain), PH_NOISY);
	
		sql_aliases = phalcon_fetch_nproperty_this(this_ptr, SL("_sqlAliases"), PH_NOISY TSRMLS_CC);
	
		if (!phalcon_array_isset_fetch(&source, sql_aliases, column_domain)) {
			zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Unknown model or alias '", column_domain, "' (1), when preparing: ", phql);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		if (PHALCON_GLOBAL(orm).column_renaming) {
	
			zval *sql_aliases_models_instances = phalcon_fetch_nproperty_this(this_ptr, SL("_sqlAliasesModelsInstances"), PH_NOISY TSRMLS_CC);
	
			if (!phalcon_array_isset(sql_aliases_models_instances, column_domain)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "There is no model related to model or alias '", column_domain, "', when executing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_OBS_VAR(model);
			phalcon_array_fetch(&model, sql_aliases_models_instances, column_domain, PH_NOISY);
	
			PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", model);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (phalcon_array_isset(column_map, column_name)) {
				PHALCON_OBS_VAR(real_column_name);
				phalcon_array_fetch(&real_column_name, column_map, column_name, PH_NOISY);
			} else {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "Column '", column_name, "' doesn't belong to the model or alias '", column_domain, "', when executing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_CPY_WRT(real_column_name, column_name);
		}
	} else {
		long int number = 0;

		PHALCON_INIT_VAR(has_model);
		ZVAL_FALSE(has_model);
	
		PHALCON_OBS_VAR(models_instances);
		phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	
		phalcon_is_iterable(models_instances, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(model);
	
			PHALCON_CALL_METHOD(&has_attribute, meta_data, "hasattribute", model, column_name);
			if (zend_is_true(has_attribute)) {
				++number;
				if (number > 1) {
					zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVSV(exception_message, "The column '", column_name, "' is ambiguous, when preparing: ", phql);
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
	
				PHALCON_CPY_WRT(has_model, model);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		if (PHALCON_IS_FALSE(has_model)) {
			zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Column '", column_name, "' doesn't belong to any of the selected models (1), when preparing: ", phql);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_OBS_VAR(models);
		phalcon_read_property_this(&models, this_ptr, SL("_models"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(models) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The models list was not loaded correctly");
			return;
		}
	
		PHALCON_INIT_VAR(class_name);
		phalcon_get_class(class_name, has_model, 0 TSRMLS_CC);
		if (!phalcon_array_isset_fetch(&source, models, class_name)) {
			zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Can't obtain the model '", column_name, "' source from the _models list, when preparing: ", phql);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", has_model);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		if (Z_TYPE_P(column_map) == IS_ARRAY) {
	
			if (phalcon_array_isset(column_map, column_name)) {
				PHALCON_OBS_NVAR(real_column_name);
				phalcon_array_fetch(&real_column_name, column_map, column_name, PH_NOISY);
			} else {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Column '", column_name, "' doesn't belong to any of the selected models (3), when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_CPY_WRT(real_column_name, column_name);
		}
	}
	
	MAKE_STD_ZVAL(s_qualified);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(s_qualified, phalcon_interned_qualified);
	array_init_size(return_value, 4);
	add_assoc_zval_ex(return_value, ISS(type), s_qualified);
	phalcon_array_update_string(&return_value, ISL(domain), source, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(name), real_column_name, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(balias), column_name, PH_COPY);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getCallArgument){

	zval *argument, *argument_type;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &argument);
	
	PHALCON_OBS_VAR(argument_type);
	phalcon_array_fetch_string(&argument_type, argument, ISL(type), PH_NOISY);
	if (PHALCON_IS_LONG(argument_type, PHQL_T_STARALL)) {
		zval *s_all;
		MAKE_STD_ZVAL(s_all);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(s_all, phalcon_interned_all);
		array_init_size(return_value, 1);
		add_assoc_zval_ex(return_value, ISS(type), s_all);
		RETURN_MM();
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_getexpression", argument);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getFunctionCall){

	zval *expr, *name, *arguments, *function_args = NULL, *argument = NULL;
	zval *argument_expr = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	int distinct;

	zval *s_functionCall;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	array_init_size(return_value, 4);

	PHALCON_OBS_VAR(name);
	phalcon_array_fetch_string(&name, expr, ISL(name), PH_NOISY);
	if (phalcon_array_isset_string_fetch(&arguments, expr, SS("arguments"))) {

		distinct = phalcon_array_isset_quick_string(expr, SS("distinct"), 73581991UL) ? 1 : 0;
	
		if (phalcon_array_isset_long(arguments, 0)) {
	
			PHALCON_INIT_VAR(function_args);
			array_init_size(function_args, zend_hash_num_elements(Z_ARRVAL_P(arguments)));
	
			phalcon_is_iterable(arguments, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(argument);
	
				PHALCON_CALL_METHOD(&argument_expr, this_ptr, "_getcallargument", argument);
				phalcon_array_append(&function_args, argument_expr, 0);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		} else {
			PHALCON_CALL_METHOD(&argument_expr, this_ptr, "_getcallargument", arguments);
	
			PHALCON_INIT_NVAR(function_args);
			array_init_size(function_args, 1);
			phalcon_array_append(&function_args, argument_expr, 0);
		}
	
		MAKE_STD_ZVAL(s_functionCall);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(s_functionCall, phalcon_interned_functionCall);
		add_assoc_zval_ex(return_value, ISS(type), s_functionCall);
		phalcon_array_update_string(&return_value, ISL(name), name, PH_COPY);
		phalcon_array_update_string(&return_value, ISL(arguments), function_args, PH_COPY);

		if (distinct) {
			add_assoc_bool_ex(return_value, ISS(distinct), distinct);
		}
	} else {
		MAKE_STD_ZVAL(s_functionCall);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(s_functionCall, phalcon_interned_functionCall);
		add_assoc_zval_ex(return_value, ISS(type), s_functionCall);
		phalcon_array_update_string(&return_value, ISL(name), name, PH_COPY);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getExpression){

	zval *expr, *quoting = NULL, *temp_not_quoting;
	zval *left = NULL, *right = NULL, *expr_type;
	zval *expr_value = NULL, *value = NULL, *escaped_value = NULL;
	zval *placeholder = NULL, *exception_message;
	zval *list_items, *expr_list_item = NULL;
	zval *expr_item = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &expr, &quoting);
	
	if (!quoting) {
		quoting = PHALCON_GLOBAL(z_true);
	}
	
	if (phalcon_array_isset_string(expr, ISS(type))) {
		zval *expr_left, *expr_right;

		PHALCON_INIT_VAR(temp_not_quoting);
		ZVAL_TRUE(temp_not_quoting);
	
		if (phalcon_array_isset_string_fetch(&expr_left, expr, SS("left"))) {
			PHALCON_CALL_METHOD(&left, this_ptr, "_getexpression", expr_left, temp_not_quoting);
		}
	
		if (phalcon_array_isset_string_fetch(&expr_right, expr, SS("right"))) {
			PHALCON_CALL_METHOD(&right, this_ptr, "_getexpression", expr_right, temp_not_quoting);
		}
	
		PHALCON_OBS_VAR(expr_type);
		phalcon_array_fetch_string(&expr_type, expr, ISL(type), PH_NOISY);
	
		switch (phalcon_get_intval(expr_type)) {
	
			case PHQL_T_LESS:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("<"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_EQUALS:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("="), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_GREATER:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL(">"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_NOTEQUALS:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("<>"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_LESSEQUAL:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("<="), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_GREATEREQUAL:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL(">="), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_AND:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("AND"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_OR:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("OR"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_QUALIFIED:
				PHALCON_RETURN_CALL_METHOD(this_ptr, "_getqualified", expr);
				break;
	
			case 359: /** @todo Is this code returned anywhere? */
				PHALCON_RETURN_CALL_METHOD(this_ptr, "_getaliased", expr);
				break;
	
			case PHQL_T_ADD:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("+"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_SUB:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("-"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_MUL:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("*"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_DIV:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("/"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_MOD:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("%"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_BITWISE_AND:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("&"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_BITWISE_OR:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("|"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_ENCLOSED:
				assert(left != NULL);
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("parentheses"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				break;
	
			case PHQL_T_MINUS:
				assert(right != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("unary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("-"), 1);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_INTEGER:
			case PHQL_T_DOUBLE:
				PHALCON_OBS_VAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
	
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				phalcon_array_update_string(&return_value, ISL(value), value, PH_COPY);
				break;
			
			case PHQL_T_RAW_QUALIFIED:
				PHALCON_OBS_VAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("name"), 268211462UL, PH_NOISY);
	
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				phalcon_array_update_string(&return_value, ISL(value), value, PH_COPY);
				break;

			case PHQL_T_TRUE:
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				add_assoc_stringl_ex(return_value, ISS(value), SL("TRUE"), 1);
				break;
	
			case PHQL_T_FALSE:
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				add_assoc_stringl_ex(return_value, ISS(value), SL("FALSE"), 1);
				break;
	
			case PHQL_T_STRING:
				PHALCON_OBS_VAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
				if (PHALCON_IS_TRUE(quoting)) {
	
					if (phalcon_memnstr_str(value, SL("'"))) {
						PHALCON_INIT_VAR(escaped_value);
						phalcon_orm_singlequotes(escaped_value, value TSRMLS_CC);
					} else {
						PHALCON_CPY_WRT(escaped_value, value);
					}
	
					PHALCON_INIT_VAR(expr_value);
					PHALCON_CONCAT_SVS(expr_value, "'", escaped_value, "'");
				} else {
					PHALCON_CPY_WRT(expr_value, value);
				}
	
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				phalcon_array_update_string(&return_value, ISL(value), expr_value, PH_COPY);
				break;
	
			case PHQL_T_NPLACEHOLDER: {
				zval question_mark, colon;

				PHALCON_OBS_VAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
	
				INIT_ZVAL(question_mark);
				INIT_ZVAL(colon);

				ZVAL_STRING(&question_mark, "?", 0);
				ZVAL_STRING(&colon, ":", 0);
	
				PHALCON_INIT_VAR(placeholder);
				phalcon_fast_str_replace(placeholder, &question_mark, &colon, value);
	
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("placeholder"), 1);
				phalcon_array_update_string(&return_value, ISL(value), placeholder, PH_COPY);
				break;
			}
	
			case PHQL_T_SPLACEHOLDER:
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
	
				PHALCON_INIT_NVAR(placeholder);
				PHALCON_CONCAT_SV(placeholder, ":", value);
	
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("placeholder"), 1);
				phalcon_array_update_string(&return_value, ISL(value), placeholder, PH_COPY);
				break;
	
			case PHQL_T_NULL:
				array_init_size(return_value, 2);
				add_assoc_stringl_ex(return_value, ISS(type), SL("literal"), 1);
				add_assoc_stringl_ex(return_value, ISS(value), SL("NULL"), 1);
				break;
	
			case PHQL_T_LIKE:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("LIKE"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_NLIKE:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("NOT LIKE"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_ILIKE:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("ILIKE"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_NILIKE:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("NOT ILIKE"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_NOT:
				assert(right != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("unary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("NOT "), 1);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_ISNULL:
				assert(left != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("unary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL(" IS NULL"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				break;
	
			case PHQL_T_ISNOTNULL:
				assert(left != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("unary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL(" IS NOT NULL"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				break;
	
			case PHQL_T_IN:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("IN"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_NOTIN:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("NOT IN"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_DISTINCT:
				assert(0);
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Unexpected PHQL_T_DISTINCT - this should not happen");
				return;
	
			case PHQL_T_BETWEEN:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("BETWEEN"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_AGAINST:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 4);
				add_assoc_stringl_ex(return_value, ISS(type), SL("binary-op"), 1);
				add_assoc_stringl_ex(return_value, ISS(op), SL("AGAINST"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_CAST:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("cast"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_CONVERT:
				assert(left != NULL && right != NULL);
				array_init_size(return_value, 3);
				add_assoc_stringl_ex(return_value, ISS(type), SL("convert"), 1);
				phalcon_array_update_string(&return_value, ISL(left), left, PH_COPY);
				phalcon_array_update_string(&return_value, ISL(right), right, PH_COPY);
				break;
	
			case PHQL_T_FCALL:
				PHALCON_RETURN_CALL_METHOD(this_ptr, "_getfunctioncall", expr);
				break;
	
			default:
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SV(exception_message, "Unknown expression type ", expr_type);
	
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
		}
	
		RETURN_MM();
	}
	
	if (phalcon_array_isset_quick_string(expr, SS("domain"), 542597917UL)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "_getqualified", expr);
		RETURN_MM();
	}
	
	if (phalcon_array_isset_long(expr, 0)) {
	
		PHALCON_INIT_VAR(list_items);
		array_init(list_items);
	
		phalcon_is_iterable(expr, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(expr_list_item);
	
			PHALCON_CALL_METHOD(&expr_item, this_ptr, "_getexpression", expr_list_item);
			phalcon_array_append(&list_items, expr_item, 0);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		array_init_size(return_value, 2);
		add_assoc_stringl_ex(return_value, ISS(type), SL("list"), 1);
		phalcon_array_append(&return_value, list_items, 0);
	
		RETURN_MM();
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Unknown expression");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getSelectColumn){

	zval *column, *column_type;
	zval *source = NULL, *model_name = NULL, *sql_column = NULL;
	zval *column_domain, *exception_message = NULL;
	zval *sql_column_alias = NULL;
	zval *prepared_alias = NULL;
	zval *column_data, *sql_expr_column = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &column);
	
	if (!phalcon_array_isset_string(column, ISS(type))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	PHALCON_OBS_VAR(column_type);
	phalcon_array_fetch_string(&column_type, column, ISL(type), PH_NOISY);
	if (PHALCON_IS_LONG(column_type, PHQL_T_STARALL)) {
		zval *models = phalcon_fetch_nproperty_this(this_ptr, SL("_models"), PH_NOISY TSRMLS_CC);
	
		phalcon_is_iterable(models, &ah0, &hp0, 0, 0);

		array_init_size(return_value, zend_hash_num_elements(ah0));
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(model_name, ah0, hp0);
			PHALCON_GET_HVALUE(source);
	
			PHALCON_INIT_NVAR(sql_column);
			array_init_size(sql_column, 3);
			add_assoc_stringl_ex(sql_column, ISS(type), SL("object"), 1);
			phalcon_array_update_string(&sql_column, ISL(model), model_name, PH_COPY);
			phalcon_array_update_string(&sql_column, ISL(column), source, PH_COPY);

			phalcon_array_append(&return_value, sql_column, 0);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		RETURN_MM();
	}
	
	if (!phalcon_array_isset_quick_string(column, SS("column"), 3545634419UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	if (PHALCON_IS_LONG(column_type, PHQL_T_DOMAINALL)) {
		zval *source, *sql_aliases_models;
		zval *sql_aliases = phalcon_fetch_nproperty_this(this_ptr, SL("_sqlAliases"), PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(column_domain);
		phalcon_array_fetch_quick_string(&column_domain, column, SS("column"), 3545634419UL, PH_NOISY);
		if (!phalcon_array_isset_fetch(&source, sql_aliases, column_domain)) {
			zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Unknown model or alias '", column_domain, "' (2), when preparing: ", phql);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_CPY_WRT(sql_column_alias, source);
	
		sql_aliases_models = phalcon_fetch_nproperty_this(this_ptr, SL("_sqlAliasesModels"), PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(model_name);
		phalcon_array_fetch(&model_name, sql_aliases_models, column_domain, PH_NOISY);
	
		if (PHALCON_IS_EQUAL(column_domain, model_name)) {
			PHALCON_INIT_VAR(prepared_alias);
			phalcon_lcfirst(prepared_alias, model_name);
		} else {
			PHALCON_CPY_WRT(prepared_alias, column_domain);
		}
	
		PHALCON_INIT_VAR(sql_column);
		array_init_size(sql_column, 4);
		add_assoc_stringl_ex(sql_column, ISS(type), SL("object"), 1);
		phalcon_array_update_string(&sql_column, ISL(model), model_name, PH_COPY);
		phalcon_array_update_string(&sql_column, ISL(column), sql_column_alias, PH_COPY);
		phalcon_array_update_string(&sql_column, ISL(balias), prepared_alias, PH_COPY);

		array_init_size(return_value, 1);
		phalcon_array_append(&return_value, sql_column, 0);
	
		RETURN_MM();
	}
	
	if (PHALCON_IS_LONG(column_type, PHQL_T_EXPR)) {
		zval *balias;

		PHALCON_INIT_NVAR(sql_column);
		array_init_size(sql_column, 4);
		add_assoc_stringl_ex(sql_column, ISS(type), SL("scalar"), 1);
	
		PHALCON_OBS_VAR(column_data);
		phalcon_array_fetch_quick_string(&column_data, column, SS("column"), 3545634419UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&sql_expr_column, this_ptr, "_getexpression", column_data);
	
		if (phalcon_array_isset_string_fetch(&balias, sql_expr_column, SS("balias"))) {
			phalcon_array_update_string(&sql_column, ISL(balias), balias, PH_COPY);
			phalcon_array_update_string(&sql_column, ISL(sqlAlias), balias, PH_COPY);
		}
	
		phalcon_array_update_string(&sql_column, ISL(column), sql_expr_column, PH_COPY);

		array_init_size(return_value, 1);
		phalcon_array_append(&return_value, sql_column, 0);
	
		RETURN_MM();
	}
	
	PHALCON_INIT_VAR(exception_message);
	PHALCON_CONCAT_SV(exception_message, "Unknown type of column ", column_type);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getTable){

	zval *manager, *qualified_name, *model_name;
	zval *model = NULL, *source = NULL, *schema = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &manager, &qualified_name);
	
	if (phalcon_array_isset_string_fetch(&model_name, qualified_name, SS("name"))) {
	
		PHALCON_CALL_METHOD(&model, manager, "load", model_name);
		PHALCON_CALL_METHOD(&source, model, "getsource");
		PHALCON_CALL_METHOD(&schema, model, "getschema");
		if (zend_is_true(schema)) {
			array_init_size(return_value, 2);
			phalcon_array_append(&return_value, schema, 0);
			phalcon_array_append(&return_value, source, 0);
			RETURN_MM();
		}
	
		RETURN_CTOR(source);
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoin){

	zval *manager, *join, *qualified, *qualified_type;
	zval *model_name, *model = NULL, *source = NULL, *schema = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &manager, &join);
	
	if (phalcon_array_isset_string_fetch(&qualified, join, SS("qualified"))) {
	
		PHALCON_OBS_VAR(qualified_type);
		phalcon_array_fetch_string(&qualified_type, qualified, ISL(type), PH_NOISY);
		if (PHALCON_IS_LONG(qualified_type, PHQL_T_QUALIFIED)) {
			PHALCON_OBS_VAR(model_name);
			phalcon_array_fetch_string(&model_name, qualified, ISL(name), PH_NOISY);
	
			PHALCON_CALL_METHOD(&model, manager, "load", model_name);
			PHALCON_CALL_METHOD(&source, model, "getsource");
			PHALCON_CALL_METHOD(&schema, model, "getschema");
	
			array_init_size(return_value, 4);
			phalcon_array_update_string(&return_value, SL("schema"), schema, PH_COPY);
			phalcon_array_update_string(&return_value, SL("source"), source, PH_COPY);
			phalcon_array_update_string(&return_value, SL("modelName"), model_name, PH_COPY);
			phalcon_array_update_string(&return_value, SL("model"), model, PH_COPY);
			RETURN_MM();
		}
	}
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoinType){

	zval *join, *type, *exception_message;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &join);
	
	if (!phalcon_array_isset_string(join, ISS(type))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_string(&type, join, ISL(type), PH_NOISY);
	
	switch (phalcon_get_intval(type)) {
	
		case PHQL_T_INNERJOIN:
			RETVAL_STRING("INNER", 1);
			break;
	
		case PHQL_T_LEFTJOIN:
			RETVAL_STRING("LEFT", 1);
			break;
	
		case PHQL_T_RIGHTJOIN:
			RETVAL_STRING("RIGHT", 1);
			break;
	
		case PHQL_T_CROSSJOIN:
			RETVAL_STRING("CROSS", 1);
			break;
	
		case PHQL_T_FULLJOIN:
			RETVAL_STRING("FULL OUTER", 1);
			break;
	
		default: {
			zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Unknown join type ", type, ", when preparing: ", phql);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getSingleJoin){

	zval *join_type, *join_source, *model_alias;
	zval *join_alias, *relation, *fields = NULL, *referenced_fields = NULL;
	zval *left = NULL, *left_expr = NULL, *right = NULL, *right_expr = NULL, *sql_join_condition = NULL;
	zval *sql_join_conditions;
	zval *field = NULL, *position = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 5, 0, &join_type, &join_source, &model_alias, &join_alias, &relation);
	
	PHALCON_CALL_METHOD(&fields, relation, "getfields");
	
	PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");

	PHALCON_INIT_VAR(sql_join_conditions);
	array_init_size(sql_join_conditions, 1);

	if (Z_TYPE_P(fields) != IS_ARRAY) { 
		PHALCON_INIT_VAR(left);
		array_init_size(left, 3);
		add_assoc_long_ex(left, ISS(type), PHQL_T_QUALIFIED);
		phalcon_array_update_string(&left, ISL(domain), model_alias, PH_COPY);
		phalcon_array_update_string(&left, ISL(name), fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&left_expr, this_ptr, "_getqualified", left);
	
		PHALCON_INIT_VAR(right);
		array_init_size(right, 3);
		add_assoc_stringl_ex(right, ISS(type), SL("qualified"), 1);
		phalcon_array_update_string(&right, ISL(domain), join_alias, PH_COPY);
		phalcon_array_update_string(&right, ISL(name), referenced_fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&right_expr, this_ptr, "_getqualified", right);
	
		PHALCON_INIT_NVAR(sql_join_condition);
		array_init_size(sql_join_condition, 4);
		add_assoc_stringl_ex(sql_join_condition, ISS(type), SL("binary-op"), 1);
		add_assoc_stringl_ex(sql_join_condition, ISS(op), SL("="), 1);
		phalcon_array_update_string(&sql_join_condition, ISL(left), left_expr, PH_COPY);
		phalcon_array_update_string(&sql_join_condition, ISL(right), right_expr, PH_COPY);
	
		phalcon_array_append(&sql_join_conditions, sql_join_condition, 0);
	} else {
		PHALCON_INIT_VAR(sql_join_conditions);
	
		phalcon_is_iterable(fields, &ah0, &hp0, 0, 0);
		array_init_size(sql_join_conditions, zend_hash_num_elements(ah0));
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			zval *referenced_field;

			PHALCON_GET_HKEY(position, ah0, hp0);
			PHALCON_GET_HVALUE(field);
	
			if (!phalcon_array_isset_fetch(&referenced_field, referenced_fields, position)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "The number of fields must be equal to the number of referenced fields in join ", model_alias, "-", join_alias, ", when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_NVAR(left);
			array_init_size(left, 3);
			add_assoc_long_ex(left, ISS(type), PHQL_T_QUALIFIED);
			phalcon_array_update_string(&left, ISL(domain), model_alias, PH_COPY);
			phalcon_array_update_string(&left, ISL(name), field, PH_COPY);
	
			PHALCON_CALL_METHOD(&left_expr, this_ptr, "_getqualified", left);
	
			PHALCON_INIT_NVAR(right);
			array_init_size(right, 3);
			add_assoc_stringl_ex(right, ISS(type), SL("qualified"), 1);
			phalcon_array_update_string(&right, ISL(domain), join_alias, PH_COPY);
			phalcon_array_update_string(&right, ISL(name), referenced_field, PH_COPY);
	
			PHALCON_CALL_METHOD(&right_expr, this_ptr, "_getqualified", right);
	
			PHALCON_INIT_NVAR(sql_join_condition);
			array_init_size(sql_join_condition, 4);
			add_assoc_stringl_ex(sql_join_condition, ISS(type), SL("binary-op"), 1);
			add_assoc_stringl_ex(sql_join_condition, ISS(op), SL("="), 1);
			phalcon_array_update_string(&sql_join_condition, ISL(left), left_expr, PH_COPY);
			phalcon_array_update_string(&sql_join_condition, ISL(right), right_expr, PH_COPY);
			phalcon_array_append(&sql_join_conditions, sql_join_condition, 0);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	array_init_size(return_value, 3);
	phalcon_array_update_string(&return_value, ISL(type), join_type, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(source), join_source, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(conditions), sql_join_conditions, PH_COPY);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getMultiJoin){

	zval *join_type, *join_source, *model_alias;
	zval *join_alias, *relation, *fields = NULL;
	zval *referenced_fields = NULL, *intermediate_model_name = NULL;
	zval *manager, *intermediate_model = NULL, *intermediate_source = NULL;
	zval *intermediate_schema = NULL, *intermediate_full_source;
	zval *intermediate_fields = NULL, *intermediate_referenced_fields = NULL;
	zval *referenced_model_name = NULL, *field = NULL, *position = NULL;
	zval *exception_message = NULL;
	zval *left = NULL, *left_expr = NULL, *right = NULL, *right_expr = NULL, *sql_equals_join_condition = NULL;
	zval *sql_join_condition_first, *sql_join_conditions_first;
	zval *sql_join_first, *sql_join_condition_second;
	zval *sql_join_conditions_second, *sql_join_second;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 5, 0, &join_type, &join_source, &model_alias, &join_alias, &relation);
	
	array_init(return_value);
	
	PHALCON_CALL_METHOD(&fields, relation, "getfields");
	
	PHALCON_CALL_METHOD(&referenced_fields, relation, "getreferencedfields");
	
	PHALCON_CALL_METHOD(&intermediate_model_name, relation, "getintermediatemodel");
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}
	
	PHALCON_CALL_METHOD(&intermediate_model, manager, "load", intermediate_model_name);
	
	PHALCON_CALL_METHOD(&intermediate_source, intermediate_model, "getsource");
	
	PHALCON_CALL_METHOD(&intermediate_schema, intermediate_model, "getschema");
	
	PHALCON_INIT_VAR(intermediate_full_source);
	array_init_size(intermediate_full_source, 2);
	phalcon_array_append(&intermediate_full_source, intermediate_schema, 0);
	phalcon_array_append(&intermediate_full_source, intermediate_source, 0);
	
	phalcon_update_property_array(this_ptr, SL("_sqlAliases"), intermediate_model_name, intermediate_source TSRMLS_CC);
	
	phalcon_update_property_array(this_ptr, SL("_sqlAliasesModelsInstances"), intermediate_model_name, intermediate_model TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&intermediate_fields, relation, "getintermediatefields");
	
	PHALCON_CALL_METHOD(&intermediate_referenced_fields, relation, "getintermediatereferencedfields");
	
	PHALCON_CALL_METHOD(&referenced_model_name, relation, "getreferencedmodel");
	if (Z_TYPE_P(fields) == IS_ARRAY) { 
		/** @todo The code seems dead - the empty array will be returned */
		phalcon_is_iterable(fields, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(position, ah0, hp0);
			PHALCON_GET_HVALUE(field);
	
			if (!phalcon_array_isset(referenced_fields, position)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "The number of fields must be equal to the number of referenced fields in join ", model_alias, "-", join_alias, ", when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_INIT_NVAR(left);
			array_init_size(left, 3);
			add_assoc_long_ex(left, ISS(type), PHQL_T_QUALIFIED);
			phalcon_array_update_string(&left, ISL(domain), model_alias, PH_COPY);
			phalcon_array_update_string(&left, ISL(name), field, PH_COPY);
	
			PHALCON_CALL_METHOD(&left_expr, this_ptr, "_getqualified", left);
	
			PHALCON_INIT_NVAR(right);
			array_init_size(right, 3);
			add_assoc_stringl_ex(right, ISS(type), SL("qualified"), 1);
			phalcon_array_update_string(&right, ISL(domain), join_alias, PH_COPY);
			phalcon_array_update_string(&right, ISL(name), referenced_fields, PH_COPY);
	
			PHALCON_CALL_METHOD(&right_expr, this_ptr, "_getqualified", right);
	
			PHALCON_INIT_NVAR(sql_equals_join_condition);
			array_init_size(sql_equals_join_condition, 4);
			add_assoc_stringl_ex(sql_equals_join_condition, ISS(type), SL("binary-op"), 1);
			add_assoc_stringl_ex(sql_equals_join_condition, ISS(op), SL("="), 1);
			phalcon_array_update_string(&sql_equals_join_condition, ISL(left), left_expr, PH_COPY);
			phalcon_array_update_string(&sql_equals_join_condition, ISL(right), right_expr, PH_COPY);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		PHALCON_INIT_NVAR(left);
		array_init_size(left, 3);
		add_assoc_long_ex(left, ISS(type), PHQL_T_QUALIFIED);
		phalcon_array_update_string(&left, ISL(domain), model_alias, PH_COPY);
		phalcon_array_update_string(&left, ISL(name), fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&left_expr, this_ptr, "_getqualified", left);
	
		PHALCON_INIT_NVAR(right);
		array_init_size(right, 3);
		add_assoc_stringl_ex(right, ISS(type), SL("qualified"), 1);
		phalcon_array_update_string(&right, ISL(domain), intermediate_model_name, PH_COPY);
		phalcon_array_update_string(&right, ISL(name), intermediate_fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&right_expr, this_ptr, "_getqualified", right);
	
		PHALCON_INIT_VAR(sql_join_condition_first);
		array_init_size(sql_join_condition_first, 4);
		add_assoc_stringl_ex(sql_join_condition_first, ISS(type), SL("binary-op"), 1);
		add_assoc_stringl_ex(sql_join_condition_first, ISS(op), SL("="), 1);
		phalcon_array_update_string(&sql_join_condition_first, ISL(left), left_expr, PH_COPY);
		phalcon_array_update_string(&sql_join_condition_first, ISL(right), right_expr, PH_COPY);
	
		PHALCON_INIT_VAR(sql_join_conditions_first);
		array_init_size(sql_join_conditions_first, 1);
		phalcon_array_append(&sql_join_conditions_first, sql_join_condition_first, 0);
	
		PHALCON_INIT_VAR(sql_join_first);
		array_init_size(sql_join_first, 3);
		phalcon_array_update_string(&sql_join_first, ISL(type), join_type, PH_COPY);
		phalcon_array_update_string(&sql_join_first, ISL(source), intermediate_source, PH_COPY);
		phalcon_array_update_string(&sql_join_first, ISL(conditions), sql_join_conditions_first, PH_COPY);
	
		PHALCON_INIT_NVAR(left);
		array_init_size(left, 3);
		add_assoc_long_ex(left, ISS(type), PHQL_T_QUALIFIED);
		phalcon_array_update_string(&left, ISL(domain), intermediate_model_name, PH_COPY);
		phalcon_array_update_string(&left, ISL(name), intermediate_referenced_fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&left_expr, this_ptr, "_getqualified", left);
	
		PHALCON_INIT_NVAR(right);
		array_init_size(right, 3);
		add_assoc_stringl_ex(right, ISS(type), SL("qualified"), 1);
		phalcon_array_update_string(&right, ISL(domain), referenced_model_name, PH_COPY);
		phalcon_array_update_string(&right, ISL(name), referenced_fields, PH_COPY);
	
		PHALCON_CALL_METHOD(&right_expr, this_ptr, "_getqualified", right);
	
		PHALCON_INIT_VAR(sql_join_condition_second);
		array_init_size(sql_join_condition_second, 4);
		add_assoc_stringl_ex(sql_join_condition_second, ISS(type), SL("binary-op"), 1);
		add_assoc_stringl_ex(sql_join_condition_second, ISS(op), SL("="), 1);
		phalcon_array_update_string(&sql_join_condition_second, ISL(left), left_expr, PH_COPY);
		phalcon_array_update_string(&sql_join_condition_second, ISL(right), right_expr, PH_COPY);
	
		PHALCON_INIT_VAR(sql_join_conditions_second);
		array_init_size(sql_join_conditions_second, 1);
		phalcon_array_append(&sql_join_conditions_second, sql_join_condition_second, 0);
	
		PHALCON_INIT_VAR(sql_join_second);
		array_init_size(sql_join_second, 3);
		phalcon_array_update_string(&sql_join_second, ISL(type), join_type, PH_COPY);
		phalcon_array_update_string(&sql_join_second, ISL(source), join_source, PH_COPY);
		phalcon_array_update_string(&sql_join_second, ISL(conditions), sql_join_conditions_second, PH_COPY);

		phalcon_array_update_long(&return_value, 0, sql_join_first, PH_COPY);
		phalcon_array_update_long(&return_value, 1, sql_join_second, PH_COPY);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getJoins){

	zval *select, *models, *sql_aliases, *sql_aliases_models;
	zval *sql_models_aliases, *sql_aliases_models_instances;
	zval *models_instances, *from_models = NULL, *sql_joins = NULL;
	zval *join_models, *join_sources, *join_types;
	zval *join_pre_condition, *join_prepared;
	zval *manager = NULL, *joins, *select_joins = NULL, *join_item = NULL;
	zval *join_data = NULL, *source = NULL, *schema = NULL, *model = NULL, *model_name = NULL;
	zval *complete_source = NULL, *join_type = NULL, *alias_expr = NULL;
	zval *alias = NULL, *exception_message, *join_alias_name = NULL;
	zval *join_expr = NULL, *pre_condition = NULL, *from_model_name = NULL;
	zval *join_model = NULL, *join_alias = NULL, *join_source = NULL;
	zval *model_name_alias = NULL, *relation = NULL, *relations = NULL;
	zval *model_alias = NULL, *is_through = NULL;
	zval *sql_join = NULL, *new_sql_joins = NULL, *sql_join_conditions = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3;
	HashPosition hp0, hp1, hp2, hp3;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &select);
	
	PHALCON_OBS_VAR(models);
	phalcon_read_property_this(&models, this_ptr, SL("_models"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(sql_aliases);
	phalcon_read_property_this(&sql_aliases, this_ptr, SL("_sqlAliases"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(sql_aliases_models);
	phalcon_read_property_this(&sql_aliases_models, this_ptr, SL("_sqlAliasesModels"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(sql_models_aliases);
	phalcon_read_property_this(&sql_models_aliases, this_ptr, SL("_sqlModelsAliases"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(sql_aliases_models_instances);
	phalcon_read_property_this(&sql_aliases_models_instances, this_ptr, SL("_sqlAliasesModelsInstances"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(models_instances);
	phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	PHALCON_CPY_WRT(from_models, models);
	
	PHALCON_INIT_VAR(sql_joins);
	array_init(sql_joins);
	
	PHALCON_INIT_VAR(join_models);
	array_init(join_models);
	
	PHALCON_INIT_VAR(join_sources);
	array_init(join_sources);
	
	PHALCON_INIT_VAR(join_types);
	array_init(join_types);
	
	PHALCON_INIT_VAR(join_pre_condition);
	array_init(join_pre_condition);
	
	PHALCON_INIT_VAR(join_prepared);
	array_init(join_prepared);
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	PHALCON_OBS_VAR(joins);
	phalcon_array_fetch_quick_string(&joins, select, SS("joins"), 120974824UL, PH_NOISY);
	if (!phalcon_array_isset_long(joins, 0)) {
		PHALCON_INIT_VAR(select_joins);
		array_init_size(select_joins, 1);
		phalcon_array_append(&select_joins, joins, 0);
	} else {
		PHALCON_CPY_WRT(select_joins, joins);
	}
	
	phalcon_is_iterable(select_joins, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(join_item);
	
		PHALCON_CALL_METHOD(&join_data, this_ptr, "_getjoin", manager, join_item);
	
		PHALCON_OBS_NVAR(source);
		phalcon_array_fetch_quick_string(&source, join_data, SS("source"), 2744839734UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(schema);
		phalcon_array_fetch_quick_string(&schema, join_data, SS("schema"), 2259341622UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(model);
		phalcon_array_fetch_quick_string(&model, join_data, SS("model"), 238191286UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(model_name);
		phalcon_array_fetch_quick_string(&model_name, join_data, SS("modelName"), 440103543UL, PH_NOISY);
	
		PHALCON_INIT_NVAR(complete_source);
		array_init_size(complete_source, 2);
		phalcon_array_append(&complete_source, source, PH_SEPARATE);
		phalcon_array_append(&complete_source, schema, 0);
	
		PHALCON_CALL_METHOD(&join_type, this_ptr, "_getjointype", join_item);
	
		if (phalcon_array_isset_string_fetch(&alias_expr, join_item, SS("alias"))) {
	
			PHALCON_OBS_NVAR(alias);
			phalcon_array_fetch_string(&alias, alias_expr, ISL(name), PH_NOISY);
	
			if (phalcon_array_isset(join_models, alias)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Cannot use '", alias, "' as join alias because it was already used when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			phalcon_array_append(&complete_source, alias, PH_SEPARATE);
	
			phalcon_array_update_zval(&join_types, alias, join_type, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases, alias, alias, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_models, alias, model_name, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_models_aliases, model_name, alias, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases_models, alias, model_name, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases_models_instances, alias, model, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&models, model_name, alias, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_sources, alias, complete_source, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_prepared, alias, join_item, PH_COPY | PH_SEPARATE);
		} else {
			if (phalcon_array_isset(join_models, model_name)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Cannot use '", model_name, "' as join alias because it was already used when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			phalcon_array_update_zval(&join_types, model_name, join_type, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases, model_name, source, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_models, model_name, source, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_models_aliases, model_name, model_name, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases_models, model_name, model_name, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&sql_aliases_models_instances, model_name, model, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&models, model_name, source, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_sources, model_name, complete_source, PH_COPY | PH_SEPARATE);
	
			phalcon_array_update_zval(&join_prepared, model_name, join_item, PH_COPY | PH_SEPARATE);
		}
	
		phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliases"), sql_aliases, 3407085878UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModels"), sql_aliases_models, 848643194UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlModelsAliases"), sql_models_aliases, 1781491322UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModelsInstances"), sql_aliases_models_instances, 3347052930UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modelsInstances"), models_instances, 457905456UL TSRMLS_CC);
	
	phalcon_is_iterable(join_prepared, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HKEY(join_alias_name, ah1, hp1);
		PHALCON_GET_HVALUE(join_item);
	
		if (phalcon_array_isset_string_fetch(&join_expr, join_item, SS("conditions"))) {
			PHALCON_CALL_METHOD(&pre_condition, this_ptr, "_getexpression", join_expr);
			phalcon_array_update_zval(&join_pre_condition, join_alias_name, pre_condition, PH_COPY | PH_SEPARATE);
		}
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	phalcon_is_iterable(from_models, &ah2, &hp2, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
		PHALCON_GET_HKEY(from_model_name, ah2, hp2);
		PHALCON_GET_HVALUE(source);
	
		phalcon_is_iterable(join_models, &ah3, &hp3, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
			PHALCON_GET_HKEY(join_alias, ah3, hp3);
			PHALCON_GET_HVALUE(join_model);
	
			PHALCON_OBS_NVAR(join_source);
			phalcon_array_fetch(&join_source, join_sources, join_alias, PH_NOISY);
	
			PHALCON_OBS_NVAR(join_type);
			phalcon_array_fetch(&join_type, join_types, join_alias, PH_NOISY);
	
			if (!phalcon_array_isset(join_pre_condition, join_alias)) {
	
				PHALCON_OBS_NVAR(model_name_alias);
				phalcon_array_fetch(&model_name_alias, sql_aliases_models, join_alias, PH_NOISY);
	
				PHALCON_CALL_METHOD(&relation, manager, "getrelationbyalias", from_model_name, model_name_alias);
				if (PHALCON_IS_FALSE(relation)) {
	
					PHALCON_CALL_METHOD(&relations, manager, "getrelationsbetween", from_model_name, model_name_alias);
					if (Z_TYPE_P(relations) == IS_ARRAY) { 
	
						if (zend_hash_num_elements(Z_ARRVAL_P(relations)) != 1) {
							zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
							PHALCON_INIT_VAR(exception_message);
							PHALCON_CONCAT_SVSVSV(exception_message, "There is more than one relation between models '", model_name, "' and '", join_model, "\", the join must be done using an alias when preparing: ", phql);
							PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
							return;
						}
	
						PHALCON_OBS_NVAR(relation);
						phalcon_array_fetch_long(&relation, relations, 0, PH_NOISY);
					}
				}
	
				if (Z_TYPE_P(relation) == IS_OBJECT) {
	
					PHALCON_OBS_NVAR(model_alias);
					phalcon_array_fetch(&model_alias, sql_models_aliases, from_model_name, PH_NOISY);
	
					PHALCON_CALL_METHOD(&is_through, relation, "isthrough");
					if (!zend_is_true(is_through)) {
						PHALCON_CALL_METHOD(&sql_join, this_ptr, "_getsinglejoin", join_type, join_source, model_alias, join_alias, relation);
					} else {
						PHALCON_CALL_METHOD(&sql_join, this_ptr, "_getmultijoin", join_type, join_source, model_alias, join_alias, relation);
					}
	
					if (phalcon_array_isset_long(sql_join, 0)) {
						PHALCON_INIT_NVAR(new_sql_joins);
						phalcon_fast_array_merge(new_sql_joins, &sql_joins, &sql_join TSRMLS_CC);
						PHALCON_CPY_WRT(sql_joins, new_sql_joins);
					} else {
						phalcon_array_append(&sql_joins, sql_join, PH_SEPARATE);
					}
				} else {
					PHALCON_INIT_NVAR(sql_join_conditions);
					array_init(sql_join_conditions);
	
					PHALCON_INIT_NVAR(sql_join);
					array_init_size(sql_join, 3);
					phalcon_array_update_string(&sql_join, ISL(type), join_type, PH_COPY | PH_SEPARATE);
					phalcon_array_update_string(&sql_join, ISL(source), join_source, PH_COPY);
					phalcon_array_update_string(&sql_join, ISL(conditions), sql_join_conditions, PH_COPY);
					phalcon_array_append(&sql_joins, sql_join, PH_SEPARATE);
				}
			} else {
				PHALCON_OBS_NVAR(pre_condition);
				phalcon_array_fetch(&pre_condition, join_pre_condition, join_alias, PH_NOISY);
	
				PHALCON_INIT_NVAR(sql_join_conditions);
				array_init_size(sql_join_conditions, 1);
				phalcon_array_append(&sql_join_conditions, pre_condition, PH_SEPARATE);
	
				PHALCON_INIT_NVAR(sql_join);
				array_init_size(sql_join, 3);
				phalcon_array_update_string(&sql_join, ISL(type), join_type, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string(&sql_join, ISL(source), join_source, PH_COPY);
				phalcon_array_update_string(&sql_join, ISL(conditions), sql_join_conditions, PH_COPY);
				phalcon_array_append(&sql_joins, sql_join, PH_SEPARATE);
			}
	
			zend_hash_move_forward_ex(ah3, &hp3);
		}
	
		zend_hash_move_forward_ex(ah2, &hp2);
	}
	
	RETURN_CTOR(sql_joins);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getOrderClause){

	zval *order, *order_columns = NULL, *order_item = NULL;
	zval *order_column = NULL, *order_part_expr = NULL, *order_sort = NULL;
	zval *order_part_sort = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &order);
	
	if (!phalcon_array_isset_long(order, 0)) {
		PHALCON_INIT_VAR(order_columns);
		array_init_size(order_columns, 1);
		phalcon_array_append(&order_columns, order, 0);
	} else {
		PHALCON_CPY_WRT(order_columns, order);
	}
	
	phalcon_is_iterable(order_columns, &ah0, &hp0, 0, 0);
	array_init_size(return_value, zend_hash_num_elements(ah0));
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(order_item);
	
		PHALCON_OBS_NVAR(order_column);
		phalcon_array_fetch_quick_string(&order_column, order_item, SS("column"), 3545634419UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&order_part_expr, this_ptr, "_getexpression", order_column);
	
		if (phalcon_array_isset_string_fetch(&order_sort, order_item, SS("sort"))) {

			PHALCON_INIT_NVAR(order_part_sort);
			if (PHALCON_IS_LONG(order_sort, PHQL_T_ASC)) {
				array_init_size(order_part_sort, 2);
				phalcon_array_append(&order_part_sort, order_part_expr, 0);
				add_next_index_stringl(order_part_sort, SL("ASC"), 1);
			} else {
				array_init_size(order_part_sort, 2);
				phalcon_array_append(&order_part_sort, order_part_expr, 0);
				add_next_index_stringl(order_part_sort, SL("DESC"), 1);
			}
		} else {
			PHALCON_INIT_NVAR(order_part_sort);
			array_init_size(order_part_sort, 1);
			phalcon_array_append(&order_part_sort, order_part_expr, 0);
		}
	
		phalcon_array_append(&return_value, order_part_sort, 0);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getGroupClause){

	zval *group, *group_item = NULL, *group_part_expr = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &group);
	
	if (phalcon_array_isset_long(group, 0)) {
	
		phalcon_is_iterable(group, &ah0, &hp0, 0, 0);

		array_init_size(return_value, zend_hash_num_elements(ah0));
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(group_item);
	
			PHALCON_CALL_METHOD(&group_part_expr, this_ptr, "_getexpression", group_item);
			phalcon_array_append(&return_value, group_part_expr, 0);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		PHALCON_CALL_METHOD(&group_part_expr, this_ptr, "_getexpression", group);
	
		array_init_size(return_value, 1);
		phalcon_array_append(&return_value, group_part_expr, 0);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getLimitClause) {
	zval *limit_clause, *tmp = NULL;
	zval *limit, *offset;

	phalcon_fetch_params(0, 1, 0, &limit_clause);
	assert(Z_TYPE_P(limit_clause) == IS_ARRAY);

	array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(limit_clause)));

	PHALCON_MM_GROW();

	if (likely(phalcon_array_isset_string_fetch(&limit, limit_clause, SS("number")))) {
		PHALCON_CALL_METHOD(&tmp, getThis(), "_getexpression", limit);
		phalcon_array_update_string(&return_value, ISL(number), tmp, PH_COPY);
	}

	if (phalcon_array_isset_string_fetch(&offset, limit_clause, SS("offset"))) {
		PHALCON_CALL_METHOD(&tmp, getThis(), "_getexpression", offset);
		phalcon_array_update_string(&return_value, ISL(offset), tmp, PH_COPY);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareSelect){

	zval *ast, *select, *distinct = NULL, *sql_models, *sql_tables, *sql_aliases;
	zval *sql_columns, *sql_aliases_models, *sql_models_aliases;
	zval *sql_aliases_models_instances, *models;
	zval *models_instances, *tables, *selected_models = NULL;
	zval *manager, *selected_model = NULL, *qualified_name = NULL;
	zval *model_name = NULL, *real_namespace = NULL;
	zval *real_model_name = NULL, *model = NULL, *schema = NULL, *source = NULL;
	zval *complete_source = NULL, *alias = NULL, *exception_message = NULL;
	zval *joins, *sql_joins = NULL, *columns, *select_columns = NULL;
	zval *position, *sql_column_aliases, *column = NULL;
	zval *sql_column_group = NULL, *sql_column = NULL, *type = NULL, *sql_select;
	zval *where, *where_expr = NULL, *group_by, *sql_group = NULL;
	zval *having, *having_expr = NULL, *order, *sql_order = NULL;
	zval *limit, *sql_limit = NULL;
	HashTable *ah0, *ah1, *ah2;
	HashPosition hp0, hp1, hp2;
	zval **hd;

	PHALCON_MM_GROW();

	ast = phalcon_fetch_nproperty_this(this_ptr, SL("_ast"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(select);
	phalcon_array_fetch_quick_string(&select, ast, SS("select"), 2342345829UL, PH_NOISY);
	if (!phalcon_array_isset_string_fetch(&tables, select, SS("tables"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	if (!phalcon_array_isset_string_fetch(&columns, select, SS("columns"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted SELECT AST");
		return;
	}
	
	phalcon_array_isset_string_fetch(&distinct, select, SS("distinct"));

	PHALCON_INIT_VAR(sql_models);
	array_init(sql_models);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_columns);
	array_init(sql_columns);
	
	PHALCON_INIT_VAR(sql_aliases_models);
	array_init(sql_aliases_models);
	
	PHALCON_INIT_VAR(sql_models_aliases);
	array_init(sql_models_aliases);
	
	PHALCON_INIT_VAR(sql_aliases_models_instances);
	array_init(sql_aliases_models_instances);
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(models_instances);
	array_init(models_instances);
	
	if (!phalcon_array_isset_long(tables, 0)) {
		PHALCON_INIT_VAR(selected_models);
		array_init_size(selected_models, 1);
		phalcon_array_append(&selected_models, tables, 0);
	} else {
		PHALCON_CPY_WRT(selected_models, tables);
	}
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	phalcon_is_iterable(selected_models, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
		zval *ns_alias;
	
		PHALCON_GET_HVALUE(selected_model);
	
		PHALCON_OBS_NVAR(qualified_name);
		phalcon_array_fetch_quick_string(&qualified_name, selected_model, SS("qualifiedName"), 2418332666UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, ISL(name), PH_NOISY);
	
		if (phalcon_array_isset_string_fetch(&ns_alias, qualified_name, SS("ns-alias"))) {
	
			PHALCON_CALL_METHOD(&real_namespace, manager, "getnamespacealias", ns_alias);
	
			PHALCON_INIT_NVAR(real_model_name);
			PHALCON_CONCAT_VSV(real_model_name, real_namespace, "\\", model_name);
		} else {
			PHALCON_CPY_WRT(real_model_name, model_name);
		}
	
		PHALCON_CALL_METHOD(&model, manager, "load", real_model_name);
	
		PHALCON_CALL_METHOD(&schema, model, "getschema");
		PHALCON_CALL_METHOD(&source, model, "getsource");
	
		if (zend_is_true(schema)) {
			PHALCON_INIT_NVAR(complete_source);
			array_init_size(complete_source, 2);
			phalcon_array_append(&complete_source, source, PH_SEPARATE);
			phalcon_array_append(&complete_source, schema, 0);
		} else {
			PHALCON_CPY_WRT(complete_source, source);
		}
	
		if (phalcon_array_isset_string_fetch(&alias, selected_model, SS("alias"))) {
	
			if (phalcon_array_isset(sql_aliases, alias)) {
				zval *phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSV(exception_message, "Alias \"", alias, " is already used when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			phalcon_array_update_zval(&sql_aliases, alias, alias, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models, alias, model_name, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_models_aliases, model_name, alias, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, alias, model, PH_COPY | PH_SEPARATE);
	
			if (Z_TYPE_P(complete_source) == IS_ARRAY) { 
				phalcon_array_append(&complete_source, alias, PH_SEPARATE);
			} else {
				PHALCON_INIT_NVAR(complete_source);
				array_init_size(complete_source, 3);
				phalcon_array_append(&complete_source, source, PH_SEPARATE);
				add_next_index_null(complete_source);
				phalcon_array_append(&complete_source, alias, 0);
			}
	
			phalcon_array_update_zval(&models, model_name, alias, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, source, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models, model_name, model_name, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_models_aliases, model_name, model_name, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, model_name, model, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&models, model_name, source, PH_COPY | PH_SEPARATE);
		}
	
		phalcon_array_append(&sql_models, model_name, PH_SEPARATE);
		phalcon_array_append(&sql_tables, complete_source, PH_SEPARATE);
		phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modelsInstances"), models_instances, 457905456UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliases"), sql_aliases, 3407085878UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModels"), sql_aliases_models, 848643194UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlModelsAliases"), sql_models_aliases, 1781491322UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModelsInstances"), sql_aliases_models_instances, 3347052930UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modelsInstances"), models_instances, 457905456UL TSRMLS_CC);
	
	if (phalcon_array_isset_string_fetch(&joins, select, SS("joins"))) {
	
		PHALCON_INIT_VAR(sql_joins);
		if (phalcon_fast_count_ev(joins TSRMLS_CC)) {
			PHALCON_CALL_METHOD(&sql_joins, this_ptr, "_getjoins", select);
		} else {
			array_init(sql_joins);
		}
	} else {
		PHALCON_INIT_NVAR(sql_joins);
		array_init(sql_joins);
	}
	
	if (!phalcon_array_isset_long(columns, 0)) {
		PHALCON_INIT_VAR(select_columns);
		array_init_size(select_columns, 1);
		phalcon_array_append(&select_columns, columns, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(select_columns, columns);
	}
	
	PHALCON_INIT_VAR(position);
	ZVAL_LONG(position, 0);
	
	PHALCON_INIT_VAR(sql_column_aliases);
	array_init(sql_column_aliases);
	
	phalcon_is_iterable(select_columns, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HVALUE(column);
	
		PHALCON_CALL_METHOD(&sql_column_group, this_ptr, "_getselectcolumn", column);
	
		phalcon_is_iterable(sql_column_group, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HVALUE(sql_column);
	
			if (phalcon_array_isset_string_fetch(&alias, column, SS("alias"))) {
	
				phalcon_array_update_string(&sql_column, ISL(balias), alias, PH_COPY | PH_SEPARATE);
				phalcon_array_update_string(&sql_column, ISL(sqlAlias), alias, PH_COPY | PH_SEPARATE);
				phalcon_array_update_zval(&sql_columns, alias, sql_column, PH_COPY | PH_SEPARATE);
				phalcon_array_update_zval_bool(&sql_column_aliases, alias, 1, PH_SEPARATE);
			} else {

				if (phalcon_array_isset_string_fetch(&alias, sql_column, SS("balias"))) {
					phalcon_array_update_zval(&sql_columns, alias, sql_column, PH_COPY | PH_SEPARATE);
				} else {
					PHALCON_OBS_NVAR(type);
					phalcon_array_fetch_string(&type, sql_column, ISL(type), PH_NOISY);
					if (PHALCON_IS_STRING(type, "scalar")) {
						PHALCON_INIT_VAR(alias);
						PHALCON_CONCAT_SV(alias, "_", position);
						phalcon_array_update_zval(&sql_columns, alias, sql_column, PH_COPY | PH_SEPARATE);
					} else {
						phalcon_array_append(&sql_columns, sql_column, PH_SEPARATE);
					}
				}
			}

			phalcon_increment(position);
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_sqlColumnAliases"), sql_column_aliases, 3031417188UL TSRMLS_CC);
	
	PHALCON_INIT_VAR(sql_select);
	array_init_size(sql_select, 10);

	if (distinct) {
		phalcon_array_update_string(&sql_select, SL("distinct"), distinct, PH_COPY);
	}

	phalcon_array_update_string(&sql_select, ISL(models), sql_models, PH_COPY);
	phalcon_array_update_string(&sql_select, ISL(tables), sql_tables, PH_COPY);
	phalcon_array_update_string(&sql_select, ISL(columns), sql_columns, PH_COPY);
	if (phalcon_fast_count_ev(sql_joins TSRMLS_CC)) {
		phalcon_array_update_string(&sql_select, ISL(joins), sql_joins, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&where, ast, SS("where"))) {
		PHALCON_CALL_METHOD(&where_expr, this_ptr, "_getexpression", where);
		phalcon_array_update_string(&sql_select, ISL(where), where_expr, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&group_by, ast, SS("groupBy"))) {
		PHALCON_CALL_METHOD(&sql_group, this_ptr, "_getgroupclause", group_by);
		phalcon_array_update_string(&sql_select, ISL(group), sql_group, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&having, ast, SS("having"))) {
		PHALCON_CALL_METHOD(&having_expr, this_ptr, "_getexpression", having);
		phalcon_array_update_string(&sql_select, ISL(having), having_expr, PH_COPY);
	}
	
	if (phalcon_array_isset_quick_string(ast, SS("orderBy"), 609540828UL)) {
		PHALCON_OBS_VAR(order);
		phalcon_array_fetch_quick_string(&order, ast, SS("orderBy"), 609540828UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&sql_order, this_ptr, "_getorderclause", order);
		phalcon_array_update_string(&sql_select, ISL(order), sql_order, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&limit, ast, SS("limit"))) {
		PHALCON_CALL_METHOD(&sql_limit, this_ptr, "_getlimitclause", limit);
		phalcon_array_update_string(&sql_select, ISL(limit), sql_limit, PH_COPY);
	}
	
	RETURN_CTOR(sql_select);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareInsert){

	zval *ast, *qualified_name, *manager, *model_name;
	zval *model = NULL, *source = NULL, *schema = NULL, *sql_aliases, *not_quoting;
	zval *expr_values, *values, *expr_value = NULL, *expr_insert = NULL;
	zval *expr_type = NULL, *value = NULL, *sql_insert, *meta_data;
	zval *sql_fields, *fields, *field = NULL, *name = NULL, *has_attribute = NULL;
	zval *phql = NULL, *exception_message = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(ast);
	phalcon_read_property_this(&ast, this_ptr, SL("_ast"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_quick_string(ast, SS("qualifiedName"), 2418332666UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted INSERT AST");
		return;
	}
	
	if (!phalcon_array_isset_quick_string(ast, SS("values"), 1765818005UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted INSERT AST");
		return;
	}
	
	PHALCON_OBS_VAR(qualified_name);
	phalcon_array_fetch_quick_string(&qualified_name, ast, SS("qualifiedName"), 2418332666UL, PH_NOISY);
	
	if (!phalcon_array_isset_quick_string(qualified_name, SS("name"), 268211462UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted INSERT AST");
		return;
	}
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	PHALCON_OBS_VAR(model_name);
	phalcon_array_fetch_string(&model_name, qualified_name, ISL(name), PH_NOISY);
	
	PHALCON_CALL_METHOD(&model, manager, "load", model_name);
	PHALCON_CALL_METHOD(&source, model, "getsource");
	PHALCON_CALL_METHOD(&schema, model, "getschema");
	if (zend_is_true(schema)) {
		PHALCON_INIT_NVAR(source);
		array_init_size(source, 2);
		phalcon_array_append(&source, schema, PH_SEPARATE);
		phalcon_array_append(&source, source, 0);
	}
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(not_quoting);
	ZVAL_BOOL(not_quoting, 0);
	
	PHALCON_INIT_VAR(expr_values);
	array_init(expr_values);
	
	PHALCON_OBS_VAR(values);
	phalcon_array_fetch_quick_string(&values, ast, SS("values"), 1765818005UL, PH_NOISY);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(expr_value);
	
		PHALCON_CALL_METHOD(&expr_insert, this_ptr, "_getexpression", expr_value, not_quoting);
	
		PHALCON_OBS_NVAR(expr_type);
		phalcon_array_fetch_string(&expr_type, expr_value, ISL(type), PH_NOISY);
	
		PHALCON_INIT_NVAR(value);
		array_init_size(value, 2);
		phalcon_array_update_string(&value, ISL(type), expr_type, PH_COPY | PH_SEPARATE);
		phalcon_array_update_string(&value, ISL(value), expr_insert, PH_COPY | PH_SEPARATE);
		phalcon_array_append(&expr_values, value, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(sql_insert);
	array_init(sql_insert);
	phalcon_array_update_string(&sql_insert, ISL(model), model_name, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&sql_insert, ISL(table), source, PH_COPY | PH_SEPARATE);
	
	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&fields, ast, SS("fields"))) {
	
		PHALCON_INIT_VAR(sql_fields);
		array_init(sql_fields);
	
		phalcon_is_iterable(fields, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(field);
	
			PHALCON_OBS_NVAR(name);
			phalcon_array_fetch_string(&name, field, ISL(name), PH_NOISY);
	
			PHALCON_CALL_METHOD(&has_attribute, meta_data, "hasattribute", model, name);
			if (!zend_is_true(has_attribute)) {
				PHALCON_OBS_NVAR(phql);
				phalcon_read_property_this(&phql, this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVS(exception_message, "The model '", model_name, "' doesn't have the attribute '", name, "'");
				PHALCON_SCONCAT_SV(exception_message, ", when preparing: ", phql);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			phalcon_array_append(&sql_fields, name, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
		phalcon_array_update_string(&sql_insert, ISL(fields), sql_fields, PH_COPY | PH_SEPARATE);
	}
	
	phalcon_array_update_string(&sql_insert, ISL(values), expr_values, PH_COPY | PH_SEPARATE);
	
	RETURN_CTOR(sql_insert);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareUpdate){

	zval *ast, *update, *models, *models_instances;
	zval *sql_tables, *sql_models, *sql_aliases;
	zval *sql_aliases_models_instances, *tables;
	zval *update_tables = NULL, *manager, *table = NULL, *qualified_name = NULL;
	zval *model_name = NULL, *ns_alias = NULL, *real_namespace = NULL;
	zval *real_model_name = NULL, *model = NULL, *source = NULL, *schema = NULL;
	zval *complete_source = NULL, *alias = NULL, *sql_fields, *sql_values;
	zval *values, *update_values = NULL, *not_quoting = NULL, *update_value = NULL;
	zval *column = NULL, *sql_column = NULL, *expr_column = NULL, *expr_value = NULL;
	zval *type = NULL, *value = NULL, *where, *where_expr = NULL;
	zval *limit, *sql_limit = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(ast);
	phalcon_read_property_this(&ast, this_ptr, SL("_ast"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_quick_string(ast, SS("update"), 1051190696UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	PHALCON_OBS_VAR(update);
	phalcon_array_fetch_quick_string(&update, ast, SS("update"), 1051190696UL, PH_NOISY);
	if (!phalcon_array_isset_quick_string(update, SS("tables"), 3465666720UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	if (!phalcon_array_isset_quick_string(update, SS("values"), 1765818005UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted UPDATE AST");
		return;
	}
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(models_instances);
	array_init(models_instances);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(sql_models);
	array_init(sql_models);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_aliases_models_instances);
	array_init(sql_aliases_models_instances);
	
	PHALCON_OBS_VAR(tables);
	phalcon_array_fetch_quick_string(&tables, update, SS("tables"), 3465666720UL, PH_NOISY);
	if (!phalcon_array_isset_long(tables, 0)) {
		PHALCON_INIT_VAR(update_tables);
		array_init_size(update_tables, 1);
		phalcon_array_append(&update_tables, tables, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(update_tables, tables);
	}
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}
	
	phalcon_is_iterable(update_tables, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(table);
	
		PHALCON_OBS_NVAR(qualified_name);
		phalcon_array_fetch_quick_string(&qualified_name, table, SS("qualifiedName"), 2418332666UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, ISL(name), PH_NOISY);
	
		if (phalcon_array_isset_quick_string(qualified_name, SS("ns-alias"), 2470863549UL)) {
			PHALCON_OBS_NVAR(ns_alias);
			phalcon_array_fetch_quick_string(&ns_alias, qualified_name, SS("ns-alias"), 2470863549UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&real_namespace, manager, "getnamespacealias", ns_alias);
	
			PHALCON_INIT_NVAR(real_model_name);
			PHALCON_CONCAT_VSV(real_model_name, real_namespace, "\\", model_name);
		} else {
			PHALCON_CPY_WRT(real_model_name, model_name);
		}
	
		PHALCON_CALL_METHOD(&model, manager, "load", real_model_name);
		PHALCON_CALL_METHOD(&source, model, "getsource");
		PHALCON_CALL_METHOD(&schema, model, "getschema");
	
		if (zend_is_true(schema)) {
			PHALCON_INIT_NVAR(complete_source);
			array_init_size(complete_source, 2);
			phalcon_array_append(&complete_source, source, PH_SEPARATE);
			phalcon_array_append(&complete_source, schema, PH_SEPARATE);
		} else {
			PHALCON_INIT_NVAR(complete_source);
			array_init_size(complete_source, 2);
			phalcon_array_append(&complete_source, source, PH_SEPARATE);
			add_next_index_null(complete_source);
		}
	
		if (phalcon_array_isset_quick_string(table, SS("alias"), 4060151663UL)) {
			PHALCON_OBS_NVAR(alias);
			phalcon_array_fetch_quick_string(&alias, table, SS("alias"), 4060151663UL, PH_NOISY);
			phalcon_array_update_zval(&sql_aliases, alias, alias, PH_COPY | PH_SEPARATE);
			phalcon_array_append(&complete_source, alias, PH_SEPARATE);
			phalcon_array_append(&sql_tables, complete_source, PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, alias, model, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&models, alias, model_name, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, source, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, model_name, model, PH_COPY | PH_SEPARATE);
			phalcon_array_append(&sql_tables, source, PH_SEPARATE);
			phalcon_array_update_zval(&models, model_name, source, PH_COPY | PH_SEPARATE);
		}
	
		phalcon_array_append(&sql_models, model_name, PH_SEPARATE);
		phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modelsInstances"), models_instances, 457905456UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliases"), sql_aliases, 3407085878UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModelsInstances"), sql_aliases_models_instances, 3347052930UL TSRMLS_CC);
	
	PHALCON_INIT_VAR(sql_fields);
	array_init(sql_fields);
	
	PHALCON_INIT_VAR(sql_values);
	array_init(sql_values);
	
	PHALCON_OBS_VAR(values);
	phalcon_array_fetch_quick_string(&values, update, SS("values"), 1765818005UL, PH_NOISY);
	if (!phalcon_array_isset_long(values, 0)) {
		PHALCON_INIT_VAR(update_values);
		array_init_size(update_values, 1);
		phalcon_array_append(&update_values, values, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(update_values, values);
	}
	
	PHALCON_INIT_VAR(not_quoting);
	ZVAL_BOOL(not_quoting, 0);
	
	phalcon_is_iterable(update_values, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HVALUE(update_value);
	
		PHALCON_OBS_NVAR(column);
		phalcon_array_fetch_quick_string(&column, update_value, SS("column"), 3545634419UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&sql_column, this_ptr, "_getexpression", column, not_quoting);
		phalcon_array_append(&sql_fields, sql_column, PH_SEPARATE);
	
		PHALCON_OBS_NVAR(expr_column);
		phalcon_array_fetch_quick_string(&expr_column, update_value, SS("expr"), 258368420UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expr_value, this_ptr, "_getexpression", expr_column, not_quoting);
	
		PHALCON_OBS_NVAR(type);
		phalcon_array_fetch_string(&type, expr_column, ISL(type), PH_NOISY);
	
		PHALCON_INIT_NVAR(value);
		array_init_size(value, 2);
		phalcon_array_update_string(&value, ISL(type), type, PH_COPY | PH_SEPARATE);
		phalcon_array_update_string(&value, SL("value"), expr_value, PH_COPY | PH_SEPARATE);
		phalcon_array_append(&sql_values, value, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	array_init_size(return_value, 7);
	phalcon_array_update_string(&return_value, ISL(tables), sql_tables, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&return_value, ISL(models), sql_models, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(fields), sql_fields, PH_COPY);
	phalcon_array_update_string(&return_value, ISL(values), sql_values, PH_COPY);
	if (phalcon_array_isset_string_fetch(&where, ast, SS("where"))) {
		ZVAL_TRUE(not_quoting);
	
		PHALCON_CALL_METHOD(&where_expr, this_ptr, "_getexpression", where, not_quoting);
		phalcon_array_update_string(&return_value, ISL(where), where_expr, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&limit, ast, SS("limit"))) {
		PHALCON_CALL_METHOD(&sql_limit, this_ptr, "_getlimitclause", limit);
		phalcon_array_update_string(&return_value, ISL(limit), sql_limit, PH_COPY);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _prepareDelete){

	zval *ast, *delete, *models, *models_instances;
	zval *sql_tables, *sql_models, *sql_aliases;
	zval *sql_aliases_models_instances, *tables;
	zval *delete_tables = NULL, *manager, *table = NULL, *qualified_name = NULL;
	zval *model_name = NULL, *ns_alias = NULL, *real_namespace = NULL;
	zval *real_model_name = NULL, *model = NULL, *source = NULL, *schema = NULL;
	zval *complete_source = NULL, *alias = NULL, *not_quoting;
	zval *where, *where_expr = NULL;
	zval *limit, *sql_limit = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(ast);
	phalcon_read_property_this(&ast, this_ptr, SL("_ast"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_quick_string(ast, SS("delete"), 150213496UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted DELETE AST");
		return;
	}
	
	PHALCON_OBS_VAR(delete);
	phalcon_array_fetch_quick_string(&delete, ast, SS("delete"), 150213496UL, PH_NOISY);
	if (!phalcon_array_isset_quick_string(delete, SS("tables"), 3465666720UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted DELETE AST");
		return;
	}
	
	PHALCON_INIT_VAR(models);
	array_init(models);
	
	PHALCON_INIT_VAR(models_instances);
	array_init(models_instances);
	
	PHALCON_INIT_VAR(sql_tables);
	array_init(sql_tables);
	
	PHALCON_INIT_VAR(sql_models);
	array_init(sql_models);
	
	PHALCON_INIT_VAR(sql_aliases);
	array_init(sql_aliases);
	
	PHALCON_INIT_VAR(sql_aliases_models_instances);
	array_init(sql_aliases_models_instances);
	
	PHALCON_OBS_VAR(tables);
	phalcon_array_fetch_quick_string(&tables, delete, SS("tables"), 3465666720UL, PH_NOISY);
	if (!phalcon_array_isset_long(tables, 0)) {
		PHALCON_INIT_VAR(delete_tables);
		array_init_size(delete_tables, 1);
		phalcon_array_append(&delete_tables, tables, PH_SEPARATE);
	} else {
		PHALCON_CPY_WRT(delete_tables, tables);
	}
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	phalcon_is_iterable(delete_tables, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(table);
	
		PHALCON_OBS_NVAR(qualified_name);
		phalcon_array_fetch_quick_string(&qualified_name, table, SS("qualifiedName"), 2418332666UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(model_name);
		phalcon_array_fetch_string(&model_name, qualified_name, ISL(name), PH_NOISY);
	
		if (phalcon_array_isset_quick_string(qualified_name, SS("ns-alias"), 2470863549UL)) {
			PHALCON_OBS_NVAR(ns_alias);
			phalcon_array_fetch_quick_string(&ns_alias, qualified_name, SS("ns-alias"), 2470863549UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&real_namespace, manager, "getnamespacealias", ns_alias);
	
			PHALCON_INIT_NVAR(real_model_name);
			PHALCON_CONCAT_VSV(real_model_name, real_namespace, "\\", model_name);
		} else {
			PHALCON_CPY_WRT(real_model_name, model_name);
		}
	
		PHALCON_CALL_METHOD(&model, manager, "load", real_model_name);
		PHALCON_CALL_METHOD(&source, model, "getsource");
		PHALCON_CALL_METHOD(&schema, model, "getschema");
		if (zend_is_true(schema)) {
			PHALCON_INIT_NVAR(complete_source);
			array_init_size(complete_source, 2);
			phalcon_array_append(&complete_source, source, 0);
			phalcon_array_append(&complete_source, schema, 0);
		} else {
			PHALCON_INIT_NVAR(complete_source);
			array_init_size(complete_source, 2);
			phalcon_array_append(&complete_source, source, 0);
			add_next_index_null(complete_source);
		}
	
		if (phalcon_array_isset_quick_string(table, SS("alias"), 4060151663UL)) {
			PHALCON_OBS_NVAR(alias);
			phalcon_array_fetch_quick_string(&alias, table, SS("alias"), 4060151663UL, PH_NOISY);
			phalcon_array_update_zval(&sql_aliases, alias, alias, PH_COPY | PH_SEPARATE);
			phalcon_array_append(&complete_source, alias, PH_SEPARATE);
			phalcon_array_append(&sql_tables, complete_source, PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, alias, model, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&models, alias, model_name, PH_COPY | PH_SEPARATE);
		} else {
			phalcon_array_update_zval(&sql_aliases, model_name, source, PH_COPY | PH_SEPARATE);
			phalcon_array_update_zval(&sql_aliases_models_instances, model_name, model, PH_COPY | PH_SEPARATE);
			phalcon_array_append(&sql_tables, source, PH_SEPARATE);
			phalcon_array_update_zval(&models, model_name, source, PH_COPY | PH_SEPARATE);
		}
	
		phalcon_array_append(&sql_models, model_name, PH_SEPARATE);
		phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_modelsInstances"), models_instances, 457905456UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliases"), sql_aliases, 3407085878UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_sqlAliasesModelsInstances"), sql_aliases_models_instances, 3347052930UL TSRMLS_CC);
	
	array_init_size(return_value, 4);
	phalcon_array_update_string(&return_value, ISL(tables), sql_tables, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&return_value, ISL(models), sql_models, PH_COPY | PH_SEPARATE);
	if (phalcon_array_isset_string_fetch(&where, ast, SS("where"))) {
		PHALCON_INIT_VAR(not_quoting);
		ZVAL_TRUE(not_quoting);
	
		PHALCON_CALL_METHOD(&where_expr, this_ptr, "_getexpression", where, not_quoting);
		phalcon_array_update_string(&return_value, ISL(where), where_expr, PH_COPY);
	}
	
	if (phalcon_array_isset_string_fetch(&limit, ast, SS("limit"))) {
		PHALCON_CALL_METHOD(&sql_limit, this_ptr, "_getlimitclause", limit);
		phalcon_array_update_string(&return_value, ISL(limit), sql_limit, PH_COPY);
	}

	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, parse){

	zval *intermediate, *phql, *ast, *ir_phql = NULL, *ir_phql_cache = NULL;
	zval *unique_id = NULL, *type = NULL, *exception_message;

	PHALCON_MM_GROW();

	intermediate = phalcon_fetch_nproperty_this(this_ptr, SL("_intermediate"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(intermediate) == IS_ARRAY) { 
		RETURN_CTOR(intermediate);
	}
	
	phql = phalcon_fetch_nproperty_this(this_ptr, SL("_phql"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(ast);
	if (phql_parse_phql(ast, phql TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_INIT_VAR(ir_phql);
	
	PHALCON_INIT_VAR(ir_phql_cache);
	
	PHALCON_INIT_VAR(unique_id);
	
	if (Z_TYPE_P(ast) == IS_ARRAY) { 
	
		if (phalcon_array_isset_quick_string(ast, SS("id"), 193494642UL)) {
	
			PHALCON_OBS_NVAR(unique_id);
			phalcon_array_fetch_quick_string(&unique_id, ast, SS("id"), 193494642UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(ir_phql_cache);
			phalcon_read_static_property(&ir_phql_cache, SL("phalcon\\mvc\\model\\query"), SL("_irPhqlCache") TSRMLS_CC);
			if (phalcon_array_isset(ir_phql_cache, unique_id)) {
	
				PHALCON_OBS_NVAR(ir_phql);
				phalcon_array_fetch(&ir_phql, ir_phql_cache, unique_id, PH_NOISY);
				if (Z_TYPE_P(ir_phql) == IS_ARRAY) { 
					PHALCON_OBS_VAR(type);
					phalcon_array_fetch_string(&type, ast, ISL(type), PH_NOISY);
					phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
					RETURN_CTOR(ir_phql);
				}
			}
		}
	
		if (phalcon_array_isset_string(ast, ISS(type))) {
			phalcon_update_property_this_quick(this_ptr, SL("_ast"), ast, 250429676UL TSRMLS_CC);
	
			PHALCON_OBS_NVAR(type);
			phalcon_array_fetch_string(&type, ast, ISL(type), PH_NOISY);
			phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	
			switch (phalcon_get_intval(type)) {
	
				case PHQL_T_SELECT:
					PHALCON_CALL_METHOD(&ir_phql, this_ptr, "_prepareselect");
					break;
	
				case PHQL_T_INSERT:
					PHALCON_CALL_METHOD(&ir_phql, this_ptr, "_prepareinsert");
					break;
	
				case PHQL_T_UPDATE:
					PHALCON_CALL_METHOD(&ir_phql, this_ptr, "_prepareupdate");
					break;
	
				case PHQL_T_DELETE:
					PHALCON_CALL_METHOD(&ir_phql, this_ptr, "_preparedelete");
					break;
	
				default:
					PHALCON_INIT_VAR(exception_message);
					PHALCON_CONCAT_SVSV(exception_message, "Unknown statement ", type, ", when preparing: ", phql);
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
			}
		}
	}
	
	if (Z_TYPE_P(ir_phql) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Corrupted AST");
		return;
	}
	
	if (Z_TYPE_P(unique_id) == IS_LONG) {
		if (Z_TYPE_P(ir_phql_cache) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(ir_phql_cache);
			array_init(ir_phql_cache);
		}
		phalcon_array_update_zval(&ir_phql_cache, unique_id, ir_phql, PH_COPY | PH_SEPARATE);
		phalcon_update_static_property_ce(phalcon_mvc_model_query_ce, SL("_irPhqlCache"), ir_phql_cache TSRMLS_CC);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_intermediate"), ir_phql, 1829292799UL TSRMLS_CC);
	
	RETURN_CTOR(ir_phql);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, cache){

	zval *cache_options;

	phalcon_fetch_params(0, 1, 0, &cache_options);
	
	phalcon_update_property_this_quick(this_ptr, SL("_cacheOptions"), cache_options, 528255652UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getCacheOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_cacheOptions", 528255652UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getCache){


	RETURN_MEMBER_QUICK(this_ptr, "_cache", 2191407384UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeSelect){

	zval *intermediate, *bind_params, *bind_types;
	zval *manager, *models_instances = NULL, *models, *number_models;
	zval *model_name = NULL, *model = NULL, *connection = NULL, *connections;
	zval *type = NULL, *connection_types = NULL, *columns;
	zval *column = NULL, *column_type = NULL, *select_columns;
	zval *simple_column_map = NULL, *meta_data, *z_null;
	zval *alias_copy = NULL, *sql_column = NULL, *instance = NULL, *attributes = NULL;
	zval *column_map = NULL, *attribute = NULL, *hidden_alias = NULL;
	zval *column_alias = NULL, *is_keeping_snapshots = NULL;
	zval *sql_alias = NULL, *dialect = NULL, *sql_select = NULL, *processed = NULL;
	zval *value = NULL, *wildcard = NULL, *string_wildcard = NULL, *processed_types = NULL;
	zval *type_wildcard = NULL, *result = NULL, *count = NULL, *result_data = NULL;
	zval *cache, *result_object = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5, *ah6;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5, hp6;
	zval **hd;
	int have_scalars = 0, have_objects = 0, is_complex = 0, is_simple_std = 0;
	size_t number_objects = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &intermediate, &bind_params, &bind_types);
	
	PHALCON_SEPARATE_PARAM(intermediate);
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	PHALCON_OBS_VAR(models_instances);
	phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(models_instances) != IS_ARRAY) { 
		PHALCON_INIT_NVAR(models_instances);
		array_init(models_instances);
	}
	
	PHALCON_OBS_VAR(models);
	phalcon_array_fetch_quick_string(&models, intermediate, SS("models"), 3565348937UL, PH_NOISY);
	
	PHALCON_INIT_VAR(number_models);
	phalcon_fast_count(number_models, models TSRMLS_CC);
	if (PHALCON_IS_LONG(number_models, 1)) {
	
		PHALCON_OBS_VAR(model_name);
		phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY);
		if (!phalcon_array_isset(models_instances, model_name)) {
			PHALCON_CALL_METHOD(&model, manager, "load", model_name);
			phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
		} else {
			PHALCON_OBS_NVAR(model);
			phalcon_array_fetch(&model, models_instances, model_name, PH_NOISY);
		}
	
		if (phalcon_method_quick_exists_ex(model, SS("selectreadconnection"), 2893916401UL TSRMLS_CC) == SUCCESS) {
	
			PHALCON_CALL_METHOD(&connection, model, "selectreadconnection", intermediate, bind_params, bind_types);
			if (Z_TYPE_P(connection) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "'selectReadConnection' didn't returned a valid connection");
				return;
			}
		} else {
			PHALCON_CALL_METHOD(&connection, model, "getreadconnection");
		}
	} else {
		PHALCON_INIT_VAR(connections);
		array_init(connections);
	
		phalcon_is_iterable(models, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(model_name);
	
			if (!phalcon_array_isset(models_instances, model_name)) {
				PHALCON_CALL_METHOD(&model, manager, "load", model_name);
				phalcon_array_update_zval(&models_instances, model_name, model, PH_COPY | PH_SEPARATE);
			} else {
				PHALCON_OBS_NVAR(model);
				phalcon_array_fetch(&model, models_instances, model_name, PH_NOISY);
			}
	
			PHALCON_CALL_METHOD(&connection, model, "getreadconnection");
	
			PHALCON_CALL_METHOD(&type, connection, "gettype");
	
			phalcon_array_update_zval_bool(&connections, type, 1, PH_SEPARATE);
	
			PHALCON_INIT_NVAR(connection_types);
			phalcon_fast_count(connection_types, connections TSRMLS_CC);
	
			if (PHALCON_IS_LONG(connection_types, 2)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cannot use models of different database systems in the same query");
				return;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_OBS_VAR(columns);
	phalcon_array_fetch_quick_string(&columns, intermediate, SS("columns"), 1041822630UL, PH_NOISY);
	
	phalcon_is_iterable(columns, &ah1, &hp1, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
		PHALCON_GET_HVALUE(column);
	
		PHALCON_OBS_NVAR(column_type);
		phalcon_array_fetch_string(&column_type, column, ISL(type), PH_NOISY);
		if (PHALCON_IS_STRING(column_type, "scalar")) {
			if (!phalcon_array_isset_quick_string(column, SS("balias"), 1705826801UL)) {
				is_complex = 1;
			}
	
			have_scalars = 1;
		} else {
			have_objects = 1;
			++number_objects;
		}
	
		zend_hash_move_forward_ex(ah1, &hp1);
	}
	
	if (!is_complex) {
		if (have_objects) {
			if (have_scalars) {
				is_complex = 1;
			} else if (number_objects == 1) {
				is_simple_std = 0;
			} else {
				is_complex = 1;
			}
		} else {
			is_simple_std = 1;
		}
	}
	
	PHALCON_INIT_VAR(select_columns);
	array_init(select_columns);
	
	PHALCON_INIT_VAR(simple_column_map);
	array_init(simple_column_map);
	
	meta_data = phalcon_fetch_nproperty_this(this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	
	z_null = PHALCON_GLOBAL(z_null);
	
	phalcon_is_iterable(columns, &ah2, &hp2, 1, 0);
	
	while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
		zval key = phalcon_get_current_key_w(ah2, &hp2);
		PHALCON_CPY_WRT_CTOR(alias_copy, &key);

		PHALCON_GET_HVALUE(column);
	
		PHALCON_OBS_NVAR(type);
		phalcon_array_fetch_string(&type, column, ISL(type), PH_NOISY);
	
		PHALCON_OBS_NVAR(sql_column);
		phalcon_array_fetch_quick_string(&sql_column, column, SS("column"), 3545634419UL, PH_NOISY);
	
		if (PHALCON_IS_STRING(type, "object")) {
	
			PHALCON_OBS_NVAR(model_name);
			phalcon_array_fetch_quick_string(&model_name, column, SS("model"), 238191286UL, PH_NOISY);
	
			if (phalcon_array_isset(models_instances, model_name)) {
				PHALCON_OBS_NVAR(instance);
				phalcon_array_fetch(&instance, models_instances, model_name, PH_NOISY);
			} else {
				PHALCON_CALL_METHOD(&instance, manager, "load", model_name);
				phalcon_array_update_zval(&models_instances, model_name, instance, PH_COPY | PH_SEPARATE);
			}
	
			PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", instance);
			if (is_complex) {
	
				if (PHALCON_GLOBAL(orm).column_renaming) {
					PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", instance);
				} else {
					PHALCON_CPY_WRT(column_map, z_null);
				}
	
				phalcon_is_iterable(attributes, &ah3, &hp3, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
					PHALCON_GET_HVALUE(attribute);
	
					PHALCON_INIT_NVAR(hidden_alias);
					PHALCON_CONCAT_SVSV(hidden_alias, "_", sql_column, "_", attribute);
	
					PHALCON_INIT_NVAR(column_alias);
					array_init_size(column_alias, 3);
					phalcon_array_append(&column_alias, attribute, 0);
					phalcon_array_append(&column_alias, sql_column, 0);
					phalcon_array_append(&column_alias, hidden_alias, 0);
					phalcon_array_append(&select_columns, column_alias, PH_SEPARATE);
	
					zend_hash_move_forward_ex(ah3, &hp3);
				}
	
				phalcon_array_update_string_multi_2(&columns, alias_copy, SL("instance"),   instance, 0);
				phalcon_array_update_string_multi_2(&columns, alias_copy, SL("attributes"), attributes, 0);
				phalcon_array_update_string_multi_2(&columns, alias_copy, SL("columnMap"),  column_map, 0);
	
				PHALCON_CALL_METHOD(&is_keeping_snapshots, manager, "iskeepingsnapshots", instance);
				if (zend_is_true(is_keeping_snapshots)) {
					phalcon_array_update_string_multi_2(&columns, alias_copy, SL("keepSnapshots"), is_keeping_snapshots, 0);
				}
			} else {
				phalcon_is_iterable(attributes, &ah4, &hp4, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {
	
					PHALCON_GET_HVALUE(attribute);
	
					PHALCON_INIT_NVAR(column_alias);
					array_init_size(column_alias, 2);
					phalcon_array_append(&column_alias, attribute, 0);
					phalcon_array_append(&column_alias, sql_column, 0);
					phalcon_array_append(&select_columns, column_alias, PH_SEPARATE);
	
					zend_hash_move_forward_ex(ah4, &hp4);
				}
	
			}
		} else {
			if (Z_TYPE_P(alias_copy) == IS_LONG) {
				PHALCON_INIT_NVAR(column_alias);
				array_init_size(column_alias, 2);
				phalcon_array_append(&column_alias, sql_column, 0);
				phalcon_array_append(&column_alias, z_null, 0);
			} else {
				PHALCON_INIT_NVAR(column_alias);
				array_init_size(column_alias, 3);
				phalcon_array_append(&column_alias, sql_column, 0);
				phalcon_array_append(&column_alias, z_null, 0);
				phalcon_array_append(&column_alias, alias_copy, 0);
			}
			phalcon_array_append(&select_columns, column_alias, PH_SEPARATE);
		}
	
		if (!is_complex && is_simple_std) {
			if (phalcon_array_isset_string_fetch(&sql_alias, column, SS("sqlAlias"))) {
				phalcon_array_update_zval(&simple_column_map, sql_alias, alias_copy, PH_COPY | PH_SEPARATE);
			} else {
				phalcon_array_update_zval(&simple_column_map, alias_copy, alias_copy, PH_COPY | PH_SEPARATE);
			}
		}
	
		zend_hash_move_forward_ex(ah2, &hp2);
	}
	zend_hash_destroy(ah2);
	efree(ah2);
	
	phalcon_array_update_string(&intermediate, SL("columns"), select_columns, PH_COPY | PH_SEPARATE);
	
	PHALCON_CALL_METHOD(&dialect, connection, "getdialect");
	PHALCON_CALL_METHOD(&sql_select, dialect, "select", intermediate);

	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(processed);
		array_init(processed);
	
		phalcon_is_iterable(bind_params, &ah5, &hp5, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) == SUCCESS) {
	
			PHALCON_GET_HKEY(wildcard, ah5, hp5);
			PHALCON_GET_HVALUE(value);
	
			if (Z_TYPE_P(wildcard) == IS_LONG) {
				PHALCON_INIT_NVAR(string_wildcard);
				PHALCON_CONCAT_SV(string_wildcard, ":", wildcard);
				phalcon_array_update_zval(&processed, string_wildcard, value, PH_COPY);
			} else {
				phalcon_array_update_zval(&processed, wildcard, value, PH_COPY);
			}
	
			zend_hash_move_forward_ex(ah5, &hp5);
		}
	
	} else {
		PHALCON_CPY_WRT(processed, bind_params);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(processed_types);
		array_init(processed_types);
	
		phalcon_is_iterable(bind_types, &ah6, &hp6, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah6, (void**) &hd, &hp6) == SUCCESS) {
	
			PHALCON_GET_HKEY(type_wildcard, ah6, hp6);
			PHALCON_GET_HVALUE(value);
	
			if (Z_TYPE_P(type_wildcard) == IS_LONG) {
				PHALCON_INIT_NVAR(string_wildcard);
				PHALCON_CONCAT_SV(string_wildcard, ":", type_wildcard);
				phalcon_array_update_zval(&processed_types, string_wildcard, value, PH_COPY | PH_SEPARATE);
			} else {
				phalcon_array_update_zval(&processed_types, type_wildcard, value, PH_COPY | PH_SEPARATE);
			}
	
			zend_hash_move_forward_ex(ah6, &hp6);
		}
	
	} else {
		PHALCON_CPY_WRT(processed_types, bind_types);
	}
	
	PHALCON_CALL_METHOD(&result, connection, "query", sql_select, processed, processed_types);
	
	PHALCON_CALL_METHOD(&count, result, "numrows", result);
	if (zend_is_true(count)) {
		PHALCON_CPY_WRT(result_data, result);
	} else {
		PHALCON_INIT_NVAR(result_data);
		ZVAL_BOOL(result_data, 0);
	}
	
	PHALCON_OBS_VAR(cache);
	phalcon_read_property_this(&cache, this_ptr, SL("_cache"), PH_NOISY TSRMLS_CC);
	if (!is_complex) {
	
		if (is_simple_std) {
			PHALCON_INIT_VAR(result_object);
			object_init_ex(result_object, phalcon_mvc_model_row_ce);
	
			PHALCON_INIT_NVAR(is_keeping_snapshots);
			ZVAL_BOOL(is_keeping_snapshots, 0);
		} else {
			PHALCON_CPY_WRT(result_object, model);
	
			PHALCON_CALL_METHOD(&simple_column_map, meta_data, "getcolumnmap", model);
	
			PHALCON_CALL_METHOD(&is_keeping_snapshots, manager, "iskeepingsnapshots", model);
		}
	
		object_init_ex(return_value, phalcon_mvc_model_resultset_simple_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", simple_column_map, result_object, result_data, cache, is_keeping_snapshots);
	
		RETURN_MM();
	}
	
	object_init_ex(return_value, phalcon_mvc_model_resultset_complex_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", columns, result_data, cache);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeInsert){

	zval *intermediate, *bind_params, *bind_types;
	zval *model_name, *manager, *models_instances;
	zval *model = NULL, *connection = NULL, *meta_data, *attributes = NULL;
	zval *automatic_fields = NULL, *fields = NULL, *column_map = NULL;
	zval *values, *number_fields, *number_values;
	zval *dialect = NULL, *double_colon, *empty_string;
	zval *null_value, *not_exists, *insert_values;
	zval *value = NULL, *number = NULL, *type = NULL, *expr_value = NULL, *insert_value = NULL;
	zval *insert_expr = NULL, *wildcard = NULL, *exception_message = NULL;
	zval *field_name = NULL, *attribute_name = NULL, *base_model = NULL;
	zval *insert_model, *success = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &intermediate, &bind_params, &bind_types);
	
	PHALCON_OBS_VAR(model_name);
	phalcon_array_fetch_quick_string(&model_name, intermediate, SS("model"), 238191286UL, PH_NOISY);
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
		return;
	}

	PHALCON_OBS_VAR(models_instances);
	phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(models_instances, model_name)) {
		PHALCON_OBS_VAR(model);
		phalcon_array_fetch(&model, models_instances, model_name, PH_NOISY);
	} else {
		PHALCON_CALL_METHOD(&model, manager, "load", model_name);
	}
	
	if (phalcon_method_quick_exists_ex(model, SS("selectwriteconnection"), 2060018080UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&connection, model, "selectwriteconnection", intermediate, bind_params, bind_types);
		if (Z_TYPE_P(connection) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "'selectWriteConnection' didn't returned a valid connection");
			return;
		}
	} else {
		PHALCON_CALL_METHOD(&connection, model, "getwriteconnection");
	}
	
	PHALCON_OBS_VAR(meta_data);
	phalcon_read_property_this(&meta_data, this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&attributes, meta_data, "getattributes", model);
	
	PHALCON_INIT_VAR(automatic_fields);
	ZVAL_FALSE(automatic_fields);
	
	if (phalcon_array_isset_quick_string(intermediate, SS("fields"), 2881624156UL)) {
		PHALCON_OBS_VAR(fields);
		phalcon_array_fetch_quick_string(&fields, intermediate, SS("fields"), 2881624156UL, PH_NOISY);
	} else {
		ZVAL_TRUE(automatic_fields);
		PHALCON_CPY_WRT(fields, attributes);
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", model);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	}
	
	PHALCON_OBS_VAR(values);
	phalcon_array_fetch_quick_string(&values, intermediate, SS("values"), 1765818005UL, PH_NOISY);
	
	PHALCON_INIT_VAR(number_fields);
	phalcon_fast_count(number_fields, fields TSRMLS_CC);
	
	PHALCON_INIT_VAR(number_values);
	phalcon_fast_count(number_values, values TSRMLS_CC);
	
	if (!PHALCON_IS_EQUAL(number_fields, number_values)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The column count does not match the values count");
		return;
	}
	
	PHALCON_CALL_METHOD(&dialect, connection, "getdialect");
	
	PHALCON_INIT_VAR(double_colon);
	ZVAL_STRING(double_colon, ":", 1);
	
	PHALCON_INIT_VAR(empty_string);
	ZVAL_EMPTY_STRING(empty_string);
	
	PHALCON_INIT_VAR(null_value);
	
	PHALCON_INIT_VAR(not_exists);
	ZVAL_BOOL(not_exists, 0);
	
	PHALCON_INIT_VAR(insert_values);
	array_init(insert_values);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(number, ah0, hp0);
		PHALCON_GET_HVALUE(value);
	
		PHALCON_OBS_NVAR(type);
		phalcon_array_fetch_string(&type, value, ISL(type), PH_NOISY);
	
		PHALCON_OBS_NVAR(expr_value);
		phalcon_array_fetch_quick_string(&expr_value, value, SS("value"), 574111618UL, PH_NOISY);
	
		switch (phalcon_get_intval(type)) {
	
			case PHQL_T_STRING:
			case PHQL_T_INTEGER:
			case PHQL_T_DOUBLE:
				PHALCON_CALL_METHOD(&insert_value, dialect, "getsqlexpression", expr_value);
				break;
	
			case PHQL_T_NULL:
				PHALCON_CPY_WRT(insert_value, null_value);
				break;
	
			case PHQL_T_NPLACEHOLDER:
			case PHQL_T_SPLACEHOLDER:
				if (Z_TYPE_P(bind_params) != IS_ARRAY) { 
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Bound parameter cannot be replaced because placeholders is not an array");
					return;
				}
	
				PHALCON_CALL_METHOD(&insert_expr, dialect, "getsqlexpression", expr_value);
	
				PHALCON_INIT_NVAR(wildcard);
				phalcon_fast_str_replace(wildcard, double_colon, empty_string, insert_expr);
				if (!phalcon_array_isset(bind_params, wildcard)) {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Bound parameter '", wildcard, "' cannot be replaced because it isn't in the placeholders list");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
	
				PHALCON_OBS_NVAR(insert_value);
				phalcon_array_fetch(&insert_value, bind_params, wildcard, PH_NOISY);
				break;
	
			default:
				PHALCON_CALL_METHOD(&insert_expr, dialect, "getsqlexpression", expr_value);
	
				PHALCON_INIT_NVAR(insert_value);
				object_init_ex(insert_value, phalcon_db_rawvalue_ce);
				PHALCON_CALL_METHOD(NULL, insert_value, "__construct", insert_expr);
	
				break;
	
		}
	
		PHALCON_OBS_NVAR(field_name);
		phalcon_array_fetch(&field_name, fields, number, PH_NOISY);
	
		if (PHALCON_IS_TRUE(automatic_fields)) {
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, field_name)) {
					PHALCON_OBS_NVAR(attribute_name);
					phalcon_array_fetch(&attribute_name, column_map, field_name, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", field_name, "\" isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_name, field_name);
			}
		} else {
			PHALCON_CPY_WRT(attribute_name, field_name);
		}
	
		phalcon_array_update_zval(&insert_values, attribute_name, insert_value, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&base_model, manager, "load", model_name);
	
	PHALCON_INIT_VAR(insert_model);
	if (phalcon_clone(insert_model, base_model TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(&success, insert_model, "create", insert_values);
	
	object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, insert_model);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _getRelatedRecords){

	zval *model, *intermediate, *bind_params, *bind_types;
	zval *selected_tables, *selected_models, *source = NULL;
	zval *model_name, *select_column, *selected_columns;
	zval *select_ir, *where_conditions, *limit_conditions;
	zval *type_select, *dependency_injector, *query;
	zval *a0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &model, &intermediate, &bind_params, &bind_types);
	
	PHALCON_OBS_VAR(selected_tables);
	phalcon_array_fetch_quick_string(&selected_tables, intermediate, SS("tables"), 3465666720UL, PH_NOISY);
	
	PHALCON_OBS_VAR(selected_models);
	phalcon_array_fetch_quick_string(&selected_models, intermediate, SS("models"), 3565348937UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&source, model, "getsource");
	
	PHALCON_INIT_VAR(model_name);
	phalcon_get_class(model_name, model, 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(select_column);
	array_init_size(select_column, 1);
	
	PHALCON_INIT_VAR(a0);
	array_init_size(a0, 3);
	add_assoc_stringl_ex(a0, ISS(type), SL("object"), 1);
	phalcon_array_update_string(&a0, SL("model"), model_name, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&a0, SL("column"), source, PH_COPY | PH_SEPARATE);
	phalcon_array_append(&select_column, a0, PH_SEPARATE);
	
	PHALCON_INIT_VAR(selected_columns);
	array_init_size(selected_columns, 1);
	phalcon_array_append(&selected_columns, select_column, PH_SEPARATE);
	
	PHALCON_INIT_VAR(select_ir);
	array_init_size(select_ir, 3);
	phalcon_array_update_string(&select_ir, SL("columns"), select_column, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&select_ir, SL("models"), selected_models, PH_COPY | PH_SEPARATE);
	phalcon_array_update_string(&select_ir, SL("tables"), selected_tables, PH_COPY | PH_SEPARATE);
	
	if (phalcon_array_isset_quick_string(intermediate, SS("where"), 621293632UL)) {
		PHALCON_OBS_VAR(where_conditions);
		phalcon_array_fetch_quick_string(&where_conditions, intermediate, SS("where"), 621293632UL, PH_NOISY);
		phalcon_array_update_string(&select_ir, SL("where"), where_conditions, PH_COPY | PH_SEPARATE);
	}
	
	if (phalcon_array_isset_quick_string(intermediate, SS("limit"), 192268420UL)) {
		PHALCON_OBS_VAR(limit_conditions);
		phalcon_array_fetch_quick_string(&limit_conditions, intermediate, SS("limit"), 192268420UL, PH_NOISY);
		phalcon_array_update_string(&select_ir, SL("limit"), limit_conditions, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(type_select);
	ZVAL_LONG(type_select, 309);
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(query);
	object_init_ex(query, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD(NULL, query, "__construct");
	
	PHALCON_CALL_METHOD(NULL, query, "setdi", dependency_injector);
	PHALCON_CALL_METHOD(NULL, query, "settype", type_select);
	PHALCON_CALL_METHOD(NULL, query, "setintermediate", select_ir);
	
	PHALCON_RETURN_CALL_METHOD(query, "execute", bind_params, bind_types);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeUpdate){

	zval *intermediate, *bind_params, *bind_types;
	zval *models, *model_name, *models_instances;
	zval *model = NULL, *manager, *connection = NULL, *dialect = NULL, *double_colon;
	zval *empty_string, *fields, *values, *update_values;
	zval *select_bind_params = NULL, *select_bind_types = NULL;
	zval *null_value, *field = NULL, *number = NULL, *field_name = NULL;
	zval *value = NULL, *type = NULL, *expr_value = NULL, *update_value = NULL;
	zval *update_expr = NULL, *wildcard = NULL, *exception_message = NULL;
	zval *records = NULL, *success = NULL, *record = NULL;
	zval *r0 = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &intermediate, &bind_params, &bind_types);
	
	PHALCON_OBS_VAR(models);
	phalcon_array_fetch_quick_string(&models, intermediate, SS("models"), 3565348937UL, PH_NOISY);
	if (phalcon_array_isset_long(models, 1)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Updating several models at the same time is still not supported");
		return;
	}
	
	PHALCON_OBS_VAR(model_name);
	phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY);
	
	PHALCON_OBS_VAR(models_instances);
	phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(models_instances, model_name)) {
		PHALCON_OBS_VAR(model);
		phalcon_array_fetch(&model, models_instances, model_name, PH_NOISY);
	} else {
		manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(manager) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
			return;
		}

		PHALCON_CALL_METHOD(&model, manager, "load", model_name);
	}
	
	if (phalcon_method_quick_exists_ex(model, SS("selectwriteconnection"), 2060018080UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&connection, model, "selectwriteconnection", intermediate, bind_params, bind_types);
		if (Z_TYPE_P(connection) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "'selectWriteConnection' didn't returned a valid connection");
			return;
		}
	} else {
		PHALCON_CALL_METHOD(&connection, model, "getwriteconnection");
	}
	
	PHALCON_CALL_METHOD(&dialect, connection, "getdialect");
	
	PHALCON_INIT_VAR(double_colon);
	ZVAL_STRING(double_colon, ":", 1);
	
	PHALCON_INIT_VAR(empty_string);
	ZVAL_EMPTY_STRING(empty_string);
	
	PHALCON_OBS_VAR(fields);
	phalcon_array_fetch_quick_string(&fields, intermediate, SS("fields"), 2881624156UL, PH_NOISY);
	
	PHALCON_OBS_VAR(values);
	phalcon_array_fetch_quick_string(&values, intermediate, SS("values"), 1765818005UL, PH_NOISY);
	
	PHALCON_INIT_VAR(update_values);
	array_init(update_values);
	
	PHALCON_CPY_WRT(select_bind_params, bind_params);
	PHALCON_CPY_WRT(select_bind_types, bind_types);
	
	PHALCON_INIT_VAR(null_value);
	
	phalcon_is_iterable(fields, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(number, ah0, hp0);
		PHALCON_GET_HVALUE(field);
	
		PHALCON_OBS_NVAR(field_name);
		phalcon_array_fetch_string(&field_name, field, ISL(name), PH_NOISY);
	
		PHALCON_OBS_NVAR(value);
		phalcon_array_fetch(&value, values, number, PH_NOISY);
	
		PHALCON_OBS_NVAR(type);
		phalcon_array_fetch_string(&type, value, ISL(type), PH_NOISY);
	
		PHALCON_OBS_NVAR(expr_value);
		phalcon_array_fetch_quick_string(&expr_value, value, SS("value"), 574111618UL, PH_NOISY);
	
		switch (phalcon_get_intval(type)) {
	
			case PHQL_T_STRING:
			case PHQL_T_DOUBLE:
			case PHQL_T_INTEGER:
				PHALCON_CALL_METHOD(&update_value, dialect, "getsqlexpression", expr_value);
				break;
	
			case PHQL_T_NULL:
				PHALCON_CPY_WRT(update_value, null_value);
				break;
	
			case PHQL_T_NPLACEHOLDER:
			case PHQL_T_SPLACEHOLDER:
				if (Z_TYPE_P(bind_params) != IS_ARRAY) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Bound parameter cannot be replaced because placeholders is not an array");
					return;
				}
	
				PHALCON_CALL_METHOD(&update_expr, dialect, "getsqlexpression", expr_value);
	
				PHALCON_INIT_NVAR(wildcard);
				phalcon_fast_str_replace(wildcard, double_colon, empty_string, update_expr);
				if (phalcon_array_isset(bind_params, wildcard)) {
					PHALCON_OBS_NVAR(update_value);
					phalcon_array_fetch(&update_value, bind_params, wildcard, PH_NOISY);
					phalcon_array_unset(&select_bind_params, wildcard, PH_SEPARATE);
					phalcon_array_unset(&select_bind_types, wildcard, PH_SEPARATE);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Bound parameter '", wildcard, "' cannot be replaced because it's not in the placeholders list");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
	
				break;

			default:
				PHALCON_CALL_METHOD(&update_expr, dialect, "getsqlexpression", expr_value);
	
				PHALCON_INIT_NVAR(update_value);
				object_init_ex(update_value, phalcon_db_rawvalue_ce);
				PHALCON_CALL_METHOD(NULL, update_value, "__construct", update_expr);
	
				break;
	
		}
		phalcon_array_update_zval(&update_values, field_name, update_value, PH_COPY | PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_CALL_METHOD(&records, this_ptr, "_getrelatedrecords", model, intermediate, select_bind_params, select_bind_types);
	
	if (!phalcon_fast_count_ev(records TSRMLS_CC)) {
		PHALCON_INIT_VAR(success);
		ZVAL_TRUE(success);
		object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, null_value);
	
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(&connection, model, "getwriteconnection");
	
	PHALCON_CALL_METHOD(NULL, connection, "begin");
	PHALCON_CALL_METHOD(NULL, records, "rewind");
	
	while (1) {
		PHALCON_CALL_METHOD(&r0, records, "valid");
		if (PHALCON_IS_NOT_FALSE(r0)) {
		} else {
			break;
		}
	
		PHALCON_CALL_METHOD(&record, records, "current");
	
		PHALCON_CALL_METHOD(&success, record, "update", update_values);
		if (!zend_is_true(success)) {
			PHALCON_CALL_METHOD(NULL, connection, "rollback");
			object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, record);
	
			RETURN_MM();
		}
	
		PHALCON_CALL_METHOD(NULL, records, "next");
	}
	
	PHALCON_CALL_METHOD(NULL, connection, "commit");
	
	PHALCON_INIT_NVAR(success);
	ZVAL_TRUE(success);
	object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, null_value);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, _executeDelete){

	zval *intermediate, *bind_params, *bind_types;
	zval *models, *model_name, *models_instances;
	zval *model = NULL, *manager, *records = NULL, *success = NULL, *null_value = NULL;
	zval *connection = NULL, *record = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &intermediate, &bind_params, &bind_types);
	
	PHALCON_OBS_VAR(models);
	phalcon_array_fetch_quick_string(&models, intermediate, SS("models"), 3565348937UL, PH_NOISY);
	if (phalcon_array_isset_long(models, 1)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Delete from several models at the same time is still not supported");
		return;
	}
	
	PHALCON_OBS_VAR(model_name);
	phalcon_array_fetch_long(&model_name, models, 0, PH_NOISY);
	
	PHALCON_OBS_VAR(models_instances);
	phalcon_read_property_this(&models_instances, this_ptr, SL("_modelsInstances"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(models_instances, model_name)) {
		PHALCON_OBS_VAR(model);
		phalcon_array_fetch(&model, models_instances, model_name, PH_NOISY);
	} else {
		manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(manager) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "dependency Injector is required to get 'modelsManager' service");
			return;
		}

		PHALCON_CALL_METHOD(&model, manager, "load", model_name);
	}
	
	PHALCON_CALL_METHOD(&records, this_ptr, "_getrelatedrecords", model, intermediate, bind_params, bind_types);
	
	if (!phalcon_fast_count_ev(records TSRMLS_CC)) {
		PHALCON_INIT_VAR(success);
		ZVAL_TRUE(success);
	
		PHALCON_INIT_VAR(null_value);
		object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, null_value);
	
		RETURN_MM();
	}
	
	if (phalcon_method_quick_exists_ex(model, SS("selectwriteconnection"), 2060018080UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHOD(&connection, model, "selectwriteconnection", intermediate, bind_params, bind_types);
		if (Z_TYPE_P(connection) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "'selectWriteConnection' didn't returned a valid connection");
			return;
		}
	} else {
		PHALCON_CALL_METHOD(&connection, model, "getwriteconnection");
	}
	
	PHALCON_CALL_METHOD(NULL, connection, "begin");
	PHALCON_CALL_METHOD(NULL, records, "rewind");
	
	while (1) {
	
		PHALCON_CALL_METHOD(&r0, records, "valid");
		if (PHALCON_IS_NOT_FALSE(r0)) {
		} else {
			break;
		}
	
		PHALCON_CALL_METHOD(&record, records, "current");
	
		PHALCON_CALL_METHOD(&success, record, "delete");
		if (!zend_is_true(success)) {
			PHALCON_CALL_METHOD(NULL, connection, "rollback");
			object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
			PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, record);
	
			RETURN_MM();
		}
	
		PHALCON_CALL_METHOD(NULL, records, "next");
	}
	
	PHALCON_CALL_METHOD(NULL, connection, "commit");
	
	PHALCON_INIT_NVAR(success);
	ZVAL_TRUE(success);
	
	PHALCON_INIT_NVAR(null_value);
	ZVAL_TRUE(null_value);
	
	object_init_ex(return_value, phalcon_mvc_model_query_status_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", success, null_value);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, execute){

	zval *bind_params = NULL, *bind_types = NULL, *unique_row;
	zval *cache_options, *key = NULL, *lifetime = NULL, *cache_service = NULL;
	zval *dependency_injector, *cache = NULL, *frontend = NULL, *result = NULL, *is_fresh;
	zval *prepared_result = NULL, *intermediate = NULL, *default_bind_params;
	zval *merged_params = NULL, *default_bind_types;
	zval *merged_types = NULL, *type, *exception_message;
	int cache_options_is_not_null;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(unique_row);
	phalcon_read_property_this(&unique_row, this_ptr, SL("_uniqueRow"), PH_NOISY TSRMLS_CC);
	
	cache_options             = phalcon_fetch_nproperty_this(this_ptr, SL("_cacheOptions"), PH_NOISY TSRMLS_CC);
	cache_options_is_not_null = (Z_TYPE_P(cache_options) != IS_NULL); /* to keep scan-build happy */

	if (cache_options_is_not_null) {
		if (Z_TYPE_P(cache_options) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid caching options");
			return;
		}
	
		if (!phalcon_array_isset_string_fetch(&key, cache_options, SS("key"))) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A cache key must be provided to identify the cached resultset in the cache backend");
			return;
		}
	
		if (!phalcon_array_isset_string_fetch(&cache_service, cache_options, SS("service"))) {
			PHALCON_INIT_VAR(cache_service);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(cache_service, phalcon_interned_modelsCache);
		}
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&cache, dependency_injector, "getshared", cache_service);
		if (Z_TYPE_P(cache) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The cache service must be an object");
			return;
		}

		PHALCON_VERIFY_INTERFACE(cache, phalcon_cache_backendinterface_ce);
	
		if (!phalcon_array_isset_string_fetch(&lifetime, cache_options, SS("lifetime"))) {
			PHALCON_CALL_METHOD(&frontend, cache, "getfrontend");

			if (Z_TYPE_P(frontend) == IS_OBJECT) {
				PHALCON_VERIFY_INTERFACE_EX(frontend, phalcon_cache_frontendinterface_ce, phalcon_mvc_model_exception_ce, 1);
				PHALCON_CALL_METHOD(&lifetime, frontend, "getlifetime");
			}
			else {
				PHALCON_INIT_VAR(lifetime);
				ZVAL_LONG(lifetime, 3600);
			}
		}

		PHALCON_CALL_METHOD(&result, cache, "get", key, lifetime);
		if (Z_TYPE_P(result) != IS_NULL) {
			if (Z_TYPE_P(result) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The cache didn't return a valid resultset");
				return;
			}
	
			PHALCON_INIT_VAR(is_fresh);
			ZVAL_BOOL(is_fresh, 0);
			PHALCON_CALL_METHOD(NULL, result, "setisfresh", is_fresh);
	
			if (zend_is_true(unique_row)) {
				PHALCON_CALL_METHOD(&prepared_result, result, "getfirst");
			} else {
				PHALCON_CPY_WRT(prepared_result, result);
			}
	
			RETURN_CTOR(prepared_result);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
		assert(key != NULL);
	}
	
	PHALCON_CALL_METHOD(&intermediate, this_ptr, "parse");
	
	PHALCON_OBS_VAR(default_bind_params);
	phalcon_read_property_this(&default_bind_params, this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(default_bind_params) == IS_ARRAY) { 
		if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &default_bind_params, &bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, default_bind_params);
		}
	} else {
		PHALCON_CPY_WRT(merged_params, bind_params);
	}

	PHALCON_OBS_VAR(default_bind_types);
	phalcon_read_property_this(&default_bind_types, this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(default_bind_types) == IS_ARRAY) { 
		if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_types);
			phalcon_fast_array_merge(merged_types, &default_bind_types, &bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_types, default_bind_types);
		}
	} else {
		PHALCON_CPY_WRT(merged_types, bind_types);
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	
	switch (phalcon_get_intval(type)) {
	
		case PHQL_T_SELECT:
			PHALCON_CALL_METHOD(&result, this_ptr, "_executeselect", intermediate, merged_params, merged_types);
			break;
	
		case PHQL_T_INSERT:
			PHALCON_CALL_METHOD(&result, this_ptr, "_executeinsert", intermediate, merged_params, merged_types);
			break;
	
		case PHQL_T_UPDATE:
			PHALCON_CALL_METHOD(&result, this_ptr, "_executeupdate", intermediate, merged_params, merged_types);
			break;
	
		case PHQL_T_DELETE:
			PHALCON_CALL_METHOD(&result, this_ptr, "_executedelete", intermediate, merged_params, merged_types);
			break;
	
		default:
			PHALCON_INIT_VAR(exception_message);
			PHALCON_CONCAT_SV(exception_message, "Unknown statement ", type);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
	
	}
	
	if (cache_options_is_not_null) {
	
		if (!PHALCON_IS_LONG(type, PHQL_T_SELECT)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Only PHQL statements that return resultsets can be cached");
			return;
		}

		assert(key != NULL);
		PHALCON_CALL_METHOD(NULL, cache, "save", key, result, lifetime);
	}
	
	if (zend_is_true(unique_row)) {
		PHALCON_RETURN_CALL_METHOD(result, "getfirst");
		RETURN_MM();
	}

	RETURN_CTOR(result);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getSingleResult){

	zval *bind_params = NULL, *bind_types = NULL, *unique_row;
	zval *first_result = NULL, *result = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	unique_row = phalcon_fetch_nproperty_this(this_ptr, SL("_uniqueRow"), PH_NOISY TSRMLS_CC);
	
	if (zend_is_true(unique_row)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "execute", bind_params, bind_types);
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(&result, this_ptr, "execute", bind_params, bind_types);
	PHALCON_CALL_METHOD(&first_result, result, "getfirst"); /* @todo is this correct? */

	RETURN_CCTOR(first_result);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setType){

	zval *type;

	phalcon_fetch_params(0, 1, 0, &type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setBindParams){

	zval *bind_params;

	phalcon_fetch_params(0, 1, 0, &bind_params);
	
	if (Z_TYPE_P(bind_params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Bind parameters must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), bind_params, 2293392709UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getBindParams){


	RETURN_MEMBER_QUICK(this_ptr, "_bindParams", 2293392709UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setBindTypes){

	zval *bind_types;

	phalcon_fetch_params(0, 1, 0, &bind_types);
	
	if (Z_TYPE_P(bind_types) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Bind types must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), bind_types, 514734038UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getBindTypes){


	RETURN_MEMBER_QUICK(this_ptr, "_bindTypes", 514734038UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, setIntermediate){

	zval *intermediate;

	phalcon_fetch_params(0, 1, 0, &intermediate);
	
	phalcon_update_property_this_quick(this_ptr, SL("_intermediate"), intermediate, 1829292799UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query, getIntermediate){


	RETURN_MEMBER_QUICK(this_ptr, "_intermediate", 1829292799UL);
}





zend_class_entry *phalcon_mvc_model_queryinterface_ce;

static const zend_function_entry phalcon_mvc_model_queryinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_QueryInterface, parse, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_QueryInterface, execute, arginfo_phalcon_mvc_model_queryinterface_execute)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_QueryInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, QueryInterface, mvc_model_queryinterface, phalcon_mvc_model_queryinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_mvc_model_relation_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Relation, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, setIntermediateRelation);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getType);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getReferencedModel);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getFields);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getReferencedFields);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getOptions);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, isForeignKey);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getForeignKey);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, isThrough);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, isReusable);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateFields);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateModel);
static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateReferencedFields);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_relation___construct, 0, 0, 4)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, referencedModel)
	ZEND_ARG_INFO(0, fields)
	ZEND_ARG_INFO(0, referencedFields)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_relation_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Relation, __construct, arginfo_phalcon_mvc_model_relation___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Relation, setIntermediateRelation, arginfo_phalcon_mvc_model_relationinterface_setintermediaterelation, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getReferencedModel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getFields, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getReferencedFields, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, isForeignKey, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getForeignKey, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, isThrough, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, isReusable, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getIntermediateFields, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getIntermediateModel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Relation, getIntermediateReferencedFields, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Relation){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Relation, mvc_model_relation, phalcon_mvc_model_relation_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_referencedModel"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_fields"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_referencedFields"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_intermediateModel"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_intermediateFields"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_intermediateReferencedFields"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_relation_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("BELONGS_TO"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("HAS_ONE"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("HAS_MANY"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("HAS_ONE_THROUGH"), 3 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("HAS_MANY_THROUGH"), 4 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("NO_ACTION"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("ACTION_RESTRICT"), 1 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_relation_ce, SL("ACTION_CASCADE"), 2 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_relation_ce TSRMLS_CC, 1, phalcon_mvc_model_relationinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, __construct){

	zval *type, *referenced_model, *fields, *referenced_fields;
	zval *options = NULL;

	phalcon_fetch_params(0, 4, 1, &type, &referenced_model, &fields, &referenced_fields, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_referencedModel"), referenced_model, 4077480136UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_fields"), fields, 3492004987UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_referencedFields"), referenced_fields, 729137326UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, setIntermediateRelation){

	zval *intermediate_fields, *intermediate_model;
	zval *intermediate_referenced_fields;

	phalcon_fetch_params(0, 3, 0, &intermediate_fields, &intermediate_model, &intermediate_referenced_fields);
	
	phalcon_update_property_this_quick(this_ptr, SL("_intermediateFields"), intermediate_fields, 1022734614UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_intermediateModel"), intermediate_model, 312011824UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_intermediateReferencedFields"), intermediate_referenced_fields, 3351276297UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getReferencedModel){


	RETURN_MEMBER_QUICK(this_ptr, "_referencedModel", 4077480136UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getFields){


	RETURN_MEMBER_QUICK(this_ptr, "_fields", 3492004987UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getReferencedFields){


	RETURN_MEMBER_QUICK(this_ptr, "_referencedFields", 729137326UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, isForeignKey){

	zval *options;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(options);
	phalcon_read_property_this(&options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		if (phalcon_array_isset_quick_string(options, SS("foreignKey"), 1865016664UL)) {
			RETURN_MM_TRUE;
		}
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getForeignKey){

	zval *options, *foreign_key;

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (phalcon_array_isset_string_fetch(&foreign_key, options, SS("foreignKey"))) {
		if (zend_is_true(foreign_key)) {
			RETURN_ZVAL(foreign_key, 1, 0);
		}
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, isThrough){

	zval *type;

	type = phalcon_fetch_nproperty_this(this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_LONG(type, 3) || PHALCON_IS_LONG(type, 4)) {
		RETURN_TRUE;
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, isReusable){

	zval *options, *reusable;

	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

	if (phalcon_array_isset_string_fetch(&reusable, options, SS("reusable"))) {
		RETURN_ZVAL(reusable, 1, 0);
	}
	
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateFields){


	RETURN_MEMBER_QUICK(this_ptr, "_intermediateFields", 1022734614UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateModel){


	RETURN_MEMBER_QUICK(this_ptr, "_intermediateModel", 312011824UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Relation, getIntermediateReferencedFields){


	RETURN_MEMBER_QUICK(this_ptr, "_intermediateReferencedFields", 3351276297UL);
}





zend_class_entry *phalcon_mvc_model_relationinterface_ce;

static const zend_function_entry phalcon_mvc_model_relationinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, setIntermediateRelation, arginfo_phalcon_mvc_model_relationinterface_setintermediaterelation)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getReferencedModel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getFields, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getReferencedFields, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getOptions, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, isForeignKey, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getForeignKey, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, isThrough, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getIntermediateFields, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getIntermediateModel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_RelationInterface, getIntermediateReferencedFields, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_RelationInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, RelationInterface, mvc_model_relationinterface, phalcon_mvc_model_relationinterface_method_entry);

	return SUCCESS;
}

















zend_class_entry *phalcon_mvc_model_resultinterface_ce;

static const zend_function_entry phalcon_mvc_model_resultinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultInterface, setDirtyState, arginfo_phalcon_mvc_model_resultinterface_setdirtystate)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ResultInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ResultInterface, mvc_model_resultinterface, phalcon_mvc_model_resultinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_mvc_model_resultset_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, next);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, key);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, rewind);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, seek);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, count);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetExists);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetGet);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetSet);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetUnset);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getType);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getFirst);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getLast);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, setIsFresh);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, isFresh);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, setHydrateMode);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getHydrateMode);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getCache);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, current);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, delete);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset, filter);

static const zend_function_entry phalcon_mvc_model_resultset_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Resultset, next, arginfo_iterator_next, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, key, arginfo_iterator_key, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, rewind, arginfo_iterator_rewind, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, seek, arginfo_seekableiterator_seek, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, count, arginfo_countable_count, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, offsetExists, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, offsetGet, arginfo_arrayaccess_offsetget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, offsetSet, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, offsetUnset, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getFirst, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getLast, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, setIsFresh, arginfo_phalcon_mvc_model_resultsetinterface_setisfresh, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, isFresh, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, setHydrateMode, arginfo_phalcon_mvc_model_resultset_sethydratemode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getHydrateMode, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getCache, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, current, arginfo_iterator_current, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, delete, arginfo_phalcon_mvc_model_resultset_delete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset, filter, arginfo_phalcon_mvc_model_resultset_filter, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Resultset, mvc_model_resultset, phalcon_mvc_model_resultset_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_long(phalcon_mvc_model_resultset_ce, SL("_type"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_result"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_cache"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_resultset_ce, SL("_isFresh"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_resultset_ce, SL("_pointer"), -1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_count"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_activeRow"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_rows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_ce, SL("_errorMessages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_resultset_ce, SL("_hydrateMode"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_declare_class_constant_long(phalcon_mvc_model_resultset_ce, SL("TYPE_RESULT_FULL"),    PHALCON_MVC_MODEL_RESULTSET_TYPE_FULL TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_resultset_ce, SL("TYPE_RESULT_PARTIAL"), PHALCON_MVC_MODEL_RESULTSET_TYPE_PARTIAL TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_resultset_ce, SL("HYDRATE_RECORDS"), 0 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_resultset_ce, SL("HYDRATE_OBJECTS"), 2 TSRMLS_CC);
	zend_declare_class_constant_long(phalcon_mvc_model_resultset_ce, SL("HYDRATE_ARRAYS"), 1 TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_ce TSRMLS_CC, 6, phalcon_mvc_model_resultsetinterface_ce, zend_ce_iterator, spl_ce_SeekableIterator, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_serializable);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, next){


	phalcon_property_incr(this_ptr, SL("_pointer") TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, key){


	RETURN_MEMBER_QUICK(this_ptr, "_pointer", 3868032485UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, rewind){

	zval *type, *z_zero;

	z_zero = PHALCON_GLOBAL(z_zero);

	type = phalcon_fetch_nproperty_this(this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(type)) {
	
		zval *result = phalcon_fetch_nproperty_this(this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
	
			zval *active_row = phalcon_fetch_nproperty_this(this_ptr, SL("_activeRow"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(active_row) != IS_NULL) {
				PHALCON_MM_GROW();
				PHALCON_CALL_METHOD(NULL, result, "dataseek", z_zero);
				PHALCON_MM_RESTORE();
			}
		}
	} else {
		zval *rows = phalcon_fetch_nproperty_this(this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(rows) == IS_NULL) {
	
			zval *result = phalcon_fetch_nproperty_this(this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(result) == IS_OBJECT) {
				zval *r = NULL;
				PHALCON_CALL_METHODW(&r, result, "fetchall");
				if (likely(Z_TYPE_P(r) == IS_ARRAY)) {
					zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(r), NULL);
				}

				phalcon_update_property_this_quick(this_ptr, SL("_rows"), r, 3989235983UL TSRMLS_CC);
				zval_ptr_dtor(&r);
			}
		}
		else if (Z_TYPE_P(rows) == IS_ARRAY) {
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(rows), NULL);
		}
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_pointer"), z_zero, 3868032485UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, seek){

	long i;
	zval *type, *result, *rows, *position;
	zval *pointer, *is_different;
	HashTable *ah0;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &position) == FAILURE) {
		RETURN_NULL();
	}

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(pointer);
	phalcon_read_property(&pointer, this_ptr, SL("_pointer"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(is_different);
	is_not_equal_function(is_different, pointer, position TSRMLS_CC);
	if (PHALCON_IS_TRUE(is_different)) {

		PHALCON_OBS_VAR(type);
		phalcon_read_property(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(type)) {

			PHALCON_OBS_VAR(result);
			phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
			PHALCON_CALL_METHOD(NULL, result, "dataseek", position);

		} else {

			PHALCON_OBS_VAR(rows);
			phalcon_read_property(&rows, this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);

			if (Z_TYPE_P(rows) == IS_NULL) {
				PHALCON_OBS_VAR(result);
				phalcon_read_property(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
				if (PHALCON_IS_NOT_FALSE(result)) {
					PHALCON_CALL_METHOD(&rows, result, "fetchall");
					phalcon_update_property_zval(this_ptr, SL("_rows"), rows TSRMLS_CC);
				}
			}

			convert_to_long(position);

			if(Z_TYPE_P(rows) == IS_ARRAY){

				ah0 = Z_ARRVAL_P(rows);
				zend_hash_internal_pointer_reset(ah0);

				i = 0;
				while (1) {

					if (i >= Z_LVAL_P(position)) {
						break;
					}

					zend_hash_move_forward(ah0);
					i++;
				}
			}

			phalcon_update_property_zval(this_ptr, SL("_pointer"), position TSRMLS_CC);
		}
	}

	PHALCON_MM_RESTORE();}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, count){

	zval *count = NULL, *type, *result = NULL, *number_rows = NULL, *rows = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(count);
	phalcon_read_property_this(&count, this_ptr, SL("_count"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(count) == IS_NULL) {
	
		PHALCON_INIT_NVAR(count);
		ZVAL_LONG(count, 0);
	
		PHALCON_OBS_VAR(type);
		phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(type)) {
	
			PHALCON_OBS_VAR(result);
			phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
			if (PHALCON_IS_NOT_FALSE(result)) {
				PHALCON_CALL_METHOD(&number_rows, result, "numrows");
	
				PHALCON_INIT_NVAR(count);
				ZVAL_LONG(count, phalcon_get_intval(number_rows));
			}
		} else {
			PHALCON_OBS_VAR(rows);
			phalcon_read_property_this(&rows, this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(rows) == IS_NULL) {
	
				PHALCON_OBS_NVAR(result);
				phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(result) == IS_OBJECT) {
					PHALCON_CALL_METHOD(&rows, result, "fetchall");
					phalcon_update_property_this_quick(this_ptr, SL("_rows"), rows, 3989235983UL TSRMLS_CC);
				}
			}
	
			PHALCON_INIT_NVAR(count);
			phalcon_fast_count(count, rows TSRMLS_CC);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_count"), count, 2208664173UL TSRMLS_CC);
	}
	
	RETURN_CCTOR(count);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetExists){

	zval *index, *count = NULL;

	phalcon_fetch_params(0, 1, 0, &index);
	
	PHALCON_CALL_METHODW(&count, this_ptr, "count");
	is_smaller_function(return_value, index, count TSRMLS_CC);
	zval_ptr_dtor(&count);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetGet){

	zval *index, *count = NULL, *pointer, *valid = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &index);
	
	PHALCON_CALL_METHOD(&count, this_ptr, "count");
	if (PHALCON_LT(index, count)) {
	
		PHALCON_OBS_VAR(pointer);
		phalcon_read_property_this(&pointer, this_ptr, SL("_pointer"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_EQUAL(pointer, index)) {
			PHALCON_RETURN_CALL_METHOD(this_ptr, "current");
			RETURN_MM();
		}
	
		PHALCON_CALL_METHOD(NULL, this_ptr, "seek", index);
	
		PHALCON_CALL_METHOD(&valid, this_ptr, "valid");
		if (PHALCON_IS_NOT_FALSE(valid)) {
			PHALCON_RETURN_CALL_METHOD(this_ptr, "current");
			RETURN_MM();
		}
	
		RETURN_MM_FALSE;
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The index does not exist in the cursor");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetSet){

	zval *index, *value;

	phalcon_fetch_params(0, 2, 0, &index, &value);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, offsetUnset){

	zval *offset;

	phalcon_fetch_params(0, 1, 0, &offset);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "Cursor is an immutable ArrayAccess object");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getFirst){

	zval *pointer, *valid = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(pointer);
	phalcon_read_property_this(&pointer, this_ptr, SL("_pointer"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_LONG(pointer, 0)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "current");
		RETURN_MM();
	}
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "rewind");
	
	PHALCON_CALL_METHOD(&valid, this_ptr, "valid");
	if (PHALCON_IS_NOT_FALSE(valid)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "current");
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getLast){

	zval *z_one, *count = NULL, *pre_count, *valid = NULL;

	PHALCON_MM_GROW();

	z_one = PHALCON_GLOBAL(z_one);
	
	PHALCON_CALL_METHOD(&count, this_ptr, "count");
	
	PHALCON_INIT_VAR(pre_count);
	sub_function(pre_count, count, z_one TSRMLS_CC);
	PHALCON_CALL_METHOD(NULL, this_ptr, "seek", pre_count);
	
	PHALCON_CALL_METHOD(&valid, this_ptr, "valid");
	if (PHALCON_IS_NOT_FALSE(valid)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "current");
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, setIsFresh){

	zval *is_fresh;

	phalcon_fetch_params(0, 1, 0, &is_fresh);
	
	phalcon_update_property_this_quick(this_ptr, SL("_isFresh"), is_fresh, 1397060440UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, isFresh){


	RETURN_MEMBER_QUICK(this_ptr, "_isFresh", 1397060440UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, setHydrateMode){

	zval *hydrate_mode;

	phalcon_fetch_params(0, 1, 0, &hydrate_mode);
	
	phalcon_update_property_this_quick(this_ptr, SL("_hydrateMode"), hydrate_mode, 2551752186UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getHydrateMode){


	RETURN_MEMBER_QUICK(this_ptr, "_hydrateMode", 2551752186UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getCache){


	RETURN_MEMBER_QUICK(this_ptr, "_cache", 2191407384UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, current){


	RETURN_MEMBER_QUICK(this_ptr, "_activeRow", 3086770360UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_errorMessages", 1019066246UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, delete){

	zval *condition_callback = NULL, *transaction = NULL, *record = NULL;
	zval *connection = NULL, *parameters = NULL, *status = NULL, *messages = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &condition_callback);
	
	if (!condition_callback) {
		condition_callback = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(transaction);
	ZVAL_FALSE(transaction);
	PHALCON_CALL_METHOD(NULL, this_ptr, "rewind");
	
	while (1) {
		PHALCON_CALL_METHOD(&r0, this_ptr, "valid");
		if (zend_is_true(r0)) {
		} else {
			break;
		}
	
		PHALCON_CALL_METHOD(&record, this_ptr, "current");
		if (PHALCON_IS_FALSE(transaction)) {
	
			if (phalcon_method_quick_exists_ex(record, SS("getwriteconnection"), 4280185952UL TSRMLS_CC) == FAILURE) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The returned record is not valid");
				return;
			}
	
			PHALCON_CALL_METHOD(&connection, record, "getwriteconnection");
			PHALCON_CALL_METHOD(NULL, connection, "begin");
	
			PHALCON_INIT_NVAR(transaction);
			ZVAL_TRUE(transaction);
		}
	
		if (Z_TYPE_P(condition_callback) == IS_OBJECT) {
	
			PHALCON_INIT_NVAR(parameters);
			array_init_size(parameters, 1);
			phalcon_array_append(&parameters, record, PH_SEPARATE);
	
			PHALCON_INIT_NVAR(status);/**/
			PHALCON_CALL_USER_FUNC_ARRAY(status, condition_callback, parameters);
			if (PHALCON_IS_FALSE(status)) {
				continue;
			}
		}
	
		PHALCON_CALL_METHOD(&status, record, "delete");
		if (!zend_is_true(status)) {
			PHALCON_CALL_METHOD(&messages, record, "getmessages");
			phalcon_update_property_this_quick(this_ptr, SL("_errorMessages"), messages, 1019066246UL TSRMLS_CC);
	
			PHALCON_CALL_METHOD(NULL, connection, "rollback");
	
			PHALCON_INIT_NVAR(transaction);
			ZVAL_BOOL(transaction, 0);
			break;
		}
	
		PHALCON_CALL_METHOD(NULL, this_ptr, "next");
	}
	
	if (PHALCON_IS_TRUE(transaction)) {
		PHALCON_CALL_METHOD(NULL, connection, "commit");
	}
	
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset, filter){

	zval *filter, *records, *parameters, *record = NULL, *processed_record = NULL;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &filter);
	
	PHALCON_INIT_VAR(records);
	array_init(records);
	PHALCON_CALL_METHOD(NULL, this_ptr, "rewind");
	
	PHALCON_INIT_VAR(parameters);
	array_init(parameters);
	
	while (1) {
	
		PHALCON_CALL_METHOD(&r0, this_ptr, "valid");
		if (zend_is_true(r0)) {
		} else {
			break;
		}
	
		PHALCON_CALL_METHOD(&record, this_ptr, "current");
		phalcon_array_update_long(&parameters, 0, record, PH_COPY | PH_SEPARATE);
	
		PHALCON_INIT_NVAR(processed_record);/**/
		PHALCON_CALL_USER_FUNC_ARRAY(processed_record, filter, parameters);
	
		if (Z_TYPE_P(processed_record) != IS_OBJECT) {
			if (Z_TYPE_P(processed_record) != IS_ARRAY) { 
				continue;
			}
		}
	
		phalcon_array_append(&records, processed_record, PH_SEPARATE);
		PHALCON_CALL_METHOD(NULL, this_ptr, "next");
	}
	
	RETURN_CTOR(records);
}





zend_class_entry *phalcon_mvc_model_resultsetinterface_ce;

static const zend_function_entry phalcon_mvc_model_resultsetinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, getFirst, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, getLast, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, setIsFresh, arginfo_phalcon_mvc_model_resultsetinterface_setisfresh)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, isFresh, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, getCache, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ResultsetInterface, toArray, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ResultsetInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ResultsetInterface, mvc_model_resultsetinterface, phalcon_mvc_model_resultsetinterface_method_entry);

	return SUCCESS;
}













zend_class_entry *phalcon_mvc_model_row_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Row, setDirtyState);
static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetExists);
static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetGet);
static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetSet);
static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetUnset);
static PHP_METHOD(Phalcon_Mvc_Model_Row, toArray);
static PHP_METHOD(Phalcon_Mvc_Model_Row, count);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_row_setdirtystate, 0, 0, 1)
	ZEND_ARG_INFO(0, dirtyState)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_row_offsetexists, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_row_offsetget, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_row_offsetset, 0, 0, 2)
	ZEND_ARG_INFO(0, index)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_row_offsetunset, 0, 0, 1)
	ZEND_ARG_INFO(0, offset)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_row_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Row, setDirtyState, arginfo_phalcon_mvc_model_row_setdirtystate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, offsetExists, arginfo_phalcon_mvc_model_row_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, offsetGet, arginfo_phalcon_mvc_model_row_offsetget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, offsetSet, arginfo_phalcon_mvc_model_row_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, offsetUnset, arginfo_phalcon_mvc_model_row_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, toArray, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Row, count, NULL, ZEND_ACC_PUBLIC)	
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Row){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Row, mvc_model_row, phalcon_mvc_model_row_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_row_ce TSRMLS_CC, 3, zend_ce_arrayaccess, spl_ce_Countable, phalcon_mvc_model_resultinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, setDirtyState){

	zval **dirty_state;

	phalcon_fetch_params_ex(1, 0, &dirty_state);

	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetExists){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	
	if (phalcon_isset_property_zval(this_ptr, index TSRMLS_CC)) {
		RETURN_TRUE;
	}
	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetGet){

	zval *index, *value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &index);
	
	if (phalcon_isset_property_zval(this_ptr, index TSRMLS_CC)) {
		PHALCON_OBS_VAR(value);
		phalcon_read_property_zval(&value, this_ptr, index, PH_NOISY TSRMLS_CC);
		RETURN_CTOR(value);
	}

	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "The index does not exist in the row");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetSet){

	zval *index, *value;

	phalcon_fetch_params(0, 2, 0, &index, &value);
	
	phalcon_update_property_zval_zval(this_ptr, index, value TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, offsetUnset){

	zval *offset;

	phalcon_fetch_params(0, 1, 0, &offset);
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "The index does not exist in the row");
	return;
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, toArray){

	HashTable *properties;

	properties = Z_OBJ_HT_P(this_ptr)->get_properties(this_ptr TSRMLS_CC);

	if (!properties) {
		RETURN_FALSE;
	}

	array_init_size(return_value, zend_hash_num_elements(properties));
	zend_hash_copy(Z_ARRVAL_P(return_value), properties, (copy_ctor_func_t)zval_add_ref, NULL, sizeof(zval*));
}

static PHP_METHOD(Phalcon_Mvc_Model_Row, count){
	HashTable *properties;
	properties = Z_OBJ_HT_P(this_ptr)->get_properties(this_ptr TSRMLS_CC);	
	if (properties) {
		RETURN_LONG(zend_hash_num_elements(properties));
	}
	RETURN_LONG(0);
}







zend_class_entry *phalcon_mvc_model_transaction_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setTransactionManager);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, begin);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, commit);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, rollback);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, getConnection);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setIsNewTransaction);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackOnAbort);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, isManaged);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, isValid);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackedRecord);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, dependencyInjector)
	ZEND_ARG_INFO(0, autoBegin)
	ZEND_ARG_INFO(0, service)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_transaction_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Transaction, __construct, arginfo_phalcon_mvc_model_transaction___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Transaction, setTransactionManager, arginfo_phalcon_mvc_model_transactioninterface_settransactionmanager, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, begin, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, commit, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, rollback, arginfo_phalcon_mvc_model_transactioninterface_rollback, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, getConnection, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, setIsNewTransaction, arginfo_phalcon_mvc_model_transactioninterface_setisnewtransaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, setRollbackOnAbort, arginfo_phalcon_mvc_model_transactioninterface_setrollbackonabort, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, isManaged, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, isValid, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction, setRollbackedRecord, arginfo_phalcon_mvc_model_transactioninterface_setrollbackedrecord, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Transaction, mvc_model_transaction, phalcon_mvc_model_transaction_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_activeTransaction"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_isNewTransaction"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_ce, SL("_rollbackOnAbort"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_manager"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_ce, SL("_rollbackRecord"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_transaction_ce TSRMLS_CC, 1, phalcon_mvc_model_transactioninterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, __construct){

	zval *dependency_injector, *auto_begin = NULL, *service = NULL;
	zval *connection = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &dependency_injector, &auto_begin, &service);
	
	if (!auto_begin) {
		auto_begin = PHALCON_GLOBAL(z_false);
	}
	
	if (!service) {
		PHALCON_INIT_VAR(service);
	} else {
		PHALCON_SEPARATE_PARAM(service);
	}
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_transaction_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	if (Z_TYPE_P(service) != IS_STRING) {
		PHALCON_INIT_NVAR(service);
		ZVAL_STRING(service, "db", 1);
	}
	
	PHALCON_CALL_METHOD(&connection, dependency_injector, "get", service);
	phalcon_update_property_this_quick(this_ptr, SL("_connection"), connection, 3057302292UL TSRMLS_CC);
	if (zend_is_true(auto_begin)) {
		PHALCON_CALL_METHOD(NULL, connection, "begin");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setTransactionManager){

	zval *manager;

	phalcon_fetch_params(0, 1, 0, &manager);
	PHALCON_VERIFY_INTERFACE_EX(manager, phalcon_mvc_model_transaction_managerinterface_ce, phalcon_mvc_model_transaction_exception_ce, 0);

	phalcon_update_property_this_quick(this_ptr, SL("_manager"), manager, 4140832863UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, begin){

	zval *connection;

	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(connection, "begin");
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, commit){

	zval *manager, *connection;

	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_CALL_METHODW(NULL, manager, "notifycommit", getThis());
	}
	
	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(connection, "commit");
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, rollback){

	zval *rollback_message = NULL, *rollback_record = NULL;
	zval *manager, *connection;
	zval *success = NULL;
	zval *i0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 2, &rollback_message, &rollback_record);
	
	if (!rollback_message) {
		PHALCON_INIT_VAR(rollback_message);
	} else {
		PHALCON_SEPARATE_PARAM(rollback_message);
	}
	
	if (!rollback_record) {
		PHALCON_INIT_VAR(rollback_record);
	} else {
		PHALCON_SEPARATE_PARAM(rollback_record);
	}
	
	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(manager) == IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, manager, "notifyrollback", getThis());
	}
	
	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&success, connection, "rollback");
	if (zend_is_true(success)) {
		if (!zend_is_true(rollback_message)) {
			PHALCON_INIT_NVAR(rollback_message);
			ZVAL_STRING(rollback_message, "Transaction aborted", 1);
		}
		if (Z_TYPE_P(rollback_record) == IS_OBJECT) {
			phalcon_update_property_this_quick(this_ptr, SL("_rollbackRecord"), rollback_record, 3406866061UL TSRMLS_CC);
		}
	
		PHALCON_OBS_NVAR(rollback_record);
		phalcon_read_property_this(&rollback_record, this_ptr, SL("_rollbackRecord"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(i0);
		object_init_ex(i0, phalcon_mvc_model_transaction_failed_ce);
		PHALCON_CALL_METHOD(NULL, i0, "__construct", rollback_message, rollback_record);
	
		phalcon_throw_exception(i0 TSRMLS_CC);
		RETURN_MM();
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, getConnection){

	zval *rollback_on_abort, *message;
	zval *connection;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(rollback_on_abort);
	phalcon_read_property_this(&rollback_on_abort, this_ptr, SL("_rollbackOnAbort"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(rollback_on_abort)) {
	
		if (PG(connection_status) & PHP_CONNECTION_ABORTED) {
			PHALCON_INIT_VAR(message);
			ZVAL_STRING(message, "The request was aborted", 1);
			PHALCON_CALL_METHOD(NULL, this_ptr, "rollback", message);
		}
	}
	
	PHALCON_OBS_VAR(connection);
	phalcon_read_property_this(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	
	RETURN_CCTOR(connection);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setIsNewTransaction){

	zval *is_new;

	phalcon_fetch_params(0, 1, 0, &is_new);
	
	phalcon_update_property_this_quick(this_ptr, SL("_isNewTransaction"), is_new, 3116442896UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackOnAbort){

	zval *rollback_on_abort;

	phalcon_fetch_params(0, 1, 0, &rollback_on_abort);
	
	phalcon_update_property_this_quick(this_ptr, SL("_rollbackOnAbort"), rollback_on_abort, 3438288323UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, isManaged){

	zval *manager;

	manager = phalcon_fetch_nproperty_this(this_ptr, SL("_manager"), PH_NOISY TSRMLS_CC);
	boolean_not_function(return_value, manager TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_messages", 743366684UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, isValid){

	zval *connection;

	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(connection, "isundertransaction");
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction, setRollbackedRecord){

	zval *record;

	phalcon_fetch_params(0, 1, 0, &record);
	
	phalcon_update_property_this_quick(this_ptr, SL("_rollbackRecord"), record, 3406866061UL TSRMLS_CC);
	
}





zend_class_entry *phalcon_mvc_model_transactioninterface_ce;

static const zend_function_entry phalcon_mvc_model_transactioninterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, setTransactionManager, arginfo_phalcon_mvc_model_transactioninterface_settransactionmanager)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, begin, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, commit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, rollback, arginfo_phalcon_mvc_model_transactioninterface_rollback)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, getConnection, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, setIsNewTransaction, arginfo_phalcon_mvc_model_transactioninterface_setisnewtransaction)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, setRollbackOnAbort, arginfo_phalcon_mvc_model_transactioninterface_setrollbackonabort)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, isManaged, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, getMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, isValid, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_TransactionInterface, setRollbackedRecord, arginfo_phalcon_mvc_model_transactioninterface_setrollbackedrecord)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_TransactionInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, TransactionInterface, mvc_model_transactioninterface, phalcon_mvc_model_transactioninterface_method_entry);

	return SUCCESS;
}


















zend_class_entry *phalcon_mvc_model_validationfailed_ce;

static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, getModel);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_validationfailed___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, validationMessages)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_validationfailed_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_ValidationFailed, __construct, arginfo_phalcon_mvc_model_validationfailed___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_ValidationFailed, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_ValidationFailed, getModel, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ValidationFailed){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model, ValidationFailed, mvc_model_validationfailed, phalcon_mvc_model_exception_ce, phalcon_mvc_model_validationfailed_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_validationfailed_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_validationfailed_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, __construct){

	zval *model, *validation_messages, *message;
	zval *message_str = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &validation_messages);
	
	if (phalcon_fast_count_ev(validation_messages TSRMLS_CC)) {
		PHALCON_OBS_VAR(message);
		phalcon_array_fetch_long(&message, validation_messages, 0, PH_NOISY);
	
		PHALCON_CALL_METHOD(&message_str, message, "getmessage");
	} else {
		PHALCON_INIT_VAR(message_str);
		ZVAL_STRING(message_str, "Validation failed", 1);
	}
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_messages"), validation_messages, 743366684UL TSRMLS_CC);
	PHALCON_CALL_PARENT(NULL, phalcon_mvc_model_validationfailed_ce, this_ptr, "__construct", message_str);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_messages", 743366684UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_ValidationFailed, getModel){


	RETURN_MEMBER_QUICK(this_ptr, "_model", 2599397109UL);
}






zend_class_entry *phalcon_mvc_model_validator_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Validator, appendMessage);
static PHP_METHOD(Phalcon_Mvc_Model_Validator, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model_Validator, getOptions);
static PHP_METHOD(Phalcon_Mvc_Model_Validator, getOption);
static PHP_METHOD(Phalcon_Mvc_Model_Validator, isSetOption);

static const zend_function_entry phalcon_mvc_model_validator_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator, __construct, arginfo_phalcon_mvc_model_validator___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Validator, appendMessage, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Validator, getMessages, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Validator, getOptions, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Validator, getOption, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Validator, isSetOption, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model, Validator, mvc_model_validator, phalcon_mvc_model_validator_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_model_validator_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_validator_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_validator_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, __construct){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "$options argument must be an Array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, appendMessage){

	zval *message, *field = NULL, *type = NULL, *code = NULL;
	zval *model_message, *t;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &message, &field, &type, &code);
	
	if (!field) {
		field = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}

	if (!code) {
		code = PHALCON_GLOBAL(z_zero);
	}
	
	if (!zend_is_true(type)) {
		char *c;
		int len;

		PHALCON_INIT_VAR(t);
		phalcon_get_class(t, this_ptr, 0 TSRMLS_CC);

		assert(Z_TYPE_P(t) == IS_STRING);

		c   = Z_STRVAL_P(t);
		len = Z_STRLEN_P(t);

		if (len > 9 && !memcmp(c + len - 9, "Validator", 9)) {
			Z_STRLEN_P(t) -= 9;
			c[len-9]       = 0;
		}
	}
	else {
		t = type;
	}
	
	PHALCON_INIT_VAR(model_message);
	object_init_ex(model_message, phalcon_mvc_model_message_ce);
	PHALCON_CALL_METHOD(NULL, model_message, "__construct", message, field, t, code);
	
	phalcon_update_property_array_append(this_ptr, SL("_messages"), model_message TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, getMessages){


	RETURN_MEMBER_QUICK(this_ptr, "_messages", 743366684UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, getOption){

	zval *option, *options, *value;

	phalcon_fetch_params(0, 1, 0, &option);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, options, option)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator, isSetOption){

	zval *option, *options;

	phalcon_fetch_params(0, 1, 0, &option);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
	RETURN_BOOL(phalcon_array_isset(options, option));
}





zend_class_entry *phalcon_mvc_model_validatorinterface_ce;

static const zend_function_entry phalcon_mvc_model_validatorinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ValidatorInterface, getMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_ValidatorInterface, validate, arginfo_phalcon_mvc_model_validatorinterface_validate)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_ValidatorInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model, ValidatorInterface, mvc_model_validatorinterface, phalcon_mvc_model_validatorinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_mvc_model_behavior_softdelete_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Behavior_SoftDelete, notify);

static const zend_function_entry phalcon_mvc_model_behavior_softdelete_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Behavior_SoftDelete, notify, arginfo_phalcon_mvc_model_behaviorinterface_notify, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Behavior_SoftDelete){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Behavior, SoftDelete, mvc_model_behavior_softdelete, phalcon_mvc_model_behavior_ce, phalcon_mvc_model_behavior_softdelete_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_behavior_softdelete_ce TSRMLS_CC, 1, phalcon_mvc_model_behaviorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior_SoftDelete, notify){

	zval *type, *model, *options = NULL, *value, *field, *actual_value = NULL;
	zval *update_model, *status = NULL, *messages = NULL, *message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &model);
	
	if (PHALCON_IS_STRING(type, "beforeDelete")) {
		PHALCON_CALL_METHOD(&options, this_ptr, "getoptions");
		if (!phalcon_array_isset_quick_string(options, SS("value"), 574111618UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'value' is required");
			return;
		}
	
		if (!phalcon_array_isset_quick_string(options, SS("field"), 4252138601UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'field' is required");
			return;
		}
	
		PHALCON_CALL_METHOD(NULL, model, "skipoperation", PHALCON_GLOBAL(z_true));
	
		PHALCON_OBS_VAR(value);
		phalcon_array_fetch_quick_string(&value, options, SS("value"), 574111618UL, PH_NOISY);
	
		PHALCON_OBS_VAR(field);
		phalcon_array_fetch_quick_string(&field, options, SS("field"), 4252138601UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&actual_value, model, "readattribute", field);
	
		if (!PHALCON_IS_EQUAL(actual_value, value)) {
	
			PHALCON_INIT_VAR(update_model);
			if (phalcon_clone(update_model, model TSRMLS_CC) == FAILURE) {
				RETURN_MM();
			}

			PHALCON_CALL_METHOD(NULL, update_model, "writeattribute", field, value);
	
			PHALCON_CALL_METHOD(&status, update_model, "save");
			if (!zend_is_true(status)) {
	
				PHALCON_CALL_METHOD(&messages, update_model, "getmessages");
	
				phalcon_is_iterable(messages, &ah0, &hp0, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
					PHALCON_GET_HVALUE(message);
	
					PHALCON_CALL_METHOD(NULL, model, "appendmessage", message);
	
					zend_hash_move_forward_ex(ah0, &hp0);
				}
	
				RETURN_MM_FALSE;
			}
	
			PHALCON_CALL_METHOD(NULL, model, "writeattribute", field, value);
		}
	}
	
	PHALCON_MM_RESTORE();
}






#include <Zend/zend_closures.h>


zend_class_entry *phalcon_mvc_model_behavior_timestampable_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Behavior_Timestampable, notify);

static const zend_function_entry phalcon_mvc_model_behavior_timestampable_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Behavior_Timestampable, notify, arginfo_phalcon_mvc_model_behaviorinterface_notify, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Behavior_Timestampable){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Behavior, Timestampable, mvc_model_behavior_timestampable, phalcon_mvc_model_behavior_ce, phalcon_mvc_model_behavior_timestampable_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_behavior_timestampable_ce TSRMLS_CC, 1, phalcon_mvc_model_behaviorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Behavior_Timestampable, notify){

	zval *type, *model, *take_action = NULL, *options = NULL, *timestamp = NULL;
	zval *format, *generator, *field, *single_field = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &type, &model);
	
	PHALCON_CALL_METHOD(&take_action, this_ptr, "musttakeaction", type);
	if (PHALCON_IS_NOT_TRUE(take_action)) {
		RETURN_MM_NULL();
	}
	
	PHALCON_CALL_METHOD(&options, this_ptr, "getoptions", type);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
	
		if (!phalcon_array_isset_quick_string(options, SS("field"), 4252138601UL)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'field' is required");
			return;
		}
	
		PHALCON_INIT_VAR(timestamp);
		if (phalcon_array_isset_quick_string(options, SS("format"), 3131886190UL)) {
			PHALCON_OBS_VAR(format);
			phalcon_array_fetch_quick_string(&format, options, SS("format"), 3131886190UL, PH_NOISY);
	
			phalcon_date(timestamp, format, NULL TSRMLS_CC);
		} else if (phalcon_array_isset_quick_string(options, SS("generator"), 3205705004UL)) {
			PHALCON_OBS_VAR(generator);
			phalcon_array_fetch_quick_string(&generator, options, SS("generator"), 3205705004UL, PH_NOISY);
			if (Z_TYPE_P(generator) == IS_OBJECT) {
				if (instanceof_function(Z_OBJCE_P(generator), zend_ce_closure TSRMLS_CC)) {
					PHALCON_INIT_NVAR(timestamp);/**/
					PHALCON_CALL_USER_FUNC(timestamp, generator);
				}
			}
		}
	
		if (Z_TYPE_P(timestamp) == IS_NULL) {
			PHALCON_INIT_NVAR(timestamp);
			ZVAL_LONG(timestamp, (long) time(NULL));
		}
	
		PHALCON_OBS_VAR(field);
		phalcon_array_fetch_quick_string(&field, options, SS("field"), 4252138601UL, PH_NOISY);
	
		if (unlikely(Z_TYPE_P(field) == IS_ARRAY)) { 
	
			phalcon_is_iterable(field, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(single_field);
	
				PHALCON_CALL_METHOD(NULL, model, "writeattribute", single_field, timestamp);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		} else {
			PHALCON_CALL_METHOD(NULL, model, "writeattribute", field, timestamp);
		}
	}
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_mvc_model_metadata_apc_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, read);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, write);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_apc___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_apc_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Apc, __construct, arginfo_phalcon_mvc_model_metadata_apc___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Apc, read, arginfo_phalcon_mvc_model_metadatainterface_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Apc, write, arginfo_phalcon_mvc_model_metadatainterface_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Apc, reset, arginfo_phalcon_mvc_model_metadatainterface_reset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Apc){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Apc, mvc_model_metadata_apc, phalcon_mvc_model_metadata_ce, phalcon_mvc_model_metadata_apc_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_apc_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_metadata_apc_ce, SL("_ttl"), 172800, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_apc_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, __construct){

	zval *options = NULL, *empty_array;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		zval *prefix, *ttl;

		if (phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&ttl, options, SS("lifetime"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_ttl"), ttl, 251113304UL TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, read)
{
	zval *key, *prefix, *apc_key, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(apc_key);
	PHALCON_CONCAT_SVV(apc_key, "$PMM$", prefix, key);
	
	PHALCON_CALL_FUNCTION(&data, "apc_fetch", apc_key);
	if (Z_TYPE_P(data) == IS_ARRAY) { 
		RETURN_CCTOR(data);
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, write){

	zval *key, *data, *prefix, *apc_key, *ttl;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &key, &data);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(apc_key);
	PHALCON_CONCAT_SVV(apc_key, "$PMM$", prefix, key);
	
	PHALCON_OBS_VAR(ttl);
	phalcon_read_property_this(&ttl, this_ptr, SL("_ttl"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_FUNCTION(NULL, "apc_store", apc_key, data, ttl);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Apc, reset)
{
	zval *meta = phalcon_fetch_nproperty_this(this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	zval *real_key = NULL;

	PHALCON_MM_GROW();

	if (Z_TYPE_P(meta) == IS_ARRAY) {
		HashTable *ht = Z_ARRVAL_P(meta);
		HashPosition hp;
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		for (
			zend_hash_internal_pointer_reset_ex(ht, &hp);
			zend_hash_get_current_key_type_ex(ht, &hp) != HASH_KEY_NON_EXISTENT;
			zend_hash_move_forward_ex(ht, &hp)
		) {
			zval key = phalcon_get_current_key_w(ht, &hp);

			PHALCON_INIT_NVAR(real_key);
			phalcon_concat_svsv(&real_key, SL("$PMM$"), prefix, SL("meta-"), &key, 0 TSRMLS_CC);
			PHALCON_CALL_FUNCTION(NULL, "apc_delete", real_key);
		}
	}

	PHALCON_CALL_PARENT(NULL, phalcon_mvc_model_metadata_apc_ce, getThis(), "reset");
	PHALCON_MM_RESTORE();
}





#include <ext/standard/php_smart_str.h>
#include <ext/standard/php_var.h>
#include <ext/spl/spl_directory.h>


zend_class_entry *phalcon_mvc_model_metadata_files_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, read);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, write);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_files___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_files_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Files, __construct, arginfo_phalcon_mvc_model_metadata_files___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Files, read, arginfo_phalcon_mvc_model_metadatainterface_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Files, write, arginfo_phalcon_mvc_model_metadatainterface_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Files, reset, arginfo_phalcon_mvc_model_metadatainterface_reset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Files){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Files, mvc_model_metadata_files, phalcon_mvc_model_metadata_ce, phalcon_mvc_model_metadata_files_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_files_ce, SL("_metaDataDir"), "./", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_files_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, __construct){

	zval *options = NULL, *meta_data_dir, *empty_array;

	phalcon_fetch_params(0, 0, 1, &options);

	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		if (phalcon_array_isset_string_fetch(&meta_data_dir, options, SS("metaDataDir"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_metaDataDir"), meta_data_dir, 1346965284UL TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, read){

	zval **key, *meta_data_dir, *virtual_key;
	zval *path, *data = NULL;

	phalcon_fetch_params_ex(1, 0, &key);
	PHALCON_ENSURE_IS_STRING(key);

	PHALCON_MM_GROW();

	meta_data_dir = phalcon_fetch_nproperty_this(this_ptr, SL("_metaDataDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(virtual_key);
	phalcon_prepare_virtual_path_ex(virtual_key, Z_STRVAL_PP(key), Z_STRLEN_PP(key), '_' TSRMLS_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VVS(path, meta_data_dir, virtual_key, ".php");
	
	if (phalcon_file_exists(path TSRMLS_CC) == SUCCESS) {
		RETURN_MM_ON_FAILURE(phalcon_require_ret(&data, Z_STRVAL_P(path) TSRMLS_CC));
		RETVAL_ZVAL(data, 1, 1);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, write){

	zval **key, **data, *meta_data_dir, *virtual_key;
	zval *path, *php_export, *status;
	smart_str exp = { NULL, 0, 0 };

	phalcon_fetch_params_ex(2, 0, &key, &data);

	PHALCON_MM_GROW();

	meta_data_dir = phalcon_fetch_nproperty_this(this_ptr, SL("_metaDataDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(virtual_key);
	phalcon_prepare_virtual_path_ex(virtual_key, Z_STRVAL_PP(key), Z_STRLEN_PP(key), '_' TSRMLS_CC);
	
	PHALCON_INIT_VAR(path);
	PHALCON_CONCAT_VVS(path, meta_data_dir, virtual_key, ".php");
	
	smart_str_appends(&exp, "<?php return ");
	php_var_export_ex(data, 0, &exp TSRMLS_CC);
	smart_str_appendc(&exp, ';');
	smart_str_0(&exp);
	
	PHALCON_INIT_VAR(php_export);
	ZVAL_STRINGL(php_export, exp.c, exp.len, 0);

	PHALCON_INIT_VAR(status);
	phalcon_file_put_contents(status, path, php_export TSRMLS_CC);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Meta-Data directory cannot be written");
		return;
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Files, reset)
{
	zval *metadata_dir, *pattern, *iterator, *itkey = NULL;
	zend_object_iterator *it;

	PHALCON_MM_GROW();

	metadata_dir = phalcon_fetch_nproperty_this(this_ptr, SL("_metaDataDir"), PH_NOISY TSRMLS_CC);

	PHALCON_INIT_VAR(pattern);
	PHALCON_CONCAT_VS(pattern, metadata_dir, "meta-*.php");

	PHALCON_INIT_VAR(iterator);
	object_init_ex(iterator, spl_ce_GlobIterator);
	PHALCON_CALL_METHOD(NULL, iterator, "__construct", pattern);

	it = spl_ce_GlobIterator->get_iterator(spl_ce_GlobIterator, iterator, 0 TSRMLS_CC);
	it->funcs->rewind(it TSRMLS_CC);
	while (SUCCESS == it->funcs->valid(it TSRMLS_CC) && !EG(exception)) {
		zval dummy;
#if PHP_VERSION_ID < 50500
		char *str_key;
		uint str_key_len;
		ulong int_key;

		int key_type = it->funcs->get_current_key(it, &str_key, &str_key_len, &int_key TSRMLS_CC);
		if (likely(key_type == HASH_KEY_IS_STRING)) {
			PHALCON_INIT_NVAR(itkey);
			/* Note that str_key_len includes the trailing zero */
			ZVAL_STRINGL(itkey, str_key, str_key_len-1, 1);
			phalcon_unlink(&dummy, itkey TSRMLS_CC);
		}
#else
		PHALCON_INIT_NVAR(itkey);
		it->funcs->get_current_key(it, itkey TSRMLS_CC);
		phalcon_unlink(&dummy, itkey TSRMLS_CC);
#endif

		it->funcs->move_forward(it TSRMLS_CC);
	}

	it->funcs->dtor(it TSRMLS_CC);

	if (!EG(exception)) {
		PHALCON_CALL_PARENT(NULL, phalcon_mvc_model_metadata_files_ce, getThis(), "reset");
	}

	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_mvc_model_metadata_memory_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, read);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, write);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_memory___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_memory_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Memory, __construct, arginfo_phalcon_mvc_model_metadata_memory___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Memory, read, arginfo_phalcon_mvc_model_metadatainterface_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Memory, write, arginfo_phalcon_mvc_model_metadatainterface_write, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Memory){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Memory, mvc_model_metadata_memory, phalcon_mvc_model_metadata_ce, phalcon_mvc_model_metadata_memory_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_metadata_memory_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, __construct){

	zval *options = NULL, *empty_array;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, read){

	zval *key;

	phalcon_fetch_params(0, 1, 0, &key);
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Memory, write){

	zval *key, *meta_data;

	phalcon_fetch_params(0, 2, 0, &key, &meta_data);
	
	RETURN_NULL();
}






zend_class_entry *phalcon_mvc_model_metadata_session_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, read);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, write);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_session___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_session_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Session, __construct, arginfo_phalcon_mvc_model_metadata_session___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Session, read, arginfo_phalcon_mvc_model_metadatainterface_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Session, write, arginfo_phalcon_mvc_model_metadatainterface_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Session, reset, arginfo_phalcon_mvc_model_metadatainterface_reset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Session){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Session, mvc_model_metadata_session, phalcon_mvc_model_metadata_ce, phalcon_mvc_model_metadata_session_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_session_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_session_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, __construct){

	zval *options = NULL, *prefix, *empty_array;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		if (phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, read){

	zval *key, *session, *prefix, *prefix_key;
	zval *meta_data;
	zval *r0, *r1 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(0, 1, 0, &key);
	
	session = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefix_key);
	PHALCON_CONCAT_SV(prefix_key, "$PMM$", prefix);
	if (phalcon_array_isset_fetch(&r0, session, prefix_key)) {

		if (phalcon_array_isset(r0, key)) {
			PHALCON_OBS_VAR(r1);
			phalcon_array_fetch(&r1, session, prefix_key, PH_NOISY);
			PHALCON_OBS_VAR(meta_data);
			phalcon_array_fetch(&meta_data, r1, key, PH_NOISY);
			RETURN_CCTOR(meta_data);
		}
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, write){

	zval *key, *data, *prefix, *prefix_key, *_SESSION;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &key, &data);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefix_key);
	PHALCON_CONCAT_SV(prefix_key, "$PMM$", prefix);
	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	phalcon_array_update_multi_2(&_SESSION, prefix_key, key, data, 0);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Session, reset)
{
	zval prefix_key = zval_used_for_init, *pprefix = &prefix_key, *_SESSION;
	zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	phalcon_concat_sv(&pprefix, SL("$PMM$"), prefix, 0 TSRMLS_CC);
	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	phalcon_array_unset(&_SESSION, &prefix_key, 0);
	zval_dtor(&prefix_key);

	PHALCON_CALL_PARENTW(NULL, phalcon_mvc_model_metadata_session_ce, getThis(), "reset");
}






zend_class_entry *phalcon_mvc_model_metadata_xcache_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, read);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, write);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_xcache___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_xcache_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Xcache, __construct, arginfo_phalcon_mvc_model_metadata_xcache___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Xcache, read, arginfo_phalcon_mvc_model_metadatainterface_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Xcache, write, arginfo_phalcon_mvc_model_metadatainterface_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Xcache, reset, arginfo_phalcon_mvc_model_metadatainterface_reset, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Xcache){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\MetaData, Xcache, mvc_model_metadata_xcache, phalcon_mvc_model_metadata_ce, phalcon_mvc_model_metadata_xcache_method_entry, 0);

	zend_declare_property_string(phalcon_mvc_model_metadata_xcache_ce, SL("_prefix"), "", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_metadata_xcache_ce, SL("_ttl"), 172800, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_metadata_xcache_ce TSRMLS_CC, 1, phalcon_mvc_model_metadatainterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, __construct){

	zval *options = NULL, *prefix, *ttl, *empty_array;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		if (phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&ttl, options, SS("lifetime"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_ttl"), ttl, 251113304UL TSRMLS_CC);
		}
	}
	
	PHALCON_ALLOC_GHOST_ZVAL(empty_array);
	array_init(empty_array);
	phalcon_update_property_this_quick(this_ptr, SL("_metaData"), empty_array, 1295805989UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, read){

	zval *key, *prefix, *xc_key, *data = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &key);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(xc_key);
	PHALCON_CONCAT_SVV(xc_key, "$PMM$", prefix, key);
	
	PHALCON_CALL_FUNCTION(&data, "xcache_get", xc_key);
	if (Z_TYPE_P(data) == IS_ARRAY) { 
		RETURN_CCTOR(data);
	}
	
	RETURN_MM_NULL();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, write){

	zval *key, *data, *prefix, *xc_key, *ttl;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &key, &data);
	
	prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(xc_key);
	PHALCON_CONCAT_SVV(xc_key, "$PMM$", prefix, key);
	
	PHALCON_OBS_VAR(ttl);
	phalcon_read_property_this(&ttl, this_ptr, SL("_ttl"), PH_NOISY TSRMLS_CC);
	PHALCON_CALL_FUNCTION(NULL, "xcache_set", xc_key, data, ttl);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Xcache, reset)
{
	zval *meta = phalcon_fetch_nproperty_this(this_ptr, SL("_metaData"), PH_NOISY TSRMLS_CC);
	zval *real_key = NULL;

	PHALCON_MM_GROW();

	if (SUCCESS == phalcon_function_exists_ex(SL("xcache_unset_by_prefix") TSRMLS_CC)) {
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		PHALCON_INIT_VAR(real_key);
		phalcon_concat_svs(&real_key, SL("$PMM$"), prefix, SL("meta-"), 0 TSRMLS_CC);
		PHALCON_CALL_FUNCTION(NULL, "xcache_unset_by_prefix", real_key);
	}
	else if (Z_TYPE_P(meta) == IS_ARRAY) {
		HashTable *ht = Z_ARRVAL_P(meta);
		HashPosition hp;
		zval *prefix = phalcon_fetch_nproperty_this(this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

		for (
			zend_hash_internal_pointer_reset_ex(ht, &hp);
			zend_hash_get_current_key_type_ex(ht, &hp) != HASH_KEY_NON_EXISTENT;
			zend_hash_move_forward_ex(ht, &hp)
		) {
			zval key = phalcon_get_current_key_w(ht, &hp);

			PHALCON_INIT_NVAR(real_key);
			phalcon_concat_svsv(&real_key, SL("$PMM$"), prefix, SL("meta-"), &key, 0 TSRMLS_CC);
			PHALCON_CALL_FUNCTION(NULL, "xcache_unset", real_key);
		}
	}

	PHALCON_CALL_PARENT(NULL, phalcon_mvc_model_metadata_xcache_ce, getThis(), "reset");
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_mvc_model_metadata_strategy_annotations_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getMetaData);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getColumnMaps);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_strategy_annotations_getmetadata, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_strategy_annotations_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getMetaData, arginfo_phalcon_mvc_model_metadata_strategy_annotations_getmetadata, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getColumnMaps, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Strategy_Annotations){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\MetaData\\Strategy, Annotations, mvc_model_metadata_strategy_annotations, phalcon_mvc_model_metadata_strategy_annotations_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getMetaData){

	zval *model, *dependency_injector, *service;
	zval *annotations = NULL, *class_name, *reflection = NULL;
	zval *exception_message = NULL, *properties_annotations = NULL;
	zval *attributes, *primary_keys, *non_primary_keys;
	zval *numeric_typed, *not_null, *field_types;
	zval *field_bind_types, *automatic_default;
	zval *identity_field = NULL, *column_annot_name;
	zval *primary_annot_name, *id_annot_name;
	zval *column_type_name, *column_nullable_name;
	zval *prop_annotations = NULL, *property = NULL, *has_annotation = NULL;
	zval *column_annotation = NULL, *feature = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &dependency_injector);
	
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The dependency injector is invalid");
		return;
	}
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "annotations", 1);
	
	PHALCON_CALL_METHOD(&annotations, dependency_injector, "get", service);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&reflection, annotations, "get", class_name);
	if (Z_TYPE_P(reflection) != IS_OBJECT) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "No annotations were found in class ", class_name);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_CALL_METHOD(&properties_annotations, reflection, "getpropertiesannotations");
	if (!phalcon_fast_count_ev(properties_annotations TSRMLS_CC)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SV(exception_message, "No properties with annotations were found in class ", class_name);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(attributes);
	array_init(attributes);
	
	PHALCON_INIT_VAR(primary_keys);
	array_init(primary_keys);
	
	PHALCON_INIT_VAR(non_primary_keys);
	array_init(non_primary_keys);
	
	PHALCON_INIT_VAR(numeric_typed);
	array_init(numeric_typed);
	
	PHALCON_INIT_VAR(not_null);
	array_init(not_null);
	
	PHALCON_INIT_VAR(field_types);
	array_init(field_types);
	
	PHALCON_INIT_VAR(field_bind_types);
	array_init(field_bind_types);
	
	PHALCON_INIT_VAR(automatic_default);
	array_init(automatic_default);
	
	PHALCON_INIT_VAR(identity_field);
	ZVAL_FALSE(identity_field);
	
	PHALCON_INIT_VAR(column_annot_name);
	ZVAL_STRING(column_annot_name, "Column", 1);
	
	PHALCON_INIT_VAR(primary_annot_name);
	ZVAL_STRING(primary_annot_name, "Primary", 1);
	
	PHALCON_INIT_VAR(id_annot_name);
	ZVAL_STRING(id_annot_name, "Identity", 1);
	
	PHALCON_INIT_VAR(column_type_name);
	ZVAL_STRING(column_type_name, "type", 1);
	
	PHALCON_INIT_VAR(column_nullable_name);
	ZVAL_STRING(column_nullable_name, "nullable", 1);
	
	phalcon_is_iterable(properties_annotations, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(property, ah0, hp0);
		PHALCON_GET_HVALUE(prop_annotations);
	
		PHALCON_CALL_METHOD(&has_annotation, prop_annotations, "has", column_annot_name);
		if (!zend_is_true(has_annotation)) {
			zend_hash_move_forward_ex(ah0, &hp0);
			continue;
		}
	
		PHALCON_CALL_METHOD(&column_annotation, prop_annotations, "get", column_annot_name);
	
		PHALCON_CALL_METHOD(&feature, column_annotation, "getargument", column_type_name);
		if (PHALCON_IS_STRING(feature, "integer")) {
			phalcon_array_update_zval_long(&field_types, property, 0, PH_SEPARATE);
			phalcon_array_update_zval_long(&field_bind_types, property, 1, PH_SEPARATE);
			phalcon_array_update_zval_bool(&numeric_typed, property, 1, PH_SEPARATE);
		} else if (PHALCON_IS_STRING(feature, "decimal")) {
			phalcon_array_update_zval_long(&field_types, property, 3, PH_SEPARATE);
			phalcon_array_update_zval_long(&field_bind_types, property, 32, PH_SEPARATE);
			phalcon_array_update_zval_bool(&numeric_typed, property, 1, PH_SEPARATE);
		} else if (PHALCON_IS_STRING(feature, "boolean")) {
			phalcon_array_update_zval_long(&field_types, property, 8, PH_SEPARATE);
			phalcon_array_update_zval_long(&field_bind_types, property, 5, PH_SEPARATE);
		} else {
			if (PHALCON_IS_STRING(feature, "date")) {
				phalcon_array_update_zval_long(&field_types, property, 1, PH_SEPARATE);
			} else {
				phalcon_array_update_zval_long(&field_types, property, 2, PH_SEPARATE);
			}
			phalcon_array_update_zval_long(&field_bind_types, property, 2, PH_SEPARATE);
		}
	
		PHALCON_CALL_METHOD(&has_annotation, prop_annotations, "has", primary_annot_name);
		if (zend_is_true(has_annotation)) {
			phalcon_array_append(&primary_keys, property, PH_SEPARATE);
		} else {
			phalcon_array_append(&non_primary_keys, property, PH_SEPARATE);
		}
	
		PHALCON_CALL_METHOD(&has_annotation, prop_annotations, "has", id_annot_name);
		if (zend_is_true(has_annotation)) {
			PHALCON_CPY_WRT(identity_field, property);
		}
	
		PHALCON_CALL_METHOD(&feature, column_annotation, "getargument", column_nullable_name);
		if (!zend_is_true(feature)) {
			phalcon_array_append(&not_null, property, PH_SEPARATE);
		}
	
		phalcon_array_append(&attributes, property, PH_SEPARATE);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	array_init_size(return_value, 10);
	phalcon_array_update_long(&return_value, 0,  attributes, PH_COPY);
	phalcon_array_update_long(&return_value, 1,  primary_keys, PH_COPY);
	phalcon_array_update_long(&return_value, 2,  non_primary_keys, PH_COPY);
	phalcon_array_update_long(&return_value, 3,  not_null, PH_COPY);
	phalcon_array_update_long(&return_value, 4,  field_types, PH_COPY);
	phalcon_array_update_long(&return_value, 5,  numeric_typed, PH_COPY);
	phalcon_array_update_long(&return_value, 8,  identity_field, PH_COPY);
	phalcon_array_update_long(&return_value, 9,  field_bind_types, PH_COPY);
	phalcon_array_update_long(&return_value, 10, automatic_default, PH_COPY);
	phalcon_array_update_long(&return_value, 11, automatic_default, PH_COPY);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Annotations, getColumnMaps){


	
}







zend_class_entry *phalcon_mvc_model_metadata_strategy_introspection_ce;

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getMetaData);
static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getColumnMaps);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_strategy_introspection_getmetadata, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_metadata_strategy_introspection_getcolumnmaps, 0, 0, 2)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_metadata_strategy_introspection_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getMetaData, arginfo_phalcon_mvc_model_metadata_strategy_introspection_getmetadata, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getColumnMaps, arginfo_phalcon_mvc_model_metadata_strategy_introspection_getcolumnmaps, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_MetaData_Strategy_Introspection){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\MetaData\\Strategy, Introspection, mvc_model_metadata_strategy_introspection, phalcon_mvc_model_metadata_strategy_introspection_method_entry, 0);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getMetaData){

	zval *model, *dependency_injector, *class_name;
	zval *schema = NULL, *table = NULL, *read_connection = NULL, *exists = NULL;
	zval *complete_table = NULL, *exception_message = NULL;
	zval *columns = NULL, *attributes, *primary_keys, *non_primary_keys;
	zval *numeric_typed, *not_null, *field_types;
	zval *field_bind_types, *automatic_default;
	zval *identity_field = NULL, *column = NULL, *field_name = NULL, *feature = NULL;
	zval *type = NULL, *bind_type = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &dependency_injector);
	
	PHALCON_INIT_VAR(class_name);
	phalcon_get_class(class_name, model, 0 TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&schema, model, "getschema");
	PHALCON_CALL_METHOD(&table, model, "getsource");
	
	PHALCON_CALL_METHOD(&read_connection, model, "getreadconnection");
	PHALCON_CALL_METHOD(&exists, read_connection, "tableexists", table, schema);
	if (!zend_is_true(exists)) {
		if (zend_is_true(schema)) {
			PHALCON_INIT_VAR(complete_table);
			PHALCON_CONCAT_VSV(complete_table, schema, "\".\"", table);
		} else {
			PHALCON_CPY_WRT(complete_table, table);
		}
	
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVSV(exception_message, "Table \"", complete_table, "\" doesn't exist on database when dumping meta-data for ", class_name);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_CALL_METHOD(&columns, read_connection, "describecolumns", table, schema);
	if (!phalcon_fast_count_ev(columns TSRMLS_CC)) {
		if (zend_is_true(schema)) {
			PHALCON_INIT_NVAR(complete_table);
			PHALCON_CONCAT_VSV(complete_table, schema, "\".\"", table);
		} else {
			PHALCON_CPY_WRT(complete_table, table);
		}
	
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVSV(exception_message, "Cannot obtain table columns for the mapped source \"", complete_table, "\" used in model ", class_name);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(attributes);
	array_init(attributes);
	
	PHALCON_INIT_VAR(primary_keys);
	array_init(primary_keys);
	
	PHALCON_INIT_VAR(non_primary_keys);
	array_init(non_primary_keys);
	
	PHALCON_INIT_VAR(numeric_typed);
	array_init(numeric_typed);
	
	PHALCON_INIT_VAR(not_null);
	array_init(not_null);
	
	PHALCON_INIT_VAR(field_types);
	array_init(field_types);
	
	PHALCON_INIT_VAR(field_bind_types);
	array_init(field_bind_types);
	
	PHALCON_INIT_VAR(automatic_default);
	array_init(automatic_default);
	
	PHALCON_INIT_VAR(identity_field);
	ZVAL_FALSE(identity_field);
	
	phalcon_is_iterable(columns, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(column);
	
		PHALCON_CALL_METHOD(&field_name, column, "getname");
		phalcon_array_append(&attributes, field_name, PH_SEPARATE);
	
		PHALCON_CALL_METHOD(&feature, column, "isprimary");
		if (PHALCON_IS_TRUE(feature)) {
			phalcon_array_append(&primary_keys, field_name, PH_SEPARATE);
		} else {
			phalcon_array_append(&non_primary_keys, field_name, PH_SEPARATE);
		}
	
		PHALCON_CALL_METHOD(&feature, column, "isnumeric");
		if (PHALCON_IS_TRUE(feature)) {
			phalcon_array_update_zval_bool(&numeric_typed, field_name, 1, PH_SEPARATE);
		}
	
		PHALCON_CALL_METHOD(&feature, column, "isnotnull");
		if (PHALCON_IS_TRUE(feature)) {
			phalcon_array_append(&not_null, field_name, PH_SEPARATE);
		}
	
		PHALCON_CALL_METHOD(&feature, column, "isautoincrement");
		if (PHALCON_IS_TRUE(feature)) {
			PHALCON_CPY_WRT(identity_field, field_name);
		}
	
		PHALCON_CALL_METHOD(&type, column, "gettype");
		phalcon_array_update_zval(&field_types, field_name, type, PH_COPY);
	
		PHALCON_CALL_METHOD(&bind_type, column, "getbindtype");
		phalcon_array_update_zval(&field_bind_types, field_name, bind_type, PH_COPY);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	array_init_size(return_value, 10);
	phalcon_array_update_long(&return_value, 0,  attributes, PH_COPY);
	phalcon_array_update_long(&return_value, 1,  primary_keys, PH_COPY);
	phalcon_array_update_long(&return_value, 2,  non_primary_keys, PH_COPY);
	phalcon_array_update_long(&return_value, 3,  not_null, PH_COPY);
	phalcon_array_update_long(&return_value, 4,  field_types, PH_COPY);
	phalcon_array_update_long(&return_value, 5,  numeric_typed, PH_COPY);
	phalcon_array_update_long(&return_value, 8,  identity_field, PH_COPY);
	phalcon_array_update_long(&return_value, 9,  field_bind_types, PH_COPY);
	phalcon_array_update_long(&return_value, 10, automatic_default, PH_COPY);
	phalcon_array_update_long(&return_value, 11, automatic_default, PH_COPY);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_MetaData_Strategy_Introspection, getColumnMaps){

	zval *model, *dependency_injector, *ordered_column_map = NULL;
	zval *reversed_column_map = NULL, *user_column_map = NULL;
	zval *user_name = NULL, *name = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &model, &dependency_injector);
	
	PHALCON_INIT_VAR(ordered_column_map);
	
	PHALCON_INIT_VAR(reversed_column_map);
	
	if (phalcon_method_quick_exists_ex(model, SS("columnmap"), 673371633UL TSRMLS_CC) == SUCCESS) {
	
		PHALCON_CALL_METHOD(&user_column_map, model, "columnmap");
		if (Z_TYPE_P(user_column_map) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "columnMap() not returned an array");
			return;
		}
	
		array_init(reversed_column_map);
		PHALCON_CPY_WRT(ordered_column_map, user_column_map);
	
		phalcon_is_iterable(user_column_map, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(name, ah0, hp0);
			PHALCON_GET_HVALUE(user_name);
	
			phalcon_array_update_zval(&reversed_column_map, user_name, name, PH_COPY);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	array_init_size(return_value, 2);
	phalcon_array_update_long(&return_value, 0, ordered_column_map, PH_COPY);
	phalcon_array_update_long(&return_value, 1, reversed_column_map, PH_COPY);
	
	PHALCON_MM_RESTORE();
}






zend_class_entry *phalcon_mvc_model_query_builder_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, distinct);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getDistinct);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, columns);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getColumns);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, from);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, addFrom);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getFrom);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, join);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, innerJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, leftJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, rightJoin);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, where);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, andWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, orWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, betweenWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, notBetweenWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, inWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, notInWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getWhere);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, orderBy);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getOrderBy);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, having);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getHaving);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, limit);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getLimit);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, offset);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getOffset);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, groupBy);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getGroupBy);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getPhql);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getQuery);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_builder___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_builder_offset, 0, 0, 1)
	ZEND_ARG_INFO(0, offset)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_query_builder_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, __construct, arginfo_phalcon_mvc_model_query_builder___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, distinct, arginfo_phalcon_mvc_model_query_builderinterface_distinct, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getDistinct, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, columns, arginfo_phalcon_mvc_model_query_builderinterface_columns, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getColumns, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, from, arginfo_phalcon_mvc_model_query_builderinterface_from, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, addFrom, arginfo_phalcon_mvc_model_query_builderinterface_addfrom, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getFrom, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, join, arginfo_phalcon_mvc_model_query_builderinterface_join, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, innerJoin, arginfo_phalcon_mvc_model_query_builderinterface_innerjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, leftJoin, arginfo_phalcon_mvc_model_query_builderinterface_leftjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, rightJoin, arginfo_phalcon_mvc_model_query_builderinterface_rightjoin, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, where, arginfo_phalcon_mvc_model_query_builderinterface_where, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, andWhere, arginfo_phalcon_mvc_model_query_builderinterface_andwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, orWhere, arginfo_phalcon_mvc_model_query_builderinterface_orwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, betweenWhere, arginfo_phalcon_mvc_model_query_builderinterface_betweenwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, notBetweenWhere, arginfo_phalcon_mvc_model_query_builderinterface_notbetweenwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, inWhere, arginfo_phalcon_mvc_model_query_builderinterface_inwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, notInWhere, arginfo_phalcon_mvc_model_query_builderinterface_notinwhere, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getWhere, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, orderBy, arginfo_phalcon_mvc_model_query_builderinterface_orderby, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getOrderBy, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, having, arginfo_phalcon_mvc_model_query_builderinterface_having, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getHaving, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, limit, arginfo_phalcon_mvc_model_query_builderinterface_limit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getLimit, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, offset, arginfo_phalcon_mvc_model_query_builder_offset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getOffset, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, groupBy, arginfo_phalcon_mvc_model_query_builderinterface_groupby, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getGroupBy, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getPhql, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Builder, getQuery, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Builder){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Query, Builder, mvc_model_query_builder, phalcon_mvc_model_query_builder_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_columns"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_models"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_joins"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_conditions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_group"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_having"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_order"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_limit"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_offset"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_forUpdate"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_sharedLock"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_bindParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_bindTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_builder_ce, SL("_distinct"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_query_builder_ce, SL("_hiddenParamNumber"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_query_builder_ce TSRMLS_CC, 2, phalcon_mvc_model_query_builderinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, __construct){

	zval *params = NULL, *dependency_injector = NULL, *conditions = NULL;
	zval *models, *columns, *group_clause, *joins;
	zval *having_clause, *order_clause, *limit_clause;
	zval *offset_clause, *for_update, *shared_lock;
	zval *limit, *offset, *single_condition_array;
	zval *condition_string = NULL, *bind_params, *bind_types;	
	zval *merged_conditions, *merged_bind_params, *merged_bind_types;
	zval *new_condition_string;	
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(0, 0, 2, &params, &dependency_injector);
	
	if (params && Z_TYPE_P(params) == IS_ARRAY) {
		if (phalcon_array_isset_long_fetch(&conditions, params, 0)) {
			phalcon_update_property_this_quick(this_ptr, SL("_conditions"), conditions, 3598010654UL TSRMLS_CC);
		} else if (phalcon_array_isset_string_fetch(&conditions, params, SS("conditions"))) {
			if (Z_TYPE_P(conditions) == IS_ARRAY) {

				/* ----------- INITIALIZING LOOP VARIABLES ----------- */

				PHALCON_INIT_VAR(single_condition_array);
				array_init(single_condition_array);

				/* ----------- INITIALIZING MERGED VARIABLES ----------- */

				PHALCON_INIT_VAR(merged_conditions);
				array_init(merged_conditions);

				PHALCON_INIT_VAR(merged_bind_params);
				array_init(merged_bind_params);

				PHALCON_INIT_VAR(merged_bind_types);
				array_init(merged_bind_types);			
				
				phalcon_is_iterable(conditions, &ah0, &hp0, 0, 0);
				
				while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
					PHALCON_GET_HVALUE(single_condition_array);
					
					if (Z_TYPE_P(single_condition_array) == IS_ARRAY
						&& phalcon_array_isset_long_fetch(&condition_string, single_condition_array, 0)
						&& phalcon_array_isset_long_fetch(&bind_params, single_condition_array, 1)
						&& Z_TYPE_P(condition_string) == IS_STRING
						&& Z_TYPE_P(bind_params) == IS_ARRAY
					) {	
						phalcon_array_append(&merged_conditions, condition_string, PH_COPY | PH_SEPARATE);

						phalcon_array_merge_recursive_n(&merged_bind_params, bind_params);

						if (phalcon_array_isset_long_fetch(&bind_types, single_condition_array, 2) && Z_TYPE_P(bind_types) == IS_ARRAY) {
							phalcon_array_merge_recursive_n(&merged_bind_types, bind_types);
						}
					}
					
					zend_hash_move_forward_ex(ah0, &hp0);
				}
				
				PHALCON_INIT_VAR(new_condition_string);
				phalcon_fast_join_str(new_condition_string, SL(" AND "), merged_conditions TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_conditions"), new_condition_string, 3598010654UL TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), merged_bind_params, 2293392709UL TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), merged_bind_types, 514734038UL TSRMLS_CC);
			} else {
				phalcon_update_property_this_quick(this_ptr, SL("_conditions"), conditions, 3598010654UL TSRMLS_CC);		
			}	
		}

		if (phalcon_array_isset_string_fetch(&models, params, SS("models"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&columns, params, SS("columns"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_columns"), columns, 4004520869UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&joins, params, SS("joins"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_joins"), joins, 2482180647UL TSRMLS_CC);
		}
	
		if (phalcon_array_isset_string_fetch(&group_clause, params, SS("group"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_group"), group_clause, 2368555377UL TSRMLS_CC);
		}
	
		if (phalcon_array_isset_string_fetch(&having_clause, params, SS("having"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_having"), having_clause, 1486953825UL TSRMLS_CC);
		}
	
		if (phalcon_array_isset_string_fetch(&order_clause, params, SS("order"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_order"), order_clause, 2681225856UL TSRMLS_CC);
		}
	
		if (phalcon_array_isset_string_fetch(&limit_clause, params, SS("limit"))) {
			if (Z_TYPE_P(limit_clause) == IS_ARRAY
				&& phalcon_array_isset_long_fetch(&limit, limit_clause, 0)
				&& phalcon_array_isset_long_fetch(&offset, limit_clause, 1)
			) {
				phalcon_update_property_this_quick(this_ptr, SL("_limit"), limit, 2553474243UL TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_offset"), offset, 2114347243UL TSRMLS_CC);
			} else {
				phalcon_update_property_this_quick(this_ptr, SL("_limit"), limit_clause, 2553474243UL TSRMLS_CC);
			}
		}
		
		if (phalcon_array_isset_string_fetch(&offset_clause, params, SS("offset"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_offset"), offset_clause, 2114347243UL TSRMLS_CC);
		}

		if (phalcon_array_isset_string_fetch(&for_update, params, SS("for_update"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_forUpdate"), for_update, 1475172846UL TSRMLS_CC);
		}
	
		if (phalcon_array_isset_string_fetch(&shared_lock, params, SS("shared_lock"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_sharedLock"), shared_lock, 3052804356UL TSRMLS_CC);
		}
	}

	if (dependency_injector && Z_TYPE_P(dependency_injector) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();	
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, distinct){

	zval **distinct;

	phalcon_fetch_params_ex(1, 0, &distinct);

	if (Z_TYPE_PP(distinct) != IS_NULL && Z_TYPE_PP(distinct) != IS_BOOL) {
		PHALCON_ENSURE_IS_BOOL(distinct);
	}

	phalcon_update_property_this(this_ptr, SL("_distinct"), *distinct TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getDistinct){


	RETURN_MEMBER_QUICK(this_ptr, "_distinct", 3353343366UL);
}


static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, columns){

	zval *columns;

	phalcon_fetch_params(0, 1, 0, &columns);
	
	phalcon_update_property_this_quick(this_ptr, SL("_columns"), columns, 4004520869UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getColumns){


	RETURN_MEMBER_QUICK(this_ptr, "_columns", 4004520869UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, from){

	zval *models;

	phalcon_fetch_params(0, 1, 0, &models);
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, addFrom){

	zval *model, *alias = NULL, *models = NULL, *current_model = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &model, &alias);
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(models);
	phalcon_read_property_this(&models, this_ptr, SL("_models"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(models) != IS_ARRAY) { 
		if (Z_TYPE_P(models) != IS_NULL) {
			PHALCON_CPY_WRT(current_model, models);
	
			PHALCON_INIT_NVAR(models);
			array_init(models);
			phalcon_array_append(&models, current_model, 0);
		} else {
			PHALCON_INIT_NVAR(models);
			array_init(models);
		}
	}
	else {
		SEPARATE_ZVAL(&models);
	}
	
	if (Z_TYPE_P(alias) == IS_STRING) {
		phalcon_array_update_zval(&models, alias, model, PH_COPY | 0);
	} else {
		phalcon_array_append(&models, model, 0);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_models"), models, 4175729768UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getFrom){


	RETURN_MEMBER_QUICK(this_ptr, "_models", 4175729768UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, join){

	zval *model, *conditions = NULL, *alias = NULL, *type = NULL, *join;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 3, &model, &conditions, &alias, &type);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(join);
	array_init_size(join, 4);
	phalcon_array_append(&join, model, 0);
	phalcon_array_append(&join, conditions, 0);
	phalcon_array_append(&join, alias, 0);
	phalcon_array_append(&join, type, 0);
	phalcon_update_property_array_append(this_ptr, SL("_joins"), join TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, innerJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *join;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "INNER", 1);
	
	PHALCON_INIT_VAR(join);
	array_init_size(join, 4);
	phalcon_array_append(&join, model, 0);
	phalcon_array_append(&join, conditions, 0);
	phalcon_array_append(&join, alias, 0);
	phalcon_array_append(&join, type, 0);
	phalcon_update_property_array_append(this_ptr, SL("_joins"), join TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, leftJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *join;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "LEFT", 1);
	
	PHALCON_INIT_VAR(join);
	array_init_size(join, 4);
	phalcon_array_append(&join, model, PH_SEPARATE);
	phalcon_array_append(&join, conditions, PH_SEPARATE);
	phalcon_array_append(&join, alias, PH_SEPARATE);
	phalcon_array_append(&join, type, PH_SEPARATE);
	phalcon_update_property_array_append(this_ptr, SL("_joins"), join TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, rightJoin){

	zval *model, *conditions = NULL, *alias = NULL, *type, *join;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &model, &conditions, &alias);
	
	if (!conditions) {
		conditions = PHALCON_GLOBAL(z_null);
	}
	
	if (!alias) {
		alias = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_INIT_VAR(type);
	ZVAL_STRING(type, "RIGHT", 1);
	
	PHALCON_INIT_VAR(join);
	array_init_size(join, 4);
	phalcon_array_append(&join, model, 0);
	phalcon_array_append(&join, conditions, 0);
	phalcon_array_append(&join, alias, 0);
	phalcon_array_append(&join, type, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_joins"), join, 2482180647UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, where){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_conditions"), conditions, 3598010654UL TSRMLS_CC);
	
	phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), bind_params, 2293392709UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), bind_types, 514734038UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, andWhere){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;
	zval *current_conditions, *new_conditions = NULL;
	zval *current_bind_params, *merged_params = NULL;
	zval *current_bind_types, *merged_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(current_conditions);
	phalcon_read_property_this(&current_conditions, this_ptr, SL("_conditions"), PH_NOISY TSRMLS_CC);
	
	if (zend_is_true(current_conditions)) {
		PHALCON_INIT_VAR(new_conditions);
		PHALCON_CONCAT_SVSVS(new_conditions, "(", current_conditions, ") AND (", conditions, ")");
	} else {
		PHALCON_CPY_WRT(new_conditions, conditions);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_conditions"), new_conditions, 3598010654UL TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(current_bind_params);
		phalcon_read_property_this(&current_bind_params, this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_bind_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_add_function(merged_params, bind_params, current_bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, bind_params);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), merged_params, 2293392709UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(current_bind_types);
		phalcon_read_property_this(&current_bind_types, this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_bind_types) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_types);
			phalcon_add_function(merged_params, bind_types, current_bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_types, bind_types);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), merged_types, 514734038UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, orWhere){

	zval *conditions, *bind_params = NULL, *bind_types = NULL;
	zval *current_conditions, *new_conditions = NULL;
	zval *current_bind_params, *merged_params = NULL;
	zval *current_bind_types, *merged_types = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &conditions, &bind_params, &bind_types);
	
	if (!bind_params) {
		bind_params = PHALCON_GLOBAL(z_null);
	}
	
	if (!bind_types) {
		bind_types = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_OBS_VAR(current_conditions);
	phalcon_read_property_this(&current_conditions, this_ptr, SL("_conditions"), PH_NOISY TSRMLS_CC);
	
	if (zend_is_true(current_conditions)) {
		PHALCON_INIT_VAR(new_conditions);
		PHALCON_CONCAT_SVSVS(new_conditions, "(", current_conditions, ") OR (", conditions, ")");
	} else {
		PHALCON_CPY_WRT(new_conditions, conditions);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_conditions"), new_conditions, 3598010654UL TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(current_bind_params);
		phalcon_read_property_this(&current_bind_params, this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_bind_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_add_function(merged_params, bind_params, current_bind_params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, bind_params);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_bindParams"), merged_params, 2293392709UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(current_bind_types);
		phalcon_read_property_this(&current_bind_types, this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(current_bind_types) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_types);
			phalcon_add_function(merged_types, bind_types, current_bind_types TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_types, bind_types);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_bindTypes"), merged_types, 514734038UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, betweenWhere){

	zval *expr, *minimum, *maximum, *hidden_param, *z_one;
	zval *next_hidden_param, *minimum_key, *maximum_key;
	zval *conditions, *bind_params;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &expr, &minimum, &maximum);
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	
	z_one = PHALCON_GLOBAL(z_one);
	
	PHALCON_INIT_VAR(next_hidden_param);
	phalcon_add_function(next_hidden_param, hidden_param, z_one TSRMLS_CC);
	
	PHALCON_INIT_VAR(minimum_key);
	PHALCON_CONCAT_SV(minimum_key, "phb", hidden_param);
	
	PHALCON_INIT_VAR(maximum_key);
	PHALCON_CONCAT_SV(maximum_key, "phb", next_hidden_param);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVSVS(conditions, expr, " BETWEEN :", minimum_key, ": AND :", maximum_key, ":");
	
	PHALCON_INIT_VAR(bind_params);
	array_init_size(bind_params, 2);
	phalcon_array_update_zval(&bind_params, minimum_key, minimum, PH_COPY);
	phalcon_array_update_zval(&bind_params, maximum_key, maximum, PH_COPY);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);

	phalcon_increment(next_hidden_param);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), next_hidden_param, 3119958698UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, notBetweenWhere){

	zval *expr, *minimum, *maximum, *hidden_param, *z_one;
	zval *next_hidden_param, *minimum_key, *maximum_key;
	zval *conditions, *bind_params;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &expr, &minimum, &maximum);
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	
	z_one = PHALCON_GLOBAL(z_one);
	
	PHALCON_INIT_VAR(next_hidden_param);
	phalcon_add_function(next_hidden_param, hidden_param, z_one TSRMLS_CC);
	
	PHALCON_INIT_VAR(minimum_key);
	PHALCON_CONCAT_SV(minimum_key, "phb", hidden_param);
	
	PHALCON_INIT_VAR(maximum_key);
	PHALCON_CONCAT_SV(maximum_key, "phb", next_hidden_param);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVSVS(conditions, expr, " NOT BETWEEN :", minimum_key, ": AND :", maximum_key, ":");
	
	PHALCON_INIT_VAR(bind_params);
	array_init_size(bind_params, 2);
	phalcon_array_update_zval(&bind_params, minimum_key, minimum, PH_COPY);
	phalcon_array_update_zval(&bind_params, maximum_key, maximum, PH_COPY);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);

	phalcon_increment(next_hidden_param);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), next_hidden_param, 3119958698UL TSRMLS_CC);
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, inWhere){

	zval *expr, *values, *hidden_param, *bind_params;
	zval *bind_keys, *value = NULL, *key = NULL, *query_key = NULL, *joined_keys;
	zval *conditions;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &expr, &values);
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Values must be an array");
		return;
	}
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	SEPARATE_ZVAL(&hidden_param);
	
	PHALCON_INIT_VAR(bind_params);
	array_init(bind_params);
	
	PHALCON_INIT_VAR(bind_keys);
	array_init(bind_keys);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(value);
	
		PHALCON_INIT_NVAR(key);
		PHALCON_CONCAT_SV(key, "phi", hidden_param);
	
		PHALCON_INIT_NVAR(query_key);
		PHALCON_CONCAT_SVS(query_key, ":", key, ":");
		phalcon_array_append(&bind_keys, query_key, 0);
		phalcon_array_update_zval(&bind_params, key, value, PH_COPY);
		phalcon_increment(hidden_param);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(joined_keys);
	phalcon_fast_join_str(joined_keys, SL(", "), bind_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVS(conditions, expr, " IN (", joined_keys, ")");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), hidden_param, 3119958698UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, notInWhere){

	zval *expr, *values, *hidden_param, *bind_params;
	zval *bind_keys, *value = NULL, *key = NULL, *query_key = NULL, *joined_keys;
	zval *conditions;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &expr, &values);
	
	if (Z_TYPE_P(values) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Values must be an array");
		return;
	}
	
	PHALCON_OBS_VAR(hidden_param);
	phalcon_read_property_this(&hidden_param, this_ptr, SL("_hiddenParamNumber"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(bind_params);
	array_init(bind_params);
	
	PHALCON_INIT_VAR(bind_keys);
	array_init(bind_keys);
	
	phalcon_is_iterable(values, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(value);
	
		PHALCON_INIT_NVAR(key);
		PHALCON_CONCAT_SV(key, "phi", hidden_param);
	
		PHALCON_INIT_NVAR(query_key);
		PHALCON_CONCAT_SVS(query_key, ":", key, ":");
		phalcon_array_append(&bind_keys, query_key, 0);
		phalcon_array_update_zval(&bind_params, key, value, PH_COPY);
		phalcon_increment(hidden_param);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	PHALCON_INIT_VAR(joined_keys);
	phalcon_fast_join_str(joined_keys, SL(", "), bind_keys TSRMLS_CC);
	
	PHALCON_INIT_VAR(conditions);
	PHALCON_CONCAT_VSVS(conditions, expr, " NOT IN (", joined_keys, ")");
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "andwhere", conditions, bind_params);
	phalcon_update_property_this_quick(this_ptr, SL("_hiddenParamNumber"), hidden_param, 3119958698UL TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getWhere){


	RETURN_MEMBER_QUICK(this_ptr, "_conditions", 3598010654UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, orderBy){

	zval *order_by;

	phalcon_fetch_params(0, 1, 0, &order_by);
	
	phalcon_update_property_this_quick(this_ptr, SL("_order"), order_by, 2681225856UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getOrderBy){


	RETURN_MEMBER_QUICK(this_ptr, "_order", 2681225856UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, having){

	zval *having;

	phalcon_fetch_params(0, 1, 0, &having);
	
	phalcon_update_property_this_quick(this_ptr, SL("_having"), having, 1486953825UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getHaving){


	RETURN_MEMBER_QUICK(this_ptr, "_having", 1486953825UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, limit){

	zval *limit, *offset = NULL;

	phalcon_fetch_params(0, 1, 1, &limit, &offset);
	
	phalcon_update_property_this_quick(this_ptr, SL("_limit"), limit, 2553474243UL TSRMLS_CC);

	if (offset) {
		phalcon_update_property_this_quick(this_ptr, SL("_offset"), offset, 2114347243UL TSRMLS_CC);
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getLimit){


	RETURN_MEMBER_QUICK(this_ptr, "_limit", 2553474243UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, offset){

	zval *offset;

	phalcon_fetch_params(0, 1, 0, &offset);
	
	phalcon_update_property_this_quick(this_ptr, SL("_offset"), offset, 2114347243UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getOffset){


	RETURN_MEMBER_QUICK(this_ptr, "_offset", 2114347243UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, groupBy){

	zval *group;

	phalcon_fetch_params(0, 1, 0, &group);
	
	phalcon_update_property_this_quick(this_ptr, SL("_group"), group, 2368555377UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getGroupBy){


	RETURN_MEMBER_QUICK(this_ptr, "_group", 2368555377UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getPhql){

	zval *dependency_injector = NULL, *models, *conditions = NULL, *distinct;
	zval *z_one, *number_models, *invalid_condition;
	zval *model = NULL, *service_name, *meta_data = NULL, *model_instance;
	zval *no_primary = NULL, *primary_keys = NULL, *first_primary_key;
	zval *column_map = NULL, *attribute_field = NULL, *exception_message;
	zval *primary_key_condition, *phql, *columns;
	zval *selected_columns = NULL, *column = NULL, *column_alias = NULL;
	zval *aliased_column = NULL, *joined_columns = NULL, *model_column_alias = NULL;
	zval *selected_column = NULL, *selected_models, *model_alias = NULL;
	zval *selected_model = NULL, *joined_models, *joins;
	zval *join = NULL, *join_model = NULL, *join_conditions = NULL, *join_alias = NULL;
	zval *join_type = NULL, *group, *group_items, *group_item = NULL;
	zval *escaped_item = NULL, *joined_items = NULL, *having, *order;
	zval *order_items, *order_item = NULL, *limit, *number, *for_update;
	HashTable *ah0, *ah1, *ah2, *ah3, *ah4, *ah5;
	HashPosition hp0, hp1, hp2, hp3, hp4, hp5;
	zval **hd;
	zend_class_entry *ce0;

	PHALCON_MM_GROW();

	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		dependency_injector = NULL;
		PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
		phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	}
	
	models = phalcon_fetch_nproperty_this(this_ptr, SL("_models"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(models) == IS_ARRAY) { 
		if (!phalcon_fast_count_ev(models TSRMLS_CC)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "At least one model is required to build the query");
			return;
		}
	} else if (!zend_is_true(models)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "At least one model is required to build the query");
		return;
	}
	
	PHALCON_OBS_VAR(conditions);
	phalcon_read_property_this(&conditions, this_ptr, SL("_conditions"), PH_NOISY TSRMLS_CC);
	if (phalcon_is_numeric(conditions)) {
	
		if (Z_TYPE_P(models) == IS_ARRAY) { 
	
			z_one = PHALCON_GLOBAL(z_one);
	
			PHALCON_INIT_VAR(number_models);
			phalcon_fast_count(number_models, models TSRMLS_CC);
	
			PHALCON_INIT_VAR(invalid_condition);
			is_smaller_function(invalid_condition, z_one, number_models TSRMLS_CC);
			if (PHALCON_IS_TRUE(invalid_condition)) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Cannot build the query. Invalid condition");
				return;
			}
	
			PHALCON_OBS_VAR(model);
			phalcon_array_fetch_long(&model, models, 0, PH_NOISY);
		} else {
			PHALCON_CPY_WRT(model, models);
		}
	
		PHALCON_INIT_VAR(service_name);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service_name, phalcon_interned_modelsMetadata);
	
		PHALCON_CALL_METHOD(&meta_data, dependency_injector, "getshared", service_name);
		PHALCON_VERIFY_INTERFACE(meta_data, phalcon_mvc_model_metadatainterface_ce);
		ce0 = phalcon_fetch_class(model TSRMLS_CC);
	
		PHALCON_INIT_VAR(model_instance);
		object_init_ex(model_instance, ce0);
		if (phalcon_has_constructor(model_instance TSRMLS_CC)) {
			PHALCON_CALL_METHOD(NULL, model_instance, "__construct", dependency_injector);
		}
	
		PHALCON_INIT_VAR(no_primary);
		ZVAL_TRUE(no_primary);
	
		PHALCON_CALL_METHOD(&primary_keys, meta_data, "getprimarykeyattributes", model_instance);
		if (phalcon_fast_count_ev(primary_keys TSRMLS_CC)) {
			if (phalcon_array_isset_long(primary_keys, 0)) {
	
				PHALCON_OBS_VAR(first_primary_key);
				phalcon_array_fetch_long(&first_primary_key, primary_keys, 0, PH_NOISY);
	
				if (PHALCON_GLOBAL(orm).column_renaming) {
					PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", model_instance);
				} else {
					PHALCON_INIT_VAR(column_map);
				}
	
				if (Z_TYPE_P(column_map) == IS_ARRAY) { 
					if (phalcon_array_isset(column_map, first_primary_key)) {
						PHALCON_OBS_VAR(attribute_field);
						phalcon_array_fetch(&attribute_field, column_map, first_primary_key, PH_NOISY);
					} else {
						PHALCON_INIT_VAR(exception_message);
						PHALCON_CONCAT_SVS(exception_message, "Column '", first_primary_key, "\" isn't part of the column map");
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
				} else {
					PHALCON_CPY_WRT(attribute_field, first_primary_key);
				}
	
				PHALCON_INIT_VAR(primary_key_condition);
				PHALCON_CONCAT_SVSVSV(primary_key_condition, "[", model, "].[", attribute_field, "] = ", conditions);
				PHALCON_CPY_WRT(conditions, primary_key_condition);
	
				ZVAL_FALSE(no_primary);
			}
		}
	
		if (PHALCON_IS_TRUE(no_primary)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Source related to this model does not have a primary key defined");
			return;
		}
	}
	
	PHALCON_INIT_VAR(phql);

	distinct = phalcon_fetch_nproperty_this(this_ptr, SL("_distinct"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(distinct) == IS_BOOL) {
		if (Z_BVAL_P(distinct)) {
			ZVAL_STRING(phql, "SELECT DISTINCT ", 1);
		}
		else {
			ZVAL_STRING(phql, "SELECT ALL ", 1);
		}
	}
	else {
		ZVAL_STRING(phql, "SELECT ", 1);
	}
	
	PHALCON_OBS_VAR(columns);
	phalcon_read_property_this(&columns, this_ptr, SL("_columns"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(columns) != IS_NULL) {
	
		if (Z_TYPE_P(columns) == IS_ARRAY) { 
	
			PHALCON_INIT_VAR(selected_columns);
			array_init(selected_columns);
	
			phalcon_is_iterable(columns, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(column_alias, ah0, hp0);
				PHALCON_GET_HVALUE(column);
	
				if (Z_TYPE_P(column_alias) == IS_LONG) {
					phalcon_array_append(&selected_columns, column, PH_SEPARATE);
				} else {
					PHALCON_INIT_NVAR(aliased_column);
					PHALCON_CONCAT_VSV(aliased_column, column, " AS ", column_alias);
					phalcon_array_append(&selected_columns, aliased_column, PH_SEPARATE);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			PHALCON_INIT_VAR(joined_columns);
			phalcon_fast_join_str(joined_columns, SL(", "), selected_columns TSRMLS_CC);
			phalcon_concat_self(&phql, joined_columns TSRMLS_CC);
		} else {
			phalcon_concat_self(&phql, columns TSRMLS_CC);
		}
	} else {
		if (Z_TYPE_P(models) == IS_ARRAY) { 
	
			PHALCON_INIT_NVAR(selected_columns);
			array_init(selected_columns);
	
			phalcon_is_iterable(models, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HKEY(model_column_alias, ah1, hp1);
				PHALCON_GET_HVALUE(model);
	
				if (Z_TYPE_P(model_column_alias) == IS_LONG) {
					PHALCON_INIT_NVAR(selected_column);
					PHALCON_CONCAT_SVS(selected_column, "[", model, "].*");
				} else {
					PHALCON_INIT_NVAR(selected_column);
					PHALCON_CONCAT_SVS(selected_column, "[", model_column_alias, "].*");
				}
				phalcon_array_append(&selected_columns, selected_column, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
			PHALCON_INIT_NVAR(joined_columns);
			phalcon_fast_join_str(joined_columns, SL(", "), selected_columns TSRMLS_CC);
			phalcon_concat_self(&phql, joined_columns TSRMLS_CC);
		} else {
			PHALCON_SCONCAT_SVS(phql, "[", models, "].*");
		}
	}
	
	if (Z_TYPE_P(models) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(selected_models);
		array_init(selected_models);
	
		phalcon_is_iterable(models, &ah2, &hp2, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
			PHALCON_GET_HKEY(model_alias, ah2, hp2);
			PHALCON_GET_HVALUE(model);
	
			if (Z_TYPE_P(model_alias) == IS_STRING) {
				PHALCON_INIT_NVAR(selected_model);
				PHALCON_CONCAT_SVSVS(selected_model, "[", model, "] AS [", model_alias, "]");
			} else {
				PHALCON_INIT_NVAR(selected_model);
				PHALCON_CONCAT_SVS(selected_model, "[", model, "]");
			}
			phalcon_array_append(&selected_models, selected_model, PH_SEPARATE);
	
			zend_hash_move_forward_ex(ah2, &hp2);
		}
	
		PHALCON_INIT_VAR(joined_models);
		phalcon_fast_join_str(joined_models, SL(", "), selected_models TSRMLS_CC);
		PHALCON_SCONCAT_SV(phql, " FROM ", joined_models);
	} else {
		PHALCON_SCONCAT_SVS(phql, " FROM [", models, "]");
	}
	
	PHALCON_OBS_VAR(joins);
	phalcon_read_property_this(&joins, this_ptr, SL("_joins"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(joins) == IS_ARRAY) { 
	
		phalcon_is_iterable(joins, &ah3, &hp3, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
			PHALCON_GET_HVALUE(join);
	
			PHALCON_OBS_NVAR(join_model);
			phalcon_array_fetch_long(&join_model, join, 0, PH_NOISY);
	
			PHALCON_OBS_NVAR(join_conditions);
			phalcon_array_fetch_long(&join_conditions, join, 1, PH_NOISY);
	
			PHALCON_OBS_NVAR(join_alias);
			phalcon_array_fetch_long(&join_alias, join, 2, PH_NOISY);
	
			PHALCON_OBS_NVAR(join_type);
			phalcon_array_fetch_long(&join_type, join, 3, PH_NOISY);
	
			if (zend_is_true(join_type)) {
				PHALCON_SCONCAT_SVSVS(phql, " ", join_type, " JOIN [", join_model, "]");
			} else {
				PHALCON_SCONCAT_SVS(phql, " JOIN [", join_model, "]");
			}
	
			if (zend_is_true(join_alias)) {
				PHALCON_SCONCAT_SVS(phql, " AS [", join_alias, "]");
			}
	
			if (zend_is_true(join_conditions)) {
				PHALCON_SCONCAT_SV(phql, " ON ", join_conditions);
			}
	
			zend_hash_move_forward_ex(ah3, &hp3);
		}
	
	}
	
	if (Z_TYPE_P(conditions) == IS_STRING) {
		if (PHALCON_IS_NOT_EMPTY(conditions)) {
			PHALCON_SCONCAT_SV(phql, " WHERE ", conditions);
		}
	}
	
	PHALCON_OBS_VAR(group);
	phalcon_read_property_this(&group, this_ptr, SL("_group"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(group) != IS_NULL) {
		if (Z_TYPE_P(group) == IS_ARRAY) { 
	
			PHALCON_INIT_VAR(group_items);
			array_init(group_items);
	
			phalcon_is_iterable(group, &ah4, &hp4, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah4, (void**) &hd, &hp4) == SUCCESS) {
	
				PHALCON_GET_HVALUE(group_item);
	
				if (phalcon_is_numeric(group_item)) {
					phalcon_array_append(&group_items, group_item, PH_SEPARATE);
				} else {
					if (phalcon_memnstr_str(group_item, SL("."))) {
						phalcon_array_append(&group_items, group_item, PH_SEPARATE);
					} else {
						PHALCON_INIT_NVAR(escaped_item);
						PHALCON_CONCAT_SVS(escaped_item, "[", group_item, "]");
						phalcon_array_append(&group_items, escaped_item, PH_SEPARATE);
					}
				}
	
				zend_hash_move_forward_ex(ah4, &hp4);
			}
	
			PHALCON_INIT_VAR(joined_items);
			phalcon_fast_join_str(joined_items, SL(", "), group_items TSRMLS_CC);
			PHALCON_SCONCAT_SV(phql, " GROUP BY ", joined_items);
		} else {
			if (phalcon_is_numeric(group)) {
				PHALCON_SCONCAT_SV(phql, " GROUP BY ", group);
			} else {
				if (phalcon_memnstr_str(group, SL("."))) {
					PHALCON_SCONCAT_SV(phql, " GROUP BY ", group);
				} else if (phalcon_memnstr_str(group, SL(","))) {
					PHALCON_INIT_VAR(group_items);
					phalcon_fast_explode_str(group_items, SL(", "), group);

					PHALCON_INIT_VAR(joined_items);
					phalcon_fast_join_str(joined_items, SL("], ["), group_items TSRMLS_CC);

					PHALCON_SCONCAT_SVS(phql, " GROUP BY [", joined_items, "]");
				} else {
					PHALCON_SCONCAT_SVS(phql, " GROUP BY [", group, "]");
				}
			}
		}
	}
	
	/* Process HAVING clause */
	PHALCON_OBS_VAR(having);
	phalcon_read_property_this(&having, this_ptr, SL("_having"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(having) != IS_NULL) {
		if (PHALCON_IS_NOT_EMPTY(having)) {
			PHALCON_SCONCAT_SV(phql, " HAVING ", having);
		}
	}

	PHALCON_OBS_VAR(order);
	phalcon_read_property_this(&order, this_ptr, SL("_order"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_NOT_EMPTY(order)) {
		if (Z_TYPE_P(order) == IS_ARRAY) { 
	
			PHALCON_INIT_VAR(order_items);
			array_init(order_items);
	
			phalcon_is_iterable(order, &ah5, &hp5, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah5, (void**) &hd, &hp5) == SUCCESS) {
	
				PHALCON_GET_HVALUE(order_item);
	
				if (phalcon_is_numeric(order_item)) {
					phalcon_array_append(&order_items, order_item, PH_SEPARATE);
				} else {
					if (phalcon_memnstr_str(order_item, SL("."))) {
						phalcon_array_append(&order_items, order_item, PH_SEPARATE);
					} else {
						PHALCON_INIT_NVAR(escaped_item);
						PHALCON_CONCAT_SVS(escaped_item, "[", order_item, "]");
						phalcon_array_append(&order_items, escaped_item, PH_SEPARATE);
					}
				}
	
				zend_hash_move_forward_ex(ah5, &hp5);
			}
	
			PHALCON_INIT_NVAR(joined_items);
			phalcon_fast_join_str(joined_items, SL(", "), order_items TSRMLS_CC);
			PHALCON_SCONCAT_SV(phql, " ORDER BY ", joined_items);
		} else {
			PHALCON_SCONCAT_SV(phql, " ORDER BY ", order);
		}
	}
	
	limit = phalcon_fetch_nproperty_this(this_ptr, SL("_limit"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(limit) != IS_NULL) {
		if (Z_TYPE_P(limit) == IS_ARRAY) { 
			zval *offset;
	
			PHALCON_OBS_VAR(number);
			phalcon_array_fetch_quick_string(&number, limit, SS("number"), 807219790UL, PH_NOISY);
			if (phalcon_array_isset_string_fetch(&offset, limit, SS("offset")) && Z_TYPE_P(offset) != IS_NULL) {
				PHALCON_SCONCAT_SVSV(phql, " LIMIT ", number, " OFFSET ", offset);
			} else {
				PHALCON_SCONCAT_SV(phql, " LIMIT ", number);
			}
		} else {
			zval *offset;

			PHALCON_SCONCAT_SV(phql, " LIMIT ", limit);

			offset = phalcon_fetch_nproperty_this(this_ptr, SL("_offset"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(offset) != IS_NULL) {
				PHALCON_SCONCAT_SV(phql, " OFFSET ", offset);
			}
		}
	}
	
	for_update = phalcon_fetch_nproperty_this(this_ptr, SL("_forUpdate"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(for_update)) {
		phalcon_concat_self_str(&phql, SL(" FOR UPDATE") TSRMLS_CC);
	}
	
	RETURN_CTOR(phql);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Builder, getQuery){

	zval *phql = NULL, *dependency_injector, *bind_params;
	zval *bind_types;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&phql, this_ptr, "getphql");
	
	dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
	object_init_ex(return_value, phalcon_mvc_model_query_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", phql, dependency_injector);
	
	bind_params = phalcon_fetch_nproperty_this(this_ptr, SL("_bindParams"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(NULL, return_value, "setbindparams", bind_params);
	}
	
	bind_types = phalcon_fetch_nproperty_this(this_ptr, SL("_bindTypes"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(NULL, return_value, "setbindtypes", bind_types);
	}
	
	RETURN_MM();
}






zend_class_entry *phalcon_mvc_model_query_builderinterface_ce;

static const zend_function_entry phalcon_mvc_model_query_builderinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, distinct, arginfo_phalcon_mvc_model_query_builderinterface_distinct)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getDistinct, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, columns, arginfo_phalcon_mvc_model_query_builderinterface_columns)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getColumns, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, from, arginfo_phalcon_mvc_model_query_builderinterface_from)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, addFrom, arginfo_phalcon_mvc_model_query_builderinterface_addfrom)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getFrom, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, join, arginfo_phalcon_mvc_model_query_builderinterface_join)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, innerJoin, arginfo_phalcon_mvc_model_query_builderinterface_innerjoin)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, leftJoin, arginfo_phalcon_mvc_model_query_builderinterface_leftjoin)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, rightJoin, arginfo_phalcon_mvc_model_query_builderinterface_rightjoin)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, where, arginfo_phalcon_mvc_model_query_builderinterface_where)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, andWhere, arginfo_phalcon_mvc_model_query_builderinterface_andwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, orWhere, arginfo_phalcon_mvc_model_query_builderinterface_orwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, betweenWhere, arginfo_phalcon_mvc_model_query_builderinterface_betweenwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, notBetweenWhere, arginfo_phalcon_mvc_model_query_builderinterface_notbetweenwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, inWhere, arginfo_phalcon_mvc_model_query_builderinterface_inwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, notInWhere, arginfo_phalcon_mvc_model_query_builderinterface_notinwhere)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getWhere, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, orderBy, arginfo_phalcon_mvc_model_query_builderinterface_orderby)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getOrderBy, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, having, arginfo_phalcon_mvc_model_query_builderinterface_having)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getHaving, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, limit, arginfo_phalcon_mvc_model_query_builderinterface_limit)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getLimit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, groupBy, arginfo_phalcon_mvc_model_query_builderinterface_groupby)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getGroupBy, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getPhql, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_BuilderInterface, getQuery, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_BuilderInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model\\Query, BuilderInterface, mvc_model_query_builderinterface, phalcon_mvc_model_query_builderinterface_method_entry);

	return SUCCESS;
}

































zend_class_entry *phalcon_mvc_model_query_lang_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Query_Lang, parsePHQL);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_lang_parsephql, 0, 0, 1)
	ZEND_ARG_INFO(0, phql)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_query_lang_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Query_Lang, parsePHQL, arginfo_phalcon_mvc_model_query_lang_parsephql, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Lang){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Query, Lang, mvc_model_query_lang, phalcon_mvc_model_query_lang_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Lang, parsePHQL){

	zval *phql;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &phql);
	
	if (Z_TYPE_P(phql) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "PHQL statement must be string");
		return;
	}
	if (phql_parse_phql(return_value, phql TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	RETURN_MM();
}



/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is include which follows the "include" declaration
** in the input file. */
#include <stdio.h>
/* #line 39 "parser.y" */






static zval *phql_ret_literal_zval(int type, phql_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, phalcon_interned_type, type);
	if (T) {
		add_assoc_stringl(ret, phalcon_interned_value, T->token, T->token_len, 0);
		efree(T);
	}

	return ret;
}

static zval *phql_ret_placeholder_zval(int type, phql_parser_token *T)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_long(ret, phalcon_interned_type, type);
	add_assoc_stringl(ret, phalcon_interned_value, T->token, T->token_len, 0);
	efree(T);

	return ret;
}

static zval *phql_ret_qualified_name(phql_parser_token *A, phql_parser_token *B, phql_parser_token *C)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_QUALIFIED);

	if (A != NULL) {
		add_assoc_stringl(ret, phalcon_interned_ns_alias, A->token, A->token_len, 0);
		efree(A);
	}

	if (B != NULL) {
		add_assoc_stringl(ret, phalcon_interned_domain, B->token, B->token_len, 0);
		efree(B);
	}

	add_assoc_stringl(ret, phalcon_interned_name, C->token, C->token_len, 0);
	efree(C);

	return ret;
}

static zval *phql_ret_raw_qualified_name(phql_parser_token *A, phql_parser_token *B)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_RAW_QUALIFIED);
	if (B != NULL) {
		add_assoc_stringl(ret, phalcon_interned_domain, A->token, A->token_len, 0);
		add_assoc_stringl(ret, phalcon_interned_name, B->token, B->token_len, 0);
		efree(B);
	} else {
		add_assoc_stringl(ret, phalcon_interned_name, A->token, A->token_len, 0);
	}
	efree(A);

	return ret;
}

static zval *phql_ret_select_statement(zval *S, zval *W, zval *O, zval *G, zval *H, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_SELECT);
	add_assoc_zval(ret, phalcon_interned_select, S);

	if (W != NULL) {
		add_assoc_zval(ret, phalcon_interned_where, W);
	}
	if (O != NULL) {
		add_assoc_zval(ret, phalcon_interned_orderBy, O);
	}
	if (G != NULL) {
		add_assoc_zval(ret, phalcon_interned_groupBy, G);
	}
	if (H != NULL) {
		add_assoc_zval(ret, phalcon_interned_having, H);
	}
	if (L != NULL) {
		add_assoc_zval(ret, phalcon_interned_limit, L);
	}

	return ret;
}

static zval *phql_ret_select_clause(zval *distinct, zval *columns, zval *tables, zval *join_list)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	if (distinct) {
		add_assoc_zval(ret, phalcon_interned_distinct, distinct);
	}

	add_assoc_zval(ret, phalcon_interned_columns, columns);
	add_assoc_zval(ret, phalcon_interned_tables, tables);
	if (join_list) {
		add_assoc_zval(ret, phalcon_interned_joins, join_list);
	}

	return ret;
}

static zval *phql_ret_distinct_all(int distinct)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	ZVAL_LONG(ret, distinct);

	return ret;
}

static zval *phql_ret_distinct(void)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	ZVAL_TRUE(ret);

	return ret;
}

static zval *phql_ret_order_item(zval *column, int sort){

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, phalcon_interned_column, column);
	if (sort != 0 ) {
		add_assoc_long(ret, phalcon_interned_sort, sort);
	}

	return ret;
}

static zval *phql_ret_limit_clause(zval *L, zval *O)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);

	add_assoc_zval(ret, phalcon_interned_number, L);

	if (O != NULL) {
		add_assoc_zval(ret, phalcon_interned_offset, O);
	}

	return ret;
}

static zval *phql_ret_insert_statement(zval *Q, zval *F, zval *V)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_INSERT);
	add_assoc_zval(ret, phalcon_interned_qualifiedName, Q);
	if (F != NULL) {
		add_assoc_zval(ret, phalcon_interned_fields, F);
	}
	add_assoc_zval(ret, phalcon_interned_values, V);

	return ret;
}

static zval *phql_ret_update_statement(zval *U, zval *W, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_UPDATE);
	add_assoc_zval(ret, phalcon_interned_update, U);
	if (W != NULL) {
		add_assoc_zval(ret, phalcon_interned_where, W);
	}
	if (L != NULL) {
		add_assoc_zval(ret, phalcon_interned_limit, L);
	}

	return ret;
}

static zval *phql_ret_update_clause(zval *tables, zval *values)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_zval(ret, phalcon_interned_tables, tables);
	add_assoc_zval(ret, phalcon_interned_values, values);

	return ret;
}

static zval *phql_ret_update_item(zval *column, zval *expr)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_zval(ret, phalcon_interned_column, column);
	add_assoc_zval(ret, phalcon_interned_expr, expr);

	return ret;
}

static zval *phql_ret_delete_statement(zval *D, zval *W, zval *L)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, phalcon_interned_type, PHQL_T_DELETE);
	add_assoc_zval(ret, phalcon_interned_delete, D);
	if (W != NULL) {
		add_assoc_zval(ret, phalcon_interned_where, W);
	}
	if (L != NULL) {
		add_assoc_zval(ret, phalcon_interned_limit, L);
	}

	return ret;
}

static zval *phql_ret_delete_clause(zval *tables)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 1);
	add_assoc_zval(ret, phalcon_interned_tables, tables);

	return ret;
}

static zval *phql_ret_zval_list(zval *list_left, zval *right_list)
{
	zval *ret;
	HashTable *list;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	list = Z_ARRVAL_P(list_left);
	if (zend_hash_index_exists(list, 0)) {
		HashPosition pos;
		zval **item;

		for (
			zend_hash_internal_pointer_reset_ex(list, &pos);
			zend_hash_get_current_data_ex(list, (void**)&item, &pos) != FAILURE;
			zend_hash_move_forward_ex(list, &pos)
		) {
			Z_ADDREF_PP(item);
			add_next_index_zval(ret, *item);
		}

		zval_ptr_dtor(&list_left);
	} else {
		add_next_index_zval(ret, list_left);
	}

	if (right_list) {
		add_next_index_zval(ret, right_list);
	}

	return ret;
}

static zval *phql_ret_column_item(int type, zval *column, phql_parser_token *identifier_column, phql_parser_token *alias)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);
	add_assoc_long(ret, phalcon_interned_type, type);
	if (column) {
		add_assoc_zval(ret, phalcon_interned_column, column);
	}
	if (identifier_column) {
		add_assoc_stringl(ret, phalcon_interned_column, identifier_column->token, identifier_column->token_len, 0);
		efree(identifier_column);
	}
	if (alias) {
		add_assoc_stringl(ret, phalcon_interned_alias, alias->token, alias->token_len, 0);
		efree(alias);
	}

	return ret;
}

static zval *phql_ret_assoc_name(zval *qualified_name, phql_parser_token *alias)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_zval(ret, phalcon_interned_qualifiedName, qualified_name);
	if (alias) {
		add_assoc_stringl(ret, phalcon_interned_alias, alias->token, alias->token_len, 0);
		efree(alias);
	}

	return ret;
}

static zval *phql_ret_join_type(int type)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	ZVAL_LONG(ret, type);

	return ret;
}

static zval *phql_ret_join_item(zval *type, zval *qualified, zval *alias, zval *conditions)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);
	add_assoc_zval(ret, phalcon_interned_type, type);

	if (qualified) {
		add_assoc_zval(ret, phalcon_interned_qualified, qualified);
	}

	if (alias) {
		add_assoc_zval(ret, phalcon_interned_alias, alias);
	}

	if (conditions) {
		add_assoc_zval(ret, phalcon_interned_conditions, conditions);
	}

	return ret;
}

static zval *phql_ret_expr(int type, zval *left, zval *right)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_long(ret, phalcon_interned_type, type);
	if (left) {
		add_assoc_zval(ret, phalcon_interned_left, left);
	}
	if (right) {
		add_assoc_zval(ret, phalcon_interned_right, right);
	}

	return ret;
}

static zval *phql_ret_func_call(phql_parser_token *name, zval *arguments, zval *distinct)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);
	add_assoc_long(ret, phalcon_interned_type, PHQL_T_FCALL);
	add_assoc_stringl(ret, phalcon_interned_name, name->token, name->token_len, 0);
	efree(name);

	if (arguments) {
		add_assoc_zval(ret, phalcon_interned_arguments, arguments);
	}
	
	if (distinct) {
		add_assoc_zval(ret, phalcon_interned_distinct, distinct);
	}

	return ret;
}


/* #line 430 "parser.c" */
/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    YYNOCODE           is a number of type YYCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash 
**                       table.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    YYACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    phql_TOKENTYPE     is the data type used for minor tokens given 
**                       directly to the parser from the tokenizer.
**    YYMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is phql_TOKENTYPE.  The entry in the union
**                       for base tokens is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.
**    phql_ARG_SDECL     A static variable declaration for the %extra_argument
**    phql_ARG_PDECL     A parameter declaration for the %extra_argument
**    phql_ARG_STORE     Code to store %extra_argument into yypParser
**    phql_ARG_FETCH     Code to extract %extra_argument from yypParser
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define YYCODETYPE unsigned char
#define YYNOCODE 120
#define YYACTIONTYPE unsigned short int
#define phql_TOKENTYPE phql_parser_token*
typedef union {
  phql_TOKENTYPE yy0;
  zval* yy92;
  int yy239;
} YYMINORTYPE;
#define YYSTACKDEPTH 100
#define phql_ARG_SDECL phql_parser_status *status;
#define phql_ARG_PDECL ,phql_parser_status *status
#define phql_ARG_FETCH phql_parser_status *status = yypParser->status
#define phql_ARG_STORE yypParser->status = status
#define YYNSTATE 249
#define YYNRULE 139
#define YYERRORSYMBOL 70
#define YYERRSYMDT yy239
#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)
#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)
#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)

/* Next are that tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   YYNSTATE <= N < YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.
**
**   N == YYNSTATE+YYNRULE              A syntax error has occurred.
**
**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.
**
**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as
**
**      yy_action[ yy_shift_ofst[S] + X ]
**
** If the index value yy_shift_ofst[S]+X is out of range or if the value
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
** and that yy_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
** YY_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
*/
static YYACTIONTYPE yy_action[] = {
 /*     0 */    72,   78,   50,   52,   54,   56,   58,   60,   40,   42,
 /*    10 */    62,   67,   44,   46,   48,   36,   34,   38,   32,   29,
 /*    20 */    74,   69,   64,  145,   72,   78,   50,   52,   54,   56,
 /*    30 */    58,   60,   40,   42,   62,   67,   44,   46,   48,   36,
 /*    40 */    34,   38,   32,   29,   74,   69,   64,   16,   17,   18,
 /*    50 */   249,   27,   28,  201,  192,  199,  150,   72,   78,   50,
 /*    60 */    52,   54,   56,   58,   60,   40,   42,   62,   67,   44,
 /*    70 */    46,   48,   36,   34,   38,   32,   29,   74,   69,   64,
 /*    80 */    36,   34,   38,   32,   29,   74,   69,   64,   83,    7,
 /*    90 */    72,   78,   50,   52,   54,   56,   58,   60,   40,   42,
 /*   100 */    62,   67,   44,   46,   48,   36,   34,   38,   32,   29,
 /*   110 */    74,   69,   64,   72,   78,   50,   52,   54,   56,   58,
 /*   120 */    60,   40,   42,   62,   67,   44,   46,   48,   36,   34,
 /*   130 */    38,   32,   29,   74,   69,   64,   40,   42,   62,   67,
 /*   140 */    44,   46,   48,   36,   34,   38,   32,   29,   74,   69,
 /*   150 */    64,  327,   89,   74,   69,   64,  158,  108,  156,   72,
 /*   160 */    78,   50,   52,   54,   56,   58,   60,   40,   42,   62,
 /*   170 */    67,   44,   46,   48,   36,   34,   38,   32,   29,   74,
 /*   180 */    69,   64,   50,   52,   54,   56,   58,   60,   40,   42,
 /*   190 */    62,   67,   44,   46,   48,   36,   34,   38,   32,   29,
 /*   200 */    74,   69,   64,  101,  203,  204,   30,   12,  250,  102,
 /*   210 */   104,   65,  128,  138,  101,  153,   93,   30,  324,   99,
 /*   220 */   102,  104,  130,  173,  189,  175,  177,   93,  181,  185,
 /*   230 */   106,  364,  173,  189,  175,  177,   76,  181,  185,  363,
 /*   240 */   172,  106,  170,   14,  110,  116,  117,   80,   86,   26,
 /*   250 */   113,  111,  112,  114,  115,  110,  116,  117,   80,   86,
 /*   260 */    26,  113,  111,  112,  114,  115,  194,  109,   71,   30,
 /*   270 */    23,  135,  102,  104,  251,   19,   92,   75,  109,  195,
 /*   280 */    30,    8,   25,  102,  104,  124,  109,   92,  208,  216,
 /*   290 */    93,  252,   99,  106,   98,   92,  253,   96,  118,   32,
 /*   300 */    29,   74,   69,   64,  106,  136,    9,  110,  116,  117,
 /*   310 */    80,   86,  127,  113,  111,  112,  114,  115,  110,  116,
 /*   320 */   117,   80,   86,  120,  113,  111,  112,  114,  115,   62,
 /*   330 */    67,   44,   46,   48,   36,   34,   38,   32,   29,   74,
 /*   340 */    69,   64,   44,   46,   48,   36,   34,   38,   32,   29,
 /*   350 */    74,   69,   64,   71,  143,  389,    1,    2,    3,    4,
 /*   360 */     5,    6,  162,  163,  164,  235,  242,  238,   10,   71,
 /*   370 */   180,  109,  109,  178,  237,  238,   21,  140,  144,  126,
 /*   380 */    92,   92,  214,  118,   11,  149,  227,  109,  202,  198,
 /*   390 */   254,  210,  243,  124,  215,  132,   92,  152,  147,  118,
 /*   400 */   109,  161,  190,  163,  164,  214,   94,  109,   71,   92,
 /*   410 */   143,   13,   15,  205,  221,  151,   92,  215,  232,  191,
 /*   420 */   246,  193,  198,  109,  155,  241,  109,  214,  109,  134,
 /*   430 */    31,  120,   92,   33,  142,   92,  159,   92,  100,  213,
 /*   440 */   109,   35,   22,  109,  240,  109,   37,  109,  109,   92,
 /*   450 */   154,  109,   92,  165,   92,  155,   92,   92,   39,  109,
 /*   460 */    92,   41,  196,   99,  109,  159,   43,  159,   92,   45,
 /*   470 */   325,   47,   49,   92,   51,   94,  109,   53,  184,  109,
 /*   480 */    20,  182,  326,  133,  109,   92,   64,  109,   92,  109,
 /*   490 */   109,   55,  109,   92,   57,  109,   92,   59,   92,   92,
 /*   500 */   120,   92,   61,  197,   92,   63,   24,   66,   68,  109,
 /*   510 */    73,  188,  109,   79,  186,  109,  125,   70,   92,  212,
 /*   520 */   109,   92,  223,  109,   92,  109,  109,   82,  109,   92,
 /*   530 */    88,  109,   92,  103,   92,   92,  329,   92,  105,  211,
 /*   540 */    92,  107,  218,  129,  169,  109,  137,  217,  109,  146,
 /*   550 */   226,  109,  212,   77,   92,   81,  109,   92,  233,  109,
 /*   560 */    92,  109,  109,  155,  109,   92,  207,  109,   92,  248,
 /*   570 */    92,   92,  222,   92,  155,  159,   92,   84,  159,   85,
 /*   580 */    90,   87,  119,   91,   95,   97,  159,  121,  131,  122,
 /*   590 */   123,  125,  230,  139,  141,  148,  160,  157,  166,  168,
 /*   600 */   167,  171,  174,  277,  176,  278,  179,  279,  280,  281,
 /*   610 */   183,  282,  283,  284,  187,  285,  200,  288,  209,  225,
 /*   620 */   289,  224,  229,  228,  296,  328,  206,  231,  236,  239,
 /*   630 */   219,  244,  220,  245,  302,  247,  260,  234,
};
static YYCODETYPE yy_lookahead[] = {
 /*     0 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*    10 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*    20 */    21,   22,   23,   49,    1,    2,    3,    4,    5,    6,
 /*    30 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*    40 */    17,   18,   19,   20,   21,   22,   23,   58,   59,   60,
 /*    50 */     0,   52,   53,   30,   25,   32,   27,    1,    2,    3,
 /*    60 */     4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
 /*    70 */    14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
 /*    80 */    16,   17,   18,   19,   20,   21,   22,   23,   32,   78,
 /*    90 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*   100 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   110 */    21,   22,   23,    1,    2,    3,    4,    5,    6,    7,
 /*   120 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*   130 */    18,   19,   20,   21,   22,   23,    9,   10,   11,   12,
 /*   140 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   150 */    23,    0,   63,   21,   22,   23,   30,   45,   32,    1,
 /*   160 */     2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
 /*   170 */    12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*   180 */    22,   23,    3,    4,    5,    6,    7,    8,    9,   10,
 /*   190 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   200 */    21,   22,   23,   17,   28,   29,   20,   56,    0,   23,
 /*   210 */    24,   11,   12,   54,   17,   25,   30,   20,    0,   25,
 /*   220 */    23,   24,   22,   33,   34,   35,   36,   30,   38,   39,
 /*   230 */    44,   45,   33,   34,   35,   36,   23,   38,   39,   45,
 /*   240 */    30,   44,   32,   25,   58,   59,   60,   61,   62,   88,
 /*   250 */    64,   65,   66,   67,   68,   58,   59,   60,   61,   62,
 /*   260 */    88,   64,   65,   66,   67,   68,   17,  106,   88,   20,
 /*   270 */   109,  110,   23,   24,    0,   57,  115,   64,  106,   30,
 /*   280 */    20,   79,  110,   23,   24,   31,  106,  115,   43,   44,
 /*   290 */    30,    0,   25,   44,  114,  115,    0,  117,  118,   19,
 /*   300 */    20,   21,   22,   23,   44,   55,   80,   58,   59,   60,
 /*   310 */    61,   62,   45,   64,   65,   66,   67,   68,   58,   59,
 /*   320 */    60,   61,   62,   69,   64,   65,   66,   67,   68,   11,
 /*   330 */    12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*   340 */    22,   23,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   350 */    21,   22,   23,   88,   88,   71,   72,   73,   74,   75,
 /*   360 */    76,   77,   91,   92,   93,  104,  105,  106,   81,   88,
 /*   370 */    34,  106,  106,   37,  105,  106,   50,  111,  112,  114,
 /*   380 */   115,  115,   88,  118,   82,   84,  102,  106,   87,   88,
 /*   390 */     0,   97,  108,   31,  100,  114,  115,   86,   26,  118,
 /*   400 */   106,   90,   91,   92,   93,   88,   44,  106,   88,  115,
 /*   410 */    88,  113,  113,   41,   97,   85,  115,  100,   46,   89,
 /*   420 */    48,   87,   88,  106,   94,   88,  106,   88,  106,   88,
 /*   430 */    88,   69,  115,   88,  112,  115,  106,  115,  118,  100,
 /*   440 */   106,   88,   51,  106,  107,  106,   88,  106,  106,  115,
 /*   450 */    89,  106,  115,   94,  115,   94,  115,  115,   88,  106,
 /*   460 */   115,   88,   31,   25,  106,  106,   88,  106,  115,   88,
 /*   470 */     0,   88,   88,  115,   88,   44,  106,   88,   34,  106,
 /*   480 */   113,   37,    0,   45,  106,  115,   23,  106,  115,  106,
 /*   490 */   106,   88,  106,  115,   88,  106,  115,   88,  115,  115,
 /*   500 */    69,  115,   88,   17,  115,   88,   25,   88,   88,  106,
 /*   510 */    88,   34,  106,   88,   37,  106,   30,   44,  115,   25,
 /*   520 */   106,  115,   25,  106,  115,  106,  106,   88,  106,  115,
 /*   530 */    88,  106,  115,   88,  115,  115,    0,  115,   88,   45,
 /*   540 */   115,   88,   45,   88,   88,  106,   88,   98,  106,   88,
 /*   550 */   101,  106,   25,   64,  115,   44,  106,  115,   89,  106,
 /*   560 */   115,  106,  106,   94,  106,  115,   94,  106,  115,   89,
 /*   570 */   115,  115,   45,  115,   94,  106,  115,   30,  106,   45,
 /*   580 */    30,   44,   28,   45,  116,   45,  106,   30,   44,   31,
 /*   590 */    30,   30,   56,   51,   25,   83,   30,   30,   95,   40,
 /*   600 */    96,   30,   34,   30,   34,   30,   34,   30,   30,   30,
 /*   610 */    34,   30,   30,   30,   34,   30,   30,    0,   44,   30,
 /*   620 */     0,  101,  103,   78,    0,    0,   42,  113,   25,    3,
 /*   630 */    43,   78,   44,  103,    0,   27,  119,   47,
};
#define YY_SHIFT_USE_DFLT (-27)
static short yy_shift_ofst[] = {
 /*     0 */   372,   50,  208,  274,  291,  296,  -26,  159,  250,  326,
 /*    10 */   151,  390,  -11,  218,  -11,  470,  -27,  -27,  -27,  -11,
 /*    20 */   482,  391,  260,  481,  260,  -27,   -1,  -27,  -27,  260,
 /*    30 */   260,  132,  260,  132,  260,  280,  260,  280,  260,  280,
 /*    40 */   260,  318,  260,  318,  260,   64,  260,   64,  260,   64,
 /*    50 */   260,  127,  260,  127,  260,  127,  260,  127,  260,  127,
 /*    60 */   260,  127,  260,  329,  200,  260,  463,  260,  329,  473,
 /*    70 */   197,  158,  260,  158,  213,  -27,  489,  -27,  260,  179,
 /*    80 */   511,  260,   56,  547,  534,  -27,  537,  260,   89,  550,
 /*    90 */   538,  -27,  -27,  362,  554,  186,  540,  -27,  194,  197,
 /*   100 */   -27,  -27,  260,  463,  260,  463,  260,  112,  -27,  -27,
 /*   110 */   -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
 /*   120 */   557,  558,  560,  -27,  561,  -27,  267,  -27,  260,  463,
 /*   130 */   544,  197,  438,  -27,  132,  -27,  260,  158,  542,  260,
 /*   140 */   569,  260,  -27,  158,  -27,  260,  158,  176,  249,   29,
 /*   150 */   566,  190,  -27,  566,  -27,  126,  567,  -27,  -27,  -27,
 /*   160 */   254,  199,  -27,  -27,  566,  210,  559,  -27,  260,  158,
 /*   170 */   571,  -27,  -27,  568,  573,  570,  575,  336,  572,  577,
 /*   180 */   578,  444,  576,  579,  581,  477,  580,  582,  583,  585,
 /*   190 */   -27,  -27,  249,  -27,  -27,  431,  486,  -27,   23,  586,
 /*   200 */   -27,  -27,  -27,  -27,  -27,  584,  566,  245,  574,  260,
 /*   210 */   494,  617,  260,  -27,  158,  -27,  589,  497,  587,  588,
 /*   220 */   260,  527,  620,  589,  -27,  -27,  -27,  -26,  536,  624,
 /*   230 */   -11,  625,  566,  590,  566,  603,  566,  -27,  626,  260,
 /*   240 */   -27,  158,  -27,  -26,  536,  634,  608,  566,  -27,
};
#define YY_REDUCE_USE_DFLT (-1)
static short yy_reduce_ofst[] = {
 /*     0 */   284,   -1,   -1,   -1,   -1,   -1,   11,  202,  226,  287,
 /*    10 */   302,   -1,  298,   -1,  299,   -1,   -1,   -1,   -1,  367,
 /*    20 */    -1,   -1,  161,   -1,  172,   -1,   -1,   -1,   -1,  341,
 /*    30 */   342,   -1,  345,   -1,  353,   -1,  358,   -1,  370,   -1,
 /*    40 */   373,   -1,  378,   -1,  381,   -1,  383,   -1,  384,   -1,
 /*    50 */   386,   -1,  389,   -1,  403,   -1,  406,   -1,  409,   -1,
 /*    60 */   414,   -1,  417,   -1,   -1,  419,   -1,  420,   -1,   -1,
 /*    70 */   265,   -1,  422,   -1,   -1,   -1,   -1,   -1,  425,   -1,
 /*    80 */    -1,  439,   -1,   -1,   -1,   -1,   -1,  442,   -1,   -1,
 /*    90 */    -1,   -1,   -1,   -1,  468,  180,   -1,   -1,   -1,  320,
 /*   100 */    -1,   -1,  445,   -1,  450,   -1,  453,   -1,   -1,   -1,
 /*   110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 /*   120 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  455,   -1,
 /*   130 */    -1,  281,   -1,   -1,   -1,   -1,  458,   -1,   -1,  266,
 /*   140 */    -1,  322,   -1,   -1,   -1,  461,   -1,  512,  301,   -1,
 /*   150 */   330,  311,   -1,  361,   -1,   -1,   -1,   -1,   -1,   -1,
 /*   160 */    -1,  271,   -1,   -1,  359,  503,  504,   -1,  456,   -1,
 /*   170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 /*   180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 /*   190 */    -1,   -1,  334,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
 /*   200 */    -1,   -1,   -1,   -1,   -1,   -1,  472,   -1,   -1,  294,
 /*   210 */    -1,   -1,  339,   -1,   -1,   -1,  449,   -1,   -1,   -1,
 /*   220 */   317,   -1,   -1,  520,   -1,   -1,   -1,  545,  519,   -1,
 /*   230 */   514,   -1,  469,   -1,  261,   -1,  269,   -1,   -1,  337,
 /*   240 */    -1,   -1,   -1,  553,  530,   -1,   -1,  480,   -1,
};
static YYACTIONTYPE yy_default[] = {
 /*     0 */   388,  388,  388,  388,  388,  388,  309,  318,  323,  311,
 /*    10 */   388,  388,  388,  388,  388,  388,  330,  331,  332,  388,
 /*    20 */   388,  388,  388,  310,  388,  312,  314,  315,  316,  388,
 /*    30 */   388,  333,  388,  335,  388,  336,  388,  337,  388,  338,
 /*    40 */   388,  339,  388,  340,  388,  341,  388,  342,  388,  343,
 /*    50 */   388,  344,  388,  345,  388,  346,  388,  347,  388,  348,
 /*    60 */   388,  349,  388,  350,  388,  388,  351,  388,  352,  388,
 /*    70 */   388,  368,  388,  356,  388,  369,  388,  370,  388,  371,
 /*    80 */   388,  388,  388,  388,  388,  357,  388,  388,  388,  388,
 /*    90 */   388,  358,  359,  387,  362,  388,  388,  360,  388,  388,
 /*   100 */   365,  367,  388,  372,  388,  373,  388,  388,  374,  375,
 /*   110 */   376,  377,  378,  379,  380,  381,  382,  383,  366,  361,
 /*   120 */   388,  385,  388,  384,  388,  386,  388,  354,  388,  353,
 /*   130 */   388,  388,  388,  355,  334,  313,  388,  322,  388,  388,
 /*   140 */   317,  388,  319,  321,  320,  388,  308,  258,  388,  388,
 /*   150 */   388,  269,  255,  388,  266,  306,  388,  304,  305,  307,
 /*   160 */   387,  268,  270,  272,  388,  276,  287,  273,  388,  286,
 /*   170 */   388,  274,  275,  388,  388,  388,  388,  388,  388,  388,
 /*   180 */   388,  388,  388,  388,  388,  388,  388,  388,  388,  388,
 /*   190 */   271,  267,  388,  259,  261,  387,  388,  262,  265,  388,
 /*   200 */   263,  264,  260,  256,  257,  388,  388,  388,  388,  388,
 /*   210 */   388,  388,  388,  290,  292,  291,  388,  388,  388,  388,
 /*   220 */   388,  388,  388,  388,  293,  295,  294,  309,  388,  388,
 /*   230 */   388,  388,  388,  388,  388,  297,  388,  298,  388,  388,
 /*   240 */   300,  301,  299,  309,  388,  388,  388,  388,  303,
};
#define YY_SZ_ACTTAB (sizeof(yy_action)/sizeof(yy_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammer, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
};
#endif /* YYFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct yyStackEntry {
  int stateno;       /* The state-number */
  int major;         /* The major token value.  This is the code
                     ** number for the token at this stack level */
  YYMINORTYPE minor; /* The user-supplied minor token value.  This
                     ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct yyParser {
  int yyidx;                    /* Index of top element in stack */
  int yyerrcnt;                 /* Shifts left before out of the error */
  phql_ARG_SDECL                /* A place to hold %extra_argument */
  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
};
typedef struct yyParser yyParser;

#ifndef NDEBUG
#include <stdio.h>
static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
static void phql_Trace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  if( yyTraceFILE==0 ) yyTracePrompt = 0;
  else if( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *yyTokenName[] = { 
  "$",             "AGAINST",       "BETWEEN",       "EQUALS",      
  "NOTEQUALS",     "LESS",          "GREATER",       "GREATEREQUAL",
  "LESSEQUAL",     "AND",           "OR",            "LIKE",        
  "ILIKE",         "BITWISE_AND",   "BITWISE_OR",    "BITWISE_XOR", 
  "DIVIDE",        "TIMES",         "MOD",           "PLUS",        
  "MINUS",         "IS",            "IN",            "NOT",         
  "BITWISE_NOT",   "COMMA",         "SELECT",        "FROM",        
  "DISTINCT",      "ALL",           "IDENTIFIER",    "DOT",         
  "AS",            "INNER",         "JOIN",          "CROSS",       
  "LEFT",          "OUTER",         "RIGHT",         "FULL",        
  "ON",            "INSERT",        "INTO",          "VALUES",      
  "PARENTHESES_OPEN",  "PARENTHESES_CLOSE",  "UPDATE",        "SET",         
  "DELETE",        "WHERE",         "ORDER",         "BY",          
  "ASC",           "DESC",          "GROUP",         "HAVING",      
  "LIMIT",         "OFFSET",        "INTEGER",       "NPLACEHOLDER",
  "SPLACEHOLDER",  "CAST",          "CONVERT",       "USING",       
  "NULL",          "STRING",        "DOUBLE",        "TRUE",        
  "FALSE",         "COLON",         "error",         "program",     
  "query_language",  "select_statement",  "insert_statement",  "update_statement",
  "delete_statement",  "select_clause",  "where_clause",  "group_clause",
  "having_clause",  "order_clause",  "select_limit_clause",  "distinct_all",
  "column_list",   "associated_name_list",  "join_list_or_null",  "column_item", 
  "expr",          "associated_name",  "join_list",     "join_item",   
  "join_clause",   "join_type",     "aliased_or_qualified_name",  "join_associated_name",
  "join_conditions",  "values_list",   "field_list",    "value_list",  
  "value_item",    "field_item",    "update_clause",  "limit_clause",
  "update_item_list",  "update_item",   "qualified_name",  "new_value",   
  "delete_clause",  "order_list",    "order_item",    "group_list",  
  "group_item",    "integer_or_placeholder",  "argument_list",  "function_call",
  "distinct_or_null",  "argument_list_or_null",  "argument_item",
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *yyRuleName[] = {
 /*   0 */ "program ::= query_language",
 /*   1 */ "query_language ::= select_statement",
 /*   2 */ "query_language ::= insert_statement",
 /*   3 */ "query_language ::= update_statement",
 /*   4 */ "query_language ::= delete_statement",
 /*   5 */ "select_statement ::= select_clause where_clause group_clause having_clause order_clause select_limit_clause",
 /*   6 */ "select_clause ::= SELECT distinct_all column_list FROM associated_name_list join_list_or_null",
 /*   7 */ "distinct_all ::= DISTINCT",
 /*   8 */ "distinct_all ::= ALL",
 /*   9 */ "distinct_all ::=",
 /*  10 */ "column_list ::= column_list COMMA column_item",
 /*  11 */ "column_list ::= column_item",
 /*  12 */ "column_item ::= TIMES",
 /*  13 */ "column_item ::= IDENTIFIER DOT TIMES",
 /*  14 */ "column_item ::= expr AS IDENTIFIER",
 /*  15 */ "column_item ::= expr IDENTIFIER",
 /*  16 */ "column_item ::= expr",
 /*  17 */ "associated_name_list ::= associated_name_list COMMA associated_name",
 /*  18 */ "associated_name_list ::= associated_name",
 /*  19 */ "join_list_or_null ::= join_list",
 /*  20 */ "join_list_or_null ::=",
 /*  21 */ "join_list ::= join_list join_item",
 /*  22 */ "join_list ::= join_item",
 /*  23 */ "join_item ::= join_clause",
 /*  24 */ "join_clause ::= join_type aliased_or_qualified_name join_associated_name join_conditions",
 /*  25 */ "join_associated_name ::= AS IDENTIFIER",
 /*  26 */ "join_associated_name ::= IDENTIFIER",
 /*  27 */ "join_associated_name ::=",
 /*  28 */ "join_type ::= INNER JOIN",
 /*  29 */ "join_type ::= CROSS JOIN",
 /*  30 */ "join_type ::= LEFT OUTER JOIN",
 /*  31 */ "join_type ::= LEFT JOIN",
 /*  32 */ "join_type ::= RIGHT OUTER JOIN",
 /*  33 */ "join_type ::= RIGHT JOIN",
 /*  34 */ "join_type ::= FULL OUTER JOIN",
 /*  35 */ "join_type ::= FULL JOIN",
 /*  36 */ "join_type ::= JOIN",
 /*  37 */ "join_conditions ::= ON expr",
 /*  38 */ "join_conditions ::=",
 /*  39 */ "insert_statement ::= INSERT INTO aliased_or_qualified_name VALUES PARENTHESES_OPEN values_list PARENTHESES_CLOSE",
 /*  40 */ "insert_statement ::= INSERT INTO aliased_or_qualified_name PARENTHESES_OPEN field_list PARENTHESES_CLOSE VALUES PARENTHESES_OPEN values_list PARENTHESES_CLOSE",
 /*  41 */ "values_list ::= values_list COMMA value_item",
 /*  42 */ "values_list ::= value_item",
 /*  43 */ "value_item ::= expr",
 /*  44 */ "field_list ::= field_list COMMA field_item",
 /*  45 */ "field_list ::= field_item",
 /*  46 */ "field_item ::= IDENTIFIER",
 /*  47 */ "update_statement ::= update_clause where_clause limit_clause",
 /*  48 */ "update_clause ::= UPDATE associated_name SET update_item_list",
 /*  49 */ "update_item_list ::= update_item_list COMMA update_item",
 /*  50 */ "update_item_list ::= update_item",
 /*  51 */ "update_item ::= qualified_name EQUALS new_value",
 /*  52 */ "new_value ::= expr",
 /*  53 */ "delete_statement ::= delete_clause where_clause limit_clause",
 /*  54 */ "delete_clause ::= DELETE FROM associated_name",
 /*  55 */ "associated_name ::= aliased_or_qualified_name AS IDENTIFIER",
 /*  56 */ "associated_name ::= aliased_or_qualified_name IDENTIFIER",
 /*  57 */ "associated_name ::= aliased_or_qualified_name",
 /*  58 */ "aliased_or_qualified_name ::= qualified_name",
 /*  59 */ "where_clause ::= WHERE expr",
 /*  60 */ "where_clause ::=",
 /*  61 */ "order_clause ::= ORDER BY order_list",
 /*  62 */ "order_clause ::=",
 /*  63 */ "order_list ::= order_list COMMA order_item",
 /*  64 */ "order_list ::= order_item",
 /*  65 */ "order_item ::= expr",
 /*  66 */ "order_item ::= expr ASC",
 /*  67 */ "order_item ::= expr DESC",
 /*  68 */ "group_clause ::= GROUP BY group_list",
 /*  69 */ "group_clause ::=",
 /*  70 */ "group_list ::= group_list COMMA group_item",
 /*  71 */ "group_list ::= group_item",
 /*  72 */ "group_item ::= expr",
 /*  73 */ "having_clause ::= HAVING expr",
 /*  74 */ "having_clause ::=",
 /*  75 */ "select_limit_clause ::= LIMIT integer_or_placeholder",
 /*  76 */ "select_limit_clause ::= LIMIT integer_or_placeholder COMMA integer_or_placeholder",
 /*  77 */ "select_limit_clause ::= LIMIT integer_or_placeholder OFFSET integer_or_placeholder",
 /*  78 */ "select_limit_clause ::=",
 /*  79 */ "limit_clause ::= LIMIT integer_or_placeholder",
 /*  80 */ "limit_clause ::=",
 /*  81 */ "integer_or_placeholder ::= INTEGER",
 /*  82 */ "integer_or_placeholder ::= NPLACEHOLDER",
 /*  83 */ "integer_or_placeholder ::= SPLACEHOLDER",
 /*  84 */ "expr ::= MINUS expr",
 /*  85 */ "expr ::= expr MINUS expr",
 /*  86 */ "expr ::= expr PLUS expr",
 /*  87 */ "expr ::= expr TIMES expr",
 /*  88 */ "expr ::= expr DIVIDE expr",
 /*  89 */ "expr ::= expr MOD expr",
 /*  90 */ "expr ::= expr AND expr",
 /*  91 */ "expr ::= expr OR expr",
 /*  92 */ "expr ::= expr BITWISE_AND expr",
 /*  93 */ "expr ::= expr BITWISE_OR expr",
 /*  94 */ "expr ::= expr BITWISE_XOR expr",
 /*  95 */ "expr ::= expr EQUALS expr",
 /*  96 */ "expr ::= expr NOTEQUALS expr",
 /*  97 */ "expr ::= expr LESS expr",
 /*  98 */ "expr ::= expr GREATER expr",
 /*  99 */ "expr ::= expr GREATEREQUAL expr",
 /* 100 */ "expr ::= expr LESSEQUAL expr",
 /* 101 */ "expr ::= expr LIKE expr",
 /* 102 */ "expr ::= expr NOT LIKE expr",
 /* 103 */ "expr ::= expr ILIKE expr",
 /* 104 */ "expr ::= expr NOT ILIKE expr",
 /* 105 */ "expr ::= expr IN PARENTHESES_OPEN argument_list PARENTHESES_CLOSE",
 /* 106 */ "expr ::= expr NOT IN PARENTHESES_OPEN argument_list PARENTHESES_CLOSE",
 /* 107 */ "expr ::= expr AGAINST expr",
 /* 108 */ "expr ::= CAST PARENTHESES_OPEN expr AS IDENTIFIER PARENTHESES_CLOSE",
 /* 109 */ "expr ::= CONVERT PARENTHESES_OPEN expr USING IDENTIFIER PARENTHESES_CLOSE",
 /* 110 */ "expr ::= function_call",
 /* 111 */ "function_call ::= IDENTIFIER PARENTHESES_OPEN distinct_or_null argument_list_or_null PARENTHESES_CLOSE",
 /* 112 */ "distinct_or_null ::= DISTINCT",
 /* 113 */ "distinct_or_null ::=",
 /* 114 */ "argument_list_or_null ::= argument_list",
 /* 115 */ "argument_list_or_null ::=",
 /* 116 */ "argument_list ::= argument_list COMMA argument_item",
 /* 117 */ "argument_list ::= argument_item",
 /* 118 */ "argument_item ::= TIMES",
 /* 119 */ "argument_item ::= expr",
 /* 120 */ "expr ::= expr IS NULL",
 /* 121 */ "expr ::= expr IS NOT NULL",
 /* 122 */ "expr ::= expr BETWEEN expr",
 /* 123 */ "expr ::= NOT expr",
 /* 124 */ "expr ::= BITWISE_NOT expr",
 /* 125 */ "expr ::= PARENTHESES_OPEN expr PARENTHESES_CLOSE",
 /* 126 */ "expr ::= qualified_name",
 /* 127 */ "expr ::= INTEGER",
 /* 128 */ "expr ::= STRING",
 /* 129 */ "expr ::= DOUBLE",
 /* 130 */ "expr ::= NULL",
 /* 131 */ "expr ::= TRUE",
 /* 132 */ "expr ::= FALSE",
 /* 133 */ "expr ::= NPLACEHOLDER",
 /* 134 */ "expr ::= SPLACEHOLDER",
 /* 135 */ "qualified_name ::= IDENTIFIER COLON IDENTIFIER DOT IDENTIFIER",
 /* 136 */ "qualified_name ::= IDENTIFIER COLON IDENTIFIER",
 /* 137 */ "qualified_name ::= IDENTIFIER DOT IDENTIFIER",
 /* 138 */ "qualified_name ::= IDENTIFIER",
};
#endif /* NDEBUG */

const char *phql_TokenName(int tokenType){
#ifndef NDEBUG
  if( tokenType>0 && (size_t)tokenType<(sizeof(yyTokenName)/sizeof(yyTokenName[0])) ){
    return yyTokenName[tokenType];
  }else{
    return "Unknown";
  }
#else
  return "";
#endif
}

void *phql_Alloc(void *(*mallocProc)(size_t)){
  yyParser *pParser;
  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );
  if( pParser ){
    pParser->yyidx = -1;
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "yymajor" is the symbol code, and "yypminor" is a pointer to
** the value.
*/
static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){
  switch( yymajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
/* #line 528 "parser.y" */
{
	if ((yypminor->yy0)) {
		if ((yypminor->yy0)->free_flag) {
			efree((yypminor->yy0)->token);
		}
		efree((yypminor->yy0));
	}
}
/* #line 1158 "parser.c" */
      break;
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 84:
    case 85:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 98:
    case 99:
    case 101:
    case 102:
    case 104:
    case 105:
    case 106:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 114:
    case 115:
    case 118:
/* #line 541 "parser.y" */
{ zval_ptr_dtor(&(yypminor->yy92)); }
/* #line 1193 "parser.c" */
      break;
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 95:
    case 96:
    case 103:
    case 116:
    case 117:
/* #line 829 "parser.y" */
{ phalcon_safe_zval_ptr_dtor((yypminor->yy92)); }
/* #line 1208 "parser.c" */
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

static int yy_pop_parser_stack(yyParser *pParser){
  YYCODETYPE yymajor;
  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];

  if( pParser->yyidx<0 ) return 0;
#ifndef NDEBUG
  if( yyTraceFILE && pParser->yyidx>=0 ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yymajor = yytos->major;
  yy_destructor( yymajor, &yytos->minor);
  pParser->yyidx--;
  return yymajor;
}

static void phql_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  yyParser *pParser = (yyParser*)p;
  if( pParser==0 ) return;
  while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);
  (*freeProc)((void*)pParser);
}

static int yy_find_shift_action(
  yyParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;
 
  /* if( pParser->yyidx<0 ) return YY_NO_ACTION;  */
  i = yy_shift_ofst[stateno];
  if( i==YY_SHIFT_USE_DFLT ){
    return yy_default[stateno];
  }
  if( iLookAhead==YYNOCODE ){
    return YY_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
    int iFallback;            /* Fallback token */
    if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])
           && (iFallback = yyFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
           yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
      }
#endif
      return yy_find_shift_action(pParser, iFallback);
    }
#endif
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}

static int yy_find_reduce_action(
  yyParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;
 
  i = yy_reduce_ofst[stateno];
  if( i==YY_REDUCE_USE_DFLT ){
    return yy_default[stateno];
  }
  if( iLookAhead==YYNOCODE ){
    return YY_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}

static void yy_shift(
  yyParser *yypParser,          /* The parser to be shifted */
  int yyNewState,               /* The new state to shift in */
  int yyMajor,                  /* The major token to shift in */
  YYMINORTYPE *yypMinor         /* Pointer ot the minor token to shift in */
){
  yyStackEntry *yytos;
  yypParser->yyidx++;
  if( yypParser->yyidx>=YYSTACKDEPTH ){
     phql_ARG_FETCH;
     yypParser->yyidx--;
#ifndef NDEBUG
     if( yyTraceFILE ){
       fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
     }
#endif
     while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
     /* Here code is inserted which will execute if the parser
     ** stack every overflows */
     phql_ARG_STORE; /* Suppress warning about unused %extra_argument var */
     return;
  }
  yytos = &yypParser->yystack[yypParser->yyidx];
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor = *yypMinor;
#ifndef NDEBUG
  if( yyTraceFILE && yypParser->yyidx>0 ){
    int i;
    fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState);
    fprintf(yyTraceFILE,"%sStack:",yyTracePrompt);
    for(i=1; i<=yypParser->yyidx; i++)
      fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]);
    fprintf(yyTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static struct {
  YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} yyRuleInfo[] = {
  { 71, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 72, 1 },
  { 73, 6 },
  { 77, 6 },
  { 83, 1 },
  { 83, 1 },
  { 83, 0 },
  { 84, 3 },
  { 84, 1 },
  { 87, 1 },
  { 87, 3 },
  { 87, 3 },
  { 87, 2 },
  { 87, 1 },
  { 85, 3 },
  { 85, 1 },
  { 86, 1 },
  { 86, 0 },
  { 90, 2 },
  { 90, 1 },
  { 91, 1 },
  { 92, 4 },
  { 95, 2 },
  { 95, 1 },
  { 95, 0 },
  { 93, 2 },
  { 93, 2 },
  { 93, 3 },
  { 93, 2 },
  { 93, 3 },
  { 93, 2 },
  { 93, 3 },
  { 93, 2 },
  { 93, 1 },
  { 96, 2 },
  { 96, 0 },
  { 74, 7 },
  { 74, 10 },
  { 97, 3 },
  { 97, 1 },
  { 100, 1 },
  { 98, 3 },
  { 98, 1 },
  { 101, 1 },
  { 75, 3 },
  { 102, 4 },
  { 104, 3 },
  { 104, 1 },
  { 105, 3 },
  { 107, 1 },
  { 76, 3 },
  { 108, 3 },
  { 89, 3 },
  { 89, 2 },
  { 89, 1 },
  { 94, 1 },
  { 78, 2 },
  { 78, 0 },
  { 81, 3 },
  { 81, 0 },
  { 109, 3 },
  { 109, 1 },
  { 110, 1 },
  { 110, 2 },
  { 110, 2 },
  { 79, 3 },
  { 79, 0 },
  { 111, 3 },
  { 111, 1 },
  { 112, 1 },
  { 80, 2 },
  { 80, 0 },
  { 82, 2 },
  { 82, 4 },
  { 82, 4 },
  { 82, 0 },
  { 103, 2 },
  { 103, 0 },
  { 113, 1 },
  { 113, 1 },
  { 113, 1 },
  { 88, 2 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 3 },
  { 88, 4 },
  { 88, 3 },
  { 88, 4 },
  { 88, 5 },
  { 88, 6 },
  { 88, 3 },
  { 88, 6 },
  { 88, 6 },
  { 88, 1 },
  { 115, 5 },
  { 116, 1 },
  { 116, 0 },
  { 117, 1 },
  { 117, 0 },
  { 114, 3 },
  { 114, 1 },
  { 118, 1 },
  { 118, 1 },
  { 88, 3 },
  { 88, 4 },
  { 88, 3 },
  { 88, 2 },
  { 88, 2 },
  { 88, 3 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 88, 1 },
  { 106, 5 },
  { 106, 3 },
  { 106, 3 },
  { 106, 1 },
};

static void yy_accept(yyParser*);  /* Forward Declaration */

static void yy_reduce(
  yyParser *yypParser,         /* The parser */
  int yyruleno                 /* Number of the rule by which to reduce */
){
  int yygoto;                     /* The next state */
  int yyact;                      /* The next action */
  YYMINORTYPE yygotominor;        /* The LHS of the rule reduced */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  phql_ARG_FETCH;
  yymsp = &yypParser->yystack[yypParser->yyidx];
#ifndef NDEBUG
  if( yyTraceFILE && yyruleno>=0 
        && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){
    fprintf(yyTraceFILE, "%sReduce [%s].\n", yyTracePrompt,
      yyRuleName[yyruleno]);
  }
#endif /* NDEBUG */

  switch( yyruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
      case 0:
/* #line 537 "parser.y" */
{
	status->ret = yymsp[0].minor.yy92;
}
/* #line 1564 "parser.c" */
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 18:
      case 19:
      case 22:
      case 23:
      case 43:
      case 50:
      case 52:
      case 58:
      case 64:
      case 71:
      case 72:
      case 110:
      case 114:
      case 119:
      case 126:
/* #line 543 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
}
/* #line 1589 "parser.c" */
        break;
      case 5:
/* #line 561 "parser.y" */
{
	yygotominor.yy92 = phql_ret_select_statement(yymsp[-5].minor.yy92, yymsp[-4].minor.yy92, yymsp[-1].minor.yy92, yymsp[-3].minor.yy92, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
}
/* #line 1596 "parser.c" */
        break;
      case 6:
/* #line 567 "parser.y" */
{
	yygotominor.yy92 = phql_ret_select_clause(yymsp[-4].minor.yy92, yymsp[-3].minor.yy92, yymsp[-1].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(26,&yymsp[-5].minor);
  yy_destructor(27,&yymsp[-2].minor);
}
/* #line 1605 "parser.c" */
        break;
      case 7:
/* #line 573 "parser.y" */
{
	yygotominor.yy92 = phql_ret_distinct_all(1);
  yy_destructor(28,&yymsp[0].minor);
}
/* #line 1613 "parser.c" */
        break;
      case 8:
/* #line 577 "parser.y" */
{
	yygotominor.yy92 = phql_ret_distinct_all(0);
  yy_destructor(29,&yymsp[0].minor);
}
/* #line 1621 "parser.c" */
        break;
      case 9:
      case 20:
      case 27:
      case 38:
      case 60:
      case 62:
      case 69:
      case 74:
      case 78:
      case 80:
      case 113:
      case 115:
/* #line 581 "parser.y" */
{
	yygotominor.yy92 = NULL;
}
/* #line 1639 "parser.c" */
        break;
      case 10:
      case 17:
      case 41:
      case 44:
      case 49:
      case 63:
      case 70:
      case 116:
/* #line 587 "parser.y" */
{
	yygotominor.yy92 = phql_ret_zval_list(yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(25,&yymsp[-1].minor);
}
/* #line 1654 "parser.c" */
        break;
      case 11:
      case 42:
      case 45:
      case 117:
/* #line 591 "parser.y" */
{
	yygotominor.yy92 = phql_ret_zval_list(yymsp[0].minor.yy92, NULL);
}
/* #line 1664 "parser.c" */
        break;
      case 12:
      case 118:
/* #line 597 "parser.y" */
{
	yygotominor.yy92 = phql_ret_column_item(PHQL_T_STARALL, NULL, NULL, NULL);
  yy_destructor(17,&yymsp[0].minor);
}
/* #line 1673 "parser.c" */
        break;
      case 13:
/* #line 601 "parser.y" */
{
	yygotominor.yy92 = phql_ret_column_item(PHQL_T_DOMAINALL, NULL, yymsp[-2].minor.yy0, NULL);
  yy_destructor(31,&yymsp[-1].minor);
  yy_destructor(17,&yymsp[0].minor);
}
/* #line 1682 "parser.c" */
        break;
      case 14:
/* #line 605 "parser.y" */
{
	yygotominor.yy92 = phql_ret_column_item(PHQL_T_EXPR, yymsp[-2].minor.yy92, NULL, yymsp[0].minor.yy0);
  yy_destructor(32,&yymsp[-1].minor);
}
/* #line 1690 "parser.c" */
        break;
      case 15:
/* #line 609 "parser.y" */
{
	yygotominor.yy92 = phql_ret_column_item(PHQL_T_EXPR, yymsp[-1].minor.yy92, NULL, yymsp[0].minor.yy0);
}
/* #line 1697 "parser.c" */
        break;
      case 16:
/* #line 613 "parser.y" */
{
	yygotominor.yy92 = phql_ret_column_item(PHQL_T_EXPR, yymsp[0].minor.yy92, NULL, NULL);
}
/* #line 1704 "parser.c" */
        break;
      case 21:
/* #line 637 "parser.y" */
{
	yygotominor.yy92 = phql_ret_zval_list(yymsp[-1].minor.yy92, yymsp[0].minor.yy92);
}
/* #line 1711 "parser.c" */
        break;
      case 24:
/* #line 654 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_item(yymsp[-3].minor.yy92, yymsp[-2].minor.yy92, yymsp[-1].minor.yy92, yymsp[0].minor.yy92);
}
/* #line 1718 "parser.c" */
        break;
      case 25:
/* #line 660 "parser.y" */
{
	yygotominor.yy92 = phql_ret_qualified_name(NULL, NULL, yymsp[0].minor.yy0);
  yy_destructor(32,&yymsp[-1].minor);
}
/* #line 1726 "parser.c" */
        break;
      case 26:
      case 46:
      case 138:
/* #line 664 "parser.y" */
{
	yygotominor.yy92 = phql_ret_qualified_name(NULL, NULL, yymsp[0].minor.yy0);
}
/* #line 1735 "parser.c" */
        break;
      case 28:
/* #line 674 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_INNERJOIN);
  yy_destructor(33,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1744 "parser.c" */
        break;
      case 29:
/* #line 678 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_CROSSJOIN);
  yy_destructor(35,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1753 "parser.c" */
        break;
      case 30:
/* #line 682 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_LEFTJOIN);
  yy_destructor(36,&yymsp[-2].minor);
  yy_destructor(37,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1763 "parser.c" */
        break;
      case 31:
/* #line 686 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_LEFTJOIN);
  yy_destructor(36,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1772 "parser.c" */
        break;
      case 32:
/* #line 690 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_RIGHTJOIN);
  yy_destructor(38,&yymsp[-2].minor);
  yy_destructor(37,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1782 "parser.c" */
        break;
      case 33:
/* #line 694 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_RIGHTJOIN);
  yy_destructor(38,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1791 "parser.c" */
        break;
      case 34:
/* #line 698 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_FULLJOIN);
  yy_destructor(39,&yymsp[-2].minor);
  yy_destructor(37,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1801 "parser.c" */
        break;
      case 35:
/* #line 702 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_FULLJOIN);
  yy_destructor(39,&yymsp[-1].minor);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1810 "parser.c" */
        break;
      case 36:
/* #line 706 "parser.y" */
{
	yygotominor.yy92 = phql_ret_join_type(PHQL_T_INNERJOIN);
  yy_destructor(34,&yymsp[0].minor);
}
/* #line 1818 "parser.c" */
        break;
      case 37:
/* #line 712 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
  yy_destructor(40,&yymsp[-1].minor);
}
/* #line 1826 "parser.c" */
        break;
      case 39:
/* #line 723 "parser.y" */
{
	yygotominor.yy92 = phql_ret_insert_statement(yymsp[-4].minor.yy92, NULL, yymsp[-1].minor.yy92);
  yy_destructor(41,&yymsp[-6].minor);
  yy_destructor(42,&yymsp[-5].minor);
  yy_destructor(43,&yymsp[-3].minor);
  yy_destructor(44,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 1838 "parser.c" */
        break;
      case 40:
/* #line 727 "parser.y" */
{
	yygotominor.yy92 = phql_ret_insert_statement(yymsp[-7].minor.yy92, yymsp[-5].minor.yy92, yymsp[-1].minor.yy92);
  yy_destructor(41,&yymsp[-9].minor);
  yy_destructor(42,&yymsp[-8].minor);
  yy_destructor(44,&yymsp[-6].minor);
  yy_destructor(45,&yymsp[-4].minor);
  yy_destructor(43,&yymsp[-3].minor);
  yy_destructor(44,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 1852 "parser.c" */
        break;
      case 47:
/* #line 765 "parser.y" */
{
	yygotominor.yy92 = phql_ret_update_statement(yymsp[-2].minor.yy92, yymsp[-1].minor.yy92, yymsp[0].minor.yy92);
}
/* #line 1859 "parser.c" */
        break;
      case 48:
/* #line 771 "parser.y" */
{
	yygotominor.yy92 = phql_ret_update_clause(yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(46,&yymsp[-3].minor);
  yy_destructor(47,&yymsp[-1].minor);
}
/* #line 1868 "parser.c" */
        break;
      case 51:
/* #line 787 "parser.y" */
{
	yygotominor.yy92 = phql_ret_update_item(yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(3,&yymsp[-1].minor);
}
/* #line 1876 "parser.c" */
        break;
      case 53:
/* #line 799 "parser.y" */
{
	yygotominor.yy92 = phql_ret_delete_statement(yymsp[-2].minor.yy92, yymsp[-1].minor.yy92, yymsp[0].minor.yy92);
}
/* #line 1883 "parser.c" */
        break;
      case 54:
/* #line 805 "parser.y" */
{
	yygotominor.yy92 = phql_ret_delete_clause(yymsp[0].minor.yy92);
  yy_destructor(48,&yymsp[-2].minor);
  yy_destructor(27,&yymsp[-1].minor);
}
/* #line 1892 "parser.c" */
        break;
      case 55:
/* #line 811 "parser.y" */
{
	yygotominor.yy92 = phql_ret_assoc_name(yymsp[-2].minor.yy92, yymsp[0].minor.yy0);
  yy_destructor(32,&yymsp[-1].minor);
}
/* #line 1900 "parser.c" */
        break;
      case 56:
/* #line 815 "parser.y" */
{
	yygotominor.yy92 = phql_ret_assoc_name(yymsp[-1].minor.yy92, yymsp[0].minor.yy0);
}
/* #line 1907 "parser.c" */
        break;
      case 57:
/* #line 819 "parser.y" */
{
	yygotominor.yy92 = phql_ret_assoc_name(yymsp[0].minor.yy92, NULL);
}
/* #line 1914 "parser.c" */
        break;
      case 59:
/* #line 831 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
  yy_destructor(49,&yymsp[-1].minor);
}
/* #line 1922 "parser.c" */
        break;
      case 61:
/* #line 841 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
  yy_destructor(50,&yymsp[-2].minor);
  yy_destructor(51,&yymsp[-1].minor);
}
/* #line 1931 "parser.c" */
        break;
      case 65:
/* #line 861 "parser.y" */
{
	yygotominor.yy92 = phql_ret_order_item(yymsp[0].minor.yy92, 0);
}
/* #line 1938 "parser.c" */
        break;
      case 66:
/* #line 865 "parser.y" */
{
	yygotominor.yy92 = phql_ret_order_item(yymsp[-1].minor.yy92, PHQL_T_ASC);
  yy_destructor(52,&yymsp[0].minor);
}
/* #line 1946 "parser.c" */
        break;
      case 67:
/* #line 869 "parser.y" */
{
	yygotominor.yy92 = phql_ret_order_item(yymsp[-1].minor.yy92, PHQL_T_DESC);
  yy_destructor(53,&yymsp[0].minor);
}
/* #line 1954 "parser.c" */
        break;
      case 68:
/* #line 875 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
  yy_destructor(54,&yymsp[-2].minor);
  yy_destructor(51,&yymsp[-1].minor);
}
/* #line 1963 "parser.c" */
        break;
      case 73:
/* #line 901 "parser.y" */
{
	yygotominor.yy92 = yymsp[0].minor.yy92;
  yy_destructor(55,&yymsp[-1].minor);
}
/* #line 1971 "parser.c" */
        break;
      case 75:
      case 79:
/* #line 911 "parser.y" */
{
	yygotominor.yy92 = phql_ret_limit_clause(yymsp[0].minor.yy92, NULL);
  yy_destructor(56,&yymsp[-1].minor);
}
/* #line 1980 "parser.c" */
        break;
      case 76:
/* #line 915 "parser.y" */
{
	yygotominor.yy92 = phql_ret_limit_clause(yymsp[0].minor.yy92, yymsp[-2].minor.yy92);
  yy_destructor(56,&yymsp[-3].minor);
  yy_destructor(25,&yymsp[-1].minor);
}
/* #line 1989 "parser.c" */
        break;
      case 77:
/* #line 919 "parser.y" */
{
	yygotominor.yy92 = phql_ret_limit_clause(yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(56,&yymsp[-3].minor);
  yy_destructor(57,&yymsp[-1].minor);
}
/* #line 1998 "parser.c" */
        break;
      case 81:
      case 127:
/* #line 937 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_INTEGER, yymsp[0].minor.yy0);
}
/* #line 2006 "parser.c" */
        break;
      case 82:
      case 133:
/* #line 941 "parser.y" */
{
	yygotominor.yy92 = phql_ret_placeholder_zval(PHQL_T_NPLACEHOLDER, yymsp[0].minor.yy0);
}
/* #line 2014 "parser.c" */
        break;
      case 83:
      case 134:
/* #line 945 "parser.y" */
{
	yygotominor.yy92 = phql_ret_placeholder_zval(PHQL_T_SPLACEHOLDER, yymsp[0].minor.yy0);
}
/* #line 2022 "parser.c" */
        break;
      case 84:
/* #line 951 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_MINUS, NULL, yymsp[0].minor.yy92);
  yy_destructor(20,&yymsp[-1].minor);
}
/* #line 2030 "parser.c" */
        break;
      case 85:
/* #line 955 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_SUB, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(20,&yymsp[-1].minor);
}
/* #line 2038 "parser.c" */
        break;
      case 86:
/* #line 959 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_ADD, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(19,&yymsp[-1].minor);
}
/* #line 2046 "parser.c" */
        break;
      case 87:
/* #line 963 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_MUL, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(17,&yymsp[-1].minor);
}
/* #line 2054 "parser.c" */
        break;
      case 88:
/* #line 967 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_DIV, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(16,&yymsp[-1].minor);
}
/* #line 2062 "parser.c" */
        break;
      case 89:
/* #line 971 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_MOD, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(18,&yymsp[-1].minor);
}
/* #line 2070 "parser.c" */
        break;
      case 90:
/* #line 975 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_AND, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(9,&yymsp[-1].minor);
}
/* #line 2078 "parser.c" */
        break;
      case 91:
/* #line 979 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_OR, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(10,&yymsp[-1].minor);
}
/* #line 2086 "parser.c" */
        break;
      case 92:
/* #line 983 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_BITWISE_AND, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(13,&yymsp[-1].minor);
}
/* #line 2094 "parser.c" */
        break;
      case 93:
/* #line 987 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_BITWISE_OR, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(14,&yymsp[-1].minor);
}
/* #line 2102 "parser.c" */
        break;
      case 94:
/* #line 991 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_BITWISE_XOR, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(15,&yymsp[-1].minor);
}
/* #line 2110 "parser.c" */
        break;
      case 95:
/* #line 995 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_EQUALS, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(3,&yymsp[-1].minor);
}
/* #line 2118 "parser.c" */
        break;
      case 96:
/* #line 999 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_NOTEQUALS, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(4,&yymsp[-1].minor);
}
/* #line 2126 "parser.c" */
        break;
      case 97:
/* #line 1003 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_LESS, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(5,&yymsp[-1].minor);
}
/* #line 2134 "parser.c" */
        break;
      case 98:
/* #line 1007 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_GREATER, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(6,&yymsp[-1].minor);
}
/* #line 2142 "parser.c" */
        break;
      case 99:
/* #line 1011 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_GREATEREQUAL, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(7,&yymsp[-1].minor);
}
/* #line 2150 "parser.c" */
        break;
      case 100:
/* #line 1015 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_LESSEQUAL, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(8,&yymsp[-1].minor);
}
/* #line 2158 "parser.c" */
        break;
      case 101:
/* #line 1019 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_LIKE, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(11,&yymsp[-1].minor);
}
/* #line 2166 "parser.c" */
        break;
      case 102:
/* #line 1023 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_NLIKE, yymsp[-3].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(23,&yymsp[-2].minor);
  yy_destructor(11,&yymsp[-1].minor);
}
/* #line 2175 "parser.c" */
        break;
      case 103:
/* #line 1027 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_ILIKE, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(12,&yymsp[-1].minor);
}
/* #line 2183 "parser.c" */
        break;
      case 104:
/* #line 1031 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_NILIKE, yymsp[-3].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(23,&yymsp[-2].minor);
  yy_destructor(12,&yymsp[-1].minor);
}
/* #line 2192 "parser.c" */
        break;
      case 105:
/* #line 1035 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_IN, yymsp[-4].minor.yy92, yymsp[-1].minor.yy92);
  yy_destructor(22,&yymsp[-3].minor);
  yy_destructor(44,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2202 "parser.c" */
        break;
      case 106:
/* #line 1039 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_NOTIN, yymsp[-5].minor.yy92, yymsp[-1].minor.yy92);
  yy_destructor(23,&yymsp[-4].minor);
  yy_destructor(22,&yymsp[-3].minor);
  yy_destructor(44,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2213 "parser.c" */
        break;
      case 107:
/* #line 1043 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_AGAINST, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(1,&yymsp[-1].minor);
}
/* #line 2221 "parser.c" */
        break;
      case 108:
/* #line 1047 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_CAST, yymsp[-3].minor.yy92, phql_ret_raw_qualified_name(yymsp[-1].minor.yy0, NULL));
  yy_destructor(61,&yymsp[-5].minor);
  yy_destructor(44,&yymsp[-4].minor);
  yy_destructor(32,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2232 "parser.c" */
        break;
      case 109:
/* #line 1051 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_CONVERT, yymsp[-3].minor.yy92, phql_ret_raw_qualified_name(yymsp[-1].minor.yy0, NULL));
  yy_destructor(62,&yymsp[-5].minor);
  yy_destructor(44,&yymsp[-4].minor);
  yy_destructor(63,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2243 "parser.c" */
        break;
      case 111:
/* #line 1061 "parser.y" */
{
	yygotominor.yy92 = phql_ret_func_call(yymsp[-4].minor.yy0, yymsp[-1].minor.yy92, yymsp[-2].minor.yy92);
  yy_destructor(44,&yymsp[-3].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2252 "parser.c" */
        break;
      case 112:
/* #line 1067 "parser.y" */
{
	yygotominor.yy92 = phql_ret_distinct();
  yy_destructor(28,&yymsp[0].minor);
}
/* #line 2260 "parser.c" */
        break;
      case 120:
/* #line 1105 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_ISNULL, yymsp[-2].minor.yy92, NULL);
  yy_destructor(21,&yymsp[-1].minor);
  yy_destructor(64,&yymsp[0].minor);
}
/* #line 2269 "parser.c" */
        break;
      case 121:
/* #line 1109 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_ISNOTNULL, yymsp[-3].minor.yy92, NULL);
  yy_destructor(21,&yymsp[-2].minor);
  yy_destructor(23,&yymsp[-1].minor);
  yy_destructor(64,&yymsp[0].minor);
}
/* #line 2279 "parser.c" */
        break;
      case 122:
/* #line 1113 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_BETWEEN, yymsp[-2].minor.yy92, yymsp[0].minor.yy92);
  yy_destructor(2,&yymsp[-1].minor);
}
/* #line 2287 "parser.c" */
        break;
      case 123:
/* #line 1117 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_NOT, NULL, yymsp[0].minor.yy92);
  yy_destructor(23,&yymsp[-1].minor);
}
/* #line 2295 "parser.c" */
        break;
      case 124:
/* #line 1121 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_BITWISE_NOT, NULL, yymsp[0].minor.yy92);
  yy_destructor(24,&yymsp[-1].minor);
}
/* #line 2303 "parser.c" */
        break;
      case 125:
/* #line 1125 "parser.y" */
{
	yygotominor.yy92 = phql_ret_expr(PHQL_T_ENCLOSED, yymsp[-1].minor.yy92, NULL);
  yy_destructor(44,&yymsp[-2].minor);
  yy_destructor(45,&yymsp[0].minor);
}
/* #line 2312 "parser.c" */
        break;
      case 128:
/* #line 1137 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_STRING, yymsp[0].minor.yy0);
}
/* #line 2319 "parser.c" */
        break;
      case 129:
/* #line 1141 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_DOUBLE, yymsp[0].minor.yy0);
}
/* #line 2326 "parser.c" */
        break;
      case 130:
/* #line 1145 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_NULL, NULL);
  yy_destructor(64,&yymsp[0].minor);
}
/* #line 2334 "parser.c" */
        break;
      case 131:
/* #line 1149 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_TRUE, NULL);
  yy_destructor(67,&yymsp[0].minor);
}
/* #line 2342 "parser.c" */
        break;
      case 132:
/* #line 1153 "parser.y" */
{
	yygotominor.yy92 = phql_ret_literal_zval(PHQL_T_FALSE, NULL);
  yy_destructor(68,&yymsp[0].minor);
}
/* #line 2350 "parser.c" */
        break;
      case 135:
/* #line 1167 "parser.y" */
{
	yygotominor.yy92 = phql_ret_qualified_name(yymsp[-4].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
  yy_destructor(69,&yymsp[-3].minor);
  yy_destructor(31,&yymsp[-1].minor);
}
/* #line 2359 "parser.c" */
        break;
      case 136:
/* #line 1171 "parser.y" */
{
	yygotominor.yy92 = phql_ret_qualified_name(yymsp[-2].minor.yy0, NULL, yymsp[0].minor.yy0);
  yy_destructor(69,&yymsp[-1].minor);
}
/* #line 2367 "parser.c" */
        break;
      case 137:
/* #line 1175 "parser.y" */
{
	yygotominor.yy92 = phql_ret_qualified_name(NULL, yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
  yy_destructor(31,&yymsp[-1].minor);
}
/* #line 2375 "parser.c" */
        break;
  };
  yygoto = yyRuleInfo[yyruleno].lhs;
  yysize = yyRuleInfo[yyruleno].nrhs;
  yypParser->yyidx -= yysize;
  yyact = yy_find_reduce_action(yypParser,yygoto);
  if( yyact < YYNSTATE ){
    yy_shift(yypParser,yyact,yygoto,&yygotominor);
  }else if( yyact == YYNSTATE + YYNRULE + 1 ){
    yy_accept(yypParser);
  }
}

static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  phql_ARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  YYMINORTYPE yyminor            /* The minor type of the error token */
){
  phql_ARG_FETCH;
#define TOKEN (yyminor.yy0)
/* #line 461 "parser.y" */

	if (status->scanner_state->start_length) {
		{

			char *token_name = NULL;
			int token_found = 0;
			unsigned int token_length;
			const phql_token_names *tokens = phql_tokens;
			uint active_token = status->scanner_state->active_token;
			uint near_length = status->scanner_state->start_length;

			if (active_token) {

				do {
					if (tokens->code == active_token) {
						token_name = tokens->name;
						token_length = tokens->length;
						token_found = 1;
						break;
					}
					++tokens;
				} while (tokens[0].code != 0);

			}

			if (!token_name) {
				token_length = strlen("UNKNOWN");
				token_name = estrndup("UNKNOWN", token_length);
				token_found = 0;
			}

			status->syntax_error_len = 96 + status->token->len + token_length + near_length + status->phql_length;;
			status->syntax_error = emalloc(sizeof(char) * status->syntax_error_len);

			if (near_length > 0) {
				if (status->token->value) {
					snprintf(status->syntax_error, status->syntax_error_len, "Syntax error, unexpected token %s(%s), near to '%s', when parsing: %s (%d)", token_name, status->token->value, status->scanner_state->start, status->phql, status->phql_length);
				} else {
					snprintf(status->syntax_error, status->syntax_error_len, "Syntax error, unexpected token %s, near to '%s', when parsing: %s (%d)", token_name, status->scanner_state->start, status->phql, status->phql_length);
				}
			} else {
				if (active_token != PHQL_T_IGNORE) {
					if (status->token->value) {
						snprintf(status->syntax_error, status->syntax_error_len, "Syntax error, unexpected token %s(%s), at the end of query, when parsing: %s (%d)", token_name, status->token->value, status->phql, status->phql_length);
					} else {
						snprintf(status->syntax_error, status->syntax_error_len, "Syntax error, unexpected token %s, at the end of query, when parsing: %s (%d)", token_name, status->phql, status->phql_length);
					}
				} else {
					snprintf(status->syntax_error, status->syntax_error_len, "Syntax error, unexpected EOF, at the end of query");
				}
				status->syntax_error[status->syntax_error_len - 1] = '\0';
			}

			if (!token_found) {
				if (token_name) {
					efree(token_name);
				}
			}
		}
	} else {
		status->syntax_error_len = strlen("Syntax error, unexpected EOF");
		status->syntax_error = estrndup("Syntax error, unexpected EOF", status->syntax_error_len);
	}

	status->status = PHQL_PARSING_FAILED;

/* #line 2484 "parser.c" */
  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  phql_ARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  phql_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "phql_Alloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
static void phql_(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  phql_TOKENTYPE yyminor       /* The value for the token */
  phql_ARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  int yyact;            /* The parser action. */
  int yyendofinput;     /* True if we are at the end of input */
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
  yyParser *yypParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  yypParser = (yyParser*)yyp;
  if( yypParser->yyidx<0 ){
    if( yymajor==0 ) return;
    yypParser->yyidx = 0;
    yypParser->yyerrcnt = -1;
    yypParser->yystack[0].stateno = 0;
    yypParser->yystack[0].major = 0;
  }
  yyminorunion.yy0 = yyminor;
  yyendofinput = (yymajor==0);
  phql_ARG_STORE;

#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sInput %s\n",yyTracePrompt,yyTokenName[yymajor]);
  }
#endif

  do{
    yyact = yy_find_shift_action(yypParser,yymajor);
    if( yyact<YYNSTATE ){
      yy_shift(yypParser,yyact,yymajor,&yyminorunion);
      yypParser->yyerrcnt--;
      if( yyendofinput && yypParser->yyidx>=0 ){
        yymajor = 0;
      }else{
        yymajor = YYNOCODE;
      }
    }else if( yyact < YYNSTATE + YYNRULE ){
      yy_reduce(yypParser,yyact-YYNSTATE);
    }else if( yyact == YY_ERROR_ACTION ){
      int yymx;
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yymx = yypParser->yystack[yypParser->yyidx].major;
      if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yymajor,&yyminorunion);
        yymajor = YYNOCODE;
      }else{
         while(
          yypParser->yyidx >= 0 &&
          yymx != YYERRORSYMBOL &&
          (yyact = yy_find_shift_action(yypParser,YYERRORSYMBOL)) >= YYNSTATE
        ){
          yy_pop_parser_stack(yypParser);
        }
        if( yypParser->yyidx < 0 || yymajor==0 ){
          yy_destructor(yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
          yymajor = YYNOCODE;
        }else if( yymx!=YYERRORSYMBOL ){
          YYMINORTYPE u2;
          u2.YYERRSYMDT = 0;
          yy_shift(yypParser,yyact,YYERRORSYMBOL,&u2);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
#else  /* YYERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yymajor,&yyminorunion);
      if( yyendofinput ){
        yy_parse_failed(yypParser);
      }
      yymajor = YYNOCODE;
#endif
    }else{
      yy_accept(yypParser);
      yymajor = YYNOCODE;
    }
  }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );
  return;
}


const phql_token_names phql_tokens[] =
{
  { SL("INTEGER"),       PHQL_T_INTEGER },
  { SL("DOUBLE"),        PHQL_T_DOUBLE },
  { SL("STRING"),        PHQL_T_STRING },
  { SL("IDENTIFIER"),    PHQL_T_IDENTIFIER },
  { SL("MINUS"),         PHQL_T_MINUS },
  { SL("+"),             PHQL_T_ADD },
  { SL("-"),             PHQL_T_SUB },
  { SL("*"),             PHQL_T_MUL },
  { SL("/"),             PHQL_T_DIV },
  { SL("&"),             PHQL_T_BITWISE_AND },
  { SL("|"),             PHQL_T_BITWISE_OR },
  { SL("%%"),            PHQL_T_MOD },
  { SL("AND"),           PHQL_T_AND },
  { SL("OR"),            PHQL_T_OR },
  { SL("LIKE"),          PHQL_T_LIKE },
  { SL("ILIKE"),         PHQL_T_ILIKE },
  { SL("DOT"),           PHQL_T_DOT },
  { SL("COLON"),         PHQL_T_COLON },
  { SL("COMMA"),         PHQL_T_COMMA },
  { SL("EQUALS"),        PHQL_T_EQUALS },
  { SL("NOT EQUALS"),    PHQL_T_NOTEQUALS },
  { SL("NOT"),           PHQL_T_NOT },
  { SL("<"),             PHQL_T_LESS },
  { SL("<="),            PHQL_T_LESSEQUAL },
  { SL(">"),             PHQL_T_GREATER },
  { SL(">="),            PHQL_T_GREATEREQUAL },
  { SL("("),             PHQL_T_PARENTHESES_OPEN },
  { SL(")"),             PHQL_T_PARENTHESES_CLOSE },
  { SL("NUMERIC PLACEHOLDER"), PHQL_T_NPLACEHOLDER },
  { SL("STRING PLACEHOLDER"),  PHQL_T_SPLACEHOLDER },
  { SL("UPDATE"),        PHQL_T_UPDATE },
  { SL("SET"),           PHQL_T_SET },
  { SL("WHERE"),         PHQL_T_WHERE },
  { SL("DELETE"),        PHQL_T_DELETE },
  { SL("FROM"),          PHQL_T_FROM },
  { SL("AS"),            PHQL_T_AS },
  { SL("INSERT"),        PHQL_T_INSERT },
  { SL("INTO"),          PHQL_T_INTO },
  { SL("VALUES"),        PHQL_T_VALUES },
  { SL("SELECT"),        PHQL_T_SELECT },
  { SL("ORDER"),         PHQL_T_ORDER },
  { SL("BY"),            PHQL_T_BY },
  { SL("LIMIT"),         PHQL_T_LIMIT },
  { SL("OFFSET"),        PHQL_T_OFFSET },
  { SL("GROUP"),         PHQL_T_GROUP },
  { SL("HAVING"),        PHQL_T_HAVING },
  { SL("IN"),            PHQL_T_IN },
  { SL("ON"),            PHQL_T_ON },
  { SL("INNER"),         PHQL_T_INNER },
  { SL("JOIN"),          PHQL_T_JOIN },
  { SL("LEFT"),          PHQL_T_LEFT },
  { SL("RIGHT"),         PHQL_T_RIGHT },
  { SL("IS"),            PHQL_T_IS },
  { SL("NULL"),          PHQL_T_NULL },
  { SL("NOT IN"),        PHQL_T_NOTIN },
  { SL("CROSS"),         PHQL_T_CROSS },
  { SL("OUTER"),         PHQL_T_OUTER },
  { SL("FULL"),          PHQL_T_FULL },
  { SL("ASC"),           PHQL_T_ASC },
  { SL("DESC"),          PHQL_T_DESC },
  { SL("BETWEEN"),       PHQL_T_BETWEEN },
  { SL("DISTINCT"),      PHQL_T_DISTINCT },
  { SL("AGAINST"),       PHQL_T_AGAINST },
  { SL("CAST"),          PHQL_T_CAST },
  { SL("CONVERT"),       PHQL_T_CONVERT },
  { SL("USING"),         PHQL_T_USING },
  { SL("ALL"),           PHQL_T_ALL },
  { NULL, 0, 0 }
};

static void *phql_wrapper_alloc(size_t bytes){
	return emalloc(bytes);
}

static void phql_wrapper_free(void *pointer){
	efree(pointer);
}

static void phql_parse_with_token(void* phql_parser, int opcode, int parsercode, phql_scanner_token *token, phql_parser_status *parser_status){

	phql_parser_token *pToken;

	pToken = emalloc(sizeof(phql_parser_token));
	pToken->opcode = opcode;
	pToken->token = token->value;
	pToken->token_len = token->len;
	pToken->free_flag = 1;
	phql_(phql_parser, parsercode, pToken, parser_status);

	token->value = NULL;
	token->len = 0;
}

static void phql_scanner_error_msg(phql_parser_status *parser_status, zval **error_msg TSRMLS_DC){

	char *error = NULL, *error_part;
	unsigned int length;
	phql_scanner_state *state = parser_status->scanner_state;

	MAKE_STD_ZVAL(*error_msg);
	if (state->start) {
		length = 64 + state->start_length + parser_status->phql_length;
		error = emalloc(sizeof(char) * length);
		if (state->start_length > 16) {
			error_part = estrndup(state->start, 16);
			snprintf(error, length, "Scanning error before '%s...' when parsing: %s (%d)", error_part, parser_status->phql, parser_status->phql_length);
			efree(error_part);
		} else {
			snprintf(error, length, "Scanning error before '%s' when parsing: %s (%d)", state->start, parser_status->phql, parser_status->phql_length);
		}
		error[length - 1] = '\0';
		ZVAL_STRING(*error_msg, error, 1);
	} else {
		ZVAL_STRING(*error_msg, "Scanning error near to EOF", 1);
	}

	if (error) {
		efree(error);
	}
}

static int phql_parse_phql(zval *result, zval *phql TSRMLS_DC) {

	zval *error_msg = NULL;

	ZVAL_NULL(result);

	if (phql_internal_parse_phql(&result, Z_STRVAL_P(phql), Z_STRLEN_P(phql), &error_msg TSRMLS_CC) == FAILURE) {
		if (likely(error_msg != NULL)) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, Z_STRVAL_P(error_msg));
			zval_ptr_dtor(&error_msg);
		}
		else {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_model_exception_ce, "There was an error parsing PHQL");
		}

		return FAILURE;
	}

	return SUCCESS;
}

static int phql_internal_parse_phql(zval **result, char *phql, unsigned int phql_length, zval **error_msg TSRMLS_DC) {

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;
	phql_parser_status *parser_status = NULL;
	int scanner_status, status = SUCCESS, error_length, cache_level;
	phql_scanner_state *state;
	phql_scanner_token token;
	unsigned long phql_key = 0;
	void* phql_parser;
	char *error;
	zval **temp_ast;

	if (!phql) {
		MAKE_STD_ZVAL(*error_msg);
		ZVAL_STRING(*error_msg, "PHQL statement cannot be NULL", 1);
		return FAILURE;
	}

	cache_level = phalcon_globals_ptr->orm.cache_level;
	if (cache_level >= 0) {

		phql_key = zend_inline_hash_func(phql, phql_length + 1);

		if (phalcon_globals_ptr->orm.parser_cache != NULL) {
			if (zend_hash_index_find(phalcon_globals_ptr->orm.parser_cache, phql_key, (void**) &temp_ast) == SUCCESS) {
				ZVAL_ZVAL(*result, *temp_ast, 1, 0);
				Z_SET_REFCOUNT_P(*result, 1);
				return SUCCESS;
			}
		}
	}

	phql_parser = phql_Alloc(phql_wrapper_alloc);
	if (unlikely(!phql_parser)) {
		MAKE_STD_ZVAL(*error_msg);
		ZVAL_STRING(*error_msg, "Memory allocation error", 1);
		return FAILURE;
	}

	parser_status = emalloc(sizeof(phql_parser_status));
	state = emalloc(sizeof(phql_scanner_state));

	parser_status->status = PHQL_PARSING_OK;
	parser_status->scanner_state = state;
	parser_status->ret = NULL;
	parser_status->syntax_error = NULL;
	parser_status->token = &token;
	parser_status->enable_literals = phalcon_globals_ptr->orm.enable_literals;
	parser_status->phql = phql;
	parser_status->phql_length = phql_length;

	state->active_token = 0;
	state->start = phql;
	state->start_length = 0;
	state->end = state->start;

	token.value = NULL;
	token.len = 0;

	while (0 <= (scanner_status = phql_get_token(state, &token))) {

		/* Calculate the 'start' length */
		state->start_length = (phql + phql_length - state->start);

		state->active_token = token.opcode;

		/* Parse the token found */
		switch (token.opcode) {

			case PHQL_T_IGNORE:
				break;

			case PHQL_T_ADD:
				phql_(phql_parser, PHQL_PLUS, NULL, parser_status);
				break;
			case PHQL_T_SUB:
				phql_(phql_parser, PHQL_MINUS, NULL, parser_status);
				break;
			case PHQL_T_MUL:
				phql_(phql_parser, PHQL_TIMES, NULL, parser_status);
				break;
			case PHQL_T_DIV:
				phql_(phql_parser, PHQL_DIVIDE, NULL, parser_status);
				break;
			case PHQL_T_MOD:
				phql_(phql_parser, PHQL_MOD, NULL, parser_status);
				break;
			case PHQL_T_AND:
				phql_(phql_parser, PHQL_AND, NULL, parser_status);
				break;
			case PHQL_T_OR:
				phql_(phql_parser, PHQL_OR, NULL, parser_status);
				break;
			case PHQL_T_EQUALS:
				phql_(phql_parser, PHQL_EQUALS, NULL, parser_status);
				break;
			case PHQL_T_NOTEQUALS:
				phql_(phql_parser, PHQL_NOTEQUALS, NULL, parser_status);
				break;
			case PHQL_T_LESS:
				phql_(phql_parser, PHQL_LESS, NULL, parser_status);
				break;
			case PHQL_T_GREATER:
				phql_(phql_parser, PHQL_GREATER, NULL, parser_status);
				break;
			case PHQL_T_GREATEREQUAL:
				phql_(phql_parser, PHQL_GREATEREQUAL, NULL, parser_status);
				break;
			case PHQL_T_LESSEQUAL:
				phql_(phql_parser, PHQL_LESSEQUAL, NULL, parser_status);
				break;
			case PHQL_T_LIKE:
				phql_(phql_parser, PHQL_LIKE, NULL, parser_status);
				break;
			case PHQL_T_ILIKE:
				phql_(phql_parser, PHQL_ILIKE, NULL, parser_status);
				break;
			case PHQL_T_NOT:
				phql_(phql_parser, PHQL_NOT, NULL, parser_status);
				break;
			case PHQL_T_BITWISE_AND:
				phql_(phql_parser, PHQL_BITWISE_AND, NULL, parser_status);
				break;
			case PHQL_T_BITWISE_OR:
				phql_(phql_parser, PHQL_BITWISE_OR, NULL, parser_status);
				break;
			case PHQL_T_BITWISE_NOT:
				phql_(phql_parser, PHQL_BITWISE_NOT, NULL, parser_status);
				break;
			case PHQL_T_BITWISE_XOR:
				phql_(phql_parser, PHQL_BITWISE_XOR, NULL, parser_status);
				break;
			case PHQL_T_AGAINST:
				phql_(phql_parser, PHQL_AGAINST, NULL, parser_status);
				break;
			case PHQL_T_DOT:
				phql_(phql_parser, PHQL_DOT, NULL, parser_status);
				break;
			case PHQL_T_COLON:
				phql_(phql_parser, PHQL_COLON, NULL, parser_status);
				break;
			case PHQL_T_COMMA:
				phql_(phql_parser, PHQL_COMMA, NULL, parser_status);
				break;

			case PHQL_T_PARENTHESES_OPEN:
				phql_(phql_parser, PHQL_PARENTHESES_OPEN, NULL, parser_status);
				break;
			case PHQL_T_PARENTHESES_CLOSE:
				phql_(phql_parser, PHQL_PARENTHESES_CLOSE, NULL, parser_status);
				break;

			case PHQL_T_INTEGER:
				if (parser_status->enable_literals) {
					phql_parse_with_token(phql_parser, PHQL_T_INTEGER, PHQL_INTEGER, &token, parser_status);
				} else {
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, "Literals are disabled in PHQL statements", 1);
					parser_status->status = PHQL_PARSING_FAILED;
				}
				break;
			case PHQL_T_DOUBLE:
				if (parser_status->enable_literals) {
					phql_parse_with_token(phql_parser, PHQL_T_DOUBLE, PHQL_DOUBLE, &token, parser_status);
				} else {
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, "Literals are disabled in PHQL statements", 1);
					parser_status->status = PHQL_PARSING_FAILED;
				}
				break;
			case PHQL_T_STRING:
				if (parser_status->enable_literals) {
					phql_parse_with_token(phql_parser, PHQL_T_STRING, PHQL_STRING, &token, parser_status);
				} else {
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, "Literals are disabled in PHQL statements", 1);
					parser_status->status = PHQL_PARSING_FAILED;
				}
				break;
			case PHQL_T_TRUE:
				if (parser_status->enable_literals) {
					phql_(phql_parser, PHQL_TRUE, NULL, parser_status);
				} else {
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, "Literals are disabled in PHQL statements", 1);
					parser_status->status = PHQL_PARSING_FAILED;
				}
				break;
			case PHQL_T_FALSE:
				if (parser_status->enable_literals) {
					phql_(phql_parser, PHQL_FALSE, NULL, parser_status);
				} else {
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, "Literals are disabled in PHQL statements", 1);
					parser_status->status = PHQL_PARSING_FAILED;
				}
				break;

			case PHQL_T_IDENTIFIER:
				phql_parse_with_token(phql_parser, PHQL_T_IDENTIFIER, PHQL_IDENTIFIER, &token, parser_status);
				break;
			case PHQL_T_NPLACEHOLDER:
				phql_parse_with_token(phql_parser, PHQL_T_NPLACEHOLDER, PHQL_NPLACEHOLDER, &token, parser_status);
				break;
			case PHQL_T_SPLACEHOLDER:
				phql_parse_with_token(phql_parser, PHQL_T_SPLACEHOLDER, PHQL_SPLACEHOLDER, &token, parser_status);
				break;

			case PHQL_T_FROM:
				phql_(phql_parser, PHQL_FROM, NULL, parser_status);
				break;
			case PHQL_T_UPDATE:
				phql_(phql_parser, PHQL_UPDATE, NULL, parser_status);
				break;
			case PHQL_T_SET:
				phql_(phql_parser, PHQL_SET, NULL, parser_status);
				break;
			case PHQL_T_WHERE:
				phql_(phql_parser, PHQL_WHERE, NULL, parser_status);
				break;
			case PHQL_T_DELETE:
				phql_(phql_parser, PHQL_DELETE, NULL, parser_status);
				break;
			case PHQL_T_INSERT:
				phql_(phql_parser, PHQL_INSERT, NULL, parser_status);
				break;
			case PHQL_T_INTO:
				phql_(phql_parser, PHQL_INTO, NULL, parser_status);
				break;
			case PHQL_T_VALUES:
				phql_(phql_parser, PHQL_VALUES, NULL, parser_status);
				break;
			case PHQL_T_SELECT:
				phql_(phql_parser, PHQL_SELECT, NULL, parser_status);
				break;
			case PHQL_T_AS:
				phql_(phql_parser, PHQL_AS, NULL, parser_status);
				break;
			case PHQL_T_ORDER:
				phql_(phql_parser, PHQL_ORDER, NULL, parser_status);
				break;
			case PHQL_T_BY:
				phql_(phql_parser, PHQL_BY, NULL, parser_status);
				break;
			case PHQL_T_LIMIT:
				phql_(phql_parser, PHQL_LIMIT, NULL, parser_status);
				break;
			case PHQL_T_OFFSET:
				phql_(phql_parser, PHQL_OFFSET, NULL, parser_status);
				break;
			case PHQL_T_GROUP:
				phql_(phql_parser, PHQL_GROUP, NULL, parser_status);
				break;
			case PHQL_T_HAVING:
				phql_(phql_parser, PHQL_HAVING, NULL, parser_status);
				break;
			case PHQL_T_ASC:
				phql_(phql_parser, PHQL_ASC, NULL, parser_status);
				break;
			case PHQL_T_DESC:
				phql_(phql_parser, PHQL_DESC, NULL, parser_status);
				break;
			case PHQL_T_IN:
				phql_(phql_parser, PHQL_IN, NULL, parser_status);
				break;
			case PHQL_T_ON:
				phql_(phql_parser, PHQL_ON, NULL, parser_status);
				break;
			case PHQL_T_INNER:
				phql_(phql_parser, PHQL_INNER, NULL, parser_status);
				break;
			case PHQL_T_JOIN:
				phql_(phql_parser, PHQL_JOIN, NULL, parser_status);
				break;
			case PHQL_T_LEFT:
				phql_(phql_parser, PHQL_LEFT, NULL, parser_status);
				break;
			case PHQL_T_RIGHT:
				phql_(phql_parser, PHQL_RIGHT, NULL, parser_status);
				break;
			case PHQL_T_CROSS:
				phql_(phql_parser, PHQL_CROSS, NULL, parser_status);
				break;
			case PHQL_T_FULL:
				phql_(phql_parser, PHQL_FULL, NULL, parser_status);
				break;
			case PHQL_T_OUTER:
				phql_(phql_parser, PHQL_OUTER, NULL, parser_status);
				break;
			case PHQL_T_IS:
				phql_(phql_parser, PHQL_IS, NULL, parser_status);
				break;
			case PHQL_T_NULL:
				phql_(phql_parser, PHQL_NULL, NULL, parser_status);
				break;
			case PHQL_T_BETWEEN:
				phql_(phql_parser, PHQL_BETWEEN, NULL, parser_status);
				break;
			case PHQL_T_DISTINCT:
				phql_(phql_parser, PHQL_DISTINCT, NULL, parser_status);
				break;
			case PHQL_T_ALL:
				phql_(phql_parser, PHQL_ALL, NULL, parser_status);
				break;
			case PHQL_T_CAST:
				phql_(phql_parser, PHQL_CAST, NULL, parser_status);
				break;
			case PHQL_T_CONVERT:
				phql_(phql_parser, PHQL_CONVERT, NULL, parser_status);
				break;
			case PHQL_T_USING:
				phql_(phql_parser, PHQL_USING, NULL, parser_status);
				break;
			default:
				parser_status->status = PHQL_PARSING_FAILED;
				error_length = sizeof(char) * 32;
				error = emalloc(error_length);
				snprintf(error, error_length, "Scanner: Unknown opcode %c", token.opcode);
				error[error_length - 1] = '\0';
				MAKE_STD_ZVAL(*error_msg);
				ZVAL_STRING(*error_msg, error, 1);
				efree(error);
				break;
		}

		if (parser_status->status != PHQL_PARSING_OK) {
			status = FAILURE;
			break;
		}

		state->end = state->start;
	}

	if (status != FAILURE) {
		switch (scanner_status) {
			case PHQL_SCANNER_RETCODE_ERR:
			case PHQL_SCANNER_RETCODE_IMPOSSIBLE:
				if (!*error_msg) {
					if (!*error_msg) {
						phql_scanner_error_msg(parser_status, error_msg TSRMLS_CC);
					}
				}
				status = FAILURE;
				break;
			default:
				phql_(phql_parser, 0, NULL, parser_status);
		}
	}

	state->active_token = 0;
	state->start = NULL;

	if (parser_status->status != PHQL_PARSING_OK) {
		status = FAILURE;
		if (parser_status->syntax_error) {
			if (!*error_msg) {
				MAKE_STD_ZVAL(*error_msg);
				ZVAL_STRING(*error_msg, parser_status->syntax_error, 1);
			}
			efree(parser_status->syntax_error);
		}
	}

	phql_Free(phql_parser, phql_wrapper_free);

	if (status != FAILURE) {
		if (parser_status->status == PHQL_PARSING_OK) {
			if (parser_status->ret) {

				if (phalcon_globals_ptr->orm.cache_level >= 1) {
					if (Z_TYPE_P(parser_status->ret) == IS_ARRAY) {
						add_assoc_long(parser_status->ret, "id", phalcon_globals_ptr->orm.unique_cache_id++);
					}
				}

				ZVAL_ZVAL(*result, parser_status->ret, 0, 0);
				ZVAL_NULL(parser_status->ret);
				zval_ptr_dtor(&parser_status->ret);

				if (cache_level >= 0) {

					if (!phalcon_globals_ptr->orm.parser_cache) {
						ALLOC_HASHTABLE(phalcon_globals_ptr->orm.parser_cache);
						zend_hash_init(phalcon_globals_ptr->orm.parser_cache, 0, NULL, ZVAL_PTR_DTOR, 0);
					}

					Z_ADDREF_PP(result);

					zend_hash_index_update(
						phalcon_globals_ptr->orm.parser_cache,
						phql_key,
						result,
						sizeof(zval *),
						NULL
					);
				}

			} else {
				efree(parser_status->ret);
			}
		}
	}

	efree(parser_status);
	efree(state);

	return status;
}


/* Generated by re2c 0.13.5 on Sat Jan 11 18:45:50 2014 */
/* #line 1 "scanner.re" */




#define YYCTYPE unsigned char
#define YYCURSOR (s->start)
#define YYLIMIT (s->end)
#define YYMARKER q

static int phql_get_token(phql_scanner_state *s, phql_scanner_token *token) {

	char *q = YYCURSOR;
	int status = PHQL_SCANNER_RETCODE_IMPOSSIBLE;

	while (PHQL_SCANNER_RETCODE_IMPOSSIBLE == status) {

		
/* #line 40 "scanner.c" */
		{
			YYCTYPE yych;
			unsigned int yyaccept = 0;
			static const unsigned char yybm[] = {
				  0,  48,  48,  48,  48,  48,  48,  48, 
				 48,  52,  52,  48,  48,  52,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 52,  48,  16,  48,  48,  48,  48,  32, 
				 48,  48,  48,  48,  48, 112,  48,  48, 
				248, 248, 248, 248, 248, 248, 248, 248, 
				248, 248,  48,  48,  48,  48,  48,  48, 
				 48, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120,  48,   8,  48,  48, 120, 
				 48, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120, 120, 120, 120, 120, 120, 
				120, 120, 120,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
				 48,  48,  48,  48,  48,  48,  48,  48, 
			};

			yych = *YYCURSOR;
			switch (yych) {
			case 0x00:	goto yy68;
			case '\t':
			case '\n':
			case '\r':
			case ' ':	goto yy66;
			case '!':	goto yy50;
			case '"':	goto yy29;
			case '%':	goto yy42;
			case '&':	goto yy62;
			case '\'':	goto yy30;
			case '(':	goto yy46;
			case ')':	goto yy48;
			case '*':	goto yy38;
			case '+':	goto yy34;
			case ',':	goto yy44;
			case '-':	goto yy36;
			case '.':	goto yy4;
			case '/':	goto yy40;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto yy2;
			case ':':	goto yy8;
			case '<':	goto yy52;
			case '=':	goto yy56;
			case '>':	goto yy54;
			case '?':	goto yy6;
			case 'A':
			case 'a':	goto yy15;
			case 'B':
			case 'b':	goto yy20;
			case 'C':
			case 'c':	goto yy27;
			case 'D':
			case 'd':	goto yy13;
			case 'E':
			case 'K':
			case 'M':
			case 'P':
			case 'Q':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'e':
			case 'k':
			case 'm':
			case 'p':
			case 'q':
			case 'x':
			case 'y':
			case 'z':	goto yy32;
			case 'F':
			case 'f':	goto yy14;
			case 'G':
			case 'g':	goto yy21;
			case 'H':
			case 'h':	goto yy22;
			case 'I':
			case 'i':	goto yy16;
			case 'J':
			case 'j':	goto yy25;
			case 'L':
			case 'l':	goto yy23;
			case 'N':
			case 'n':	goto yy24;
			case 'O':
			case 'o':	goto yy19;
			case 'R':
			case 'r':	goto yy26;
			case 'S':
			case 's':	goto yy12;
			case 'T':
			case 't':	goto yy28;
			case 'U':
			case 'u':	goto yy10;
			case 'V':
			case 'v':	goto yy17;
			case 'W':
			case 'w':	goto yy18;
			case '[':	goto yy33;
			case '\\':	goto yy31;
			case '^':	goto yy60;
			case '|':	goto yy64;
			case '~':	goto yy58;
			default:	goto yy70;
			}
yy2:
			++YYCURSOR;
			if ((yych = *YYCURSOR) == '.') goto yy291;
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy293;
yy3:
/* #line 41 "scanner.re" */
			{
			token->opcode = PHQL_T_INTEGER;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
/* #line 188 "scanner.c" */
yy4:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '/') goto yy5;
			if (yych <= '9') goto yy288;
yy5:
/* #line 353 "scanner.re" */
			{
			token->opcode = PHQL_T_DOT;
			return 0;
		}
/* #line 199 "scanner.c" */
yy6:
			++YYCURSOR;
			if (yybm[0+(yych = *YYCURSOR)] & 128) {
				goto yy285;
			}
yy7:
/* #line 448 "scanner.re" */
			{
			status = PHQL_SCANNER_RETCODE_ERR;
			break;
		}
/* #line 211 "scanner.c" */
yy8:
			yyaccept = 0;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yybm[0+yych] & 64) {
				goto yy281;
			}
yy9:
/* #line 358 "scanner.re" */
			{
			token->opcode = PHQL_T_COLON;
			return 0;
		}
/* #line 224 "scanner.c" */
yy10:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= 'S') {
				if (yych == 'P') goto yy270;
				if (yych <= 'R') goto yy87;
				goto yy271;
			} else {
				if (yych <= 'p') {
					if (yych <= 'o') goto yy87;
					goto yy270;
				} else {
					if (yych == 's') goto yy271;
					goto yy87;
				}
			}
yy11:
/* #line 301 "scanner.re" */
			{
			token->opcode = PHQL_T_IDENTIFIER;
			if ((YYCURSOR - q) > 1) {
				if (q[0] == '\\') {
					token->value = estrndup(q + 1, YYCURSOR - q - 1);
					token->len = YYCURSOR - q - 1;
				} else {
					token->value = estrndup(q, YYCURSOR - q);
					token->len = YYCURSOR - q;
				}
			} else {
				token->value = estrndup(q, YYCURSOR - q);
				token->len = YYCURSOR - q;
			}
			q = YYCURSOR;
			return 0;
		}
/* #line 259 "scanner.c" */
yy12:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy262;
			if (yych == 'e') goto yy262;
			goto yy87;
yy13:
			yych = *++YYCURSOR;
			if (yych <= 'I') {
				if (yych == 'E') goto yy245;
				if (yych <= 'H') goto yy87;
				goto yy246;
			} else {
				if (yych <= 'e') {
					if (yych <= 'd') goto yy87;
					goto yy245;
				} else {
					if (yych == 'i') goto yy246;
					goto yy87;
				}
			}
yy14:
			yych = *++YYCURSOR;
			if (yych <= 'U') {
				if (yych <= 'Q') {
					if (yych == 'A') goto yy232;
					goto yy87;
				} else {
					if (yych <= 'R') goto yy233;
					if (yych <= 'T') goto yy87;
					goto yy234;
				}
			} else {
				if (yych <= 'q') {
					if (yych == 'a') goto yy232;
					goto yy87;
				} else {
					if (yych <= 'r') goto yy233;
					if (yych == 'u') goto yy234;
					goto yy87;
				}
			}
yy15:
			yych = *++YYCURSOR;
			if (yych <= 'S') {
				if (yych <= 'L') {
					if (yych == 'G') goto yy215;
					if (yych <= 'K') goto yy87;
					goto yy216;
				} else {
					if (yych == 'N') goto yy217;
					if (yych <= 'R') goto yy87;
					goto yy218;
				}
			} else {
				if (yych <= 'l') {
					if (yych == 'g') goto yy215;
					if (yych <= 'k') goto yy87;
					goto yy216;
				} else {
					if (yych <= 'n') {
						if (yych <= 'm') goto yy87;
						goto yy217;
					} else {
						if (yych == 's') goto yy218;
						goto yy87;
					}
				}
			}
yy16:
			yych = *++YYCURSOR;
			if (yych <= 'S') {
				if (yych <= 'M') {
					if (yych == 'L') goto yy194;
					goto yy87;
				} else {
					if (yych <= 'N') goto yy195;
					if (yych <= 'R') goto yy87;
					goto yy197;
				}
			} else {
				if (yych <= 'm') {
					if (yych == 'l') goto yy194;
					goto yy87;
				} else {
					if (yych <= 'n') goto yy195;
					if (yych == 's') goto yy197;
					goto yy87;
				}
			}
yy17:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy188;
			if (yych == 'a') goto yy188;
			goto yy87;
yy18:
			yych = *++YYCURSOR;
			if (yych == 'H') goto yy183;
			if (yych == 'h') goto yy183;
			goto yy87;
yy19:
			yych = *++YYCURSOR;
			if (yych <= 'U') {
				if (yych <= 'N') {
					if (yych == 'F') goto yy164;
					if (yych <= 'M') goto yy87;
					goto yy165;
				} else {
					if (yych == 'R') goto yy167;
					if (yych <= 'T') goto yy87;
					goto yy169;
				}
			} else {
				if (yych <= 'n') {
					if (yych == 'f') goto yy164;
					if (yych <= 'm') goto yy87;
					goto yy165;
				} else {
					if (yych <= 'r') {
						if (yych <= 'q') goto yy87;
						goto yy167;
					} else {
						if (yych == 'u') goto yy169;
						goto yy87;
					}
				}
			}
yy20:
			yych = *++YYCURSOR;
			if (yych <= 'Y') {
				if (yych == 'E') goto yy155;
				if (yych <= 'X') goto yy87;
				goto yy156;
			} else {
				if (yych <= 'e') {
					if (yych <= 'd') goto yy87;
					goto yy155;
				} else {
					if (yych == 'y') goto yy156;
					goto yy87;
				}
			}
yy21:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy150;
			if (yych == 'r') goto yy150;
			goto yy87;
yy22:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy144;
			if (yych == 'a') goto yy144;
			goto yy87;
yy23:
			yych = *++YYCURSOR;
			if (yych <= 'I') {
				if (yych == 'E') goto yy132;
				if (yych <= 'H') goto yy87;
				goto yy133;
			} else {
				if (yych <= 'e') {
					if (yych <= 'd') goto yy87;
					goto yy132;
				} else {
					if (yych == 'i') goto yy133;
					goto yy87;
				}
			}
yy24:
			yych = *++YYCURSOR;
			if (yych <= 'U') {
				if (yych == 'O') goto yy125;
				if (yych <= 'T') goto yy87;
				goto yy126;
			} else {
				if (yych <= 'o') {
					if (yych <= 'n') goto yy87;
					goto yy125;
				} else {
					if (yych == 'u') goto yy126;
					goto yy87;
				}
			}
yy25:
			yych = *++YYCURSOR;
			if (yych == 'O') goto yy121;
			if (yych == 'o') goto yy121;
			goto yy87;
yy26:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy116;
			if (yych == 'i') goto yy116;
			goto yy87;
yy27:
			yych = *++YYCURSOR;
			if (yych <= 'R') {
				if (yych <= 'N') {
					if (yych == 'A') goto yy100;
					goto yy87;
				} else {
					if (yych <= 'O') goto yy101;
					if (yych <= 'Q') goto yy87;
					goto yy102;
				}
			} else {
				if (yych <= 'n') {
					if (yych == 'a') goto yy100;
					goto yy87;
				} else {
					if (yych <= 'o') goto yy101;
					if (yych == 'r') goto yy102;
					goto yy87;
				}
			}
yy28:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy96;
			if (yych == 'r') goto yy96;
			goto yy87;
yy29:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 0x00) goto yy7;
			goto yy94;
yy30:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= 0x00) goto yy7;
			goto yy89;
yy31:
			yych = *++YYCURSOR;
			if (yych <= '^') {
				if (yych <= '@') goto yy7;
				if (yych <= 'Z') goto yy86;
				goto yy7;
			} else {
				if (yych == '`') goto yy7;
				if (yych <= 'z') goto yy86;
				goto yy7;
			}
yy32:
			yych = *++YYCURSOR;
			goto yy87;
yy33:
			yyaccept = 1;
			yych = *(YYMARKER = ++YYCURSOR);
			if (yych <= '\\') {
				if (yych <= '@') goto yy7;
				if (yych == '[') goto yy7;
				goto yy81;
			} else {
				if (yych <= '_') {
					if (yych <= '^') goto yy7;
					goto yy81;
				} else {
					if (yych <= '`') goto yy7;
					if (yych <= 'z') goto yy81;
					goto yy7;
				}
			}
yy34:
			++YYCURSOR;
/* #line 328 "scanner.re" */
			{
			token->opcode = PHQL_T_ADD;
			return 0;
		}
/* #line 525 "scanner.c" */
yy36:
			++YYCURSOR;
/* #line 333 "scanner.re" */
			{
			token->opcode = PHQL_T_SUB;
			return 0;
		}
/* #line 533 "scanner.c" */
yy38:
			++YYCURSOR;
/* #line 338 "scanner.re" */
			{
			token->opcode = PHQL_T_MUL;
			return 0;
		}
/* #line 541 "scanner.c" */
yy40:
			++YYCURSOR;
/* #line 343 "scanner.re" */
			{
			token->opcode = PHQL_T_DIV;
			return 0;
		}
/* #line 549 "scanner.c" */
yy42:
			++YYCURSOR;
/* #line 348 "scanner.re" */
			{
			token->opcode = PHQL_T_MOD;
			return 0;
		}
/* #line 557 "scanner.c" */
yy44:
			++YYCURSOR;
/* #line 363 "scanner.re" */
			{
			token->opcode = PHQL_T_COMMA;
			return 0;
		}
/* #line 565 "scanner.c" */
yy46:
			++YYCURSOR;
/* #line 368 "scanner.re" */
			{
			token->opcode = PHQL_T_PARENTHESES_OPEN;
			return 0;
		}
/* #line 573 "scanner.c" */
yy48:
			++YYCURSOR;
/* #line 373 "scanner.re" */
			{
			token->opcode = PHQL_T_PARENTHESES_CLOSE;
			return 0;
		}
/* #line 581 "scanner.c" */
yy50:
			++YYCURSOR;
			if ((yych = *YYCURSOR) == '=') goto yy79;
/* #line 413 "scanner.re" */
			{
			token->opcode = PHQL_T_NOT;
			return 0;
		}
/* #line 590 "scanner.c" */
yy52:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '<') goto yy53;
			if (yych <= '=') goto yy75;
			if (yych <= '>') goto yy77;
yy53:
/* #line 398 "scanner.re" */
			{
			token->opcode = PHQL_T_LESS;
			return 0;
		}
/* #line 602 "scanner.c" */
yy54:
			++YYCURSOR;
			if ((yych = *YYCURSOR) == '=') goto yy73;
/* #line 403 "scanner.re" */
			{
			token->opcode = PHQL_T_GREATER;
			return 0;
		}
/* #line 611 "scanner.c" */
yy56:
			++YYCURSOR;
/* #line 408 "scanner.re" */
			{
			token->opcode = PHQL_T_EQUALS;
			return 0;
		}
/* #line 619 "scanner.c" */
yy58:
			++YYCURSOR;
/* #line 418 "scanner.re" */
			{
			token->opcode = PHQL_T_BITWISE_NOT;
			return 0;
		}
/* #line 627 "scanner.c" */
yy60:
			++YYCURSOR;
/* #line 423 "scanner.re" */
			{
			token->opcode = PHQL_T_BITWISE_XOR;
			return 0;
		}
/* #line 635 "scanner.c" */
yy62:
			++YYCURSOR;
/* #line 428 "scanner.re" */
			{
			token->opcode = PHQL_T_BITWISE_AND;
			return 0;
		}
/* #line 643 "scanner.c" */
yy64:
			++YYCURSOR;
/* #line 433 "scanner.re" */
			{
			token->opcode = PHQL_T_BITWISE_OR;
			return 0;
		}
/* #line 651 "scanner.c" */
yy66:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy72;
yy67:
/* #line 438 "scanner.re" */
			{
			token->opcode = PHQL_T_IGNORE;
			return 0;
		}
/* #line 662 "scanner.c" */
yy68:
			++YYCURSOR;
/* #line 443 "scanner.re" */
			{
			status = PHQL_SCANNER_RETCODE_EOF;
			break;
		}
/* #line 670 "scanner.c" */
yy70:
			yych = *++YYCURSOR;
			goto yy7;
yy71:
			++YYCURSOR;
			yych = *YYCURSOR;
yy72:
			if (yybm[0+yych] & 4) {
				goto yy71;
			}
			goto yy67;
yy73:
			++YYCURSOR;
/* #line 393 "scanner.re" */
			{
			token->opcode = PHQL_T_GREATEREQUAL;
			return 0;
		}
/* #line 689 "scanner.c" */
yy75:
			++YYCURSOR;
/* #line 388 "scanner.re" */
			{
			token->opcode = PHQL_T_LESSEQUAL;
			return 0;
		}
/* #line 697 "scanner.c" */
yy77:
			++YYCURSOR;
/* #line 383 "scanner.re" */
			{
			token->opcode = PHQL_T_NOTEQUALS;
			return 0;
		}
/* #line 705 "scanner.c" */
yy79:
			++YYCURSOR;
/* #line 378 "scanner.re" */
			{
			token->opcode = PHQL_T_NOTEQUALS;
			return 0;
		}
/* #line 713 "scanner.c" */
yy81:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yybm[0+yych] & 8) {
				goto yy81;
			}
			if (yych == ']') goto yy84;
yy83:
			YYCURSOR = YYMARKER;
			if (yyaccept <= 0) {
				goto yy9;
			} else {
				goto yy7;
			}
yy84:
			++YYCURSOR;
/* #line 320 "scanner.re" */
			{
			token->opcode = PHQL_T_IDENTIFIER;
			token->value = estrndup(q, YYCURSOR - q - 1);
			token->len = YYCURSOR - q - 1;
			q = YYCURSOR;
			return 0;
		}
/* #line 738 "scanner.c" */
yy86:
			++YYCURSOR;
			yych = *YYCURSOR;
yy87:
			if (yych <= '[') {
				if (yych <= '9') {
					if (yych <= '/') goto yy11;
					goto yy86;
				} else {
					if (yych <= '@') goto yy11;
					if (yych <= 'Z') goto yy86;
					goto yy11;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych <= '^') goto yy11;
					goto yy86;
				} else {
					if (yych <= '`') goto yy11;
					if (yych <= 'z') goto yy86;
					goto yy11;
				}
			}
yy88:
			++YYCURSOR;
			yych = *YYCURSOR;
yy89:
			if (yybm[0+yych] & 16) {
				goto yy88;
			}
			if (yych <= 0x00) goto yy83;
			if (yych <= '[') goto yy91;
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yych == '\n') goto yy83;
			goto yy88;
yy91:
			++YYCURSOR;
/* #line 292 "scanner.re" */
			{
			token->opcode = PHQL_T_STRING;
			token->value = estrndup(q, YYCURSOR - q - 1);
			token->len = YYCURSOR - q - 1;
			q = YYCURSOR;
			return 0;
		}
/* #line 786 "scanner.c" */
yy93:
			++YYCURSOR;
			yych = *YYCURSOR;
yy94:
			if (yybm[0+yych] & 32) {
				goto yy93;
			}
			if (yych <= 0x00) goto yy83;
			if (yych <= '[') goto yy91;
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yych == '\n') goto yy83;
			goto yy93;
yy96:
			yych = *++YYCURSOR;
			if (yych == 'U') goto yy97;
			if (yych != 'u') goto yy87;
yy97:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy98;
			if (yych != 'e') goto yy87;
yy98:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy99;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy99;
					if (yych <= 'z') goto yy86;
				}
			}
yy99:
/* #line 281 "scanner.re" */
			{
			token->opcode = PHQL_T_TRUE;
			return 0;
		}
/* #line 832 "scanner.c" */
yy100:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy113;
			if (yych == 's') goto yy113;
			goto yy87;
yy101:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy107;
			if (yych == 'n') goto yy107;
			goto yy87;
yy102:
			yych = *++YYCURSOR;
			if (yych == 'O') goto yy103;
			if (yych != 'o') goto yy87;
yy103:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy104;
			if (yych != 's') goto yy87;
yy104:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy105;
			if (yych != 's') goto yy87;
yy105:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy106;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy106;
					if (yych <= 'z') goto yy86;
				}
			}
yy106:
/* #line 226 "scanner.re" */
			{
			token->opcode = PHQL_T_CROSS;
			return 0;
		}
/* #line 879 "scanner.c" */
yy107:
			yych = *++YYCURSOR;
			if (yych == 'V') goto yy108;
			if (yych != 'v') goto yy87;
yy108:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy109;
			if (yych != 'e') goto yy87;
yy109:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy110;
			if (yych != 'r') goto yy87;
yy110:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy111;
			if (yych != 't') goto yy87;
yy111:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy112;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy112;
					if (yych <= 'z') goto yy86;
				}
			}
yy112:
/* #line 271 "scanner.re" */
			{
			token->opcode = PHQL_T_CONVERT;
			return 0;
		}
/* #line 920 "scanner.c" */
yy113:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy114;
			if (yych != 't') goto yy87;
yy114:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy115;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy115;
					if (yych <= 'z') goto yy86;
				}
			}
yy115:
/* #line 266 "scanner.re" */
			{
			token->opcode = PHQL_T_CAST;
			return 0;
		}
/* #line 949 "scanner.c" */
yy116:
			yych = *++YYCURSOR;
			if (yych == 'G') goto yy117;
			if (yych != 'g') goto yy87;
yy117:
			yych = *++YYCURSOR;
			if (yych == 'H') goto yy118;
			if (yych != 'h') goto yy87;
yy118:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy119;
			if (yych != 't') goto yy87;
yy119:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy120;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy120;
					if (yych <= 'z') goto yy86;
				}
			}
yy120:
/* #line 221 "scanner.re" */
			{
			token->opcode = PHQL_T_RIGHT;
			return 0;
		}
/* #line 986 "scanner.c" */
yy121:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy122;
			if (yych != 'i') goto yy87;
yy122:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy123;
			if (yych != 'n') goto yy87;
yy123:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy124;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy124;
					if (yych <= 'z') goto yy86;
				}
			}
yy124:
/* #line 206 "scanner.re" */
			{
			token->opcode = PHQL_T_JOIN;
			return 0;
		}
/* #line 1019 "scanner.c" */
yy125:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy130;
			if (yych == 't') goto yy130;
			goto yy87;
yy126:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy127;
			if (yych != 'l') goto yy87;
yy127:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy128;
			if (yych != 'l') goto yy87;
yy128:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy129;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy129;
					if (yych <= 'z') goto yy86;
				}
			}
yy129:
/* #line 246 "scanner.re" */
			{
			token->opcode = PHQL_T_NULL;
			return 0;
		}
/* #line 1057 "scanner.c" */
yy130:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy131;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy131;
					if (yych <= 'z') goto yy86;
				}
			}
yy131:
/* #line 166 "scanner.re" */
			{
			token->opcode = PHQL_T_NOT;
			return 0;
		}
/* #line 1082 "scanner.c" */
yy132:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy141;
			if (yych == 'f') goto yy141;
			goto yy87;
yy133:
			yych = *++YYCURSOR;
			if (yych <= 'M') {
				if (yych == 'K') goto yy135;
				if (yych <= 'L') goto yy87;
			} else {
				if (yych <= 'k') {
					if (yych <= 'j') goto yy87;
					goto yy135;
				} else {
					if (yych != 'm') goto yy87;
				}
			}
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy138;
			if (yych == 'i') goto yy138;
			goto yy87;
yy135:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy136;
			if (yych != 'e') goto yy87;
yy136:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy137;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy137;
					if (yych <= 'z') goto yy86;
				}
			}
yy137:
/* #line 181 "scanner.re" */
			{
			token->opcode = PHQL_T_LIKE;
			return 0;
		}
/* #line 1133 "scanner.c" */
yy138:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy139;
			if (yych != 't') goto yy87;
yy139:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy140;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy140;
					if (yych <= 'z') goto yy86;
				}
			}
yy140:
/* #line 156 "scanner.re" */
			{
			token->opcode = PHQL_T_LIMIT;
			return 0;
		}
/* #line 1162 "scanner.c" */
yy141:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy142;
			if (yych != 't') goto yy87;
yy142:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy143;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy143;
					if (yych <= 'z') goto yy86;
				}
			}
yy143:
/* #line 216 "scanner.re" */
			{
			token->opcode = PHQL_T_LEFT;
			return 0;
		}
/* #line 1191 "scanner.c" */
yy144:
			yych = *++YYCURSOR;
			if (yych == 'V') goto yy145;
			if (yych != 'v') goto yy87;
yy145:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy146;
			if (yych != 'i') goto yy87;
yy146:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy147;
			if (yych != 'n') goto yy87;
yy147:
			yych = *++YYCURSOR;
			if (yych == 'G') goto yy148;
			if (yych != 'g') goto yy87;
yy148:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy149;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy149;
					if (yych <= 'z') goto yy86;
				}
			}
yy149:
/* #line 151 "scanner.re" */
			{
			token->opcode = PHQL_T_HAVING;
			return 0;
		}
/* #line 1232 "scanner.c" */
yy150:
			yych = *++YYCURSOR;
			if (yych == 'O') goto yy151;
			if (yych != 'o') goto yy87;
yy151:
			yych = *++YYCURSOR;
			if (yych == 'U') goto yy152;
			if (yych != 'u') goto yy87;
yy152:
			yych = *++YYCURSOR;
			if (yych == 'P') goto yy153;
			if (yych != 'p') goto yy87;
yy153:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy154;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy154;
					if (yych <= 'z') goto yy86;
				}
			}
yy154:
/* #line 146 "scanner.re" */
			{
			token->opcode = PHQL_T_GROUP;
			return 0;
		}
/* #line 1269 "scanner.c" */
yy155:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy158;
			if (yych == 't') goto yy158;
			goto yy87;
yy156:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy157;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy157;
					if (yych <= 'z') goto yy86;
				}
			}
yy157:
/* #line 131 "scanner.re" */
			{
			token->opcode = PHQL_T_BY;
			return 0;
		}
/* #line 1299 "scanner.c" */
yy158:
			yych = *++YYCURSOR;
			if (yych == 'W') goto yy159;
			if (yych != 'w') goto yy87;
yy159:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy160;
			if (yych != 'e') goto yy87;
yy160:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy161;
			if (yych != 'e') goto yy87;
yy161:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy162;
			if (yych != 'n') goto yy87;
yy162:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy163;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy163;
					if (yych <= 'z') goto yy86;
				}
			}
yy163:
/* #line 261 "scanner.re" */
			{
			token->opcode = PHQL_T_BETWEEN;
			return 0;
		}
/* #line 1340 "scanner.c" */
yy164:
			yych = *++YYCURSOR;
			if (yych == 'F') goto yy178;
			if (yych == 'f') goto yy178;
			goto yy87;
yy165:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy166;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy166;
					if (yych <= 'z') goto yy86;
				}
			}
yy166:
/* #line 201 "scanner.re" */
			{
			token->opcode = PHQL_T_ON;
			return 0;
		}
/* #line 1370 "scanner.c" */
yy167:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '@') {
					if (yych <= '/') goto yy168;
					if (yych <= '9') goto yy86;
				} else {
					if (yych == 'D') goto yy174;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '`') {
					if (yych <= '\\') goto yy86;
					if (yych == '_') goto yy86;
				} else {
					if (yych == 'd') goto yy174;
					if (yych <= 'z') goto yy86;
				}
			}
yy168:
/* #line 176 "scanner.re" */
			{
			token->opcode = PHQL_T_OR;
			return 0;
		}
/* #line 1396 "scanner.c" */
yy169:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy170;
			if (yych != 't') goto yy87;
yy170:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy171;
			if (yych != 'e') goto yy87;
yy171:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy172;
			if (yych != 'r') goto yy87;
yy172:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy173;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy173;
					if (yych <= 'z') goto yy86;
				}
			}
yy173:
/* #line 231 "scanner.re" */
			{
			token->opcode = PHQL_T_OUTER;
			return 0;
		}
/* #line 1433 "scanner.c" */
yy174:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy175;
			if (yych != 'e') goto yy87;
yy175:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy176;
			if (yych != 'r') goto yy87;
yy176:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy177;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy177;
					if (yych <= 'z') goto yy86;
				}
			}
yy177:
/* #line 126 "scanner.re" */
			{
			token->opcode = PHQL_T_ORDER;
			return 0;
		}
/* #line 1466 "scanner.c" */
yy178:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy179;
			if (yych != 's') goto yy87;
yy179:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy180;
			if (yych != 'e') goto yy87;
yy180:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy181;
			if (yych != 't') goto yy87;
yy181:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy182;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy182;
					if (yych <= 'z') goto yy86;
				}
			}
yy182:
/* #line 161 "scanner.re" */
			{
			token->opcode = PHQL_T_OFFSET;
			return 0;
		}
/* #line 1503 "scanner.c" */
yy183:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy184;
			if (yych != 'e') goto yy87;
yy184:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy185;
			if (yych != 'r') goto yy87;
yy185:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy186;
			if (yych != 'e') goto yy87;
yy186:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy187;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy187;
					if (yych <= 'z') goto yy86;
				}
			}
yy187:
/* #line 116 "scanner.re" */
			{
			token->opcode = PHQL_T_WHERE;
			return 0;
		}
/* #line 1540 "scanner.c" */
yy188:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy189;
			if (yych != 'l') goto yy87;
yy189:
			yych = *++YYCURSOR;
			if (yych == 'U') goto yy190;
			if (yych != 'u') goto yy87;
yy190:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy191;
			if (yych != 'e') goto yy87;
yy191:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy192;
			if (yych != 's') goto yy87;
yy192:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy193;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy193;
					if (yych <= 'z') goto yy86;
				}
			}
yy193:
/* #line 111 "scanner.re" */
			{
			token->opcode = PHQL_T_VALUES;
			return 0;
		}
/* #line 1581 "scanner.c" */
yy194:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy211;
			if (yych == 'i') goto yy211;
			goto yy87;
yy195:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= 'N') {
					if (yych <= '9') {
						if (yych >= '0') goto yy86;
					} else {
						if (yych <= '@') goto yy196;
						if (yych <= 'M') goto yy86;
						goto yy201;
					}
				} else {
					if (yych <= 'S') {
						if (yych <= 'R') goto yy86;
						goto yy199;
					} else {
						if (yych <= 'T') goto yy200;
						if (yych <= 'Z') goto yy86;
					}
				}
			} else {
				if (yych <= 'm') {
					if (yych <= '^') {
						if (yych <= '\\') goto yy86;
					} else {
						if (yych != '`') goto yy86;
					}
				} else {
					if (yych <= 's') {
						if (yych <= 'n') goto yy201;
						if (yych <= 'r') goto yy86;
						goto yy199;
					} else {
						if (yych <= 't') goto yy200;
						if (yych <= 'z') goto yy86;
					}
				}
			}
yy196:
/* #line 196 "scanner.re" */
			{
			token->opcode = PHQL_T_IN;
			return 0;
		}
/* #line 1631 "scanner.c" */
yy197:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy198;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy198;
					if (yych <= 'z') goto yy86;
				}
			}
yy198:
/* #line 241 "scanner.re" */
			{
			token->opcode = PHQL_T_IS;
			return 0;
		}
/* #line 1656 "scanner.c" */
yy199:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy207;
			if (yych == 'e') goto yy207;
			goto yy87;
yy200:
			yych = *++YYCURSOR;
			if (yych == 'O') goto yy205;
			if (yych == 'o') goto yy205;
			goto yy87;
yy201:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy202;
			if (yych != 'e') goto yy87;
yy202:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy203;
			if (yych != 'r') goto yy87;
yy203:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy204;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy204;
					if (yych <= 'z') goto yy86;
				}
			}
yy204:
/* #line 211 "scanner.re" */
			{
			token->opcode = PHQL_T_INNER;
			return 0;
		}
/* #line 1699 "scanner.c" */
yy205:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy206;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy206;
					if (yych <= 'z') goto yy86;
				}
			}
yy206:
/* #line 106 "scanner.re" */
			{
			token->opcode = PHQL_T_INTO;
			return 0;
		}
/* #line 1724 "scanner.c" */
yy207:
			yych = *++YYCURSOR;
			if (yych == 'R') goto yy208;
			if (yych != 'r') goto yy87;
yy208:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy209;
			if (yych != 't') goto yy87;
yy209:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy210;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy210;
					if (yych <= 'z') goto yy86;
				}
			}
yy210:
/* #line 101 "scanner.re" */
			{
			token->opcode = PHQL_T_INSERT;
			return 0;
		}
/* #line 1757 "scanner.c" */
yy211:
			yych = *++YYCURSOR;
			if (yych == 'K') goto yy212;
			if (yych != 'k') goto yy87;
yy212:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy213;
			if (yych != 'e') goto yy87;
yy213:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy214;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy214;
					if (yych <= 'z') goto yy86;
				}
			}
yy214:
/* #line 186 "scanner.re" */
			{
			token->opcode = PHQL_T_ILIKE;
			return 0;
		}
/* #line 1790 "scanner.c" */
yy215:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy226;
			if (yych == 'a') goto yy226;
			goto yy87;
yy216:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy224;
			if (yych == 'l') goto yy224;
			goto yy87;
yy217:
			yych = *++YYCURSOR;
			if (yych == 'D') goto yy222;
			if (yych == 'd') goto yy222;
			goto yy87;
yy218:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '@') {
					if (yych <= '/') goto yy219;
					if (yych <= '9') goto yy86;
				} else {
					if (yych == 'C') goto yy220;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '`') {
					if (yych <= '\\') goto yy86;
					if (yych == '_') goto yy86;
				} else {
					if (yych == 'c') goto yy220;
					if (yych <= 'z') goto yy86;
				}
			}
yy219:
/* #line 96 "scanner.re" */
			{
			token->opcode = PHQL_T_AS;
			return 0;
		}
/* #line 1831 "scanner.c" */
yy220:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy221;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy221;
					if (yych <= 'z') goto yy86;
				}
			}
yy221:
/* #line 136 "scanner.re" */
			{
			token->opcode = PHQL_T_ASC;
			return 0;
		}
/* #line 1856 "scanner.c" */
yy222:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy223;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy223;
					if (yych <= 'z') goto yy86;
				}
			}
yy223:
/* #line 171 "scanner.re" */
			{
			token->opcode = PHQL_T_AND;
			return 0;
		}
/* #line 1881 "scanner.c" */
yy224:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy225;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy225;
					if (yych <= 'z') goto yy86;
				}
			}
yy225:
/* #line 256 "scanner.re" */
			{
			token->opcode = PHQL_T_ALL;
			return 0;
		}
/* #line 1906 "scanner.c" */
yy226:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy227;
			if (yych != 'i') goto yy87;
yy227:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy228;
			if (yych != 'n') goto yy87;
yy228:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy229;
			if (yych != 's') goto yy87;
yy229:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy230;
			if (yych != 't') goto yy87;
yy230:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy231;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy231;
					if (yych <= 'z') goto yy86;
				}
			}
yy231:
/* #line 191 "scanner.re" */
			{
			token->opcode = PHQL_T_AGAINST;
			return 0;
		}
/* #line 1947 "scanner.c" */
yy232:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy241;
			if (yych == 'l') goto yy241;
			goto yy87;
yy233:
			yych = *++YYCURSOR;
			if (yych == 'O') goto yy238;
			if (yych == 'o') goto yy238;
			goto yy87;
yy234:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy235;
			if (yych != 'l') goto yy87;
yy235:
			yych = *++YYCURSOR;
			if (yych == 'L') goto yy236;
			if (yych != 'l') goto yy87;
yy236:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy237;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy237;
					if (yych <= 'z') goto yy86;
				}
			}
yy237:
/* #line 236 "scanner.re" */
			{
			token->opcode = PHQL_T_FULL;
			return 0;
		}
/* #line 1990 "scanner.c" */
yy238:
			yych = *++YYCURSOR;
			if (yych == 'M') goto yy239;
			if (yych != 'm') goto yy87;
yy239:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy240;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy240;
					if (yych <= 'z') goto yy86;
				}
			}
yy240:
/* #line 91 "scanner.re" */
			{
			token->opcode = PHQL_T_FROM;
			return 0;
		}
/* #line 2019 "scanner.c" */
yy241:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy242;
			if (yych != 's') goto yy87;
yy242:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy243;
			if (yych != 'e') goto yy87;
yy243:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy244;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy244;
					if (yych <= 'z') goto yy86;
				}
			}
yy244:
/* #line 286 "scanner.re" */
			{
			token->opcode = PHQL_T_FALSE;
			return 0;
		}
/* #line 2052 "scanner.c" */
yy245:
			yych = *++YYCURSOR;
			if (yych <= 'S') {
				if (yych == 'L') goto yy254;
				if (yych <= 'R') goto yy87;
				goto yy255;
			} else {
				if (yych <= 'l') {
					if (yych <= 'k') goto yy87;
					goto yy254;
				} else {
					if (yych == 's') goto yy255;
					goto yy87;
				}
			}
yy246:
			yych = *++YYCURSOR;
			if (yych == 'S') goto yy247;
			if (yych != 's') goto yy87;
yy247:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy248;
			if (yych != 't') goto yy87;
yy248:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy249;
			if (yych != 'i') goto yy87;
yy249:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy250;
			if (yych != 'n') goto yy87;
yy250:
			yych = *++YYCURSOR;
			if (yych == 'C') goto yy251;
			if (yych != 'c') goto yy87;
yy251:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy252;
			if (yych != 't') goto yy87;
yy252:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy253;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy253;
					if (yych <= 'z') goto yy86;
				}
			}
yy253:
/* #line 251 "scanner.re" */
			{
			token->opcode = PHQL_T_DISTINCT;
			return 0;
		}
/* #line 2116 "scanner.c" */
yy254:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy258;
			if (yych == 'e') goto yy258;
			goto yy87;
yy255:
			yych = *++YYCURSOR;
			if (yych == 'C') goto yy256;
			if (yych != 'c') goto yy87;
yy256:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy257;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy257;
					if (yych <= 'z') goto yy86;
				}
			}
yy257:
/* #line 141 "scanner.re" */
			{
			token->opcode = PHQL_T_DESC;
			return 0;
		}
/* #line 2150 "scanner.c" */
yy258:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy259;
			if (yych != 't') goto yy87;
yy259:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy260;
			if (yych != 'e') goto yy87;
yy260:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy261;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy261;
					if (yych <= 'z') goto yy86;
				}
			}
yy261:
/* #line 86 "scanner.re" */
			{
			token->opcode = PHQL_T_DELETE;
			return 0;
		}
/* #line 2183 "scanner.c" */
yy262:
			yych = *++YYCURSOR;
			if (yych <= 'T') {
				if (yych == 'L') goto yy265;
				if (yych <= 'S') goto yy87;
			} else {
				if (yych <= 'l') {
					if (yych <= 'k') goto yy87;
					goto yy265;
				} else {
					if (yych != 't') goto yy87;
				}
			}
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy264;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy264;
					if (yych <= 'z') goto yy86;
				}
			}
yy264:
/* #line 81 "scanner.re" */
			{
			token->opcode = PHQL_T_SET;
			return 0;
		}
/* #line 2220 "scanner.c" */
yy265:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy266;
			if (yych != 'e') goto yy87;
yy266:
			yych = *++YYCURSOR;
			if (yych == 'C') goto yy267;
			if (yych != 'c') goto yy87;
yy267:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy268;
			if (yych != 't') goto yy87;
yy268:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy269;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy269;
					if (yych <= 'z') goto yy86;
				}
			}
yy269:
/* #line 121 "scanner.re" */
			{
			token->opcode = PHQL_T_SELECT;
			return 0;
		}
/* #line 2257 "scanner.c" */
yy270:
			yych = *++YYCURSOR;
			if (yych == 'D') goto yy276;
			if (yych == 'd') goto yy276;
			goto yy87;
yy271:
			yych = *++YYCURSOR;
			if (yych == 'I') goto yy272;
			if (yych != 'i') goto yy87;
yy272:
			yych = *++YYCURSOR;
			if (yych == 'N') goto yy273;
			if (yych != 'n') goto yy87;
yy273:
			yych = *++YYCURSOR;
			if (yych == 'G') goto yy274;
			if (yych != 'g') goto yy87;
yy274:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy275;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy275;
					if (yych <= 'z') goto yy86;
				}
			}
yy275:
/* #line 276 "scanner.re" */
			{
			token->opcode = PHQL_T_USING;
			return 0;
		}
/* #line 2299 "scanner.c" */
yy276:
			yych = *++YYCURSOR;
			if (yych == 'A') goto yy277;
			if (yych != 'a') goto yy87;
yy277:
			yych = *++YYCURSOR;
			if (yych == 'T') goto yy278;
			if (yych != 't') goto yy87;
yy278:
			yych = *++YYCURSOR;
			if (yych == 'E') goto yy279;
			if (yych != 'e') goto yy87;
yy279:
			++YYCURSOR;
			if ((yych = *YYCURSOR) <= '[') {
				if (yych <= '9') {
					if (yych >= '0') goto yy86;
				} else {
					if (yych <= '@') goto yy280;
					if (yych <= 'Z') goto yy86;
				}
			} else {
				if (yych <= '_') {
					if (yych <= '\\') goto yy86;
					if (yych >= '_') goto yy86;
				} else {
					if (yych <= '`') goto yy280;
					if (yych <= 'z') goto yy86;
				}
			}
yy280:
/* #line 76 "scanner.re" */
			{
			token->opcode = PHQL_T_UPDATE;
			return 0;
		}
/* #line 2336 "scanner.c" */
yy281:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yybm[0+yych] & 64) {
				goto yy281;
			}
			if (yych != ':') goto yy83;
			++YYCURSOR;
/* #line 68 "scanner.re" */
			{
			token->opcode = PHQL_T_SPLACEHOLDER;
			token->value = estrndup(q, YYCURSOR - q - 1);
			token->len = YYCURSOR - q - 1;
			q = YYCURSOR;
			return 0;
		}
/* #line 2353 "scanner.c" */
yy285:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yybm[0+yych] & 128) {
				goto yy285;
			}
/* #line 59 "scanner.re" */
			{
			token->opcode = PHQL_T_NPLACEHOLDER;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
/* #line 2368 "scanner.c" */
yy288:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yych <= '/') goto yy290;
			if (yych <= '9') goto yy288;
yy290:
/* #line 50 "scanner.re" */
			{
			token->opcode = PHQL_T_DOUBLE;
			token->value = estrndup(q, YYCURSOR - q);
			token->len = YYCURSOR - q;
			q = YYCURSOR;
			return 0;
		}
/* #line 2383 "scanner.c" */
yy291:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yych <= '/') goto yy290;
			if (yych <= '9') goto yy291;
			goto yy290;
yy293:
			++YYCURSOR;
			yych = *YYCURSOR;
			if (yych == '.') goto yy291;
			if (yych <= '/') goto yy3;
			if (yych <= '9') goto yy293;
			goto yy3;
		}
/* #line 453 "scanner.re" */

	}

	return status;
}





zend_class_entry *phalcon_mvc_model_query_status_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getModel);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getMessages);
static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, success);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_query_status___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, success)
	ZEND_ARG_INFO(0, model)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_query_status_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Query_Status, __construct, arginfo_phalcon_mvc_model_query_status___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Query_Status, getModel, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Status, getMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Query_Status, success, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_Status){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Query, Status, mvc_model_query_status, phalcon_mvc_model_query_status_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_query_status_ce, SL("_success"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_query_status_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_query_status_ce TSRMLS_CC, 1, phalcon_mvc_model_query_statusinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, __construct){

	zval *success, *model;

	phalcon_fetch_params(0, 2, 0, &success, &model);
	
	phalcon_update_property_this_quick(this_ptr, SL("_success"), success, 1784834493UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getModel){


	RETURN_MEMBER_QUICK(this_ptr, "_model", 2599397109UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, getMessages){

	zval *model;

	model = phalcon_fetch_nproperty_this(this_ptr, SL("_model"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(model) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHODW(model, "getmessages");
		return;
	}
	
	array_init(return_value);
}

static PHP_METHOD(Phalcon_Mvc_Model_Query_Status, success){


	RETURN_MEMBER_QUICK(this_ptr, "_success", 1784834493UL);
}






zend_class_entry *phalcon_mvc_model_query_statusinterface_ce;

static const zend_function_entry phalcon_mvc_model_query_statusinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_StatusInterface, getModel, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_StatusInterface, getMessages, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Query_StatusInterface, success, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Query_StatusInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model\\Query, StatusInterface, mvc_model_query_statusinterface, phalcon_mvc_model_query_statusinterface_method_entry);

	return SUCCESS;
}








#include <ext/pdo/php_pdo_driver.h>



zend_class_entry *phalcon_mvc_model_resultset_complex_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, valid);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, toArray);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, serialize);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, unserialize);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_resultset_complex___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, columnsTypes)
	ZEND_ARG_INFO(0, result)
	ZEND_ARG_INFO(0, cache)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_resultset_complex_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Resultset_Complex, __construct, arginfo_phalcon_mvc_model_resultset_complex___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Complex, valid, arginfo_iterator_valid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Complex, toArray, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Complex, serialize, arginfo_serializable_serialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Complex, unserialize, arginfo_serializable_unserialize, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset_Complex){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Resultset, Complex, mvc_model_resultset_complex, phalcon_mvc_model_resultset_ce, phalcon_mvc_model_resultset_complex_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_resultset_complex_ce, SL("_columnTypes"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_complex_ce TSRMLS_CC, 1, phalcon_mvc_model_resultsetinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, __construct){

	zval *columns_types, *result, *cache = NULL, *fetch_assoc;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &columns_types, &result, &cache);
	
	if (!cache) {
		cache = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_columnTypes"), columns_types, 204488327UL TSRMLS_CC);
	
	phalcon_update_property_this_quick(this_ptr, SL("_result"), result, 1670144931UL TSRMLS_CC);
	
	if (Z_TYPE_P(cache) != IS_NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
	}
	
	phalcon_update_property_long(this_ptr, SL("_type"), PHALCON_MVC_MODEL_RESULTSET_TYPE_PARTIAL TSRMLS_CC);
	
	if (Z_TYPE_P(result) == IS_OBJECT) {
		PHALCON_INIT_VAR(fetch_assoc);
		ZVAL_LONG(fetch_assoc, PDO_FETCH_ASSOC);
		PHALCON_CALL_METHOD(NULL, result, "setfetchmode", fetch_assoc);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, valid){

	zval *type = NULL, *row = NULL, *underscore;
	zval *empty_str, *active_row = NULL;
	zval *dirty_state, *column = NULL, *alias = NULL, *source = NULL, *attributes = NULL;
	zval *column_map = NULL, *row_model = NULL, *attribute = NULL, *column_alias = NULL;
	zval *column_value = NULL;
	zval *value = NULL, *sql_alias = NULL, *n_alias = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int i_type, is_partial;

	PHALCON_MM_GROW();

	type       = phalcon_fetch_nproperty_this(this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	i_type     = (Z_TYPE_P(type) == IS_LONG) ? Z_LVAL_P(type) : phalcon_get_intval(type);
	is_partial = (i_type == PHALCON_MVC_MODEL_RESULTSET_TYPE_PARTIAL);
	type       = NULL;

	PHALCON_INIT_VAR(row);
	if (is_partial) {
		zval *result = phalcon_fetch_nproperty_this(this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_NOT_FALSE(result)) {
			PHALCON_CALL_METHOD(&row, result, "fetch", result);
		} else {
			ZVAL_FALSE(row);
		}
	} else {
		zval *rows = phalcon_fetch_nproperty_this(this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(rows) == IS_ARRAY) { 
			phalcon_array_get_current(row, rows);
			if (Z_TYPE_P(row) == IS_OBJECT) {
				zend_hash_move_forward(Z_ARRVAL_P(rows));
			}
		} else {
			ZVAL_FALSE(row);
		}
	}
	
	if (Z_TYPE_P(row) == IS_ARRAY || Z_TYPE_P(row) == IS_OBJECT) {
	
		if (is_partial) {
	
			zval *hydrate_mode  = phalcon_fetch_nproperty_this(this_ptr, SL("_hydrateMode"), PH_NOISY TSRMLS_CC);
			zval *columns_types = phalcon_fetch_nproperty_this(this_ptr, SL("_columnTypes"), PH_NOISY TSRMLS_CC);
			int i_hydrate_mode  = phalcon_get_intval(hydrate_mode);
	
			PHALCON_INIT_VAR(underscore);
			ZVAL_STRING(underscore, "_", 1);
	
			PHALCON_INIT_VAR(empty_str);
			ZVAL_EMPTY_STRING(empty_str);
	
			PHALCON_INIT_VAR(active_row);
			switch (i_hydrate_mode) {
				case 0:
					object_init_ex(active_row, phalcon_mvc_model_row_ce);
					break;
	
				case 1:
					array_init(active_row);
					break;
	
				case 2:
				default:
					object_init(active_row);
					break;
			}
	
	
			PHALCON_INIT_VAR(dirty_state);
			ZVAL_LONG(dirty_state, 0);
	
			phalcon_is_iterable(columns_types, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(alias, ah0, hp0);
				PHALCON_GET_HVALUE(column);
	
				PHALCON_OBS_NVAR(type);
				phalcon_array_fetch_quick_string(&type, column, SS("type"), 276192743UL, PH_NOISY);
				if (PHALCON_IS_STRING(type, "object")) {
	
					PHALCON_OBS_NVAR(source);
					phalcon_array_fetch_quick_string(&source, column, SS("column"), 3545634419UL, PH_NOISY);
	
					PHALCON_OBS_NVAR(attributes);
					phalcon_array_fetch_quick_string(&attributes, column, SS("attributes"), 3318431052UL, PH_NOISY);
	
					PHALCON_OBS_NVAR(column_map);
					phalcon_array_fetch_quick_string(&column_map, column, SS("columnMap"), 672221649UL, PH_NOISY);
	
					PHALCON_INIT_NVAR(row_model);
					array_init(row_model);
	
					phalcon_is_iterable(attributes, &ah1, &hp1, 0, 0);
	
					while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
						PHALCON_GET_HVALUE(attribute);
	
						PHALCON_INIT_NVAR(column_alias);
						PHALCON_CONCAT_VVVV(column_alias, underscore, source, underscore, attribute);
	
						PHALCON_OBS_NVAR(column_value);
						phalcon_array_fetch(&column_value, row, column_alias, PH_NOISY);
						phalcon_array_update_zval(&row_model, attribute, column_value, PH_COPY | PH_SEPARATE);
	
						zend_hash_move_forward_ex(ah1, &hp1);
					}
	
					switch (phalcon_get_intval(hydrate_mode)) {
	
						case 0: {
							zval *keep_snapshots, *instance;

							if (!phalcon_array_isset_string_fetch(&keep_snapshots, column, SS("keepSnapshots"))) {
								keep_snapshots = PHALCON_GLOBAL(z_false);
							}
	
							if (!phalcon_array_isset_string_fetch(&instance, column, SS("instance"))) {
								php_error_docref(NULL TSRMLS_CC, E_NOTICE, "Undefined index: instance");
								instance = PHALCON_GLOBAL(z_null);
							}
	
							PHALCON_CALL_CE_STATIC(&value, phalcon_mvc_model_ce, "cloneresultmap", instance, row_model, column_map, dirty_state, keep_snapshots);
							break;
						}
	
						default:
							PHALCON_CALL_CE_STATIC(&value, phalcon_mvc_model_ce, "cloneresultmaphydrate", row_model, column_map, hydrate_mode);
							break;
	
					}
	
					PHALCON_OBS_NVAR(attribute);
					if (phalcon_array_isset_quick_string(column, SS("balias"), 1705826801UL)) {
						phalcon_array_fetch_quick_string(&attribute, column, SS("balias"), 1705826801UL, PH_NOISY);
					}
				} else {
					if (phalcon_array_isset_quick_string(column, SS("sqlAlias"), 2820722015UL)) {
						PHALCON_OBS_NVAR(sql_alias);
						phalcon_array_fetch_quick_string(&sql_alias, column, SS("sqlAlias"), 2820722015UL, PH_NOISY);
	
						PHALCON_OBS_NVAR(value);
						phalcon_array_fetch(&value, row, sql_alias, PH_NOISY);
					} else {
						PHALCON_OBS_NVAR(value);
						if (phalcon_array_isset(row, alias)) {
							phalcon_array_fetch(&value, row, alias, PH_NOISY);
						}
					}
	
					if (phalcon_array_isset_quick_string(column, SS("balias"), 1705826801UL)) {
						PHALCON_CPY_WRT(attribute, alias);
					} else {
						PHALCON_INIT_NVAR(n_alias);
						phalcon_fast_str_replace(n_alias, underscore, empty_str, alias);
						PHALCON_CPY_WRT(attribute, n_alias);
					}

					assert(attribute != NULL);
				}
	
				if (unlikely(!attribute)) {
					zend_throw_exception_ex(phalcon_mvc_model_exception_ce, 0 TSRMLS_CC, "Unexpected inconsistency: attribute is NULL");
					RETURN_MM();
				}
	
				switch (phalcon_get_intval(hydrate_mode)) {
	
					case 1:
						phalcon_array_update_zval(&active_row, attribute, value, PH_COPY | PH_SEPARATE);
						break;
	
					default:
						phalcon_update_property_zval_zval(active_row, attribute, value TSRMLS_CC);
						break;
	
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			phalcon_update_property_this_quick(this_ptr, SL("_activeRow"), active_row, 3086770360UL TSRMLS_CC);
		} else {
			phalcon_update_property_this_quick(this_ptr, SL("_activeRow"), row, 3086770360UL TSRMLS_CC);
		}
		RETURN_MM_TRUE;
	}
	
	phalcon_update_property_bool(this_ptr, SL("_activeRow"), 0 TSRMLS_CC);
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, toArray){

	zval *valid = NULL, *current = NULL;

	PHALCON_MM_GROW();

	array_init(return_value);
	PHALCON_CALL_METHOD(NULL, this_ptr, "rewind");
	
	while (1) {
		PHALCON_CALL_METHOD(&valid, this_ptr, "valid");
		if (!PHALCON_IS_NOT_FALSE(valid)) {
			break;
		}
	
		PHALCON_CALL_METHOD(&current, this_ptr, "current");
		phalcon_array_append(&return_value, current, 0);
		PHALCON_CALL_METHOD(NULL, this_ptr, "next");
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, serialize){

	zval *records = NULL, *cache, *column_types, *hydrate_mode;
	zval *data, *serialized;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&records, this_ptr, "toarray");
	
	cache        = phalcon_fetch_nproperty_this(this_ptr, SL("_cache"), PH_NOISY TSRMLS_CC);
	column_types = phalcon_fetch_nproperty_this(this_ptr, SL("_columnTypes"), PH_NOISY TSRMLS_CC);
	hydrate_mode = phalcon_fetch_nproperty_this(this_ptr, SL("_hydrateMode"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(data);
	array_init_size(data, 4);
	phalcon_array_update_string(&data, SL("cache"), cache, PH_COPY);
	phalcon_array_update_string(&data, SL("rows"), records, PH_COPY);
	phalcon_array_update_string(&data, SL("columnTypes"), column_types, PH_COPY);
	phalcon_array_update_string(&data, SL("hydrateMode"), hydrate_mode, PH_COPY);
	
	PHALCON_INIT_VAR(serialized);
	phalcon_serialize(serialized, &data TSRMLS_CC);
	
	if (Z_TYPE_P(serialized) != IS_STRING) {
		RETURN_MM_NULL();
	}
	
	RETURN_CTOR(serialized);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Complex, unserialize){

	zval *data, *resultset, *rows, *cache, *column_types;
	zval *hydrate_mode;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(resultset);
	phalcon_unserialize(resultset, data TSRMLS_CC);
	if (Z_TYPE_P(resultset) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
		return;
	}
	
	PHALCON_OBS_VAR(rows);
	phalcon_array_fetch_quick_string(&rows, resultset, SS("rows"), 273469616UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_rows"), rows, 3989235983UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(cache);
	phalcon_array_fetch_quick_string(&cache, resultset, SS("cache"), 4125168857UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_types);
	phalcon_array_fetch_quick_string(&column_types, resultset, SS("columnTypes"), 2207459080UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_columnTypes"), column_types, 204488327UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(hydrate_mode);
	phalcon_array_fetch_quick_string(&hydrate_mode, resultset, SS("hydrateMode"), 259755643UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_hydrateMode"), hydrate_mode, 2551752186UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}




#include <ext/pdo/php_pdo_driver.h>



zend_class_entry *phalcon_mvc_model_resultset_simple_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, valid);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, toArray);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, serialize);
static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, unserialize);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_resultset_simple___construct, 0, 0, 3)
	ZEND_ARG_INFO(0, columnMap)
	ZEND_ARG_INFO(0, model)
	ZEND_ARG_INFO(0, result)
	ZEND_ARG_INFO(0, cache)
	ZEND_ARG_INFO(0, keepSnapshots)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_resultset_simple_toarray, 0, 0, 0)
	ZEND_ARG_INFO(0, renameColumns)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_resultset_simple_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Resultset_Simple, __construct, arginfo_phalcon_mvc_model_resultset_simple___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Simple, valid, arginfo_iterator_valid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Simple, toArray, arginfo_phalcon_mvc_model_resultset_simple_toarray, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Simple, serialize, arginfo_serializable_serialize, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Resultset_Simple, unserialize, arginfo_serializable_unserialize, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Resultset_Simple){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Resultset, Simple, mvc_model_resultset_simple, phalcon_mvc_model_resultset_ce, phalcon_mvc_model_resultset_simple_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_resultset_simple_ce, SL("_model"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_resultset_simple_ce, SL("_columnMap"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_resultset_simple_ce, SL("_keepSnapshots"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_resultset_simple_ce TSRMLS_CC, 5, zend_ce_iterator, spl_ce_SeekableIterator, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_serializable);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, __construct){

	zval *column_map, *model, *result, *cache = NULL, *keep_snapshots = NULL;
	zval *fetch_assoc, *limit, *row_count = NULL, *big_resultset;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 2, &column_map, &model, &result, &cache, &keep_snapshots);
	
	if (!cache) {
		cache = PHALCON_GLOBAL(z_null);
	}
	
	if (!keep_snapshots) {
		keep_snapshots = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_result"), result, 1670144931UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_columnMap"), column_map, 1530164624UL TSRMLS_CC);
	if (Z_TYPE_P(result) != IS_OBJECT) {
		RETURN_MM_NULL();
	}
	
	PHALCON_INIT_VAR(fetch_assoc);
	ZVAL_LONG(fetch_assoc, PDO_FETCH_ASSOC);
	PHALCON_CALL_METHOD(NULL, result, "setfetchmode", fetch_assoc);
	
	PHALCON_INIT_VAR(limit);
	ZVAL_LONG(limit, 32);
	
	PHALCON_CALL_METHOD(&row_count, result, "numrows");
	
	PHALCON_INIT_VAR(big_resultset);
	is_smaller_function(big_resultset, limit, row_count TSRMLS_CC);
	if (PHALCON_IS_TRUE(big_resultset)) {
		phalcon_update_property_long(this_ptr, SL("_type"), 1 TSRMLS_CC);
	} else {
		phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_count"), row_count, 2208664173UL TSRMLS_CC);
	
	phalcon_update_property_this_quick(this_ptr, SL("_keepSnapshots"), keep_snapshots, 2428293068UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, valid){

	zval *type, *result = NULL, *row = NULL, *rows = NULL, *dirty_state, *hydrate_mode;
	zval *keep_snapshots, *column_map, *model, *active_row = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(type);
	phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(type)) {
	
		PHALCON_OBS_VAR(result);
		phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(result) == IS_OBJECT) {
			PHALCON_CALL_METHOD(&row, result, "fetch", result);
		} else {
			PHALCON_INIT_VAR(row);
			ZVAL_BOOL(row, 0);
		}
	} else {
		PHALCON_OBS_VAR(rows);
		phalcon_read_property_this(&rows, this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(rows) != IS_ARRAY) { 
	
			PHALCON_OBS_NVAR(result);
			phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(result) == IS_OBJECT) {
				PHALCON_CALL_METHOD(&rows, result, "fetchall");
				phalcon_update_property_this_quick(this_ptr, SL("_rows"), rows, 3989235983UL TSRMLS_CC);
			}
		}
	
		if (Z_TYPE_P(rows) == IS_ARRAY) { 
	
			PHALCON_INIT_NVAR(row);
			phalcon_array_get_current(row, rows);
			if (PHALCON_IS_NOT_FALSE(row)) {
				zend_hash_move_forward(Z_ARRVAL_P(rows));
			}
		} else {
			PHALCON_INIT_NVAR(row);
			ZVAL_BOOL(row, 0);
		}
	}
	
	if (Z_TYPE_P(row) != IS_ARRAY) { 
		phalcon_update_property_bool(this_ptr, SL("_activeRow"), 0 TSRMLS_CC);
		RETURN_MM_FALSE;
	}
	
	PHALCON_INIT_VAR(dirty_state);
	ZVAL_LONG(dirty_state, 0);
	
	PHALCON_OBS_VAR(hydrate_mode);
	phalcon_read_property_this(&hydrate_mode, this_ptr, SL("_hydrateMode"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(keep_snapshots);
	phalcon_read_property_this(&keep_snapshots, this_ptr, SL("_keepSnapshots"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	
	switch (phalcon_get_intval(hydrate_mode)) {
	
		case 0:
			PHALCON_OBS_VAR(model);
			phalcon_read_property_this(&model, this_ptr, SL("_model"), PH_NOISY TSRMLS_CC);
	
			PHALCON_CALL_CE_STATIC(&active_row, phalcon_mvc_model_ce, "cloneresultmap", model, row, column_map, dirty_state, keep_snapshots);
			break;
	
		default:
			PHALCON_CALL_CE_STATIC(&active_row, phalcon_mvc_model_ce, "cloneresultmaphydrate", row, column_map, hydrate_mode);
			break;
	
	}
	phalcon_update_property_this_quick(this_ptr, SL("_activeRow"), active_row, 3086770360UL TSRMLS_CC);
	RETURN_MM_TRUE;
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, toArray){

	zval *rename_columns = NULL, *type, *result = NULL, *active_row = NULL;
	zval *records = NULL, *row_count, *column_map, *renamed_records;
	zval *record = NULL, *renamed = NULL, *value = NULL, *key = NULL, *exception_message = NULL;
	zval *renamed_key = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &rename_columns);
	
	if (!rename_columns) {
		rename_columns = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_read_property_this(&type, this_ptr, SL("_type"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(type)) {
	
		PHALCON_OBS_VAR(result);
		phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(result) == IS_OBJECT) {
	
			PHALCON_OBS_VAR(active_row);
			phalcon_read_property_this(&active_row, this_ptr, SL("_activeRow"), PH_NOISY TSRMLS_CC);
	
			if (Z_TYPE_P(active_row) != IS_NULL) {
				PHALCON_CALL_METHOD(NULL, result, "execute");
			}
	
			PHALCON_CALL_METHOD(&records, result, "fetchall");
		} else {
			PHALCON_INIT_NVAR(records);
			array_init(records);
		}
	} else {
		PHALCON_OBS_NVAR(records);
		phalcon_read_property_this(&records, this_ptr, SL("_rows"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(records) != IS_ARRAY) { 
	
			PHALCON_OBS_NVAR(result);
			phalcon_read_property_this(&result, this_ptr, SL("_result"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(result) == IS_OBJECT) {
	
				PHALCON_OBS_NVAR(active_row);
				phalcon_read_property_this(&active_row, this_ptr, SL("_activeRow"), PH_NOISY TSRMLS_CC);
	
				if (Z_TYPE_P(active_row) != IS_NULL) {
					PHALCON_CALL_METHOD(NULL, result, "execute");
				}
	
				PHALCON_CALL_METHOD(&records, result, "fetchall");
				phalcon_update_property_this_quick(this_ptr, SL("_rows"), records, 3989235983UL TSRMLS_CC);
	
				PHALCON_INIT_VAR(row_count);
				phalcon_fast_count(row_count, records TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_count"), row_count, 2208664173UL TSRMLS_CC);
			}
			else {
				PHALCON_INIT_NVAR(records);
				array_init(records);
			}
		}
	}
	
	if (zend_is_true(rename_columns)) {
	
		PHALCON_OBS_VAR(column_map);
		phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(column_map) != IS_ARRAY) { 
			RETURN_CCTOR(records);
		}
	
		PHALCON_INIT_VAR(renamed_records);
		array_init(renamed_records);
		if (Z_TYPE_P(records) == IS_ARRAY) { 
	
			phalcon_is_iterable(records, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(record);
	
				PHALCON_INIT_NVAR(renamed);
				array_init(renamed);
	
				phalcon_is_iterable(record, &ah1, &hp1, 0, 0);
	
				while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
					PHALCON_GET_HKEY(key, ah1, hp1);
					PHALCON_GET_HVALUE(value);
	
					if (!phalcon_array_isset(column_map, key)) {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SVS(exception_message, "Column '", key, "' is not part of the column map");
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
						return;
					}
	
					PHALCON_OBS_NVAR(renamed_key);
					phalcon_array_fetch(&renamed_key, column_map, key, PH_NOISY);
	
					phalcon_array_update_zval(&renamed, renamed_key, value, PH_COPY | PH_SEPARATE);
	
					zend_hash_move_forward_ex(ah1, &hp1);
				}
	
				phalcon_array_append(&renamed_records, renamed, PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		RETURN_CTOR(renamed_records);
	}
	
	RETURN_CCTOR(records);
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, serialize){

	zval *rename_columns, *records = NULL, *model, *cache;
	zval *column_map, *hydrate_mode, *data;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(rename_columns);
	ZVAL_BOOL(rename_columns, 0);
	
	PHALCON_CALL_METHOD(&records, this_ptr, "toarray", rename_columns);
	
	PHALCON_OBS_VAR(model);
	phalcon_read_property_this(&model, this_ptr, SL("_model"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(cache);
	phalcon_read_property_this(&cache, this_ptr, SL("_cache"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_read_property_this(&column_map, this_ptr, SL("_columnMap"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(hydrate_mode);
	phalcon_read_property_this(&hydrate_mode, this_ptr, SL("_hydrateMode"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(data);
	array_init_size(data, 5);
	phalcon_array_update_string(&data, SL("model"), model, PH_COPY);
	phalcon_array_update_string(&data, SL("cache"), cache, PH_COPY);
	phalcon_array_update_string(&data, SL("rows"), records, PH_COPY);
	phalcon_array_update_string(&data, SL("columnMap"), column_map, PH_COPY);
	phalcon_array_update_string(&data, SL("hydrateMode"), hydrate_mode, PH_COPY);
	
	phalcon_update_property_bool(this_ptr, SL("_activeRow"), 0 TSRMLS_CC);
	
	phalcon_serialize(return_value, &data TSRMLS_CC);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Resultset_Simple, unserialize){

	zval *data, *resultset, *model, *rows, *cache, *column_map;
	zval *hydrate_mode;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	phalcon_update_property_long(this_ptr, SL("_type"), 0 TSRMLS_CC);
	
	PHALCON_INIT_VAR(resultset);
	phalcon_unserialize(resultset, data TSRMLS_CC);
	if (Z_TYPE_P(resultset) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Invalid serialization data");
		return;
	}
	
	PHALCON_OBS_VAR(model);
	phalcon_array_fetch_quick_string(&model, resultset, SS("model"), 238191286UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_model"), model, 2599397109UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(rows);
	phalcon_array_fetch_quick_string(&rows, resultset, SS("rows"), 273469616UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_rows"), rows, 3989235983UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(cache);
	phalcon_array_fetch_quick_string(&cache, resultset, SS("cache"), 4125168857UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(column_map);
	phalcon_array_fetch_quick_string(&column_map, resultset, SS("columnMap"), 672221649UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_columnMap"), column_map, 1530164624UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(hydrate_mode);
	phalcon_array_fetch_quick_string(&hydrate_mode, resultset, SS("hydrateMode"), 259755643UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_hydrateMode"), hydrate_mode, 2551752186UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_mvc_model_transaction_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Transaction, Exception, mvc_model_transaction_exception, phalcon_mvc_model_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_model_transaction_failed_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecordMessages);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecord);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction_failed___construct, 0, 0, 2)
	ZEND_ARG_INFO(0, message)
	ZEND_ARG_INFO(0, record)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_transaction_failed_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Transaction_Failed, __construct, arginfo_phalcon_mvc_model_transaction_failed___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Failed, getRecordMessages, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Failed, getRecord, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Failed){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Transaction, Failed, mvc_model_transaction_failed, phalcon_mvc_model_transaction_exception_ce, phalcon_mvc_model_transaction_failed_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_failed_ce, SL("_record"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, __construct){

	zval *message, *record;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &message, &record);
	
	phalcon_update_property_this_quick(this_ptr, SL("_record"), record, 1650960579UL TSRMLS_CC);
	PHALCON_CALL_PARENT(NULL, phalcon_mvc_model_transaction_failed_ce, this_ptr, "__construct", message);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecordMessages)
{
	zval *record = phalcon_fetch_nproperty_this(this_ptr, SL("_record"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(record) != IS_NULL) {
		PHALCON_RETURN_CALL_METHODW(record, "getmessages");
	}
	
	PHALCON_RETURN_CALL_METHODW(this_ptr, "getmessage");
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Failed, getRecord){


	RETURN_MEMBER_QUICK(this_ptr, "_record", 1650960579UL);
}






zend_class_entry *phalcon_mvc_model_transaction_manager_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, __construct);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setDI);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getDI);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setDbService);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getDbService);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setRollbackPendent);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getRollbackPendent);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, has);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, get);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getOrCreateTransaction);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollbackPendent);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, commit);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollback);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyRollback);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyCommit);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, _collectTransaction);
static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, collectTransactions);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction_manager___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction_manager_setdbservice, 0, 0, 1)
	ZEND_ARG_INFO(0, service)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction_manager_setrollbackpendent, 0, 0, 1)
	ZEND_ARG_INFO(0, rollbackPendent)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_model_transaction_manager_getorcreatetransaction, 0, 0, 0)
	ZEND_ARG_INFO(0, autoBegin)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_model_transaction_manager_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, __construct, arginfo_phalcon_mvc_model_transaction_manager___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, setDbService, arginfo_phalcon_mvc_model_transaction_manager_setdbservice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, getDbService, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, setRollbackPendent, arginfo_phalcon_mvc_model_transaction_manager_setrollbackpendent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, getRollbackPendent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, has, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, get, arginfo_phalcon_mvc_model_transaction_managerinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, getOrCreateTransaction, arginfo_phalcon_mvc_model_transaction_manager_getorcreatetransaction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, rollbackPendent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, commit, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, rollback, arginfo_phalcon_mvc_model_transaction_managerinterface_rollback, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, notifyRollback, arginfo_phalcon_mvc_model_transaction_managerinterface_notifyrollback, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, notifyCommit, arginfo_phalcon_mvc_model_transaction_managerinterface_notifycommit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, _collectTransaction, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Model_Transaction_Manager, collectTransactions, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_Manager){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Model\\Transaction, Manager, mvc_model_transaction_manager, phalcon_mvc_model_transaction_manager_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_model_transaction_manager_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_manager_ce, SL("_initialized"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_model_transaction_manager_ce, SL("_rollbackPendent"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_model_transaction_manager_ce, SL("_number"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_model_transaction_manager_ce, SL("_service"), "db", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_model_transaction_manager_ce, SL("_transactions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_model_transaction_manager_ce TSRMLS_CC, 2, phalcon_mvc_model_transaction_managerinterface_ce, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, __construct){

	zval *dependency_injector = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &dependency_injector);
	
	if (!dependency_injector || Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		dependency_injector = NULL;
		PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");
	}

	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_transaction_exception_ce, 1);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_model_transaction_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setDbService){

	zval *service;

	phalcon_fetch_params(0, 1, 0, &service);
	
	phalcon_update_property_this_quick(this_ptr, SL("_service"), service, 3205872725UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getDbService){


	RETURN_MEMBER_QUICK(this_ptr, "_service", 3205872725UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, setRollbackPendent){

	zval *rollback_pendent;

	phalcon_fetch_params(0, 1, 0, &rollback_pendent);
	
	phalcon_update_property_this_quick(this_ptr, SL("_rollbackPendent"), rollback_pendent, 1836882012UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getRollbackPendent){


	RETURN_MEMBER_QUICK(this_ptr, "_rollbackPendent", 1836882012UL);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, has){

	zval *z_zero, *number;

	z_zero = PHALCON_GLOBAL(z_zero);
	
	number = phalcon_fetch_nproperty_this(this_ptr, SL("_number"), PH_NOISY TSRMLS_CC);
	is_smaller_function(return_value, z_zero, number TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, get){

	zval *auto_begin = NULL, *initialized, *rollback_pendent = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &auto_begin);
	
	if (!auto_begin) {
		auto_begin = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_OBS_VAR(initialized);
	phalcon_read_property_this(&initialized, this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(initialized)) {
	
		PHALCON_OBS_VAR(rollback_pendent);
		phalcon_read_property_this(&rollback_pendent, this_ptr, SL("_rollbackPendent"), PH_NOISY TSRMLS_CC);
		if (zend_is_true(rollback_pendent)) {
			PHALCON_INIT_NVAR(rollback_pendent);
			array_init_size(rollback_pendent, 2);
			phalcon_array_append(&rollback_pendent, this_ptr, PH_SEPARATE);
			add_next_index_stringl(rollback_pendent, SL("rollbackPendent"), 1);
			PHALCON_CALL_FUNCTION(NULL, "register_shutdown_function", rollback_pendent);
		}
	
		phalcon_update_property_bool(this_ptr, SL("_initialized"), 1 TSRMLS_CC);
	}
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "getorcreatetransaction");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, getOrCreateTransaction){

	zval *auto_begin = NULL, *dependency_injector, *number;
	zval *transactions, *transaction = NULL, *false_value = NULL;
	zval *service;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &auto_begin);
	
	if (!auto_begin) {
		auto_begin = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_transaction_exception_ce, "A dependency injector container is required to obtain the services related to the ORM");
		return;
	}
	
	PHALCON_OBS_VAR(number);
	phalcon_read_property_this(&number, this_ptr, SL("_number"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(number)) {
	
		PHALCON_OBS_VAR(transactions);
		phalcon_read_property_this(&transactions, this_ptr, SL("_transactions"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(transactions) == IS_ARRAY) { 
	
			phalcon_is_iterable(transactions, &ah0, &hp0, 0, 1);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(transaction);
	
				if (Z_TYPE_P(transaction) == IS_OBJECT) {
					false_value = PHALCON_GLOBAL(z_false);
					PHALCON_CALL_METHOD(NULL, transaction, "setisnewtransaction", false_value);
					RETURN_CTOR(transaction);
				}
	
				zend_hash_move_backwards_ex(ah0, &hp0);
			}
	
		}
	}
	
	PHALCON_OBS_VAR(service);
	phalcon_read_property_this(&service, this_ptr, SL("_service"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(transaction);
	object_init_ex(transaction, phalcon_mvc_model_transaction_ce);
	PHALCON_CALL_METHOD(NULL, transaction, "__construct", dependency_injector, auto_begin, service);
	
	PHALCON_CALL_METHOD(NULL, transaction, "settransactionmanager", this_ptr);
	phalcon_update_property_array_append(this_ptr, SL("_transactions"), transaction TSRMLS_CC);
	phalcon_property_incr(this_ptr, SL("_number") TSRMLS_CC);
	
	RETURN_CTOR(transaction);
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollbackPendent){


	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(NULL, this_ptr, "rollback");
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, commit){

	zval *transactions, *transaction = NULL, *connection = NULL;
	zval *is_under_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(transactions);
	phalcon_read_property_this(&transactions, this_ptr, SL("_transactions"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(transactions) == IS_ARRAY) { 
	
		phalcon_is_iterable(transactions, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(transaction);
	
			PHALCON_CALL_METHOD(&connection, transaction, "getconnection");
			PHALCON_CALL_METHOD(&is_under_transaction, connection, "isundertransaction");
			if (zend_is_true(is_under_transaction)) {
				PHALCON_CALL_METHOD(NULL, connection, "commit");
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, rollback){

	zval *collect = NULL, *transactions, *transaction = NULL, *connection = NULL;
	zval *is_under_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &collect);
	
	if (!collect) {
		collect = PHALCON_GLOBAL(z_true);
	}
	
	PHALCON_OBS_VAR(transactions);
	phalcon_read_property_this(&transactions, this_ptr, SL("_transactions"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(transactions) == IS_ARRAY) { 
	
		phalcon_is_iterable(transactions, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(transaction);
	
			PHALCON_CALL_METHOD(&connection, transaction, "getconnection");
			PHALCON_CALL_METHOD(&is_under_transaction, connection, "isundertransaction");
			if (zend_is_true(is_under_transaction)) {
				PHALCON_CALL_METHOD(NULL, connection, "rollback");
				PHALCON_CALL_METHOD(NULL, connection, "close");
			}
	
			if (zend_is_true(collect)) {
				PHALCON_CALL_METHOD(NULL, this_ptr, "_collecttransaction", transaction);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyRollback){

	zval *transaction;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &transaction);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "_collecttransaction", transaction);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, notifyCommit){

	zval *transaction;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &transaction);
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "_collecttransaction", transaction);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, _collectTransaction){

	zval *transaction, *transactions, *new_transactions;
	zval *managed_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &transaction);
	
	PHALCON_OBS_VAR(transactions);
	phalcon_read_property_this(&transactions, this_ptr, SL("_transactions"), PH_NOISY TSRMLS_CC);
	if (phalcon_fast_count_ev(transactions TSRMLS_CC)) {
	
		PHALCON_INIT_VAR(new_transactions);
		array_init(new_transactions);
	
		phalcon_is_iterable(transactions, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(managed_transaction);
	
			if (PHALCON_IS_EQUAL(managed_transaction, transaction)) {
				phalcon_array_append(&new_transactions, transaction, PH_SEPARATE);
				phalcon_property_decr(this_ptr, SL("_number") TSRMLS_CC);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_transactions"), new_transactions, 3308612605UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Model_Transaction_Manager, collectTransactions){

	zval *transactions, *managed_transaction = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(transactions);
	phalcon_read_property_this(&transactions, this_ptr, SL("_transactions"), PH_NOISY TSRMLS_CC);
	if (phalcon_fast_count_ev(transactions TSRMLS_CC)) {
	
		phalcon_is_iterable(transactions, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(managed_transaction);
	
			phalcon_property_decr(this_ptr, SL("_number") TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_update_property_null(this_ptr, SL("_transactions") TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}





zend_class_entry *phalcon_mvc_model_transaction_managerinterface_ce;

static const zend_function_entry phalcon_mvc_model_transaction_managerinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, has, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, get, arginfo_phalcon_mvc_model_transaction_managerinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, rollbackPendent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, commit, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, rollback, arginfo_phalcon_mvc_model_transaction_managerinterface_rollback)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, notifyRollback, arginfo_phalcon_mvc_model_transaction_managerinterface_notifyrollback)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, notifyCommit, arginfo_phalcon_mvc_model_transaction_managerinterface_notifycommit)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Model_Transaction_ManagerInterface, collectTransactions, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Transaction_ManagerInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Model\\Transaction, ManagerInterface, mvc_model_transaction_managerinterface, phalcon_mvc_model_transaction_managerinterface_method_entry);

	return SUCCESS;
}
















zend_class_entry *phalcon_mvc_model_validator_email_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Email, validate);

static const zend_function_entry phalcon_mvc_model_validator_email_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Email, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Email){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Email, mvc_model_validator_email, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_email_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_email_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Email, validate){

	zval *record, *option = NULL, *field_name = NULL, *regs, *invalid = NULL;
	zval *value = NULL, *pattern, *match_pattern, *match_zero;
	zval *message = NULL, *type, *is_set_code = NULL, *code = NULL;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field_name, this_ptr, "getoption", option);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_VAR(regs);
	
	PHALCON_INIT_VAR(invalid);
	ZVAL_BOOL(invalid, 0);
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field_name);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	PHALCON_INIT_VAR(pattern);
	ZVAL_STRING(pattern, "/^([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22))*\\x40([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d))*$/", 1);
	
	PHALCON_INIT_VAR(match_pattern);
	RETURN_MM_ON_FAILURE(phalcon_preg_match(match_pattern, pattern, value, regs TSRMLS_CC));
	
	if (zend_is_true(match_pattern)) {
		PHALCON_OBS_VAR(match_zero);
		phalcon_array_fetch_long(&match_zero, regs, 0, PH_NOISY);
	
		is_not_equal_function(invalid, match_zero, value TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(invalid);
		ZVAL_BOOL(invalid, 1);
	}
	
	if (PHALCON_IS_TRUE(invalid)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "Value of field '", field_name, "' must have a valid e-mail format");
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Email", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field_name, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}








zend_class_entry *phalcon_mvc_model_validator_exclusionin_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Exclusionin, validate);

static const zend_function_entry phalcon_mvc_model_validator_exclusionin_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Exclusionin, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Exclusionin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Exclusionin, mvc_model_validator_exclusionin, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_exclusionin_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_exclusionin_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Exclusionin, validate){

	zval *record, *option = NULL, *field_name = NULL, *is_set = NULL, *domain = NULL;
	zval *value = NULL, *message = NULL, *joined_domain, *type, *is_set_code = NULL, *code = NULL;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field_name, this_ptr, "getoption", option);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_CALL_METHOD(&is_set, this_ptr, "issetoption", option);
	if (PHALCON_IS_FALSE(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_CALL_METHOD(&domain, this_ptr, "getoption", option);
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field_name);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	if (phalcon_fast_in_array(value, domain TSRMLS_CC)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_VAR(joined_domain);
			phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);
	
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVSV(message, "Value of field '", field_name, "' must not be part of list: ", joined_domain);
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Exclusion", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field_name, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}








zend_class_entry *phalcon_mvc_model_validator_inclusionin_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Inclusionin, validate);

static const zend_function_entry phalcon_mvc_model_validator_inclusionin_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Inclusionin, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Inclusionin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Inclusionin, mvc_model_validator_inclusionin, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_inclusionin_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_inclusionin_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Inclusionin, validate){

	zval *record, *field = NULL, *is_set = NULL, *domain = NULL;
	zval *value = NULL, *option, *message = NULL, *joined_domain, *is_set_code = NULL, *code = NULL;
	zval *type;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field, this_ptr, "getoption", option);
	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_CALL_METHOD(&is_set, this_ptr, "issetoption", option);
	if (PHALCON_IS_FALSE(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "The option 'domain' is required for this validator");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "domain", 1);
	
	PHALCON_CALL_METHOD(&domain, this_ptr, "getoption", option);
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	if (!phalcon_fast_in_array(value, domain TSRMLS_CC)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_VAR(joined_domain);
			phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);
	
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVSV(message, "Value of field '", field, "' must be part of list: ", joined_domain);
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Inclusion", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_mvc_model_validator_numericality_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Numericality, validate);

static const zend_function_entry phalcon_mvc_model_validator_numericality_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Numericality, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Numericality){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Numericality, mvc_model_validator_numericality, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_numericality_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_numericality_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Numericality, validate){

	zval *record, *option = NULL, *field = NULL, *value = NULL, *message = NULL;
	zval *type, *is_set_code = NULL, *code = NULL;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field, this_ptr, "getoption", option);
	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	if (!phalcon_is_numeric(value)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "Value of field '", field, "' must be numeric");
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Numericality", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}








zend_class_entry *phalcon_mvc_model_validator_presenceof_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_PresenceOf, validate);

static const zend_function_entry phalcon_mvc_model_validator_presenceof_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_PresenceOf, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_PresenceOf){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, PresenceOf, mvc_model_validator_presenceof, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_presenceof_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_presenceof_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_PresenceOf, validate){

	zval *record, *option = NULL, *field_name = NULL, *value = NULL, *message = NULL;
	zval *type, *is_set_code = NULL, *code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field_name, this_ptr, "getoption", option);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field_name);
	if (PHALCON_IS_EMPTY(value)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "'", field_name, "' is required");
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "PresenceOf", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field_name, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}








zend_class_entry *phalcon_mvc_model_validator_regex_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Regex, validate);

static const zend_function_entry phalcon_mvc_model_validator_regex_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Regex, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Regex){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Regex, mvc_model_validator_regex, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_regex_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_regex_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Regex, validate){

	zval *record, *option = NULL, *field_name = NULL, *is_set = NULL, *value = NULL;
	zval *failed = NULL, *matches, *pattern = NULL, *match_pattern;
	zval *match_zero, *message = NULL, *type, *is_set_code = NULL, *code = NULL;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field_name, this_ptr, "getoption", option);
	if (Z_TYPE_P(field_name) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "pattern", 1);
	
	PHALCON_CALL_METHOD(&is_set, this_ptr, "issetoption", option);
	if (!zend_is_true(is_set)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Validator requires a perl-compatible regex pattern");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field_name);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	PHALCON_INIT_VAR(failed);
	ZVAL_BOOL(failed, 0);
	
	PHALCON_INIT_VAR(matches);
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "pattern", 1);

	PHALCON_CALL_METHOD(&pattern, this_ptr, "getoption", option);
	
	PHALCON_INIT_VAR(match_pattern);
	RETURN_MM_ON_FAILURE(phalcon_preg_match(match_pattern, pattern, value, matches TSRMLS_CC));
	
	if (zend_is_true(match_pattern)) {
		PHALCON_OBS_VAR(match_zero);
		phalcon_array_fetch_long(&match_zero, matches, 0, PH_NOISY);
	
		is_not_equal_function(failed, match_zero, value TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(failed);
		ZVAL_BOOL(failed, 1);
	}
	
	if (PHALCON_IS_TRUE(failed)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "Value of field '", field_name, "' doesn't match regular expression");
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Regex", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field_name, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_mvc_model_validator_stringlength_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_StringLength, validate);

static const zend_function_entry phalcon_mvc_model_validator_stringlength_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_StringLength, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_StringLength){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, StringLength, mvc_model_validator_stringlength, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_stringlength_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_stringlength_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_StringLength, validate){

	zval *record, *option = NULL, *field = NULL, *is_set_min = NULL, *is_set_max = NULL;
	zval *value = NULL, *length = NULL, *invalid_maximum = NULL, *invalid_minimum = NULL;
	zval *maximum = NULL, *message = NULL, *type = NULL, *minimum = NULL, *is_set_code = NULL, *code = NULL;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field, this_ptr, "getoption", option);
	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "min", 1);
	
	PHALCON_CALL_METHOD(&is_set_min, this_ptr, "issetoption", option);
	
	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "max", 1);
	
	PHALCON_CALL_METHOD(&is_set_max, this_ptr, "issetoption", option);
	if (!zend_is_true(is_set_min)) {
		if (!zend_is_true(is_set_max)) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "A minimum or maximum must be set");
			return;
		}
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	if (phalcon_function_quick_exists_ex(SS("mb_strlen"), 3716840971UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_FUNCTION(&length, "mb_strlen", value);
	} else {
		PHALCON_INIT_VAR(length);
		phalcon_fast_strlen(length, value);
	}
	
	PHALCON_INIT_VAR(invalid_maximum);
	ZVAL_BOOL(invalid_maximum, 0);
	
	PHALCON_INIT_VAR(invalid_minimum);
	ZVAL_BOOL(invalid_minimum, 0);
	
	if (zend_is_true(is_set_max)) {
	
		PHALCON_INIT_NVAR(option);
		ZVAL_STRING(option, "max", 1);
	
		PHALCON_CALL_METHOD(&maximum, this_ptr, "getoption", option);
	
		is_smaller_function(invalid_maximum, maximum, length TSRMLS_CC);
		if (PHALCON_IS_TRUE(invalid_maximum)) {
	
			PHALCON_INIT_NVAR(option);
			ZVAL_STRING(option, "messageMaximum", 1);
	
			PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
			if (!zend_is_true(message)) {
				PHALCON_INIT_NVAR(message);
				PHALCON_CONCAT_SVSVS(message, "Value of field '", field, "' exceeds the maximum ", maximum, " characters");
			}
	
			PHALCON_INIT_VAR(type);
			ZVAL_STRING(type, "TooLong", 1);

			PHALCON_INIT_NVAR(option);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

			PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
			if (zend_is_true(is_set_code)) {
				PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
			} else {
				PHALCON_INIT_VAR(code);
				ZVAL_LONG(code, 0);
			}

			PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
			RETURN_MM_FALSE;
		}
	}
	
	if (zend_is_true(is_set_min)) {
	
		PHALCON_INIT_NVAR(option);
		ZVAL_STRING(option, "min", 1);
	
		PHALCON_CALL_METHOD(&minimum, this_ptr, "getoption", option);
	
		is_smaller_function(invalid_minimum, length, minimum TSRMLS_CC);
		if (PHALCON_IS_TRUE(invalid_minimum)) {
	
			PHALCON_INIT_NVAR(option);
			ZVAL_STRING(option, "messageMinimum", 1);
	
			PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
			if (!zend_is_true(message)) {
				PHALCON_INIT_NVAR(message);
				PHALCON_CONCAT_SVSVS(message, "Value of field '", field, "' is less than the minimum ", minimum, " characters");
			}
	
			PHALCON_INIT_NVAR(type);
			ZVAL_STRING(type, "TooShort", 1);

			PHALCON_INIT_NVAR(option);
			PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

			PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
			if (zend_is_true(is_set_code)) {
				PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
			} else {
				PHALCON_INIT_VAR(code);
				ZVAL_LONG(code, 0);
			}

			PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
			RETURN_MM_FALSE;
		}
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_mvc_model_validator_uniqueness_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Uniqueness, validate);

static const zend_function_entry phalcon_mvc_model_validator_uniqueness_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Uniqueness, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Uniqueness){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Uniqueness, mvc_model_validator_uniqueness, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_uniqueness_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_uniqueness_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Uniqueness, validate){

	zval *record, *option = NULL, *field = NULL, *dependency_injector = NULL;
	zval *service, *meta_data = NULL, *bind_types, *bind_data_types = NULL;
	zval *column_map = NULL, *conditions, *bind_params;
	zval *number = NULL, *compose_field = NULL, *column_field = NULL;
	zval *exception_message = NULL, *value = NULL, *compose_condition = NULL;
	zval *bind_type = NULL, *condition = NULL, *operation_made = NULL;
	zval *primary_fields = NULL, *primary_field = NULL, *attribute_field = NULL;
	zval *join_conditions, *params;
	zval *message = NULL, *join_fields, *type, *is_set_code = NULL, *code = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field, this_ptr, "getoption", option);
	PHALCON_CALL_METHOD(&dependency_injector, record, "getdi");
	
	PHALCON_INIT_VAR(service);
	ZVAL_STRING(service, "modelsMetadata", 1);
	
	PHALCON_CALL_METHOD(&meta_data, dependency_injector, "getshared", service);
	PHALCON_VERIFY_INTERFACE(meta_data, phalcon_mvc_model_metadatainterface_ce);
	
	PHALCON_INIT_VAR(bind_types);
	array_init(bind_types);
	
	PHALCON_CALL_METHOD(&bind_data_types, meta_data, "getbindtypes", record);
	if (PHALCON_GLOBAL(orm).column_renaming) {
		PHALCON_CALL_METHOD(&column_map, meta_data, "getreversecolumnmap", record);
	} else {
		PHALCON_INIT_VAR(column_map);
	}
	
	PHALCON_INIT_VAR(conditions);
	array_init(conditions);
	
	PHALCON_INIT_VAR(bind_params);
	array_init(bind_params);
	
	PHALCON_INIT_VAR(number);
	ZVAL_LONG(number, 0);
	if (Z_TYPE_P(field) == IS_ARRAY) { 
	
		phalcon_is_iterable(field, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(compose_field);
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, compose_field)) {
					PHALCON_OBS_NVAR(column_field);
					phalcon_array_fetch(&column_field, column_map, compose_field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", compose_field, "\" isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(column_field, compose_field);
			}
	
			if (!phalcon_array_isset(bind_data_types, column_field)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", column_field, "\" isn't part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			PHALCON_CALL_METHOD(&value, record, "readattribute", compose_field);
	
			PHALCON_INIT_NVAR(compose_condition);
			PHALCON_CONCAT_SVSV(compose_condition, "[", compose_field, "] = ?", number);
			phalcon_array_append(&conditions, compose_condition, PH_SEPARATE);
			phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
			PHALCON_OBS_NVAR(bind_type);
			phalcon_array_fetch(&bind_type, bind_data_types, column_field, PH_NOISY);
			phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
			phalcon_increment(number);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		if (Z_TYPE_P(column_map) == IS_ARRAY) { 
			if (phalcon_array_isset(column_map, field)) {
				PHALCON_OBS_NVAR(column_field);
				phalcon_array_fetch(&column_field, column_map, field, PH_NOISY);
			} else {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", field, "\" isn't part of the column map");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
		} else {
			PHALCON_CPY_WRT(column_field, field);
		}
	
		if (!phalcon_array_isset(bind_data_types, column_field)) {
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVS(exception_message, "Column '", column_field, "\" isn't part of the table columns");
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
			return;
		}
	
		PHALCON_CALL_METHOD(&value, record, "readattribute", field);
	
		PHALCON_INIT_VAR(condition);
		PHALCON_CONCAT_SVS(condition, "[", field, "] = ?0");
		phalcon_array_append(&conditions, condition, PH_SEPARATE);
		phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
		PHALCON_OBS_NVAR(bind_type);
		phalcon_array_fetch(&bind_type, bind_data_types, column_field, PH_NOISY);
		phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
		phalcon_increment(number);
	}
	
	PHALCON_CALL_METHOD(&operation_made, record, "getoperationmade");
	if (PHALCON_IS_LONG(operation_made, 2)) {
	
		if (PHALCON_GLOBAL(orm).column_renaming) {
			PHALCON_CALL_METHOD(&column_map, meta_data, "getcolumnmap", record);
		} else {
			PHALCON_INIT_VAR(column_map);
		}
	
		PHALCON_CALL_METHOD(&primary_fields, meta_data, "getprimarykeyattributes", record);
	
		phalcon_is_iterable(primary_fields, &ah1, &hp1, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
			PHALCON_GET_HVALUE(primary_field);
	
			if (!phalcon_array_isset(bind_data_types, primary_field)) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Column '", primary_field, "\" isn't part of the table columns");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
				return;
			}
	
			if (Z_TYPE_P(column_map) == IS_ARRAY) { 
				if (phalcon_array_isset(column_map, primary_field)) {
					PHALCON_OBS_NVAR(attribute_field);
					phalcon_array_fetch(&attribute_field, column_map, primary_field, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(exception_message);
					PHALCON_CONCAT_SVS(exception_message, "Column '", primary_field, "\" isn't part of the column map");
					PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_model_exception_ce, exception_message);
					return;
				}
			} else {
				PHALCON_CPY_WRT(attribute_field, primary_field);
			}
	
			PHALCON_CALL_METHOD(&value, record, "readattribute", primary_field);
	
			PHALCON_INIT_NVAR(condition);
			PHALCON_CONCAT_SVSV(condition, "[", attribute_field, "] <> ?", number);
			phalcon_array_append(&conditions, condition, PH_SEPARATE);
			phalcon_array_append(&bind_params, value, PH_SEPARATE);
	
			PHALCON_OBS_NVAR(bind_type);
			phalcon_array_fetch(&bind_type, bind_data_types, primary_field, PH_NOISY);
			phalcon_array_append(&bind_types, bind_type, PH_SEPARATE);
			phalcon_increment(number);
	
			zend_hash_move_forward_ex(ah1, &hp1);
		}
	
	}
	
	PHALCON_INIT_VAR(join_conditions);
	phalcon_fast_join_str(join_conditions, SL(" AND "), conditions TSRMLS_CC);
	
	PHALCON_INIT_VAR(params);
	array_init_size(params, 4);
	phalcon_array_update_string(&params, SL("di"), dependency_injector, PH_COPY);
	phalcon_array_update_string(&params, SL("conditions"), join_conditions, PH_COPY);
	phalcon_array_update_string(&params, SL("bind"), bind_params, PH_COPY);
	phalcon_array_update_string(&params, SL("bindTypes"), bind_types, PH_COPY);
	
	PHALCON_CALL_CE_STATIC(&number, Z_OBJCE_P(record), "count", params);
	if (!PHALCON_IS_LONG(number, 0)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			if (Z_TYPE_P(field) == IS_ARRAY) { 
				PHALCON_INIT_VAR(join_fields);
				phalcon_fast_join_str(join_fields, SL(", "), field TSRMLS_CC);
	
				PHALCON_INIT_NVAR(message);
				PHALCON_CONCAT_SVS(message, "Value of fields: '", join_fields, "' are already present in another record");
			} else {
				PHALCON_INIT_NVAR(message);
				PHALCON_CONCAT_SVS(message, "Value of field: '", field, "' is already present in another record");
			}
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Unique", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_mvc_model_validator_url_ce;

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Url, validate);

static const zend_function_entry phalcon_mvc_model_validator_url_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Model_Validator_Url, validate, arginfo_phalcon_mvc_model_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Model_Validator_Url){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Model\\Validator, Url, mvc_model_validator_url, phalcon_mvc_model_validator_ce, phalcon_mvc_model_validator_url_method_entry, 0);

	zend_class_implements(phalcon_mvc_model_validator_url_ce TSRMLS_CC, 1, phalcon_mvc_model_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Model_Validator_Url, validate){

	zval *record, *option = NULL, *field = NULL, *value = NULL, *flag, *is_valid = NULL;
	zval *message = NULL, *type, *is_set_code = NULL, *code;
	zval *allow_empty = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &record);
	
	PHALCON_INIT_VAR(option);
	ZVAL_STRING(option, "field", 1);
	
	PHALCON_CALL_METHOD(&field, this_ptr, "getoption", option);
	if (Z_TYPE_P(field) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_model_exception_ce, "Field name must be a string");
		return;
	}
	
	PHALCON_CALL_METHOD(&value, record, "readattribute", field);

	PHALCON_INIT_NVAR(option);
	ZVAL_STRING(option, "allowEmpty", 1);

	PHALCON_CALL_METHOD(&allow_empty, this_ptr, "getoption", option);
	if (allow_empty && zend_is_true(allow_empty) && PHALCON_IS_EMPTY(value)) {
		RETURN_MM_TRUE;
	}
	
	PHALCON_INIT_VAR(flag);
	ZVAL_LONG(flag, 273);
	
	PHALCON_CALL_FUNCTION(&is_valid, "filter_var", value, flag);
	if (!zend_is_true(is_valid)) {
	
		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_message);
	
		PHALCON_CALL_METHOD(&message, this_ptr, "getoption", option);
		if (!zend_is_true(message)) {
			PHALCON_INIT_NVAR(message);
			PHALCON_CONCAT_SVS(message, "'", field, "' does not have a valid url format");
		}
	
		PHALCON_INIT_VAR(type);
		ZVAL_STRING(type, "Url", 1);

		PHALCON_INIT_NVAR(option);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(option, phalcon_interned_code);

		PHALCON_CALL_METHOD(&is_set_code, this_ptr, "issetoption", option);
		if (zend_is_true(is_set_code)) {
			PHALCON_CALL_METHOD(&code, this_ptr, "getoption", option);
		} else {
			PHALCON_INIT_VAR(code);
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_METHOD(NULL, this_ptr, "appendmessage", message, field, type, code);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_mvc_router_annotations_ce;

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, addResource);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, addModuleResource);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, handle);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, processControllerAnnotation);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, processActionAnnotation);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, setControllerSuffix);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, setActionSuffix);
static PHP_METHOD(Phalcon_Mvc_Router_Annotations, getResources);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_addresource, 0, 0, 1)
	ZEND_ARG_INFO(0, handler)
	ZEND_ARG_INFO(0, prefix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_addmoduleresource, 0, 0, 2)
	ZEND_ARG_INFO(0, module)
	ZEND_ARG_INFO(0, handler)
	ZEND_ARG_INFO(0, prefix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_handle, 0, 0, 0)
	ZEND_ARG_INFO(0, uri)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_processcontrollerannotation, 0, 0, 2)
	ZEND_ARG_INFO(0, handler)
	ZEND_ARG_INFO(0, annotation)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_processactionannotation, 0, 0, 5)
	ZEND_ARG_INFO(0, module)
	ZEND_ARG_INFO(0, namespace)
	ZEND_ARG_INFO(0, controller)
	ZEND_ARG_INFO(0, action)
	ZEND_ARG_INFO(0, annotation)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_setcontrollersuffix, 0, 0, 1)
	ZEND_ARG_INFO(0, controllerSuffix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_annotations_setactionsuffix, 0, 0, 1)
	ZEND_ARG_INFO(0, actionSuffix)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_router_annotations_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Router_Annotations, addResource, arginfo_phalcon_mvc_router_annotations_addresource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, addModuleResource, arginfo_phalcon_mvc_router_annotations_addmoduleresource, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, handle, arginfo_phalcon_mvc_router_annotations_handle, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, processControllerAnnotation, arginfo_phalcon_mvc_router_annotations_processcontrollerannotation, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, processActionAnnotation, arginfo_phalcon_mvc_router_annotations_processactionannotation, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, setControllerSuffix, arginfo_phalcon_mvc_router_annotations_setcontrollersuffix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, setActionSuffix, arginfo_phalcon_mvc_router_annotations_setactionsuffix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Annotations, getResources, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Annotations){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Router, Annotations, mvc_router_annotations, phalcon_mvc_router_ce, phalcon_mvc_router_annotations_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_annotations_ce, SL("_handlers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_router_annotations_ce, SL("_processed"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_router_annotations_ce, SL("_controllerSuffix"), "Controller", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_string(phalcon_mvc_router_annotations_ce, SL("_actionSuffix"), "Action", ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_annotations_ce, SL("_routePrefix"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, addResource){

	zval *handler, *prefix = NULL, *scope;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &handler, &prefix);
	
	if (!prefix) {
		prefix = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(handler) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "The handler must be a class name");
		return;
	}
	
	PHALCON_INIT_VAR(scope);
	array_init_size(scope, 2);
	phalcon_array_append(&scope, prefix, 0);
	phalcon_array_append(&scope, handler, 0);
	phalcon_update_property_array_append(this_ptr, SL("_handlers"), scope TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_processed"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, addModuleResource){

	zval *module, *handler, *prefix = NULL, *scope;

	phalcon_fetch_params(0, 2, 1, &module, &handler, &prefix);
	
	if (!prefix) {
		prefix = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(module) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_router_exception_ce, "The module is not a valid string");
		return;
	}
	if (Z_TYPE_P(handler) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_router_exception_ce, "The handler must be a class name");
		return;
	}
	
	MAKE_STD_ZVAL(scope);
	array_init_size(scope, 3);
	phalcon_array_append(&scope, prefix, 0);
	phalcon_array_append(&scope, handler, 0);
	phalcon_array_append(&scope, module, 0);
	phalcon_update_property_array_append(this_ptr, SL("_handlers"), scope TSRMLS_CC);
	zval_ptr_dtor(&scope);

	phalcon_update_property_this(this_ptr, SL("_processed"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, handle){

	zval *uri = NULL, *real_uri = NULL, *processed, *annotations_service = NULL;
	zval *handlers, *controller_suffix, *scope = NULL, *prefix = NULL;
	zval *dependency_injector = NULL, *service = NULL, *handler = NULL;
	zval *controller_name = NULL;
	zval *namespace_name = NULL, *module_name = NULL, *suffixed = NULL;
	zval *handler_annotations = NULL, *class_annotations = NULL;
	zval *annotations = NULL, *annotation = NULL, *method_annotations = NULL;
	zval *collection = NULL, *method = NULL;
	HashTable *ah0, *ah1, *ah2, *ah3;
	HashPosition hp0, hp1, hp2, hp3;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &uri);
	
	if (!uri) {
		uri = PHALCON_GLOBAL(z_null);
	}
	
	if (!zend_is_true(uri)) {
		PHALCON_CALL_METHOD(&real_uri, this_ptr, "getrewriteuri");
	} else {
		PHALCON_CPY_WRT(real_uri, uri);
	}
	
	PHALCON_OBS_VAR(processed);
	phalcon_read_property_this(&processed, this_ptr, SL("_processed"), PH_NOISY TSRMLS_CC);
	if (!zend_is_true(processed)) {
	
		PHALCON_INIT_VAR(annotations_service);
	
		PHALCON_OBS_VAR(handlers);
		phalcon_read_property_this(&handlers, this_ptr, SL("_handlers"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(handlers) == IS_ARRAY) { 
	
			PHALCON_OBS_VAR(controller_suffix);
			phalcon_read_property_this(&controller_suffix, this_ptr, SL("_controllerSuffix"), PH_NOISY TSRMLS_CC);
	
			phalcon_is_iterable(handlers, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HVALUE(scope);
	
				if (Z_TYPE_P(scope) == IS_ARRAY) { 
	
					PHALCON_OBS_NVAR(prefix);
					phalcon_array_fetch_long(&prefix, scope, 0, PH_NOISY);
					if (Z_TYPE_P(prefix) == IS_STRING) {
						if (!phalcon_start_with(real_uri, prefix, NULL)) {
							zend_hash_move_forward_ex(ah0, &hp0);
							continue;
						}
					}
	
					if (Z_TYPE_P(annotations_service) != IS_OBJECT) {
	
						PHALCON_OBS_NVAR(dependency_injector);
						phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
						if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
							PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "A dependency injection container is required to access the 'annotations' service");
							return;
						}
	
						PHALCON_INIT_NVAR(service);
						ZVAL_STRING(service, "annotations", 1);
	
						PHALCON_CALL_METHOD(&annotations_service, dependency_injector, "getshared", service);
						PHALCON_VERIFY_INTERFACE(annotations_service, phalcon_annotations_adapterinterface_ce);
					}
	
					PHALCON_OBS_NVAR(handler);
					phalcon_array_fetch_long(&handler, scope, 1, PH_NOISY);
					if (phalcon_memnstr_str(handler, SL("\\"))) {
						PHALCON_INIT_NVAR(controller_name);
						phalcon_get_class_ns(controller_name, handler, 0 TSRMLS_CC);
	
						PHALCON_INIT_NVAR(namespace_name);
						phalcon_get_ns_class(namespace_name, handler, 0 TSRMLS_CC);
					} else {
						PHALCON_CPY_WRT(controller_name, handler);
	
						PHALCON_INIT_NVAR(namespace_name);
					}
	
					phalcon_update_property_null(this_ptr, SL("_routePrefix") TSRMLS_CC);
	
					if (phalcon_array_isset_long(scope, 2)) {
						PHALCON_OBS_NVAR(module_name);
						phalcon_array_fetch_long(&module_name, scope, 2, PH_NOISY);
					} else {
						PHALCON_INIT_NVAR(module_name);
					}
	
					PHALCON_INIT_NVAR(suffixed);
					PHALCON_CONCAT_VV(suffixed, handler, controller_suffix);
	
					PHALCON_CALL_METHOD(&handler_annotations, annotations_service, "get", suffixed);
	
					PHALCON_CALL_METHOD(&class_annotations, handler_annotations, "getclassannotations");
					if (Z_TYPE_P(class_annotations) == IS_OBJECT) {
	
						PHALCON_CALL_METHOD(&annotations, class_annotations, "getannotations");
						if (Z_TYPE_P(annotations) == IS_ARRAY) { 
	
							phalcon_is_iterable(annotations, &ah1, &hp1, 0, 0);
	
							while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
								PHALCON_GET_HVALUE(annotation);
	
								PHALCON_CALL_METHOD(NULL, this_ptr, "processcontrollerannotation", controller_name, annotation);
	
								zend_hash_move_forward_ex(ah1, &hp1);
							}
	
						}
					}
	
					PHALCON_CALL_METHOD(&method_annotations, handler_annotations, "getmethodsannotations");
					if (Z_TYPE_P(method_annotations) == IS_ARRAY) { 
	
						phalcon_is_iterable(method_annotations, &ah2, &hp2, 0, 0);
	
						while (zend_hash_get_current_data_ex(ah2, (void**) &hd, &hp2) == SUCCESS) {
	
							PHALCON_GET_HKEY(method, ah2, hp2);
							PHALCON_GET_HVALUE(collection);
	
							if (Z_TYPE_P(collection) == IS_OBJECT) {
								PHALCON_CALL_METHOD(&annotations, collection, "getannotations");
	
								phalcon_is_iterable(annotations, &ah3, &hp3, 0, 0);
	
								while (zend_hash_get_current_data_ex(ah3, (void**) &hd, &hp3) == SUCCESS) {
	
									PHALCON_GET_HVALUE(annotation);
	
									PHALCON_CALL_METHOD(NULL, this_ptr, "processactionannotation", module_name, namespace_name, controller_name, method, annotation);
	
									zend_hash_move_forward_ex(ah3, &hp3);
								}
	
							}
	
							zend_hash_move_forward_ex(ah2, &hp2);
						}
	
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		phalcon_update_property_bool(this_ptr, SL("_processed"), 1 TSRMLS_CC);
	}
	
	PHALCON_CALL_PARENT(NULL, phalcon_mvc_router_annotations_ce, this_ptr, "handle", real_uri);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, processControllerAnnotation){

	zval *handler, *annotation, *name = NULL, *position, *value = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &handler, &annotation);
	
	PHALCON_CALL_METHOD(&name, annotation, "getname");
	
	if (PHALCON_IS_STRING(name, "RoutePrefix")) {
		position = PHALCON_GLOBAL(z_zero);
	
		PHALCON_CALL_METHOD(&value, annotation, "getargument", position);
		phalcon_update_property_this_quick(this_ptr, SL("_routePrefix"), value, 2004814177UL TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, processActionAnnotation){

	zval *module, *namespace, *controller, *action;
	zval *annotation, *methods = NULL, *name = NULL;
	zval *empty_str, *real_action_name, *action_name;
	zval *parameter = NULL, *paths = NULL, *position;
	zval *value = NULL, *uri = NULL, *route = NULL, *converts = NULL, *convert = NULL, *param = NULL;
	zval *conversor_param = NULL, *route_name = NULL;
	HashTable *ah0, *ah1;
	HashPosition hp0, hp1;
	zval **hd;
	int is_route;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 5, 0, &module, &namespace, &controller, &action, &annotation);
	
	PHALCON_CALL_METHOD(&name, annotation, "getname");
	
	/* Find if the route is for adding routes */
	PHALCON_INIT_VAR(methods);
	if (PHALCON_IS_STRING(name, "Route")) {
		is_route = 1;
	} else if (PHALCON_IS_STRING(name, "Get")) {
		is_route = 1;
		ZVAL_STRING(methods, phalcon_interned_GET, !IS_INTERNED(phalcon_interned_GET));
	} else if (PHALCON_IS_STRING(name, "Post")) {
		is_route = 1;
		ZVAL_STRING(methods, phalcon_interned_POST, !IS_INTERNED(phalcon_interned_POST));
	} else if (PHALCON_IS_STRING(name, "Put")) {
		is_route = 1;
		ZVAL_STRING(methods, phalcon_interned_PUT, !IS_INTERNED(phalcon_interned_PUT));
	} else if (PHALCON_IS_STRING(name, "Delete")) {
		is_route = 1;
		ZVAL_STRING(methods, phalcon_interned_DELETE, !IS_INTERNED(phalcon_interned_DELETE));
	} else if (PHALCON_IS_STRING(name, "Options")) {
		is_route = 1;
		ZVAL_STRING(methods, phalcon_interned_OPTIONS, !IS_INTERNED(phalcon_interned_OPTIONS));
	}
	else {
		is_route = 0;
	}
	
	if (is_route) {
		zval *action_suffix = phalcon_fetch_nproperty_this(this_ptr, SL("_actionSuffix"), PH_NOISY TSRMLS_CC);
		zval *route_prefix  = phalcon_fetch_nproperty_this(this_ptr, SL("_routePrefix"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_VAR(empty_str);
		ZVAL_EMPTY_STRING(empty_str);
	
		PHALCON_INIT_VAR(real_action_name);
		phalcon_fast_str_replace(real_action_name, action_suffix, empty_str, action);
	
		PHALCON_INIT_VAR(action_name);
		phalcon_fast_strtolower(action_name, real_action_name);
	
		PHALCON_INIT_VAR(parameter);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(parameter, phalcon_interned_paths);
	
		PHALCON_CALL_METHOD(&paths, annotation, "getargument", parameter);
		if (Z_TYPE_P(paths) != IS_ARRAY) { 
			PHALCON_INIT_NVAR(paths);
			array_init(paths);
		}
	
		if (Z_TYPE_P(module) == IS_STRING) {
			phalcon_array_update_string(&paths, ISL(module), module, PH_COPY);
		}
	
		if (Z_TYPE_P(namespace) == IS_STRING) {
			phalcon_array_update_string(&paths, ISL(namespace), namespace, PH_COPY);
		}

		phalcon_array_update_string(&paths, ISL(controller), controller, PH_COPY);
		phalcon_array_update_string(&paths, ISL(action), real_action_name, PH_COPY);
		phalcon_array_update_string(&paths, SL("\0exact"), PHALCON_GLOBAL(z_true), PH_COPY);
	
		PHALCON_INIT_VAR(position);
		ZVAL_LONG(position, 0);
	
		PHALCON_CALL_METHOD(&value, annotation, "getargument", position);
	
		if (Z_TYPE_P(value) != IS_NULL) {
			if (!PHALCON_IS_STRING(value, "/")) {
				PHALCON_INIT_VAR(uri);
				PHALCON_CONCAT_VV(uri, route_prefix, value);
			} else {
				if (Z_TYPE_P(route_prefix) != IS_NULL) {
					PHALCON_CPY_WRT(uri, route_prefix);
				} else {
					PHALCON_CPY_WRT(uri, value);
				}
			}
		} else {
			PHALCON_INIT_NVAR(uri);
			PHALCON_CONCAT_VV(uri, route_prefix, action_name);
		}
	
		PHALCON_CALL_METHOD(&route, this_ptr, "add", uri, paths);
		if (Z_TYPE_P(methods) == IS_NULL) {
	
			PHALCON_INIT_NVAR(parameter);
			ZVAL_STRING(parameter, "methods", 1);
	
			PHALCON_CALL_METHOD(&methods, annotation, "getargument", parameter);
			if (Z_TYPE_P(methods) == IS_ARRAY || Z_TYPE_P(methods) == IS_STRING) {
				PHALCON_CALL_METHOD(NULL, route, "via", methods);
			}
		} else {
			PHALCON_CALL_METHOD(NULL, route, "via", methods);
		}
	
		PHALCON_INIT_NVAR(parameter);
		ZVAL_STRING(parameter, "converts", 1);
	
		PHALCON_CALL_METHOD(&converts, annotation, "getargument", parameter);
		if (Z_TYPE_P(converts) == IS_ARRAY) { 
	
			phalcon_is_iterable(converts, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(param, ah0, hp0);
				PHALCON_GET_HVALUE(convert);
	
				PHALCON_CALL_METHOD(NULL, route, "convert", param, convert);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		PHALCON_INIT_NVAR(parameter);
		ZVAL_STRING(parameter, "conversors", 1);
	
		PHALCON_CALL_METHOD(&converts, annotation, "getargument", parameter);
		if (Z_TYPE_P(converts) == IS_ARRAY) { 
	
			phalcon_is_iterable(converts, &ah1, &hp1, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah1, (void**) &hd, &hp1) == SUCCESS) {
	
				PHALCON_GET_HKEY(conversor_param, ah1, hp1);
				PHALCON_GET_HVALUE(convert);
	
				PHALCON_CALL_METHOD(NULL, route, "convert", conversor_param, convert);
	
				zend_hash_move_forward_ex(ah1, &hp1);
			}
	
		}
	
		PHALCON_INIT_NVAR(parameter);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(parameter, phalcon_interned_name);
	
		PHALCON_CALL_METHOD(&route_name, annotation, "getargument", parameter);
		if (Z_TYPE_P(route_name) == IS_STRING) {
			PHALCON_CALL_METHOD(NULL, route, "setname", route_name);
		}
	
		RETURN_MM_TRUE;
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, setControllerSuffix){

	zval *controller_suffix;

	phalcon_fetch_params(0, 1, 0, &controller_suffix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_controllerSuffix"), controller_suffix, 2437326621UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, setActionSuffix){

	zval *action_suffix;

	phalcon_fetch_params(0, 1, 0, &action_suffix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_actionSuffix"), action_suffix, 879621975UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_Router_Annotations, getResources){


	RETURN_MEMBER_QUICK(this_ptr, "_handlers", 2445210229UL);
}





zend_class_entry *phalcon_mvc_router_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Router, Exception, mvc_router_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}







zend_class_entry *phalcon_mvc_router_group_ce;

static PHP_METHOD(Phalcon_Mvc_Router_Group, __construct);
static PHP_METHOD(Phalcon_Mvc_Router_Group, setHostname);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getHostname);
static PHP_METHOD(Phalcon_Mvc_Router_Group, setPrefix);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getPrefix);
static PHP_METHOD(Phalcon_Mvc_Router_Group, beforeMatch);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getBeforeMatch);
static PHP_METHOD(Phalcon_Mvc_Router_Group, setPaths);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getPaths);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getRoutes);
static PHP_METHOD(Phalcon_Mvc_Router_Group, _addRoute);
static PHP_METHOD(Phalcon_Mvc_Router_Group, add);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addGet);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addPost);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addPut);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addPatch);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addDelete);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addOptions);
static PHP_METHOD(Phalcon_Mvc_Router_Group, addHead);
static PHP_METHOD(Phalcon_Mvc_Router_Group, clear);
static PHP_METHOD(Phalcon_Mvc_Router_Group, convert);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getConverters);
static PHP_METHOD(Phalcon_Mvc_Router_Group, setName);
static PHP_METHOD(Phalcon_Mvc_Router_Group, getName);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_sethostname, 0, 0, 1)
	ZEND_ARG_INFO(0, hostname)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_setprefix, 0, 0, 1)
	ZEND_ARG_INFO(0, prefix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_beforematch, 0, 0, 1)
	ZEND_ARG_INFO(0, beforeMatch)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_setpaths, 0, 0, 1)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_add, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
	ZEND_ARG_INFO(0, httpMethods)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addget, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addpost, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addput, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addpatch, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_adddelete, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_addhead, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_convert, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, converter)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_group_setname, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_router_group_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Router_Group, __construct, arginfo_phalcon_mvc_router_group___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Router_Group, setHostname, arginfo_phalcon_mvc_router_group_sethostname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getHostname, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, setPrefix, arginfo_phalcon_mvc_router_group_setprefix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getPrefix, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, beforeMatch, arginfo_phalcon_mvc_router_group_beforematch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getBeforeMatch, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, setPaths, arginfo_phalcon_mvc_router_group_setpaths, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getPaths, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getRoutes, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, _addRoute, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_Router_Group, add, arginfo_phalcon_mvc_router_group_add, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addGet, arginfo_phalcon_mvc_router_group_addget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addPost, arginfo_phalcon_mvc_router_group_addpost, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addPut, arginfo_phalcon_mvc_router_group_addput, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addPatch, arginfo_phalcon_mvc_router_group_addpatch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addDelete, arginfo_phalcon_mvc_router_group_adddelete, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addOptions, arginfo_phalcon_mvc_router_group_addoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, addHead, arginfo_phalcon_mvc_router_group_addhead, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, clear, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, convert, arginfo_phalcon_mvc_router_group_convert, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getConverters, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, setName, arginfo_phalcon_mvc_router_group_setname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Group, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Group){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Router, Group, mvc_router_group, phalcon_mvc_router_group_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_prefix"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_hostname"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_paths"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_routes"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_beforeMatch"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_converters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_group_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, __construct){

	zval *paths = NULL;

	phalcon_fetch_params(0, 0, 1, &paths);

	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}

	if (Z_TYPE_P(paths) == IS_ARRAY || Z_TYPE_P(paths) == IS_STRING) {
		phalcon_update_property_this_quick(this_ptr, SL("_paths"), paths, 2700778884UL TSRMLS_CC);
	}

	if (phalcon_method_quick_exists_ex(this_ptr, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_METHODW(NULL, this_ptr, "initialize", paths);
	}
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, setHostname){

	zval *hostname;

	phalcon_fetch_params(0, 1, 0, &hostname);

	phalcon_update_property_this_quick(this_ptr, SL("_hostname"), hostname, 598751491UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getHostname){


	RETURN_MEMBER_QUICK(this_ptr, "_hostname", 598751491UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, setPrefix){

	zval *prefix;

	phalcon_fetch_params(0, 1, 0, &prefix);

	phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getPrefix){


	RETURN_MEMBER_QUICK(this_ptr, "_prefix", 3873791314UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, beforeMatch){

	zval *before_match;

	phalcon_fetch_params(0, 1, 0, &before_match);

	phalcon_update_property_this_quick(this_ptr, SL("_beforeMatch"), before_match, 2834072708UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getBeforeMatch){


	RETURN_MEMBER_QUICK(this_ptr, "_beforeMatch", 2834072708UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, setPaths){

	zval *paths;

	phalcon_fetch_params(0, 1, 0, &paths);

	phalcon_update_property_this_quick(this_ptr, SL("_paths"), paths, 2700778884UL TSRMLS_CC);

}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getPaths){


	RETURN_MEMBER_QUICK(this_ptr, "_paths", 2700778884UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getRoutes){


	RETURN_MEMBER_QUICK(this_ptr, "_routes", 2063827110UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, _addRoute){

	zval **pattern, **paths = NULL, **http_methods = NULL, *prefix, *prefix_pattern;
	zval *default_paths, *merged_paths = NULL;

	phalcon_fetch_params_ex(1, 2, &pattern, &paths, &http_methods);
	PHALCON_ENSURE_IS_STRING(pattern);

	PHALCON_MM_GROW();

	if (!paths) {
		paths = &PHALCON_GLOBAL(z_null);
	}

	if (!http_methods) {
		http_methods = &PHALCON_GLOBAL(z_null);
	}

	PHALCON_OBS_VAR(prefix);
	phalcon_read_property_this(&prefix, this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(prefix) != IS_STRING) {
		convert_to_string_ex(&prefix);
	}

	PHALCON_INIT_VAR(prefix_pattern);
	{
		const char *s_pattern = Z_STRVAL_PP(pattern); /* NUL-terminated */
		const char *s_prefix  = Z_STRVAL_P(prefix);   /* NUL-terminated */
		int pattern_len       = Z_STRLEN_PP(pattern);
		int prefix_len        = Z_STRLEN_P(prefix);
		if (prefix_len && *s_pattern == '/' && s_prefix[prefix_len-1] == '/') {
			char *new_pattern = safe_emalloc(prefix_len - 1 /* slash */ + 1 /* \0 */, 1, pattern_len);
			memcpy(new_pattern, s_prefix, prefix_len - 1);
			memcpy(new_pattern + prefix_len - 1, s_pattern, pattern_len + 1);
			ZVAL_STRINGL(prefix_pattern, new_pattern, prefix_len + pattern_len - 1, 0);
		}
		else {
			PHALCON_CONCAT_VV(prefix_pattern, prefix, *pattern);
		}
	}

	default_paths = phalcon_fetch_nproperty_this(this_ptr, SL("_paths"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(default_paths) == IS_ARRAY && Z_TYPE_PP(paths) == IS_ARRAY) {
		PHALCON_INIT_VAR(merged_paths);
		phalcon_fast_array_merge(merged_paths, &default_paths, paths TSRMLS_CC);
	} else {
		merged_paths = *paths;
	}

	object_init_ex(return_value, phalcon_mvc_router_route_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", prefix_pattern, merged_paths, *http_methods);
	PHALCON_CALL_METHOD(NULL, return_value, "setgroup", this_ptr);

	phalcon_update_property_array_append(this_ptr, SL("_routes"), return_value TSRMLS_CC);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, add){

	zval *pattern, *paths = NULL, *http_methods = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &pattern, &paths, &http_methods);

	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}

	if (!http_methods) {
		http_methods = PHALCON_GLOBAL(z_null);
	}

	PHALCON_RETURN_CALL_METHOD(this_ptr, "_addroute", pattern, paths, http_methods);
	RETURN_MM();
}

static void phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAMETERS, const char *method)
{
	zval *pattern, *paths = NULL, *http_method;

	phalcon_fetch_params(0, 1, 1, &pattern, &paths);

	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}

	PHALCON_ALLOC_GHOST_ZVAL(http_method);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(http_method, method);
	PHALCON_RETURN_CALL_METHODW(getThis(), "_addroute", pattern, paths, http_method);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addGet){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_GET);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addPost){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_POST);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addPut){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_PUT);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addPatch){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_PATCH);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addDelete){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_DELETE);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addOptions){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_OPTIONS);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, addHead){

	phalcon_mvc_router_group_add_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, phalcon_interned_HEAD);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, clear){

	zval *empty_routes;

	MAKE_STD_ZVAL(empty_routes);
	array_init(empty_routes);
	phalcon_update_property_this_quick(this_ptr, SL("_routes"), empty_routes, 2063827110UL TSRMLS_CC);
	zval_ptr_dtor(&empty_routes);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, convert){

	zval **name, **converter;

	phalcon_fetch_params_ex(2, 0, &name, &converter);

	phalcon_update_property_array(this_ptr, SL("_converters"), *name, *converter TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getConverters) {

	RETURN_MEMBER_QUICK(this_ptr, "_converters", 994353007UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, setName){

	zval **name;

	phalcon_fetch_params_ex(1, 0, &name);

	phalcon_update_property_this(this_ptr, SL("_name"), *name TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Group, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}






zend_class_entry *phalcon_mvc_router_route_ce;

static PHP_METHOD(Phalcon_Mvc_Router_Route, __construct);
static PHP_METHOD(Phalcon_Mvc_Router_Route, compilePattern);
static PHP_METHOD(Phalcon_Mvc_Router_Route, via);
static PHP_METHOD(Phalcon_Mvc_Router_Route, reConfigure);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getName);
static PHP_METHOD(Phalcon_Mvc_Router_Route, setName);
static PHP_METHOD(Phalcon_Mvc_Router_Route, beforeMatch);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getBeforeMatch);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getRouteId);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getPattern);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getCompiledPattern);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getPaths);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getReversedPaths);
static PHP_METHOD(Phalcon_Mvc_Router_Route, setHttpMethods);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getHttpMethods);
static PHP_METHOD(Phalcon_Mvc_Router_Route, setHostname);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getHostname);
static PHP_METHOD(Phalcon_Mvc_Router_Route, setGroup);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getGroup);
static PHP_METHOD(Phalcon_Mvc_Router_Route, convert);
static PHP_METHOD(Phalcon_Mvc_Router_Route, getConverters);
static PHP_METHOD(Phalcon_Mvc_Router_Route, reset);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_route___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, pattern)
	ZEND_ARG_INFO(0, paths)
	ZEND_ARG_INFO(0, httpMethods)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_route_setgroup, 0, 0, 1)
	ZEND_ARG_INFO(0, group)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_route_beforematch, 0, 0, 1)
	ZEND_ARG_INFO(0, callback)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_route_sethostname, 0, 0, 1)
	ZEND_ARG_INFO(0, hostname)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_router_route_convert, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, converter)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_router_route_method_entry[] = {
	PHP_ME(Phalcon_Mvc_Router_Route, __construct, arginfo_phalcon_mvc_router_route___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_Router_Route, compilePattern, arginfo_phalcon_mvc_router_routeinterface_compilepattern, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, via, arginfo_phalcon_mvc_router_routeinterface_via, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, reConfigure, arginfo_phalcon_mvc_router_routeinterface_reconfigure, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getName, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, setName, arginfo_phalcon_mvc_router_routeinterface_setname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, beforeMatch, arginfo_phalcon_mvc_router_route_beforematch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getBeforeMatch, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getRouteId, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getPattern, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getCompiledPattern, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getPaths, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getReversedPaths, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, setHttpMethods, arginfo_phalcon_mvc_router_routeinterface_sethttpmethods, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getHttpMethods, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, setHostname, arginfo_phalcon_mvc_router_route_sethostname, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getHostname, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, setGroup, arginfo_phalcon_mvc_router_route_setgroup, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getGroup, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, convert, arginfo_phalcon_mvc_router_route_convert, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, getConverters, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_Router_Route, reset, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Router_Route){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\Router, Route, mvc_router_route, phalcon_mvc_router_route_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_pattern"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_compiledPattern"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_paths"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_methods"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_hostname"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_converters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_id"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_beforeMatch"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_router_route_ce, SL("_group"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_router_route_ce, SL("_uniqueId"), 0, ZEND_ACC_STATIC|ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_router_route_ce TSRMLS_CC, 1, phalcon_mvc_router_routeinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, __construct){

	zval *pattern, *paths = NULL, *http_methods = NULL, *unique_id = NULL;
	zval *route_id = NULL;
	int separate = 0;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &pattern, &paths, &http_methods);
	
	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}
	
	if (!http_methods) {
		http_methods = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "reconfigure", pattern, paths);
	
	phalcon_update_property_this_quick(this_ptr, SL("_methods"), http_methods, 960170392UL TSRMLS_CC);
	
	unique_id = phalcon_fetch_static_property_ce(phalcon_mvc_router_route_ce, SL("_uniqueId") TSRMLS_CC);
	if (Z_REFCOUNT_P(unique_id) > 1) {
		PHALCON_INIT_VAR(unique_id);
		separate = 1;
	}

	if (Z_TYPE_P(unique_id) == IS_NULL) {
		ZVAL_LONG(unique_id, 0);
	}
	
	PHALCON_CPY_WRT_CTOR(route_id, unique_id); /* route_id is now separated from unique_id */
	phalcon_update_property_this_quick(this_ptr, SL("_id"), route_id, 2090005265UL TSRMLS_CC);
	
	/* increment_function() will increment the value of the static property as well */
	increment_function(unique_id);
	if (separate) {
		phalcon_update_static_property_ce(phalcon_mvc_router_route_ce, SL("_uniqueId"), unique_id TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, compilePattern){

	zval *pattern, *compiled_pattern = NULL, *id_pattern;
	zval wildcard, *pattern_copy = NULL, *params_pattern;
	zval *int_pattern;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &pattern);
	
	PHALCON_CPY_WRT(compiled_pattern, pattern);
	
	if (phalcon_memnstr_str(pattern, SL(":"))) {
	
		PHALCON_INIT_VAR(id_pattern);
		ZVAL_STRING(id_pattern, "/([a-zA-Z0-9_-]++)", 1);
	
		if (phalcon_memnstr_str(pattern, SL("/:module"))) {
			INIT_ZVAL(wildcard);
			ZVAL_STRING(&wildcard, "/:module", 0);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, id_pattern, pattern_copy);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:controller"))) {
			INIT_ZVAL(wildcard);
			ZVAL_STRING(&wildcard, "/:controller", 0);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, id_pattern, pattern_copy);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:namespace"))) {
			INIT_ZVAL(wildcard)
			ZVAL_STRING(&wildcard, "/:namespace", 0);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, id_pattern, pattern_copy);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:action"))) {
			INIT_ZVAL(wildcard);
			ZVAL_STRING(&wildcard, "/:action", 0);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, id_pattern, pattern_copy);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:params"))) {
			INIT_ZVAL(wildcard);
			ZVAL_STRING(&wildcard, "/:params", 0);
	
			PHALCON_INIT_VAR(params_pattern);
			ZVAL_STRING(params_pattern, "(/.*+)?+", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, params_pattern, pattern_copy);
		}
	
		if (phalcon_memnstr_str(pattern, SL("/:int"))) {
			INIT_ZVAL(wildcard);
			ZVAL_STRING(&wildcard, "/:int", 0);
	
			PHALCON_INIT_VAR(int_pattern);
			ZVAL_STRING(int_pattern, "/([0-9]++)", 1);
			PHALCON_CPY_WRT(pattern_copy, compiled_pattern);
	
			PHALCON_INIT_NVAR(compiled_pattern);
			phalcon_fast_str_replace(compiled_pattern, &wildcard, int_pattern, pattern_copy);
		}
	}
	
	if (phalcon_memnstr_str(compiled_pattern, SL("("))) {
		PHALCON_CONCAT_SVS(return_value, "#^", compiled_pattern, "$#");
		RETURN_MM();
	}
	
	if (phalcon_memnstr_str(compiled_pattern, SL("["))) {
		PHALCON_CONCAT_SVS(return_value, "#^", compiled_pattern, "$#");
		RETURN_MM();
	}
	
	RETURN_CCTOR(compiled_pattern);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, via){

	zval *http_methods;

	phalcon_fetch_params(0, 1, 0, &http_methods);
	
	phalcon_update_property_this_quick(this_ptr, SL("_methods"), http_methods, 960170392UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, reConfigure){

	zval *pattern, *paths = NULL, *module_name = NULL, *controller_name = NULL;
	zval *action_name = NULL, *parts, *number_parts, *route_paths = NULL;
	zval *real_class_name = NULL, *namespace_name, *lower_name;
	zval *pcre_pattern = NULL, *compiled_pattern = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &pattern, &paths);
	
	if (!paths) {
		paths = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(pattern) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "The pattern must be string");
		return;
	}
	if (Z_TYPE_P(paths) != IS_NULL) {
		if (Z_TYPE_P(paths) == IS_STRING) {
	
			PHALCON_INIT_VAR(module_name);
	
			PHALCON_INIT_VAR(controller_name);
	
			PHALCON_INIT_VAR(action_name);
	
			PHALCON_INIT_VAR(parts);
			phalcon_fast_explode_str(parts, SL("::"), paths);
	
			PHALCON_INIT_VAR(number_parts);
			phalcon_fast_count(number_parts, parts TSRMLS_CC);
	
	
			switch (phalcon_get_intval(number_parts)) {
	
				case 3:
					PHALCON_OBS_NVAR(module_name);
					phalcon_array_fetch_long(&module_name, parts, 0, PH_NOISY);
	
					PHALCON_OBS_NVAR(controller_name);
					phalcon_array_fetch_long(&controller_name, parts, 1, PH_NOISY);
	
					PHALCON_OBS_NVAR(action_name);
					phalcon_array_fetch_long(&action_name, parts, 2, PH_NOISY);
					break;
	
				case 2:
					PHALCON_OBS_NVAR(controller_name);
					phalcon_array_fetch_long(&controller_name, parts, 0, PH_NOISY);
	
					PHALCON_OBS_NVAR(action_name);
					phalcon_array_fetch_long(&action_name, parts, 1, PH_NOISY);
					break;
	
				case 1:
					PHALCON_OBS_NVAR(controller_name);
					phalcon_array_fetch_long(&controller_name, parts, 0, PH_NOISY);
					break;
	
			}
	
			PHALCON_INIT_VAR(route_paths);
			array_init(route_paths);
	
			if (Z_TYPE_P(module_name) != IS_NULL) {
				phalcon_array_update_string(&route_paths, SL("module"), module_name, PH_COPY | PH_SEPARATE);
			}
	
			if (Z_TYPE_P(controller_name) != IS_NULL) {
	
				if (phalcon_memnstr_str(controller_name, SL("\\"))) {
	
					PHALCON_INIT_VAR(real_class_name);
					phalcon_get_class_ns(real_class_name, controller_name, 0 TSRMLS_CC);
	
					PHALCON_INIT_VAR(namespace_name);
					phalcon_get_ns_class(namespace_name, controller_name, 0 TSRMLS_CC);
	
					if (zend_is_true(namespace_name)) {
						phalcon_array_update_string(&route_paths, SL("namespace"), namespace_name, PH_COPY | PH_SEPARATE);
					}
				} else {
					PHALCON_CPY_WRT(real_class_name, controller_name);
				}
	
				PHALCON_INIT_VAR(lower_name);
				phalcon_uncamelize(lower_name, real_class_name);
	
				phalcon_array_update_string(&route_paths, SL("controller"), lower_name, PH_COPY | PH_SEPARATE);
			}
	
			if (Z_TYPE_P(action_name) != IS_NULL) {
				phalcon_array_update_string(&route_paths, SL("action"), action_name, PH_COPY | PH_SEPARATE);
			}
		} else {
			PHALCON_CPY_WRT(route_paths, paths);
		}
	} else {
		PHALCON_INIT_NVAR(route_paths);
		array_init(route_paths);
	}
	
	if (Z_TYPE_P(route_paths) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_router_exception_ce, "The route contains invalid paths");
		return;
	}
	
	if (!phalcon_start_with_str(pattern, SL("#"))) {
		if (phalcon_memnstr_str(pattern, SL("{"))) {
			PHALCON_INIT_VAR(pcre_pattern);
			phalcon_extract_named_params(pcre_pattern, pattern, route_paths);
		} else {
			PHALCON_CPY_WRT(pcre_pattern, pattern);
		}
	
		PHALCON_CALL_METHOD(&compiled_pattern, this_ptr, "compilepattern", pcre_pattern);
	} else {
		PHALCON_CPY_WRT(compiled_pattern, pattern);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_pattern"), pattern, 3404429922UL TSRMLS_CC);
	
	phalcon_update_property_this_quick(this_ptr, SL("_compiledPattern"), compiled_pattern, 4104436623UL TSRMLS_CC);
	
	phalcon_update_property_this_quick(this_ptr, SL("_paths"), route_paths, 2700778884UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getName){


	RETURN_MEMBER_QUICK(this_ptr, "_name", 3983977829UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, setName){

	zval *name;

	phalcon_fetch_params(0, 1, 0, &name);
	
	phalcon_update_property_this_quick(this_ptr, SL("_name"), name, 3983977829UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, beforeMatch){

	zval *callback;

	phalcon_fetch_params(0, 1, 0, &callback);
	
	phalcon_update_property_this_quick(this_ptr, SL("_beforeMatch"), callback, 2834072708UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getBeforeMatch){


	RETURN_MEMBER_QUICK(this_ptr, "_beforeMatch", 2834072708UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getRouteId){


	RETURN_MEMBER_QUICK(this_ptr, "_id", 2090005265UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getPattern){


	RETURN_MEMBER_QUICK(this_ptr, "_pattern", 3404429922UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getCompiledPattern){


	RETURN_MEMBER_QUICK(this_ptr, "_compiledPattern", 4104436623UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getPaths){


	RETURN_MEMBER_QUICK(this_ptr, "_paths", 2700778884UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getReversedPaths){

	zval *paths, *position = NULL, *path = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(paths);
	phalcon_read_property_this(&paths, this_ptr, SL("_paths"), PH_NOISY TSRMLS_CC);
	
	phalcon_is_iterable(paths, &ah0, &hp0, 0, 0);

	array_init_size(return_value, zend_hash_num_elements(ah0));

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(path, ah0, hp0);
		PHALCON_GET_HVALUE(position);
	
		phalcon_array_update_zval(&return_value, position, path, PH_COPY);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, setHttpMethods){

	zval *http_methods;

	phalcon_fetch_params(0, 1, 0, &http_methods);
	
	phalcon_update_property_this_quick(this_ptr, SL("_methods"), http_methods, 960170392UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getHttpMethods){


	RETURN_MEMBER_QUICK(this_ptr, "_methods", 960170392UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, setHostname){

	zval *hostname;

	phalcon_fetch_params(0, 1, 0, &hostname);
	
	phalcon_update_property_this_quick(this_ptr, SL("_hostname"), hostname, 598751491UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getHostname){


	RETURN_MEMBER_QUICK(this_ptr, "_hostname", 598751491UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, setGroup) {

	zval *group;

	phalcon_fetch_params(0, 1, 0, &group);
	PHALCON_VERIFY_CLASS_EX(group, phalcon_mvc_router_group_ce, phalcon_mvc_router_exception_ce, 0);

	phalcon_update_property_this(getThis(), SL("_group"), group TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getGroup) {

	RETURN_MEMBER_QUICK(this_ptr, "_group", 2368555377UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, convert){

	zval *name, *converter;

	phalcon_fetch_params(0, 2, 0, &name, &converter);
	
	phalcon_update_property_array(this_ptr, SL("_converters"), name, converter TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, getConverters){


	RETURN_MEMBER_QUICK(this_ptr, "_converters", 994353007UL);
}

static PHP_METHOD(Phalcon_Mvc_Router_Route, reset){

	zend_update_static_property_long(phalcon_mvc_router_route_ce, SL("_uniqueId"), 0 TSRMLS_CC);
}





zend_class_entry *phalcon_mvc_router_routeinterface_ce;

static const zend_function_entry phalcon_mvc_router_routeinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, compilePattern, arginfo_phalcon_mvc_router_routeinterface_compilepattern)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, via, arginfo_phalcon_mvc_router_routeinterface_via)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, reConfigure, arginfo_phalcon_mvc_router_routeinterface_reconfigure)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getName, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, setName, arginfo_phalcon_mvc_router_routeinterface_setname)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, setHttpMethods, arginfo_phalcon_mvc_router_routeinterface_sethttpmethods)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getRouteId, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getPattern, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getCompiledPattern, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getPaths, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_Router_RouteInterface, getHttpMethods, NULL)
	ZEND_FENTRY(reset, NULL, NULL, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_Router_RouteInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\Router, RouteInterface, mvc_router_routeinterface, phalcon_mvc_router_routeinterface_method_entry);

	return SUCCESS;
}

















zend_class_entry *phalcon_mvc_url_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_Url_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\Url, Exception, mvc_url_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_mvc_user_component_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_User_Component){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Component, mvc_user_component, phalcon_di_injectable_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_mvc_user_module_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_User_Module){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Module, mvc_user_module, phalcon_di_injectable_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_mvc_user_plugin_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_User_Plugin){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\User, Plugin, mvc_user_plugin, phalcon_di_injectable_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_mvc_view_engine_ce;

static PHP_METHOD(Phalcon_Mvc_View_Engine, __construct);
static PHP_METHOD(Phalcon_Mvc_View_Engine, getContent);
static PHP_METHOD(Phalcon_Mvc_View_Engine, partial);
static PHP_METHOD(Phalcon_Mvc_View_Engine, getView);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, view)
	ZEND_ARG_INFO(0, dependencyInjector)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_view_engine_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View_Engine, __construct, arginfo_phalcon_mvc_view_engine___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_View_Engine, getContent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine, partial, arginfo_phalcon_mvc_view_engineinterface_partial, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine, getView, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View, Engine, mvc_view_engine, phalcon_di_injectable_ce, phalcon_mvc_view_engine_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_mvc_view_engine_ce, SL("_view"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_engine_ce TSRMLS_CC, 1, phalcon_mvc_view_engineinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine, __construct){

	zval *view, *dependency_injector = NULL;

	phalcon_fetch_params(0, 1, 1, &view, &dependency_injector);
	
	if (!dependency_injector) {
		dependency_injector = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_view"), view, 3993744575UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine, getContent)
{
	zval *view = phalcon_fetch_nproperty_this(this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(view, "getcontent");
}

static PHP_METHOD(Phalcon_Mvc_View_Engine, partial){

	zval *partial_path, *params = NULL, *view;

	phalcon_fetch_params(0, 1, 1, &partial_path, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	view = phalcon_fetch_nproperty_this(this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
	PHALCON_RETURN_CALL_METHODW(view, "partial", partial_path, params);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine, getView){


	RETURN_MEMBER_QUICK(this_ptr, "_view", 3993744575UL);
}






zend_class_entry *phalcon_mvc_view_engineinterface_ce;

static const zend_function_entry phalcon_mvc_view_engineinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Mvc_View_EngineInterface, getContent, NULL)
	PHP_ABSTRACT_ME(Phalcon_Mvc_View_EngineInterface, partial, arginfo_phalcon_mvc_view_engineinterface_partial)
	PHP_ABSTRACT_ME(Phalcon_Mvc_View_EngineInterface, render, arginfo_phalcon_mvc_view_engineinterface_render)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_EngineInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Mvc\\View, EngineInterface, mvc_view_engineinterface, phalcon_mvc_view_engineinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_mvc_view_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View, Exception, mvc_view_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





#include <Zend/zend_closures.h>


zend_class_entry *phalcon_mvc_view_simple_ce;

static PHP_METHOD(Phalcon_Mvc_View_Simple, __construct);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setViewsDir);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getViewsDir);
static PHP_METHOD(Phalcon_Mvc_View_Simple, registerEngines);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getRegisteredEngines);
static PHP_METHOD(Phalcon_Mvc_View_Simple, _loadTemplateEngines);
static PHP_METHOD(Phalcon_Mvc_View_Simple, _internalRender);
static PHP_METHOD(Phalcon_Mvc_View_Simple, render);
static PHP_METHOD(Phalcon_Mvc_View_Simple, partial);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setCacheOptions);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getCacheOptions);
static PHP_METHOD(Phalcon_Mvc_View_Simple, _createCache);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getCache);
static PHP_METHOD(Phalcon_Mvc_View_Simple, cache);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setParamToView);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setVars);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setVar);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getParamsToView);
static PHP_METHOD(Phalcon_Mvc_View_Simple, setContent);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getContent);
static PHP_METHOD(Phalcon_Mvc_View_Simple, getActiveRenderPath);
static PHP_METHOD(Phalcon_Mvc_View_Simple, __set);
static PHP_METHOD(Phalcon_Mvc_View_Simple, __get);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setviewsdir, 0, 0, 1)
	ZEND_ARG_INFO(0, viewsDir)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_registerengines, 0, 0, 1)
	ZEND_ARG_INFO(0, engines)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_render, 0, 0, 1)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_partial, 0, 0, 1)
	ZEND_ARG_INFO(0, partialPath)
	ZEND_ARG_INFO(0, params)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setcacheoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_cache, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setparamtoview, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setvars, 0, 0, 1)
	ZEND_ARG_INFO(0, params)
	ZEND_ARG_INFO(0, merge)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setvar, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple_setcontent, 0, 0, 1)
	ZEND_ARG_INFO(0, content)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple___set, 0, 0, 2)
	ZEND_ARG_INFO(0, key)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_simple___get, 0, 0, 1)
	ZEND_ARG_INFO(0, key)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_view_simple_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View_Simple, __construct, arginfo_phalcon_mvc_view_simple___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_View_Simple, setViewsDir, arginfo_phalcon_mvc_view_simple_setviewsdir, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getViewsDir, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, registerEngines, arginfo_phalcon_mvc_view_simple_registerengines, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getRegisteredEngines, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, _loadTemplateEngines, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Simple, _internalRender, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Simple, render, arginfo_phalcon_mvc_view_simple_render, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, partial, arginfo_phalcon_mvc_view_simple_partial, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, setCacheOptions, arginfo_phalcon_mvc_view_simple_setcacheoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getCacheOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, _createCache, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Simple, getCache, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, cache, arginfo_phalcon_mvc_view_simple_cache, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, setParamToView, arginfo_phalcon_mvc_view_simple_setparamtoview, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, setVars, arginfo_phalcon_mvc_view_simple_setvars, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, setVar, arginfo_phalcon_mvc_view_simple_setvar, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Mvc_View_Simple, getVar, __get, arginfo_phalcon_mvc_view_simple___get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getParamsToView, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, setContent, arginfo_phalcon_mvc_view_simple_setcontent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getContent, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, getActiveRenderPath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, __set, arginfo_phalcon_mvc_view_simple___set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Simple, __get, arginfo_phalcon_mvc_view_simple___get, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Simple){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View, Simple, mvc_view_simple, phalcon_di_injectable_ce, phalcon_mvc_view_simple_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_viewsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_partialsDir"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_viewParams"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_simple_ce, SL("_engines"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_registeredEngines"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_activeRenderPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_content"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_simple_ce, SL("_cache"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_simple_ce, SL("_cacheOptions"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setViewsDir){

	zval *views_dir;

	phalcon_fetch_params(0, 1, 0, &views_dir);
	
	phalcon_update_property_this_quick(this_ptr, SL("_viewsDir"), views_dir, 3398309201UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getViewsDir){


	RETURN_MEMBER_QUICK(this_ptr, "_viewsDir", 3398309201UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, registerEngines){

	zval *engines;

	phalcon_fetch_params(0, 1, 0, &engines);
	
	if (Z_TYPE_P(engines) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Engines to register must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_registeredEngines"), engines, 3326968731UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getRegisteredEngines) {

	RETURN_MEMBER(getThis(), "_registeredEngines")
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, _loadTemplateEngines){

	zval *engines = NULL, *dependency_injector, *registered_engines;
	zval *php_engine, *arguments, *engine_service = NULL;
	zval *extension = NULL, *engine_object = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(engines);
	phalcon_read_property_this(&engines, this_ptr, SL("_engines"), PH_NOISY TSRMLS_CC);
	
	if (PHALCON_IS_FALSE(engines)) {
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(engines);
		array_init(engines);
	
		PHALCON_OBS_VAR(registered_engines);
		phalcon_read_property_this(&registered_engines, this_ptr, SL("_registeredEngines"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(registered_engines) != IS_ARRAY) { 
			PHALCON_INIT_VAR(php_engine);
			object_init_ex(php_engine, phalcon_mvc_view_engine_php_ce);
			PHALCON_CALL_METHOD(NULL, php_engine, "__construct", this_ptr, dependency_injector);
	
			phalcon_array_update_string(&engines, SL(".phtml"), php_engine, PH_COPY | PH_SEPARATE);
		} else {
			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the application services");
				return;
			}
	
			PHALCON_INIT_VAR(arguments);
			array_init_size(arguments, 2);
			phalcon_array_append(&arguments, this_ptr, PH_SEPARATE);
			phalcon_array_append(&arguments, dependency_injector, PH_SEPARATE);
	
			phalcon_is_iterable(registered_engines, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(extension, ah0, hp0);
				PHALCON_GET_HVALUE(engine_service);
	
				if (Z_TYPE_P(engine_service) == IS_OBJECT) {
	
					if (instanceof_function(Z_OBJCE_P(engine_service), zend_ce_closure TSRMLS_CC)) {
						PHALCON_INIT_NVAR(engine_object);/**/
						PHALCON_CALL_USER_FUNC_ARRAY(engine_object, engine_service, arguments);
					} else {
						PHALCON_CPY_WRT(engine_object, engine_service);
					}
				} else {
					if (Z_TYPE_P(engine_service) == IS_STRING) {
						PHALCON_CALL_METHOD(&engine_object, dependency_injector, "getshared", engine_service, arguments);
						PHALCON_VERIFY_INTERFACE(engine_object, phalcon_mvc_view_engineinterface_ce);
					} else {
						PHALCON_INIT_NVAR(exception_message);
						PHALCON_CONCAT_SV(exception_message, "Invalid template engine registration for extension: ", extension);
						PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
						return;
					}
				}
				phalcon_array_update_zval(&engines, extension, engine_object, PH_COPY | PH_SEPARATE);
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_engines"), engines, 1840711053UL TSRMLS_CC);
	} else {
		PHALCON_OBS_NVAR(engines);
		phalcon_read_property_this(&engines, this_ptr, SL("_engines"), PH_NOISY TSRMLS_CC);
	}
	
	RETURN_CCTOR(engines);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, _internalRender){

	zval *path, *params, *events_manager, *event_name = NULL;
	zval *status = NULL, *not_exists = NULL, *views_dir;
	zval *views_dir_path, *engines = NULL, *engine = NULL, *extension = NULL;
	zval *view_engine_path = NULL, *exception_message;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &path, &params);
	
	PHALCON_OBS_VAR(events_manager);
	phalcon_read_property_this(&events_manager, this_ptr, SL("_eventsManager"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_activeRenderPath"), path, 1528023309UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(event_name);
		ZVAL_STRING(event_name, "view:beforeRender", 1);
	
		PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr);
		if (PHALCON_IS_FALSE(status)) {
			RETURN_MM_NULL();
		}
	}
	
	PHALCON_INIT_VAR(not_exists);
	ZVAL_TRUE(not_exists);
	
	PHALCON_OBS_VAR(views_dir);
	phalcon_read_property_this(&views_dir, this_ptr, SL("_viewsDir"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(views_dir_path);
	PHALCON_CONCAT_VV(views_dir_path, views_dir, path);
	
	PHALCON_CALL_METHOD(&engines, this_ptr, "_loadtemplateengines");
	
	phalcon_is_iterable(engines, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(extension, ah0, hp0);
		PHALCON_GET_HVALUE(engine);
	
		PHALCON_INIT_NVAR(view_engine_path);
		PHALCON_CONCAT_VV(view_engine_path, views_dir_path, extension);
	
		if (phalcon_file_exists(view_engine_path TSRMLS_CC) == SUCCESS) {
	
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
	
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:beforeRenderView", 1);
	
				PHALCON_CALL_METHOD(&status, events_manager, "fire", event_name, this_ptr, view_engine_path);
				if (PHALCON_IS_FALSE(status)) {
					zend_hash_move_forward_ex(ah0, &hp0);
					continue;
				}
			}
			
			PHALCON_CALL_METHOD(NULL, engine, "render", view_engine_path, params, PHALCON_GLOBAL(z_true));
	
			PHALCON_INIT_NVAR(not_exists);
			ZVAL_FALSE(not_exists);
			if (Z_TYPE_P(events_manager) == IS_OBJECT) {
				PHALCON_INIT_NVAR(event_name);
				ZVAL_STRING(event_name, "view:afterRenderView", 1);
				PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
			}
	
			break;
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (PHALCON_IS_TRUE(not_exists)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "View '", views_dir_path, "' was not found in the views directory");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	if (Z_TYPE_P(events_manager) == IS_OBJECT) {
		PHALCON_INIT_NVAR(event_name);
		ZVAL_STRING(event_name, "view:afterRender", 1);
		PHALCON_CALL_METHOD(NULL, events_manager, "fire", event_name, this_ptr);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, render){

	zval *path, *params = NULL, *cache = NULL, *is_started = NULL, *key = NULL, *lifetime = NULL;
	zval *cache_options, *content = NULL, *view_params;
	zval *merged_params = NULL, *is_fresh = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &path, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	PHALCON_CALL_METHOD(&cache, this_ptr, "getcache");
	if (Z_TYPE_P(cache) == IS_OBJECT) {
	
		PHALCON_CALL_METHOD(&is_started, cache, "isstarted");
		if (PHALCON_IS_FALSE(is_started)) {
	
			PHALCON_INIT_VAR(key);
	
			PHALCON_INIT_VAR(lifetime);
	
			PHALCON_OBS_VAR(cache_options);
			phalcon_read_property_this(&cache_options, this_ptr, SL("_cacheOptions"), PH_NOISY TSRMLS_CC);
	
			if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
				if (phalcon_array_isset_quick_string(cache_options, SS("key"), 2090432846UL)) {
					PHALCON_OBS_NVAR(key);
					phalcon_array_fetch_quick_string(&key, cache_options, SS("key"), 2090432846UL, PH_NOISY);
				}
				if (phalcon_array_isset_quick_string(cache_options, SS("lifetime"), 2639810228UL)) {
					PHALCON_OBS_NVAR(lifetime);
					phalcon_array_fetch_quick_string(&lifetime, cache_options, SS("lifetime"), 2639810228UL, PH_NOISY);
				}
			}
	
			if (Z_TYPE_P(key) == IS_NULL) {
				PHALCON_INIT_NVAR(key);
				phalcon_md5(key, path);
			}
	
			PHALCON_CALL_METHOD(&content, cache, "start", key, lifetime);
			if (Z_TYPE_P(content) != IS_NULL) {
				phalcon_update_property_this_quick(this_ptr, SL("_content"), content, 4081318271UL TSRMLS_CC);
				RETURN_CTOR(content);
			}
		}
	}
	
	phalcon_create_symbol_table(TSRMLS_C);
	
	phalcon_ob_start(TSRMLS_C);
	
	PHALCON_OBS_VAR(view_params);
	phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
		if (Z_TYPE_P(view_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &view_params, &params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, params);
		}
	} else {
		PHALCON_CPY_WRT(merged_params, view_params);
	}
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "_internalrender", path, merged_params);
	
	if (Z_TYPE_P(cache) == IS_OBJECT) {
		PHALCON_CALL_METHOD(&is_started, cache, "isstarted");
		if (PHALCON_IS_TRUE(is_started)) {
			PHALCON_CALL_METHOD(&is_fresh, cache, "isfresh");
			if (PHALCON_IS_TRUE(is_fresh)) {
				PHALCON_CALL_METHOD(NULL, cache, "save");
			} else {
				PHALCON_CALL_METHOD(NULL, cache, "stop");
			}
		} else {
			PHALCON_CALL_METHOD(NULL, cache, "stop");
		}
	}
	
	phalcon_ob_end_clean(TSRMLS_C);
	
	PHALCON_OBS_NVAR(content);
	phalcon_read_property_this(&content, this_ptr, SL("_content"), PH_NOISY TSRMLS_CC);
	RETURN_CTOR(content);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, partial){

	zval *partial_path, *params = NULL, *view_params = NULL, *merged_params = NULL;
	zval *content;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &partial_path, &params);
	
	if (!params) {
		params = PHALCON_GLOBAL(z_null);
	}
	
	phalcon_ob_start(TSRMLS_C);
	
	if (Z_TYPE_P(params) == IS_ARRAY) { 
	
		PHALCON_OBS_VAR(view_params);
		phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	
		if (Z_TYPE_P(view_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &view_params, &params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, params);
		}
	
		phalcon_create_symbol_table(TSRMLS_C);
	
	} else {
		PHALCON_CPY_WRT(merged_params, params);
	}
	
	PHALCON_CALL_METHOD(NULL, this_ptr, "_internalrender", partial_path, merged_params);
	
	if (view_params != NULL) {
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), view_params, 1685283331UL TSRMLS_CC);
	}
	
	phalcon_ob_end_clean(TSRMLS_C);
	
	content = phalcon_fetch_nproperty_this(this_ptr, SL("_content"), PH_NOISY TSRMLS_CC);
	
	zend_print_zval(content, 0);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setCacheOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	phalcon_update_property_this_quick(this_ptr, SL("_cacheOptions"), options, 528255652UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getCacheOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_cacheOptions", 528255652UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, _createCache){

	zval *dependency_injector, *cache_service = NULL;
	zval *cache_options;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(dependency_injector);
	phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "A dependency injector container is required to obtain the view cache services");
		return;
	}
	
	PHALCON_INIT_VAR(cache_service);
	ZVAL_STRING(cache_service, "viewCache", 1);
	
	PHALCON_OBS_VAR(cache_options);
	phalcon_read_property_this(&cache_options, this_ptr, SL("_cacheOptions"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(cache_options) == IS_ARRAY) { 
		if (phalcon_array_isset_quick_string(cache_options, SS("service"), 243174486UL)) {
			PHALCON_OBS_NVAR(cache_service);
			phalcon_array_fetch_quick_string(&cache_service, cache_options, SS("service"), 243174486UL, PH_NOISY);
		}
	}
	
	PHALCON_RETURN_CALL_METHOD(dependency_injector, "getshared", cache_service);
	if (return_value_ptr) {
		return_value = *return_value_ptr;
	}

	if (Z_TYPE_P(return_value) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The injected caching service is invalid");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE(return_value, phalcon_cache_backendinterface_ce);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getCache){

	zval *cache = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(cache);
	phalcon_read_property_this(&cache, this_ptr, SL("_cache"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(cache)) {
		if (Z_TYPE_P(cache) != IS_OBJECT) {
			PHALCON_CALL_METHOD(&cache, this_ptr, "_createcache");
			phalcon_update_property_this_quick(this_ptr, SL("_cache"), cache, 2191407384UL TSRMLS_CC);
		}
	}
	
	RETURN_CCTOR(cache);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, cache){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(options) == IS_ARRAY) { 
		phalcon_update_property_this(this_ptr, SL("_cache"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_cacheOptions"), options, 528255652UL TSRMLS_CC);
	} else {
		if (zend_is_true(options)) {
			phalcon_update_property_this(this_ptr, SL("_cache"), PHALCON_GLOBAL(z_true) TSRMLS_CC);
		} else {
			phalcon_update_property_this(this_ptr, SL("_cache"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
		}
	}
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setParamToView){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setVars){

	zval *params, *merge = NULL, *view_params, *merged_params = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &params, &merge);
	
	if (!merge) {
		merge = PHALCON_GLOBAL(z_true);
	}
	
	if (Z_TYPE_P(params) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The render parameters must be an array");
		return;
	}

	if (zend_is_true(merge)) {
		PHALCON_OBS_VAR(view_params);
		phalcon_read_property_this(&view_params, this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(view_params) == IS_ARRAY) { 
			PHALCON_INIT_VAR(merged_params);
			phalcon_fast_array_merge(merged_params, &view_params, &params TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(merged_params, params);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), merged_params, 1685283331UL TSRMLS_CC);
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_viewParams"), params, 1685283331UL TSRMLS_CC);
	}
	
	RETURN_THIS();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setVar){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	RETURN_THISW();
}


static PHP_METHOD(Phalcon_Mvc_View_Simple, getParamsToView){


	RETURN_MEMBER_QUICK(this_ptr, "_viewParams", 1685283331UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, setContent){

	zval *content;

	phalcon_fetch_params(0, 1, 0, &content);
	
	if (Z_TYPE_P(content) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Content must be a string");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_content"), content, 4081318271UL TSRMLS_CC);
	
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getContent){


	RETURN_MEMBER_QUICK(this_ptr, "_content", 4081318271UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, getActiveRenderPath){


	RETURN_MEMBER_QUICK(this_ptr, "_activeRenderPath", 1528023309UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, __set){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_viewParams"), key, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Simple, __get){

	zval *key, *params, *value;

	phalcon_fetch_params(0, 1, 0, &key);
	
	params = phalcon_fetch_nproperty_this(this_ptr, SL("_viewParams"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, params, key)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_NULL();
}



#include <Zend/zend_globals.h>

zend_bool phalcon_mvc_view_engine_php_symtable_merger(HashTable *ht, void *pData, zend_hash_key *hash_key, void *pParam)
{
#ifdef ZTS
	TSRMLS_FETCH_FROM_CTX(pParam);
#endif

	return hash_key->arKey && hash_key->nKeyLength && !zend_hash_quick_exists(CG(auto_globals), hash_key->arKey, hash_key->nKeyLength, hash_key->h);
}






zend_class_entry *phalcon_mvc_view_engine_php_ce;

static PHP_METHOD(Phalcon_Mvc_View_Engine_Php, render);

static const zend_function_entry phalcon_mvc_view_engine_php_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View_Engine_Php, render, arginfo_phalcon_mvc_view_engineinterface_render, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Php){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View\\Engine, Php, mvc_view_engine_php, phalcon_mvc_view_engine_ce, phalcon_mvc_view_engine_php_method_entry, 0);

	zend_class_implements(phalcon_mvc_view_engine_php_ce TSRMLS_CC, 1, phalcon_mvc_view_engineinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Php, render){

	zval **path, **params, **must_clean = NULL, *contents;
	zval *view;
	int clean;

	phalcon_fetch_params_ex(2, 1, &path, &params, &must_clean);
	PHALCON_ENSURE_IS_STRING(path);
	
	if (!must_clean) {
		must_clean = &PHALCON_GLOBAL(z_false);
	}
	
	clean = PHALCON_IS_TRUE(*must_clean);

	if (clean) {
		phalcon_ob_clean(TSRMLS_C);
	}
	
	if (Z_TYPE_PP(params) == IS_ARRAY) {
		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		zend_hash_merge_ex(
			EG(active_symbol_table),
			Z_ARRVAL_PP(params),
			(copy_ctor_func_t)zval_add_ref,
			sizeof(zval*),
			phalcon_mvc_view_engine_php_symtable_merger
#ifdef ZTS
			TSRMLS_CC
#else
			, NULL
#endif
		);
	}
	
	if (phalcon_require(Z_STRVAL_PP(path) TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}

	if (clean) {
		PHALCON_ALLOC_GHOST_ZVAL(contents);
		phalcon_ob_get_contents(contents TSRMLS_CC);
	
		view = phalcon_fetch_nproperty_this(this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
		PHALCON_CALL_METHODW(NULL, view, "setcontent", contents);
	}

	RETURN_TRUE;
}






zend_class_entry *phalcon_mvc_view_engine_volt_ce;

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, setOptions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getOptions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getCompiler);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, render);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, length);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, isIncluded);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, convertEncoding);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, slice);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, sort);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_setoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_length, 0, 0, 1)
	ZEND_ARG_INFO(0, item)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_isincluded, 0, 0, 2)
	ZEND_ARG_INFO(0, needle)
	ZEND_ARG_INFO(0, haystack)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_convertencoding, 0, 0, 3)
	ZEND_ARG_INFO(0, text)
	ZEND_ARG_INFO(0, from)
	ZEND_ARG_INFO(0, to)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_slice, 0, 0, 2)
	ZEND_ARG_INFO(0, value)
	ZEND_ARG_INFO(0, start)
	ZEND_ARG_INFO(0, end)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_sort, 0, 0, 1)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_view_engine_volt_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, setOptions, arginfo_phalcon_mvc_view_engine_volt_setoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, getCompiler, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, render, arginfo_phalcon_mvc_view_engineinterface_render, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, length, arginfo_phalcon_mvc_view_engine_volt_length, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, isIncluded, arginfo_phalcon_mvc_view_engine_volt_isincluded, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, convertEncoding, arginfo_phalcon_mvc_view_engine_volt_convertencoding, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, slice, arginfo_phalcon_mvc_view_engine_volt_slice, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt, sort, arginfo_phalcon_mvc_view_engine_volt_sort, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Volt){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Mvc\\View\\Engine, Volt, mvc_view_engine_volt, phalcon_mvc_view_engine_ce, phalcon_mvc_view_engine_volt_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_engine_volt_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_ce, SL("_compiler"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_engine_volt_ce TSRMLS_CC, 1, phalcon_mvc_view_engineinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, setOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Options parameter must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, getCompiler){

	zval *compiler = NULL, *view, *options, *dependency_injector;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(compiler);
	phalcon_read_property_this(&compiler, this_ptr, SL("_compiler"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(compiler) != IS_OBJECT) {
	
		PHALCON_OBS_VAR(view);
		phalcon_read_property_this(&view, this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(options);
		phalcon_read_property_this(&options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	
		PHALCON_OBS_VAR(dependency_injector);
		phalcon_read_property_this(&dependency_injector, this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(compiler);
		object_init_ex(compiler, phalcon_mvc_view_engine_volt_compiler_ce);
		PHALCON_CALL_METHOD(NULL, compiler, "__construct", view);
	
		if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
			PHALCON_CALL_METHOD(NULL, compiler, "setdi", dependency_injector);
		}
	
		if (Z_TYPE_P(options) == IS_ARRAY) { 
			PHALCON_CALL_METHOD(NULL, compiler, "setoptions", options);
		}
	
		phalcon_update_property_this_quick(this_ptr, SL("_compiler"), compiler, 96166463UL TSRMLS_CC);
	}
	
	RETURN_CCTOR(compiler);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, render){

	zval **template_path, **params, **must_clean = NULL, *compiler = NULL;
	zval *compiled_template_path = NULL, *contents;
	zval *view;
	int clean;

	phalcon_fetch_params_ex(2, 1, &template_path, &params, &must_clean);
	PHALCON_ENSURE_IS_STRING(template_path);
	
	if (!must_clean) {
		clean = 0;
	}
	else {
		clean = PHALCON_IS_TRUE(*must_clean);
	}
	
	if (clean) {
		phalcon_ob_clean(TSRMLS_C);
	}

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&compiler, this_ptr, "getcompiler");
	PHALCON_CALL_METHOD(NULL, compiler, "compile", *template_path);
	PHALCON_CALL_METHOD(&compiled_template_path, compiler, "getcompiledtemplatepath");
	
	if (Z_TYPE_PP(params) == IS_ARRAY) {
		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		zend_hash_merge_ex(
			EG(active_symbol_table),
			Z_ARRVAL_PP(params),
			(copy_ctor_func_t)zval_add_ref,
			sizeof(zval*),
			phalcon_mvc_view_engine_php_symtable_merger
#ifdef ZTS
			TSRMLS_CC
#else
			, NULL
#endif
		);
	}
	
	convert_to_string(compiled_template_path);
	if (phalcon_require(Z_STRVAL_P(compiled_template_path) TSRMLS_CC) == FAILURE) {
		RETVAL_FALSE;
		RETURN_MM();
	}

	if (clean) {
		PHALCON_INIT_VAR(contents);
		phalcon_ob_get_contents(contents TSRMLS_CC);
	
		view = phalcon_fetch_nproperty_this(this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
		PHALCON_CALL_METHOD(NULL, view, "setcontent", contents);
	}
	
	RETVAL_TRUE;
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, length){

	zval *item;

	phalcon_fetch_params(0, 1, 0, &item);
	
	if (Z_TYPE_P(item) == IS_OBJECT || Z_TYPE_P(item) == IS_ARRAY) {
		phalcon_fast_count(return_value, item TSRMLS_CC);
	} else if (phalcon_function_quick_exists_ex(SS("mb_strlen"), 3716840971UL TSRMLS_CC) == SUCCESS) {
		PHALCON_RETURN_CALL_FUNCTIONW("mb_strlen", item);
	} else {
		phalcon_fast_strlen(return_value, item);
	}
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, isIncluded){

	zval *needle, *haystack;

	phalcon_fetch_params(0, 2, 0, &needle, &haystack);
	
	if (Z_TYPE_P(haystack) == IS_ARRAY) { 
		RETURN_BOOL(phalcon_fast_in_array(needle, haystack TSRMLS_CC));
	}

	if (Z_TYPE_P(haystack) == IS_STRING) {
		if (phalcon_function_quick_exists_ex(SS("mb_strpos"), 3716995774UL TSRMLS_CC) == SUCCESS) {
			PHALCON_RETURN_CALL_FUNCTIONW("mb_strpos", haystack, needle);
			return;
		}

		phalcon_fast_strpos(return_value, haystack, needle);
	}
	
	PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Invalid haystack");
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, convertEncoding){

	zval *text, *from, *to;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &text, &from, &to);
	
	if (PHALCON_IS_STRING(from, "latin1")) {
		if (PHALCON_IS_STRING(to, "utf8")) {
			PHALCON_RETURN_CALL_FUNCTION("utf8_encode", text);
			RETURN_MM();
		}
	}
	
	if (PHALCON_IS_STRING(to, "latin1")) {
		if (PHALCON_IS_STRING(from, "utf8")) {
			PHALCON_RETURN_CALL_FUNCTION("utf8_decode", text);
			RETURN_MM();
		}
	}
	
	if (phalcon_function_quick_exists_ex(SS("mb_convert_encoding"), 2165643194UL TSRMLS_CC) == SUCCESS) {
		PHALCON_RETURN_CALL_FUNCTION("mb_convert_encoding", text, from, to);
		RETURN_MM();
	}
	
	if (phalcon_function_quick_exists_ex(SS("iconv"), 67824100UL TSRMLS_CC) == SUCCESS) {
		PHALCON_RETURN_CALL_FUNCTION("iconv", from, to, text);
		RETURN_MM();
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Any of 'mbstring' or 'iconv' is required to perform the charset conversion");
	return;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, slice){

	zval *value, *start, *end = NULL, *slice, *length = NULL, *position;
	zval *current = NULL, *range;
	zval *r0 = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &value, &start, &end);
	
	if (!end) {
		end = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(value) == IS_OBJECT) {
	
		PHALCON_INIT_VAR(slice);
		array_init(slice);
		if (Z_TYPE_P(end) == IS_NULL) {
			PHALCON_INIT_VAR(length);
			phalcon_fast_count(length, value TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(length, end);
		}
	
		PHALCON_INIT_VAR(position);
		ZVAL_LONG(position, 0);
		PHALCON_CALL_METHOD(NULL, value, "rewind");
	
		while (1) {
			PHALCON_CALL_METHOD(&r0, value, "valid");
			if (zend_is_true(r0)) {
			} else {
				break;
			}
	
			if (PHALCON_GE(position, start)) {
				if (PHALCON_LE(position, length)) {
					PHALCON_CALL_METHOD(&current, value, "current");
					phalcon_array_append(&slice, current, PH_SEPARATE);
				}
			}
			PHALCON_CALL_METHOD(NULL, value, "next");
			phalcon_increment(position);
		}
	
		RETURN_CTOR(slice);
	}
	
	if (Z_TYPE_P(end) != IS_NULL) {
		PHALCON_INIT_VAR(range);
		sub_function(range, end, start TSRMLS_CC);
	
		PHALCON_INIT_NVAR(length);
		phalcon_add_function(length, range, PHALCON_GLOBAL(z_one) TSRMLS_CC);
	} else {
		PHALCON_INIT_NVAR(length);
	}
	
	if (Z_TYPE_P(value) == IS_ARRAY) { 
		PHALCON_RETURN_CALL_FUNCTION("array_slice", value, start, length);
		RETURN_MM();
	}
	
	if (phalcon_function_quick_exists_ex(SS("mb_substr"), 3737269654UL TSRMLS_CC) == SUCCESS) {
		if (Z_TYPE_P(length) != IS_NULL) {
			PHALCON_RETURN_CALL_FUNCTION("mb_substr", value, start, length);
			RETURN_MM();
		}
		PHALCON_RETURN_CALL_FUNCTION("mb_substr", value, start);
		RETURN_MM();
	}
	
	if (Z_TYPE_P(length) != IS_NULL) {
		PHALCON_RETURN_CALL_FUNCTION("substr", value, start, length);
		RETURN_MM();
	}
	
	PHALCON_RETURN_CALL_FUNCTION("substr", value, start);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt, sort){

	zval *value;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &value);
	PHALCON_SEPARATE_PARAM(value);
	
	Z_SET_ISREF_P(value);
	PHALCON_CALL_FUNCTION(NULL, "asort", value);
	Z_UNSET_ISREF_P(value);
	RETURN_CTOR(value);
}




#include <Zend/zend_closures.h>


zend_class_entry *phalcon_mvc_view_engine_volt_compiler_ce;

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, __construct);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setOptions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setOption);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getOption);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getOptions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, fireExtensionEvent);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addExtension);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getExtensions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addFunction);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getFunctions);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addFilter);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getFilters);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setUniquePrefix);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getUniquePrefix);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, attributeReader);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, functionCall);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveTest);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveFilter);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, expression);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementListOrExtends);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForeach);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForElse);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileIf);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileElseIf);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCache);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileEcho);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileInclude);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileSet);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileDo);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileReturn);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileAutoEscape);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileMacro);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCall);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileFile);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compile);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getTemplatePath);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getCompiledTemplatePath);
static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, parse);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, view)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_setoptions, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_setoption, 0, 0, 2)
	ZEND_ARG_INFO(0, option)
	ZEND_ARG_INFO(0, value)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_getoption, 0, 0, 1)
	ZEND_ARG_INFO(0, option)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_fireextensionevent, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, arguments)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_addextension, 0, 0, 1)
	ZEND_ARG_INFO(0, extension)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_addfunction, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_addfilter, 0, 0, 2)
	ZEND_ARG_INFO(0, name)
	ZEND_ARG_INFO(0, definition)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_setuniqueprefix, 0, 0, 1)
	ZEND_ARG_INFO(0, prefix)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_attributereader, 0, 0, 1)
	ZEND_ARG_INFO(0, expr)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_functioncall, 0, 0, 1)
	ZEND_ARG_INFO(0, expr)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_resolvetest, 0, 0, 2)
	ZEND_ARG_INFO(0, test)
	ZEND_ARG_INFO(0, left)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_expression, 0, 0, 1)
	ZEND_ARG_INFO(0, expr)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileforeach, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileif, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileelseif, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilecache, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileecho, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileinclude, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileset, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compiledo, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilereturn, 0, 0, 1)
	ZEND_ARG_INFO(0, statement)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compileautoescape, 0, 0, 2)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilemacro, 0, 0, 2)
	ZEND_ARG_INFO(0, statement)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilestring, 0, 0, 1)
	ZEND_ARG_INFO(0, viewCode)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compilefile, 0, 0, 2)
	ZEND_ARG_INFO(0, path)
	ZEND_ARG_INFO(0, compiledPath)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_compile, 0, 0, 1)
	ZEND_ARG_INFO(0, templatePath)
	ZEND_ARG_INFO(0, extendsMode)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_mvc_view_engine_volt_compiler_parse, 0, 0, 1)
	ZEND_ARG_INFO(0, viewCode)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_mvc_view_engine_volt_compiler_method_entry[] = {
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, __construct, arginfo_phalcon_mvc_view_engine_volt_compiler___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, setOptions, arginfo_phalcon_mvc_view_engine_volt_compiler_setoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, setOption, arginfo_phalcon_mvc_view_engine_volt_compiler_setoption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getOption, arginfo_phalcon_mvc_view_engine_volt_compiler_getoption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getOptions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, fireExtensionEvent, arginfo_phalcon_mvc_view_engine_volt_compiler_fireextensionevent, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, addExtension, arginfo_phalcon_mvc_view_engine_volt_compiler_addextension, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getExtensions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, addFunction, arginfo_phalcon_mvc_view_engine_volt_compiler_addfunction, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getFunctions, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, addFilter, arginfo_phalcon_mvc_view_engine_volt_compiler_addfilter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getFilters, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, setUniquePrefix, arginfo_phalcon_mvc_view_engine_volt_compiler_setuniqueprefix, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getUniquePrefix, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, attributeReader, arginfo_phalcon_mvc_view_engine_volt_compiler_attributereader, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, functionCall, arginfo_phalcon_mvc_view_engine_volt_compiler_functioncall, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveTest, arginfo_phalcon_mvc_view_engine_volt_compiler_resolvetest, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveFilter, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, expression, arginfo_phalcon_mvc_view_engine_volt_compiler_expression, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementListOrExtends, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForeach, arginfo_phalcon_mvc_view_engine_volt_compiler_compileforeach, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForElse, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileIf, arginfo_phalcon_mvc_view_engine_volt_compiler_compileif, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileElseIf, arginfo_phalcon_mvc_view_engine_volt_compiler_compileelseif, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCache, arginfo_phalcon_mvc_view_engine_volt_compiler_compilecache, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileEcho, arginfo_phalcon_mvc_view_engine_volt_compiler_compileecho, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileInclude, arginfo_phalcon_mvc_view_engine_volt_compiler_compileinclude, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileSet, arginfo_phalcon_mvc_view_engine_volt_compiler_compileset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileDo, arginfo_phalcon_mvc_view_engine_volt_compiler_compiledo, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileReturn, arginfo_phalcon_mvc_view_engine_volt_compiler_compilereturn, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileAutoEscape, arginfo_phalcon_mvc_view_engine_volt_compiler_compileautoescape, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileMacro, arginfo_phalcon_mvc_view_engine_volt_compiler_compilemacro, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCall, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString, arginfo_phalcon_mvc_view_engine_volt_compiler_compilestring, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compileFile, arginfo_phalcon_mvc_view_engine_volt_compiler_compilefile, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, compile, arginfo_phalcon_mvc_view_engine_volt_compiler_compile, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getTemplatePath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, getCompiledTemplatePath, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Mvc_View_Engine_Volt_Compiler, parse, arginfo_phalcon_mvc_view_engine_volt_compiler_parse, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Mvc_View_Engine_Volt_Compiler){

	PHALCON_REGISTER_CLASS(Phalcon\\Mvc\\View\\Engine\\Volt, Compiler, mvc_view_engine_volt_compiler, phalcon_mvc_view_engine_volt_compiler_method_entry, 0);

	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_view"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_arrayHelpers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_engine_volt_compiler_ce, SL("_level"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_engine_volt_compiler_ce, SL("_foreachLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_engine_volt_compiler_ce, SL("_blockLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_mvc_view_engine_volt_compiler_ce, SL("_exprLevel"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_engine_volt_compiler_ce, SL("_extended"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_mvc_view_engine_volt_compiler_ce, SL("_autoescape"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_extendedBlocks"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_currentBlock"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_blocks"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_forElsePointers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_loopPointers"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_extensions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_functions"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_filters"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_macros"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_prefix"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_currentPath"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_mvc_view_engine_volt_compiler_ce, SL("_compiledTemplatePath"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_mvc_view_engine_volt_compiler_ce TSRMLS_CC, 1, phalcon_di_injectionawareinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, __construct){

	zval *view = NULL;

	phalcon_fetch_params(0, 0, 1, &view);
	
	if (view && Z_TYPE_P(view) == IS_OBJECT) {
		phalcon_update_property_this_quick(this_ptr, SL("_view"), view, 3993744575UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_mvc_view_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setOptions){

	zval *options;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Options must be an array");
		return;
	}
	phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setOption){

	zval *option, *value;

	phalcon_fetch_params(0, 2, 0, &option, &value);
	
	phalcon_update_property_array(this_ptr, SL("_options"), option, value TSRMLS_CC);
	
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getOption){

	zval *option, *options, *value;

	phalcon_fetch_params(0, 1, 0, &option);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, options, option)) {
		RETURN_ZVAL(value, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getOptions){


	RETURN_MEMBER_QUICK(this_ptr, "_options", 1620153008UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, fireExtensionEvent){

	zval *name, *arguments = NULL, *extensions;
	zval *call_object = NULL, *status = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &name, &arguments);
	
	if (!arguments) {
		arguments = PHALCON_GLOBAL(z_null);
	}
	
	extensions = phalcon_fetch_nproperty_this(this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(extensions) == IS_ARRAY) { 
		zval **extension;
		HashTable *h = Z_ARRVAL_P(extensions);
		HashPosition pos;

		for (
			zend_hash_internal_pointer_reset_ex(h, &pos);
			zend_hash_get_current_data_ex(h, (void**)&extension, &pos) == SUCCESS;
			zend_hash_move_forward_ex(h, &pos)
		) {
			if (phalcon_method_exists(*extension, name TSRMLS_CC) == SUCCESS) {
				PHALCON_INIT_NVAR(status);
				PHALCON_INIT_NVAR(call_object);
				array_init_size(call_object, 2);
				phalcon_array_append(&call_object, *extension, 0);
				phalcon_array_append(&call_object, name, 0);
				if (Z_TYPE_P(arguments) == IS_ARRAY) { 
					PHALCON_CALL_USER_FUNC_ARRAY(status, call_object, arguments);
				} else {
					PHALCON_CALL_USER_FUNC(status, call_object);
				}
	
				if (Z_TYPE_P(status) == IS_STRING) {
					RETURN_CCTOR(status);
				}
			}
		}
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addExtension){

	zval *extension;

	phalcon_fetch_params(0, 1, 0, &extension);

	if (Z_TYPE_P(extension) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "The extension is not valid");
		return;
	}
	
	if (phalcon_method_quick_exists_ex(extension, SS("initialize"), 2896075127UL TSRMLS_CC) == SUCCESS) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, extension, "initialize", this_ptr);
		PHALCON_MM_RESTORE();
	}
	
	phalcon_update_property_array_append(this_ptr, SL("_extensions"), extension TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getExtensions){


	RETURN_MEMBER_QUICK(this_ptr, "_extensions", 726159316UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addFunction){

	zval **name, **definition;

	phalcon_fetch_params_ex(2, 0, &name, &definition);
	PHALCON_ENSURE_IS_STRING(name);

	phalcon_update_property_array(this_ptr, SL("_functions"), *name, *definition TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getFunctions){


	RETURN_MEMBER_QUICK(this_ptr, "_functions", 2704716189UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, addFilter){

	zval **name, **definition;

	phalcon_fetch_params_ex(2, 0, &name, &definition);
	PHALCON_ENSURE_IS_STRING(name);
	
	phalcon_update_property_array(this_ptr, SL("_filters"), *name, *definition TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getFilters){


	RETURN_MEMBER_QUICK(this_ptr, "_filters", 3850488637UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, setUniquePrefix){

	zval *prefix;

	phalcon_fetch_params(0, 1, 0, &prefix);
	
	phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getUniquePrefix){

	zval *prefix = NULL, *parameters, *calculated_prefix = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(prefix);
	phalcon_read_property_this(&prefix, this_ptr, SL("_prefix"), PH_NOISY TSRMLS_CC);
	
	if (!zend_is_true(prefix)) {
		zval *current_path = phalcon_fetch_nproperty_this(this_ptr, SL("_currentPath"), PH_NOISY TSRMLS_CC);
	
		PHALCON_INIT_NVAR(prefix);
		phalcon_unique_path_key(prefix, current_path TSRMLS_CC);
		phalcon_update_property_this_quick(this_ptr, SL("_prefix"), prefix, 3873791314UL TSRMLS_CC);
	}
	
	if (Z_TYPE_P(prefix) == IS_OBJECT) {
		if (instanceof_function(Z_OBJCE_P(prefix), zend_ce_closure TSRMLS_CC)) {
			PHALCON_INIT_VAR(parameters);
			array_init_size(parameters, 1);
			phalcon_array_append(&parameters, this_ptr, 0);
	
			PHALCON_CALL_FUNCTION(&calculated_prefix, "call_user_func_array", prefix, parameters);
			phalcon_update_property_this_quick(this_ptr, SL("_prefix"), calculated_prefix, 3873791314UL TSRMLS_CC);
			PHALCON_CPY_WRT(prefix, calculated_prefix);
		}
	}
	
	if (Z_TYPE_P(prefix) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The unique compilation prefix is invalid");
		return;
	}
	
	RETURN_CCTOR(prefix);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, attributeReader){

	zval *expr, *expr_code, *loop_context, *left, *left_type;
	zval *variable, *prefix = NULL;
	zval *is_service = NULL, *left_code = NULL, *right, *right_type;
	zval *member, *right_code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	PHALCON_INIT_VAR(expr_code);
	
	PHALCON_INIT_VAR(loop_context);
	
	PHALCON_OBS_VAR(left);
	phalcon_array_fetch_quick_string(&left, expr, SS("left"), 265976240UL, PH_NOISY);
	
	PHALCON_OBS_VAR(left_type);
	phalcon_array_fetch_quick_string(&left_type, left, SS("type"), 276192743UL, PH_NOISY);
	if (PHALCON_IS_LONG(left_type, PHVOLT_T_IDENTIFIER)) {
	
		PHALCON_OBS_VAR(variable);
		phalcon_array_fetch_quick_string(&variable, left, SS("value"), 574111618UL, PH_NOISY);
	
		if (PHALCON_IS_STRING(variable, "loop")) {
			zval *level = phalcon_fetch_nproperty_this(this_ptr, SL("_foreachLevel"), PH_NOISY TSRMLS_CC);
	
			PHALCON_CALL_METHOD(&prefix, this_ptr, "getuniqueprefix");
			PHALCON_SCONCAT_SVVS(expr_code, "$", prefix, level, "loop");
			phalcon_update_property_array(this_ptr, SL("_loopPointers"), level, level TSRMLS_CC);
		} else {
			zval *dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(dependency_injector) == IS_OBJECT) {
	
				PHALCON_CALL_METHOD(&is_service, dependency_injector, "has", variable);
				if (zend_is_true(is_service)) {
					PHALCON_SCONCAT_SV(expr_code, "$this->", variable);
				} else {
					PHALCON_SCONCAT_SV(expr_code, "$", variable);
				}
			} else {
				PHALCON_SCONCAT_SV(expr_code, "$", variable);
			}
		}
	} else {
		PHALCON_CALL_METHOD(&left_code, this_ptr, "expression", left);
		if (!PHALCON_IS_LONG(left_type, PHVOLT_T_DOT)) {
			if (!PHALCON_IS_LONG(left_type, PHVOLT_T_FCALL)) {
				PHALCON_SCONCAT_SVS(expr_code, "(", left_code, ")");
			} else {
				phalcon_concat_self(&expr_code, left_code TSRMLS_CC);
			}
		} else {
			phalcon_concat_self(&expr_code, left_code TSRMLS_CC);
		}
	}
	
	phalcon_concat_self_str(&expr_code, SL("->") TSRMLS_CC);
	
	PHALCON_OBS_VAR(right);
	phalcon_array_fetch_quick_string(&right, expr, SS("right"), 426864067UL, PH_NOISY);
	
	PHALCON_OBS_VAR(right_type);
	phalcon_array_fetch_quick_string(&right_type, right, SS("type"), 276192743UL, PH_NOISY);
	if (PHALCON_IS_LONG(right_type, PHVOLT_T_IDENTIFIER)) {
		PHALCON_OBS_VAR(member);
		phalcon_array_fetch_quick_string(&member, right, SS("value"), 574111618UL, PH_NOISY);
		phalcon_concat_self(&expr_code, member TSRMLS_CC);
	} else {
		PHALCON_CALL_METHOD(&right_code, this_ptr, "expression", right);
		phalcon_concat_self(&expr_code, right_code TSRMLS_CC);
	}
	
	RETURN_CCTOR(expr_code);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, functionCall){

	zval *expr, *code = NULL, *func_arguments = NULL, *arguments = NULL;
	zval *name_expr, *name_type, *name = NULL;
	zval *event;
	zval *line = NULL, *file = NULL, *exception_message = NULL;
	zval *block, *escaped_code = NULL, *camelized;
	zval *method, *class_name, *array_helpers = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	if (Z_TYPE_P(expr) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted function call");
		return;
	}
	
	PHALCON_INIT_VAR(code);
	
	if (phalcon_array_isset_quick_string(expr, SS("arguments"), 3751272283UL)) {
		PHALCON_OBS_VAR(func_arguments);
		phalcon_array_fetch_quick_string(&func_arguments, expr, SS("arguments"), 3751272283UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&arguments, this_ptr, "expression", func_arguments);
	} else {
		PHALCON_INIT_VAR(func_arguments);
		PHALCON_INIT_VAR(arguments);
		ZVAL_EMPTY_STRING(arguments);
	}
	
	PHALCON_OBS_VAR(name_expr);
	phalcon_array_fetch_quick_string(&name_expr, expr, SS("name"), 268211462UL, PH_NOISY);
	
	PHALCON_OBS_VAR(name_type);
	phalcon_array_fetch_quick_string(&name_type, name_expr, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_LONG(name_type, PHVOLT_T_IDENTIFIER)) {
		zval *extensions, *functions, *macros;

		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, name_expr, SS("value"), 574111618UL, PH_NOISY);
	
		extensions = phalcon_fetch_nproperty_this(this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(extensions) == IS_ARRAY) { 
			zval *fire_arguments;

			PHALCON_INIT_VAR(event);
			ZVAL_STRING(event, "compileFunction", 1);
	
			PHALCON_ALLOC_GHOST_ZVAL(fire_arguments);
			array_init_size(fire_arguments, 3);
			phalcon_array_append(&fire_arguments, name, 0);
			phalcon_array_append(&fire_arguments, arguments, 0);
			phalcon_array_append(&fire_arguments, func_arguments, 0);
	
			PHALCON_CALL_METHOD(&code, this_ptr, "fireextensionevent", event, fire_arguments);
			if (Z_TYPE_P(code) == IS_STRING) {
				RETURN_CCTOR(code);
			}
		}
	
		functions = phalcon_fetch_nproperty_this(this_ptr, SL("_functions"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(functions) == IS_ARRAY) { 
			zval *definition;

			if (phalcon_array_isset_fetch(&definition, functions, name)) {
				if (Z_TYPE_P(definition) == IS_STRING) {
					PHALCON_CONCAT_VSVS(return_value, definition, "(", arguments, ")");
					RETURN_MM();
				}
	
				if (Z_TYPE_P(definition) == IS_OBJECT) {
					if (instanceof_function(Z_OBJCE_P(definition), zend_ce_closure TSRMLS_CC)) {
						zval *parameters;

						PHALCON_ALLOC_GHOST_ZVAL(parameters);
						array_init_size(parameters, 2);
						phalcon_array_append(&parameters, arguments, 0);
						phalcon_array_append(&parameters, func_arguments, 0);
						PHALCON_RETURN_CALL_FUNCTION("call_user_func_array", definition, parameters);
						RETURN_MM();
					}
				}
	
				PHALCON_OBS_VAR(line);
				phalcon_array_fetch_quick_string(&line, expr, SS("line"), 266128205UL, PH_NOISY);
	
				PHALCON_OBS_VAR(file);
				phalcon_array_fetch_quick_string(&file, expr, SS("file"), 259010501UL, PH_NOISY);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "Invalid definition for user function '", name, "' in ", file, " on line ", line);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
				return;
			}
		}
	
		macros = phalcon_fetch_nproperty_this(this_ptr, SL("_macros"), PH_NOISY TSRMLS_CC);
	
		if (phalcon_array_isset(macros, name)) {
			PHALCON_CONCAT_SVSVS(return_value, "vmacro_", name, "(array(", arguments, "))");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "get_content") || PHALCON_IS_STRING(name, "content")) {
			RETURN_MM_STRING("$this->getContent()", 1);
		}
	
		if (PHALCON_IS_STRING(name, "partial")) {
			PHALCON_CONCAT_SVS(return_value, "$this->partial(", arguments, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "super")) {
			zval *extended_blocks = phalcon_fetch_nproperty_this(this_ptr, SL("_extendedBlocks"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(extended_blocks) == IS_ARRAY) { 
				zval *current_block = phalcon_fetch_nproperty_this(this_ptr, SL("_currentBlock"), PH_NOISY TSRMLS_CC);
				if (phalcon_array_isset(extended_blocks, current_block)) {
					zval *expr_level = phalcon_fetch_nproperty_this(this_ptr, SL("_exprLevel"), PH_NOISY TSRMLS_CC);
	
					PHALCON_OBS_VAR(block);
					phalcon_array_fetch(&block, extended_blocks, current_block, PH_NOISY);
					if (Z_TYPE_P(block) == IS_ARRAY) { 
	
						PHALCON_CALL_METHOD(&code, this_ptr, "_statementlistorextends", block);
						if (PHALCON_IS_LONG(expr_level, 1)) {
							PHALCON_CPY_WRT(escaped_code, code);
						} else {
							PHALCON_INIT_NVAR(escaped_code);
							phalcon_addslashes(escaped_code, code TSRMLS_CC);
						}
					} else {
						if (PHALCON_IS_LONG(expr_level, 1)) {
							PHALCON_CPY_WRT(escaped_code, block);
						} else {
							PHALCON_INIT_NVAR(escaped_code);
							phalcon_addslashes(escaped_code, block TSRMLS_CC);
						}
					}
	
					if (PHALCON_IS_LONG(expr_level, 1)) {
						RETURN_CCTOR(escaped_code);
					}
	
					PHALCON_CONCAT_SVS(return_value, "'", escaped_code, "'");
	
					RETURN_MM();
				}
			}
	
			RETURN_MM_STRING("''", 1);
		}
	
		PHALCON_INIT_VAR(camelized);
		phalcon_camelize(camelized, name);
	
		PHALCON_INIT_VAR(method);
		phalcon_lcfirst(method, camelized);
	
		PHALCON_INIT_VAR(class_name);
		ZVAL_STRING(class_name, "Phalcon\\Tag", 1);
	
		if (phalcon_method_exists(class_name, method TSRMLS_CC) == SUCCESS) {

			PHALCON_OBS_VAR(array_helpers);
			phalcon_read_property_this(&array_helpers, this_ptr, SL("_arrayHelpers"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(array_helpers) != IS_ARRAY) { 
				PHALCON_INIT_NVAR(array_helpers);
				array_init_size(array_helpers, 17);
				add_assoc_bool_ex(array_helpers, SS("link_to"), 1);
				add_assoc_bool_ex(array_helpers, SS("image"), 1);
				add_assoc_bool_ex(array_helpers, SS("form"), 1);
				add_assoc_bool_ex(array_helpers, SS("select"), 1);
				add_assoc_bool_ex(array_helpers, SS("select_static"), 1);
				add_assoc_bool_ex(array_helpers, SS("submit_button"), 1);
				add_assoc_bool_ex(array_helpers, SS("radio_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("check_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("file_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("hidden_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("password_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("text_area"), 1);
				add_assoc_bool_ex(array_helpers, SS("text_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("date_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("numeric_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("email_field"), 1);
				add_assoc_bool_ex(array_helpers, SS("image_input"), 1);
				phalcon_update_property_this_quick(this_ptr, SL("_arrayHelpers"), array_helpers, 3087512406UL TSRMLS_CC);
			}
	
			if (phalcon_array_isset(array_helpers, name)) {
				PHALCON_CONCAT_SVSVS(return_value, "$this->tag->", method, "(array(", arguments, "))");
				RETURN_MM();
			}
	
			PHALCON_CONCAT_SVSVS(return_value, "$this->tag->", method, "(", arguments, ")");
	
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "url")) {
			PHALCON_CONCAT_SVS(return_value, "$this->url->get(", arguments, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "static_url")) {
			PHALCON_CONCAT_SVS(return_value, "$this->url->getStatic(", arguments, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "date")) {
			PHALCON_CONCAT_SVS(return_value, "date(", arguments, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "time")) {
			RETVAL_STRING("time()", 1);
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "dump")) {
			PHALCON_CONCAT_SVS(return_value, "var_dump(", arguments, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "version")) {
			RETURN_MM_STRING("Phalcon\\Version::get()", 1);
		}
	
		if (PHALCON_IS_STRING(name, "version_id")) {
			RETURN_MM_STRING("Phalcon\\Version::getId()", 1);
		}
	
		if (PHALCON_IS_STRING(name, "constant")) {
			PHALCON_CONCAT_SVS(return_value, "constant(", arguments, ")");
			RETURN_MM();
		}
	
		PHALCON_OBS_NVAR(line);
		phalcon_array_fetch_quick_string(&line, expr, SS("line"), 266128205UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(file);
		phalcon_array_fetch_quick_string(&file, expr, SS("file"), 259010501UL, PH_NOISY);
	
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVSVSV(exception_message, "Undefined function '", name, "' in ", file, " on line ", line);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	PHALCON_CALL_METHOD(&name, this_ptr, "expression", name_expr);
	PHALCON_CONCAT_VSVS(return_value, name, "(", arguments, ")");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveTest){

	zval *test, *left, *type, *name = NULL, *test_name, *test_arguments = NULL;
	zval *arguments = NULL, *right_code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &test, &left);
	
	if (Z_TYPE_P(test) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted test");
		return;
	}
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, test, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_LONG(type, PHVOLT_T_IDENTIFIER)) {
	
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, test, SS("value"), 574111618UL, PH_NOISY);
	
		if (PHALCON_IS_STRING(name, "empty")) {
			PHALCON_CONCAT_SVS(return_value, "empty(", left, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "even")) {
			PHALCON_CONCAT_SVS(return_value, "(((", left, ") % 2) == 0)");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "odd")) {
			PHALCON_CONCAT_SVS(return_value, "(((", left, ") % 2) != 0)");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "numeric")) {
			PHALCON_CONCAT_SVS(return_value, "is_numeric(", left, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "scalar")) {
			PHALCON_CONCAT_SVS(return_value, "is_scalar(", left, ")");
			RETURN_MM();
		}
	
		if (PHALCON_IS_STRING(name, "iterable")) {
			PHALCON_CONCAT_SVSVS(return_value, "(is_array(", left, ") || (", left, ") instanceof Traversable)");
			RETURN_MM();
		}
	}
	
	if (PHALCON_IS_LONG(type, PHVOLT_T_FCALL)) {
	
		PHALCON_OBS_VAR(test_name);
		phalcon_array_fetch_quick_string(&test_name, test, SS("name"), 268211462UL, PH_NOISY);
		if (phalcon_array_isset_quick_string(test_name, SS("value"), 574111618UL)) {
	
			PHALCON_OBS_NVAR(name);
			phalcon_array_fetch_quick_string(&name, test_name, SS("value"), 574111618UL, PH_NOISY);
			if (PHALCON_IS_STRING(name, "divisibleby")) {
				PHALCON_OBS_VAR(test_arguments);
				phalcon_array_fetch_quick_string(&test_arguments, test, SS("arguments"), 3751272283UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&arguments, this_ptr, "expression", test_arguments);
				PHALCON_CONCAT_SVSVS(return_value, "(((", left, ") % (", arguments, ")) == 0)");
				RETURN_MM();
			}
	
			if (PHALCON_IS_STRING(name, "sameas")) {
				PHALCON_OBS_NVAR(test_arguments);
				phalcon_array_fetch_quick_string(&test_arguments, test, SS("arguments"), 3751272283UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&arguments, this_ptr, "expression", test_arguments);
				PHALCON_CONCAT_SVSVS(return_value, "(", left, ") === (", arguments, ")");
				RETURN_MM();
			}
	
			if (PHALCON_IS_STRING(name, "type")) {
				PHALCON_OBS_NVAR(test_arguments);
				phalcon_array_fetch_quick_string(&test_arguments, test, SS("arguments"), 3751272283UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&arguments, this_ptr, "expression", test_arguments);
				PHALCON_CONCAT_SVSVS(return_value, "gettype(", left, ") === (", arguments, ")");
				RETURN_MM();
			}
		}
	}
	
	PHALCON_CALL_METHOD(&right_code, this_ptr, "expression", test);
	PHALCON_CONCAT_VSV(return_value, left, " == ", right_code);
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, resolveFilter){

	zval *filter, *left, *code = NULL, *type, *name = NULL, *function_name;
	zval *line = NULL, *file = NULL, *exception_message = NULL, *func_arguments = NULL;
	zval *arguments = NULL, *resolved_expr, *resolved_param;
	zval *extensions, *event, *fire_arguments, *filters;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &filter, &left);
	
	if (Z_TYPE_P(filter) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted filter");
		return;
	}
	
	PHALCON_INIT_VAR(code);
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, filter, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_LONG(type, PHVOLT_T_IDENTIFIER)) {
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, filter, SS("value"), 574111618UL, PH_NOISY);
	} else if (PHALCON_IS_LONG(type, PHVOLT_T_FCALL)) {
		PHALCON_OBS_VAR(function_name);
		phalcon_array_fetch_quick_string(&function_name, filter, SS("name"), 268211462UL, PH_NOISY);

		PHALCON_OBS_NVAR(name);
		phalcon_array_fetch_quick_string(&name, function_name, SS("value"), 574111618UL, PH_NOISY);
	} else {
		PHALCON_OBS_VAR(line);
		phalcon_array_fetch_quick_string(&line, filter, SS("line"), 266128205UL, PH_NOISY);

		PHALCON_OBS_VAR(file);
		phalcon_array_fetch_quick_string(&file, filter, SS("file"), 259010501UL, PH_NOISY);

		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVSV(exception_message, "Unknown filter type in ", file, " on line ", line);
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(func_arguments);
	
	PHALCON_INIT_VAR(arguments);
	
	if (phalcon_array_isset_quick_string(filter, SS("arguments"), 3751272283UL)) {
	
		PHALCON_OBS_NVAR(file);
		phalcon_array_fetch_quick_string(&file, filter, SS("file"), 259010501UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(line);
		phalcon_array_fetch_quick_string(&line, filter, SS("line"), 266128205UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(func_arguments);
		phalcon_array_fetch_quick_string(&func_arguments, filter, SS("arguments"), 3751272283UL, PH_NOISY);
	
		if (!PHALCON_IS_STRING(name, "default")) {
			PHALCON_INIT_VAR(resolved_expr);
			array_init_size(resolved_expr, 4);
			add_assoc_long_ex(resolved_expr, ISS(type), PHVOLT_T_RESOLVED_EXPR);
			phalcon_array_update_string(&resolved_expr, ISL(value), left, PH_COPY);
			phalcon_array_update_string(&resolved_expr, ISL(file), file, PH_COPY);
			phalcon_array_update_string(&resolved_expr, ISL(line), line, PH_COPY);
	
			PHALCON_INIT_VAR(resolved_param);
			array_init_size(resolved_param, 3);
			phalcon_array_update_string(&resolved_param, ISL(expr), resolved_expr, PH_COPY);
			phalcon_array_update_string(&resolved_param, ISL(file), file, PH_COPY);
			phalcon_array_update_string(&resolved_param, ISL(line), line, PH_COPY);
	
			phalcon_array_unshift(func_arguments, resolved_param TSRMLS_CC);
		}
	
		PHALCON_CALL_METHOD(&arguments, this_ptr, "expression", func_arguments);
	} else {
		PHALCON_CPY_WRT(arguments, left);
	}
	
	extensions = phalcon_fetch_nproperty_this(this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(extensions) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(event);
		ZVAL_STRING(event, "compileFilter", 1);
	
		PHALCON_INIT_VAR(fire_arguments);
		array_init_size(fire_arguments, 3);
		phalcon_array_append(&fire_arguments, name, 0);
		phalcon_array_append(&fire_arguments, arguments, 0);
		phalcon_array_append(&fire_arguments, func_arguments, 0);
	
		PHALCON_CALL_METHOD(&code, this_ptr, "fireextensionevent", event, fire_arguments);
		if (Z_TYPE_P(code) == IS_STRING) {
			RETURN_CCTOR(code);
		}
	}
	
	filters = phalcon_fetch_nproperty_this(this_ptr, SL("_filters"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(filters) == IS_ARRAY) { 
		zval *definition;

		if (phalcon_array_isset_fetch(&definition, filters, name)) {
			if (Z_TYPE_P(definition) == IS_STRING) {
				PHALCON_CONCAT_VSVS(return_value, definition, "(", arguments, ")");
				RETURN_MM();
			}
	
			if (Z_TYPE_P(definition) == IS_OBJECT) {
				if (instanceof_function(Z_OBJCE_P(definition), zend_ce_closure TSRMLS_CC)) {
					zval *parameters;

					PHALCON_ALLOC_GHOST_ZVAL(parameters);
					array_init_size(parameters, 2);
					phalcon_array_append(&parameters, arguments, 0);
					phalcon_array_append(&parameters, func_arguments, 0);
					PHALCON_RETURN_CALL_FUNCTION("call_user_func_array", definition, parameters);
					RETURN_MM();
				}
			}
	
			PHALCON_OBS_NVAR(line);
			phalcon_array_fetch_quick_string(&line, filter, SS("line"), 266128205UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(file);
			phalcon_array_fetch_quick_string(&file, filter, SS("file"), 259010501UL, PH_NOISY);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSVSV(exception_message, "Invalid definition for user filter '", name, "' in ", file, " on line ", line);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
			return;
		}
	}
	
	if (PHALCON_IS_STRING(name, "length")) {
		PHALCON_CONCAT_SVS(return_value, "$this->length(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "e")) {
		PHALCON_CONCAT_SVS(return_value, "$this->escaper->escapeHtml(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "escape")) {
		PHALCON_CONCAT_SVS(return_value, "$this->escaper->escapeHtml(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "escape_css")) {
		PHALCON_CONCAT_SVS(return_value, "$this->escaper->escapeCss(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "escape_js")) {
		PHALCON_CONCAT_SVS(return_value, "$this->escaper->escapeJs(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "escape_attr")) {
		PHALCON_CONCAT_SVS(return_value, "$this->escaper->escapeHtmlAttr(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "trim")) {
		PHALCON_CONCAT_SVS(return_value, "trim(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "left_trim")) {
		PHALCON_CONCAT_SVS(return_value, "ltrim(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "right_trim")) {
		PHALCON_CONCAT_SVS(return_value, "rtrim(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "striptags")) {
		PHALCON_CONCAT_SVS(return_value, "strip_tags(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "url_encode")) {
		PHALCON_CONCAT_SVS(return_value, "urlencode(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "slashes")) {
		PHALCON_CONCAT_SVS(return_value, "addslashes(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "stripslashes")) {
		PHALCON_CONCAT_SVS(return_value, "stripslashes(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "nl2br")) {
		PHALCON_CONCAT_SVS(return_value, "nl2br(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "keys")) {
		PHALCON_CONCAT_SVS(return_value, "array_keys(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "join")) {
		PHALCON_CONCAT_SVS(return_value, "join(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "lowercase")) {
		PHALCON_CONCAT_SVS(return_value, "Phalcon\\Text::lower(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "lower")) {
		PHALCON_CONCAT_SVS(return_value, "Phalcon\\Text::lower(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "uppercase")) {
		PHALCON_CONCAT_SVS(return_value, "Phalcon\\Text::upper(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "upper")) {
		PHALCON_CONCAT_SVS(return_value, "Phalcon\\Text::upper(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "capitalize")) {
		PHALCON_CONCAT_SVS(return_value, "ucwords(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "sort")) {
		PHALCON_CONCAT_SVS(return_value, "$this->sort(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "json_encode")) {
		PHALCON_CONCAT_SVS(return_value, "json_encode(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "json_decode")) {
		PHALCON_CONCAT_SVS(return_value, "json_decode(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "format")) {
		PHALCON_CONCAT_SVS(return_value, "sprintf(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "abs")) {
		PHALCON_CONCAT_SVS(return_value, "abs(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "slice")) {
		PHALCON_CONCAT_SVS(return_value, "$this->slice(", arguments, ")");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "default")) {
		PHALCON_CONCAT_SVSVSVS(return_value, "(empty(", left, ") ? (", arguments, ") : (", left, "))");
		RETURN_MM();
	}
	
	if (PHALCON_IS_STRING(name, "convert_encoding")) {
		PHALCON_CONCAT_SVS(return_value, "$this->convertEncoding(", arguments, ")");
		RETURN_MM();
	}
	
	PHALCON_OBS_NVAR(line);
	phalcon_array_fetch_quick_string(&line, filter, SS("line"), 266128205UL, PH_NOISY);
	
	PHALCON_OBS_NVAR(file);
	phalcon_array_fetch_quick_string(&file, filter, SS("file"), 259010501UL, PH_NOISY);
	
	PHALCON_INIT_NVAR(exception_message);
	PHALCON_CONCAT_SVSVSV(exception_message, "Unknown filter \"", name, "\" in ", file, " on line ", line);
	PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
	return;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, expression){

	zval *expr, *expr_code = NULL, *extensions, *event = NULL, *fire_arguments = NULL;
	zval *items = NULL, *single_expr = NULL, *single_expr_expr = NULL;
	zval *single_expr_code = NULL, *parameter = NULL, *type = NULL;
	zval *left = NULL, *left_code = NULL, *right_code = NULL, *right = NULL, *value = NULL;
	zval *single_quote = NULL, *escaped_quoute = NULL, *escaped_string = NULL;
	zval *start_code = NULL, *end_code = NULL, *ternary = NULL;
	zval *ternary_code = NULL, *line = NULL, *file = NULL, *exception_message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &expr);
	
	if (Z_TYPE_P(expr) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted expression");
		return;
	}
	
	PHALCON_INIT_VAR(expr_code);
	phalcon_property_incr(this_ptr, SL("_exprLevel") TSRMLS_CC);
	
	extensions = phalcon_fetch_nproperty_this(this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
	
	while (1) {
	
		if (Z_TYPE_P(extensions) == IS_ARRAY) { 
	
			PHALCON_INIT_NVAR(event);
			ZVAL_STRING(event, "resolveExpression", 1);
	
			PHALCON_INIT_NVAR(fire_arguments);
			array_init_size(fire_arguments, 1);
			phalcon_array_append(&fire_arguments, expr, 0);
	
			PHALCON_CALL_METHOD(&expr_code, this_ptr, "fireextensionevent", event, fire_arguments);
			if (Z_TYPE_P(expr_code) == IS_STRING) {
				break;
			}
		}

		if (!phalcon_array_isset_string_fetch(&type, expr, SS("type"))) {
	
			PHALCON_INIT_NVAR(items);
			array_init(items);
	
			phalcon_is_iterable(expr, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
				zval *name;

				PHALCON_GET_HVALUE(single_expr);
	
				PHALCON_OBS_NVAR(single_expr_expr);
				phalcon_array_fetch_quick_string(&single_expr_expr, single_expr, SS("expr"), 258368420UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&single_expr_code, this_ptr, "expression", single_expr_expr);
				if (phalcon_array_isset_string_fetch(&name, single_expr, SS("name"))) {
					PHALCON_INIT_NVAR(parameter);
					PHALCON_CONCAT_SVSV(parameter, "'", name, "' => ", single_expr_code);
					phalcon_array_append(&items, parameter, PH_SEPARATE);
				} else {
					phalcon_array_append(&items, single_expr_code, PH_SEPARATE);
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			PHALCON_INIT_NVAR(expr_code);
			phalcon_fast_join_str(expr_code, SL(", "), items TSRMLS_CC);
			break;
		}
	
		if (PHALCON_IS_LONG(type, PHVOLT_T_DOT)) {
			PHALCON_CALL_METHOD(&expr_code, this_ptr, "attributereader", expr);
			break;
		}
	
		PHALCON_INIT_NVAR(left_code);
		if (phalcon_array_isset_string_fetch(&left, expr, SS("left"))) {
			PHALCON_CALL_METHOD(&left_code, this_ptr, "expression", left);
		}
	
		if (PHALCON_IS_LONG(type, PHVOLT_T_IS)) {
			PHALCON_OBS_NVAR(right_code);
			phalcon_array_fetch_quick_string(&right_code, expr, SS("right"), 426864067UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&expr_code, this_ptr, "resolvetest", right_code, left_code);
			break;
		}
	
		if (PHALCON_IS_LONG(type, 124)) { /* FIXME there is no constant equal to 124 in scanner.h */
			PHALCON_OBS_NVAR(right_code);
			phalcon_array_fetch_quick_string(&right_code, expr, SS("right"), 426864067UL, PH_NOISY);
	
			PHALCON_CALL_METHOD(&expr_code, this_ptr, "resolvefilter", right_code, left_code);
			break;
		}
	
		PHALCON_INIT_NVAR(right_code);
		if (phalcon_array_isset_string_fetch(&right, expr, SS("right"))) {
			PHALCON_CALL_METHOD(&right_code, this_ptr, "expression", right);
		}
	
		PHALCON_INIT_NVAR(expr_code);
		switch (phalcon_get_intval(type)) {
	
			case PHVOLT_T_NOT:
				PHALCON_CONCAT_SV(expr_code, "!", right_code);
				break;
	
			case PHVOLT_T_MUL:
				PHALCON_CONCAT_VSV(expr_code, left_code, " * ", right_code);
				break;
	
			case PHVOLT_T_ADD:
				PHALCON_CONCAT_VSV(expr_code, left_code, " + ", right_code);
				break;
	
			case PHVOLT_T_SUB:
				PHALCON_CONCAT_VSV(expr_code, left_code, " - ", right_code);
				break;
	
			case PHVOLT_T_DIV:
				PHALCON_CONCAT_VSV(expr_code, left_code, " / ", right_code);
				break;
	
			case PHVOLT_T_MOD:
				PHALCON_CONCAT_VSV(expr_code, left_code, " % ", right_code);
				break;
	
			case PHVOLT_T_LESS:
				PHALCON_CONCAT_VSV(expr_code, left_code, " < ", right_code);
				break;
	
			case PHVOLT_T_ASSIGN:
				PHALCON_CONCAT_VSV(expr_code, left_code, " > ", right_code); /* FIXME really >? */
				break;
	
			case PHVOLT_T_GREATER:
				PHALCON_CONCAT_VSV(expr_code, left_code, " > ", right_code);
				break;
	
			case 126: /* FIXME no such constant*/
				PHALCON_CONCAT_VSV(expr_code, left_code, " . ", right_code);
				break;
	
			case PHVOLT_T_POW:
				PHALCON_CONCAT_SVSVS(expr_code, "pow(", left_code, ", ", right_code, ")");
				break;
	
			case PHVOLT_T_ARRAY:
				if (phalcon_array_isset_quick_string(expr, SS("left"), 265976240UL)) {
					PHALCON_CONCAT_SVS(expr_code, "array(", left_code, ")");
				} else {
					ZVAL_STRING(expr_code, "array()", 1);
				}
				break;
	
			case PHVOLT_T_INTEGER:
			case PHVOLT_T_DOUBLE:
			case PHVOLT_T_RESOLVED_EXPR:
				PHALCON_OBS_NVAR(expr_code);
				phalcon_array_fetch_quick_string(&expr_code, expr, SS("value"), 574111618UL, PH_NOISY);
				break;
	
			case PHVOLT_T_STRING:
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
	
				PHALCON_INIT_NVAR(single_quote);
				ZVAL_STRING(single_quote, "'", 1);
	
				PHALCON_INIT_NVAR(escaped_quoute);
				ZVAL_STRING(escaped_quoute, "\\'", 1);
	
				PHALCON_INIT_NVAR(escaped_string);
				phalcon_fast_str_replace(escaped_string, single_quote, escaped_quoute, value);
	
				PHALCON_CONCAT_SVS(expr_code, "'", escaped_string, "'");
				break;
	
			case PHVOLT_T_NULL:
				ZVAL_STRING(expr_code, "null", 1);
				break;
	
			case PHVOLT_T_FALSE:
				ZVAL_STRING(expr_code, "false", 1);
				break;
	
			case PHVOLT_T_TRUE:
				ZVAL_STRING(expr_code, "true", 1);
				break;
	
			case PHVOLT_T_IDENTIFIER:
				PHALCON_OBS_NVAR(value);
				phalcon_array_fetch_quick_string(&value, expr, SS("value"), 574111618UL, PH_NOISY);
	
				PHALCON_CONCAT_SV(expr_code, "$", value);
				break;
	
			case PHVOLT_T_AND:
				PHALCON_CONCAT_VSV(expr_code, left_code, " && ", right_code);
				break;
	
			case PHVOLT_T_OR:
				PHALCON_CONCAT_VSV(expr_code, left_code, " || ", right_code);
				break;
	
			case PHVOLT_T_LESSEQUAL:
				PHALCON_CONCAT_VSV(expr_code, left_code, " <= ", right_code);
				break;
	
			case PHVOLT_T_GREATEREQUAL:
				PHALCON_CONCAT_VSV(expr_code, left_code, " >= ", right_code);
				break;
	
			case PHVOLT_T_EQUALS:
				PHALCON_CONCAT_VSV(expr_code, left_code, " == ", right_code);
				break;
	
			case PHVOLT_T_NOTEQUALS:
				PHALCON_CONCAT_VSV(expr_code, left_code, " != ", right_code);
				break;
	
			case PHVOLT_T_IDENTICAL:
				PHALCON_CONCAT_VSV(expr_code, left_code, " === ", right_code);
				break;
	
			case PHVOLT_T_NOTIDENTICAL:
				PHALCON_CONCAT_VSV(expr_code, left_code, " !== ", right_code);
				break;
	
			case PHVOLT_T_RANGE:
				PHALCON_CONCAT_SVSVS(expr_code, "range(", left_code, ", ", right_code, ")");
				break;
	
			case PHVOLT_T_FCALL:
				PHALCON_CALL_METHOD(&expr_code, this_ptr, "functioncall", expr);
				break;
	
			case PHVOLT_T_ENCLOSED:
				PHALCON_CONCAT_SVS(expr_code, "(", left_code, ")");
				break;
	
			case PHVOLT_T_ARRAYACCESS:
				PHALCON_CONCAT_VSVS(expr_code, left_code, "[", right_code, "]");
				break;
	
			case PHVOLT_T_SLICE: {
				zval *start, *end;
				PHALCON_INIT_NVAR(start_code);
				if (phalcon_array_isset_string_fetch(&start, expr, SS("start"))) {
					PHALCON_CALL_METHOD(&start_code, this_ptr, "expression", start);
				} else {
					ZVAL_STRING(start_code, "null", 1);
				}
	
				PHALCON_INIT_NVAR(end_code);
				if (phalcon_array_isset_string_fetch(&end, expr, SS("end"))) {
					PHALCON_CALL_METHOD(&end_code, this_ptr, "expression", end);
				} else {
					ZVAL_STRING(end_code, "null", 1);
				}
	
				PHALCON_CONCAT_SVSVSVS(expr_code, "$this->slice(", left_code, ", ", start_code, ", ", end_code, ")");
				break;
			}
	
			case PHVOLT_T_NOT_ISSET:
				PHALCON_CONCAT_SVS(expr_code, "!isset(", left_code, ")");
				break;
	
			case PHVOLT_T_ISSET:
				PHALCON_CONCAT_SVS(expr_code, "isset(", left_code, ")");
				break;
	
			case PHVOLT_T_IN:
				PHALCON_CONCAT_SVSVS(expr_code, "$this->isIncluded(", left_code, ", ", right_code, ")");
				break;
	
			case PHVOLT_T_NOT_IN:
				PHALCON_CONCAT_SVSVS(expr_code, "!$this->isIncluded(", left_code, ", ", right_code, ")");
				break;
	
			case PHVOLT_T_TERNARY:
				PHALCON_OBS_NVAR(ternary);
				phalcon_array_fetch_quick_string(&ternary, expr, SS("ternary"), 4197153930UL, PH_NOISY);
	
				PHALCON_CALL_METHOD(&ternary_code, this_ptr, "expression", ternary);
	
				PHALCON_CONCAT_SVSVSVS(expr_code, "(", ternary_code, " ? ", left_code, " : ", right_code, ")");
				break;
	
			case PHVOLT_T_MINUS:
				PHALCON_CONCAT_SV(expr_code, "-", right_code);
				break;
	
			case PHVOLT_T_PLUS:
				PHALCON_CONCAT_SV(expr_code, "+", right_code);
				break;
	
			default:
				PHALCON_OBS_NVAR(line);
				phalcon_array_fetch_quick_string(&line, expr, SS("line"), 266128205UL, PH_NOISY);
	
				PHALCON_OBS_NVAR(file);
				phalcon_array_fetch_quick_string(&file, expr, SS("file"), 259010501UL, PH_NOISY);
	
				PHALCON_INIT_VAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "Unknown expression ", type, " in ", file, " on line ", line);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
				return;
	
		}
		break;
	}

	phalcon_property_decr(this_ptr, SL("_exprLevel") TSRMLS_CC);
	RETURN_CCTOR(expr_code);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementListOrExtends){

	zval *statements, *is_statement_list = NULL, *statement = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statements);
	
	if (Z_TYPE_P(statements) != IS_ARRAY) { 
		RETURN_CCTOR(statements);
	}
	
	PHALCON_INIT_VAR(is_statement_list);
	ZVAL_TRUE(is_statement_list);
	if (!phalcon_array_isset_quick_string(statements, SS("type"), 276192743UL)) {
	
		phalcon_is_iterable(statements, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(statement);
	
			if (Z_TYPE_P(statement) != IS_ARRAY) { 
				ZVAL_FALSE(is_statement_list);
				break;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	if (PHALCON_IS_TRUE(is_statement_list)) {
		PHALCON_RETURN_CALL_METHOD(this_ptr, "_statementlist", statements);
		RETURN_MM();
	}
	
	RETURN_CCTOR(statements);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForeach){

	zval *statement, *extends_mode = NULL, *compilation;
	zval *prefix = NULL, *level, *prefix_level, *expr, *expr_code = NULL;
	zval *block_statements, *for_else = NULL, *bstatement = NULL;
	zval *type = NULL, *code = NULL, *loop_context, *iterator = NULL, *variable;
	zval *key, *if_expr, *if_expr_code = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &statement, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_INIT_VAR(compilation);
	phalcon_property_incr(this_ptr, SL("_foreachLevel") TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&prefix, this_ptr, "getuniqueprefix");
	
	PHALCON_OBS_VAR(level);
	phalcon_read_property_this(&level, this_ptr, SL("_foreachLevel"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(prefix_level);
	PHALCON_CONCAT_VV(prefix_level, prefix, level);
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_OBS_VAR(block_statements);
	phalcon_array_fetch_quick_string(&block_statements, statement, SS("block_statements"), 883954391UL, PH_NOISY);
	
	PHALCON_INIT_VAR(for_else);
	ZVAL_BOOL(for_else, 0);
	if (Z_TYPE_P(block_statements) == IS_ARRAY) { 
	
		phalcon_is_iterable(block_statements, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(bstatement);
	
			if (Z_TYPE_P(bstatement) != IS_ARRAY) { 
				break;
			}
	
			if (!phalcon_array_isset_quick_string(bstatement, SS("type"), 276192743UL)) {
				break;
			}
	
			PHALCON_OBS_NVAR(type);
			phalcon_array_fetch_quick_string(&type, bstatement, SS("type"), 276192743UL, PH_NOISY);
			if (PHALCON_IS_LONG(type, PHVOLT_T_ELSEFOR)) {
				PHALCON_SCONCAT_SVS(compilation, "<?php $", prefix_level, "iterated = false; ?>");
				PHALCON_CPY_WRT(for_else, prefix_level);
				phalcon_update_property_array(this_ptr, SL("_forElsePointers"), level, for_else TSRMLS_CC);
				break;
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	PHALCON_CALL_METHOD(&code, this_ptr, "_statementlist", block_statements, extends_mode);
	
	PHALCON_OBS_VAR(loop_context);
	phalcon_read_property_this(&loop_context, this_ptr, SL("_loopPointers"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset(loop_context, level)) {
		PHALCON_SCONCAT_SVSVS(compilation, "<?php $", prefix_level, "iterator = ", expr_code, "; ");
		PHALCON_SCONCAT_SVS(compilation, "$", prefix_level, "incr = 0; ");
		PHALCON_SCONCAT_SVS(compilation, "$", prefix_level, "loop = new stdClass(); ");
		PHALCON_SCONCAT_SVSVS(compilation, "$", prefix_level, "loop->length = count($", prefix_level, "iterator); ");
		PHALCON_SCONCAT_SVS(compilation, "$", prefix_level, "loop->index = 1; ");
		PHALCON_SCONCAT_SVS(compilation, "$", prefix_level, "loop->index0 = 1; ");
		PHALCON_SCONCAT_SVSVS(compilation, "$", prefix_level, "loop->revindex = $", prefix_level, "loop->length; ");
		PHALCON_SCONCAT_SVSVS(compilation, "$", prefix_level, "loop->revindex0 = $", prefix_level, "loop->length - 1; ?>");
	
		PHALCON_INIT_VAR(iterator);
		PHALCON_CONCAT_SVS(iterator, "$", prefix_level, "iterator");
	} else {
		PHALCON_CPY_WRT(iterator, expr_code);
	}
	
	PHALCON_OBS_VAR(variable);
	phalcon_array_fetch_quick_string(&variable, statement, SS("variable"), 1809440971UL, PH_NOISY);
	
	if (phalcon_array_isset_quick_string(statement, SS("key"), 2090432846UL)) {
		PHALCON_OBS_VAR(key);
		phalcon_array_fetch_quick_string(&key, statement, SS("key"), 2090432846UL, PH_NOISY);
		PHALCON_SCONCAT_SVSVSVS(compilation, "<?php foreach (", iterator, " as $", key, " => $", variable, ") { ");
	} else {
		PHALCON_SCONCAT_SVSVS(compilation, "<?php foreach (", iterator, " as $", variable, ") { ");
	}
	
	if (phalcon_array_isset_string_fetch(&if_expr, statement, SS("if_expr"))) {
		PHALCON_CALL_METHOD(&if_expr_code, this_ptr, "expression", if_expr);
		PHALCON_SCONCAT_SVS(compilation, "if (", if_expr_code, ") { ?>");
	} else {
		phalcon_concat_self_str(&compilation, SL("?>") TSRMLS_CC);
	}
	
	if (phalcon_array_isset(loop_context, level)) {
		PHALCON_SCONCAT_SVSVS(compilation, "<?php $", prefix_level, "loop->first = ($", prefix_level, "incr == 0); ");
		PHALCON_SCONCAT_SVSVS(compilation, "$", prefix_level, "loop->index = $", prefix_level, "incr + 1; ");
		PHALCON_SCONCAT_SVSVS(compilation, "$", prefix_level, "loop->index0 = $", prefix_level, "incr; ");
		PHALCON_SCONCAT_SVSVSVS(compilation, "$", prefix_level, "loop->revindex = $", prefix_level, "loop->length - $", prefix_level, "incr; ");
		PHALCON_SCONCAT_SVSVSVS(compilation, "$", prefix_level, "loop->revindex0 = $", prefix_level, "loop->length - ($", prefix_level, "incr + 1); ");
		PHALCON_SCONCAT_SVSVSVS(compilation, "$", prefix_level, "loop->last = ($", prefix_level, "incr == ($", prefix_level, "loop->length - 1)); ?>");
	}
	
	if (Z_TYPE_P(for_else) == IS_STRING) {
		PHALCON_SCONCAT_SVS(compilation, "<?php $", for_else, "iterated = true; ?>");
	}
	
	phalcon_concat_self(&compilation, code TSRMLS_CC);
	if (phalcon_array_isset_quick_string(statement, SS("if_expr"), 4083762802UL)) {
		phalcon_concat_self_str(&compilation, SL("<?php } ?>") TSRMLS_CC);
	}
	
	if (Z_TYPE_P(for_else) == IS_STRING) {
		phalcon_concat_self_str(&compilation, SL("<?php } ?>") TSRMLS_CC);
	} else if (phalcon_array_isset(loop_context, level)) {
		PHALCON_SCONCAT_SVS(compilation, "<?php $", prefix_level, "incr++; } ?>");
	} else {
		phalcon_concat_self_str(&compilation, SL("<?php } ?>") TSRMLS_CC);
	}
	
	phalcon_property_decr(this_ptr, SL("_foreachLevel") TSRMLS_CC);
	
	RETURN_CTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileForElse){

	zval *level, *for_else_pointers, *prefix, *loop_context;
	zval *compilation = NULL;

	PHALCON_MM_GROW();

	PHALCON_OBS_VAR(level);
	phalcon_read_property_this(&level, this_ptr, SL("_foreachLevel"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(for_else_pointers);
	phalcon_read_property_this(&for_else_pointers, this_ptr, SL("_forElsePointers"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(for_else_pointers, level)) {
	
		PHALCON_OBS_VAR(prefix);
		phalcon_array_fetch(&prefix, for_else_pointers, level, PH_NOISY);
	
		PHALCON_OBS_VAR(loop_context);
		phalcon_read_property_this(&loop_context, this_ptr, SL("_loopPointers"), PH_NOISY TSRMLS_CC);
		if (phalcon_array_isset(loop_context, level)) {
			PHALCON_INIT_VAR(compilation);
			PHALCON_CONCAT_SVSVS(compilation, "<?php $", prefix, "incr++; } if (!$", prefix, "iterated) { ?>");
		} else {
			PHALCON_INIT_NVAR(compilation);
			PHALCON_CONCAT_SVS(compilation, "<?php } if (!$", prefix, "iterated) { ?>");
		}
	
		RETURN_CTOR(compilation);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileIf){

	zval *statement, *extends_mode = NULL, *compilation;
	zval *expr, *expr_code = NULL, *block_statements = NULL, *code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &statement, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	PHALCON_INIT_VAR(compilation);
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_SCONCAT_SVS(compilation, "<?php if (", expr_code, ") { ?>");
	if (phalcon_array_isset_string_fetch(&block_statements, statement, SS("true_statements"))) {
		PHALCON_CALL_METHOD(&code, this_ptr, "_statementlist", block_statements, extends_mode);
		phalcon_concat_self(&compilation, code TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&block_statements, statement, SS("false_statements"))) {
		phalcon_concat_self_str(&compilation, SL("<?php } else { ?>") TSRMLS_CC);
	
		PHALCON_CALL_METHOD(&code, this_ptr, "_statementlist", block_statements, extends_mode);
		phalcon_concat_self(&compilation, code TSRMLS_CC);
	}
	
	phalcon_concat_self_str(&compilation, SL("<?php } ?>") TSRMLS_CC);
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileElseIf){

	zval *statement, *expr, *expr_code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_CONCAT_SVS(return_value, "<?php } elseif (", expr_code, ") { ?>");
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCache){

	zval *statement, *extends_mode = NULL, *compilation;
	zval *expr, *expr_code = NULL, *lifetime = NULL, *block_statements;
	zval *code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &statement, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_INIT_VAR(compilation);
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_SCONCAT_SVS(compilation, "<?php $_cache[", expr_code, "] = $this->di->get('viewCache'); ");
	if (phalcon_array_isset_string_fetch(&lifetime, statement, SS("lifetime"))) {
		PHALCON_SCONCAT_SVS(compilation, "$_cacheKey[", expr_code, "]");
		PHALCON_SCONCAT_SVSVSVS(compilation, " = $_cache[", expr_code, "]->start(", expr_code, ", ", lifetime, "); ");
	} else {
		PHALCON_SCONCAT_SVSVSVS(compilation, "$_cacheKey[", expr_code, "] = $_cache[", expr_code, "]->start(", expr_code, "); ");
	}
	
	PHALCON_SCONCAT_SVS(compilation, "if ($_cacheKey[", expr_code, "] === null) { ?>");
	PHALCON_OBS_VAR(block_statements);
	phalcon_array_fetch_quick_string(&block_statements, statement, SS("block_statements"), 883954391UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&code, this_ptr, "_statementlist", block_statements, extends_mode);
	phalcon_concat_self(&compilation, code TSRMLS_CC);
	
	if (phalcon_array_isset_string_fetch(&lifetime, statement, SS("lifetime"))) {
		PHALCON_SCONCAT_SVSVSVS(compilation, "<?php $_cache[", expr_code, "]->save(", expr_code, ", null, ", lifetime, "); ");
		PHALCON_SCONCAT_SVS(compilation, "} else { echo $_cacheKey[", expr_code, "]; } ?>");
	} else {
		PHALCON_SCONCAT_SVSVSVS(compilation, "<?php $_cache[", expr_code, "]->save(", expr_code, "); } else { echo $_cacheKey[", expr_code, "]; } ?>");
	}
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileEcho){

	zval *statement, *compilation, *expr, *expr_code = NULL;
	zval *expr_type, *name, *name_type, *name_value;
	zval *autoescape;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_INIT_VAR(compilation);
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_OBS_VAR(expr_type);
	phalcon_array_fetch_quick_string(&expr_type, expr, SS("type"), 276192743UL, PH_NOISY);
	if (PHALCON_IS_LONG(expr_type, PHVOLT_T_FCALL)) {
	
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, expr, SS("name"), 268211462UL, PH_NOISY);
	
		PHALCON_OBS_VAR(name_type);
		phalcon_array_fetch_quick_string(&name_type, name, SS("type"), 276192743UL, PH_NOISY);
		if (PHALCON_IS_LONG(name_type, PHVOLT_T_IDENTIFIER)) {
	
			PHALCON_OBS_VAR(name_value);
			phalcon_array_fetch_quick_string(&name_value, name, SS("value"), 574111618UL, PH_NOISY);
	
			if (PHALCON_IS_STRING(name_value, "super")) {
				RETURN_CCTOR(expr_code);
			}
		}
	}
	
	autoescape = phalcon_fetch_nproperty_this(this_ptr, SL("_autoescape"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(autoescape)) {
		PHALCON_SCONCAT_SVS(compilation, "<?php echo $this->escaper->escapeHtml(", expr_code, "); ?>");
	} else {
		PHALCON_SCONCAT_SVS(compilation, "<?php echo ", expr_code, "; ?>");
	}
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileInclude){

	zval *statement, *path_expr, *expr_type, *path = NULL;
	zval *view, *views_dir = NULL, *final_path = NULL, *extended;
	zval *sub_compiler, *compilation = NULL, *compiled_path = NULL;
	zval *expr_params, *params = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("path"), 270591026UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(path_expr);
	phalcon_array_fetch_quick_string(&path_expr, statement, SS("path"), 270591026UL, PH_NOISY);
	
	PHALCON_OBS_VAR(expr_type);
	phalcon_array_fetch_quick_string(&expr_type, path_expr, SS("type"), 276192743UL, PH_NOISY);
	
	if (PHALCON_IS_LONG(expr_type, 260)) {
	
		if (!phalcon_array_isset_quick_string(statement, SS("params"), 2613350281UL)) {
	
			PHALCON_OBS_VAR(path);
			phalcon_array_fetch_quick_string(&path, path_expr, SS("value"), 574111618UL, PH_NOISY);
	
			PHALCON_OBS_VAR(view);
			phalcon_read_property_this(&view, this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
			if (Z_TYPE_P(view) == IS_OBJECT) {
				PHALCON_CALL_METHOD(&views_dir, view, "getviewsdir");
	
				PHALCON_INIT_VAR(final_path);
				PHALCON_CONCAT_VV(final_path, views_dir, path);
			} else {
				PHALCON_CPY_WRT(final_path, path);
			}
	
			PHALCON_INIT_VAR(extended);
			ZVAL_BOOL(extended, 0);
	
			PHALCON_INIT_VAR(sub_compiler);
			if (phalcon_clone(sub_compiler, this_ptr TSRMLS_CC) == FAILURE) {
				RETURN_MM();
			}
	
			PHALCON_CALL_METHOD(&compilation, sub_compiler, "compile", final_path, extended);
	
			if (Z_TYPE_P(compilation) == IS_NULL) {
				PHALCON_CALL_METHOD(&compiled_path, sub_compiler, "getcompiledtemplatepath");
	
				PHALCON_INIT_NVAR(compilation);
				phalcon_file_get_contents(compilation, compiled_path TSRMLS_CC);
			}
	
			RETURN_CCTOR(compilation);
		}
	}
	
	PHALCON_CALL_METHOD(&path, this_ptr, "expression", path_expr);
	if (!phalcon_array_isset_quick_string(statement, SS("params"), 2613350281UL)) {
		PHALCON_CONCAT_SVS(return_value, "<?php $this->partial(", path, "); ?>");
		RETURN_MM();
	}
	
	PHALCON_OBS_VAR(expr_params);
	phalcon_array_fetch_quick_string(&expr_params, statement, SS("params"), 2613350281UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&params, this_ptr, "expression", expr_params);
	PHALCON_CONCAT_SVSVS(return_value, "<?php $this->partial(", path, ", ", params, "); ?>");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileSet){

	zval *statement, *compilation, *assignments;
	zval *assignment = NULL, *expr = NULL, *expr_code = NULL, *variable = NULL;
	zval *op = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("assignments"), 2364482705UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_INIT_VAR(compilation);
	ZVAL_STRING(compilation, "<?php", 1);
	
	PHALCON_OBS_VAR(assignments);
	phalcon_array_fetch_quick_string(&assignments, statement, SS("assignments"), 2364482705UL, PH_NOISY);
	
	phalcon_is_iterable(assignments, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(assignment);
	
		PHALCON_OBS_NVAR(expr);
		phalcon_array_fetch_quick_string(&expr, assignment, SS("expr"), 258368420UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
		PHALCON_OBS_NVAR(variable);
		phalcon_array_fetch_quick_string(&variable, assignment, SS("variable"), 1809440971UL, PH_NOISY);
	
		PHALCON_OBS_NVAR(op);
		phalcon_array_fetch_quick_string(&op, assignment, SS("op"), 193501572UL, PH_NOISY);
	
	
		switch (phalcon_get_intval(op)) {
	
			case 281:
				PHALCON_SCONCAT_SVSVS(compilation, " $", variable, " += ", expr_code, ";");
				break;
	
			case 282:
				PHALCON_SCONCAT_SVSVS(compilation, " $", variable, " -= ", expr_code, ";");
				break;
	
			case 283:
				PHALCON_SCONCAT_SVSVS(compilation, " $", variable, " *= ", expr_code, ";");
				break;
	
			case 284:
				PHALCON_SCONCAT_SVSVS(compilation, " $", variable, " /= ", expr_code, ";");
				break;
	
			default:
				PHALCON_SCONCAT_SVSVS(compilation, " $", variable, " = ", expr_code, ";");
				break;
	
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	phalcon_concat_self_str(&compilation, SL(" ?>") TSRMLS_CC);
	
	RETURN_CTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileDo){

	zval *statement, *expr, *expr_code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	
	PHALCON_CONCAT_SVS(return_value, "<?php ", expr_code, "; ?>");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileReturn){

	zval *statement, *expr, *expr_code = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &statement);
	
	if (!phalcon_array_isset_quick_string(statement, SS("expr"), 258368420UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(expr);
	phalcon_array_fetch_quick_string(&expr, statement, SS("expr"), 258368420UL, PH_NOISY);
	
	PHALCON_CALL_METHOD(&expr_code, this_ptr, "expression", expr);
	PHALCON_CONCAT_SVS(return_value, "<?php return ", expr_code, "; ?>");
	
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileAutoEscape){

	zval *statement, *extends_mode, *old_autoescape;
	zval *autoescape, *block_statements;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &statement, &extends_mode);
	
	if (!phalcon_array_isset_quick_string(statement, SS("enable"), 1780738348UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(old_autoescape);
	phalcon_read_property_this(&old_autoescape, this_ptr, SL("_autoescape"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(autoescape);
	phalcon_array_fetch_quick_string(&autoescape, statement, SS("enable"), 1780738348UL, PH_NOISY);
	phalcon_update_property_this_quick(this_ptr, SL("_autoescape"), autoescape, 2399648718UL TSRMLS_CC);
	
	PHALCON_OBS_VAR(block_statements);
	phalcon_array_fetch_quick_string(&block_statements, statement, SS("block_statements"), 883954391UL, PH_NOISY);
	
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_statementlist", block_statements, extends_mode);
	phalcon_update_property_this_quick(this_ptr, SL("_autoescape"), old_autoescape, 2399648718UL TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileMacro){

	zval *statement, *extends_mode, *name, *macros;
	zval *exception_message, *code, *parameters;
	zval *parameter = NULL, *position = NULL, *variable_name = NULL, *block_statements;
	zval *block_code = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &statement, &extends_mode);
	
	if (!phalcon_array_isset_quick_string(statement, SS("name"), 268211462UL)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
		return;
	}
	
	PHALCON_OBS_VAR(name);
	phalcon_array_fetch_quick_string(&name, statement, SS("name"), 268211462UL, PH_NOISY);
	
	PHALCON_OBS_VAR(macros);
	phalcon_read_property_this(&macros, this_ptr, SL("_macros"), PH_NOISY TSRMLS_CC);
	
	if (phalcon_array_isset(macros, name)) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Macro \"", name, "\" is already defined");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	} else {
		phalcon_update_property_array(this_ptr, SL("_macros"), name, name TSRMLS_CC);
	}
	
	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<?php function vmacro_", 1);
	if (!phalcon_array_isset_quick_string(statement, SS("parameters"), 3941032889UL)) {
		PHALCON_SCONCAT_VS(code, name, "() { ?>");
	} else {
		PHALCON_SCONCAT_VS(code, name, "($__p) { ");
	
		PHALCON_OBS_VAR(parameters);
		phalcon_array_fetch_quick_string(&parameters, statement, SS("parameters"), 3941032889UL, PH_NOISY);
	
		phalcon_is_iterable(parameters, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(position, ah0, hp0);
			PHALCON_GET_HVALUE(parameter);
	
			PHALCON_OBS_NVAR(variable_name);
			phalcon_array_fetch_quick_string(&variable_name, parameter, SS("variable"), 1809440971UL, PH_NOISY);
			PHALCON_SCONCAT_SVS(code, "if (isset($__p[", position, "])) { ");
			PHALCON_SCONCAT_SVSVS(code, "$", variable_name, " = $__p[", position, "];");
			phalcon_concat_self_str(&code, SL(" } else { ") TSRMLS_CC);
			PHALCON_SCONCAT_SVS(code, "if (isset($__p['", variable_name, "'])) { ");
			PHALCON_SCONCAT_SVSVS(code, "$", variable_name, " = $__p['", variable_name, "'];");
			phalcon_concat_self_str(&code, SL(" } else { ") TSRMLS_CC);
			PHALCON_SCONCAT_SVSVS(code, " throw new \\Phalcon\\Mvc\\View\\Exception(\"Macro ", name, " was called without parameter: ", variable_name, "\"); ");
			phalcon_concat_self_str(&code, SL(" } } ") TSRMLS_CC);
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
		phalcon_concat_self_str(&code, SL(" ?>") TSRMLS_CC);
	}
	
	if (phalcon_array_isset_quick_string(statement, SS("block_statements"), 883954391UL)) {
		PHALCON_OBS_VAR(block_statements);
		phalcon_array_fetch_quick_string(&block_statements, statement, SS("block_statements"), 883954391UL, PH_NOISY);
	
		PHALCON_CALL_METHOD(&block_code, this_ptr, "_statementlist", block_statements, extends_mode);
		PHALCON_SCONCAT_VS(code, block_code, "<?php } ?>");
	} else {
		phalcon_concat_self_str(&code, SL("<?php } ?>") TSRMLS_CC);
	}
	
	RETURN_CTOR(code);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileCall){


	
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _statementList){

	zval *statements, *extends_mode = NULL, *extended = NULL, *block_mode = NULL;
	zval *compilation = NULL, *extensions, *statement = NULL, *line = NULL;
	zval *file = NULL, *exception_message = NULL, *event = NULL, *fire_arguments = NULL;
	zval *temp_compilation = NULL, *type = NULL, *block_name = NULL, *block_statements = NULL;
	zval *blocks = NULL, *code = NULL, *path = NULL, *view = NULL, *views_dir = NULL, *final_path = NULL;
	zval *sub_compiler = NULL, *compiled_path = NULL, *level;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &statements, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	if (!phalcon_fast_count_ev(statements TSRMLS_CC)) {
		RETURN_MM_EMPTY_STRING();
	}
	
	PHALCON_OBS_VAR(extended);
	phalcon_read_property_this(&extended, this_ptr, SL("_extended"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(block_mode);
	ZVAL_BOOL(block_mode, zend_is_true(extended) || zend_is_true(extends_mode));
	if (PHALCON_IS_TRUE(block_mode)) {
		phalcon_property_incr(this_ptr, SL("_blockLevel") TSRMLS_CC);
	}
	
	phalcon_property_incr(this_ptr, SL("_level") TSRMLS_CC);
	
	PHALCON_INIT_VAR(compilation);
	
	PHALCON_OBS_VAR(extensions);
	phalcon_read_property_this(&extensions, this_ptr, SL("_extensions"), PH_NOISY TSRMLS_CC);
	
	phalcon_is_iterable(statements, &ah0, &hp0, 0, 0);
	
	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HVALUE(statement);
	
		if (Z_TYPE_P(statement) != IS_ARRAY) { 
			PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Corrupted statement");
			return;
		}
	
		if (!phalcon_array_isset_quick_string(statement, SS("type"), 276192743UL)) {
			PHALCON_OBS_NVAR(line);
			phalcon_array_fetch_quick_string(&line, statement, SS("line"), 266128205UL, PH_NOISY);
	
			PHALCON_OBS_NVAR(file);
			phalcon_array_fetch_quick_string(&file, statement, SS("file"), 259010501UL, PH_NOISY);
	
			PHALCON_INIT_NVAR(exception_message);
			PHALCON_CONCAT_SVSV(exception_message, "Invalid statement in ", file, " on line ", line);
			PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
			return;
		}
	
		if (Z_TYPE_P(extensions) == IS_ARRAY) { 
	
			PHALCON_INIT_NVAR(event);
			ZVAL_STRING(event, "compileStatement", 1);
	
			PHALCON_INIT_NVAR(fire_arguments);
			array_init_size(fire_arguments, 1);
			phalcon_array_append(&fire_arguments, statement, PH_SEPARATE);
	
			PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "fireextensionevent", event, fire_arguments);
			if (Z_TYPE_P(temp_compilation) == IS_STRING) {
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				zend_hash_move_forward_ex(ah0, &hp0);
				continue;
			}
		}
	
		PHALCON_OBS_NVAR(type);
		phalcon_array_fetch_quick_string(&type, statement, SS("type"), 276192743UL, PH_NOISY);
	
	
		switch (phalcon_get_intval(type)) {
	
			case 357:
				PHALCON_OBS_NVAR(temp_compilation);
				phalcon_array_fetch_quick_string(&temp_compilation, statement, SS("value"), 574111618UL, PH_NOISY);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 300:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileif", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 302:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileelseif", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 304:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileforeach", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 306:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileset", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 359:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileecho", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 307:
				PHALCON_OBS_NVAR(block_name);
				phalcon_array_fetch_quick_string(&block_name, statement, SS("name"), 268211462UL, PH_NOISY);
				if (phalcon_array_isset_quick_string(statement, SS("block_statements"), 883954391UL)) {
					PHALCON_OBS_NVAR(block_statements);
					phalcon_array_fetch_quick_string(&block_statements, statement, SS("block_statements"), 883954391UL, PH_NOISY);
				} else {
					PHALCON_INIT_NVAR(block_statements);
				}
	
				PHALCON_OBS_NVAR(blocks);
				phalcon_read_property_this(&blocks, this_ptr, SL("_blocks"), PH_NOISY TSRMLS_CC);
				if (zend_is_true(block_mode)) {
					if (Z_TYPE_P(blocks) != IS_ARRAY) { 
						PHALCON_INIT_NVAR(blocks);
						array_init(blocks);
					}
	
					if (Z_TYPE_P(compilation) != IS_NULL) {
						phalcon_array_append(&blocks, compilation, PH_SEPARATE);
	
						PHALCON_INIT_NVAR(compilation);
					}
	
					phalcon_array_update_zval(&blocks, block_name, block_statements, PH_COPY | PH_SEPARATE);
					phalcon_update_property_this_quick(this_ptr, SL("_blocks"), blocks, 2750049986UL TSRMLS_CC);
				} else {
					if (Z_TYPE_P(block_statements) == IS_ARRAY) { 
						PHALCON_CALL_METHOD(&code, this_ptr, "_statementlist", block_statements, extends_mode);
						phalcon_concat_self(&compilation, code TSRMLS_CC);
					}
				}
	
				break;
	
			case 310:
				PHALCON_OBS_NVAR(path);
				phalcon_array_fetch_quick_string(&path, statement, SS("path"), 270591026UL, PH_NOISY);
	
				PHALCON_OBS_NVAR(view);
				phalcon_read_property_this(&view, this_ptr, SL("_view"), PH_NOISY TSRMLS_CC);
				if (Z_TYPE_P(view) == IS_OBJECT) {
					PHALCON_CALL_METHOD(&views_dir, view, "getviewsdir");
	
					PHALCON_INIT_NVAR(final_path);
					PHALCON_CONCAT_VV(final_path, views_dir, path);
				} else {
					PHALCON_CPY_WRT(final_path, path);
				}
	
				PHALCON_INIT_NVAR(extended);
				ZVAL_BOOL(extended, 1);
	
				PHALCON_INIT_NVAR(sub_compiler);
				if (phalcon_clone(sub_compiler, this_ptr TSRMLS_CC) == FAILURE) {
					RETURN_MM();
				}
	
				PHALCON_CALL_METHOD(&temp_compilation, sub_compiler, "compile", final_path, extended);
	
				if (Z_TYPE_P(temp_compilation) == IS_NULL) {
					PHALCON_CALL_METHOD(&compiled_path, sub_compiler, "getcompiledtemplatepath");
	
					PHALCON_INIT_NVAR(temp_compilation);
					phalcon_file_get_contents(temp_compilation, compiled_path TSRMLS_CC);
				}
	
				phalcon_update_property_bool(this_ptr, SL("_extended"), 1 TSRMLS_CC);
				phalcon_update_property_this_quick(this_ptr, SL("_extendedBlocks"), temp_compilation, 3140083987UL TSRMLS_CC);
				PHALCON_CPY_WRT(block_mode, extended);
				break;
	
			case 313:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileinclude", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 314:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compilecache", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 316:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compiledo", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 327:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compilereturn", statement);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 317:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileautoescape", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 319:
				phalcon_concat_self_str(&compilation, SL("<?php continue; ?>") TSRMLS_CC);
				break;
	
			case 320:
				phalcon_concat_self_str(&compilation, SL("<?php break; ?>") TSRMLS_CC);
				break;
	
			case 321:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compileforelse");
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 322:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compilemacro", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 325:
				PHALCON_CALL_METHOD(&temp_compilation, this_ptr, "compilecall", statement, extends_mode);
				phalcon_concat_self(&compilation, temp_compilation TSRMLS_CC);
				break;
	
			case 358:
				break;
	
			default:
				PHALCON_OBS_NVAR(line);
				phalcon_array_fetch_quick_string(&line, statement, SS("line"), 266128205UL, PH_NOISY);
	
				PHALCON_OBS_NVAR(file);
				phalcon_array_fetch_quick_string(&file, statement, SS("file"), 259010501UL, PH_NOISY);
	
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVSVSV(exception_message, "Unknown statement ", type, " in ", file, " on line ", line);
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
				return;
	
		}
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	if (PHALCON_IS_TRUE(block_mode)) {
	
		PHALCON_OBS_VAR(level);
		phalcon_read_property_this(&level, this_ptr, SL("_blockLevel"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_LONG(level, 1)) {
	
			if (Z_TYPE_P(compilation) != IS_NULL) {
				phalcon_update_property_array_append(this_ptr, SL("_blocks"), compilation TSRMLS_CC);
			}
		}
	
		phalcon_property_decr(this_ptr, SL("_blockLevel") TSRMLS_CC);
	}
	
	phalcon_property_decr(this_ptr, SL("_level") TSRMLS_CC);
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, _compileSource){

	zval *view_code, *extends_mode = NULL, *current_path;
	zval *intermediate, *compilation = NULL, *extended;
	zval *final_compilation = NULL, *blocks = NULL, *extended_blocks;
	zval *block = NULL, *name = NULL, *local_block = NULL, *block_compilation = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &view_code, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	PHALCON_OBS_VAR(current_path);
	phalcon_read_property_this(&current_path, this_ptr, SL("_currentPath"), PH_NOISY TSRMLS_CC);
	
	PHALCON_INIT_VAR(intermediate);
	if (phvolt_parse_view(intermediate, view_code, current_path TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	if (Z_TYPE_P(intermediate) == IS_ARRAY) { 
		PHALCON_CALL_METHOD(&compilation, this_ptr, "_statementlist", intermediate, extends_mode);
	
		PHALCON_OBS_VAR(extended);
		phalcon_read_property_this(&extended, this_ptr, SL("_extended"), PH_NOISY TSRMLS_CC);
		if (PHALCON_IS_TRUE(extended)) {
	
			if (PHALCON_IS_TRUE(extends_mode)) {
				PHALCON_INIT_VAR(final_compilation);
				array_init(final_compilation);
			} else {
				PHALCON_INIT_NVAR(final_compilation);
			}
	
			PHALCON_OBS_VAR(blocks);
			phalcon_read_property_this(&blocks, this_ptr, SL("_blocks"), PH_NOISY TSRMLS_CC);
	
			PHALCON_OBS_VAR(extended_blocks);
			phalcon_read_property_this(&extended_blocks, this_ptr, SL("_extendedBlocks"), PH_NOISY TSRMLS_CC);
	
			phalcon_is_iterable(extended_blocks, &ah0, &hp0, 0, 0);
	
			while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
				PHALCON_GET_HKEY(name, ah0, hp0);
				PHALCON_GET_HVALUE(block);
	
				if (Z_TYPE_P(name) == IS_STRING) {
					if (Z_TYPE_P(block) == IS_ARRAY) { 
						if (phalcon_array_isset(blocks, name)) {
							PHALCON_OBS_NVAR(local_block);
							phalcon_array_fetch(&local_block, blocks, name, PH_NOISY);
							phalcon_update_property_this_quick(this_ptr, SL("_currentBlock"), name, 1187906770UL TSRMLS_CC);
	
							PHALCON_CALL_METHOD(&block_compilation, this_ptr, "_statementlist", local_block);
						} else {
							PHALCON_CALL_METHOD(&block_compilation, this_ptr, "_statementlist", block);
						}
					} else {
						if (phalcon_array_isset(blocks, name)) {
							PHALCON_OBS_NVAR(local_block);
							phalcon_array_fetch(&local_block, blocks, name, PH_NOISY);
							phalcon_update_property_this_quick(this_ptr, SL("_currentBlock"), name, 1187906770UL TSRMLS_CC);
	
							PHALCON_CALL_METHOD(&block_compilation, this_ptr, "_statementlist", local_block);
						} else {
							PHALCON_CPY_WRT(block_compilation, block);
						}
					}
					if (PHALCON_IS_TRUE(extends_mode)) {
						phalcon_array_update_zval(&final_compilation, name, block_compilation, PH_COPY | PH_SEPARATE);
					} else {
						phalcon_concat_self(&final_compilation, block_compilation TSRMLS_CC);
					}
				} else {
					if (PHALCON_IS_TRUE(extends_mode)) {
						phalcon_array_append(&final_compilation, block, PH_SEPARATE);
					} else {
						phalcon_concat_self(&final_compilation, block TSRMLS_CC);
					}
				}
	
				zend_hash_move_forward_ex(ah0, &hp0);
			}
	
			RETURN_CCTOR(final_compilation);
		}
	
		if (PHALCON_IS_TRUE(extends_mode)) {
			PHALCON_OBS_NVAR(blocks);
			phalcon_read_property_this(&blocks, this_ptr, SL("_blocks"), PH_NOISY TSRMLS_CC);
			RETURN_CCTOR(blocks);
		}
	
		RETURN_CCTOR(compilation);
	}
	
	PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Invalid intermediate representation");
	return;
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileString){

	zval *view_code, *extends_mode = NULL, *current_path;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &view_code, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	if (Z_TYPE_P(view_code) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "The code must be string");
		return;
	}
	
	PHALCON_INIT_VAR(current_path);
	ZVAL_STRING(current_path, "eval code", 1);
	phalcon_update_property_this_quick(this_ptr, SL("_currentPath"), current_path, 3436123892UL TSRMLS_CC);
	PHALCON_RETURN_CALL_METHOD(this_ptr, "_compilesource", view_code, extends_mode);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compileFile){

	zval *path, *compiled_path, *extends_mode = NULL, *exception_message = NULL;
	zval *view_code, *compilation = NULL, *final_compilation = NULL;
	zval *status;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 1, &path, &compiled_path, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	if (PHALCON_IS_EQUAL(path, compiled_path)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Template path and compilation template path cannot be the same");
		return;
	}
	
	if (phalcon_file_exists(path TSRMLS_CC) == FAILURE) {
		PHALCON_INIT_VAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Template file ", path, " does not exist");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	PHALCON_INIT_VAR(view_code);
	phalcon_file_get_contents(view_code, path TSRMLS_CC);
	if (PHALCON_IS_FALSE(view_code)) {
		PHALCON_INIT_NVAR(exception_message);
		PHALCON_CONCAT_SVS(exception_message, "Template file ", path, " could not be opened");
		PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
		return;
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_currentPath"), path, 3436123892UL TSRMLS_CC);
	
	PHALCON_CALL_METHOD(&compilation, this_ptr, "_compilesource", view_code, extends_mode);
	
	if (Z_TYPE_P(compilation) == IS_ARRAY) { 
		PHALCON_INIT_VAR(final_compilation);
		phalcon_serialize(final_compilation, &compilation TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT(final_compilation, compilation);
	}
	
	PHALCON_INIT_VAR(status);
	phalcon_file_put_contents(status, compiled_path, final_compilation TSRMLS_CC);
	if (PHALCON_IS_FALSE(status)) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "Volt directory can't be written");
		return;
	}
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, compile){

	zval *template_path, *extends_mode = NULL;
	zval *stat = NULL, *compile_always = NULL, *compiled_path = NULL;
	zval *prefix = NULL, *compiled_separator = NULL, *compiled_extension = NULL;
	zval *compilation = NULL, *options, *real_template_path;
	zval *template_sep_path = NULL, *compiled_template_path = NULL;
	zval *params, *real_compiled_path = NULL, *blocks_code;
	zval *exception_message = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &template_path, &extends_mode);
	
	if (!extends_mode) {
		extends_mode = PHALCON_GLOBAL(z_false);
	}
	
	phalcon_update_property_this(this_ptr, SL("_extended"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_extendedBlocks"), PHALCON_GLOBAL(z_false) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_blocks"), PHALCON_GLOBAL(z_null) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_level"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_foreachLevel"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_blockLevel"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_exprLevel"), PHALCON_GLOBAL(z_zero) TSRMLS_CC);
	
	PHALCON_INIT_VAR(stat);
	ZVAL_BOOL(stat, 1);
	
	PHALCON_INIT_VAR(compile_always);
	ZVAL_FALSE(compile_always);

	PHALCON_INIT_VAR(compiled_path);
	ZVAL_EMPTY_STRING(compiled_path);
	PHALCON_CPY_WRT(prefix, PHALCON_GLOBAL(z_null));
	
	PHALCON_INIT_VAR(compiled_separator);
	ZVAL_STRING(compiled_separator, "%%", 1);
	
	PHALCON_INIT_VAR(compiled_extension);
	ZVAL_STRING(compiled_extension, ".php", 1);
	PHALCON_CPY_WRT(compilation, PHALCON_GLOBAL(z_null));
	
	PHALCON_OBS_VAR(options);
	phalcon_read_property_this(&options, this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(options) == IS_ARRAY) { 
	
		if (phalcon_array_isset_quick_string(options, SS("compileAlways"), 595908511UL)) {
	
			PHALCON_OBS_NVAR(compile_always);
			phalcon_array_fetch_quick_string(&compile_always, options, SS("compileAlways"), 595908511UL, PH_NOISY);
			if (Z_TYPE_P(compile_always) != IS_BOOL) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compileAlways must be a bool value");
				return;
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("prefix"), 3263410483UL)) {
	
			PHALCON_OBS_NVAR(prefix);
			phalcon_array_fetch_quick_string(&prefix, options, SS("prefix"), 3263410483UL, PH_NOISY);
			if (Z_TYPE_P(prefix) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "prefix must be a string");
				return;
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("compiledPath"), 2785475967UL)) {
	
			PHALCON_OBS_NVAR(compiled_path);
			phalcon_array_fetch_quick_string(&compiled_path, options, SS("compiledPath"), 2785475967UL, PH_NOISY);
			if (Z_TYPE_P(compiled_path) != IS_STRING) {
				if (Z_TYPE_P(compiled_path) != IS_OBJECT) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledPath must be a string or a closure");
					return;
				}
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("compiledSeparator"), 3462898403UL)) {
	
			PHALCON_OBS_NVAR(compiled_separator);
			phalcon_array_fetch_quick_string(&compiled_separator, options, SS("compiledSeparator"), 3462898403UL, PH_NOISY);
			if (Z_TYPE_P(compiled_separator) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledSeparator must be a string");
				return;
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("compiledExtension"), 401304207UL)) {
	
			PHALCON_OBS_NVAR(compiled_extension);
			phalcon_array_fetch_quick_string(&compiled_extension, options, SS("compiledExtension"), 401304207UL, PH_NOISY);
			if (Z_TYPE_P(compiled_extension) != IS_STRING) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledExtension must be a string");
				return;
			}
		}
	
		if (phalcon_array_isset_quick_string(options, SS("stat"), 274811297UL)) {
			PHALCON_OBS_NVAR(stat);
			phalcon_array_fetch_quick_string(&stat, options, SS("stat"), 274811297UL, PH_NOISY);
		}
	}
	
	if (Z_TYPE_P(compiled_path) == IS_STRING) {
	
		if (PHALCON_IS_NOT_EMPTY(compiled_path)) {
			PHALCON_INIT_VAR(real_template_path);
			phalcon_realpath(real_template_path, template_path TSRMLS_CC);
	
			PHALCON_INIT_VAR(template_sep_path);
			phalcon_prepare_virtual_path(template_sep_path, real_template_path, compiled_separator TSRMLS_CC);
		} else {
			PHALCON_CPY_WRT(template_sep_path, template_path);
		}
	
		PHALCON_INIT_VAR(compiled_template_path);
		if (PHALCON_IS_TRUE(extends_mode)) {
			PHALCON_CONCAT_VVVVSVV(compiled_template_path, compiled_path, prefix, template_sep_path, compiled_separator, "e", compiled_separator, compiled_extension);
		} else {
			PHALCON_CONCAT_VVVV(compiled_template_path, compiled_path, prefix, template_sep_path, compiled_extension);
		}
	} else {
		if (Z_TYPE_P(compiled_path) == IS_OBJECT) {
			if (instanceof_function(Z_OBJCE_P(compiled_path), zend_ce_closure TSRMLS_CC)) {
	
				PHALCON_INIT_VAR(params);
				array_init_size(params, 3);
				phalcon_array_append(&params, template_path, 0);
				phalcon_array_append(&params, options, 0);
				phalcon_array_append(&params, extends_mode, 0);
	
				PHALCON_INIT_NVAR(compiled_template_path);/**/
				PHALCON_CALL_USER_FUNC_ARRAY(compiled_template_path, compiled_path, params);
	
				if (Z_TYPE_P(compiled_template_path) != IS_STRING) {
					PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledPath closure didn't return a valid string");
					return;
				}
			} else {
				PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "compiledPath must be a string or a closure");
				return;
			}
		}
	}
	
	PHALCON_CPY_WRT(real_compiled_path, compiled_template_path);
	if (zend_is_true(compile_always)) {
		PHALCON_CALL_METHOD(&compilation, this_ptr, "compilefile", template_path, real_compiled_path, extends_mode);
	} else {
		if (PHALCON_IS_TRUE(stat)) {
	
			if (phalcon_file_exists(compiled_template_path TSRMLS_CC) == SUCCESS) {
	
				if (phalcon_compare_mtime(template_path, real_compiled_path TSRMLS_CC)) {
					PHALCON_CALL_METHOD(&compilation, this_ptr, "compilefile", template_path, real_compiled_path, extends_mode);
				} else {
					if (PHALCON_IS_TRUE(extends_mode)) {
	
						PHALCON_INIT_VAR(blocks_code);
						phalcon_file_get_contents(blocks_code, real_compiled_path TSRMLS_CC);
						if (PHALCON_IS_FALSE(blocks_code)) {
							PHALCON_INIT_VAR(exception_message);
							PHALCON_CONCAT_SVS(exception_message, "Extends compilation file ", real_compiled_path, " could not be opened");
							PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
							return;
						}
	
						if (zend_is_true(blocks_code)) {
							PHALCON_INIT_NVAR(compilation);
							phalcon_unserialize(compilation, blocks_code TSRMLS_CC);
						} else {
							PHALCON_INIT_NVAR(compilation);
							array_init(compilation);
						}
					}
				}
			} else {
				PHALCON_CALL_METHOD(&compilation, this_ptr, "compilefile", template_path, real_compiled_path, extends_mode);
			}
		} else {
			if (phalcon_file_exists(real_compiled_path TSRMLS_CC) == FAILURE) {
				PHALCON_INIT_NVAR(exception_message);
				PHALCON_CONCAT_SVS(exception_message, "Compiled template file ", real_compiled_path, " does not exist");
				PHALCON_THROW_EXCEPTION_ZVAL(phalcon_mvc_view_exception_ce, exception_message);
				return;
			}
		}
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_compiledTemplatePath"), real_compiled_path, 2270620474UL TSRMLS_CC);
	
	RETURN_CCTOR(compilation);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getTemplatePath){


	RETURN_MEMBER_QUICK(this_ptr, "_currentPath", 3436123892UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, getCompiledTemplatePath){


	RETURN_MEMBER_QUICK(this_ptr, "_compiledTemplatePath", 2270620474UL);
}

static PHP_METHOD(Phalcon_Mvc_View_Engine_Volt_Compiler, parse){

	zval *view_code, *current_path;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &view_code);
	
	PHALCON_INIT_VAR(current_path);
	ZVAL_STRING(current_path, "eval code", 1);
	if (phvolt_parse_view(return_value, view_code, current_path TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	RETURN_MM();
}


/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is include which follows the "include" declaration
** in the input file. */
#include <stdio.h>
/* #line 42 "parser.y" */



#include <ext/standard/php_smart_str.h>


static zval *phvolt_ret_literal_zval(int type, phvolt_parser_token *T, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);
	if (T) {
		add_assoc_stringl(ret, "value", T->token, T->token_len, 0);
		efree(T);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_if_statement(zval *expr, zval *true_statements, zval *false_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_IF);
	add_assoc_zval(ret, "expr", expr);

	if (true_statements) {
		add_assoc_zval(ret, "true_statements", true_statements);
	}
	if (false_statements) {
		add_assoc_zval(ret, "false_statements", false_statements);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_elseif_statement(zval *expr, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_ELSEIF);
	add_assoc_zval(ret, "expr", expr);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_elsefor_statement(phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_ELSEFOR);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_for_statement(phvolt_parser_token *variable, phvolt_parser_token *key, zval *expr, zval *if_expr, zval *block_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_FOR);

	add_assoc_stringl(ret, "variable", variable->token, variable->token_len, 0);
	efree(variable);

	if (key) {
		add_assoc_stringl(ret, "key", key->token, key->token_len, 0);
		efree(key);
	}

	add_assoc_zval(ret, "expr", expr);

	if (if_expr) {
		add_assoc_zval(ret, "if_expr", if_expr);
	}

	add_assoc_zval(ret, "block_statements", block_statements);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_cache_statement(zval *expr, phvolt_parser_token *lifetime, zval *block_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHVOLT_T_CACHE);
	add_assoc_zval(ret, "expr", expr);

	if (lifetime) {
		add_assoc_stringl(ret, "lifetime", lifetime->token, lifetime->token_len, 0);
		efree(lifetime);
	}
	add_assoc_zval(ret, "block_statements", block_statements);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_set_statement(zval *assignments)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 2);
	add_assoc_long(ret, "type", PHVOLT_T_SET);

	add_assoc_zval(ret, "assignments", assignments);

	return ret;
}

static zval *phvolt_ret_set_assignment(phvolt_parser_token *variable, int operator, zval *expr, phvolt_scanner_state *state)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 5);

	add_assoc_stringl(ret, "variable", variable->token, variable->token_len, 0);
	efree(variable);

	add_assoc_long(ret, "op", operator);

	add_assoc_zval(ret, "expr", expr);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_echo_statement(zval *expr, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);
	add_assoc_long(ret, "type", PHVOLT_T_ECHO);
	add_assoc_zval(ret, "expr", expr);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_block_statement(phvolt_parser_token *name, zval *block_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	add_assoc_long(ret, "type", PHVOLT_T_BLOCK);

	add_assoc_stringl(ret, "name", name->token, name->token_len, 0);
	efree(name);

	if (block_statements) {
		add_assoc_zval(ret, "block_statements", block_statements);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_macro_statement(phvolt_parser_token *macro_name, zval *parameters, zval *block_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_MACRO);

	add_assoc_stringl(ret, "name", macro_name->token, macro_name->token_len, 0);
	efree(macro_name);

	if (parameters) {
		add_assoc_zval(ret, "parameters", parameters);
	}

	if (block_statements) {
		add_assoc_zval(ret, "block_statements", block_statements);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_macro_parameter(phvolt_parser_token *variable, zval *default_value, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 5);

	add_assoc_stringl(ret, "variable", variable->token, variable->token_len, 0);
	efree(variable);

	if (default_value) {
		add_assoc_zval(ret, "default", default_value);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_extends_statement(phvolt_parser_token *P, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	add_assoc_long(ret, "type", PHVOLT_T_EXTENDS);
	add_assoc_stringl(ret, "path", P->token, P->token_len, 0);
	efree(P);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_include_statement(zval *path, zval *params, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	add_assoc_long(ret, "type", PHVOLT_T_INCLUDE);

	add_assoc_zval(ret, "path", path);
	if (params) {
		add_assoc_zval(ret, "params", params);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_do_statement(zval *expr, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	add_assoc_long(ret, "type", PHVOLT_T_DO);

	add_assoc_zval(ret, "expr", expr);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_return_statement(zval *expr, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 4);

	add_assoc_long(ret, "type", PHVOLT_T_RETURN);

	add_assoc_zval(ret, "expr", expr);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_autoescape_statement(int enable, zval *block_statements, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 5);

	add_assoc_long(ret, "type", PHVOLT_T_AUTOESCAPE);
	add_assoc_long(ret, "enable", enable);
	add_assoc_zval(ret, "block_statements", block_statements);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_empty_statement(phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 3);
	add_assoc_long(ret, "type", PHVOLT_T_EMPTY);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_break_statement(phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 3);
	add_assoc_long(ret, "type", PHVOLT_T_BREAK);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_continue_statement(phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init_size(ret, 3);
	add_assoc_long(ret, "type", PHVOLT_T_CONTINUE);

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_zval_list(zval *list_left, zval *right_list)
{

	zval *ret;
	HashPosition pos;
	HashTable *list;

	MAKE_STD_ZVAL(ret);
	array_init(ret);

	if (list_left) {

		list = Z_ARRVAL_P(list_left);
		if (zend_hash_index_exists(list, 0)) {
			zend_hash_internal_pointer_reset_ex(list, &pos);
			for (;; zend_hash_move_forward_ex(list, &pos)) {

				zval ** item;

				if (zend_hash_get_current_data_ex(list, (void**) &item, &pos) == FAILURE) {
					break;
				}

				Z_ADDREF_PP(item);
				add_next_index_zval(ret, *item);

			}
			zval_ptr_dtor(&list_left);
		} else {
			add_next_index_zval(ret, list_left);
		}
	}

	add_next_index_zval(ret, right_list);

	return ret;
}

static zval *phvolt_ret_named_item(phvolt_parser_token *name, zval *expr, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_zval(ret, "expr", expr);
	if (name != NULL) {
		add_assoc_stringl(ret, "name", name->token, name->token_len, 0);
		efree(name);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_expr(int type, zval *left, zval *right, zval *ternary, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", type);

	if (ternary) {
		add_assoc_zval(ret, "ternary", ternary);
	}

	if (left) {
		add_assoc_zval(ret, "left", left);
	}

	if (right) {
		add_assoc_zval(ret, "right", right);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_slice(zval *left, zval *start, zval *end, phvolt_scanner_state *state)
{
	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_SLICE);
	add_assoc_zval(ret, "left", left);

	if (start != NULL) {
		add_assoc_zval(ret, "start", start);
	}

	if (end != NULL) {
		add_assoc_zval(ret, "end", end);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_func_call(zval *expr, zval *arguments, phvolt_scanner_state *state)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_FCALL);
	add_assoc_zval(ret, "name", expr);

	if (arguments) {
		add_assoc_zval(ret, "arguments", arguments);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}

static zval *phvolt_ret_macro_call_statement(zval *expr, zval *arguments, zval *caller, phvolt_scanner_state *state)
{

	zval *ret;

	MAKE_STD_ZVAL(ret);
	array_init(ret);
	add_assoc_long(ret, "type", PHVOLT_T_CALL);
	add_assoc_zval(ret, "name", expr);

	if (arguments) {
		add_assoc_zval(ret, "arguments", arguments);
	}

	if (caller) {
		add_assoc_zval(ret, "caller", caller);
	}

	Z_ADDREF_P(state->active_file);
	add_assoc_zval(ret, "file", state->active_file);
	add_assoc_long(ret, "line", state->active_line);

	return ret;
}


/* #line 565 "parser.c" */
/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
#if INTERFACE
#define PHVOLT_OPEN_DELIMITER                  1
#define PHVOLT_COMMA                           2
#define PHVOLT_IN                              3
#define PHVOLT_QUESTION                        4
#define PHVOLT_COLON                           5
#define PHVOLT_RANGE                           6
#define PHVOLT_AND                             7
#define PHVOLT_OR                              8
#define PHVOLT_IS                              9
#define PHVOLT_EQUALS                         10
#define PHVOLT_NOTEQUALS                      11
#define PHVOLT_LESS                           12
#define PHVOLT_GREATER                        13
#define PHVOLT_GREATEREQUAL                   14
#define PHVOLT_LESSEQUAL                      15
#define PHVOLT_IDENTICAL                      16
#define PHVOLT_NOTIDENTICAL                   17
#define PHVOLT_DIVIDE                         18
#define PHVOLT_TIMES                          19
#define PHVOLT_MOD                            20
#define PHVOLT_PLUS                           21
#define PHVOLT_MINUS                          22
#define PHVOLT_CONCAT                         23
#define PHVOLT_SBRACKET_OPEN                  24
#define PHVOLT_PIPE                           25
#define PHVOLT_NOT                            26
#define PHVOLT_INCR                           27
#define PHVOLT_DECR                           28
#define PHVOLT_PARENTHESES_OPEN               29
#define PHVOLT_DOT                            30
#define PHVOLT_IF                             31
#define PHVOLT_CLOSE_DELIMITER                32
#define PHVOLT_ENDIF                          33
#define PHVOLT_ELSE                           34
#define PHVOLT_ELSEIF                         35
#define PHVOLT_ELSEFOR                        36
#define PHVOLT_FOR                            37
#define PHVOLT_IDENTIFIER                     38
#define PHVOLT_ENDFOR                         39
#define PHVOLT_SET                            40
#define PHVOLT_ASSIGN                         41
#define PHVOLT_ADD_ASSIGN                     42
#define PHVOLT_SUB_ASSIGN                     43
#define PHVOLT_MUL_ASSIGN                     44
#define PHVOLT_DIV_ASSIGN                     45
#define PHVOLT_MACRO                          46
#define PHVOLT_PARENTHESES_CLOSE              47
#define PHVOLT_ENDMACRO                       48
#define PHVOLT_INTEGER                        49
#define PHVOLT_STRING                         50
#define PHVOLT_DOUBLE                         51
#define PHVOLT_NULL                           52
#define PHVOLT_FALSE                          53
#define PHVOLT_TRUE                           54
#define PHVOLT_CALL                           55
#define PHVOLT_ENDCALL                        56
#define PHVOLT_OPEN_EDELIMITER                57
#define PHVOLT_CLOSE_EDELIMITER               58
#define PHVOLT_BLOCK                          59
#define PHVOLT_ENDBLOCK                       60
#define PHVOLT_CACHE                          61
#define PHVOLT_ENDCACHE                       62
#define PHVOLT_EXTENDS                        63
#define PHVOLT_INCLUDE                        64
#define PHVOLT_WITH                           65
#define PHVOLT_DO                             66
#define PHVOLT_RETURN                         67
#define PHVOLT_AUTOESCAPE                     68
#define PHVOLT_ENDAUTOESCAPE                  69
#define PHVOLT_BREAK                          70
#define PHVOLT_CONTINUE                       71
#define PHVOLT_RAW_FRAGMENT                   72
#define PHVOLT_DEFINED                        73
#define PHVOLT_SBRACKET_CLOSE                 74
#define PHVOLT_CBRACKET_OPEN                  75
#define PHVOLT_CBRACKET_CLOSE                 76
#endif
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    KKCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    KKNOCODE           is a number of type KKCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash 
**                       table.
**    KKFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    KKACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    phvolt_KTOKENTYPE     is the data type used for minor tokens given 
**                       directly to the parser from the tokenizer.
**    KKMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is phvolt_KTOKENTYPE.  The entry in the union
**                       for base tokens is called "kk0".
**    KKSTACKDEPTH       is the maximum depth of the parser's stack.
**    phvolt_ARG_SDECL     A static variable declaration for the %extra_argument
**    phvolt_ARG_PDECL     A parameter declaration for the %extra_argument
**    phvolt_ARG_STORE     Code to store %extra_argument into kkpParser
**    phvolt_ARG_FETCH     Code to extract %extra_argument from kkpParser
**    KKNSTATE           the combined number of states.
**    KKNRULE            the number of rules in the grammar
**    KKERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define KKCODETYPE unsigned char
#define KKNOCODE 114
#define KKACTIONTYPE unsigned short int
#if INTERFACE
#define phvolt_KTOKENTYPE phvolt_parser_token*
#endif
typedef union {
  phvolt_KTOKENTYPE kk0;
  zval* kk132;
  int kk227;
} KKMINORTYPE;
#define KKSTACKDEPTH 100
#if INTERFACE
#define phvolt_ARG_SDECL phvolt_parser_status *status;
#define phvolt_ARG_PDECL ,phvolt_parser_status *status
#define phvolt_ARG_FETCH phvolt_parser_status *status = kkpParser->status
#define phvolt_ARG_STORE kkpParser->status = status
#endif
#define KKNSTATE 322
#define KKNRULE 133
#define KKERRORSYMBOL 77
#define KKERRSYMDT kk227
#define KK_NO_ACTION      (KKNSTATE+KKNRULE+2)
#define KK_ACCEPT_ACTION  (KKNSTATE+KKNRULE+1)
#define KK_ERROR_ACTION   (KKNSTATE+KKNRULE)

/* Next are that tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < KKNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   KKNSTATE <= N < KKNSTATE+KKNRULE   Reduce by rule N-KKNSTATE.
**
**   N == KKNSTATE+KKNRULE              A syntax error has occurred.
**
**   N == KKNSTATE+KKNRULE+1            The parser accepts its input.
**
**   N == KKNSTATE+KKNRULE+2            No such action.  Denotes unused
**                                      slots in the kk_action[] table.
**
** The action table is constructed as a single large table named kk_action[].
** Given state S and lookahead X, the action is computed as
**
**      kk_action[ kk_shift_ofst[S] + X ]
**
** If the index value kk_shift_ofst[S]+X is out of range or if the value
** kk_lookahead[kk_shift_ofst[S]+X] is not equal to X or if kk_shift_ofst[S]
** is equal to KK_SHIFT_USE_DFLT, it means that the action is not in the table
** and that kk_default[S] should be used instead.  
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the kk_reduce_ofst[] array is used in place of
** the kk_shift_ofst[] array and KK_REDUCE_USE_DFLT is used in place of
** KK_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  kk_action[]        A single table containing all actions.
**  kk_lookahead[]     A table containing the lookahead for each entry in
**                     kk_action.  Used to detect hash collisions.
**  kk_shift_ofst[]    For each state, the offset into kk_action for
**                     shifting terminals.
**  kk_reduce_ofst[]   For each state, the offset into kk_action for
**                     shifting non-terminals after a reduce.
**  kk_default[]       Default action for each state.
*/
static KKACTIONTYPE kk_action[] = {
 /*     0 */    82,   92,   23,   60,   52,   54,   64,   62,   66,   72,
 /*    10 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*    20 */    56,   89,   58,   84,   87,   88,   96,   80,  288,  162,
 /*    30 */    82,   92,  128,   60,   52,   54,   64,   62,   66,   72,
 /*    40 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*    50 */    56,   89,   58,   84,   87,   88,   96,   80,  244,  213,
 /*    60 */    48,   46,   50,   43,   40,   56,   89,   58,   84,   87,
 /*    70 */    88,   96,   80,  247,  295,  160,  255,  127,  168,  183,
 /*    80 */    82,   92,  170,   60,   52,   54,   64,   62,   66,   72,
 /*    90 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   100 */    56,   89,   58,   84,   87,   88,   96,   80,  322,  223,
 /*   110 */    82,   92,  169,   60,   52,   54,   64,   62,   66,   72,
 /*   120 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   130 */    56,   89,   58,   84,   87,   88,   96,   80,  304,  299,
 /*   140 */    82,   92,  224,   60,   52,   54,   64,   62,   66,   72,
 /*   150 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   160 */    56,   89,   58,   84,   87,   88,   96,   80,   30,   26,
 /*   170 */    82,   92,   32,   60,   52,   54,   64,   62,   66,   72,
 /*   180 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   190 */    56,   89,   58,   84,   87,   88,   96,   80,  108,   39,
 /*   200 */    82,   92,  108,   60,   52,   54,   64,   62,   66,   72,
 /*   210 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   220 */    56,   89,   58,   84,   87,   88,   96,   80,   82,   92,
 /*   230 */    94,   60,   52,   54,   64,   62,   66,   72,   74,   76,
 /*   240 */    78,   68,   70,   48,   46,   50,   43,   40,   56,   89,
 /*   250 */    58,   84,   87,   88,   96,   80,   43,   40,   56,   89,
 /*   260 */    58,   84,   87,   88,   96,   80,   84,   87,   88,   96,
 /*   270 */    80,   91,  112,  128,  107,   82,   92,  276,   60,   52,
 /*   280 */    54,   64,   62,   66,   72,   74,   76,   78,   68,   70,
 /*   290 */    48,   46,   50,   43,   40,   56,   89,   58,   84,   87,
 /*   300 */    88,   96,   80,   89,   58,   84,   87,   88,   96,   80,
 /*   310 */   281,  282,  283,  284,  285,  286,  269,  287,  197,  102,
 /*   320 */   234,  249,  270,   82,   92,   36,   60,   52,   54,   64,
 /*   330 */    62,   66,   72,   74,   76,   78,   68,   70,   48,   46,
 /*   340 */    50,   43,   40,   56,   89,   58,   84,   87,   88,   96,
 /*   350 */    80,   85,  226,   82,   92,  136,   60,   52,   54,   64,
 /*   360 */    62,   66,   72,   74,   76,   78,   68,   70,   48,   46,
 /*   370 */    50,   43,   40,   56,   89,   58,   84,   87,   88,   96,
 /*   380 */    80,  115,  229,   82,   92,  137,   60,   52,   54,   64,
 /*   390 */    62,   66,   72,   74,   76,   78,   68,   70,   48,   46,
 /*   400 */    50,   43,   40,   56,   89,   58,   84,   87,   88,   96,
 /*   410 */    80,  131,  232,   82,   92,  435,   60,   52,   54,   64,
 /*   420 */    62,   66,   72,   74,   76,   78,   68,   70,   48,   46,
 /*   430 */    50,   43,   40,   56,   89,   58,   84,   87,   88,   96,
 /*   440 */    80,   92,  436,   60,   52,   54,   64,   62,   66,   72,
 /*   450 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   460 */    56,   89,   58,   84,   87,   88,   96,   80,  246,  141,
 /*   470 */   143,  144,   82,   92,  157,   60,   52,   54,   64,   62,
 /*   480 */    66,   72,   74,   76,   78,   68,   70,   48,   46,   50,
 /*   490 */    43,   40,   56,   89,   58,   84,   87,   88,   96,   80,
 /*   500 */   435,  290,   82,   92,  159,   60,   52,   54,   64,   62,
 /*   510 */    66,   72,   74,   76,   78,   68,   70,   48,   46,   50,
 /*   520 */    43,   40,   56,   89,   58,   84,   87,   88,   96,   80,
 /*   530 */   436,  306,   82,   92,  166,   60,   52,   54,   64,   62,
 /*   540 */    66,   72,   74,   76,   78,   68,   70,   48,   46,   50,
 /*   550 */    43,   40,   56,   89,   58,   84,   87,   88,   96,   80,
 /*   560 */    82,   92,  172,   60,   52,   54,   64,   62,   66,   72,
 /*   570 */    74,   76,   78,   68,   70,   48,   46,   50,   43,   40,
 /*   580 */    56,   89,   58,   84,   87,   88,  195,   80,   60,   52,
 /*   590 */    54,   64,   62,   66,   72,   74,   76,   78,   68,   70,
 /*   600 */    48,   46,   50,   43,   40,   56,   89,   58,   84,   87,
 /*   610 */    88,   96,   80,   52,   54,   64,   62,   66,   72,   74,
 /*   620 */    76,   78,   68,   70,   48,   46,   50,   43,   40,   56,
 /*   630 */    89,   58,   84,   87,   88,   96,   80,  456,    1,    2,
 /*   640 */   248,    4,    5,    6,    7,    8,    9,   10,   11,   12,
 /*   650 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   660 */    64,   62,   66,   72,   74,   76,   78,   68,   70,   48,
 /*   670 */    46,   50,   43,   40,   56,   89,   58,   84,   87,   88,
 /*   680 */    96,   80,   27,  248,    4,    5,    6,    7,    8,    9,
 /*   690 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   700 */    20,   21,   22,   33,  248,    4,    5,    6,    7,    8,
 /*   710 */     9,   10,   11,   12,   13,   14,   15,   16,   17,   18,
 /*   720 */    19,   20,   21,   22,  163,  248,    4,    5,    6,    7,
 /*   730 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*   740 */    18,   19,   20,   21,   22,  189,  248,    4,    5,    6,
 /*   750 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*   760 */    17,   18,   19,   20,   21,   22,  199,  248,    4,    5,
 /*   770 */     6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
 /*   780 */    16,   17,   18,   19,   20,   21,   22,  207,  248,    4,
 /*   790 */     5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
 /*   800 */    15,   16,   17,   18,   19,   20,   21,   22,  214,  248,
 /*   810 */     4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
 /*   820 */    14,   15,   16,   17,   18,   19,   20,   21,   22,  236,
 /*   830 */   248,    4,    5,    6,    7,    8,    9,   10,   11,   12,
 /*   840 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   850 */   251,  248,    4,    5,    6,    7,    8,    9,   10,   11,
 /*   860 */    12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
 /*   870 */    22,  257,  248,    4,    5,    6,    7,    8,    9,   10,
 /*   880 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   890 */    21,   22,  272,  248,    4,    5,    6,    7,    8,    9,
 /*   900 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   910 */    20,   21,   22,  291,  248,    4,    5,    6,    7,    8,
 /*   920 */     9,   10,   11,   12,   13,   14,   15,   16,   17,   18,
 /*   930 */    19,   20,   21,   22,  300,  248,    4,    5,    6,    7,
 /*   940 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*   950 */    18,   19,   20,   21,   22,  307,  248,    4,    5,    6,
 /*   960 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*   970 */    17,   18,   19,   20,   21,   22,    3,    4,    5,    6,
 /*   980 */     7,    8,    9,   10,   11,   12,   13,   14,   15,   16,
 /*   990 */    17,   18,   19,   20,   21,   22,   24,  203,   29,   31,
 /*  1000 */    37,  156,  158,  323,   23,  167,  171,  185,   25,   90,
 /*  1010 */   139,  184,  173,  175,  177,  179,  181,  140,  117,  117,
 /*  1020 */   193,  138,  186,  188,  204,  278,  211,  192,  218,  221,
 /*  1030 */   198,  227,  230,  233,  187,  240,  242,   24,  203,  315,
 /*  1040 */   317,   37,  156,  158,   97,  314,  167,   38,  202,  104,
 /*  1050 */   126,   28,  184,  104,  117,  134,  106,  117,  113,  117,
 /*  1060 */   244,  193,  125,  117,  205,  204,  266,  211,  206,  218,
 /*  1070 */   221,  219,  227,  230,  233,  247,  240,  242,   24,  203,
 /*  1080 */    35,  104,   37,  156,  158,  155,   97,  167,  111,   97,
 /*  1090 */   113,  117,  196,  184,  139,  117,  117,  134,  210,  117,
 /*  1100 */   129,  244,  193,  217,  220,  138,  204,  244,  211,  235,
 /*  1110 */   218,  221,  311,  227,  230,  233,  247,  240,  242,   24,
 /*  1120 */   203,   42,  247,   37,  156,  158,  154,  165,  167,  239,
 /*  1130 */   142,  117,  241,  243,  184,   45,  117,  250,   47,  267,
 /*  1140 */    49,  254,  256,  193,  260,  117,  263,  204,  117,  211,
 /*  1150 */   117,  218,  221,   34,  227,  230,  233,  164,  240,  242,
 /*  1160 */    24,  203,   51,   53,   37,  156,  158,  265,  244,  167,
 /*  1170 */   268,   55,  117,  117,  271,  184,   57,  191,  275,  190,
 /*  1180 */   279,  117,  280,  247,  193,  278,  117,  277,  204,  297,
 /*  1190 */   211,  294,  218,  221,   59,  227,  230,  233,  200,  240,
 /*  1200 */   242,   24,  203,  296,  117,   37,  156,  158,   61,  244,
 /*  1210 */   167,  303,  310,  244,  313,  316,  184,   63,  117,  318,
 /*  1220 */   319,  320,   65,  321,  247,  193,  201,  117,  247,  204,
 /*  1230 */   261,  211,  117,  218,  221,  244,  227,  230,  233,  208,
 /*  1240 */   240,  242,   24,  203,  248,   67,   37,  156,  158,   69,
 /*  1250 */   247,  167,   71,  248,  244,  117,  215,  184,   73,  117,
 /*  1260 */   248,  248,  117,   75,  248,  248,  193,  248,  117,  247,
 /*  1270 */   204,  209,  211,  117,  218,  221,  237,  227,  230,  233,
 /*  1280 */   252,  240,  242,   24,  203,  248,  244,   37,  156,  158,
 /*  1290 */    77,  248,  167,  248,   79,  244,   81,  258,  184,   83,
 /*  1300 */   117,  247,  248,  248,  117,  248,  117,  193,  248,  117,
 /*  1310 */   247,  204,  244,  211,  216,  218,  221,  273,  227,  230,
 /*  1320 */   233,  292,  240,  242,   24,  203,  248,  247,   37,  156,
 /*  1330 */   158,   86,  244,  167,   93,   95,  244,  248,  301,  184,
 /*  1340 */    99,  117,  248,  248,  117,  117,  248,  247,  193,  248,
 /*  1350 */   117,  247,  204,  244,  211,  248,  218,  221,  308,  227,
 /*  1360 */   230,  233,  238,  240,  242,   24,  203,  248,  247,   37,
 /*  1370 */   156,  158,  101,  244,  167,  116,  248,  244,  248,  248,
 /*  1380 */   184,  132,  117,  248,  248,  117,  151,  248,  247,  193,
 /*  1390 */   248,  117,  247,  204,  244,  211,  117,  218,  221,  248,
 /*  1400 */   227,  230,  233,  253,  240,  242,   24,  203,  153,  247,
 /*  1410 */    37,  156,  158,  161,  244,  167,  174,  248,  117,  248,
 /*  1420 */   248,  184,  176,  117,  248,  178,  117,  248,  248,  247,
 /*  1430 */   193,  248,  117,  248,  204,  117,  211,  259,  218,  221,
 /*  1440 */   180,  227,  230,  233,  248,  240,  242,   24,  203,  182,
 /*  1450 */   117,   37,  156,  158,  194,  212,  167,  248,  248,  117,
 /*  1460 */   222,  248,  184,  225,  117,  117,  248,  248,  228,  248,
 /*  1470 */   117,  193,  248,  117,  248,  204,  262,  211,  117,  218,
 /*  1480 */   221,  248,  227,  230,  233,  248,  240,  242,   24,  203,
 /*  1490 */   231,  245,   37,  156,  158,  248,  289,  167,  298,  305,
 /*  1500 */   117,  117,  248,  184,  248,  274,  117,  248,  117,  117,
 /*  1510 */   248,  248,  193,  248,  248,  248,  204,  248,  211,  248,
 /*  1520 */   218,  221,  248,  227,  230,  233,  248,  240,  242,   24,
 /*  1530 */   203,  248,  248,   37,  156,  158,  248,  293,  167,  248,
 /*  1540 */   248,  248,  248,  248,  184,  248,  248,  248,  248,  248,
 /*  1550 */   248,  248,  248,  193,  248,  248,  248,  204,  248,  211,
 /*  1560 */   248,  218,  221,  248,  227,  230,  233,  248,  240,  242,
 /*  1570 */    24,  203,  248,  248,   37,  156,  158,  248,  302,  167,
 /*  1580 */   248,  248,  248,  248,  248,  184,  248,  248,  248,  248,
 /*  1590 */   248,  248,  248,  248,  193,  248,  248,  248,  204,  248,
 /*  1600 */   211,  248,  218,  221,  248,  227,  230,  233,  248,  240,
 /*  1610 */   242,   24,  203,  248,  248,   37,  156,  158,  248,  309,
 /*  1620 */   167,  248,  248,  248,  248,  248,  184,  248,  248,  248,
 /*  1630 */   248,  248,  248,  248,  248,  193,  248,  248,  248,  204,
 /*  1640 */   248,  211,  248,  218,  221,  248,  227,  230,  233,  248,
 /*  1650 */   240,  242,   24,  203,  312,  248,   37,  156,  158,  248,
 /*  1660 */   248,  167,  248,  248,  248,  248,  248,  184,  248,  248,
 /*  1670 */   248,  248,  248,  248,  248,  248,  193,  248,  248,  248,
 /*  1680 */   204,  248,  211,  248,  218,  221,  248,  227,  230,  233,
 /*  1690 */   248,  240,  242,   24,  203,  248,  248,   37,  156,  158,
 /*  1700 */   248,  248,  167,  248,  248,  248,  248,  248,  184,  248,
 /*  1710 */   248,  248,  248,  248,  248,  248,  248,  193,  248,  248,
 /*  1720 */   248,  204,  248,  211,  248,  218,  221,  248,  227,  230,
 /*  1730 */   233,  248,  240,  242,  248,  248,  248,  152,  248,   44,
 /*  1740 */    41,  248,  103,  248,   98,  248,  248,  100,  248,  248,
 /*  1750 */   248,  248,  248,  248,  248,  248,  118,  248,  248,  248,
 /*  1760 */   248,  248,  248,  248,  248,  248,  248,  119,  120,  121,
 /*  1770 */   122,  123,  124,  248,  248,  150,  248,  248,   44,   41,
 /*  1780 */   248,  103,  248,   98,  248,  248,  100,  248,  248,  248,
 /*  1790 */   248,  248,  248,  109,  248,  118,  248,   44,   41,  248,
 /*  1800 */   103,  248,  147,  248,  248,  100,  119,  120,  121,  122,
 /*  1810 */   123,  124,  248,  248,  118,  248,  248,  135,  248,  248,
 /*  1820 */   248,  248,  248,  248,  248,  119,  120,  121,  122,  123,
 /*  1830 */   124,  248,  109,   44,   41,  248,  103,  248,   98,  248,
 /*  1840 */   248,  100,  248,  248,  248,  248,  248,  248,  248,  149,
 /*  1850 */   146,  109,   44,   41,  248,  103,  248,   98,  248,  248,
 /*  1860 */   100,  145,  120,  121,  122,  123,  124,  248,  248,  118,
 /*  1870 */   248,   44,   41,  248,  103,  248,   98,  248,  133,  100,
 /*  1880 */   119,  130,  121,  122,  123,  124,  248,  109,  118,  248,
 /*  1890 */   248,  248,  248,  248,  248,  248,  248,  248,  248,  119,
 /*  1900 */   114,  121,  122,  123,  124,  248,  109,  248,  248,   44,
 /*  1910 */    41,  248,  103,  248,   98,  248,  248,  100,  248,  248,
 /*  1920 */   248,  248,  248,  248,  105,  109,  118,  248,   44,   41,
 /*  1930 */   248,  103,  248,   98,  248,  248,  100,  119,  114,  121,
 /*  1940 */   122,  123,  124,  248,  248,  118,  248,  248,  248,  248,
 /*  1950 */   248,  248,  248,  248,  248,  248,  119,  120,  121,  122,
 /*  1960 */   123,  124,  248,  109,  110,  248,  248,   44,   41,  248,
 /*  1970 */   103,  248,   98,  248,  248,  100,  248,  248,  248,  248,
 /*  1980 */   148,  248,  109,  248,  118,  248,   44,   41,  248,  103,
 /*  1990 */   248,   98,  248,  264,  100,  119,  130,  121,  122,  123,
 /*  2000 */   124,  248,  248,  118,  248,  248,  248,  248,  248,  248,
 /*  2010 */   248,  248,  248,  248,  119,  120,  121,  122,  123,  124,
 /*  2020 */   248,  109,   44,   41,  248,  103,  248,   98,  248,  248,
 /*  2030 */   100,  248,  248,  248,  248,  248,  248,  248,  248,  118,
 /*  2040 */   109,   44,   41,  248,  103,  248,   98,  248,  248,  100,
 /*  2050 */   119,  114,  121,  122,  123,  124,  248,  248,  118,  248,
 /*  2060 */   248,  248,  248,  248,  248,  248,  248,  248,  248,  119,
 /*  2070 */   130,  121,  122,  123,  124,  248,  109,  248,  248,  248,
 /*  2080 */   248,  248,  248,  248,  248,  248,  248,  248,  248,  248,
 /*  2090 */   248,  248,  248,  248,  248,  109,
};
static KKCODETYPE kk_lookahead[] = {
 /*     0 */     3,    4,    1,    6,    7,    8,    9,   10,   11,   12,
 /*    10 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*    20 */    23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
 /*    30 */     3,    4,    2,    6,    7,    8,    9,   10,   11,   12,
 /*    40 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*    50 */    23,   24,   25,   26,   27,   28,   29,   30,   57,   32,
 /*    60 */    18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
 /*    70 */    28,   29,   30,   72,    2,    3,   49,   47,  102,  103,
 /*    80 */     3,    4,    2,    6,    7,    8,    9,   10,   11,   12,
 /*    90 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   100 */    23,   24,   25,   26,   27,   28,   29,   30,    0,   32,
 /*   110 */     3,    4,   32,    6,    7,    8,    9,   10,   11,   12,
 /*   120 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   130 */    23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
 /*   140 */     3,    4,   65,    6,    7,    8,    9,   10,   11,   12,
 /*   150 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   160 */    23,   24,   25,   26,   27,   28,   29,   30,   32,   32,
 /*   170 */     3,    4,   32,    6,    7,    8,    9,   10,   11,   12,
 /*   180 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   190 */    23,   24,   25,   26,   27,   28,   29,   30,    2,   32,
 /*   200 */     3,    4,    2,    6,    7,    8,    9,   10,   11,   12,
 /*   210 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   220 */    23,   24,   25,   26,   27,   28,   29,   30,    3,    4,
 /*   230 */     5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
 /*   240 */    15,   16,   17,   18,   19,   20,   21,   22,   23,   24,
 /*   250 */    25,   26,   27,   28,   29,   30,   21,   22,   23,   24,
 /*   260 */    25,   26,   27,   28,   29,   30,   26,   27,   28,   29,
 /*   270 */    30,   74,   76,    2,   74,    3,    4,    2,    6,    7,
 /*   280 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*   290 */    18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
 /*   300 */    28,   29,   30,   24,   25,   26,   27,   28,   29,   30,
 /*   310 */    49,   50,   51,   52,   53,   54,  104,  105,   47,   47,
 /*   320 */    53,   54,   47,    3,    4,   32,    6,    7,    8,    9,
 /*   330 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   340 */    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
 /*   350 */    30,    3,   32,    3,    4,  109,    6,    7,    8,    9,
 /*   360 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   370 */    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
 /*   380 */    30,    5,   32,    3,    4,   74,    6,    7,    8,    9,
 /*   390 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   400 */    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
 /*   410 */    30,    5,   32,    3,    4,   74,    6,    7,    8,    9,
 /*   420 */    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
 /*   430 */    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
 /*   440 */    30,    4,   74,    6,    7,    8,    9,   10,   11,   12,
 /*   450 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   460 */    23,   24,   25,   26,   27,   28,   29,   30,   58,    5,
 /*   470 */   109,   74,    3,    4,   32,    6,    7,    8,    9,   10,
 /*   480 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   490 */    21,   22,   23,   24,   25,   26,   27,   28,   29,   30,
 /*   500 */     5,   32,    3,    4,   38,    6,    7,    8,    9,   10,
 /*   510 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   520 */    21,   22,   23,   24,   25,   26,   27,   28,   29,   30,
 /*   530 */     5,   32,    3,    4,   32,    6,    7,    8,    9,   10,
 /*   540 */    11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
 /*   550 */    21,   22,   23,   24,   25,   26,   27,   28,   29,   30,
 /*   560 */     3,    4,   38,    6,    7,    8,    9,   10,   11,   12,
 /*   570 */    13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
 /*   580 */    23,   24,   25,   26,   27,   28,   29,   30,    6,    7,
 /*   590 */     8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
 /*   600 */    18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
 /*   610 */    28,   29,   30,    7,    8,    9,   10,   11,   12,   13,
 /*   620 */    14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
 /*   630 */    24,   25,   26,   27,   28,   29,   30,   78,   79,   80,
 /*   640 */    81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
 /*   650 */    91,   92,   93,   94,   95,   96,   97,   98,   99,  100,
 /*   660 */     9,   10,   11,   12,   13,   14,   15,   16,   17,   18,
 /*   670 */    19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
 /*   680 */    29,   30,   80,   81,   82,   83,   84,   85,   86,   87,
 /*   690 */    88,   89,   90,   91,   92,   93,   94,   95,   96,   97,
 /*   700 */    98,   99,  100,   80,   81,   82,   83,   84,   85,   86,
 /*   710 */    87,   88,   89,   90,   91,   92,   93,   94,   95,   96,
 /*   720 */    97,   98,   99,  100,   80,   81,   82,   83,   84,   85,
 /*   730 */    86,   87,   88,   89,   90,   91,   92,   93,   94,   95,
 /*   740 */    96,   97,   98,   99,  100,   80,   81,   82,   83,   84,
 /*   750 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
 /*   760 */    95,   96,   97,   98,   99,  100,   80,   81,   82,   83,
 /*   770 */    84,   85,   86,   87,   88,   89,   90,   91,   92,   93,
 /*   780 */    94,   95,   96,   97,   98,   99,  100,   80,   81,   82,
 /*   790 */    83,   84,   85,   86,   87,   88,   89,   90,   91,   92,
 /*   800 */    93,   94,   95,   96,   97,   98,   99,  100,   80,   81,
 /*   810 */    82,   83,   84,   85,   86,   87,   88,   89,   90,   91,
 /*   820 */    92,   93,   94,   95,   96,   97,   98,   99,  100,   80,
 /*   830 */    81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
 /*   840 */    91,   92,   93,   94,   95,   96,   97,   98,   99,  100,
 /*   850 */    80,   81,   82,   83,   84,   85,   86,   87,   88,   89,
 /*   860 */    90,   91,   92,   93,   94,   95,   96,   97,   98,   99,
 /*   870 */   100,   80,   81,   82,   83,   84,   85,   86,   87,   88,
 /*   880 */    89,   90,   91,   92,   93,   94,   95,   96,   97,   98,
 /*   890 */    99,  100,   80,   81,   82,   83,   84,   85,   86,   87,
 /*   900 */    88,   89,   90,   91,   92,   93,   94,   95,   96,   97,
 /*   910 */    98,   99,  100,   80,   81,   82,   83,   84,   85,   86,
 /*   920 */    87,   88,   89,   90,   91,   92,   93,   94,   95,   96,
 /*   930 */    97,   98,   99,  100,   80,   81,   82,   83,   84,   85,
 /*   940 */    86,   87,   88,   89,   90,   91,   92,   93,   94,   95,
 /*   950 */    96,   97,   98,   99,  100,   80,   81,   82,   83,   84,
 /*   960 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
 /*   970 */    95,   96,   97,   98,   99,  100,   81,   82,   83,   84,
 /*   980 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
 /*   990 */    95,   96,   97,   98,   99,  100,   31,   32,   33,   34,
 /*  1000 */    35,   36,   37,    0,    1,   40,  103,   38,  101,  101,
 /*  1010 */    38,   46,   41,   42,   43,   44,   45,  109,  111,  111,
 /*  1020 */    55,   49,   29,   32,   59,   38,   61,   32,   63,   64,
 /*  1030 */    32,   66,   67,   68,   47,   70,   71,   31,   32,   33,
 /*  1040 */    34,   35,   36,   37,  101,    1,   40,  101,   32,  101,
 /*  1050 */   107,    1,   46,  101,  111,  112,  108,  111,  110,  111,
 /*  1060 */    57,   55,  110,  111,   38,   59,    1,   61,   32,   63,
 /*  1070 */    64,   50,   66,   67,   68,   72,   70,   71,   31,   32,
 /*  1080 */    33,  101,   35,   36,   37,  101,  101,   40,  108,  101,
 /*  1090 */   110,  111,  107,   46,   38,  111,  111,  112,   32,  111,
 /*  1100 */   112,   57,   55,   32,   32,   49,   59,   57,   61,   32,
 /*  1110 */    63,   64,    1,   66,   67,   68,   72,   70,   71,   31,
 /*  1120 */    32,  101,   72,   35,   36,   37,  101,   39,   40,   32,
 /*  1130 */    74,  111,   32,   32,   46,  101,  111,   32,  101,   56,
 /*  1140 */   101,   32,   32,   55,   32,  111,   32,   59,  111,   61,
 /*  1150 */   111,   63,   64,    1,   66,   67,   68,    1,   70,   71,
 /*  1160 */    31,   32,  101,  101,   35,   36,   37,   32,   57,   40,
 /*  1170 */    32,  101,  111,  111,   32,   46,  101,   48,   32,    1,
 /*  1180 */    41,  111,  106,   72,   55,   38,  111,  105,   59,    3,
 /*  1190 */    61,   32,   63,   64,  101,   66,   67,   68,    1,   70,
 /*  1200 */    71,   31,   32,   38,  111,   35,   36,   37,  101,   57,
 /*  1210 */    40,   32,   32,   57,   32,   32,   46,  101,  111,   32,
 /*  1220 */     1,   33,  101,   32,   72,   55,   56,  111,   72,   59,
 /*  1230 */     1,   61,  111,   63,   64,   57,   66,   67,   68,    1,
 /*  1240 */    70,   71,   31,   32,  113,  101,   35,   36,   37,  101,
 /*  1250 */    72,   40,  101,  113,   57,  111,    1,   46,  101,  111,
 /*  1260 */   113,  113,  111,  101,  113,  113,   55,  113,  111,   72,
 /*  1270 */    59,   60,   61,  111,   63,   64,    1,   66,   67,   68,
 /*  1280 */     1,   70,   71,   31,   32,  113,   57,   35,   36,   37,
 /*  1290 */   101,  113,   40,  113,  101,   57,  101,    1,   46,  101,
 /*  1300 */   111,   72,  113,  113,  111,  113,  111,   55,  113,  111,
 /*  1310 */    72,   59,   57,   61,   62,   63,   64,    1,   66,   67,
 /*  1320 */    68,    1,   70,   71,   31,   32,  113,   72,   35,   36,
 /*  1330 */    37,  101,   57,   40,  101,  101,   57,  113,    1,   46,
 /*  1340 */   101,  111,  113,  113,  111,  111,  113,   72,   55,  113,
 /*  1350 */   111,   72,   59,   57,   61,  113,   63,   64,    1,   66,
 /*  1360 */    67,   68,   69,   70,   71,   31,   32,  113,   72,   35,
 /*  1370 */    36,   37,  101,   57,   40,  101,  113,   57,  113,  113,
 /*  1380 */    46,  101,  111,  113,  113,  111,  101,  113,   72,   55,
 /*  1390 */   113,  111,   72,   59,   57,   61,  111,   63,   64,  113,
 /*  1400 */    66,   67,   68,   69,   70,   71,   31,   32,  101,   72,
 /*  1410 */    35,   36,   37,  101,   57,   40,  101,  113,  111,  113,
 /*  1420 */   113,   46,  101,  111,  113,  101,  111,  113,  113,   72,
 /*  1430 */    55,  113,  111,  113,   59,  111,   61,   62,   63,   64,
 /*  1440 */   101,   66,   67,   68,  113,   70,   71,   31,   32,  101,
 /*  1450 */   111,   35,   36,   37,  101,  101,   40,  113,  113,  111,
 /*  1460 */   101,  113,   46,  101,  111,  111,  113,  113,  101,  113,
 /*  1470 */   111,   55,  113,  111,  113,   59,   60,   61,  111,   63,
 /*  1480 */    64,  113,   66,   67,   68,  113,   70,   71,   31,   32,
 /*  1490 */   101,  101,   35,   36,   37,  113,  101,   40,  101,  101,
 /*  1500 */   111,  111,  113,   46,  113,   48,  111,  113,  111,  111,
 /*  1510 */   113,  113,   55,  113,  113,  113,   59,  113,   61,  113,
 /*  1520 */    63,   64,  113,   66,   67,   68,  113,   70,   71,   31,
 /*  1530 */    32,  113,  113,   35,   36,   37,  113,   39,   40,  113,
 /*  1540 */   113,  113,  113,  113,   46,  113,  113,  113,  113,  113,
 /*  1550 */   113,  113,  113,   55,  113,  113,  113,   59,  113,   61,
 /*  1560 */   113,   63,   64,  113,   66,   67,   68,  113,   70,   71,
 /*  1570 */    31,   32,  113,  113,   35,   36,   37,  113,   39,   40,
 /*  1580 */   113,  113,  113,  113,  113,   46,  113,  113,  113,  113,
 /*  1590 */   113,  113,  113,  113,   55,  113,  113,  113,   59,  113,
 /*  1600 */    61,  113,   63,   64,  113,   66,   67,   68,  113,   70,
 /*  1610 */    71,   31,   32,  113,  113,   35,   36,   37,  113,   39,
 /*  1620 */    40,  113,  113,  113,  113,  113,   46,  113,  113,  113,
 /*  1630 */   113,  113,  113,  113,  113,   55,  113,  113,  113,   59,
 /*  1640 */   113,   61,  113,   63,   64,  113,   66,   67,   68,  113,
 /*  1650 */    70,   71,   31,   32,   33,  113,   35,   36,   37,  113,
 /*  1660 */   113,   40,  113,  113,  113,  113,  113,   46,  113,  113,
 /*  1670 */   113,  113,  113,  113,  113,  113,   55,  113,  113,  113,
 /*  1680 */    59,  113,   61,  113,   63,   64,  113,   66,   67,   68,
 /*  1690 */   113,   70,   71,   31,   32,  113,  113,   35,   36,   37,
 /*  1700 */   113,  113,   40,  113,  113,  113,  113,  113,   46,  113,
 /*  1710 */   113,  113,  113,  113,  113,  113,  113,   55,  113,  113,
 /*  1720 */   113,   59,  113,   61,  113,   63,   64,  113,   66,   67,
 /*  1730 */    68,  113,   70,   71,  113,  113,  113,   19,  113,   21,
 /*  1740 */    22,  113,   24,  113,   26,  113,  113,   29,  113,  113,
 /*  1750 */   113,  113,  113,  113,  113,  113,   38,  113,  113,  113,
 /*  1760 */   113,  113,  113,  113,  113,  113,  113,   49,   50,   51,
 /*  1770 */    52,   53,   54,  113,  113,   18,  113,  113,   21,   22,
 /*  1780 */   113,   24,  113,   26,  113,  113,   29,  113,  113,  113,
 /*  1790 */   113,  113,  113,   75,  113,   38,  113,   21,   22,  113,
 /*  1800 */    24,  113,   26,  113,  113,   29,   49,   50,   51,   52,
 /*  1810 */    53,   54,  113,  113,   38,  113,  113,    5,  113,  113,
 /*  1820 */   113,  113,  113,  113,  113,   49,   50,   51,   52,   53,
 /*  1830 */    54,  113,   75,   21,   22,  113,   24,  113,   26,  113,
 /*  1840 */   113,   29,  113,  113,  113,  113,  113,  113,  113,   73,
 /*  1850 */    38,   75,   21,   22,  113,   24,  113,   26,  113,  113,
 /*  1860 */    29,   49,   50,   51,   52,   53,   54,  113,  113,   38,
 /*  1870 */   113,   21,   22,  113,   24,  113,   26,  113,   47,   29,
 /*  1880 */    49,   50,   51,   52,   53,   54,  113,   75,   38,  113,
 /*  1890 */   113,  113,  113,  113,  113,  113,  113,  113,  113,   49,
 /*  1900 */    50,   51,   52,   53,   54,  113,   75,  113,  113,   21,
 /*  1910 */    22,  113,   24,  113,   26,  113,  113,   29,  113,  113,
 /*  1920 */   113,  113,  113,  113,   74,   75,   38,  113,   21,   22,
 /*  1930 */   113,   24,  113,   26,  113,  113,   29,   49,   50,   51,
 /*  1940 */    52,   53,   54,  113,  113,   38,  113,  113,  113,  113,
 /*  1950 */   113,  113,  113,  113,  113,  113,   49,   50,   51,   52,
 /*  1960 */    53,   54,  113,   75,   76,  113,  113,   21,   22,  113,
 /*  1970 */    24,  113,   26,  113,  113,   29,  113,  113,  113,  113,
 /*  1980 */    73,  113,   75,  113,   38,  113,   21,   22,  113,   24,
 /*  1990 */   113,   26,  113,   47,   29,   49,   50,   51,   52,   53,
 /*  2000 */    54,  113,  113,   38,  113,  113,  113,  113,  113,  113,
 /*  2010 */   113,  113,  113,  113,   49,   50,   51,   52,   53,   54,
 /*  2020 */   113,   75,   21,   22,  113,   24,  113,   26,  113,  113,
 /*  2030 */    29,  113,  113,  113,  113,  113,  113,  113,  113,   38,
 /*  2040 */    75,   21,   22,  113,   24,  113,   26,  113,  113,   29,
 /*  2050 */    49,   50,   51,   52,   53,   54,  113,  113,   38,  113,
 /*  2060 */   113,  113,  113,  113,  113,  113,  113,  113,  113,   49,
 /*  2070 */    50,   51,   52,   53,   54,  113,   75,  113,  113,  113,
 /*  2080 */   113,  113,  113,  113,  113,  113,  113,  113,  113,  113,
 /*  2090 */   113,  113,  113,  113,  113,   75,
};
#define KK_SHIFT_USE_DFLT (-4)
static short kk_shift_ofst[] = {
 /*     0 */     1,  108, 1003,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
 /*    10 */    -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
 /*    20 */    -4,   -4,   -4, 1662, 1965,  137, 1044, 1050,  965,  136,
 /*    30 */    -4,  140, 1111, 1152, 1047,  293,   -4, 1965,  167,   -4,
 /*    40 */  1965, 1965,  279, 1965, 1965,  279, 1718,  235, 1757,  235,
 /*    50 */  1965,  235, 1965,  651, 1965,  651, 1965,  279, 1965,  240,
 /*    60 */  1965,  606, 1965,   42, 1776,   42, 1965,   42, 1965,   42,
 /*    70 */  1965,   42, 1965,   42, 1965,   42, 1965,   42, 1965,   42,
 /*    80 */  1965,   -4, 1965,  437,  348, 1965,  240,   -4,   -4, 1812,
 /*    90 */   197,   -4, 1965,  225, 1965,  582, 1831,  529, 1965,  240,
 /*   100 */  1965,  272,   -4, 1850,  529,   -4,  200,   -4, 2001, 1888,
 /*   110 */    -4,  196,   -4,   -4,  376, 1965,  529,   -4,   -4,   -4,
 /*   120 */    -4,   -4,   -4,   -4,   -4,   -4,   30,   -4, 2020,   -4,
 /*   130 */   406, 1965,  529,   -4,   -4,  972,  311,   -4,  341,  368,
 /*   140 */   464, 1056,   -4,  397,   -4,  495,  525, 1907,   -4,   -4,
 /*   150 */  1965,  235, 1965,  235,  279,  279,  442,   -4,  466,   72,
 /*   160 */  1965,   -3,    1, 1156, 1088,  502,   -4,  524,   80,   -4,
 /*   170 */   524,   -4,  971, 1965,  529, 1965,  529, 1965,  529, 1965,
 /*   180 */   529, 1965,  529,   -4,  969,  993,  987,  991,    1, 1178,
 /*   190 */  1129,  995,   -4, 1965,  557, 1946,  271,  998,    1, 1197,
 /*   200 */  1170, 1016,   -4,   -4, 1026, 1036, 1229, 1238, 1211, 1066,
 /*   210 */    -4, 1965,   27,    1, 1255, 1252, 1071,   -4, 1021, 1072,
 /*   220 */    -4, 1965,   77,   -4, 1965,  320,   -4, 1965,  350,   -4,
 /*   230 */  1965,  380,   -4,  267, 1077,    1, 1275, 1293, 1097,   -4,
 /*   240 */  1100,   -4, 1101,   -4, 1965,  410,   -4,   -4,   -4, 1105,
 /*   250 */     1, 1279, 1334, 1109,   -4, 1110,    1, 1296, 1375, 1112,
 /*   260 */    -4, 1416, 1114,   -4, 1135, 1065, 1083, 1138,   -4,  275,
 /*   270 */  1142,    1, 1316, 1457, 1146,   -4, 1147,   -4, 1139,  261,
 /*   280 */    -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4, 1965,  469,
 /*   290 */     1, 1320, 1498, 1159,   -4, 1165, 1186, 1965,  107,    1,
 /*   300 */  1337, 1539, 1179,   -4, 1965,  499,    1, 1357, 1580, 1180,
 /*   310 */    -4, 1621, 1182,   -4, 1006, 1183,   -4, 1187, 1219, 1188,
 /*   320 */  1191,   -4,
};
#define KK_REDUCE_USE_DFLT (-25)
static short kk_reduce_ofst[] = {
 /*     0 */   559,  -25,  895,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
 /*    10 */   -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
 /*    20 */   -25,  -25,  -25,  -25,  907,  -25,  602,  895,  -25,  -25,
 /*    30 */   -25,  -25,  623,  895,  -25,  -25,  -25,  946,  -25,  -25,
 /*    40 */   984, 1020,  -25, 1025, 1034,  -25, 1037,  -25, 1039,  -25,
 /*    50 */  1061,  -25, 1062,  -25, 1070,  -25, 1075,  -25, 1093,  -25,
 /*    60 */  1107,  -25, 1116,  -25, 1121,  -25, 1144,  -25, 1148,  -25,
 /*    70 */  1151,  -25, 1157,  -25, 1162,  -25, 1189,  -25, 1193,  -25,
 /*    80 */  1195,  -25, 1198,  -25,  -25, 1230,  -25,  -25,  -25,  908,
 /*    90 */   -25,  -25, 1233,  -25, 1234,  -25,  943,  -25, 1239,  -25,
 /*   100 */  1271,  -25,  -25,  948,  -25,  -25,  -25,  -25,  952,  980,
 /*   110 */   -25,  -25,  -25,  -25,  -25, 1274,  -25,  -25,  -25,  -25,
 /*   120 */   -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  988,  -25,
 /*   130 */   -25, 1280,  -25,  -25,  -25,  246,  -25,  -25,  -25,  -25,
 /*   140 */   -25,  361,  -25,  -25,  -25,  -25,  -25, 1239,  -25,  -25,
 /*   150 */  1285,  -25, 1307,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
 /*   160 */  1312,  -25,  644,  895,  -25,  -25,  -25,  -24,  -25,  -25,
 /*   170 */   903,  -25,  -25, 1315,  -25, 1321,  -25, 1324,  -25, 1339,
 /*   180 */   -25, 1348,  -25,  -25,  -25,  -25,  212,  -25,  665,  895,
 /*   190 */   -25,  -25,  -25, 1353,  -25,  985,  -25,  -25,  686,  895,
 /*   200 */   -25,  -25,  -25,  -25,  -25,  -25,  707,  895,  -25,  -25,
 /*   210 */   -25, 1354,  -25,  728,  895,  -25,  -25,  -25,  -25,  -25,
 /*   220 */   -25, 1359,  -25,  -25, 1362,  -25,  -25, 1367,  -25,  -25,
 /*   230 */  1389,  -25,  -25,  -25,  -25,  749,  895,  -25,  -25,  -25,
 /*   240 */   -25,  -25,  -25,  -25, 1390,  -25,  -25,  -25,  -25,  -25,
 /*   250 */   770,  895,  -25,  -25,  -25,  -25,  791,  895,  -25,  -25,
 /*   260 */   -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
 /*   270 */   -25,  812,  895,  -25,  -25,  -25, 1082,  -25,  -25, 1076,
 /*   280 */   -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25, 1395,  -25,
 /*   290 */   833,  895,  -25,  -25,  -25,  -25,  -25, 1397,  -25,  854,
 /*   300 */   895,  -25,  -25,  -25, 1398,  -25,  875,  895,  -25,  -25,
 /*   310 */   -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
 /*   320 */   -25,  -25,
};
static KKACTIONTYPE kk_default[] = {
 /*     0 */   455,  455,  455,  324,  326,  327,  328,  329,  330,  331,
 /*    10 */   332,  333,  334,  335,  336,  337,  338,  339,  340,  341,
 /*    20 */   342,  343,  344,  455,  455,  455,  455,  455,  455,  455,
 /*    30 */   345,  455,  455,  455,  455,  455,  347,  455,  455,  350,
 /*    40 */   455,  455,  394,  455,  455,  395,  455,  398,  455,  400,
 /*    50 */   455,  402,  455,  403,  455,  404,  455,  405,  455,  406,
 /*    60 */   455,  407,  455,  408,  455,  411,  455,  412,  455,  413,
 /*    70 */   455,  414,  455,  415,  455,  416,  455,  417,  455,  418,
 /*    80 */   455,  419,  455,  420,  455,  455,  421,  423,  424,  455,
 /*    90 */   455,  430,  455,  455,  455,  431,  455,  446,  455,  422,
 /*   100 */   455,  455,  425,  455,  440,  426,  455,  427,  455,  455,
 /*   110 */   428,  455,  429,  438,  450,  455,  439,  441,  448,  449,
 /*   120 */   450,  451,  452,  453,  454,  437,  455,  442,  455,  444,
 /*   130 */   450,  455,  447,  443,  445,  455,  455,  432,  455,  455,
 /*   140 */   455,  455,  433,  455,  434,  449,  448,  455,  409,  410,
 /*   150 */   455,  401,  455,  399,  397,  396,  455,  351,  455,  455,
 /*   160 */   455,  455,  455,  455,  455,  455,  352,  455,  455,  356,
 /*   170 */   455,  357,  455,  455,  359,  455,  360,  455,  361,  455,
 /*   180 */   362,  455,  363,  358,  455,  455,  455,  455,  455,  455,
 /*   190 */   455,  455,  364,  455,  455,  455,  455,  442,  455,  455,
 /*   200 */   455,  455,  376,  378,  455,  455,  455,  455,  455,  455,
 /*   210 */   380,  455,  455,  455,  455,  455,  455,  382,  455,  455,
 /*   220 */   384,  455,  455,  385,  455,  455,  386,  455,  455,  387,
 /*   230 */   455,  455,  388,  455,  455,  455,  455,  455,  455,  389,
 /*   240 */   455,  391,  455,  392,  455,  455,  379,  393,  325,  455,
 /*   250 */   455,  455,  455,  455,  390,  455,  455,  455,  455,  455,
 /*   260 */   383,  455,  455,  381,  443,  455,  455,  455,  377,  455,
 /*   270 */   455,  455,  455,  455,  455,  365,  455,  366,  368,  455,
 /*   280 */   369,  370,  371,  372,  373,  374,  375,  367,  455,  455,
 /*   290 */   455,  455,  455,  455,  353,  455,  455,  455,  455,  455,
 /*   300 */   455,  455,  455,  354,  455,  455,  455,  455,  455,  455,
 /*   310 */   355,  455,  455,  348,  455,  455,  346,  455,  455,  455,
 /*   320 */   455,  349,
};
#define KK_SZ_ACTTAB (sizeof(kk_action)/sizeof(kk_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammer, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef KKFALLBACK
static const KKCODETYPE kkFallback[] = {
};
#endif /* KKFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct kkStackEntry {
  int stateno;       /* The state-number */
  int major;         /* The major token value.  This is the code
                     ** number for the token at this stack level */
  KKMINORTYPE minor; /* The user-supplied minor token value.  This
                     ** is the value of the token  */
};
typedef struct kkStackEntry kkStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct kkParser {
  int kkidx;                    /* Index of top element in stack */
  int kkerrcnt;                 /* Shifts left before out of the error */
  phvolt_ARG_SDECL                /* A place to hold %extra_argument */
  kkStackEntry kkstack[KKSTACKDEPTH];  /* The parser's stack */
};
typedef struct kkParser kkParser;

#ifndef NDEBUG
#include <stdio.h>
static FILE *kkTraceFILE = 0;
static char *kkTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
static void phvolt_Trace(FILE *TraceFILE, char *zTracePrompt){
  kkTraceFILE = TraceFILE;
  kkTracePrompt = zTracePrompt;
  if( kkTraceFILE==0 ) kkTracePrompt = 0;
  else if( kkTracePrompt==0 ) kkTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *kkTokenName[] = { 
  "$",             "OPEN_DELIMITER",  "COMMA",         "IN",          
  "QUESTION",      "COLON",         "RANGE",         "AND",         
  "OR",            "IS",            "EQUALS",        "NOTEQUALS",   
  "LESS",          "GREATER",       "GREATEREQUAL",  "LESSEQUAL",   
  "IDENTICAL",     "NOTIDENTICAL",  "DIVIDE",        "TIMES",       
  "MOD",           "PLUS",          "MINUS",         "CONCAT",      
  "SBRACKET_OPEN",  "PIPE",          "NOT",           "INCR",        
  "DECR",          "PARENTHESES_OPEN",  "DOT",           "IF",          
  "CLOSE_DELIMITER",  "ENDIF",         "ELSE",          "ELSEIF",      
  "ELSEFOR",       "FOR",           "IDENTIFIER",    "ENDFOR",      
  "SET",           "ASSIGN",        "ADD_ASSIGN",    "SUB_ASSIGN",  
  "MUL_ASSIGN",    "DIV_ASSIGN",    "MACRO",         "PARENTHESES_CLOSE",
  "ENDMACRO",      "INTEGER",       "STRING",        "DOUBLE",      
  "NULL",          "FALSE",         "TRUE",          "CALL",        
  "ENDCALL",       "OPEN_EDELIMITER",  "CLOSE_EDELIMITER",  "BLOCK",       
  "ENDBLOCK",      "CACHE",         "ENDCACHE",      "EXTENDS",     
  "INCLUDE",       "WITH",          "DO",            "RETURN",      
  "AUTOESCAPE",    "ENDAUTOESCAPE",  "BREAK",         "CONTINUE",    
  "RAW_FRAGMENT",  "DEFINED",       "SBRACKET_CLOSE",  "CBRACKET_OPEN",
  "CBRACKET_CLOSE",  "error",         "program",       "volt_language",
  "statement_list",  "statement",     "raw_fragment",  "if_statement",
  "elseif_statement",  "elsefor_statement",  "for_statement",  "set_statement",
  "echo_statement",  "block_statement",  "cache_statement",  "extends_statement",
  "include_statement",  "do_statement",  "return_statement",  "autoescape_statement",
  "break_statement",  "continue_statement",  "macro_statement",  "empty_statement",
  "macro_call_statement",  "expr",          "set_assignments",  "set_assignment",
  "macro_parameters",  "macro_parameter",  "macro_parameter_default",  "argument_list",
  "array_list",    "slice_offset",  "array_item",    "function_call",
  "argument_item",
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *kkRuleName[] = {
 /*   0 */ "program ::= volt_language",
 /*   1 */ "volt_language ::= statement_list",
 /*   2 */ "statement_list ::= statement_list statement",
 /*   3 */ "statement_list ::= statement",
 /*   4 */ "statement ::= raw_fragment",
 /*   5 */ "statement ::= if_statement",
 /*   6 */ "statement ::= elseif_statement",
 /*   7 */ "statement ::= elsefor_statement",
 /*   8 */ "statement ::= for_statement",
 /*   9 */ "statement ::= set_statement",
 /*  10 */ "statement ::= echo_statement",
 /*  11 */ "statement ::= block_statement",
 /*  12 */ "statement ::= cache_statement",
 /*  13 */ "statement ::= extends_statement",
 /*  14 */ "statement ::= include_statement",
 /*  15 */ "statement ::= do_statement",
 /*  16 */ "statement ::= return_statement",
 /*  17 */ "statement ::= autoescape_statement",
 /*  18 */ "statement ::= break_statement",
 /*  19 */ "statement ::= continue_statement",
 /*  20 */ "statement ::= macro_statement",
 /*  21 */ "statement ::= empty_statement",
 /*  22 */ "statement ::= macro_call_statement",
 /*  23 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  24 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  25 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ELSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  26 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ELSE CLOSE_DELIMITER OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  27 */ "if_statement ::= OPEN_DELIMITER IF expr CLOSE_DELIMITER OPEN_DELIMITER ELSE CLOSE_DELIMITER OPEN_DELIMITER ENDIF CLOSE_DELIMITER",
 /*  28 */ "elseif_statement ::= OPEN_DELIMITER ELSEIF expr CLOSE_DELIMITER",
 /*  29 */ "elsefor_statement ::= OPEN_DELIMITER ELSEFOR CLOSE_DELIMITER",
 /*  30 */ "for_statement ::= OPEN_DELIMITER FOR IDENTIFIER IN expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDFOR CLOSE_DELIMITER",
 /*  31 */ "for_statement ::= OPEN_DELIMITER FOR IDENTIFIER IN expr IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDFOR CLOSE_DELIMITER",
 /*  32 */ "for_statement ::= OPEN_DELIMITER FOR IDENTIFIER COMMA IDENTIFIER IN expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDFOR CLOSE_DELIMITER",
 /*  33 */ "for_statement ::= OPEN_DELIMITER FOR IDENTIFIER COMMA IDENTIFIER IN expr IF expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDFOR CLOSE_DELIMITER",
 /*  34 */ "set_statement ::= OPEN_DELIMITER SET set_assignments CLOSE_DELIMITER",
 /*  35 */ "set_assignments ::= set_assignments COMMA set_assignment",
 /*  36 */ "set_assignments ::= set_assignment",
 /*  37 */ "set_assignment ::= IDENTIFIER ASSIGN expr",
 /*  38 */ "set_assignment ::= IDENTIFIER ADD_ASSIGN expr",
 /*  39 */ "set_assignment ::= IDENTIFIER SUB_ASSIGN expr",
 /*  40 */ "set_assignment ::= IDENTIFIER MUL_ASSIGN expr",
 /*  41 */ "set_assignment ::= IDENTIFIER DIV_ASSIGN expr",
 /*  42 */ "macro_statement ::= OPEN_DELIMITER MACRO IDENTIFIER PARENTHESES_OPEN PARENTHESES_CLOSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDMACRO CLOSE_DELIMITER",
 /*  43 */ "macro_statement ::= OPEN_DELIMITER MACRO IDENTIFIER PARENTHESES_OPEN macro_parameters PARENTHESES_CLOSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDMACRO CLOSE_DELIMITER",
 /*  44 */ "macro_parameters ::= macro_parameters COMMA macro_parameter",
 /*  45 */ "macro_parameters ::= macro_parameter",
 /*  46 */ "macro_parameter ::= IDENTIFIER",
 /*  47 */ "macro_parameter ::= IDENTIFIER ASSIGN macro_parameter_default",
 /*  48 */ "macro_parameter_default ::= INTEGER",
 /*  49 */ "macro_parameter_default ::= STRING",
 /*  50 */ "macro_parameter_default ::= DOUBLE",
 /*  51 */ "macro_parameter_default ::= NULL",
 /*  52 */ "macro_parameter_default ::= FALSE",
 /*  53 */ "macro_parameter_default ::= TRUE",
 /*  54 */ "macro_call_statement ::= OPEN_DELIMITER CALL expr PARENTHESES_OPEN argument_list PARENTHESES_CLOSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDCALL CLOSE_DELIMITER",
 /*  55 */ "macro_call_statement ::= OPEN_DELIMITER CALL expr PARENTHESES_OPEN PARENTHESES_CLOSE CLOSE_DELIMITER OPEN_DELIMITER ENDCALL CLOSE_DELIMITER",
 /*  56 */ "empty_statement ::= OPEN_DELIMITER CLOSE_DELIMITER",
 /*  57 */ "echo_statement ::= OPEN_EDELIMITER expr CLOSE_EDELIMITER",
 /*  58 */ "block_statement ::= OPEN_DELIMITER BLOCK IDENTIFIER CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDBLOCK CLOSE_DELIMITER",
 /*  59 */ "block_statement ::= OPEN_DELIMITER BLOCK IDENTIFIER CLOSE_DELIMITER OPEN_DELIMITER ENDBLOCK CLOSE_DELIMITER",
 /*  60 */ "cache_statement ::= OPEN_DELIMITER CACHE expr CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDCACHE CLOSE_DELIMITER",
 /*  61 */ "cache_statement ::= OPEN_DELIMITER CACHE expr INTEGER CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDCACHE CLOSE_DELIMITER",
 /*  62 */ "extends_statement ::= OPEN_DELIMITER EXTENDS STRING CLOSE_DELIMITER",
 /*  63 */ "include_statement ::= OPEN_DELIMITER INCLUDE expr CLOSE_DELIMITER",
 /*  64 */ "include_statement ::= OPEN_DELIMITER INCLUDE expr WITH expr CLOSE_DELIMITER",
 /*  65 */ "do_statement ::= OPEN_DELIMITER DO expr CLOSE_DELIMITER",
 /*  66 */ "return_statement ::= OPEN_DELIMITER RETURN expr CLOSE_DELIMITER",
 /*  67 */ "autoescape_statement ::= OPEN_DELIMITER AUTOESCAPE FALSE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDAUTOESCAPE CLOSE_DELIMITER",
 /*  68 */ "autoescape_statement ::= OPEN_DELIMITER AUTOESCAPE TRUE CLOSE_DELIMITER statement_list OPEN_DELIMITER ENDAUTOESCAPE CLOSE_DELIMITER",
 /*  69 */ "break_statement ::= OPEN_DELIMITER BREAK CLOSE_DELIMITER",
 /*  70 */ "continue_statement ::= OPEN_DELIMITER CONTINUE CLOSE_DELIMITER",
 /*  71 */ "raw_fragment ::= RAW_FRAGMENT",
 /*  72 */ "expr ::= MINUS expr",
 /*  73 */ "expr ::= PLUS expr",
 /*  74 */ "expr ::= expr MINUS expr",
 /*  75 */ "expr ::= expr PLUS expr",
 /*  76 */ "expr ::= expr TIMES expr",
 /*  77 */ "expr ::= expr TIMES TIMES expr",
 /*  78 */ "expr ::= expr DIVIDE expr",
 /*  79 */ "expr ::= expr DIVIDE DIVIDE expr",
 /*  80 */ "expr ::= expr MOD expr",
 /*  81 */ "expr ::= expr AND expr",
 /*  82 */ "expr ::= expr OR expr",
 /*  83 */ "expr ::= expr CONCAT expr",
 /*  84 */ "expr ::= expr PIPE expr",
 /*  85 */ "expr ::= expr RANGE expr",
 /*  86 */ "expr ::= expr EQUALS expr",
 /*  87 */ "expr ::= expr IS NOT DEFINED",
 /*  88 */ "expr ::= expr IS DEFINED",
 /*  89 */ "expr ::= expr IS expr",
 /*  90 */ "expr ::= expr NOTEQUALS expr",
 /*  91 */ "expr ::= expr IDENTICAL expr",
 /*  92 */ "expr ::= expr NOTIDENTICAL expr",
 /*  93 */ "expr ::= expr LESS expr",
 /*  94 */ "expr ::= expr GREATER expr",
 /*  95 */ "expr ::= expr GREATEREQUAL expr",
 /*  96 */ "expr ::= expr LESSEQUAL expr",
 /*  97 */ "expr ::= expr DOT expr",
 /*  98 */ "expr ::= expr IN expr",
 /*  99 */ "expr ::= expr NOT IN expr",
 /* 100 */ "expr ::= NOT expr",
 /* 101 */ "expr ::= expr INCR",
 /* 102 */ "expr ::= expr DECR",
 /* 103 */ "expr ::= PARENTHESES_OPEN expr PARENTHESES_CLOSE",
 /* 104 */ "expr ::= SBRACKET_OPEN SBRACKET_CLOSE",
 /* 105 */ "expr ::= SBRACKET_OPEN array_list SBRACKET_CLOSE",
 /* 106 */ "expr ::= CBRACKET_OPEN CBRACKET_CLOSE",
 /* 107 */ "expr ::= CBRACKET_OPEN array_list CBRACKET_CLOSE",
 /* 108 */ "expr ::= expr SBRACKET_OPEN expr SBRACKET_CLOSE",
 /* 109 */ "expr ::= expr QUESTION expr COLON expr",
 /* 110 */ "expr ::= expr SBRACKET_OPEN COLON slice_offset SBRACKET_CLOSE",
 /* 111 */ "expr ::= expr SBRACKET_OPEN slice_offset COLON SBRACKET_CLOSE",
 /* 112 */ "expr ::= expr SBRACKET_OPEN slice_offset COLON slice_offset SBRACKET_CLOSE",
 /* 113 */ "slice_offset ::= INTEGER",
 /* 114 */ "slice_offset ::= IDENTIFIER",
 /* 115 */ "array_list ::= array_list COMMA array_item",
 /* 116 */ "array_list ::= array_item",
 /* 117 */ "array_item ::= STRING COLON expr",
 /* 118 */ "array_item ::= expr",
 /* 119 */ "expr ::= function_call",
 /* 120 */ "function_call ::= expr PARENTHESES_OPEN argument_list PARENTHESES_CLOSE",
 /* 121 */ "function_call ::= expr PARENTHESES_OPEN PARENTHESES_CLOSE",
 /* 122 */ "argument_list ::= argument_list COMMA argument_item",
 /* 123 */ "argument_list ::= argument_item",
 /* 124 */ "argument_item ::= expr",
 /* 125 */ "argument_item ::= STRING COLON expr",
 /* 126 */ "expr ::= IDENTIFIER",
 /* 127 */ "expr ::= INTEGER",
 /* 128 */ "expr ::= STRING",
 /* 129 */ "expr ::= DOUBLE",
 /* 130 */ "expr ::= NULL",
 /* 131 */ "expr ::= FALSE",
 /* 132 */ "expr ::= TRUE",
};
#endif /* NDEBUG */

const char *phvolt_TokenName(int tokenType){
#ifndef NDEBUG
  if( tokenType>0 && (size_t)tokenType<(sizeof(kkTokenName)/sizeof(kkTokenName[0])) ){
    return kkTokenName[tokenType];
  }else{
    return "Unknown";
  }
#else
  return "";
#endif
}

void *phvolt_Alloc(void *(*mallocProc)(size_t)){
  kkParser *pParser;
  pParser = (kkParser*)(*mallocProc)( (size_t)sizeof(kkParser) );
  if( pParser ){
    pParser->kkidx = -1;
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "kkmajor" is the symbol code, and "kkpminor" is a pointer to
** the value.
*/
static void kk_destructor(KKCODETYPE kkmajor, KKMINORTYPE *kkpminor){
  switch( kkmajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
/* #line 697 "parser.y" */
{
	if ((kkpminor->kk0)) {
		if ((kkpminor->kk0)->free_flag) {
			efree((kkpminor->kk0)->token);
		}
		efree((kkpminor->kk0));
	}
}
/* #line 1692 "parser.c" */
      break;
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
/* #line 714 "parser.y" */
{ zval_ptr_dtor(&(kkpminor->kk132)); }
/* #line 1728 "parser.c" */
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

static int kk_pop_parser_stack(kkParser *pParser){
  KKCODETYPE kkmajor;
  kkStackEntry *kktos = &pParser->kkstack[pParser->kkidx];

  if( pParser->kkidx<0 ) return 0;
#ifndef NDEBUG
  if( kkTraceFILE && pParser->kkidx>=0 ){
    fprintf(kkTraceFILE,"%sPopping %s\n",
      kkTracePrompt,
      kkTokenName[kktos->major]);
  }
#endif
  kkmajor = kktos->major;
  kk_destructor( kkmajor, &kktos->minor);
  pParser->kkidx--;
  return kkmajor;
}

static void phvolt_Free(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  kkParser *pParser = (kkParser*)p;
  if( pParser==0 ) return;
  while( pParser->kkidx>=0 ) kk_pop_parser_stack(pParser);
  (*freeProc)((void*)pParser);
}

static int kk_find_shift_action(
  kkParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->kkstack[pParser->kkidx].stateno;
 
  /* if( pParser->kkidx<0 ) return KK_NO_ACTION;  */
  i = kk_shift_ofst[stateno];
  if( i==KK_SHIFT_USE_DFLT ){
    return kk_default[stateno];
  }
  if( iLookAhead==KKNOCODE ){
    return KK_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)KK_SZ_ACTTAB || kk_lookahead[i]!=iLookAhead ){
#ifdef KKFALLBACK
    int iFallback;            /* Fallback token */
    if( iLookAhead<sizeof(kkFallback)/sizeof(kkFallback[0])
           && (iFallback = kkFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
      if( kkTraceFILE ){
        fprintf(kkTraceFILE, "%sFALLBACK %s => %s\n",
           kkTracePrompt, kkTokenName[iLookAhead], kkTokenName[iFallback]);
      }
#endif
      return kk_find_shift_action(pParser, iFallback);
    }
#endif
    return kk_default[stateno];
  }else{
    return kk_action[i];
  }
}

static int kk_find_reduce_action(
  kkParser *pParser,        /* The parser */
  int iLookAhead            /* The look-ahead token */
){
  int i;
  int stateno = pParser->kkstack[pParser->kkidx].stateno;
 
  i = kk_reduce_ofst[stateno];
  if( i==KK_REDUCE_USE_DFLT ){
    return kk_default[stateno];
  }
  if( iLookAhead==KKNOCODE ){
    return KK_NO_ACTION;
  }
  i += iLookAhead;
  if( i<0 || i>=(int)KK_SZ_ACTTAB || kk_lookahead[i]!=iLookAhead ){
    return kk_default[stateno];
  }else{
    return kk_action[i];
  }
}

static void kk_shift(
  kkParser *kkpParser,          /* The parser to be shifted */
  int kkNewState,               /* The new state to shift in */
  int kkMajor,                  /* The major token to shift in */
  KKMINORTYPE *kkpMinor         /* Pointer ot the minor token to shift in */
){
  kkStackEntry *kktos;
  kkpParser->kkidx++;
  if( kkpParser->kkidx>=KKSTACKDEPTH ){
     phvolt_ARG_FETCH;
     kkpParser->kkidx--;
#ifndef NDEBUG
     if( kkTraceFILE ){
       fprintf(kkTraceFILE,"%sStack Overflow!\n",kkTracePrompt);
     }
#endif
     while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
     /* Here code is inserted which will execute if the parser
     ** stack every overflows */
     phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument var */
     return;
  }
  kktos = &kkpParser->kkstack[kkpParser->kkidx];
  kktos->stateno = kkNewState;
  kktos->major = kkMajor;
  kktos->minor = *kkpMinor;
#ifndef NDEBUG
  if( kkTraceFILE && kkpParser->kkidx>0 ){
    int i;
    fprintf(kkTraceFILE,"%sShift %d\n",kkTracePrompt,kkNewState);
    fprintf(kkTraceFILE,"%sStack:",kkTracePrompt);
    for(i=1; i<=kkpParser->kkidx; i++)
      fprintf(kkTraceFILE," %s",kkTokenName[kkpParser->kkstack[i].major]);
    fprintf(kkTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static struct {
  KKCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} kkRuleInfo[] = {
  { 78, 1 },
  { 79, 1 },
  { 80, 2 },
  { 80, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 81, 1 },
  { 83, 8 },
  { 83, 7 },
  { 83, 12 },
  { 83, 11 },
  { 83, 10 },
  { 84, 4 },
  { 85, 3 },
  { 86, 10 },
  { 86, 12 },
  { 86, 12 },
  { 86, 14 },
  { 87, 4 },
  { 102, 3 },
  { 102, 1 },
  { 103, 3 },
  { 103, 3 },
  { 103, 3 },
  { 103, 3 },
  { 103, 3 },
  { 98, 10 },
  { 98, 11 },
  { 104, 3 },
  { 104, 1 },
  { 105, 1 },
  { 105, 3 },
  { 106, 1 },
  { 106, 1 },
  { 106, 1 },
  { 106, 1 },
  { 106, 1 },
  { 106, 1 },
  { 100, 11 },
  { 100, 9 },
  { 99, 2 },
  { 88, 3 },
  { 89, 8 },
  { 89, 7 },
  { 90, 8 },
  { 90, 9 },
  { 91, 4 },
  { 92, 4 },
  { 92, 6 },
  { 93, 4 },
  { 94, 4 },
  { 95, 8 },
  { 95, 8 },
  { 96, 3 },
  { 97, 3 },
  { 82, 1 },
  { 101, 2 },
  { 101, 2 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 4 },
  { 101, 3 },
  { 101, 4 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 4 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 3 },
  { 101, 4 },
  { 101, 2 },
  { 101, 2 },
  { 101, 2 },
  { 101, 3 },
  { 101, 2 },
  { 101, 3 },
  { 101, 2 },
  { 101, 3 },
  { 101, 4 },
  { 101, 5 },
  { 101, 5 },
  { 101, 5 },
  { 101, 6 },
  { 109, 1 },
  { 109, 1 },
  { 108, 3 },
  { 108, 1 },
  { 110, 3 },
  { 110, 1 },
  { 101, 1 },
  { 111, 4 },
  { 111, 3 },
  { 107, 3 },
  { 107, 1 },
  { 112, 1 },
  { 112, 3 },
  { 101, 1 },
  { 101, 1 },
  { 101, 1 },
  { 101, 1 },
  { 101, 1 },
  { 101, 1 },
  { 101, 1 },
};

static void kk_accept(kkParser*);  /* Forward Declaration */

static void kk_reduce(
  kkParser *kkpParser,         /* The parser */
  int kkruleno                 /* Number of the rule by which to reduce */
){
  int kkgoto;                     /* The next state */
  int kkact;                      /* The next action */
  KKMINORTYPE kkgotominor;        /* The LHS of the rule reduced */
  kkStackEntry *kkmsp;            /* The top of the parser's stack */
  int kksize;                     /* Amount to pop the stack */
  phvolt_ARG_FETCH;
  kkmsp = &kkpParser->kkstack[kkpParser->kkidx];
#ifndef NDEBUG
  if( kkTraceFILE && kkruleno>=0 
        && kkruleno<(int)(sizeof(kkRuleName)/sizeof(kkRuleName[0])) ){
    fprintf(kkTraceFILE, "%sReduce [%s].\n", kkTracePrompt,
      kkRuleName[kkruleno]);
  }
#endif /* NDEBUG */

  switch( kkruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
      case 0:
/* #line 706 "parser.y" */
{
	status->ret = kkmsp[0].minor.kk132;
}
/* #line 2078 "parser.c" */
        break;
      case 1:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 119:
/* #line 710 "parser.y" */
{
	kkgotominor.kk132 = kkmsp[0].minor.kk132;
}
/* #line 2105 "parser.c" */
        break;
      case 2:
/* #line 716 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_zval_list(kkmsp[-1].minor.kk132, kkmsp[0].minor.kk132);
}
/* #line 2112 "parser.c" */
        break;
      case 3:
      case 36:
      case 45:
      case 116:
      case 123:
/* #line 720 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_zval_list(NULL, kkmsp[0].minor.kk132);
}
/* #line 2123 "parser.c" */
        break;
      case 23:
/* #line 804 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_if_statement(kkmsp[-5].minor.kk132, kkmsp[-3].minor.kk132, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-7].minor);
  kk_destructor(31,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(33,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2136 "parser.c" */
        break;
      case 24:
/* #line 808 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_if_statement(kkmsp[-4].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-6].minor);
  kk_destructor(31,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-3].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(33,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2149 "parser.c" */
        break;
      case 25:
/* #line 812 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_if_statement(kkmsp[-9].minor.kk132, kkmsp[-7].minor.kk132, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-11].minor);
  kk_destructor(31,&kkmsp[-10].minor);
  kk_destructor(32,&kkmsp[-8].minor);
  kk_destructor(1,&kkmsp[-6].minor);
  kk_destructor(34,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(33,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2165 "parser.c" */
        break;
      case 26:
/* #line 816 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_if_statement(kkmsp[-8].minor.kk132, kkmsp[-6].minor.kk132, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-10].minor);
  kk_destructor(31,&kkmsp[-9].minor);
  kk_destructor(32,&kkmsp[-7].minor);
  kk_destructor(1,&kkmsp[-5].minor);
  kk_destructor(34,&kkmsp[-4].minor);
  kk_destructor(32,&kkmsp[-3].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(33,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2181 "parser.c" */
        break;
      case 27:
/* #line 820 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_if_statement(kkmsp[-7].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-9].minor);
  kk_destructor(31,&kkmsp[-8].minor);
  kk_destructor(32,&kkmsp[-6].minor);
  kk_destructor(1,&kkmsp[-5].minor);
  kk_destructor(34,&kkmsp[-4].minor);
  kk_destructor(32,&kkmsp[-3].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(33,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2197 "parser.c" */
        break;
      case 28:
/* #line 826 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_elseif_statement(kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(35,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2207 "parser.c" */
        break;
      case 29:
/* #line 832 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_elsefor_statement(status->scanner_state);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(36,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2217 "parser.c" */
        break;
      case 30:
/* #line 838 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_for_statement(kkmsp[-7].minor.kk0, NULL, kkmsp[-5].minor.kk132, NULL, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-9].minor);
  kk_destructor(37,&kkmsp[-8].minor);
  kk_destructor(3,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(39,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2231 "parser.c" */
        break;
      case 31:
/* #line 842 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_for_statement(kkmsp[-9].minor.kk0, NULL, kkmsp[-7].minor.kk132, kkmsp[-5].minor.kk132, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-11].minor);
  kk_destructor(37,&kkmsp[-10].minor);
  kk_destructor(3,&kkmsp[-8].minor);
  kk_destructor(31,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(39,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2246 "parser.c" */
        break;
      case 32:
/* #line 846 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_for_statement(kkmsp[-7].minor.kk0, kkmsp[-9].minor.kk0, kkmsp[-5].minor.kk132, NULL, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-11].minor);
  kk_destructor(37,&kkmsp[-10].minor);
  kk_destructor(2,&kkmsp[-8].minor);
  kk_destructor(3,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(39,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2261 "parser.c" */
        break;
      case 33:
/* #line 850 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_for_statement(kkmsp[-9].minor.kk0, kkmsp[-11].minor.kk0, kkmsp[-7].minor.kk132, kkmsp[-5].minor.kk132, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-13].minor);
  kk_destructor(37,&kkmsp[-12].minor);
  kk_destructor(2,&kkmsp[-10].minor);
  kk_destructor(3,&kkmsp[-8].minor);
  kk_destructor(31,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(39,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2277 "parser.c" */
        break;
      case 34:
/* #line 856 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_statement(kkmsp[-1].minor.kk132);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(40,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2287 "parser.c" */
        break;
      case 35:
      case 44:
      case 115:
      case 122:
/* #line 862 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_zval_list(kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132);
  kk_destructor(2,&kkmsp[-1].minor);
}
/* #line 2298 "parser.c" */
        break;
      case 37:
/* #line 872 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_assignment(kkmsp[-2].minor.kk0, PHVOLT_T_ASSIGN, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(41,&kkmsp[-1].minor);
}
/* #line 2306 "parser.c" */
        break;
      case 38:
/* #line 876 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_assignment(kkmsp[-2].minor.kk0, PHVOLT_T_ADD_ASSIGN, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(42,&kkmsp[-1].minor);
}
/* #line 2314 "parser.c" */
        break;
      case 39:
/* #line 880 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_assignment(kkmsp[-2].minor.kk0, PHVOLT_T_SUB_ASSIGN, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(43,&kkmsp[-1].minor);
}
/* #line 2322 "parser.c" */
        break;
      case 40:
/* #line 884 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_assignment(kkmsp[-2].minor.kk0, PHVOLT_T_MUL_ASSIGN, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(44,&kkmsp[-1].minor);
}
/* #line 2330 "parser.c" */
        break;
      case 41:
/* #line 888 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_set_assignment(kkmsp[-2].minor.kk0, PHVOLT_T_DIV_ASSIGN, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(45,&kkmsp[-1].minor);
}
/* #line 2338 "parser.c" */
        break;
      case 42:
/* #line 894 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_statement(kkmsp[-7].minor.kk0, NULL, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-9].minor);
  kk_destructor(46,&kkmsp[-8].minor);
  kk_destructor(29,&kkmsp[-6].minor);
  kk_destructor(47,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(48,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2353 "parser.c" */
        break;
      case 43:
/* #line 898 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_statement(kkmsp[-8].minor.kk0, kkmsp[-6].minor.kk132, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-10].minor);
  kk_destructor(46,&kkmsp[-9].minor);
  kk_destructor(29,&kkmsp[-7].minor);
  kk_destructor(47,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(48,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2368 "parser.c" */
        break;
      case 46:
/* #line 914 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_parameter(kkmsp[0].minor.kk0, NULL, status->scanner_state);
}
/* #line 2375 "parser.c" */
        break;
      case 47:
/* #line 918 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_parameter(kkmsp[-2].minor.kk0, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(41,&kkmsp[-1].minor);
}
/* #line 2383 "parser.c" */
        break;
      case 48:
      case 113:
      case 127:
/* #line 922 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_INTEGER, kkmsp[0].minor.kk0, status->scanner_state);
}
/* #line 2392 "parser.c" */
        break;
      case 49:
      case 128:
/* #line 926 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_STRING, kkmsp[0].minor.kk0, status->scanner_state);
}
/* #line 2400 "parser.c" */
        break;
      case 50:
      case 129:
/* #line 930 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_DOUBLE, kkmsp[0].minor.kk0, status->scanner_state);
}
/* #line 2408 "parser.c" */
        break;
      case 51:
      case 130:
/* #line 934 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_NULL, NULL, status->scanner_state);
  kk_destructor(52,&kkmsp[0].minor);
}
/* #line 2417 "parser.c" */
        break;
      case 52:
      case 131:
/* #line 938 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_FALSE, NULL, status->scanner_state);
  kk_destructor(53,&kkmsp[0].minor);
}
/* #line 2426 "parser.c" */
        break;
      case 53:
      case 132:
/* #line 942 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_TRUE, NULL, status->scanner_state);
  kk_destructor(54,&kkmsp[0].minor);
}
/* #line 2435 "parser.c" */
        break;
      case 54:
/* #line 948 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_call_statement(kkmsp[-8].minor.kk132, kkmsp[-6].minor.kk132, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-10].minor);
  kk_destructor(55,&kkmsp[-9].minor);
  kk_destructor(29,&kkmsp[-7].minor);
  kk_destructor(47,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(56,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2450 "parser.c" */
        break;
      case 55:
/* #line 952 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_macro_call_statement(kkmsp[-6].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-8].minor);
  kk_destructor(55,&kkmsp[-7].minor);
  kk_destructor(29,&kkmsp[-5].minor);
  kk_destructor(47,&kkmsp[-4].minor);
  kk_destructor(32,&kkmsp[-3].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(56,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2465 "parser.c" */
        break;
      case 56:
/* #line 958 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_empty_statement(status->scanner_state);
  kk_destructor(1,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2474 "parser.c" */
        break;
      case 57:
/* #line 964 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_echo_statement(kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(57,&kkmsp[-2].minor);
  kk_destructor(58,&kkmsp[0].minor);
}
/* #line 2483 "parser.c" */
        break;
      case 58:
/* #line 970 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_block_statement(kkmsp[-5].minor.kk0, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-7].minor);
  kk_destructor(59,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(60,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2496 "parser.c" */
        break;
      case 59:
/* #line 974 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_block_statement(kkmsp[-4].minor.kk0, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-6].minor);
  kk_destructor(59,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-3].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(60,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2509 "parser.c" */
        break;
      case 60:
/* #line 980 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_cache_statement(kkmsp[-5].minor.kk132, NULL, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-7].minor);
  kk_destructor(61,&kkmsp[-6].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(62,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2522 "parser.c" */
        break;
      case 61:
/* #line 984 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_cache_statement(kkmsp[-6].minor.kk132, kkmsp[-5].minor.kk0, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-8].minor);
  kk_destructor(61,&kkmsp[-7].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(62,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2535 "parser.c" */
        break;
      case 62:
/* #line 990 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_extends_statement(kkmsp[-1].minor.kk0, status->scanner_state);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(63,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2545 "parser.c" */
        break;
      case 63:
/* #line 996 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_include_statement(kkmsp[-1].minor.kk132, NULL, status->scanner_state);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(64,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2555 "parser.c" */
        break;
      case 64:
/* #line 1000 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_include_statement(kkmsp[-3].minor.kk132, kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-5].minor);
  kk_destructor(64,&kkmsp[-4].minor);
  kk_destructor(65,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2566 "parser.c" */
        break;
      case 65:
/* #line 1006 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_do_statement(kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(66,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2576 "parser.c" */
        break;
      case 66:
/* #line 1012 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_return_statement(kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-3].minor);
  kk_destructor(67,&kkmsp[-2].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2586 "parser.c" */
        break;
      case 67:
/* #line 1018 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_autoescape_statement(0, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-7].minor);
  kk_destructor(68,&kkmsp[-6].minor);
  kk_destructor(53,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(69,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2600 "parser.c" */
        break;
      case 68:
/* #line 1022 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_autoescape_statement(1, kkmsp[-3].minor.kk132, status->scanner_state);
  kk_destructor(1,&kkmsp[-7].minor);
  kk_destructor(68,&kkmsp[-6].minor);
  kk_destructor(54,&kkmsp[-5].minor);
  kk_destructor(32,&kkmsp[-4].minor);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(69,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2614 "parser.c" */
        break;
      case 69:
/* #line 1028 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_break_statement(status->scanner_state);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(70,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2624 "parser.c" */
        break;
      case 70:
/* #line 1034 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_continue_statement(status->scanner_state);
  kk_destructor(1,&kkmsp[-2].minor);
  kk_destructor(71,&kkmsp[-1].minor);
  kk_destructor(32,&kkmsp[0].minor);
}
/* #line 2634 "parser.c" */
        break;
      case 71:
/* #line 1040 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_RAW_FRAGMENT, kkmsp[0].minor.kk0, status->scanner_state);
}
/* #line 2641 "parser.c" */
        break;
      case 72:
/* #line 1046 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_MINUS, NULL, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(22,&kkmsp[-1].minor);
}
/* #line 2649 "parser.c" */
        break;
      case 73:
/* #line 1050 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_PLUS, NULL, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(21,&kkmsp[-1].minor);
}
/* #line 2657 "parser.c" */
        break;
      case 74:
/* #line 1054 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_SUB, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(22,&kkmsp[-1].minor);
}
/* #line 2665 "parser.c" */
        break;
      case 75:
/* #line 1058 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ADD, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(21,&kkmsp[-1].minor);
}
/* #line 2673 "parser.c" */
        break;
      case 76:
/* #line 1062 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_MUL, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(19,&kkmsp[-1].minor);
}
/* #line 2681 "parser.c" */
        break;
      case 77:
/* #line 1066 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_POW, kkmsp[-3].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(19,&kkmsp[-2].minor);
  kk_destructor(19,&kkmsp[-1].minor);
}
/* #line 2690 "parser.c" */
        break;
      case 78:
/* #line 1070 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_DIV, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(18,&kkmsp[-1].minor);
}
/* #line 2698 "parser.c" */
        break;
      case 79:
/* #line 1074 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_MOD, kkmsp[-3].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(18,&kkmsp[-2].minor);
  kk_destructor(18,&kkmsp[-1].minor);
}
/* #line 2707 "parser.c" */
        break;
      case 80:
/* #line 1078 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_MOD, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(20,&kkmsp[-1].minor);
}
/* #line 2715 "parser.c" */
        break;
      case 81:
/* #line 1082 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_AND, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(7,&kkmsp[-1].minor);
}
/* #line 2723 "parser.c" */
        break;
      case 82:
/* #line 1086 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_OR, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(8,&kkmsp[-1].minor);
}
/* #line 2731 "parser.c" */
        break;
      case 83:
/* #line 1090 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_CONCAT, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(23,&kkmsp[-1].minor);
}
/* #line 2739 "parser.c" */
        break;
      case 84:
/* #line 1094 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_PIPE, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(25,&kkmsp[-1].minor);
}
/* #line 2747 "parser.c" */
        break;
      case 85:
/* #line 1098 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_RANGE, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(6,&kkmsp[-1].minor);
}
/* #line 2755 "parser.c" */
        break;
      case 86:
/* #line 1102 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_EQUALS, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(10,&kkmsp[-1].minor);
}
/* #line 2763 "parser.c" */
        break;
      case 87:
/* #line 1106 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_NOT_ISSET, kkmsp[-3].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(9,&kkmsp[-2].minor);
  kk_destructor(26,&kkmsp[-1].minor);
  kk_destructor(73,&kkmsp[0].minor);
}
/* #line 2773 "parser.c" */
        break;
      case 88:
/* #line 1110 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ISSET, kkmsp[-2].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(9,&kkmsp[-1].minor);
  kk_destructor(73,&kkmsp[0].minor);
}
/* #line 2782 "parser.c" */
        break;
      case 89:
/* #line 1114 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_IS, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(9,&kkmsp[-1].minor);
}
/* #line 2790 "parser.c" */
        break;
      case 90:
/* #line 1118 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_NOTEQUALS, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(11,&kkmsp[-1].minor);
}
/* #line 2798 "parser.c" */
        break;
      case 91:
/* #line 1122 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_IDENTICAL, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(16,&kkmsp[-1].minor);
}
/* #line 2806 "parser.c" */
        break;
      case 92:
/* #line 1126 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_NOTIDENTICAL, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(17,&kkmsp[-1].minor);
}
/* #line 2814 "parser.c" */
        break;
      case 93:
/* #line 1130 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_LESS, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(12,&kkmsp[-1].minor);
}
/* #line 2822 "parser.c" */
        break;
      case 94:
/* #line 1134 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_GREATER, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(13,&kkmsp[-1].minor);
}
/* #line 2830 "parser.c" */
        break;
      case 95:
/* #line 1138 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_GREATEREQUAL, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(14,&kkmsp[-1].minor);
}
/* #line 2838 "parser.c" */
        break;
      case 96:
/* #line 1142 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_LESSEQUAL, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(15,&kkmsp[-1].minor);
}
/* #line 2846 "parser.c" */
        break;
      case 97:
/* #line 1146 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_DOT, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(30,&kkmsp[-1].minor);
}
/* #line 2854 "parser.c" */
        break;
      case 98:
/* #line 1150 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_IN, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(3,&kkmsp[-1].minor);
}
/* #line 2862 "parser.c" */
        break;
      case 99:
/* #line 1154 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_NOT_IN, kkmsp[-3].minor.kk132, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(26,&kkmsp[-2].minor);
  kk_destructor(3,&kkmsp[-1].minor);
}
/* #line 2871 "parser.c" */
        break;
      case 100:
/* #line 1158 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_NOT, NULL, kkmsp[0].minor.kk132, NULL, status->scanner_state);
  kk_destructor(26,&kkmsp[-1].minor);
}
/* #line 2879 "parser.c" */
        break;
      case 101:
/* #line 1162 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_INCR, kkmsp[-1].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(27,&kkmsp[0].minor);
}
/* #line 2887 "parser.c" */
        break;
      case 102:
/* #line 1166 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_DECR, kkmsp[-1].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(28,&kkmsp[0].minor);
}
/* #line 2895 "parser.c" */
        break;
      case 103:
/* #line 1170 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ENCLOSED, kkmsp[-1].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(29,&kkmsp[-2].minor);
  kk_destructor(47,&kkmsp[0].minor);
}
/* #line 2904 "parser.c" */
        break;
      case 104:
/* #line 1174 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ARRAY, NULL, NULL, NULL, status->scanner_state);
  kk_destructor(24,&kkmsp[-1].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2913 "parser.c" */
        break;
      case 105:
/* #line 1178 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ARRAY, kkmsp[-1].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2922 "parser.c" */
        break;
      case 106:
/* #line 1182 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ARRAY, NULL, NULL, NULL, status->scanner_state);
  kk_destructor(75,&kkmsp[-1].minor);
  kk_destructor(76,&kkmsp[0].minor);
}
/* #line 2931 "parser.c" */
        break;
      case 107:
/* #line 1186 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ARRAY, kkmsp[-1].minor.kk132, NULL, NULL, status->scanner_state);
  kk_destructor(75,&kkmsp[-2].minor);
  kk_destructor(76,&kkmsp[0].minor);
}
/* #line 2940 "parser.c" */
        break;
      case 108:
/* #line 1190 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_ARRAYACCESS, kkmsp[-3].minor.kk132, kkmsp[-1].minor.kk132, NULL, status->scanner_state);
  kk_destructor(24,&kkmsp[-2].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2949 "parser.c" */
        break;
      case 109:
/* #line 1194 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_expr(PHVOLT_T_TERNARY, kkmsp[-2].minor.kk132, kkmsp[0].minor.kk132, kkmsp[-4].minor.kk132, status->scanner_state);
  kk_destructor(4,&kkmsp[-3].minor);
  kk_destructor(5,&kkmsp[-1].minor);
}
/* #line 2958 "parser.c" */
        break;
      case 110:
/* #line 1198 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_slice(kkmsp[-4].minor.kk132, NULL, kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(24,&kkmsp[-3].minor);
  kk_destructor(5,&kkmsp[-2].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2968 "parser.c" */
        break;
      case 111:
/* #line 1202 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_slice(kkmsp[-4].minor.kk132, kkmsp[-2].minor.kk132, NULL, status->scanner_state);
  kk_destructor(24,&kkmsp[-3].minor);
  kk_destructor(5,&kkmsp[-1].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2978 "parser.c" */
        break;
      case 112:
/* #line 1206 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_slice(kkmsp[-5].minor.kk132, kkmsp[-3].minor.kk132, kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(24,&kkmsp[-4].minor);
  kk_destructor(5,&kkmsp[-2].minor);
  kk_destructor(74,&kkmsp[0].minor);
}
/* #line 2988 "parser.c" */
        break;
      case 114:
      case 126:
/* #line 1216 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_literal_zval(PHVOLT_T_IDENTIFIER, kkmsp[0].minor.kk0, status->scanner_state);
}
/* #line 2996 "parser.c" */
        break;
      case 117:
      case 125:
/* #line 1232 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_named_item(kkmsp[-2].minor.kk0, kkmsp[0].minor.kk132, status->scanner_state);
  kk_destructor(5,&kkmsp[-1].minor);
}
/* #line 3005 "parser.c" */
        break;
      case 118:
      case 124:
/* #line 1236 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_named_item(NULL, kkmsp[0].minor.kk132, status->scanner_state);
}
/* #line 3013 "parser.c" */
        break;
      case 120:
/* #line 1246 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_func_call(kkmsp[-3].minor.kk132, kkmsp[-1].minor.kk132, status->scanner_state);
  kk_destructor(29,&kkmsp[-2].minor);
  kk_destructor(47,&kkmsp[0].minor);
}
/* #line 3022 "parser.c" */
        break;
      case 121:
/* #line 1250 "parser.y" */
{
	kkgotominor.kk132 = phvolt_ret_func_call(kkmsp[-2].minor.kk132, NULL, status->scanner_state);
  kk_destructor(29,&kkmsp[-1].minor);
  kk_destructor(47,&kkmsp[0].minor);
}
/* #line 3031 "parser.c" */
        break;
  };
  kkgoto = kkRuleInfo[kkruleno].lhs;
  kksize = kkRuleInfo[kkruleno].nrhs;
  kkpParser->kkidx -= kksize;
  kkact = kk_find_reduce_action(kkpParser,kkgoto);
  if( kkact < KKNSTATE ){
    kk_shift(kkpParser,kkact,kkgoto,&kkgotominor);
  }else if( kkact == KKNSTATE + KKNRULE + 1 ){
    kk_accept(kkpParser);
  }
}

static void kk_parse_failed(
  kkParser *kkpParser           /* The parser */
){
  phvolt_ARG_FETCH;
#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sFail!\n",kkTracePrompt);
  }
#endif
  while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void kk_syntax_error(
  kkParser *kkpParser,           /* The parser */
  int kkmajor,                   /* The major type of the error token */
  KKMINORTYPE kkminor            /* The minor type of the error token */
){
  phvolt_ARG_FETCH;
#define KTOKEN (kkminor.kk0)
/* #line 599 "parser.y" */

	{

		smart_str error_str = {0};

		char *token_name = NULL;
		const phvolt_token_names *tokens = phvolt_tokens;
		int token_len = 0;
		uint active_token = status->scanner_state->active_token;

		if (status->scanner_state->start_length) {

			if (active_token) {

				do {
					if (tokens->code == active_token) {
						token_name = tokens->name;
						token_len = tokens->len;
						break;
					}
					++tokens;
				} while (tokens[0].code != 0);

			}

			smart_str_appendl(&error_str, "Syntax error, unexpected token ", sizeof("Syntax error, unexpected token ") - 1);
			if (!token_name) {
				smart_str_appendl(&error_str, "UNKNOWN", sizeof("UNKNOWN") - 1);
			} else {
				smart_str_appendl(&error_str, token_name, token_len);
			}
			if (status->token->value) {
				smart_str_appendc(&error_str, '(');
				smart_str_appendl(&error_str, status->token->value, status->token->len);
				smart_str_appendc(&error_str, ')');
			}
			smart_str_appendl(&error_str, " in ", sizeof(" in ") - 1);
			smart_str_appendl(&error_str, Z_STRVAL_P(status->scanner_state->active_file), Z_STRLEN_P(status->scanner_state->active_file));
			smart_str_appendl(&error_str, " on line ", sizeof(" on line ") - 1);
			{
				char stmp[MAX_LENGTH_OF_LONG + 1];
				int str_len;
				str_len = slprintf(stmp, sizeof(stmp), "%ld", status->scanner_state->active_line);
				smart_str_appendl(&error_str, stmp, str_len);
			}

		} else {

			smart_str_appendl(&error_str, "Syntax error, unexpected EOF in ", sizeof("Syntax error, unexpected EOF in ") - 1);
			smart_str_appendl(&error_str, Z_STRVAL_P(status->scanner_state->active_file), Z_STRLEN_P(status->scanner_state->active_file));

			/* Report unclosed 'if' blocks */
			if ((status->scanner_state->if_level + status->scanner_state->old_if_level) > 0) {
				if ((status->scanner_state->if_level + status->scanner_state->old_if_level) == 1) {
					smart_str_appendl(&error_str, ", there is one 'if' block without close", sizeof(", there is one 'if' block without close") - 1);
				} else {
					smart_str_appendl(&error_str, ", there are ", sizeof(", there are ") - 1);
					{
						char stmp[MAX_LENGTH_OF_LONG + 1];
						int str_len;
						str_len = slprintf(stmp, sizeof(stmp), "%ld", status->scanner_state->if_level + status->scanner_state->old_if_level);
						smart_str_appendl(&error_str, stmp, str_len);
					}
					smart_str_appendl(&error_str, " 'if' blocks without close", sizeof(" 'if' blocks without close") - 1);
				}
			}

			/* Report unclosed 'for' blocks */
			if (status->scanner_state->for_level > 0) {
				if (status->scanner_state->for_level == 1) {
					smart_str_appendl(&error_str, ", there is one 'for' block without close", sizeof(", there is one 'for' block without close") - 1);
				} else {
					smart_str_appendl(&error_str, ", there are ", sizeof(", there are ") - 1);
					{
						char stmp[MAX_LENGTH_OF_LONG + 1];
						int str_len;
						str_len = slprintf(stmp, sizeof(stmp), "%ld", status->scanner_state->if_level);
						smart_str_appendl(&error_str, stmp, str_len);
					}
					smart_str_appendl(&error_str, " 'for' blocks without close", sizeof(" 'for' blocks without close") - 1);
				}
			}
		}

		smart_str_0(&error_str);

		if (error_str.len) {
			status->syntax_error = error_str.c;
			status->syntax_error_len = error_str.len;
		} else {
			status->syntax_error = NULL;
		}

	}

	status->status = PHVOLT_PARSING_FAILED;

/* #line 3171 "parser.c" */
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

static void kk_accept(
  kkParser *kkpParser           /* The parser */
){
  phvolt_ARG_FETCH;
#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sAccept!\n",kkTracePrompt);
  }
#endif
  while( kkpParser->kkidx>=0 ) kk_pop_parser_stack(kkpParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  phvolt_ARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "phvolt_Alloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
static void phvolt_(
  void *kkp,                   /* The parser */
  int kkmajor,                 /* The major token code number */
  phvolt_KTOKENTYPE kkminor       /* The value for the token */
  phvolt_ARG_PDECL               /* Optional %extra_argument parameter */
){
  KKMINORTYPE kkminorunion;
  int kkact;            /* The parser action. */
  int kkendofinput;     /* True if we are at the end of input */
  int kkerrorhit = 0;   /* True if kkmajor has invoked an error */
  kkParser *kkpParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  kkpParser = (kkParser*)kkp;
  if( kkpParser->kkidx<0 ){
    if( kkmajor==0 ) return;
    kkpParser->kkidx = 0;
    kkpParser->kkerrcnt = -1;
    kkpParser->kkstack[0].stateno = 0;
    kkpParser->kkstack[0].major = 0;
  }
  kkminorunion.kk0 = kkminor;
  kkendofinput = (kkmajor==0);
  phvolt_ARG_STORE;

#ifndef NDEBUG
  if( kkTraceFILE ){
    fprintf(kkTraceFILE,"%sInput %s\n",kkTracePrompt,kkTokenName[kkmajor]);
  }
#endif

  do{
    kkact = kk_find_shift_action(kkpParser,kkmajor);
    if( kkact<KKNSTATE ){
      kk_shift(kkpParser,kkact,kkmajor,&kkminorunion);
      kkpParser->kkerrcnt--;
      if( kkendofinput && kkpParser->kkidx>=0 ){
        kkmajor = 0;
      }else{
        kkmajor = KKNOCODE;
      }
    }else if( kkact < KKNSTATE + KKNRULE ){
      kk_reduce(kkpParser,kkact-KKNSTATE);
    }else if( kkact == KK_ERROR_ACTION ){
      int kkmx;
#ifndef NDEBUG
      if( kkTraceFILE ){
        fprintf(kkTraceFILE,"%sSyntax Error!\n",kkTracePrompt);
      }
#endif
#ifdef KKERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( kkpParser->kkerrcnt<0 ){
        kk_syntax_error(kkpParser,kkmajor,kkminorunion);
      }
      kkmx = kkpParser->kkstack[kkpParser->kkidx].major;
      if( kkmx==KKERRORSYMBOL || kkerrorhit ){
#ifndef NDEBUG
        if( kkTraceFILE ){
          fprintf(kkTraceFILE,"%sDiscard input token %s\n",
             kkTracePrompt,kkTokenName[kkmajor]);
        }
#endif
        kk_destructor(kkmajor,&kkminorunion);
        kkmajor = KKNOCODE;
      }else{
         while(
          kkpParser->kkidx >= 0 &&
          kkmx != KKERRORSYMBOL &&
          (kkact = kk_find_shift_action(kkpParser,KKERRORSYMBOL)) >= KKNSTATE
        ){
          kk_pop_parser_stack(kkpParser);
        }
        if( kkpParser->kkidx < 0 || kkmajor==0 ){
          kk_destructor(kkmajor,&kkminorunion);
          kk_parse_failed(kkpParser);
          kkmajor = KKNOCODE;
        }else if( kkmx!=KKERRORSYMBOL ){
          KKMINORTYPE u2;
          u2.KKERRSYMDT = 0;
          kk_shift(kkpParser,kkact,KKERRORSYMBOL,&u2);
        }
      }
      kkpParser->kkerrcnt = 3;
      kkerrorhit = 1;
#else  /* KKERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( kkpParser->kkerrcnt<=0 ){
        kk_syntax_error(kkpParser,kkmajor,kkminorunion);
      }
      kkpParser->kkerrcnt = 3;
      kk_destructor(kkmajor,&kkminorunion);
      if( kkendofinput ){
        kk_parse_failed(kkpParser);
      }
      kkmajor = KKNOCODE;
#endif
    }else{
      kk_accept(kkpParser);
      kkmajor = KKNOCODE;
    }
  }while( kkmajor!=KKNOCODE && kkpParser->kkidx>=0 );
  return;
}


const phvolt_token_names phvolt_tokens[] =
{
  { SL("INTEGER"),        PHVOLT_T_INTEGER },
  { SL("DOUBLE"),         PHVOLT_T_DOUBLE },
  { SL("STRING"),         PHVOLT_T_STRING },
  { SL("IDENTIFIER"),     PHVOLT_T_IDENTIFIER },
  { SL("MINUS"),          PHVOLT_T_MINUS },
  { SL("+"),              PHVOLT_T_ADD },
  { SL("-"),              PHVOLT_T_SUB },
  { SL("*"),              PHVOLT_T_MUL },
  { SL("/"),              PHVOLT_T_DIV },
  { SL("%%"),             PHVOLT_T_MOD },
  { SL("!"),              PHVOLT_T_NOT },
  { SL("~"),              PHVOLT_T_CONCAT },
  { SL("AND"),            PHVOLT_T_AND },
  { SL("OR"),             PHVOLT_T_OR },
  { SL("DOT"),            PHVOLT_T_DOT },
  { SL("COMMA"),          PHVOLT_T_COMMA },
  { SL("EQUALS"),         PHVOLT_T_EQUALS },
  { SL("NOT EQUALS"),     PHVOLT_T_NOTEQUALS },
  { SL("IDENTICAL"),      PHVOLT_T_IDENTICAL },
  { SL("NOT IDENTICAL"),  PHVOLT_T_NOTIDENTICAL },
  { SL("NOT"),            PHVOLT_T_NOT },
  { SL("RANGE"),          PHVOLT_T_RANGE },
  { SL("COLON"),          PHVOLT_T_COLON },
  { SL("QUESTION MARK"),  PHVOLT_T_QUESTION },
  { SL("<"),              PHVOLT_T_LESS },
  { SL("<="),             PHVOLT_T_LESSEQUAL },
  { SL(">"),              PHVOLT_T_GREATER },
  { SL(">="),             PHVOLT_T_GREATEREQUAL },
  { SL("("),              PHVOLT_T_PARENTHESES_OPEN },
  { SL(")"),              PHVOLT_T_PARENTHESES_CLOSE },
  { SL("["),              PHVOLT_T_SBRACKET_OPEN },
  { SL("]"),              PHVOLT_T_SBRACKET_CLOSE },
  { SL("{"),              PHVOLT_T_CBRACKET_OPEN },
  { SL("}"),              PHVOLT_T_CBRACKET_CLOSE },
  { SL("{%"),             PHVOLT_T_OPEN_DELIMITER },
  { SL("%}"),             PHVOLT_T_CLOSE_DELIMITER },
  { SL("{{"),             PHVOLT_T_OPEN_EDELIMITER },
  { SL("}}"),             PHVOLT_T_CLOSE_EDELIMITER },
  { SL("IF"),             PHVOLT_T_IF },
  { SL("ELSE"),           PHVOLT_T_ELSE },
  { SL("ELSEIF"),         PHVOLT_T_ELSEIF },
  { SL("ELSEFOR"),        PHVOLT_T_ELSEFOR },
  { SL("ENDIF"),          PHVOLT_T_ENDIF },
  { SL("FOR"),            PHVOLT_T_FOR },
  { SL("IN"),             PHVOLT_T_IN },
  { SL("ENDFOR"),         PHVOLT_T_ENDFOR },
  { SL("SET"),            PHVOLT_T_SET },
  { SL("ASSIGN"),         PHVOLT_T_ASSIGN },
  { SL("+="),             PHVOLT_T_ADD_ASSIGN },
  { SL("-="),             PHVOLT_T_SUB_ASSIGN },
  { SL("*="),             PHVOLT_T_MUL_ASSIGN },
  { SL("/="),             PHVOLT_T_DIV_ASSIGN },
  { SL("++"),             PHVOLT_T_INCR },
  { SL("--"),             PHVOLT_T_DECR },
  { SL("BLOCK"),          PHVOLT_T_BLOCK },
  { SL("ENDBLOCK"),       PHVOLT_T_ENDBLOCK },
  { SL("CACHE"),          PHVOLT_T_CACHE },
  { SL("ENDCACHE"),       PHVOLT_T_ENDCACHE },
  { SL("EXTENDS"),        PHVOLT_T_EXTENDS },
  { SL("IS"),             PHVOLT_T_IS },
  { SL("DEFINED"),        PHVOLT_T_DEFINED },
  { SL("INCLUDE"),        PHVOLT_T_INCLUDE },
  { SL("DO"),             PHVOLT_T_DO },
  { SL("WHITESPACE"),     PHVOLT_T_IGNORE },
  { SL("AUTOESCAPE"),     PHVOLT_T_AUTOESCAPE },
  { SL("ENDAUTOESCAPE"),  PHVOLT_T_ENDAUTOESCAPE },
  { SL("CONTINUE"),       PHVOLT_T_CONTINUE },
  { SL("BREAK"),          PHVOLT_T_BREAK },
  { SL("WITH"),           PHVOLT_T_WITH },
  { SL("RETURN"),         PHVOLT_T_RETURN },
  { SL("MACRO"),          PHVOLT_T_MACRO },
  { SL("ENDMACRO"),       PHVOLT_T_ENDMACRO },
  { SL("CALL"),           PHVOLT_T_CALL },
  { SL("WITH"),           PHVOLT_T_WITH },
  { NULL, 0, 0 }
};

static void *phvolt_wrapper_alloc(size_t bytes){
	return emalloc(bytes);
}

static void phvolt_wrapper_free(void *pointer){
	efree(pointer);
}

static void phvolt_parse_with_token(void* phvolt_parser, int opcode, int parsercode, phvolt_scanner_token *token, phvolt_parser_status *parser_status){

	phvolt_parser_token *pToken;

	pToken = emalloc(sizeof(phvolt_parser_token));
	pToken->opcode = opcode;
	pToken->token = token->value;
	pToken->token_len = token->len;
	pToken->free_flag = 1;

	phvolt_(phvolt_parser, parsercode, pToken, parser_status);

	token->value = NULL;
	token->len = 0;
}

static void phvolt_create_error_msg(phvolt_parser_status *parser_status, char *message){

	unsigned int length = (128 + Z_STRLEN_P(parser_status->scanner_state->active_file));
	char *str = emalloc(sizeof(char) * length);

	snprintf(str, length, "%s in %s on line %d", message, Z_STRVAL_P(parser_status->scanner_state->active_file), parser_status->scanner_state->active_line);
	str[length - 1] = '\0';

	parser_status->syntax_error = estrndup(str, strlen(str));
	efree(str);
}

static void phvolt_scanner_error_msg(phvolt_parser_status *parser_status, zval **error_msg TSRMLS_DC){

	char *error, *error_part;
	int length;
	phvolt_scanner_state *state = parser_status->scanner_state;

	MAKE_STD_ZVAL(*error_msg);
	if (state->start) {
		error = emalloc(sizeof(char) * 72 + state->start_length +  Z_STRLEN_P(state->active_file));
		if (state->start_length > 16) {
			length = 72 + Z_STRLEN_P(state->active_file);
			error_part = estrndup(state->start, 16);
			snprintf(error, length, "Scanning error before '%s...' in %s on line %d", error_part, Z_STRVAL_P(state->active_file), state->active_line);
			error[length - 1] = '\0';
		} else {
			length = 48 + state->start_length + Z_STRLEN_P(state->active_file);
			snprintf(error, length, "Scanning error before '%s' in %s on line %d", state->start, Z_STRVAL_P(state->active_file), state->active_line);
		}
	} else {
		error = emalloc(sizeof(char) * (32 + Z_STRLEN_P(state->active_file)));
		length = 32 + Z_STRLEN_P(state->active_file);
		snprintf(error, length, "Scanning error near to EOF in %s", Z_STRVAL_P(state->active_file));
	}

	error[length - 1] = '\0';
	ZVAL_STRING(*error_msg, error, 1);
	efree(error);
}

static int phvolt_parse_view(zval *result, zval *view_code, zval *template_path TSRMLS_DC){

	zval *error_msg = NULL;

	ZVAL_NULL(result);

	if (Z_TYPE_P(view_code) != IS_STRING) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_mvc_view_exception_ce, "View code must be a string");
		return FAILURE;
	}

	if (phvolt_internal_parse_view(&result, view_code, template_path, &error_msg TSRMLS_CC) == FAILURE) {
		if (likely(error_msg != NULL)) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, Z_STRVAL_P(error_msg));
			zval_ptr_dtor(&error_msg);
		}
		else {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_mvc_view_exception_ce, "Error parsing the view");
		}

		return FAILURE;
	}

	return SUCCESS;
}

static int phvolt_is_blank_string(phvolt_scanner_token *token){

	char *marker = token->value;
	int i;

	for (i = 0; i < token->len; i++) {
		char ch = *marker;
		if (ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r' && ch != 11) {
			return 0;
		}
		marker++;
	}

	return 1;
}

static int phvolt_internal_parse_view(zval **result, zval *view_code, zval *template_path, zval **error_msg TSRMLS_DC) {

	char *error;
	phvolt_scanner_state *state;
	phvolt_scanner_token token;
	int scanner_status, status = SUCCESS;
	phvolt_parser_status *parser_status = NULL;
	void* phvolt_parser;

	/** Check if the view has code */
	if (!Z_STRVAL_P(view_code)) {
		MAKE_STD_ZVAL(*error_msg);
		ZVAL_STRING(*error_msg, "View code cannot be null", 1);
		return FAILURE;
	}

	if (!Z_STRLEN_P(view_code)) {
		array_init(*result);
		return SUCCESS;
	}

	/** Start the reentrant parser */
	phvolt_parser = phvolt_Alloc(phvolt_wrapper_alloc);
	if (unlikely(!phvolt_parser)) {
		MAKE_STD_ZVAL(*error_msg);
		ZVAL_STRING(*error_msg, "Memory allocation error", 1);
		return FAILURE;
	}

	parser_status = emalloc(sizeof(phvolt_parser_status));
	state = emalloc(sizeof(phvolt_scanner_state));

	parser_status->status = PHVOLT_PARSING_OK;
	parser_status->scanner_state = state;
	parser_status->ret = NULL;
	parser_status->token = &token;
	parser_status->syntax_error = NULL;

	/** Initialize the scanner state */
	state->active_token = 0;
	state->start = Z_STRVAL_P(view_code);
	state->mode = PHVOLT_MODE_RAW;
	state->raw_buffer = emalloc(sizeof(char) * PHVOLT_RAW_BUFFER_SIZE);
	state->raw_buffer_size = PHVOLT_RAW_BUFFER_SIZE;
	state->raw_buffer_cursor = 0;
	state->active_file = template_path;
	state->active_line = 1;
	state->statement_position = 0;
	state->extends_mode = 0;
	state->block_level = 0;
	state->macro_level = 0;
	state->start_length = 0;
	state->old_if_level = 0;
	state->if_level = 0;
	state->for_level = 0;
	state->whitespace_control = 0;

	state->end = state->start;

	token.value = NULL;
	token.len = 0;

	while (0 <= (scanner_status = phvolt_get_token(state, &token))) {

		state->active_token = token.opcode;

		state->start_length = (Z_STRVAL_P(view_code) + Z_STRLEN_P(view_code) - state->start);

		switch (token.opcode) {

			case PHVOLT_T_IGNORE:
				break;

			case PHVOLT_T_ADD:
				phvolt_(phvolt_parser, PHVOLT_PLUS, NULL, parser_status);
				break;
			case PHVOLT_T_SUB:
				phvolt_(phvolt_parser, PHVOLT_MINUS, NULL, parser_status);
				break;
			case PHVOLT_T_MUL:
				phvolt_(phvolt_parser, PHVOLT_TIMES, NULL, parser_status);
				break;
			case PHVOLT_T_DIV:
				phvolt_(phvolt_parser, PHVOLT_DIVIDE, NULL, parser_status);
				break;
			case PHVOLT_T_MOD:
				phvolt_(phvolt_parser, PHVOLT_MOD, NULL, parser_status);
				break;
			case PHVOLT_T_AND:
				phvolt_(phvolt_parser, PHVOLT_AND, NULL, parser_status);
				break;
			case PHVOLT_T_OR:
				phvolt_(phvolt_parser, PHVOLT_OR, NULL, parser_status);
				break;
			case PHVOLT_T_IS:
				phvolt_(phvolt_parser, PHVOLT_IS, NULL, parser_status);
				break;
			case PHVOLT_T_EQUALS:
				phvolt_(phvolt_parser, PHVOLT_EQUALS, NULL, parser_status);
				break;
			case PHVOLT_T_NOTEQUALS:
				phvolt_(phvolt_parser, PHVOLT_NOTEQUALS, NULL, parser_status);
				break;
			case PHVOLT_T_LESS:
				phvolt_(phvolt_parser, PHVOLT_LESS, NULL, parser_status);
				break;
			case PHVOLT_T_GREATER:
				phvolt_(phvolt_parser, PHVOLT_GREATER, NULL, parser_status);
				break;
			case PHVOLT_T_GREATEREQUAL:
				phvolt_(phvolt_parser, PHVOLT_GREATEREQUAL, NULL, parser_status);
				break;
			case PHVOLT_T_LESSEQUAL:
				phvolt_(phvolt_parser, PHVOLT_LESSEQUAL, NULL, parser_status);
				break;
			case PHVOLT_T_IDENTICAL:
				phvolt_(phvolt_parser, PHVOLT_IDENTICAL, NULL, parser_status);
				break;
			case PHVOLT_T_NOTIDENTICAL:
				phvolt_(phvolt_parser, PHVOLT_NOTIDENTICAL, NULL, parser_status);
				break;
			case PHVOLT_T_NOT:
				phvolt_(phvolt_parser, PHVOLT_NOT, NULL, parser_status);
				break;
			case PHVOLT_T_DOT:
				phvolt_(phvolt_parser, PHVOLT_DOT, NULL, parser_status);
				break;
			case PHVOLT_T_CONCAT:
				phvolt_(phvolt_parser, PHVOLT_CONCAT, NULL, parser_status);
				break;
			case PHVOLT_T_RANGE:
				phvolt_(phvolt_parser, PHVOLT_RANGE, NULL, parser_status);
				break;
			case PHVOLT_T_PIPE:
				phvolt_(phvolt_parser, PHVOLT_PIPE, NULL, parser_status);
				break;
			case PHVOLT_T_COMMA:
				phvolt_(phvolt_parser, PHVOLT_COMMA, NULL, parser_status);
				break;
			case PHVOLT_T_COLON:
				phvolt_(phvolt_parser, PHVOLT_COLON, NULL, parser_status);
				break;
			case PHVOLT_T_QUESTION:
				phvolt_(phvolt_parser, PHVOLT_QUESTION, NULL, parser_status);
				break;

			case PHVOLT_T_PARENTHESES_OPEN:
				phvolt_(phvolt_parser, PHVOLT_PARENTHESES_OPEN, NULL, parser_status);
				break;
			case PHVOLT_T_PARENTHESES_CLOSE:
				phvolt_(phvolt_parser, PHVOLT_PARENTHESES_CLOSE, NULL, parser_status);
				break;
			case PHVOLT_T_SBRACKET_OPEN:
				phvolt_(phvolt_parser, PHVOLT_SBRACKET_OPEN, NULL, parser_status);
				break;
			case PHVOLT_T_SBRACKET_CLOSE:
				phvolt_(phvolt_parser, PHVOLT_SBRACKET_CLOSE, NULL, parser_status);
				break;
			case PHVOLT_T_CBRACKET_OPEN:
				phvolt_(phvolt_parser, PHVOLT_CBRACKET_OPEN, NULL, parser_status);
				break;
			case PHVOLT_T_CBRACKET_CLOSE:
				phvolt_(phvolt_parser, PHVOLT_CBRACKET_CLOSE, NULL, parser_status);
				break;

			case PHVOLT_T_OPEN_DELIMITER:
				phvolt_(phvolt_parser, PHVOLT_OPEN_DELIMITER, NULL, parser_status);
				break;
			case PHVOLT_T_CLOSE_DELIMITER:
				phvolt_(phvolt_parser, PHVOLT_CLOSE_DELIMITER, NULL, parser_status);
				break;

			case PHVOLT_T_OPEN_EDELIMITER:
				if (state->extends_mode == 1 && state->block_level == 0) {
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				}
				phvolt_(phvolt_parser, PHVOLT_OPEN_EDELIMITER, NULL, parser_status);
				break;
			case PHVOLT_T_CLOSE_EDELIMITER:
				phvolt_(phvolt_parser, PHVOLT_CLOSE_EDELIMITER, NULL, parser_status);
				break;

			case PHVOLT_T_NULL:
				phvolt_(phvolt_parser, PHVOLT_NULL, NULL, parser_status);
				break;
			case PHVOLT_T_TRUE:
				phvolt_(phvolt_parser, PHVOLT_TRUE, NULL, parser_status);
				break;
			case PHVOLT_T_FALSE:
				phvolt_(phvolt_parser, PHVOLT_FALSE, NULL, parser_status);
				break;

			case PHVOLT_T_INTEGER:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_INTEGER, PHVOLT_INTEGER, &token, parser_status);
				break;
			case PHVOLT_T_DOUBLE:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_DOUBLE, PHVOLT_DOUBLE, &token, parser_status);
				break;
			case PHVOLT_T_STRING:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_STRING, PHVOLT_STRING, &token, parser_status);
				break;
			case PHVOLT_T_IDENTIFIER:
				phvolt_parse_with_token(phvolt_parser, PHVOLT_T_IDENTIFIER, PHVOLT_IDENTIFIER, &token, parser_status);
				break;

			case PHVOLT_T_IF:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->if_level++;
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_IF, NULL, parser_status);
				break;

			case PHVOLT_T_ELSE:
				if (state->if_level == 0 && state->for_level > 0) {
					phvolt_(phvolt_parser, PHVOLT_ELSEFOR, NULL, parser_status);
				} else {
					phvolt_(phvolt_parser, PHVOLT_ELSE, NULL, parser_status);
				}
				break;

			case PHVOLT_T_ELSEFOR:
				phvolt_(phvolt_parser, PHVOLT_ELSEFOR, NULL, parser_status);
				break;

			case PHVOLT_T_ELSEIF:
				if (state->if_level == 0) {
					phvolt_create_error_msg(parser_status, "Unexpected ENDIF");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				}
				phvolt_(phvolt_parser, PHVOLT_ELSEIF, NULL, parser_status);
				break;

			case PHVOLT_T_ENDIF:
				state->block_level--;
				state->if_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDIF, NULL, parser_status);
				break;

			case PHVOLT_T_FOR:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->old_if_level = state->if_level;
					state->if_level = 0;
					state->for_level++;
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_FOR, NULL, parser_status);
				break;

			case PHVOLT_T_IN:
				phvolt_(phvolt_parser, PHVOLT_IN, NULL, parser_status);
				break;

			case PHVOLT_T_ENDFOR:
				state->block_level--;
				state->for_level--;
				state->if_level = state->old_if_level;
				phvolt_(phvolt_parser, PHVOLT_ENDFOR, NULL, parser_status);
				break;

			case PHVOLT_T_RAW_FRAGMENT:
				if (token.len > 0) {
					if (state->extends_mode == 1 && state->block_level == 0){
						if (!phvolt_is_blank_string(&token)) {
							phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
							parser_status->status = PHVOLT_PARSING_FAILED;
						}
						efree(token.value);
						break;
					} else {
						if (!phvolt_is_blank_string(&token)) {
							state->statement_position++;
						}
					}
					phvolt_parse_with_token(phvolt_parser, PHVOLT_T_RAW_FRAGMENT, PHVOLT_RAW_FRAGMENT, &token, parser_status);
				} else {
					efree(token.value);
				}
				break;

			case PHVOLT_T_SET:
				if (state->extends_mode == 1 && state->block_level == 0){
					phvolt_create_error_msg(parser_status, "Child templates only may contain blocks");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				}
				phvolt_(phvolt_parser, PHVOLT_SET, NULL, parser_status);
				break;
			case PHVOLT_T_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_ASSIGN, NULL, parser_status);
				break;
			case PHVOLT_T_ADD_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_ADD_ASSIGN, NULL, parser_status);
				break;
			case PHVOLT_T_SUB_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_SUB_ASSIGN, NULL, parser_status);
				break;
			case PHVOLT_T_MUL_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_MUL_ASSIGN, NULL, parser_status);
				break;
			case PHVOLT_T_DIV_ASSIGN:
				phvolt_(phvolt_parser, PHVOLT_DIV_ASSIGN, NULL, parser_status);
				break;

			case PHVOLT_T_INCR:
				phvolt_(phvolt_parser, PHVOLT_INCR, NULL, parser_status);
				break;
			case PHVOLT_T_DECR:
				phvolt_(phvolt_parser, PHVOLT_DECR, NULL, parser_status);
				break;

			case PHVOLT_T_BLOCK:
				if (state->block_level > 0) {
					phvolt_create_error_msg(parser_status, "Embedding blocks into other blocks is not supported");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->block_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_BLOCK, NULL, parser_status);
				break;
			case PHVOLT_T_ENDBLOCK:
				state->block_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDBLOCK, NULL, parser_status);
				break;

			case PHVOLT_T_MACRO:
				if (state->macro_level > 0) {
					phvolt_create_error_msg(parser_status, "Embedding macros into other macros is not allowed");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->macro_level++;
				}
				phvolt_(phvolt_parser, PHVOLT_MACRO, NULL, parser_status);
				break;
			case PHVOLT_T_ENDMACRO:
				state->macro_level--;
				phvolt_(phvolt_parser, PHVOLT_ENDMACRO, NULL, parser_status);
				break;

			case PHVOLT_T_CALL:
				phvolt_(phvolt_parser, PHVOLT_CALL, NULL, parser_status);
				break;
			case PHVOLT_T_ENDCALL:
				phvolt_(phvolt_parser, PHVOLT_ENDCALL, NULL, parser_status);
				break;

			case PHVOLT_T_CACHE:
				phvolt_(phvolt_parser, PHVOLT_CACHE, NULL, parser_status);
				break;
			case PHVOLT_T_ENDCACHE:
				phvolt_(phvolt_parser, PHVOLT_ENDCACHE, NULL, parser_status);
				break;

			case PHVOLT_T_INCLUDE:
				phvolt_(phvolt_parser, PHVOLT_INCLUDE, NULL, parser_status);
				break;

			case PHVOLT_T_WITH:
				phvolt_(phvolt_parser, PHVOLT_WITH, NULL, parser_status);
				break;

			case PHVOLT_T_DEFINED:
				phvolt_(phvolt_parser, PHVOLT_DEFINED, NULL, parser_status);
				break;

			case PHVOLT_T_DO:
				phvolt_(phvolt_parser, PHVOLT_DO, NULL, parser_status);
				break;
			case PHVOLT_T_RETURN:
				phvolt_(phvolt_parser, PHVOLT_RETURN, NULL, parser_status);
				break;

			case PHVOLT_T_AUTOESCAPE:
				phvolt_(phvolt_parser, PHVOLT_AUTOESCAPE, NULL, parser_status);
				break;

			case PHVOLT_T_ENDAUTOESCAPE:
				phvolt_(phvolt_parser, PHVOLT_ENDAUTOESCAPE, NULL, parser_status);
				break;

			case PHVOLT_T_BREAK:
				phvolt_(phvolt_parser, PHVOLT_BREAK, NULL, parser_status);
				break;

			case PHVOLT_T_CONTINUE:
				phvolt_(phvolt_parser, PHVOLT_CONTINUE, NULL, parser_status);
				break;

			case PHVOLT_T_EXTENDS:
				if (state->statement_position != 1) {
					phvolt_create_error_msg(parser_status, "Extends statement must be placed at the first line in the template");
					parser_status->status = PHVOLT_PARSING_FAILED;
					break;
				} else {
					state->extends_mode = 1;
				}
				phvolt_(phvolt_parser, PHVOLT_EXTENDS, NULL, parser_status);
				break;

			default:
				parser_status->status = PHVOLT_PARSING_FAILED;
				if (!*error_msg) {
					error = emalloc(sizeof(char) * (48 + Z_STRLEN_P(state->active_file)));
					snprintf(error, 48 + Z_STRLEN_P(state->active_file) + state->active_line, "Scanner: unknown opcode %d on in %s line %d", token.opcode, Z_STRVAL_P(state->active_file), state->active_line);
					MAKE_STD_ZVAL(*error_msg);
					ZVAL_STRING(*error_msg, error, 1);
					efree(error);
				}
				break;
		}

		if (parser_status->status != PHVOLT_PARSING_OK) {
			status = FAILURE;
			break;
		}

		state->end = state->start;
	}

	if (status != FAILURE) {
		switch (scanner_status) {
			case PHVOLT_SCANNER_RETCODE_ERR:
			case PHVOLT_SCANNER_RETCODE_IMPOSSIBLE:
				if (!*error_msg) {
					phvolt_scanner_error_msg(parser_status, error_msg TSRMLS_CC);
				}
				status = FAILURE;
				break;
			default:
				phvolt_(phvolt_parser, 0, NULL, parser_status);
		}
	}

	state->active_token = 0;
	state->start = NULL;
	efree(state->raw_buffer);

	if (parser_status->status != PHVOLT_PARSING_OK) {
		status = FAILURE;
		if (parser_status->syntax_error) {
			if (!*error_msg) {
				MAKE_STD_ZVAL(*error_msg);
				ZVAL_STRING(*error_msg, parser_status->syntax_error, 1);
			}
			efree(parser_status->syntax_error);
		}
	}

	phvolt_Free(phvolt_parser, phvolt_wrapper_free);

	if (status != FAILURE) {
		if (parser_status->status == PHVOLT_PARSING_OK) {
			if (parser_status->ret) {
				ZVAL_ZVAL(*result, parser_status->ret, 0, 0);
				ZVAL_NULL(parser_status->ret);
				zval_ptr_dtor(&parser_status->ret);
			} else {
				array_init(*result);
			}
		}
	}

	efree(parser_status);
	efree(state);

	return status;
}


/* Generated by re2c 0.13.5 on Sat Jan 11 18:49:23 2014 */
/* #line 1 "scanner.re" */



#define KKCTYPE unsigned char
#define KKCURSOR (s->start)
#define KKLIMIT (s->end)
#define KKMARKER q

static void phvolt_rtrim(phvolt_scanner_token *token) {

	char *cursor, *removed_str;
	int i;
	char ch;

	if (token->len > 0) {

		cursor = token->value;
		cursor += (token->len - 1);
		for (i = token->len; i > 0; i--) {
			ch = (*cursor);
			if (ch == '\t' || ch == '\n' || ch == '\r' || ch == ' ' || ch == '\v') {
				cursor--;
				continue;
			}
			break;
		}

		removed_str = emalloc(i + 1);
		memcpy(removed_str, token->value, i);
		removed_str[i] = '\0';

		efree(token->value);
		token->value = removed_str;
		token->len = i;
	}

}

static void phvolt_ltrim(phvolt_scanner_token *token) {

	char *cursor, *removed_str;
	int i;

	if (token->len > 0) {

		cursor = token->value;
		for (i = 0; i < token->len; i++) {
			char ch = (*cursor);
			if (ch == '\t' || ch == '\n' || ch == '\r' || ch == ' ' || ch == '\v') {
				cursor++;
				continue;
			}
			break;
		}

		removed_str = emalloc(token->len - i + 1);
		memcpy(removed_str, token->value + i, token->len - i);
		removed_str[token->len - i] = '\0';

		efree(token->value);
		token->value = removed_str;
		token->len = token->len - i;
	}

}

static int phvolt_get_token(phvolt_scanner_state *s, phvolt_scanner_token *token) {

	unsigned char next, double_next;
	char *q = KKCURSOR, *start = KKCURSOR;
	int status = PHVOLT_SCANNER_RETCODE_IMPOSSIBLE;

	while (PHVOLT_SCANNER_RETCODE_IMPOSSIBLE == status) {

		if (s->mode == PHVOLT_MODE_RAW || s->mode == PHVOLT_MODE_COMMENT) {

			next = '\0';
			double_next = '\0';

			if (*KKCURSOR == '\n') {
				s->active_line++;
			}

			if (*KKCURSOR != '\0') {
				next = *(KKCURSOR + 1);
				if (next != '\0') {
					double_next = *(KKCURSOR + 2);
				}
			}

			if (*KKCURSOR == '\0' || (*KKCURSOR == '{' && (next == '%' || next == '{' || next == '#'))) {

				if (next != '#') {

					s->mode = PHVOLT_MODE_CODE;

					if (s->raw_buffer_cursor > 0) {

						token->opcode = PHVOLT_T_RAW_FRAGMENT;
						token->value = emalloc(sizeof(char) * s->raw_buffer_cursor + 1);
						memcpy(token->value, s->raw_buffer, s->raw_buffer_cursor);
						token->value[s->raw_buffer_cursor] = 0;
						token->len = s->raw_buffer_cursor;

						if (s->whitespace_control == 1) {
							phvolt_ltrim(token);
							s->whitespace_control = 0;
						}

						if (double_next == '-') {
							phvolt_rtrim(token);
						}

						s->raw_buffer_cursor = 0;
						q = KKCURSOR;
					} else {
						token->opcode = PHVOLT_T_IGNORE;
					}

				} else {

					while ((next = *(++KKCURSOR))) {
						if (next == '#' && *(KKCURSOR + 1) == '}') {
							KKCURSOR+=2;
							token->opcode = PHVOLT_T_IGNORE;
							return 0;
						} else {
							if (next == '\n') {
								s->active_line++;
							}
						}
					}

					return PHVOLT_SCANNER_RETCODE_EOF;
				}

				return 0;

			} else {

				if (s->raw_buffer_cursor == s->raw_buffer_size) {
					s->raw_buffer_size += PHVOLT_RAW_BUFFER_SIZE;
					s->raw_buffer = erealloc(s->raw_buffer, s->raw_buffer_size);
				}

				memcpy(s->raw_buffer+s->raw_buffer_cursor, KKCURSOR, 1);
				s->raw_buffer_cursor++;

				++KKCURSOR;
			}

		} else {

		
/* #line 177 "scanner.c" */
		{
			KKCTYPE kkch;
			unsigned int kkaccept = 0;
			static const unsigned char kkbm[] = {
				  0,  96,  96,  96,  96,  96,  96,  96, 
				 96, 104,  96,  96,  96, 104,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				104,  96,  32,  96,  96,  96,  96,  64, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				240, 240, 240, 240, 240, 240, 240, 240, 
				240, 240,  96,  96,  96,  96,  96,  96, 
				 96, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112,  96,  16,  96,  96, 112, 
				 96, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112, 112, 112, 112, 112, 112, 
				112, 112, 112,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
				 96,  96,  96,  96,  96,  96,  96,  96, 
			};

			kkch = *KKCURSOR;
			switch (kkch) {
			case 0x00:	goto kk70;
			case '\t':
			case '\r':
			case ' ':	goto kk66;
			case '\n':	goto kk68;
			case '!':	goto kk58;
			case '"':	goto kk27;
			case '%':	goto kk21;
			case '\'':	goto kk29;
			case '(':	goto kk44;
			case ')':	goto kk46;
			case '*':	goto kk34;
			case '+':	goto kk32;
			case ',':	goto kk42;
			case '-':	goto kk23;
			case '.':	goto kk40;
			case '/':	goto kk36;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':	goto kk2;
			case ':':	goto kk62;
			case '<':	goto kk52;
			case '=':	goto kk54;
			case '>':	goto kk56;
			case '?':	goto kk64;
			case 'A':
			case 'a':	goto kk11;
			case 'B':
			case 'b':	goto kk13;
			case 'C':
			case 'c':	goto kk15;
			case 'D':
			case 'd':	goto kk18;
			case 'E':
			case 'e':	goto kk6;
			case 'F':
			case 'f':	goto kk7;
			case 'G':
			case 'H':
			case 'J':
			case 'K':
			case 'L':
			case 'P':
			case 'Q':
			case 'U':
			case 'V':
			case 'X':
			case 'Y':
			case 'Z':
			case '_':
			case 'g':
			case 'h':
			case 'j':
			case 'k':
			case 'l':
			case 'p':
			case 'q':
			case 'u':
			case 'v':
			case 'x':
			case 'y':
			case 'z':	goto kk31;
			case 'I':
			case 'i':	goto kk4;
			case 'M':
			case 'm':	goto kk14;
			case 'N':
			case 'n':	goto kk9;
			case 'O':
			case 'o':	goto kk12;
			case 'R':
			case 'r':	goto kk17;
			case 'S':
			case 's':	goto kk8;
			case 'T':
			case 't':	goto kk10;
			case 'W':
			case 'w':	goto kk16;
			case '[':	goto kk48;
			case '\\':	goto kk30;
			case ']':	goto kk50;
			case '{':	goto kk19;
			case '|':	goto kk60;
			case '}':	goto kk25;
			case '~':	goto kk38;
			default:	goto kk72;
			}
kk2:
			kkaccept = 0;
			kkch = *(KKMARKER = ++KKCURSOR);
			goto kk292;
kk3:
/* #line 178 "scanner.re" */
			{
			token->opcode = PHVOLT_T_INTEGER;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
/* #line 325 "scanner.c" */
kk4:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) <= 'S') {
				if (kkch <= 'M') {
					if (kkch == 'F') goto kk278;
					goto kk100;
				} else {
					if (kkch <= 'N') goto kk280;
					if (kkch <= 'R') goto kk100;
					goto kk282;
				}
			} else {
				if (kkch <= 'm') {
					if (kkch == 'f') goto kk278;
					goto kk100;
				} else {
					if (kkch <= 'n') goto kk280;
					if (kkch == 's') goto kk282;
					goto kk100;
				}
			}
kk5:
/* #line 443 "scanner.re" */
			{
			token->opcode = PHVOLT_T_IDENTIFIER;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
/* #line 356 "scanner.c" */
kk6:
			kkch = *++KKCURSOR;
			if (kkch <= 'X') {
				if (kkch <= 'M') {
					if (kkch == 'L') goto kk219;
					goto kk100;
				} else {
					if (kkch <= 'N') goto kk220;
					if (kkch <= 'W') goto kk100;
					goto kk221;
				}
			} else {
				if (kkch <= 'm') {
					if (kkch == 'l') goto kk219;
					goto kk100;
				} else {
					if (kkch <= 'n') goto kk220;
					if (kkch == 'x') goto kk221;
					goto kk100;
				}
			}
kk7:
			kkch = *++KKCURSOR;
			if (kkch <= 'O') {
				if (kkch == 'A') goto kk211;
				if (kkch <= 'N') goto kk100;
				goto kk212;
			} else {
				if (kkch <= 'a') {
					if (kkch <= '`') goto kk100;
					goto kk211;
				} else {
					if (kkch == 'o') goto kk212;
					goto kk100;
				}
			}
kk8:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk208;
			if (kkch == 'e') goto kk208;
			goto kk100;
kk9:
			kkch = *++KKCURSOR;
			if (kkch <= 'U') {
				if (kkch == 'O') goto kk201;
				if (kkch <= 'T') goto kk100;
				goto kk202;
			} else {
				if (kkch <= 'o') {
					if (kkch <= 'n') goto kk100;
					goto kk201;
				} else {
					if (kkch == 'u') goto kk202;
					goto kk100;
				}
			}
kk10:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk197;
			if (kkch == 'r') goto kk197;
			goto kk100;
kk11:
			kkch = *++KKCURSOR;
			if (kkch <= 'U') {
				if (kkch == 'N') goto kk184;
				if (kkch <= 'T') goto kk100;
				goto kk185;
			} else {
				if (kkch <= 'n') {
					if (kkch <= 'm') goto kk100;
					goto kk184;
				} else {
					if (kkch == 'u') goto kk185;
					goto kk100;
				}
			}
kk12:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk182;
			if (kkch == 'r') goto kk182;
			goto kk100;
kk13:
			kkch = *++KKCURSOR;
			if (kkch <= 'R') {
				if (kkch == 'L') goto kk172;
				if (kkch <= 'Q') goto kk100;
				goto kk173;
			} else {
				if (kkch <= 'l') {
					if (kkch <= 'k') goto kk100;
					goto kk172;
				} else {
					if (kkch == 'r') goto kk173;
					goto kk100;
				}
			}
kk14:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk167;
			if (kkch == 'a') goto kk167;
			goto kk100;
kk15:
			kkch = *++KKCURSOR;
			if (kkch <= 'O') {
				if (kkch == 'A') goto kk151;
				if (kkch <= 'N') goto kk100;
				goto kk152;
			} else {
				if (kkch <= 'a') {
					if (kkch <= '`') goto kk100;
					goto kk151;
				} else {
					if (kkch == 'o') goto kk152;
					goto kk100;
				}
			}
kk16:
			kkch = *++KKCURSOR;
			if (kkch == 'I') goto kk147;
			if (kkch == 'i') goto kk147;
			goto kk100;
kk17:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk141;
			if (kkch == 'e') goto kk141;
			goto kk100;
kk18:
			kkch = *++KKCURSOR;
			if (kkch <= 'O') {
				if (kkch == 'E') goto kk132;
				if (kkch <= 'N') goto kk100;
				goto kk133;
			} else {
				if (kkch <= 'e') {
					if (kkch <= 'd') goto kk100;
					goto kk132;
				} else {
					if (kkch == 'o') goto kk133;
					goto kk100;
				}
			}
kk19:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '%') goto kk126;
			if (kkch == '{') goto kk124;
/* #line 526 "scanner.re" */
			{
			token->opcode = PHVOLT_T_CBRACKET_OPEN;
			return 0;
		}
/* #line 507 "scanner.c" */
kk21:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '}') goto kk122;
/* #line 471 "scanner.re" */
			{
			token->opcode = PHVOLT_T_MOD;
			return 0;
		}
/* #line 516 "scanner.c" */
kk23:
			kkaccept = 1;
			kkch = *(KKMARKER = ++KKCURSOR);
			if (kkch <= '-') {
				if (kkch == '%') goto kk117;
				if (kkch >= '-') goto kk114;
			} else {
				if (kkch <= '=') {
					if (kkch >= '=') goto kk112;
				} else {
					if (kkch == '}') goto kk116;
				}
			}
kk24:
/* #line 456 "scanner.re" */
			{
			token->opcode = PHVOLT_T_SUB;
			return 0;
		}
/* #line 536 "scanner.c" */
kk25:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '}') goto kk110;
/* #line 531 "scanner.re" */
			{
			token->opcode = PHVOLT_T_CBRACKET_CLOSE;
			return 0;
		}
/* #line 545 "scanner.c" */
kk27:
			kkaccept = 2;
			kkch = *(KKMARKER = ++KKCURSOR);
			if (kkch >= 0x01) goto kk108;
kk28:
/* #line 642 "scanner.re" */
			{
			status = PHVOLT_SCANNER_RETCODE_ERR;
			break;
		}
/* #line 556 "scanner.c" */
kk29:
			kkaccept = 2;
			kkch = *(KKMARKER = ++KKCURSOR);
			if (kkch <= 0x00) goto kk28;
			goto kk102;
kk30:
			kkch = *++KKCURSOR;
			if (kkch <= '^') {
				if (kkch <= '@') goto kk28;
				if (kkch <= 'Z') goto kk99;
				goto kk28;
			} else {
				if (kkch == '`') goto kk28;
				if (kkch <= 'z') goto kk99;
				goto kk28;
			}
kk31:
			kkch = *++KKCURSOR;
			goto kk100;
kk32:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '+') goto kk97;
			if (kkch == '=') goto kk95;
/* #line 451 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ADD;
			return 0;
		}
/* #line 585 "scanner.c" */
kk34:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk93;
/* #line 461 "scanner.re" */
			{
			token->opcode = PHVOLT_T_MUL;
			return 0;
		}
/* #line 594 "scanner.c" */
kk36:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk91;
/* #line 466 "scanner.re" */
			{
			token->opcode = PHVOLT_T_DIV;
			return 0;
		}
/* #line 603 "scanner.c" */
kk38:
			++KKCURSOR;
/* #line 486 "scanner.re" */
			{
			token->opcode = PHVOLT_T_CONCAT;
			return 0;
		}
/* #line 611 "scanner.c" */
kk40:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '.') goto kk89;
/* #line 496 "scanner.re" */
			{
			token->opcode = PHVOLT_T_DOT;
			return 0;
		}
/* #line 620 "scanner.c" */
kk42:
			++KKCURSOR;
/* #line 501 "scanner.re" */
			{
			token->opcode = PHVOLT_T_COMMA;
			return 0;
		}
/* #line 628 "scanner.c" */
kk44:
			++KKCURSOR;
/* #line 506 "scanner.re" */
			{
			token->opcode = PHVOLT_T_PARENTHESES_OPEN;
			return 0;
		}
/* #line 636 "scanner.c" */
kk46:
			++KKCURSOR;
/* #line 511 "scanner.re" */
			{
			token->opcode = PHVOLT_T_PARENTHESES_CLOSE;
			return 0;
		}
/* #line 644 "scanner.c" */
kk48:
			++KKCURSOR;
/* #line 516 "scanner.re" */
			{
			token->opcode = PHVOLT_T_SBRACKET_OPEN;
			return 0;
		}
/* #line 652 "scanner.c" */
kk50:
			++KKCURSOR;
/* #line 521 "scanner.re" */
			{
			token->opcode = PHVOLT_T_SBRACKET_CLOSE;
			return 0;
		}
/* #line 660 "scanner.c" */
kk52:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) <= '<') goto kk53;
			if (kkch <= '=') goto kk87;
			if (kkch <= '>') goto kk85;
kk53:
/* #line 601 "scanner.re" */
			{
			token->opcode = PHVOLT_T_LESS;
			return 0;
		}
/* #line 672 "scanner.c" */
kk54:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk81;
/* #line 541 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ASSIGN;
			return 0;
		}
/* #line 681 "scanner.c" */
kk56:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk79;
/* #line 606 "scanner.re" */
			{
			token->opcode = PHVOLT_T_GREATER;
			return 0;
		}
/* #line 690 "scanner.c" */
kk58:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk75;
/* #line 596 "scanner.re" */
			{
			token->opcode = PHVOLT_T_NOT;
			return 0;
		}
/* #line 699 "scanner.c" */
kk60:
			++KKCURSOR;
/* #line 611 "scanner.re" */
			{
			token->opcode = PHVOLT_T_PIPE;
			return 0;
		}
/* #line 707 "scanner.c" */
kk62:
			++KKCURSOR;
/* #line 616 "scanner.re" */
			{
			token->opcode = PHVOLT_T_COLON;
			return 0;
		}
/* #line 715 "scanner.c" */
kk64:
			++KKCURSOR;
/* #line 621 "scanner.re" */
			{
			token->opcode = PHVOLT_T_QUESTION;
			return 0;
		}
/* #line 723 "scanner.c" */
kk66:
			++KKCURSOR;
			kkch = *KKCURSOR;
			goto kk74;
kk67:
/* #line 626 "scanner.re" */
			{
			token->opcode = PHVOLT_T_IGNORE;
			return 0;
		}
/* #line 734 "scanner.c" */
kk68:
			++KKCURSOR;
/* #line 631 "scanner.re" */
			{
			s->active_line++;
			token->opcode = PHVOLT_T_IGNORE;
			return 0;
		}
/* #line 743 "scanner.c" */
kk70:
			++KKCURSOR;
/* #line 637 "scanner.re" */
			{
			status = PHVOLT_SCANNER_RETCODE_EOF;
			break;
		}
/* #line 751 "scanner.c" */
kk72:
			kkch = *++KKCURSOR;
			goto kk28;
kk73:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk74:
			if (kkbm[0+kkch] & 8) {
				goto kk73;
			}
			goto kk67;
kk75:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk77;
/* #line 576 "scanner.re" */
			{
			token->opcode = PHVOLT_T_NOTEQUALS;
			return 0;
		}
/* #line 771 "scanner.c" */
kk77:
			++KKCURSOR;
/* #line 591 "scanner.re" */
			{
			token->opcode = PHVOLT_T_NOTIDENTICAL;
			return 0;
		}
/* #line 779 "scanner.c" */
kk79:
			++KKCURSOR;
/* #line 566 "scanner.re" */
			{
			token->opcode = PHVOLT_T_GREATEREQUAL;
			return 0;
		}
/* #line 787 "scanner.c" */
kk81:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '=') goto kk83;
/* #line 571 "scanner.re" */
			{
			token->opcode = PHVOLT_T_EQUALS;
			return 0;
		}
/* #line 796 "scanner.c" */
kk83:
			++KKCURSOR;
/* #line 586 "scanner.re" */
			{
			token->opcode = PHVOLT_T_IDENTICAL;
			return 0;
		}
/* #line 804 "scanner.c" */
kk85:
			++KKCURSOR;
/* #line 581 "scanner.re" */
			{
			token->opcode = PHVOLT_T_NOTEQUALS;
			return 0;
		}
/* #line 812 "scanner.c" */
kk87:
			++KKCURSOR;
/* #line 536 "scanner.re" */
			{
			token->opcode = PHVOLT_T_LESSEQUAL;
			return 0;
		}
/* #line 820 "scanner.c" */
kk89:
			++KKCURSOR;
/* #line 491 "scanner.re" */
			{
			token->opcode = PHVOLT_T_RANGE;
			return 0;
		}
/* #line 828 "scanner.c" */
kk91:
			++KKCURSOR;
/* #line 561 "scanner.re" */
			{
			token->opcode = PHVOLT_T_DIV_ASSIGN;
			return 0;
		}
/* #line 836 "scanner.c" */
kk93:
			++KKCURSOR;
/* #line 556 "scanner.re" */
			{
			token->opcode = PHVOLT_T_MUL_ASSIGN;
			return 0;
		}
/* #line 844 "scanner.c" */
kk95:
			++KKCURSOR;
/* #line 546 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ADD_ASSIGN;
			return 0;
		}
/* #line 852 "scanner.c" */
kk97:
			++KKCURSOR;
/* #line 476 "scanner.re" */
			{
			token->opcode = PHVOLT_T_INCR;
			return 0;
		}
/* #line 860 "scanner.c" */
kk99:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk100:
			if (kkbm[0+kkch] & 16) {
				goto kk99;
			}
			goto kk5;
kk101:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk102:
			if (kkbm[0+kkch] & 32) {
				goto kk101;
			}
			if (kkch <= 0x00) goto kk103;
			if (kkch <= '[') goto kk105;
			goto kk104;
kk103:
			KKCURSOR = KKMARKER;
			if (kkaccept <= 1) {
				if (kkaccept <= 0) {
					goto kk3;
				} else {
					goto kk24;
				}
			} else {
				goto kk28;
			}
kk104:
			++KKCURSOR;
			kkch = *KKCURSOR;
			if (kkch == '\n') goto kk103;
			goto kk101;
kk105:
			++KKCURSOR;
/* #line 434 "scanner.re" */
			{
			token->opcode = PHVOLT_T_STRING;
			token->value = estrndup(q, KKCURSOR - q - 1);
			token->len = KKCURSOR - q - 1;
			q = KKCURSOR;
			return 0;
		}
/* #line 905 "scanner.c" */
kk107:
			++KKCURSOR;
			kkch = *KKCURSOR;
kk108:
			if (kkbm[0+kkch] & 64) {
				goto kk107;
			}
			if (kkch <= 0x00) goto kk103;
			if (kkch <= '[') goto kk105;
			++KKCURSOR;
			kkch = *KKCURSOR;
			if (kkch == '\n') goto kk103;
			goto kk107;
kk110:
			++KKCURSOR;
/* #line 413 "scanner.re" */
			{
			s->mode = PHVOLT_MODE_RAW;
			token->opcode = PHVOLT_T_CLOSE_EDELIMITER;
			return 0;
		}
/* #line 927 "scanner.c" */
kk112:
			++KKCURSOR;
/* #line 551 "scanner.re" */
			{
			token->opcode = PHVOLT_T_SUB_ASSIGN;
			return 0;
		}
/* #line 935 "scanner.c" */
kk114:
			++KKCURSOR;
/* #line 481 "scanner.re" */
			{
			token->opcode = PHVOLT_T_DECR;
			return 0;
		}
/* #line 943 "scanner.c" */
kk116:
			kkch = *++KKCURSOR;
			if (kkch == '}') goto kk120;
			goto kk103;
kk117:
			kkch = *++KKCURSOR;
			if (kkch != '}') goto kk103;
			++KKCURSOR;
/* #line 399 "scanner.re" */
			{
			s->mode = PHVOLT_MODE_RAW;
			s->whitespace_control = 1;
			token->opcode = PHVOLT_T_CLOSE_DELIMITER;
			return 0;
		}
/* #line 959 "scanner.c" */
kk120:
			++KKCURSOR;
/* #line 426 "scanner.re" */
			{
			s->mode = PHVOLT_MODE_RAW;
			s->whitespace_control = 1;
			token->opcode = PHVOLT_T_CLOSE_EDELIMITER;
			return 0;
		}
/* #line 969 "scanner.c" */
kk122:
			++KKCURSOR;
/* #line 387 "scanner.re" */
			{
			s->mode = PHVOLT_MODE_RAW;
			token->opcode = PHVOLT_T_CLOSE_DELIMITER;
			return 0;
		}
/* #line 978 "scanner.c" */
kk124:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '-') goto kk130;
/* #line 406 "scanner.re" */
			{
			s->whitespace_control = 0;
			s->statement_position++;
			token->opcode = PHVOLT_T_OPEN_EDELIMITER;
			return 0;
		}
/* #line 989 "scanner.c" */
kk126:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) == '-') goto kk128;
/* #line 381 "scanner.re" */
			{
			s->whitespace_control = 0;
			token->opcode = PHVOLT_T_OPEN_DELIMITER;
			return 0;
		}
/* #line 999 "scanner.c" */
kk128:
			++KKCURSOR;
/* #line 393 "scanner.re" */
			{
			s->whitespace_control = 0;
			token->opcode = PHVOLT_T_OPEN_DELIMITER;
			return 0;
		}
/* #line 1008 "scanner.c" */
kk130:
			++KKCURSOR;
/* #line 419 "scanner.re" */
			{
			s->whitespace_control = 0;
			s->statement_position++;
			token->opcode = PHVOLT_T_OPEN_EDELIMITER;
			return 0;
		}
/* #line 1018 "scanner.c" */
kk132:
			kkch = *++KKCURSOR;
			if (kkch == 'F') goto kk135;
			if (kkch == 'f') goto kk135;
			goto kk100;
kk133:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 351 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_DO;
			return 0;
		}
/* #line 1035 "scanner.c" */
kk135:
			kkch = *++KKCURSOR;
			if (kkch == 'I') goto kk136;
			if (kkch != 'i') goto kk100;
kk136:
			kkch = *++KKCURSOR;
			if (kkch == 'N') goto kk137;
			if (kkch != 'n') goto kk100;
kk137:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk138;
			if (kkch != 'e') goto kk100;
kk138:
			kkch = *++KKCURSOR;
			if (kkch == 'D') goto kk139;
			if (kkch != 'd') goto kk100;
kk139:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 328 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_DEFINED;
			return 0;
		}
/* #line 1063 "scanner.c" */
kk141:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk142;
			if (kkch != 't') goto kk100;
kk142:
			kkch = *++KKCURSOR;
			if (kkch == 'U') goto kk143;
			if (kkch != 'u') goto kk100;
kk143:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk144;
			if (kkch != 'r') goto kk100;
kk144:
			kkch = *++KKCURSOR;
			if (kkch == 'N') goto kk145;
			if (kkch != 'n') goto kk100;
kk145:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 305 "scanner.re" */
			{
			token->opcode = PHVOLT_T_RETURN;
			return 0;
		}
/* #line 1090 "scanner.c" */
kk147:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk148;
			if (kkch != 't') goto kk100;
kk148:
			kkch = *++KKCURSOR;
			if (kkch == 'H') goto kk149;
			if (kkch != 'h') goto kk100;
kk149:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 300 "scanner.re" */
			{
			token->opcode = PHVOLT_T_WITH;
			return 0;
		}
/* #line 1109 "scanner.c" */
kk151:
			kkch = *++KKCURSOR;
			if (kkch <= 'L') {
				if (kkch == 'C') goto kk161;
				if (kkch <= 'K') goto kk100;
				goto kk160;
			} else {
				if (kkch <= 'c') {
					if (kkch <= 'b') goto kk100;
					goto kk161;
				} else {
					if (kkch == 'l') goto kk160;
					goto kk100;
				}
			}
kk152:
			kkch = *++KKCURSOR;
			if (kkch == 'N') goto kk153;
			if (kkch != 'n') goto kk100;
kk153:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk154;
			if (kkch != 't') goto kk100;
kk154:
			kkch = *++KKCURSOR;
			if (kkch == 'I') goto kk155;
			if (kkch != 'i') goto kk100;
kk155:
			kkch = *++KKCURSOR;
			if (kkch == 'N') goto kk156;
			if (kkch != 'n') goto kk100;
kk156:
			kkch = *++KKCURSOR;
			if (kkch == 'U') goto kk157;
			if (kkch != 'u') goto kk100;
kk157:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk158;
			if (kkch != 'e') goto kk100;
kk158:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 369 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_CONTINUE;
			return 0;
		}
/* #line 1160 "scanner.c" */
kk160:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk165;
			if (kkch == 'l') goto kk165;
			goto kk100;
kk161:
			kkch = *++KKCURSOR;
			if (kkch == 'H') goto kk162;
			if (kkch != 'h') goto kk100;
kk162:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk163;
			if (kkch != 'e') goto kk100;
kk163:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 340 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_CACHE;
			return 0;
		}
/* #line 1185 "scanner.c" */
kk165:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 289 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_CALL;
			return 0;
		}
/* #line 1197 "scanner.c" */
kk167:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk168;
			if (kkch != 'c') goto kk100;
kk168:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk169;
			if (kkch != 'r') goto kk100;
kk169:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk170;
			if (kkch != 'o') goto kk100;
kk170:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 278 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_MACRO;
			return 0;
		}
/* #line 1221 "scanner.c" */
kk172:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk178;
			if (kkch == 'o') goto kk178;
			goto kk100;
kk173:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk174;
			if (kkch != 'e') goto kk100;
kk174:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk175;
			if (kkch != 'a') goto kk100;
kk175:
			kkch = *++KKCURSOR;
			if (kkch == 'K') goto kk176;
			if (kkch != 'k') goto kk100;
kk176:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 375 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_BREAK;
			return 0;
		}
/* #line 1250 "scanner.c" */
kk178:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk179;
			if (kkch != 'c') goto kk100;
kk179:
			kkch = *++KKCURSOR;
			if (kkch == 'K') goto kk180;
			if (kkch != 'k') goto kk100;
kk180:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 267 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_BLOCK;
			return 0;
		}
/* #line 1270 "scanner.c" */
kk182:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 262 "scanner.re" */
			{
			token->opcode = PHVOLT_T_OR;
			return 0;
		}
/* #line 1281 "scanner.c" */
kk184:
			kkch = *++KKCURSOR;
			if (kkch == 'D') goto kk195;
			if (kkch == 'd') goto kk195;
			goto kk100;
kk185:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk186;
			if (kkch != 't') goto kk100;
kk186:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk187;
			if (kkch != 'o') goto kk100;
kk187:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk188;
			if (kkch != 'e') goto kk100;
kk188:
			kkch = *++KKCURSOR;
			if (kkch == 'S') goto kk189;
			if (kkch != 's') goto kk100;
kk189:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk190;
			if (kkch != 'c') goto kk100;
kk190:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk191;
			if (kkch != 'a') goto kk100;
kk191:
			kkch = *++KKCURSOR;
			if (kkch == 'P') goto kk192;
			if (kkch != 'p') goto kk100;
kk192:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk193;
			if (kkch != 'e') goto kk100;
kk193:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 357 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_AUTOESCAPE;
			return 0;
		}
/* #line 1330 "scanner.c" */
kk195:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 257 "scanner.re" */
			{
			token->opcode = PHVOLT_T_AND;
			return 0;
		}
/* #line 1341 "scanner.c" */
kk197:
			kkch = *++KKCURSOR;
			if (kkch == 'U') goto kk198;
			if (kkch != 'u') goto kk100;
kk198:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk199;
			if (kkch != 'e') goto kk100;
kk199:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 252 "scanner.re" */
			{
			token->opcode = PHVOLT_T_TRUE;
			return 0;
		}
/* #line 1360 "scanner.c" */
kk201:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk206;
			if (kkch == 't') goto kk206;
			goto kk100;
kk202:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk203;
			if (kkch != 'l') goto kk100;
kk203:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk204;
			if (kkch != 'l') goto kk100;
kk204:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 242 "scanner.re" */
			{
			token->opcode = PHVOLT_T_NULL;
			return 0;
		}
/* #line 1384 "scanner.c" */
kk206:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 322 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_NOT;
			return 0;
		}
/* #line 1396 "scanner.c" */
kk208:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk209;
			if (kkch != 't') goto kk100;
kk209:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 237 "scanner.re" */
			{
			token->opcode = PHVOLT_T_SET;
			return 0;
		}
/* #line 1411 "scanner.c" */
kk211:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk215;
			if (kkch == 'l') goto kk215;
			goto kk100;
kk212:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk213;
			if (kkch != 'r') goto kk100;
kk213:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 221 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_FOR;
			return 0;
		}
/* #line 1432 "scanner.c" */
kk215:
			kkch = *++KKCURSOR;
			if (kkch == 'S') goto kk216;
			if (kkch != 's') goto kk100;
kk216:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk217;
			if (kkch != 'e') goto kk100;
kk217:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 247 "scanner.re" */
			{
			token->opcode = PHVOLT_T_FALSE;
			return 0;
		}
/* #line 1451 "scanner.c" */
kk219:
			kkch = *++KKCURSOR;
			if (kkch == 'S') goto kk268;
			if (kkch == 's') goto kk268;
			goto kk100;
kk220:
			kkch = *++KKCURSOR;
			if (kkch == 'D') goto kk228;
			if (kkch == 'd') goto kk228;
			goto kk100;
kk221:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk222;
			if (kkch != 't') goto kk100;
kk222:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk223;
			if (kkch != 'e') goto kk100;
kk223:
			kkch = *++KKCURSOR;
			if (kkch == 'N') goto kk224;
			if (kkch != 'n') goto kk100;
kk224:
			kkch = *++KKCURSOR;
			if (kkch == 'D') goto kk225;
			if (kkch != 'd') goto kk100;
kk225:
			kkch = *++KKCURSOR;
			if (kkch == 'S') goto kk226;
			if (kkch != 's') goto kk100;
kk226:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 310 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_EXTENDS;
			return 0;
		}
/* #line 1493 "scanner.c" */
kk228:
			kkch = *++KKCURSOR;
			switch (kkch) {
			case 'A':
			case 'a':	goto kk229;
			case 'B':
			case 'b':	goto kk230;
			case 'C':
			case 'c':	goto kk231;
			case 'F':
			case 'f':	goto kk232;
			case 'I':
			case 'i':	goto kk233;
			case 'M':
			case 'm':	goto kk234;
			default:	goto kk100;
			}
kk229:
			kkch = *++KKCURSOR;
			if (kkch == 'U') goto kk258;
			if (kkch == 'u') goto kk258;
			goto kk100;
kk230:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk253;
			if (kkch == 'l') goto kk253;
			goto kk100;
kk231:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk245;
			if (kkch == 'a') goto kk245;
			goto kk100;
kk232:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk242;
			if (kkch == 'o') goto kk242;
			goto kk100;
kk233:
			kkch = *++KKCURSOR;
			if (kkch == 'F') goto kk240;
			if (kkch == 'f') goto kk240;
			goto kk100;
kk234:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk235;
			if (kkch != 'a') goto kk100;
kk235:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk236;
			if (kkch != 'c') goto kk100;
kk236:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk237;
			if (kkch != 'r') goto kk100;
kk237:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk238;
			if (kkch != 'o') goto kk100;
kk238:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 284 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDMACRO;
			return 0;
		}
/* #line 1562 "scanner.c" */
kk240:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 216 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDIF;
			return 0;
		}
/* #line 1573 "scanner.c" */
kk242:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk243;
			if (kkch != 'r') goto kk100;
kk243:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 227 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDFOR;
			return 0;
		}
/* #line 1588 "scanner.c" */
kk245:
			kkch = *++KKCURSOR;
			if (kkch <= 'L') {
				if (kkch == 'C') goto kk246;
				if (kkch <= 'K') goto kk100;
				goto kk247;
			} else {
				if (kkch <= 'c') {
					if (kkch <= 'b') goto kk100;
				} else {
					if (kkch == 'l') goto kk247;
					goto kk100;
				}
			}
kk246:
			kkch = *++KKCURSOR;
			if (kkch == 'H') goto kk250;
			if (kkch == 'h') goto kk250;
			goto kk100;
kk247:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk248;
			if (kkch != 'l') goto kk100;
kk248:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 295 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDCALL;
			return 0;
		}
/* #line 1622 "scanner.c" */
kk250:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk251;
			if (kkch != 'e') goto kk100;
kk251:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 346 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDCACHE;
			return 0;
		}
/* #line 1637 "scanner.c" */
kk253:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk254;
			if (kkch != 'o') goto kk100;
kk254:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk255;
			if (kkch != 'c') goto kk100;
kk255:
			kkch = *++KKCURSOR;
			if (kkch == 'K') goto kk256;
			if (kkch != 'k') goto kk100;
kk256:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 273 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ENDBLOCK;
			return 0;
		}
/* #line 1660 "scanner.c" */
kk258:
			kkch = *++KKCURSOR;
			if (kkch == 'T') goto kk259;
			if (kkch != 't') goto kk100;
kk259:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk260;
			if (kkch != 'o') goto kk100;
kk260:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk261;
			if (kkch != 'e') goto kk100;
kk261:
			kkch = *++KKCURSOR;
			if (kkch == 'S') goto kk262;
			if (kkch != 's') goto kk100;
kk262:
			kkch = *++KKCURSOR;
			if (kkch == 'C') goto kk263;
			if (kkch != 'c') goto kk100;
kk263:
			kkch = *++KKCURSOR;
			if (kkch == 'A') goto kk264;
			if (kkch != 'a') goto kk100;
kk264:
			kkch = *++KKCURSOR;
			if (kkch == 'P') goto kk265;
			if (kkch != 'p') goto kk100;
kk265:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk266;
			if (kkch != 'e') goto kk100;
kk266:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 363 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_ENDAUTOESCAPE;
			return 0;
		}
/* #line 1704 "scanner.c" */
kk268:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk269;
			if (kkch != 'e') goto kk100;
kk269:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) <= '[') {
				if (kkch <= 'E') {
					if (kkch <= '/') goto kk270;
					if (kkch <= '9') goto kk99;
					if (kkch >= 'A') goto kk99;
				} else {
					if (kkch <= 'H') {
						if (kkch <= 'F') goto kk271;
						goto kk99;
					} else {
						if (kkch <= 'I') goto kk272;
						if (kkch <= 'Z') goto kk99;
					}
				}
			} else {
				if (kkch <= 'e') {
					if (kkch <= '^') {
						if (kkch <= '\\') goto kk99;
					} else {
						if (kkch != '`') goto kk99;
					}
				} else {
					if (kkch <= 'h') {
						if (kkch <= 'f') goto kk271;
						goto kk99;
					} else {
						if (kkch <= 'i') goto kk272;
						if (kkch <= 'z') goto kk99;
					}
				}
			}
kk270:
/* #line 201 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ELSE;
			return 0;
		}
/* #line 1748 "scanner.c" */
kk271:
			kkch = *++KKCURSOR;
			if (kkch == 'O') goto kk275;
			if (kkch == 'o') goto kk275;
			goto kk100;
kk272:
			kkch = *++KKCURSOR;
			if (kkch == 'F') goto kk273;
			if (kkch != 'f') goto kk100;
kk273:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 211 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ELSEIF;
			return 0;
		}
/* #line 1768 "scanner.c" */
kk275:
			kkch = *++KKCURSOR;
			if (kkch == 'R') goto kk276;
			if (kkch != 'r') goto kk100;
kk276:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 206 "scanner.re" */
			{
			token->opcode = PHVOLT_T_ELSEFOR;
			return 0;
		}
/* #line 1783 "scanner.c" */
kk278:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 195 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_IF;
			return 0;
		}
/* #line 1795 "scanner.c" */
kk280:
			++KKCURSOR;
			if ((kkch = *KKCURSOR) <= '[') {
				if (kkch <= '@') {
					if (kkch <= '/') goto kk281;
					if (kkch <= '9') goto kk99;
				} else {
					if (kkch == 'C') goto kk284;
					if (kkch <= 'Z') goto kk99;
				}
			} else {
				if (kkch <= '`') {
					if (kkch <= '\\') goto kk99;
					if (kkch == '_') goto kk99;
				} else {
					if (kkch == 'c') goto kk284;
					if (kkch <= 'z') goto kk99;
				}
			}
kk281:
/* #line 232 "scanner.re" */
			{
			token->opcode = PHVOLT_T_IN;
			return 0;
		}
/* #line 1821 "scanner.c" */
kk282:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 316 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_IS;
			return 0;
		}
/* #line 1833 "scanner.c" */
kk284:
			kkch = *++KKCURSOR;
			if (kkch == 'L') goto kk285;
			if (kkch != 'l') goto kk100;
kk285:
			kkch = *++KKCURSOR;
			if (kkch == 'U') goto kk286;
			if (kkch != 'u') goto kk100;
kk286:
			kkch = *++KKCURSOR;
			if (kkch == 'D') goto kk287;
			if (kkch != 'd') goto kk100;
kk287:
			kkch = *++KKCURSOR;
			if (kkch == 'E') goto kk288;
			if (kkch != 'e') goto kk100;
kk288:
			++KKCURSOR;
			if (kkbm[0+(kkch = *KKCURSOR)] & 16) {
				goto kk99;
			}
/* #line 334 "scanner.re" */
			{
			s->statement_position++;
			token->opcode = PHVOLT_T_INCLUDE;
			return 0;
		}
/* #line 1861 "scanner.c" */
kk290:
			kkch = *++KKCURSOR;
			if (kkch <= '/') goto kk103;
			if (kkch <= '9') goto kk293;
			goto kk103;
kk291:
			kkaccept = 0;
			KKMARKER = ++KKCURSOR;
			kkch = *KKCURSOR;
kk292:
			if (kkbm[0+kkch] & 128) {
				goto kk291;
			}
			if (kkch == '.') goto kk290;
			goto kk3;
kk293:
			++KKCURSOR;
			kkch = *KKCURSOR;
			if (kkch <= '/') goto kk295;
			if (kkch <= '9') goto kk293;
kk295:
/* #line 187 "scanner.re" */
			{
			token->opcode = PHVOLT_T_DOUBLE;
			token->value = estrndup(start, KKCURSOR - start);
			token->len = KKCURSOR - start;
			q = KKCURSOR;
			return 0;
		}
/* #line 1891 "scanner.c" */
		}
/* #line 647 "scanner.re" */


		}
	}

	return status;
}





zend_class_entry *phalcon_paginator_adapterinterface_ce;

static const zend_function_entry phalcon_paginator_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Paginator_AdapterInterface, setCurrentPage, arginfo_phalcon_paginator_adapterinterface_setcurrentpage)
	PHP_ABSTRACT_ME(Phalcon_Paginator_AdapterInterface, getPaginate, arginfo_phalcon_paginator_adapterinterface_getpaginate)
	PHP_FE_END
};


PHALCON_INIT_CLASS(Phalcon_Paginator_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Paginator, AdapterInterface, paginator_adapterinterface, phalcon_paginator_adapterinterface_method_entry);

	return SUCCESS;
}








zend_class_entry *phalcon_paginator_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Paginator_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Paginator, Exception, paginator_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





#include <math.h>


zend_class_entry *phalcon_paginator_adapter_model_ce;

static PHP_METHOD(Phalcon_Paginator_Adapter_Model, __construct);
static PHP_METHOD(Phalcon_Paginator_Adapter_Model, setCurrentPage);
static PHP_METHOD(Phalcon_Paginator_Adapter_Model, getPaginate);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_paginator_adapter_model___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, config)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_paginator_adapter_model_method_entry[] = {
	PHP_ME(Phalcon_Paginator_Adapter_Model, __construct, arginfo_phalcon_paginator_adapter_model___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Paginator_Adapter_Model, setCurrentPage, arginfo_phalcon_paginator_adapterinterface_setcurrentpage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_Model, getPaginate, arginfo_phalcon_paginator_adapterinterface_getpaginate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Paginator_Adapter_Model){

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, Model, paginator_adapter_model, phalcon_paginator_adapter_model_method_entry, 0);

	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_config"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_model_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_paginator_adapter_model_ce TSRMLS_CC, 1, phalcon_paginator_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Paginator_Adapter_Model, __construct){

	zval *config, *limit, *page;

	phalcon_fetch_params(0, 1, 0, &config);
	
	phalcon_update_property_this_quick(this_ptr, SL("_config"), config, 4157843450UL TSRMLS_CC);
	if (phalcon_array_isset_string_fetch(&limit, config, SS("limit"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_limitRows"), limit, 597448366UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&page, config, SS("page"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_page"), page, 3986343137UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Paginator_Adapter_Model, setCurrentPage){

	zval *page;

	phalcon_fetch_params(0, 1, 0, &page);
	
	phalcon_update_property_this_quick(this_ptr, SL("_page"), page, 3986343137UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Paginator_Adapter_Model, getPaginate){

	zval *z_one, *z_zero, *show, *config, *items, *page_number = NULL;
	zval *rowcount, *page, *last_show_page, *start;
	zval *possible_pages = NULL, *total_pages, *page_items;
	zval *valid = NULL, *current = NULL, *maximum_pages, *next = NULL, *additional_page;
	zval *before = NULL, *remainder, *pages_total = NULL;
	long int i, i_show;

	PHALCON_MM_GROW();

	z_one  = PHALCON_GLOBAL(z_one);
	z_zero = PHALCON_GLOBAL(z_zero);
	
	show        = phalcon_fetch_nproperty_this(this_ptr, SL("_limitRows"), PH_NOISY TSRMLS_CC);
	config      = phalcon_fetch_nproperty_this(this_ptr, SL("_config"), PH_NOISY TSRMLS_CC);
	
	PHALCON_OBS_VAR(page_number);
	phalcon_read_property_this(&page_number, this_ptr, SL("_page"), PH_NOISY TSRMLS_CC);

	i_show = (Z_TYPE_P(show) == IS_LONG) ? Z_LVAL_P(show) : phalcon_get_intval(show);

	PHALCON_OBS_VAR(items);
	phalcon_array_fetch_quick_string(&items, config, SS("data"), 256359743UL, PH_NOISY);
	
	if (Z_TYPE_P(page_number) == IS_NULL || PHALCON_LT(show, z_zero)) {
		PHALCON_CPY_WRT_CTOR(page_number, z_one);
	}
	
	PHALCON_INIT_VAR(rowcount);
	phalcon_fast_count(rowcount, items TSRMLS_CC);

	PHALCON_INIT_VAR(page);
	object_init(page);
	
	PHALCON_INIT_VAR(last_show_page);
	sub_function(last_show_page, page_number, z_one TSRMLS_CC);
	
	PHALCON_INIT_VAR(start);
	mul_function(start, show, last_show_page TSRMLS_CC);
	
	PHALCON_INIT_VAR(possible_pages);
	div_function(possible_pages, rowcount, show TSRMLS_CC);
	if (unlikely(Z_TYPE_P(possible_pages)) != IS_DOUBLE) {
		convert_to_double(possible_pages);
	}
	
	PHALCON_INIT_VAR(total_pages);
	ZVAL_LONG(total_pages, (long int)ceil(Z_DVAL_P(possible_pages)));
	if (Z_TYPE_P(items) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}
	
	PHALCON_INIT_VAR(page_items);
	array_init(page_items);
	if (PHALCON_GT(rowcount, z_zero)) {
	
		if (PHALCON_LT(start, rowcount)) {
			PHALCON_CALL_METHOD(NULL, items, "seek", start);
		} else {
			PHALCON_CALL_METHOD(NULL, items, "rewind");
			PHALCON_CPY_WRT_CTOR(page_number, z_one);
			PHALCON_CPY_WRT_CTOR(start, z_zero);
		}
	
		for (i=1; ; ++i) {
			PHALCON_CALL_METHOD(&valid, items, "valid");
			if (!PHALCON_IS_NOT_FALSE(valid)) {
				break;
			}
	
			PHALCON_CALL_METHOD(&current, items, "current");
			phalcon_array_append(&page_items, current, 0);

			if (i >= i_show) {
				break;
			}
		}
	}
	
	phalcon_update_property_zval(page, SL("items"), page_items TSRMLS_CC);
	
	PHALCON_INIT_VAR(maximum_pages);
	phalcon_add_function(maximum_pages, start, show TSRMLS_CC);
	if (PHALCON_LT(maximum_pages, rowcount)) {
		PHALCON_INIT_VAR(next);
		phalcon_add_function(next, page_number, z_one TSRMLS_CC);
	} else if (PHALCON_IS_EQUAL(maximum_pages, rowcount)) {
			PHALCON_CPY_WRT(next, rowcount);
	} else {
		div_function(possible_pages, rowcount, show TSRMLS_CC);

		PHALCON_INIT_VAR(additional_page);
		phalcon_add_function(additional_page, possible_pages, z_one TSRMLS_CC);

		PHALCON_INIT_NVAR(next);
		ZVAL_LONG(next, phalcon_get_intval(additional_page));
	}
	
	if (PHALCON_GT(next, total_pages)) {
		PHALCON_CPY_WRT(next, total_pages);
	}
	
	phalcon_update_property_zval(page, SL("next"), next TSRMLS_CC);
	if (PHALCON_GT(page_number, z_one)) {
		PHALCON_INIT_VAR(before);
		sub_function(before, page_number, z_one TSRMLS_CC);
	} else {
		PHALCON_CPY_WRT_CTOR(before, z_one);
	}
	
	phalcon_update_property_zval(page, SL("first"), z_one TSRMLS_CC);
	phalcon_update_property_zval(page, SL("before"), before TSRMLS_CC);
	phalcon_update_property_zval(page, SL("current"), page_number TSRMLS_CC);
	
	PHALCON_INIT_VAR(remainder);
	mod_function(remainder, rowcount, show TSRMLS_CC);
	
	PHALCON_INIT_NVAR(possible_pages);
	div_function(possible_pages, rowcount, show TSRMLS_CC);
	if (!PHALCON_IS_LONG(remainder, 0)) {
		PHALCON_INIT_NVAR(next);
		phalcon_add_function(next, possible_pages, z_one TSRMLS_CC);
	
		PHALCON_INIT_VAR(pages_total);
		ZVAL_LONG(pages_total, phalcon_get_intval(next));
	} else {
		PHALCON_CPY_WRT(pages_total, possible_pages);
	}
	
	phalcon_update_property_zval(page, SL("last"), pages_total TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_pages"), pages_total TSRMLS_CC);
	phalcon_update_property_zval(page, SL("total_items"), rowcount TSRMLS_CC);
	
	RETURN_CTOR(page);
}






zend_class_entry *phalcon_paginator_adapter_nativearray_ce;

static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, __construct);
static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, setCurrentPage);
static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, getPaginate);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_paginator_adapter_nativearray___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, config)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_paginator_adapter_nativearray_method_entry[] = {
	PHP_ME(Phalcon_Paginator_Adapter_NativeArray, __construct, arginfo_phalcon_paginator_adapter_nativearray___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Paginator_Adapter_NativeArray, setCurrentPage, arginfo_phalcon_paginator_adapterinterface_setcurrentpage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_NativeArray, getPaginate, arginfo_phalcon_paginator_adapterinterface_getpaginate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Paginator_Adapter_NativeArray){

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, NativeArray, paginator_adapter_nativearray, phalcon_paginator_adapter_nativearray_method_entry, 0);

	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_nativearray_ce, SL("_page"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_paginator_adapter_nativearray_ce TSRMLS_CC, 1, phalcon_paginator_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, __construct){

	zval *config, *limit, *page, *data;

	phalcon_fetch_params(0, 1, 0, &config);
	
	if (phalcon_array_isset_string_fetch(&limit, config, SS("limit"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_limitRows"), limit, 597448366UL TSRMLS_CC);
	}
	
	if (phalcon_array_isset_string_fetch(&page, config, SS("page"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_page"), page, 3986343137UL TSRMLS_CC);
	}

	if (!phalcon_array_isset_string_fetch(&data, config, SS("data"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "Parameter 'data' is required");
		return;
	}

	if (Z_TYPE_P(data) != IS_ARRAY) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "'data' should be an array");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_data"), data, 3972126110UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, setCurrentPage){

	zval **current_page;

	phalcon_fetch_params_ex(1, 0, &current_page);
	PHALCON_ENSURE_IS_LONG(current_page);
	
	phalcon_update_property_this(this_ptr, SL("_page"), *current_page TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Paginator_Adapter_NativeArray, getPaginate){

	zval *items, *limit, *number_page, *lim;
	zval *start, *slice = NULL;
	zval *params[3];
	long int i_limit, i_number_page, i_number, i_before, i_rowcount;
	long int i_total_pages, i_next;
	ldiv_t tp;

	items = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (UNEXPECTED(Z_TYPE_P(items) != IS_ARRAY)) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "Invalid data for paginator");
		return;
	}

	limit         = phalcon_fetch_nproperty_this(this_ptr, SL("_limitRows"), PH_NOISY TSRMLS_CC);
	number_page   = phalcon_fetch_nproperty_this(this_ptr, SL("_page"), PH_NOISY TSRMLS_CC);
	i_limit       = phalcon_get_intval(limit);
	i_number_page = phalcon_get_intval(number_page);

	if (i_limit < 1) {
		/* This should never happen unless someone deliberately modified the properties of the object */
		i_limit = 10;
	}

	if (!i_number_page) {
		i_number_page = 1;
	}

	i_number      = (i_number_page - 1) * i_limit;
	i_before      = (i_number_page == 1) ? 1 : (i_number_page - 1);
	i_rowcount    = zend_hash_num_elements(Z_ARRVAL_P(items));
	tp            = ldiv(i_rowcount, i_limit);
	i_total_pages = tp.quot + (tp.rem ? 1 : 0);
	i_next        = (i_number_page < i_total_pages) ? (i_number_page + 1) : i_total_pages;

	PHALCON_ALLOC_GHOST_ZVAL(start);
	PHALCON_ALLOC_GHOST_ZVAL(lim);
	ZVAL_LONG(start, i_number);
	ZVAL_LONG(lim, i_limit);

	params[0] = items;
	params[1] = start;
	params[2] = lim;
	RETURN_ON_FAILURE(phalcon_call_func_aparams(&slice, SL("array_slice"), 3, params TSRMLS_CC));

	Z_DELREF_P(slice);
	
	object_init(return_value);
	phalcon_update_property_zval(return_value, SL("items"),       slice TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("before"),      i_before TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("first"),       1 TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("next"),        i_next TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("last"),        i_total_pages TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("current"),     i_number_page TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("total_pages"), i_total_pages TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("total_items"), i_rowcount TSRMLS_CC);
}







zend_class_entry *phalcon_paginator_adapter_querybuilder_ce;

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, __construct);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getPaginate);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setCurrentPage);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getCurrentPage);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setLimit);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getLimit);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setQueryBuilder);
static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getQueryBuilder);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_paginator_adapter_querybuilder___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, config)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_paginator_adapter_querybuilder_setlimit, 0, 0, 1)
	ZEND_ARG_INFO(0, limit)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_paginator_adapter_querybuilder_setquerybuilder, 0, 0, 1)
	ZEND_ARG_INFO(0, queryBuilder)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_paginator_adapter_querybuilder_method_entry[] = {
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, __construct, arginfo_phalcon_paginator_adapter_querybuilder___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, getPaginate, arginfo_phalcon_paginator_adapterinterface_getpaginate, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, setLimit, arginfo_phalcon_paginator_adapter_querybuilder_setlimit, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, getLimit, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, setCurrentPage, arginfo_phalcon_paginator_adapterinterface_setcurrentpage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, getCurrentPage, arginfo_phalcon_paginator_adapterinterface_getcurrentpage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, setQueryBuilder, arginfo_phalcon_paginator_adapter_querybuilder_setquerybuilder, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Paginator_Adapter_QueryBuilder, getQueryBuilder, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Paginator_Adapter_QueryBuilder){

	PHALCON_REGISTER_CLASS(Phalcon\\Paginator\\Adapter, QueryBuilder, paginator_adapter_querybuilder, phalcon_paginator_adapter_querybuilder_method_entry, 0);

	zend_declare_property_null(phalcon_paginator_adapter_querybuilder_ce, SL("_builder"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_paginator_adapter_querybuilder_ce, SL("_limitRows"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_paginator_adapter_querybuilder_ce, SL("_page"), 1, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_paginator_adapter_querybuilder_ce TSRMLS_CC, 1, phalcon_paginator_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, __construct){

	zval *config, *builder, *limit, *page;
	long int i_limit;

	phalcon_fetch_params(0, 1, 0, &config);
	
	if (!phalcon_array_isset_string_fetch(&builder, config, SS("builder"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "Parameter 'builder' is required");
		return;
	}
	
	PHALCON_VERIFY_INTERFACE_EX(builder, phalcon_mvc_model_query_builderinterface_ce, phalcon_paginator_exception_ce, 0);

	phalcon_update_property_this_quick(this_ptr, SL("_builder"), builder, 3366211339UL TSRMLS_CC);

	if (!phalcon_array_isset_string_fetch(&limit, config, SS("limit"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "Parameter 'limit' is required");
		return;
	}

	i_limit = phalcon_get_intval(limit);
	if (i_limit < 1) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_paginator_exception_ce, "'limit' should be positive");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_limitRows"), limit, 597448366UL TSRMLS_CC);
	
	if (phalcon_array_isset_string_fetch(&page, config, SS("page"))) {
		phalcon_update_property_this_quick(this_ptr, SL("_page"), page, 3986343137UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setCurrentPage){

	zval **current_page;

	phalcon_fetch_params_ex(1, 0, &current_page);
	PHALCON_ENSURE_IS_LONG(current_page);
	
	phalcon_update_property_this(this_ptr, SL("_page"), *current_page TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getCurrentPage){

	RETURN_MEMBER_QUICK(this_ptr, "_page", 3986343137UL);
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setLimit){

	zval **current_limit;

	phalcon_fetch_params_ex(1, 0, &current_limit);
	PHALCON_ENSURE_IS_LONG(current_limit);

	phalcon_update_property_this(this_ptr, SL("_limitRows"), *current_limit TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getLimit){

	RETURN_MEMBER_QUICK(this_ptr, "_limitRows", 597448366UL);
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, setQueryBuilder){

	zval *query_builder;

	phalcon_fetch_params(0, 1, 0, &query_builder);
	PHALCON_VERIFY_INTERFACE_EX(query_builder, phalcon_mvc_model_query_builderinterface_ce, phalcon_paginator_exception_ce, 0);

	phalcon_update_property_this_quick(this_ptr, SL("_builder"), query_builder, 3366211339UL TSRMLS_CC);

	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getQueryBuilder){

	RETURN_MEMBER_QUICK(this_ptr, "_builder", 3366211339UL);
}

static PHP_METHOD(Phalcon_Paginator_Adapter_QueryBuilder, getPaginate){

	zval *original_builder, *builder, *total_builder;
	zval *limit, *number_page;
	zval *query = NULL, *items = NULL;
	zval *total_query = NULL, *result = NULL, *row = NULL, *rowcount;
	zval *dependency_injector = NULL, *service_name, *models_manager = NULL;
	zval *models = NULL, *model_name = NULL, *model = NULL, *connection = NULL;
	zval *bind_params = NULL, *bind_types = NULL, *processed = NULL;
	zval *value = NULL, *wildcard = NULL, *string_wildcard = NULL, *processed_types = NULL;
	zval *intermediate = NULL, *tables, *table, *table_name = NULL, *select_column, *dialect = NULL, *sql_select = NULL, *sql;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;
	long int i_limit, i_number_page, i_number, i_before, i_rowcount;
	long int i_total_pages, i_next;
	ldiv_t tp;

	PHALCON_MM_GROW();

	original_builder = phalcon_fetch_nproperty_this(this_ptr, SL("_builder"), PH_NOISY TSRMLS_CC);
	
	/* Make a copy of the original builder to leave it as it is */
	PHALCON_INIT_VAR(builder);
	if (phalcon_clone(builder, original_builder TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	/* make a copy of the original builder to count the total of records */
	PHALCON_INIT_VAR(total_builder);
	if (phalcon_clone(total_builder, builder TSRMLS_CC) == FAILURE) {
		RETURN_MM();
	}
	
	limit         = phalcon_fetch_nproperty_this(this_ptr, SL("_limitRows"), PH_NOISY TSRMLS_CC);
	number_page   = phalcon_fetch_nproperty_this(this_ptr, SL("_page"), PH_NOISY TSRMLS_CC);
	i_limit       = phalcon_get_intval(limit);
	i_number_page = phalcon_get_intval(number_page);

	if (i_limit < 1) {
		/* This should never happen unless someone deliberately modified the properties of the object */
		i_limit = 10;
	}

	if (!i_number_page) {
		i_number_page = 1;
	}

	i_number = (i_number_page - 1) * i_limit;
	i_before = (i_number_page == 1) ? 1 : (i_number_page - 1);

	/* Set the limit clause avoiding negative offsets */
	if (i_number < i_limit) {
		PHALCON_CALL_METHOD(NULL, builder, "limit", limit);
	} else {
		zval *number;
		PHALCON_ALLOC_GHOST_ZVAL(number);
		ZVAL_LONG(number, i_number);
		PHALCON_CALL_METHOD(NULL, builder, "limit", limit, number);
	}
	
	PHALCON_CALL_METHOD(&query, builder, "getquery");

	/* Execute the query an return the requested slice of data */
	PHALCON_CALL_METHOD(&items, query, "execute");
	
	/* Remove the 'ORDER BY' clause, PostgreSQL requires this */
	PHALCON_CALL_METHOD(NULL, total_builder, "orderby", PHALCON_GLOBAL(z_null));
	
	/* Obtain the PHQL for the total query */
	PHALCON_CALL_METHOD(&total_query, total_builder, "getquery");

	PHALCON_CALL_METHOD(&dependency_injector, total_query, "getdi");
	if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "A dependency injection object is required to access internal services");
		return;
	}

	/* Get the connection through the model */
	PHALCON_INIT_VAR(service_name);
	ZVAL_STRING(service_name, "modelsManager", 1);

	PHALCON_CALL_METHOD(&models_manager, dependency_injector, "getshared", service_name);
	if (Z_TYPE_P(models_manager) != IS_OBJECT) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_paginator_exception_ce, "The injected service 'modelsManager' is not valid");
		return;
	}

	PHALCON_VERIFY_INTERFACE(models_manager, phalcon_mvc_model_managerinterface_ce);

	PHALCON_CALL_METHOD(&models, builder, "getfrom");

	if (Z_TYPE_P(models) == IS_ARRAY) {
		PHALCON_INIT_VAR(model_name);
		phalcon_array_get_current(model_name, models);
	} else {
		PHALCON_CPY_WRT(model_name, models);
	}

	PHALCON_CALL_METHOD(&model, models_manager, "load", model_name);

	PHALCON_CALL_METHOD(&connection, model, "getreadconnection");

	PHALCON_CALL_METHOD(&intermediate, total_query, "parse");

	PHALCON_OBS_VAR(tables);
	phalcon_array_fetch_quick_string(&tables, intermediate, SS("tables"), 3465666720UL, PH_NOISY);
	
	PHALCON_OBS_VAR(table);
	phalcon_array_fetch_long(&table, tables, 0, PH_NOISY);

	if (Z_TYPE_P(table) == IS_ARRAY) {
		if (phalcon_array_isset_long(table, 2)) {
			PHALCON_OBS_VAR(table_name);
			phalcon_array_fetch_long(&table_name, table, 2, PH_NOISY);
		} else {
			PHALCON_OBS_VAR(table_name);
			phalcon_array_fetch_long(&table_name, table, 0, PH_NOISY);
		}
	} else {
		PHALCON_CPY_WRT(table_name, table);
	}

	PHALCON_INIT_VAR(select_column);
	PHALCON_CONCAT_VS(select_column, table_name, ".*");	

	phalcon_array_update_string(&intermediate, SL("columns"), select_column, PH_COPY | PH_SEPARATE);

	PHALCON_CALL_METHOD(&dialect, connection, "getdialect");
	PHALCON_CALL_METHOD(&sql_select, dialect, "select", intermediate);

	PHALCON_CALL_METHOD(&bind_params, total_query, "getbindparams");
	PHALCON_CALL_METHOD(&bind_types, total_query, "getbindtypes");

	PHALCON_INIT_VAR(sql);
	PHALCON_CONCAT_SVS(sql, "SELECT COUNT(*) \"rowcount\" FROM (", sql_select, ") AS T");

	if (Z_TYPE_P(bind_params) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(processed);
		array_init(processed);
	
		phalcon_is_iterable(bind_params, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(wildcard, ah0, hp0);
			PHALCON_GET_HVALUE(value);
	
			if (Z_TYPE_P(wildcard) == IS_LONG) {
				PHALCON_INIT_NVAR(string_wildcard);
				PHALCON_CONCAT_SV(string_wildcard, ":", wildcard);
				phalcon_array_update_zval(&processed, string_wildcard, value, PH_COPY);
			} else {
				phalcon_array_update_zval(&processed, wildcard, value, PH_COPY);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		PHALCON_CPY_WRT(processed, bind_params);
	}
	
	if (Z_TYPE_P(bind_types) == IS_ARRAY) { 
	
		PHALCON_INIT_VAR(processed_types);
		array_init(processed_types);
	
		phalcon_is_iterable(bind_types, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HKEY(wildcard, ah0, hp0);
			PHALCON_GET_HVALUE(value);
	
			if (Z_TYPE_P(wildcard) == IS_LONG) {
				PHALCON_INIT_NVAR(string_wildcard);
				PHALCON_CONCAT_SV(string_wildcard, ":", wildcard);
				phalcon_array_update_zval(&processed_types, string_wildcard, value, PH_COPY | PH_SEPARATE);
			} else {
				phalcon_array_update_zval(&processed_types, wildcard, value, PH_COPY | PH_SEPARATE);
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	} else {
		PHALCON_CPY_WRT(processed_types, bind_types);
	}

	PHALCON_CALL_METHOD(&result, connection, "query", sql, processed, processed_types);
	PHALCON_CALL_METHOD(&row, result, "fetch");
	
	PHALCON_OBS_VAR(rowcount);
	phalcon_array_fetch_quick_string(&rowcount, row, SS("rowcount"), 4184721862UL, PH_NOISY);
	
	i_rowcount    = phalcon_get_intval(rowcount);
	tp            = ldiv(i_rowcount, i_limit);
	i_total_pages = tp.quot + (tp.rem ? 1 : 0);
	i_next        = (i_number_page < i_total_pages) ? (i_number_page + 1) : i_total_pages;

	object_init(return_value);
	phalcon_update_property_zval(return_value, SL("items"),       items TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("before"),      i_before TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("first"),       1 TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("next"),        i_next TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("last"),        i_total_pages TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("current"),     i_number_page TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("total_pages"), i_total_pages TSRMLS_CC);
	phalcon_update_property_long(return_value, SL("total_items"), i_rowcount TSRMLS_CC);
	
	PHALCON_MM_RESTORE();
}





zend_class_entry *psr_log_abstractlogger_ce;

static void psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAMETERS, const char *lvl)
{
	zval *level, *message, *context = NULL;
	zval *retval = NULL;
	zval **params[3] = { &level, &message, &context };
	zval function_name = zval_used_for_init;
	zend_fcall_info fci;
	zend_fcall_info_cache fcic;
	zend_class_entry *ce;

	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|z", &message, &context)) {
		RETURN_NULL();
	}

	ce = Z_OBJCE_P(getThis());

	if (!context) {
		MAKE_STD_ZVAL(context);
		array_init(context);
		Z_SET_REFCOUNT_P(context, 0);
	}

	MAKE_STD_ZVAL(level);
	ZVAL_STRING(level, lvl, 1);
	Z_SET_REFCOUNT_P(level, 0);

	fci.size           = sizeof(fci);
	fci.function_table = &ce->function_table;
	fci.object_ptr     = getThis();
	fci.function_name  = &function_name;
	fci.retval_ptr_ptr = &retval;
	fci.param_count    = 3;
	fci.params         = params;
	fci.no_separation  = 1;
	fci.symbol_table   = NULL;

	fcic.initialized   = 1;
	fcic.object_ptr    = getThis();
	fcic.calling_scope = ce;
	fcic.called_scope  = ce;

	if (zend_hash_quick_find(fci.function_table, ZEND_STRS("log"), zend_inline_hash_func(ZEND_STRS("log")), (void**)&fcic.function_handler) == FAILURE) {
		fcic.initialized = 0;
		ZVAL_STRING(&function_name, "log", 0);
	}

	zend_call_function(&fci, &fcic TSRMLS_CC);

	if (retval) {
		zval_ptr_dtor(&retval);
	}
}

PHP_FUNCTION(Psr_Log_Emergency)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_EMERGENCY);
}

PHP_FUNCTION(Psr_Log_Alert)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_ALERT);
}

PHP_FUNCTION(Psr_Log_Critical)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_CRITICAL);
}

PHP_FUNCTION(Psr_Log_Error)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_ERROR);
}

PHP_FUNCTION(Psr_Log_Warning)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_WARNING);
}

PHP_FUNCTION(Psr_Log_Notice)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_NOTICE);
}

PHP_FUNCTION(Psr_Log_Info)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_INFO);
}

PHP_FUNCTION(Psr_Log_Debug)
{
	psr_log_abstractlogger_log_helper(INTERNAL_FUNCTION_PARAM_PASSTHRU, PSR_LOG_LOGLEVEL_DEBUG);
}

static const zend_function_entry fe_psr_log_abstractlogger[] = {
	PHP_ME_MAPPING(emergency, Psr_Log_Emergency, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(alert, Psr_Log_Alert, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(critical, Psr_Log_Critical, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(error, Psr_Log_Error, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(warning, Psr_Log_Warning, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(notice, Psr_Log_Notice, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(info, Psr_Log_Info, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(debug, Psr_Log_Debug, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_AbstractLogger)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\AbstractLogger", fe_psr_log_abstractlogger);

	psr_log_abstractlogger_ce = zend_register_internal_class(&ce TSRMLS_CC);
	if (EXPECTED(psr_log_abstractlogger_ce != NULL)) {
		zend_class_implements(psr_log_abstractlogger_ce TSRMLS_CC, 1, psr_log_loggerinterface_ce);
		return SUCCESS;
	}

	return FAILURE;
}





#include <Zend/zend_exceptions.h>
#include <ext/spl/spl_exceptions.h>

zend_class_entry *psr_log_invalidargumentexception_ce;

PHALCON_INIT_CLASS(Psr_Log_InvalidArgumentException)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\InvalidArgumentException", NULL);

	psr_log_invalidargumentexception_ce = zend_register_internal_class_ex(&ce, spl_ce_InvalidArgumentException, NULL TSRMLS_CC);
	return (EXPECTED(psr_log_invalidargumentexception_ce != NULL)) ? SUCCESS : FAILURE;
}





zend_class_entry *psr_log_loggerawareinterface_ce;

static const zend_function_entry fe_psr_log_loggerawareinterface[] = {
	PHP_ABSTRACT_ME(Psr_Log_LoggerAwareInterface, setLogger, arginfo_psr_log_loggerawareinterface_setlogger)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_LoggerAwareInterface)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\LoggerAwareInterface", fe_psr_log_loggerawareinterface);

	psr_log_loggerawareinterface_ce = zend_register_internal_interface(&ce TSRMLS_CC);
	return (EXPECTED(psr_log_loggerawareinterface_ce != NULL)) ? SUCCESS : FAILURE;
}





zend_class_entry *psr_log_loggerawaretrait_ce;

#if PHP_VERSION_ID >= 50400

static PHP_METHOD(Psr_Log_LoggerAwareTrait, setLogger)
{
	zval **logger;

	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Z", &logger)) {
		RETURN_NULL();
	}

	zend_update_property(psr_log_loggerawaretrait_ce, getThis(), ZEND_STRL("logger"), *logger TSRMLS_CC);
}

static const zend_function_entry fe_psr_log_loggerawaretrait[] = {
	PHP_ME(Psr_Log_LoggerAwareTrait, setLogger, arginfo_psr_log_loggerawareinterface_setlogger, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_LoggerAwareTrait)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\LoggerAwareTrait", fe_psr_log_loggerawaretrait);

	psr_log_loggerawaretrait_ce = zend_register_internal_class(&ce TSRMLS_CC);
	if (EXPECTED(psr_log_loggerawaretrait_ce != NULL)) {
		psr_log_loggerawaretrait_ce->ce_flags |= ZEND_ACC_TRAIT;

		zend_declare_property_null(psr_log_loggerawaretrait_ce, ZEND_STRL("logger"), ZEND_ACC_PROTECTED TSRMLS_CC);
		return SUCCESS;
	}

	return FAILURE;
}

#else

PHALCON_INIT_CLASS(Psr_Log_LoggerAwareTrait)
{
	psr_log_loggerawaretrait_ce = NULL;
	return SUCCESS;
}

#endif



zend_class_entry *psr_log_loggerinterface_ce;

static const zend_function_entry fe_psr_log_loggerinterface[] = {
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, emergency, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, alert, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, critical, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, error, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, warning, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, notice, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, info, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, debug, arginfo_psr_log_loggerinterface_logspecialized)
	PHP_ABSTRACT_ME(Psr_Log_LoggerInterface, log, arginfo_psr_log_loggerinterface_log)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_LoggerInterface)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\LoggerInterface", fe_psr_log_loggerinterface);

	psr_log_loggerinterface_ce = zend_register_internal_interface(&ce TSRMLS_CC);
	return (EXPECTED(psr_log_loggerinterface_ce != NULL)) ? SUCCESS : FAILURE;
}



zend_class_entry *psr_log_loggertrait_ce;

#if PHP_VERSION_ID >= 50400

static const zend_function_entry fe_psr_log_loggertrait[] = {
	PHP_ME_MAPPING(emergency, Psr_Log_Emergency, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(alert, Psr_Log_Alert, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(critical, Psr_Log_Critical, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(error, Psr_Log_Error, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(warning, Psr_Log_Warning, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(notice, Psr_Log_Notice, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(info, Psr_Log_Info, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ME_MAPPING(debug, Psr_Log_Debug, arginfo_psr_log_loggerinterface_logspecialized, ZEND_ACC_PUBLIC)
	PHP_ABSTRACT_ME(Psr_Log_LoggerTrait, log, arginfo_psr_log_loggerinterface_log)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_LoggerTrait)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\LoggerTrait", fe_psr_log_loggertrait);

	psr_log_loggertrait_ce = zend_register_internal_class(&ce TSRMLS_CC);
	if (EXPECTED(psr_log_loggertrait_ce != NULL)) {
		psr_log_loggertrait_ce->ce_flags |= ZEND_ACC_TRAIT;
		return SUCCESS;
	}

	return FAILURE;
}

#else

PHALCON_INIT_CLASS(Psr_Log_LoggerTrait)
{
	psr_log_loggertrait_ce = NULL;
	return SUCCESS;
}

#endif





zend_class_entry *psr_log_loglevel_ce;

PHALCON_INIT_CLASS(Psr_Log_LogLevel)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\LogLevel", NULL);

	psr_log_loglevel_ce = zend_register_internal_class(&ce TSRMLS_CC);
	if (EXPECTED(psr_log_loglevel_ce != NULL)) {
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("EMERGENCY"), ZEND_STRS(PSR_LOG_LOGLEVEL_EMERGENCY) TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("ALERT"),     ZEND_STRS(PSR_LOG_LOGLEVEL_ALERT)     TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("CRITICAL"),  ZEND_STRS(PSR_LOG_LOGLEVEL_CRITICAL)  TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("ERROR"),     ZEND_STRS(PSR_LOG_LOGLEVEL_ERROR)     TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("WARNING"),   ZEND_STRS(PSR_LOG_LOGLEVEL_WARNING)   TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("NOTICE"),    ZEND_STRS(PSR_LOG_LOGLEVEL_NOTICE)    TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("INFO"),      ZEND_STRS(PSR_LOG_LOGLEVEL_INFO)      TSRMLS_CC);
		zend_declare_class_constant_stringl(psr_log_loglevel_ce, ZEND_STRS("DEBUG"),     ZEND_STRS(PSR_LOG_LOGLEVEL_DEBUG)     TSRMLS_CC);

		return SUCCESS;
	}

	return FAILURE;
}





zend_class_entry *psr_log_nulllogger_ce;

static PHP_METHOD(Psr_Log_NullLogger, log)
{
	zval *level, *message, *context = NULL;

	if (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "zz|z!", &level, &message, &context)) {
		RETURN_NULL();
	}
}

static const zend_function_entry fe_psr_log_nulllogger[] = {
	PHP_ME(Psr_Log_NullLogger, log, arginfo_psr_log_loggerinterface_log, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Psr_Log_NullLogger)
{
	zend_class_entry ce;
	INIT_CLASS_ENTRY(ce, "Psr\\Log\\NullLogger", fe_psr_log_nulllogger);

	psr_log_nulllogger_ce = zend_register_internal_class_ex(&ce, psr_log_abstractlogger_ce, NULL TSRMLS_CC);
	return (EXPECTED(psr_log_nulllogger_ce != NULL)) ? SUCCESS : FAILURE;
}




#include <ext/standard/file.h>
#include <main/php_streams.h>


zend_class_entry *phalcon_queue_beanstalk_ce;

static PHP_METHOD(Phalcon_Queue_Beanstalk, __construct);
static PHP_METHOD(Phalcon_Queue_Beanstalk, connect);
static PHP_METHOD(Phalcon_Queue_Beanstalk, put);
static PHP_METHOD(Phalcon_Queue_Beanstalk, reserve);
static PHP_METHOD(Phalcon_Queue_Beanstalk, choose);
static PHP_METHOD(Phalcon_Queue_Beanstalk, watch);
static PHP_METHOD(Phalcon_Queue_Beanstalk, peekReady);
static PHP_METHOD(Phalcon_Queue_Beanstalk, peekDelayed);
static PHP_METHOD(Phalcon_Queue_Beanstalk, peekBuried);
static PHP_METHOD(Phalcon_Queue_Beanstalk, readStatus);
static PHP_METHOD(Phalcon_Queue_Beanstalk, read);
static PHP_METHOD(Phalcon_Queue_Beanstalk, write);
static PHP_METHOD(Phalcon_Queue_Beanstalk, disconnect);
static PHP_METHOD(Phalcon_Queue_Beanstalk, __sleep);
static PHP_METHOD(Phalcon_Queue_Beanstalk, __wakeup);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_put, 0, 0, 1)
	ZEND_ARG_INFO(0, data)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_reserve, 0, 0, 0)
	ZEND_ARG_INFO(0, timeout)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_choose, 0, 0, 1)
	ZEND_ARG_INFO(0, tube)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_watch, 0, 0, 1)
	ZEND_ARG_INFO(0, tube)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_read, 0, 0, 0)
	ZEND_ARG_INFO(0, length)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_queue_beanstalk_method_entry[] = {
	PHP_ME(Phalcon_Queue_Beanstalk, __construct, arginfo_phalcon_queue_beanstalk___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Queue_Beanstalk, connect, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, put, arginfo_phalcon_queue_beanstalk_put, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, reserve, arginfo_phalcon_queue_beanstalk_reserve, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, choose, arginfo_phalcon_queue_beanstalk_choose, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, watch, arginfo_phalcon_queue_beanstalk_watch, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, peekReady, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, peekDelayed, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, peekBuried, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, readStatus, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Queue_Beanstalk, read, arginfo_phalcon_queue_beanstalk_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, write, NULL, ZEND_ACC_PROTECTED)
	PHP_ME(Phalcon_Queue_Beanstalk, disconnect, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, __sleep, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk, __wakeup, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Queue_Beanstalk){

	PHALCON_REGISTER_CLASS(Phalcon\\Queue, Beanstalk, queue_beanstalk, phalcon_queue_beanstalk_method_entry, 0);

	zend_declare_property_null(phalcon_queue_beanstalk_ce, SL("_connection"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_queue_beanstalk_ce, SL("_parameters"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, __construct){

	zval *options = NULL, *parameters = NULL, *tmp;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_INIT_VAR(parameters);
		array_init_size(parameters, 2);
	} else {
		PHALCON_CPY_WRT_CTOR(parameters, options);
	}

	if (!phalcon_array_isset_string_fetch(&tmp, parameters, SS("host"))) {
		phalcon_array_update_string_string(&parameters, SL("host"), SL("127.0.0.1"), 0);
	}
	else {
		convert_to_string(tmp);
	}
	
	if (!phalcon_array_isset_string_fetch(&tmp, parameters, SS("port"))) {
		phalcon_array_update_string_long(&parameters, SL("port"), 11300, 0);
	}
	else {
		convert_to_long(tmp);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_parameters"), parameters, 2188379992UL TSRMLS_CC);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, connect){

	zval *connection = NULL, *parameters, *host, *port;

	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection) == IS_RESOURCE) {
		PHALCON_MM_GROW();
		PHALCON_CALL_METHOD(NULL, this_ptr, "disconnect");
		PHALCON_MM_RESTORE();
	}
	
	parameters = phalcon_fetch_nproperty_this(this_ptr, SL("_parameters"), PH_NOISY TSRMLS_CC);
	
	if (!phalcon_array_isset_string_fetch(&host, parameters, SS("host")) || !phalcon_array_isset_string_fetch(&port, parameters, SS("port"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_exception_ce, "Unexpected inconsistency in options");
		return;
	}
	
	convert_to_string(host);
	convert_to_long(port);

	{
		ulong timeout = (ulong)(FG(default_socket_timeout) * 1000000.0);
		char *hostname;
		long int hostname_len = spprintf(&hostname, 0, "%s:%ld", Z_STRVAL_P(host), Z_LVAL_P(port));
		struct timeval tv;
		php_stream *stream;
		int err;
		char *errstr = NULL;

		tv.tv_sec  = timeout / 1000000;
		tv.tv_usec = timeout % 1000000;

		stream = php_stream_xport_create(hostname, hostname_len, ENFORCE_SAFE_MODE | REPORT_ERRORS, STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT, NULL, &tv, NULL, &errstr, &err);
		efree(hostname);

		if (!stream) {
			zend_throw_exception_ex(phalcon_exception_ce, err TSRMLS_CC, "Unable to connect to Beanstalk server at %s:%ld (%s)", Z_STRVAL_P(host), Z_LVAL_P(port), (errstr == NULL ? "Unknown error" : errstr));
		}

		if (errstr) {
			efree(errstr);
		}

		if (!stream) {
			RETURN_NULL();
		}

		tv.tv_sec  = -1;
		tv.tv_usec = 0;
		php_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &tv);

		MAKE_STD_ZVAL(connection);
		php_stream_to_zval(stream, connection);
		phalcon_update_property_this_quick(this_ptr, SL("_connection"), connection, 3057302292UL TSRMLS_CC);
		RETVAL_ZVAL(connection, 1, 1);
	}
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, put){

	zval *data, *options = NULL, *priority = NULL, *delay = NULL, *ttr = NULL, *serialized;
	zval *serialized_length, *command, *response = NULL;
	zval *status, *job_id = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &data, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (!phalcon_array_isset_string_fetch(&priority, options, SS("priority"))) {
		PHALCON_INIT_VAR(priority);
		ZVAL_STRING(priority, "100", 1);
	}

	if (!phalcon_array_isset_string_fetch(&delay, options, SS("delay"))) {
		PHALCON_INIT_VAR(delay);
		ZVAL_STRING(delay, "0", 1);
	}

	if (!phalcon_array_isset_string_fetch(&ttr, options, SS("ttr"))) {
		PHALCON_INIT_VAR(ttr);
		ZVAL_STRING(ttr, "86400", 1);
	}
	
	PHALCON_INIT_VAR(serialized);
	phalcon_serialize(serialized, &data TSRMLS_CC);
	
	if (Z_TYPE_P(serialized) == IS_STRING) {
		PHALCON_INIT_VAR(serialized_length);
		ZVAL_LONG(serialized_length, Z_STRLEN_P(serialized));
	}
	else {
		RETURN_MM_FALSE;
	}

	PHALCON_INIT_VAR(command);
	PHALCON_CONCAT_SVSV(command, "put ", priority, " ", delay);
	PHALCON_SCONCAT_SVSV(command, " ", ttr, " ", serialized_length);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", serialized);
	
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "INSERTED")) {
		PHALCON_OBS_VAR(job_id);
		phalcon_array_fetch_long(&job_id, response, 1, PH_NOISY);
		RETURN_CCTOR(job_id);
	}
	
	if (PHALCON_IS_STRING(status, "BURIED")) {
		PHALCON_OBS_NVAR(job_id);
		phalcon_array_fetch_long(&job_id, response, 1, PH_NOISY);
		RETURN_CCTOR(job_id);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, reserve){

	zval *timeout = NULL, *command = NULL, *response = NULL, *status, *job_id;
	zval *length, *serialized_body = NULL, *body;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &timeout);
	
	if (!timeout) {
		timeout = PHALCON_GLOBAL(z_null);
	}

	PHALCON_INIT_VAR(command);
	if (zend_is_true(timeout)) {
		PHALCON_CONCAT_SV(command, "reserve-with-timeout ", timeout);
	} else {
		ZVAL_STRING(command, "reserve", 1);
	}
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "RESERVED")) {
		PHALCON_OBS_VAR(job_id);
		phalcon_array_fetch_long(&job_id, response, 1, PH_NOISY);
	
		PHALCON_OBS_VAR(length);
		phalcon_array_fetch_long(&length, response, 2, PH_NOISY);
	
		PHALCON_CALL_METHOD(&serialized_body, this_ptr, "read", length);
	
		PHALCON_INIT_VAR(body);
		phalcon_unserialize(body, serialized_body TSRMLS_CC);
	
		object_init_ex(return_value, phalcon_queue_beanstalk_job_ce);
		PHALCON_CALL_METHOD(NULL, return_value, "__construct", this_ptr, job_id, body);
	
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, choose){

	zval *tube, *command, *response = NULL, *status, *using_tube;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &tube);
	
	PHALCON_INIT_VAR(command);
	PHALCON_CONCAT_SV(command, "use ", tube);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "USING")) {
		PHALCON_OBS_VAR(using_tube);
		phalcon_array_fetch_long(&using_tube, response, 1, PH_NOISY);
		RETURN_CCTOR(using_tube);
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, watch){

	zval *tube, *command, *response = NULL, *status, *watching_tube;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &tube);
	
	PHALCON_INIT_VAR(command);
	PHALCON_CONCAT_SV(command, "watch ", tube);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "WATCHING")) {
		PHALCON_OBS_VAR(watching_tube);
		phalcon_array_fetch_long(&watching_tube, response, 1, PH_NOISY);
		RETURN_CCTOR(watching_tube);
	}
	
	RETURN_MM_FALSE;
}

static void phalcon_queue_beanstalk_peek_common(zval *return_value, zval *this_ptr, zval *response TSRMLS_DC)
{
	zval *job_id, *length, *serialized = NULL, *body;

	if (!phalcon_array_isset_long_fetch(&job_id, response, 1)) {
		job_id = PHALCON_GLOBAL(z_null);
	}

	if (!phalcon_array_isset_long_fetch(&length, response, 2)) {
		length = PHALCON_GLOBAL(z_null);
	}

	PHALCON_CALL_METHODW(&serialized, this_ptr, "read", length);

	MAKE_STD_ZVAL(body);
	phalcon_unserialize(body, serialized TSRMLS_CC);
	zval_ptr_dtor(&serialized);
	if (Z_REFCOUNT_P(body) >= 1) {
		Z_DELREF_P(body);
	}

	object_init_ex(return_value, phalcon_queue_beanstalk_job_ce);
	PHALCON_CALL_METHODW(NULL, return_value, "__construct", this_ptr, job_id, body);
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, peekReady){

	zval *command, *response = NULL, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(command);
	ZVAL_STRING(command, "peek-ready", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "FOUND")) {
		phalcon_queue_beanstalk_peek_common(return_value, getThis(), response TSRMLS_CC);
		RETURN_MM();
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, peekDelayed){

	zval *command, *response = NULL, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(command);
	ZVAL_STRING(command, "peek-delayed", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "FOUND")) {
		phalcon_queue_beanstalk_peek_common(return_value, getThis(), response TSRMLS_CC);
		RETURN_MM();
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, peekBuried){

	zval *command, *response = NULL, *status;

	PHALCON_MM_GROW();

	PHALCON_INIT_VAR(command);
	ZVAL_STRING(command, "peek-buried", 1);
	PHALCON_CALL_METHOD(NULL, this_ptr, "write", command);
	PHALCON_CALL_METHOD(&response, this_ptr, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "FOUND")) {
		phalcon_queue_beanstalk_peek_common(return_value, getThis(), response TSRMLS_CC);
		RETURN_MM();
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, readStatus){

	zval *response = NULL;

	PHALCON_MM_GROW();

	PHALCON_CALL_METHOD(&response, this_ptr, "read");
	phalcon_fast_explode_str(return_value, SL(" "), response);
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, read){

	zval **length = NULL, *connection, *meta;
	php_stream *stream;

	PHALCON_MM_GROW();

	phalcon_fetch_params_ex(0, 1, &length);
	
	if (!length) {
		length = &PHALCON_GLOBAL(z_zero);
	}
	else {
		PHALCON_ENSURE_IS_LONG(length);
	}
	
	PHALCON_OBS_VAR(connection);
	phalcon_read_property_this(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection) != IS_RESOURCE) {
		PHALCON_CALL_METHOD(&connection, this_ptr, "connect");
		if (Z_TYPE_P(connection) != IS_RESOURCE) {
			RETURN_MM_FALSE;
		}
	}
	
	php_stream_from_zval_no_verify(stream, &connection);
	if (!stream) {
		RETURN_MM_FALSE;
	}

	if (zend_is_true(*length)) {
		long int total_length;
		long int len;
		zend_bool timeout = 0;
		char *buf;
	
		if (php_stream_eof(stream)) {
			RETURN_MM_FALSE;
		}
	
		total_length = Z_LVAL_PP(length) + 2;

		buf = ecalloc(1, total_length + 1);
		len = php_stream_read(stream, buf, total_length);

		ZVAL_STRINGL(return_value, buf, len, 0);

		PHALCON_INIT_VAR(meta);
		array_init_size(meta, 4);
		if (php_stream_populate_meta_data(stream, meta)) {
			zval *t;
			if (phalcon_array_isset_string_fetch(&t, meta, SS("timed_out"))) {
				timeout = zend_is_true(t);
			}
		}

		if (timeout) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_exception_ce, "Connection timed out");
			return;
		}
	} else {
		size_t line_len = 0;
		long int len = 16384;
		char *buf = ecalloc(1, len+1);

		if (php_stream_get_line(stream, buf, len, &line_len) != NULL) {
			if (line_len < 512) {
				buf = erealloc(buf, line_len + 1);
			}

			ZVAL_STRINGL(return_value, buf, line_len, 0);
		}
		else {
			efree(buf);
			ZVAL_FALSE(return_value);
		}
	}

	if (Z_TYPE_P(return_value) == IS_STRING && Z_STRLEN_P(return_value) >= 2) {
		char *s      = Z_STRVAL_P(return_value);
		long int len = Z_STRLEN_P(return_value);

		if (s[len-1] == '\n' && s[len-2] == '\r') {
			s[len-2] = '\0';
			Z_STRLEN_P(return_value) -= 2;
		}
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, write){

	zval *data, *connection, *packet;
	php_stream *stream;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &data);
	
	PHALCON_OBS_VAR(connection);
	phalcon_read_property_this(&connection, this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection) != IS_RESOURCE) {
		PHALCON_CALL_METHOD(&connection, this_ptr, "connect");
		if (Z_TYPE_P(connection) != IS_RESOURCE) {
			RETURN_MM_FALSE;
		}
	}
	
	php_stream_from_zval_no_verify(stream, &connection);
	if (!stream) {
		RETURN_MM_FALSE;
	}

	PHALCON_INIT_VAR(packet);
	PHALCON_CONCAT_VS(packet, data, "\r\n");
	
	php_stream_write(stream, Z_STRVAL_P(packet), Z_STRLEN_P(packet));
	RETURN_MM();
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, disconnect){

	zval *connection;
	php_stream *stream;

	connection = phalcon_fetch_nproperty_this(this_ptr, SL("_connection"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(connection) != IS_RESOURCE) {
		RETURN_FALSE;
	}
	
	php_stream_from_zval_no_verify(stream, &connection);
	if (!stream) {
		RETURN_FALSE;
	}

	if ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) == 0) {
		if (!stream->is_persistent) {
			zend_list_delete(stream->rsrc_id);
		}
		else {
			php_stream_pclose(stream);
		}
	}

	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, __sleep){

	array_init_size(return_value, 1);
	add_next_index_string(return_value, "_parameters", 1);
}

static PHP_METHOD(Phalcon_Queue_Beanstalk, __wakeup){

	zval *params, *host, *port;
	int fail;

	zend_update_property_null(phalcon_queue_beanstalk_ce, getThis(), SL("_connection") TSRMLS_CC);

	params = phalcon_fetch_nproperty_this(this_ptr, SL("_parameters"), PH_NOISY TSRMLS_CC);
	if (
			Z_TYPE_P(params) != IS_ARRAY
		 || !phalcon_array_isset_string_fetch(&host, params, SS("host"))
		 || !phalcon_array_isset_string_fetch(&port, params, SS("port"))
	) {
		fail = 1;
	}
	else if (Z_TYPE_P(host) != IS_STRING || Z_TYPE_P(port) != IS_LONG) {
		fail = 1;
	}
	else {
		fail = 0;
	}

	if (fail) {
		zend_throw_exception_ex(phalcon_exception_ce, 0 TSRMLS_CC, "Invalid serialization data");
	}
}






zend_class_entry *phalcon_queue_beanstalk_job_ce;

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, __construct);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, getId);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, getBody);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, delete);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, release);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, bury);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, touch);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, kick);
static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, __wakeup);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_queue_beanstalk_job___construct, 0, 0, 3)
	ZEND_ARG_INFO(0, queue)
	ZEND_ARG_INFO(0, id)
	ZEND_ARG_INFO(0, body)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_queue_beanstalk_job_method_entry[] = {
	PHP_ME(Phalcon_Queue_Beanstalk_Job, __construct, arginfo_phalcon_queue_beanstalk_job___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, getId, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, getBody, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, delete, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, release, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, bury, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, touch, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, kick, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Queue_Beanstalk_Job, __wakeup, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Queue_Beanstalk_Job){

	PHALCON_REGISTER_CLASS(Phalcon\\Queue\\Beanstalk, Job, queue_beanstalk_job, phalcon_queue_beanstalk_job_method_entry, 0);

	zend_declare_property_null(phalcon_queue_beanstalk_job_ce, SL("_queue"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_queue_beanstalk_job_ce, SL("_id"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_queue_beanstalk_job_ce, SL("_body"), ZEND_ACC_PROTECTED TSRMLS_CC);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, __construct){

	zval **queue, **id, **body;

	phalcon_fetch_params_ex(3, 0, &queue, &id, &body);
	PHALCON_VERIFY_CLASS_EX(*queue, phalcon_queue_beanstalk_ce, phalcon_exception_ce, 0);
	PHALCON_ENSURE_IS_STRING(id);

	phalcon_update_property_this(this_ptr, SL("_queue"), *queue TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_id"),    *id    TSRMLS_CC);
	phalcon_update_property_this(this_ptr, SL("_body"),  *body  TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, getId){


	RETURN_MEMBER_QUICK(this_ptr, "_id", 2090005265UL);
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, getBody){


	RETURN_MEMBER_QUICK(this_ptr, "_body", 3970240754UL);
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, delete){

	zval *id, *command, *queue, *response = NULL, *status;

	PHALCON_MM_GROW();

	id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);
	
	PHALCON_ALLOC_GHOST_ZVAL(command);
	PHALCON_CONCAT_SV(command, "delete ", id);
	PHALCON_CALL_METHOD(NULL, queue, "write", command);
	
	PHALCON_CALL_METHOD(&response, queue, "readstatus");
	
	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "DELETED")) {
		RETURN_MM_TRUE;
	}
	
	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, release){

	zval *priority = NULL, *delay = NULL;
	zval *id, *command, *queue, *response = NULL, *status;

	phalcon_fetch_params(0, 0, 2, &priority, &delay);

	PHALCON_MM_GROW();

	if (!priority) {
		PHALCON_INIT_VAR(priority);
		ZVAL_LONG(priority, 100);
	}

	if (!delay) {
		delay = PHALCON_GLOBAL(z_zero);
	}

	id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);

	PHALCON_ALLOC_GHOST_ZVAL(command);
	PHALCON_CONCAT_SVSVSV(command, "release ", id, " ", priority, " ", delay);
	PHALCON_CALL_METHOD(NULL, queue, "write", command);

	PHALCON_CALL_METHOD(&response, queue, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "RELEASED")) {
		RETURN_MM_TRUE;
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, bury){

	zval *priority = NULL;
	zval *id, *command, *queue, *response = NULL, *status;

	phalcon_fetch_params(0, 0, 1, &priority);

	PHALCON_MM_GROW();

	if (!priority) {
		PHALCON_INIT_VAR(priority);
		ZVAL_LONG(priority, 100);
	}

	id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);

	PHALCON_ALLOC_GHOST_ZVAL(command);
	PHALCON_CONCAT_SVSV(command, "bury ", id, " ", priority);
	PHALCON_CALL_METHOD(NULL, queue, "write", command);
	PHALCON_CALL_METHOD(&response, queue, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "BURIED")) {
		RETURN_MM_TRUE;
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, touch){

	zval *id, *command, *queue, *response = NULL, *status;

	PHALCON_MM_GROW();

	id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);

	PHALCON_ALLOC_GHOST_ZVAL(command);
	PHALCON_CONCAT_SV(command, "touch ", id);
	PHALCON_CALL_METHOD(NULL, queue, "write", command);
	PHALCON_CALL_METHOD(&response, queue, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "TOUCHED")) {
		RETURN_MM_TRUE;
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, kick){

	zval *id, *command, *queue, *response = NULL, *status;

	PHALCON_MM_GROW();

	id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);

	PHALCON_ALLOC_GHOST_ZVAL(command);
	PHALCON_CONCAT_SV(command, "kick-job ", id);
	PHALCON_CALL_METHOD(NULL, queue, "write", command);
	PHALCON_CALL_METHOD(&response, queue, "readstatus");

	PHALCON_OBS_VAR(status);
	phalcon_array_fetch_long(&status, response, 0, PH_NOISY);
	if (PHALCON_IS_STRING(status, "KICKED")) {
		RETURN_MM_TRUE;
	}

	RETURN_MM_FALSE;
}

static PHP_METHOD(Phalcon_Queue_Beanstalk_Job, __wakeup) {

	zval *id    = phalcon_fetch_nproperty_this(this_ptr, SL("_id"), PH_NOISY TSRMLS_CC);
	zval *queue = phalcon_fetch_nproperty_this(this_ptr, SL("_queue"), PH_NOISY TSRMLS_CC);

	PHALCON_VERIFY_CLASS_EX(queue, phalcon_queue_beanstalk_ce, phalcon_exception_ce, 0);

	if (Z_TYPE_P(id) != IS_STRING) {
		zend_throw_exception_ex(phalcon_exception_ce, 0 TSRMLS_CC, "Unexpected inconsistency in %s - possible break-in attempt!", "Phalcon\\Queue\\Beanstalk\\Job::__wakeup()");
	}
}





zend_class_entry *phalcon_security_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Security_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Security, Exception, security_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





#include <main/SAPI.h>
#include <ext/spl/spl_array.h>


zend_class_entry *phalcon_session_adapter_ce;

static zend_object_handlers phalcon_session_adapter_object_handlers;

static PHP_METHOD(Phalcon_Session_Adapter, __construct);
static PHP_METHOD(Phalcon_Session_Adapter, __destruct);
static PHP_METHOD(Phalcon_Session_Adapter, start);
static PHP_METHOD(Phalcon_Session_Adapter, setOptions);
static PHP_METHOD(Phalcon_Session_Adapter, getOptions);
static PHP_METHOD(Phalcon_Session_Adapter, get);
static PHP_METHOD(Phalcon_Session_Adapter, set);
static PHP_METHOD(Phalcon_Session_Adapter, has);
static PHP_METHOD(Phalcon_Session_Adapter, remove);
static PHP_METHOD(Phalcon_Session_Adapter, getId);
static PHP_METHOD(Phalcon_Session_Adapter, isStarted);
static PHP_METHOD(Phalcon_Session_Adapter, destroy);
static PHP_METHOD(Phalcon_Session_Adapter, __get);
static PHP_METHOD(Phalcon_Session_Adapter, count);
static PHP_METHOD(Phalcon_Session_Adapter, getIterator);
static PHP_METHOD(Phalcon_Session_Adapter, setId);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_setid, 0, 0, 1)
	ZEND_ARG_INFO(0, sid)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_session_adapter_method_entry[] = {
	PHP_ME(Phalcon_Session_Adapter, __construct, arginfo_phalcon_session_adapter___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Session_Adapter, __destruct, arginfo___destruct, ZEND_ACC_PUBLIC | ZEND_ACC_DTOR)
	PHP_ME(Phalcon_Session_Adapter, start, arginfo_phalcon_session_adapterinterface_start, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, setOptions, arginfo_phalcon_session_adapterinterface_setoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, getOptions, arginfo_phalcon_session_adapterinterface_getoptions, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, get, arginfo_phalcon_session_adapterinterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, set, arginfo_phalcon_session_adapterinterface_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, has, arginfo_phalcon_session_adapterinterface_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, remove, arginfo_phalcon_session_adapterinterface_remove, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, getId, arginfo_phalcon_session_adapterinterface_getid, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, isStarted, arginfo_phalcon_session_adapterinterface_isstarted, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, destroy, arginfo_phalcon_session_adapterinterface_destroy, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, __get, arginfo___getref, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, __set, set, arginfo___set, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, __isset, has, arginfo___isset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, __unset, remove, arginfo___unset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, offsetGet, __get, arginfo_arrayaccess_offsetgetref, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, offsetSet, set, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, offsetExists, has, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Adapter, offsetUnset, remove, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, count, arginfo_countable_count, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, getIterator, arginfo_iteratoraggregate_getiterator, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter, setId, arginfo_phalcon_session_adapter_setid, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

static zval** phalcon_session_adapter_get_property_ptr_ptr_internal(zval *object, zval *member, int type TSRMLS_DC)
{
	zval *unique_id, *_SESSION, key = zval_used_for_init, *pkey = &key;
	zval **value;

	unique_id = phalcon_fetch_nproperty_this(object, SL("_uniqueId"), PH_NOISY TSRMLS_CC);

	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (Z_TYPE_P(_SESSION) != IS_ARRAY) {
		if (type == BP_VAR_R || type == BP_VAR_RW) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Session is not started or $_SESSION is invalid");
		}
		return (type == BP_VAR_W || type == BP_VAR_RW) ? &EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);
	}

	phalcon_concat_vv(&pkey, unique_id, member, 0 TSRMLS_CC);
	value = phalcon_hash_get(Z_ARRVAL_P(_SESSION), pkey, type);
	zval_dtor(&key);

	return value;
}

static int phalcon_session_adapter_has_property_internal(zval *object, zval *member, int has_set_exists TSRMLS_DC)
{
	zval *unique_id, *_SESSION, **tmp;
	zval key = zval_used_for_init, *pkey = &key;

	unique_id = phalcon_fetch_nproperty_this(object, SL("_uniqueId"), PH_NOISY TSRMLS_CC);

	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (Z_TYPE_P(_SESSION) != IS_ARRAY) {
		return 0;
	}

	phalcon_concat_vv(&pkey, unique_id, member, 0 TSRMLS_CC);
	tmp = phalcon_hash_get(Z_ARRVAL_P(_SESSION), pkey, BP_VAR_NA);
	zval_dtor(&key);

	if (!tmp) {
		return 0;
	}

	if (0 == has_set_exists) {
		return Z_TYPE_PP(tmp) != IS_NULL;
	}

	if (1 == has_set_exists) {
		return zend_is_true(*tmp);
	}

	return 1;
}

static void phalcon_session_adapter_write_property_internal(zval *object, zval *member, zval *value TSRMLS_DC)
{
	zval *unique_id, *_SESSION;
	zval key = zval_used_for_init, *pkey = &key;

	unique_id = phalcon_fetch_nproperty_this(object, SL("_uniqueId"), PH_NOISY TSRMLS_CC);

	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (Z_TYPE_P(_SESSION) == IS_ARRAY) {
		phalcon_concat_vv(&pkey, unique_id, member, 0 TSRMLS_CC);
		Z_ADDREF_P(value);
		phalcon_hash_update_or_insert(Z_ARRVAL_P(_SESSION), pkey, value);
		zval_dtor(&key);
	}
}

static void phalcon_session_adapter_unset_property_internal(zval *object, zval *member TSRMLS_DC)
{
	zval *unique_id, *_SESSION;
	zval key = zval_used_for_init, *pkey = &key;

	unique_id = phalcon_fetch_nproperty_this(object, SL("_uniqueId"), PH_NOISY TSRMLS_CC);

	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (Z_TYPE_P(_SESSION) == IS_ARRAY) {
		phalcon_concat_vv(&pkey, unique_id, member, 0 TSRMLS_CC);
		phalcon_hash_unset(Z_ARRVAL_P(_SESSION), pkey);
		zval_dtor(&key);
	}
}

#if PHP_VERSION_ID < 50500

static zval** phalcon_session_adapter_get_property_ptr_ptr(zval *object, zval *member ZLK_DC TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->get_property_ptr_ptr(object, member ZLK_CC TSRMLS_CC);
	}

	return phalcon_session_adapter_get_property_ptr_ptr_internal(object, member, BP_VAR_W TSRMLS_CC);
}

#else

static zval** phalcon_session_adapter_get_property_ptr_ptr(zval *object, zval *member, int type ZLK_DC TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->get_property_ptr_ptr(object, member, type ZLK_CC TSRMLS_CC);
	}

	return phalcon_session_adapter_get_property_ptr_ptr_internal(object, member, type TSRMLS_CC);
}

#endif

static int phalcon_session_adapter_has_property(zval *object, zval *member, int has_set_exists ZLK_DC TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_property(object, member, has_set_exists ZLK_CC TSRMLS_CC);
	}

	return phalcon_session_adapter_has_property_internal(object, member, has_set_exists TSRMLS_CC);
}

static void phalcon_session_adapter_write_property(zval *object, zval *member, zval *value ZLK_DC TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object)) || phalcon_isset_property_zval(object, member TSRMLS_CC)) {
		zend_get_std_object_handlers()->write_property(object, member, value ZLK_CC TSRMLS_CC);
	}
	else {
		phalcon_session_adapter_write_property_internal(object, member, value TSRMLS_CC);
	}
}

static void phalcon_session_adapter_unset_property(zval *object, zval *member ZLK_DC TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->unset_property(object, member ZLK_CC TSRMLS_CC);
	}
	else {
		phalcon_session_adapter_unset_property_internal(object, member TSRMLS_CC);
	}
}

static zval* phalcon_session_adapter_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval **ret;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	if (UNEXPECTED(!offset)) {
		return EG(uninitialized_zval_ptr);
	}

	ret = phalcon_session_adapter_get_property_ptr_ptr_internal(object, offset, type TSRMLS_CC);

	/* For write context we need to return a reference */
	if ((type == BP_VAR_W || type == BP_VAR_RW || type == BP_VAR_UNSET) && !Z_ISREF_PP(ret)) {
		if (Z_REFCOUNT_PP(ret) > 1) {
			zval *newval;

			MAKE_STD_ZVAL(newval);
			*newval = **ret;
			zval_copy_ctor(newval);
			Z_SET_REFCOUNT_P(newval, 1);

			Z_DELREF_PP(ret);
			*ret = newval;
		}

		Z_SET_ISREF_PP(ret);
	}

	return *ret;
}

static void phalcon_session_adapter_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->write_dimension(object, offset, value TSRMLS_CC);
		return;
	}

	if (!offset) {
		offset = PHALCON_GLOBAL(z_null);
	}

	phalcon_session_adapter_write_property_internal(object, offset, value TSRMLS_CC);
}

static int phalcon_session_adapter_has_dimension(zval *object, zval *member, int check_empty TSRMLS_DC)
{
	zval **tmp;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_dimension(object, member, check_empty TSRMLS_CC);
	}

	tmp = phalcon_session_adapter_get_property_ptr_ptr_internal(object, member, BP_VAR_NA TSRMLS_CC);

	if (!tmp) {
		return 0;
	}

	if (0 == check_empty) {
		return Z_TYPE_PP(tmp) != IS_NULL;
	}

	if (1 == check_empty) {
		return zend_is_true(*tmp);
	}

	return 1;
}

static void phalcon_session_adapter_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->unset_dimension(object, offset TSRMLS_CC);
		return;
	}

	phalcon_session_adapter_unset_property_internal(object, offset TSRMLS_CC);
}

static int phalcon_session_adapter_count_elements(zval *object, long *count TSRMLS_DC)
{
	int res;
	zval *cnt = NULL;

	if (is_phalcon_class(Z_OBJCE_P(object))) {
		zval *_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
		if (Z_TYPE_P(_SESSION) == IS_ARRAY) {
			*count = zend_hash_num_elements(Z_ARRVAL_P(_SESSION));
			return SUCCESS;
		}

		return FAILURE;
	}

	res = phalcon_call_method(&cnt, object, "count", 0, NULL TSRMLS_CC);
	if (res == SUCCESS) {
		*count = (Z_TYPE_P(cnt) == IS_LONG) ? Z_LVAL_P(cnt) : phalcon_get_intval(cnt);
		zval_ptr_dtor(&cnt);
	}

	return res;
}

static zend_object_value phalcon_session_adapter_object_ctor(zend_class_entry *ce TSRMLS_DC)
{
	zend_object *obj = emalloc(sizeof(zend_object));
	zend_object_value retval;

	zend_object_std_init(obj, ce TSRMLS_CC);
	object_properties_init(obj, ce);

	retval.handlers = &phalcon_session_adapter_object_handlers;
	retval.handle   = zend_objects_store_put(
		obj,
		(zend_objects_store_dtor_t)zend_objects_destroy_object,
		(zend_objects_free_object_storage_t)zend_objects_free_object_storage,
		NULL
		TSRMLS_CC
	);

	return retval;
}

static zend_object_iterator* phalcon_session_adapter_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)
{
	zval *iterator;
	zval *data;
	zval *params[1];
	zend_object_iterator *ret;

	data = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (Z_TYPE_P(data) != IS_ARRAY) {
		return NULL;
	}

	MAKE_STD_ZVAL(iterator);
	object_init_ex(iterator, spl_ce_ArrayIterator);
	params[0] = data;
	if (FAILURE == phalcon_call_method(NULL, iterator, "__construct", 1, params TSRMLS_CC)) {
		ret = NULL;
	}
	else if (Z_TYPE_P(iterator) == IS_OBJECT) {
		ret = spl_ce_ArrayIterator->get_iterator(spl_ce_ArrayIterator, iterator, by_ref TSRMLS_CC);
	}
	else {
		ret = NULL;
	}

	zval_ptr_dtor(&iterator);
	return ret;
}

PHALCON_INIT_CLASS(Phalcon_Session_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Session, Adapter, session_adapter, phalcon_session_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	phalcon_session_adapter_ce->create_object = phalcon_session_adapter_object_ctor;

	zend_declare_property_null(phalcon_session_adapter_ce, SL("_uniqueId"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_session_adapter_ce, SL("_started"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_adapter_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	phalcon_session_adapter_object_handlers = *zend_get_std_object_handlers();
	phalcon_session_adapter_object_handlers.get_property_ptr_ptr = phalcon_session_adapter_get_property_ptr_ptr;
	phalcon_session_adapter_object_handlers.has_property         = phalcon_session_adapter_has_property;
	phalcon_session_adapter_object_handlers.write_property       = phalcon_session_adapter_write_property;
	phalcon_session_adapter_object_handlers.unset_property       = phalcon_session_adapter_unset_property;
	phalcon_session_adapter_object_handlers.count_elements       = phalcon_session_adapter_count_elements;
	phalcon_session_adapter_object_handlers.read_dimension       = phalcon_session_adapter_read_dimension;
	phalcon_session_adapter_object_handlers.write_dimension      = phalcon_session_adapter_write_dimension;
	phalcon_session_adapter_object_handlers.has_dimension        = phalcon_session_adapter_has_dimension;
	phalcon_session_adapter_object_handlers.unset_dimension      = phalcon_session_adapter_unset_dimension;

	phalcon_session_adapter_ce->get_iterator = phalcon_session_adapter_get_iterator;

	zend_class_implements(
		phalcon_session_adapter_ce TSRMLS_CC, 4,
		phalcon_session_adapterinterface_ce,
		spl_ce_Countable,
		zend_ce_aggregate,
		zend_ce_arrayaccess
	);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Session_Adapter, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);

	if (options && Z_TYPE_P(options) == IS_ARRAY) {
		PHALCON_CALL_METHODW(NULL, this_ptr, "setoptions", options);
	}
}

static PHP_METHOD(Phalcon_Session_Adapter, __destruct) {

	zval *started;

	started = phalcon_fetch_nproperty_this(getThis(), SL("_started"), PH_NOISY TSRMLS_CC);
	if (zend_is_true(started)) {
		RETURN_ON_FAILURE(phalcon_session_write_close(TSRMLS_C));
		phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Session_Adapter, start){

	if (!SG(headers_sent)) {
		RETURN_ON_FAILURE(phalcon_session_start(TSRMLS_C));
		phalcon_update_property_bool(this_ptr, SL("_started"), 1 TSRMLS_CC);
		RETURN_TRUE;
	}

	RETURN_FALSE;
}

static PHP_METHOD(Phalcon_Session_Adapter, setOptions){

	zval *options, *unique_id;

	phalcon_fetch_params(0, 1, 0, &options);

	if (Z_TYPE_P(options) == IS_ARRAY) {
		if (phalcon_array_isset_string_fetch(&unique_id, options, SS("uniqueId"))) {
			phalcon_update_property_this_quick(this_ptr, SL("_uniqueId"), unique_id, 427461512UL TSRMLS_CC);
		}

		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Session_Adapter, getOptions){

	RETURN_MEMBER(getThis(), "_options");
}

static PHP_METHOD(Phalcon_Session_Adapter, get){

	zval *index, *default_value = NULL, *remove = NULL, *unique_id, *key, *_SESSION;
	zval *value;

	phalcon_fetch_params(0, 1, 2, &index, &default_value, &remove);
	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}

	if (!remove || !zend_is_true(remove)) {
		/* Fast path */
		zval **value = phalcon_session_adapter_get_property_ptr_ptr_internal(getThis(), index, BP_VAR_NA TSRMLS_CC);
		if (value) {
			RETURN_ZVAL(*value, 1, 0);
		}

		RETURN_ZVAL(default_value, 1, 0);
	}

	unique_id = phalcon_fetch_nproperty_this(this_ptr, SL("_uniqueId"), PH_NOISY TSRMLS_CC);

	PHALCON_MM_GROW();
	PHALCON_INIT_VAR(key);
	PHALCON_CONCAT_VV(key, unique_id, index);

	_SESSION = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, _SESSION, key)) {
		RETVAL_ZVAL(value, 1, 0);
		phalcon_array_unset(&_SESSION, key, 0);
	}
	else {
		RETVAL_ZVAL(default_value, 1, 0);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Adapter, set){

	zval *index, *value;

	phalcon_fetch_params(0, 2, 0, &index, &value);
	phalcon_session_adapter_write_property_internal(getThis(), index, value TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Session_Adapter, has){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	RETURN_BOOL(phalcon_session_adapter_has_property_internal(getThis(), index, 2 TSRMLS_CC));
}

static PHP_METHOD(Phalcon_Session_Adapter, remove){

	zval *index;

	phalcon_fetch_params(0, 1, 0, &index);
	phalcon_session_adapter_unset_property_internal(getThis(), index TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Session_Adapter, getId){

	RETURN_ON_FAILURE(phalcon_get_session_id(return_value, return_value_ptr TSRMLS_CC));
}

static PHP_METHOD(Phalcon_Session_Adapter, isStarted){


	RETURN_MEMBER_QUICK(this_ptr, "_started", 433407867UL);
}

static PHP_METHOD(Phalcon_Session_Adapter, destroy){

	phalcon_update_property_bool(this_ptr, SL("_started"), 0 TSRMLS_CC);
	RETURN_ON_FAILURE(phalcon_session_destroy(TSRMLS_C));
	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Session_Adapter, __get)
{
	zval **property, **retval;

	assert(return_value_ptr != NULL);

	phalcon_fetch_params_ex(1, 0, &property);
	retval = phalcon_session_adapter_get_property_ptr_ptr_internal(getThis(), *property, BP_VAR_W TSRMLS_CC);

	zval_ptr_dtor(return_value_ptr);
	*return_value_ptr = *retval;
	Z_ADDREF_PP(return_value_ptr);
	Z_SET_ISREF_PP(return_value_ptr);
}

static PHP_METHOD(Phalcon_Session_Adapter, count)
{
	long int count;

	if (SUCCESS == phalcon_session_adapter_count_elements(getThis(), &count TSRMLS_CC)) {
		RETURN_LONG(count);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Session_Adapter, getIterator)
{
	zval *data;

	data = phalcon_get_global(SS("_SESSION") TSRMLS_CC);
	object_init_ex(return_value, spl_ce_ArrayIterator);
	PHALCON_CALL_METHODW(NULL, return_value, "__construct", data);
}

static PHP_METHOD(Phalcon_Session_Adapter, setId){

	zval *sid;

	phalcon_fetch_params(0, 1, 0, &sid);

	RETURN_ON_FAILURE(phalcon_set_session_id(sid TSRMLS_CC));
}





zend_class_entry *phalcon_session_adapterinterface_ce;

static const zend_function_entry phalcon_session_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, start, arginfo_phalcon_session_adapterinterface_start)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, setOptions, arginfo_phalcon_session_adapterinterface_setoptions)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, getOptions, arginfo_phalcon_session_adapterinterface_getoptions)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, get, arginfo_phalcon_session_adapterinterface_get)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, set, arginfo_phalcon_session_adapterinterface_set)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, has, arginfo_phalcon_session_adapterinterface_has)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, remove, arginfo_phalcon_session_adapterinterface_remove)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, getId, arginfo_phalcon_session_adapterinterface_getid)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, isStarted, arginfo_phalcon_session_adapterinterface_isstarted)
	PHP_ABSTRACT_ME(Phalcon_Session_AdapterInterface, destroy, arginfo_phalcon_session_adapterinterface_destroy)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Session_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Session, AdapterInterface, session_adapterinterface, phalcon_session_adapterinterface_method_entry);

	return SUCCESS;
}















#include <ext/spl/spl_array.h>



zend_class_entry *phalcon_session_bag_ce;

static PHP_METHOD(Phalcon_Session_Bag, __construct);
static PHP_METHOD(Phalcon_Session_Bag, setDI);
static PHP_METHOD(Phalcon_Session_Bag, getDI);
static PHP_METHOD(Phalcon_Session_Bag, initialize);
static PHP_METHOD(Phalcon_Session_Bag, destroy);
static PHP_METHOD(Phalcon_Session_Bag, set);
static PHP_METHOD(Phalcon_Session_Bag, get);
static PHP_METHOD(Phalcon_Session_Bag, has);
static PHP_METHOD(Phalcon_Session_Bag, __get);
static PHP_METHOD(Phalcon_Session_Bag, remove);
static PHP_METHOD(Phalcon_Session_Bag, getIterator);
static PHP_METHOD(Phalcon_Session_Bag, count);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_bag___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, name)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_session_bag_method_entry[] = {
	PHP_ME(Phalcon_Session_Bag, __construct, arginfo_phalcon_session_bag___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Session_Bag, setDI, arginfo_phalcon_di_injectionawareinterface_setdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, getDI, arginfo_phalcon_di_injectionawareinterface_getdi, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, initialize, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, destroy, arginfo_empty, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, set, arginfo_phalcon_session_baginterface_set, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, get, arginfo_phalcon_session_baginterface_get, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, has, arginfo_phalcon_session_baginterface_has, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, remove, arginfo_phalcon_session_baginterface_remove, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, getIterator, arginfo_iteratoraggregate_getiterator, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, __get, arginfo___getref, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, __set, set, arginfo___set, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, __isset, has, arginfo___isset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, __unset, remove, arginfo___unset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, offsetGet, __get, arginfo_arrayaccess_offsetgetref, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, offsetSet, set, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, offsetExists, has, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_MALIAS(Phalcon_Session_Bag, offsetUnset, remove, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Bag, count, arginfo_countable_count, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

static int phalcon_session_bag_maybe_initialize(zval *this_ptr TSRMLS_DC)
{
	zval *initialized;

	initialized = phalcon_fetch_nproperty_this(this_ptr, SL("_initialized"), PH_NOISY TSRMLS_CC);
	if (PHALCON_IS_FALSE(initialized)) {
		return phalcon_call_method(NULL, this_ptr, "initialize", 0, NULL TSRMLS_CC);
	}

	return SUCCESS;
}

static zend_object_iterator* phalcon_session_bag_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)
{
	zval *iterator;
	zval *data;
	zval *params[1];
	zend_object_iterator *ret;

	if (FAILURE == phalcon_session_bag_maybe_initialize(object TSRMLS_CC)) {
		return NULL;
	}

	data = phalcon_fetch_nproperty_this(object, SL("_data"), PH_NOISY TSRMLS_CC);

	MAKE_STD_ZVAL(iterator);
	object_init_ex(iterator, spl_ce_ArrayIterator);
	params[0] = data;
	if (FAILURE == phalcon_call_method(NULL, iterator, "__construct", 1, params TSRMLS_CC)) {
		ret = NULL;
	}
	else if (Z_TYPE_P(iterator) == IS_OBJECT) {
		ret = spl_ce_ArrayIterator->get_iterator(spl_ce_ArrayIterator, iterator, by_ref TSRMLS_CC);
	}
	else {
		ret = NULL;
	}

	zval_ptr_dtor(&iterator);
	return ret;
}

PHALCON_INIT_CLASS(Phalcon_Session_Bag){

	PHALCON_REGISTER_CLASS(Phalcon\\Session, Bag, session_bag, phalcon_session_bag_method_entry, 0);

	zend_declare_property_null(phalcon_session_bag_ce, SL("_dependencyInjector"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_name"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_data"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_bool(phalcon_session_bag_ce, SL("_initialized"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_bag_ce, SL("_session"), ZEND_ACC_PROTECTED TSRMLS_CC);

	phalcon_session_bag_ce->get_iterator = phalcon_session_bag_get_iterator;

	zend_class_implements(
		phalcon_session_bag_ce TSRMLS_CC, 5,
		phalcon_di_injectionawareinterface_ce,
		phalcon_session_baginterface_ce,
		zend_ce_aggregate,
		zend_ce_arrayaccess,
		spl_ce_Countable
	);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Session_Bag, __construct){

	zval **name;

	phalcon_fetch_params_ex(1, 0, &name);
	PHALCON_ENSURE_IS_STRING(name);
	phalcon_update_property_this(this_ptr, SL("_name"), *name TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Session_Bag, setDI){

	zval *dependency_injector;

	phalcon_fetch_params(0, 1, 0, &dependency_injector);
	PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_session_exception_ce, 0);
	phalcon_update_property_this_quick(this_ptr, SL("_dependencyInjector"), dependency_injector, 765199457UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Session_Bag, getDI){


	RETURN_MEMBER_QUICK(this_ptr, "_dependencyInjector", 765199457UL);
}

static PHP_METHOD(Phalcon_Session_Bag, initialize){

	zval *session = NULL, *dependency_injector = NULL, *service;
	zval *name, **data, *tmp = NULL;

	PHALCON_MM_GROW();

	session = phalcon_fetch_nproperty_this(this_ptr, SL("_session"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(session) != IS_OBJECT) {
		dependency_injector = phalcon_fetch_nproperty_this(this_ptr, SL("_dependencyInjector"), PH_NOISY TSRMLS_CC);
		if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {

			dependency_injector = NULL;
			PHALCON_CALL_CE_STATIC(&dependency_injector, phalcon_di_ce, "getdefault");

			if (Z_TYPE_P(dependency_injector) != IS_OBJECT) {
				PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "A dependency injection object is required to access the 'session' service");
				return;
			}
		}

		PHALCON_VERIFY_INTERFACE_EX(dependency_injector, phalcon_diinterface_ce, phalcon_session_exception_ce, 1);

		PHALCON_INIT_VAR(service);
		PHALCON_ZVAL_MAYBE_INTERNED_STRING(service, phalcon_interned_session);

		session = NULL;
		PHALCON_CALL_METHOD(&session, dependency_injector, "getshared", service);
		PHALCON_VERIFY_INTERFACE(session, phalcon_session_adapterinterface_ce);
		phalcon_update_property_this_quick(this_ptr, SL("_session"), session, 3241463720UL TSRMLS_CC);
	}

	name = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);

	/*if (!nusphere_dbg_present) {
#if PHP_VERSION_ID < 50500
		data = Z_OBJ_HANDLER_P(session, get_property_ptr_ptr)(session, name ZLK_NULL_CC TSRMLS_CC);
#else
		data = Z_OBJ_HANDLER_P(session, get_property_ptr_ptr)(session, name, BP_VAR_W ZLK_NULL_CC TSRMLS_CC);
#endif
	}
	else {*/
		PHALCON_CALL_METHOD(&tmp, session, "__get", name);
		data = &tmp;
	//}

	if (Z_TYPE_PP(data) != IS_ARRAY) {
		zval *empty_array;
		PHALCON_ALLOC_GHOST_ZVAL(empty_array);
		array_init(empty_array);
		phalcon_update_property_this_quick(this_ptr, SL("_data"), empty_array, 3972126110UL TSRMLS_CC);
	}
	else {
		phalcon_update_property_this(this_ptr, SL("_data"), *data TSRMLS_CC);
	}

	phalcon_update_property_bool(this_ptr, SL("_initialized"), 1 TSRMLS_CC);
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Bag, destroy){

	zval *name, *session;

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	name    = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	session = phalcon_fetch_nproperty_this(this_ptr, SL("_session"), PH_NOISY TSRMLS_CC);

	/*if (!nusphere_dbg_present) {
		Z_OBJ_HANDLER_P(session, unset_property)(session, name ZLK_NULL_CC TSRMLS_CC);
	}
	else {*/
		PHALCON_CALL_METHODW(NULL, session, "__unset", name);
	//}
}

static PHP_METHOD(Phalcon_Session_Bag, set){

	zval *property, *value, *session, *name, *data;

	phalcon_fetch_params(0, 2, 0, &property, &value);

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	phalcon_update_property_array(this_ptr, SL("_data"), property, value TSRMLS_CC);

	name    = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
	data    = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	session = phalcon_fetch_nproperty_this(this_ptr, SL("_session"), PH_NOISY TSRMLS_CC);

	/*if (!nusphere_dbg_present) {
		Z_OBJ_HANDLER_P(session, write_property)(session, name, data ZLK_NULL_CC TSRMLS_CC);
	}
	else {*/
		PHALCON_CALL_METHODW(NULL, session, "__set", name, data);
	//}
}


static PHP_METHOD(Phalcon_Session_Bag, get){

	zval *property, *default_value = NULL;
	zval *data, *value;

	phalcon_fetch_params(0, 1, 1, &property, &default_value);

	if (!default_value) {
		default_value = PHALCON_GLOBAL(z_null);
	}

	/* Check first if the bag is initialized */
	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	/* Retrieve the data */
	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&value, data, property)) {
		RETURN_ZVAL(value, 1, 0);
	}

	RETURN_ZVAL(default_value, 1, 0);
}

static PHP_METHOD(Phalcon_Session_Bag, __get)
{
	zval *property, *data, *value;

	assert(return_value_ptr != NULL);

	phalcon_fetch_params(0, 1, 0, &property);

	/* Check first if the bag is initialized */
	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	/* Retrieve the data */
	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	zval_ptr_dtor(return_value_ptr);
	if (phalcon_array_isset_fetch(&value, data, property)) {
		*return_value_ptr = value;
	}
	else {
		zval *tmp, *name, *data, *session;

		ALLOC_INIT_ZVAL(tmp);
		Z_DELREF_P(tmp);
		phalcon_update_property_array(this_ptr, SL("_data"), property, tmp TSRMLS_CC);
		*return_value_ptr = tmp;

		name    = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
		data    = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
		session = phalcon_fetch_nproperty_this(this_ptr, SL("_session"), PH_NOISY TSRMLS_CC);
		/*if (!nusphere_dbg_present) {
			Z_OBJ_HANDLER_P(session, write_property)(session, name, data ZLK_NULL_CC TSRMLS_CC);
		}
		else {*/
			PHALCON_CALL_METHODW(NULL, session, "__set", name, data);
		//}
	}

	Z_ADDREF_PP(return_value_ptr);
	Z_SET_ISREF_PP(return_value_ptr);
}


static PHP_METHOD(Phalcon_Session_Bag, has){

	zval *property, *data;

	phalcon_fetch_params(0, 1, 0, &property);

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(data, property));
}


static PHP_METHOD(Phalcon_Session_Bag, remove){

	zval *property, *data = NULL, *name, *session;

	phalcon_fetch_params(0, 1, 0, &property);

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	data = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(data, property)) {
		phalcon_unset_property_array(this_ptr, SL("_data"), property TSRMLS_CC);

		data    = phalcon_fetch_nproperty_this(this_ptr, SL("_data"), PH_NOISY TSRMLS_CC);
		name    = phalcon_fetch_nproperty_this(this_ptr, SL("_name"), PH_NOISY TSRMLS_CC);
		session = phalcon_fetch_nproperty_this(this_ptr, SL("_session"), PH_NOISY TSRMLS_CC);

		/*if (!nusphere_dbg_present) {
			Z_OBJ_HANDLER_P(session, write_property)(session, name, data ZLK_NULL_CC TSRMLS_CC);
		}
		else {*/
			PHALCON_CALL_METHODW(NULL, session, "__set", name, data);
		//}

		RETURN_TRUE;
	}

	RETURN_FALSE;
}


static PHP_METHOD(Phalcon_Session_Bag, getIterator)
{
	zval *data;

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	data = phalcon_fetch_nproperty_this(getThis(), SL("_data"), PH_NOISY TSRMLS_CC);
	object_init_ex(return_value, spl_ce_ArrayIterator);
	PHALCON_CALL_METHODW(NULL, return_value, "__construct", data);
}

static PHP_METHOD(Phalcon_Session_Bag, count)
{
	zval *data;
	long int count;

	RETURN_ON_FAILURE(phalcon_session_bag_maybe_initialize(this_ptr TSRMLS_CC));

	data  = phalcon_fetch_nproperty_this(getThis(), SL("_data"), PH_NOISY TSRMLS_CC);
	count = (Z_TYPE_P(data) == IS_ARRAY) ? zend_hash_num_elements(Z_ARRVAL_P(data)) : 0;
	RETURN_LONG(count);
}





zend_class_entry *phalcon_session_baginterface_ce;

static const zend_function_entry phalcon_session_baginterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, initialize, NULL)
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, destroy, NULL)
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, set, arginfo_phalcon_session_baginterface_set)
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, get, arginfo_phalcon_session_baginterface_get)
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, has, arginfo_phalcon_session_baginterface_has)
	PHP_ABSTRACT_ME(Phalcon_Session_BagInterface, remove, arginfo_phalcon_session_baginterface_remove)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Session_BagInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Session, BagInterface, session_baginterface, phalcon_session_baginterface_method_entry);

	return SUCCESS;
}











zend_class_entry *phalcon_session_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Session_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session, Exception, session_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}





zend_class_entry *phalcon_session_adapter_files_ce;

PHALCON_INIT_CLASS(Phalcon_Session_Adapter_Files){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session\\Adapter, Files, session_adapter_files, phalcon_session_adapter_ce, NULL, 0);

	zend_class_implements(phalcon_session_adapter_files_ce TSRMLS_CC, 1, phalcon_session_adapterinterface_ce);

	return SUCCESS;
}





#ifdef PHALCON_USE_PHP_SESSION
#include <ext/session/php_session.h>
#endif


zend_class_entry *phalcon_session_adapter_libmemcached_ce;

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, __construct);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, open);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, close);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, read);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, write);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, destroy);
static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, gc);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_libmemcached___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_libmemcached_read, 0, 0, 1)
	ZEND_ARG_INFO(0, sessionId)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_libmemcached_write, 0, 0, 2)
	ZEND_ARG_INFO(0, sessionId)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_libmemcached_destroy, 0, 0, 0)
        ZEND_ARG_INFO(0, sessionId)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_session_adapter_libmemcached_method_entry[] = {
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, __construct, arginfo_phalcon_session_adapter_libmemcached___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, open, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, close, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, read, arginfo_phalcon_session_adapter_libmemcached_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, write, arginfo_phalcon_session_adapter_libmemcached_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, destroy, arginfo_phalcon_session_adapter_libmemcached_destroy, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Libmemcached, gc, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Session_Adapter_Libmemcached){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session\\Adapter, Libmemcached, session_adapter_libmemcached, phalcon_session_adapter_ce, phalcon_session_adapter_libmemcached_method_entry, 0);

	zend_declare_property_null(phalcon_session_adapter_libmemcached_ce, SL("_lifetime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_adapter_libmemcached_ce, SL("_libmemcached"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_session_adapter_libmemcached_ce TSRMLS_CC, 1, phalcon_session_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, __construct){

	zval *options;
	zval *servers, *client, *lifetime, *prefix;
	zval *frontend_data, *libmemcached, *option;
	zval *callable_open , *callable_close , *callable_read , *callable_write , *callable_destroy , *callable_gc;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "The options must be an array");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&servers, options, SS("servers"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "No servers given in options");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&client, options, SS("client"))) {
		client = NULL;
	}

	if (!phalcon_array_isset_string_fetch(&lifetime, options, SS("lifetime"))) {
		PHALCON_INIT_VAR(lifetime);
		ZVAL_LONG(lifetime, 8600);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_lifetime"), lifetime, 1624604307UL TSRMLS_CC);

	if (!phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
		PHALCON_INIT_VAR(prefix);
                ZVAL_EMPTY_STRING(prefix);
	}

	/* create libmemcached instance */
	PHALCON_INIT_VAR(option);
	array_init_size(option, 1);

	phalcon_array_update_string(&option, SL("lifetime"), lifetime, PH_COPY);

	PHALCON_INIT_VAR(frontend_data);
	object_init_ex(frontend_data, phalcon_cache_frontend_data_ce);

	PHALCON_CALL_METHOD(NULL, frontend_data, "__construct", option);

	PHALCON_INIT_NVAR(option);
	array_init(option);

	phalcon_array_update_string(&option, SL("servers"), servers, PH_COPY);
	if (client) {
		phalcon_array_update_string(&option, SL("client"), client, PH_COPY);
	}
	phalcon_array_update_string(&option, SL("prefix"), prefix, PH_COPY);

	PHALCON_INIT_VAR(libmemcached);
	object_init_ex(libmemcached, phalcon_cache_backend_libmemcached_ce);

	PHALCON_CALL_METHOD(NULL, libmemcached, "__construct", frontend_data, option);

	phalcon_update_property_this_quick(this_ptr, SL("_libmemcached"), libmemcached, 2592485970UL TSRMLS_CC);

	/* open callback */
	PHALCON_INIT_VAR(callable_open);
	array_init_size(callable_open, 2);
	phalcon_array_append(&callable_open, this_ptr, 0);
	phalcon_array_append_string(&callable_open, SL("open"), 0);

	/* close callback */
	PHALCON_INIT_VAR(callable_close);
	array_init_size(callable_close, 2);
	phalcon_array_append(&callable_close, this_ptr, 0);
	phalcon_array_append_string(&callable_close, SL("close"), 0);

	/* read callback */
	PHALCON_INIT_VAR(callable_read);
	array_init_size(callable_read, 2);
	phalcon_array_append(&callable_read, this_ptr, 0);
	phalcon_array_append_string(&callable_read, SL("read"), 0);

	/* write callback */
	PHALCON_INIT_VAR(callable_write);
	array_init_size(callable_write, 2);
	phalcon_array_append(&callable_write, this_ptr, 0);
	phalcon_array_append_string(&callable_write, SL("write"), 0);

	/* destroy callback */
	PHALCON_INIT_VAR(callable_destroy);
	array_init_size(callable_destroy, 2);
	phalcon_array_append(&callable_destroy, this_ptr, 0);
	phalcon_array_append_string(&callable_destroy, SL("destroy"), 0);

	/* gc callback */
	PHALCON_INIT_VAR(callable_gc);
	array_init_size(callable_gc, 2);
	phalcon_array_append(&callable_gc, this_ptr, 0);
	phalcon_array_append_string(&callable_gc, SL("gc"), 0);

	PHALCON_CALL_FUNCTION(NULL, "session_set_save_handler", callable_open, callable_close, callable_read, callable_write, callable_destroy, callable_gc);

	PHALCON_CALL_PARENT(NULL, phalcon_session_adapter_libmemcached_ce, this_ptr, "__construct", options);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, open){

	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, close){

	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, read){

	zval *sid;
	zval *lifetime, *libmemcached;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &sid);

	lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lifetime"), PH_NOISY TSRMLS_CC);
	libmemcached = phalcon_fetch_nproperty_this(this_ptr, SL("_libmemcached"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(libmemcached) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(libmemcached, "get", sid, lifetime);

		RETURN_MM();
	} else {
		RETURN_MM_FALSE;
	}
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, write){

	zval *sid, *data;
	zval *lifetime, *libmemcached;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &sid, &data);

	lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lifetime"), PH_NOISY TSRMLS_CC);
	libmemcached = phalcon_fetch_nproperty_this(this_ptr, SL("_libmemcached"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(libmemcached) == IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, libmemcached, "save", sid, data, lifetime);	
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, destroy){

	zval *sid = NULL;
	zval *libmemcached;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &sid);

	if (!sid) {
		PHALCON_INIT_VAR(sid);
		PHALCON_CALL_SELF(&sid, "getid");
	}

	libmemcached = phalcon_fetch_nproperty_this(this_ptr, SL("_libmemcached"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(libmemcached) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(libmemcached, "delete", sid);

		RETURN_MM();
	} else {
		RETURN_MM_FALSE;
	}
}

static PHP_METHOD(Phalcon_Session_Adapter_Libmemcached, gc){

	RETURN_TRUE;
}






#ifdef PHALCON_USE_PHP_SESSION
#include <ext/session/php_session.h>
#endif


zend_class_entry *phalcon_session_adapter_memcache_ce;

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, __construct);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, open);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, close);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, read);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, write);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, destroy);
static PHP_METHOD(Phalcon_Session_Adapter_Memcache, gc);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_memcache___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_memcache_read, 0, 0, 1)
	ZEND_ARG_INFO(0, sessionId)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_memcache_write, 0, 0, 2)
	ZEND_ARG_INFO(0, sessionId)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_session_adapter_memcache_destroy, 0, 0, 0)
        ZEND_ARG_INFO(0, sessionId)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_session_adapter_memcache_method_entry[] = {
	PHP_ME(Phalcon_Session_Adapter_Memcache, __construct, arginfo_phalcon_session_adapter_memcache___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Session_Adapter_Memcache, open, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Memcache, close, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Memcache, read, arginfo_phalcon_session_adapter_memcache_read, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Memcache, write, arginfo_phalcon_session_adapter_memcache_write, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Memcache, destroy, arginfo_phalcon_session_adapter_memcache_destroy, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Session_Adapter_Memcache, gc, NULL, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Session_Adapter_Memcache){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Session\\Adapter, Memcache, session_adapter_memcache, phalcon_session_adapter_ce, phalcon_session_adapter_memcache_method_entry, 0);

	zend_declare_property_null(phalcon_session_adapter_memcache_ce, SL("_lifetime"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_session_adapter_memcache_ce, SL("_memcache"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_session_adapter_memcache_ce TSRMLS_CC, 1, phalcon_session_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, __construct){

	zval *options;
	zval *host, *port, *lifetime, *persistent, *prefix;
	zval *frontend_data, *memcache, *option;
	zval *callable_open , *callable_close , *callable_read , *callable_write , *callable_destroy , *callable_gc;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "The options must be an array");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&host, options, SS("host"))) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_session_exception_ce, "No session host given in options");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&port, options, SS("port"))) {
		PHALCON_INIT_VAR(port);
		ZVAL_LONG(port, 11211);
	}

	if (!phalcon_array_isset_string_fetch(&lifetime, options, SS("lifetime"))) {
		PHALCON_INIT_VAR(lifetime);
		ZVAL_LONG(lifetime, 8600);
	}

	phalcon_update_property_this_quick(this_ptr, SL("_lifetime"), lifetime, 1624604307UL TSRMLS_CC);

	if (!phalcon_array_isset_string_fetch(&persistent, options, SS("persistent"))) {
		PHALCON_INIT_VAR(persistent);
		ZVAL_FALSE(persistent);
	}

	if (!phalcon_array_isset_string_fetch(&prefix, options, SS("prefix"))) {
		PHALCON_INIT_VAR(prefix);
		ZVAL_EMPTY_STRING(prefix);
	}

	/* create memcache instance */
	PHALCON_INIT_VAR(option);
	array_init_size(option, 1);

	phalcon_array_update_string(&option, SL("lifetime"), lifetime, PH_COPY);

	PHALCON_INIT_VAR(frontend_data);
	object_init_ex(frontend_data, phalcon_cache_frontend_data_ce);

	PHALCON_CALL_METHOD(NULL, frontend_data, "__construct", option);

	PHALCON_INIT_NVAR(option);
	array_init_size(option, 3);

	phalcon_array_update_string(&option, SL("host"), host, PH_COPY);
	phalcon_array_update_string(&option, SL("port"), port, PH_COPY);
	phalcon_array_update_string(&option, SL("persistent"), persistent, PH_COPY);
	phalcon_array_update_string(&option, SL("prefix"), prefix, PH_COPY);

	PHALCON_INIT_VAR(memcache);
	object_init_ex(memcache, phalcon_cache_backend_memcache_ce);

	PHALCON_CALL_METHOD(NULL, memcache, "__construct", frontend_data, option);

	phalcon_update_property_this_quick(this_ptr, SL("_memcache"), memcache, 958186231UL TSRMLS_CC);

	/* open callback */
	PHALCON_INIT_VAR(callable_open);
	array_init_size(callable_open, 2);
	phalcon_array_append(&callable_open, this_ptr, 0);
	phalcon_array_append_string(&callable_open, SL("open"), 0);

	/* close callback */
	PHALCON_INIT_VAR(callable_close);
	array_init_size(callable_close, 2);
	phalcon_array_append(&callable_close, this_ptr, 0);
	phalcon_array_append_string(&callable_close, SL("close"), 0);

	/* read callback */
	PHALCON_INIT_VAR(callable_read);
	array_init_size(callable_read, 2);
	phalcon_array_append(&callable_read, this_ptr, 0);
	phalcon_array_append_string(&callable_read, SL("read"), 0);

	/* write callback */
	PHALCON_INIT_VAR(callable_write);
	array_init_size(callable_write, 2);
	phalcon_array_append(&callable_write, this_ptr, 0);
	phalcon_array_append_string(&callable_write, SL("write"), 0);

	/* destroy callback */
	PHALCON_INIT_VAR(callable_destroy);
	array_init_size(callable_destroy, 2);
	phalcon_array_append(&callable_destroy, this_ptr, 0);
	phalcon_array_append_string(&callable_destroy, SL("destroy"), 0);

	/* gc callback */
	PHALCON_INIT_VAR(callable_gc);
	array_init_size(callable_gc, 2);
	phalcon_array_append(&callable_gc, this_ptr, 0);
	phalcon_array_append_string(&callable_gc, SL("gc"), 0);

	PHALCON_CALL_FUNCTION(NULL, "session_set_save_handler", callable_open, callable_close, callable_read, callable_write, callable_destroy, callable_gc);

	PHALCON_CALL_PARENT(NULL, phalcon_session_adapter_memcache_ce, this_ptr, "__construct", options);
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, open){

	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, close){

	RETURN_TRUE;
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, read){

	zval *sid;
	zval *lifetime, *memcache;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &sid);

	lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lifetime"), PH_NOISY TSRMLS_CC);
	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(memcache) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(memcache, "get", sid, lifetime);

		RETURN_MM();	
	} else {
		RETURN_MM_FALSE;
	}
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, write){

	zval *sid, *data;
	zval *lifetime, *memcache;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &sid, &data);

	lifetime = phalcon_fetch_nproperty_this(this_ptr, SL("_lifetime"), PH_NOISY TSRMLS_CC);
	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(memcache) == IS_OBJECT) {
		PHALCON_CALL_METHOD(NULL, memcache, "save", sid, data, lifetime);
	}

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, destroy){

	zval *sid = NULL;
	zval *memcache;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 0, 1, &sid);

	if (!sid) {
		PHALCON_INIT_VAR(sid);
		PHALCON_CALL_SELF(&sid, "getid");
	}

	memcache = phalcon_fetch_nproperty_this(this_ptr, SL("_memcache"), PH_NOISY TSRMLS_CC);

	if (Z_TYPE_P(memcache) == IS_OBJECT) {
		PHALCON_RETURN_CALL_METHOD(memcache, "delete", sid);

		RETURN_MM();
	} else {
		RETURN_MM_FALSE;
	}
}

static PHP_METHOD(Phalcon_Session_Adapter_Memcache, gc){

	RETURN_TRUE;
}







zend_class_entry *phalcon_tag_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Tag_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Tag, Exception, tag_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_tag_select_ce;

static PHP_METHOD(Phalcon_Tag_Select, selectField);
static PHP_METHOD(Phalcon_Tag_Select, _optionsFromResultset);
static PHP_METHOD(Phalcon_Tag_Select, _optionsFromArray);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_tag_select_selectfield, 0, 0, 1)
	ZEND_ARG_INFO(0, parameters)
	ZEND_ARG_INFO(0, data)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_tag_select_method_entry[] = {
	PHP_ME(Phalcon_Tag_Select, selectField, arginfo_phalcon_tag_select_selectfield, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag_Select, _optionsFromResultset, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_ME(Phalcon_Tag_Select, _optionsFromArray, NULL, ZEND_ACC_PROTECTED|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Tag_Select){

	PHALCON_REGISTER_CLASS(Phalcon\\Tag, Select, tag_select, phalcon_tag_select_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Tag_Select, selectField){

	zval *parameters, *data = NULL, *params = NULL, *id = NULL, *name, *value = NULL;
	zval *use_empty = NULL, *empty_value = NULL, *empty_text = NULL, *code;
	zval *close_option, *options = NULL, *using = NULL;
	zval *resultset_options = NULL, *array_options = NULL;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 1, &parameters, &data);
	
	if (!data) {
		data = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(parameters) != IS_ARRAY) { 
		PHALCON_INIT_VAR(params);
		array_init_size(params, 2);
		phalcon_array_append(&params, parameters, 0);
		phalcon_array_append(&params, data, 0);
	} else {
		PHALCON_CPY_WRT(params, parameters);
	}
	
	if (!phalcon_array_isset_long(params, 0)) {
		PHALCON_OBS_VAR(id);
		phalcon_array_fetch_quick_string(&id, params, SS("id"), 193494642UL, PH_NOISY);
		phalcon_array_update_long(&params, 0, id, PH_COPY | PH_SEPARATE);
	}
	
	PHALCON_OBS_NVAR(id);
	phalcon_array_fetch_long(&id, params, 0, PH_NOISY);
	if (!phalcon_array_isset_quick_string(params, SS("name"), 268211462UL)) {
		phalcon_array_update_string(&params, SL("name"), id, PH_COPY | PH_SEPARATE);
	} else {
		PHALCON_OBS_VAR(name);
		phalcon_array_fetch_quick_string(&name, params, SS("name"), 268211462UL, PH_NOISY);
		if (!zend_is_true(name)) {
			phalcon_array_update_string(&params, SL("name"), id, PH_COPY | PH_SEPARATE);
		}
	}
	
	if (!phalcon_memnstr_str(id, SL("["))) {
		if (!phalcon_array_isset_quick_string(params, SS("id"), 193494642UL)) {
			phalcon_array_update_string(&params, SL("id"), id, PH_COPY | PH_SEPARATE);
		}
	}
	
	if (!phalcon_array_isset_quick_string(params, SS("value"), 574111618UL)) {
		PHALCON_CALL_CE_STATIC(&value, phalcon_tag_ce, "getvalue", id, params);
	} else {
		PHALCON_OBS_VAR(value);
		phalcon_array_fetch_quick_string(&value, params, SS("value"), 574111618UL, PH_NOISY);
		phalcon_array_unset_string(&params, SS("value"), PH_SEPARATE);
	}
	
	PHALCON_INIT_VAR(use_empty);
	ZVAL_FALSE(use_empty);
	if (phalcon_array_isset_quick_string(params, SS("useEmpty"), 1479578401UL)) {
		if (!phalcon_array_isset_quick_string(params, SS("emptyValue"), 2008930769UL)) {
			PHALCON_INIT_VAR(empty_value);
			ZVAL_EMPTY_STRING(empty_value);
		} else {
			PHALCON_OBS_NVAR(empty_value);
			phalcon_array_fetch_quick_string(&empty_value, params, SS("emptyValue"), 2008930769UL, PH_NOISY);
			phalcon_array_unset_string(&params, SS("emptyValue"), PH_SEPARATE);
		}
		if (!phalcon_array_isset_quick_string(params, SS("emptyText"), 3312424633UL)) {
			PHALCON_INIT_VAR(empty_text);
			ZVAL_STRING(empty_text, "Choose...", 1);
		} else {
			PHALCON_OBS_NVAR(empty_text);
			phalcon_array_fetch_quick_string(&empty_text, params, SS("emptyText"), 3312424633UL, PH_NOISY);
			phalcon_array_unset_string(&params, SS("emptyText"), PH_SEPARATE);
		}
	
		PHALCON_OBS_NVAR(use_empty);
		phalcon_array_fetch_quick_string(&use_empty, params, SS("useEmpty"), 1479578401UL, PH_NOISY);
		phalcon_array_unset_string(&params, SS("useEmpty"), PH_SEPARATE);
	}
	
	if (phalcon_array_isset_string_fetch(&using, params, SS("using"))) {
		phalcon_array_unset_string(&params, SS("using"), PH_SEPARATE);
	}

	PHALCON_INIT_VAR(code);
	ZVAL_STRING(code, "<select", 1);
	{
		zend_class_entry *scope = EG(scope);
		EG(scope) = phalcon_tag_ce;
		phalcon_tag_render_attributes(code, params TSRMLS_CC);
		EG(scope) = scope;
	}
	
	phalcon_concat_self_str(&code, SL(">" PHP_EOL) TSRMLS_CC);
	
	PHALCON_INIT_VAR(close_option);
	ZVAL_STRING(close_option, "</option>" PHP_EOL, 1);
	if (zend_is_true(use_empty)) {
		PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", empty_value, "\">", empty_text, close_option);
	}
	
	if (phalcon_array_isset_long(params, 1)) {
		PHALCON_OBS_VAR(options);
		phalcon_array_fetch_long(&options, params, 1, PH_NOISY);
	} else {
		PHALCON_CPY_WRT(options, data);
	}

	if (Z_TYPE_P(options) == IS_OBJECT) {
		if (using == NULL) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter is required");
			return;
		}

		if (Z_TYPE_P(using) != IS_ARRAY && Z_TYPE_P(using) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "The 'using' parameter should be an Array");
			return;
		}

		PHALCON_CALL_SELF(&resultset_options, "_optionsfromresultset", options, using, value, close_option);
		phalcon_concat_self(&code, resultset_options TSRMLS_CC);
	} else if (Z_TYPE_P(options) == IS_ARRAY) {
		PHALCON_CALL_SELF(&array_options, "_optionsfromarray", options, value, close_option);
		phalcon_concat_self(&code, array_options TSRMLS_CC);
	} else {
		PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Invalid data provided to SELECT helper");
		return;
	}
	
	phalcon_concat_self_str(&code, SL("</select>") TSRMLS_CC);
	
	RETURN_CTOR(code);
}

static PHP_METHOD(Phalcon_Tag_Select, _optionsFromResultset){

	zval *resultset, *using, *value, *close_option;
	zval *code, *params = NULL, *option = NULL, *using_zero = NULL, *using_one = NULL;
	zval *option_value = NULL, *option_text = NULL, *code_option = NULL;
	zval *r0 = NULL, *escaped;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 4, 0, &resultset, &using, &value, &close_option);
	
	PHALCON_INIT_VAR(code);
	ZVAL_EMPTY_STRING(code);
	
	PHALCON_INIT_VAR(params);
	/**/

	PHALCON_CALL_METHOD(NULL, resultset, "rewind");
	
	PHALCON_INIT_VAR(escaped);

	while (1) {
		PHALCON_CALL_METHOD(&r0, resultset, "valid");
		if (PHALCON_IS_NOT_FALSE(r0)) {
		} else {
			break;
		}
	
		PHALCON_CALL_METHOD(&option, resultset, "current");
		if (Z_TYPE_P(using) == IS_ARRAY) { 
	
			PHALCON_OBS_NVAR(using_zero);
			phalcon_array_fetch_long(&using_zero, using, 0, PH_NOISY);
	
			PHALCON_OBS_NVAR(using_one);
			phalcon_array_fetch_long(&using_one, using, 1, PH_NOISY);
			if (Z_TYPE_P(option) == IS_OBJECT) {
				if (phalcon_method_quick_exists_ex(option, SS("readattribute"), 95450773UL TSRMLS_CC) == SUCCESS) {
					PHALCON_CALL_METHOD(&option_value, option, "readattribute", using_zero);
	
					PHALCON_CALL_METHOD(&option_text, option, "readattribute", using_one);
				} else {
					PHALCON_OBS_NVAR(option_value);
					phalcon_read_property_zval(&option_value, option, using_zero, PH_NOISY TSRMLS_CC);
	
					PHALCON_OBS_NVAR(option_text);
					phalcon_read_property_zval(&option_text, option, using_one, PH_NOISY TSRMLS_CC);
				}
			} else {
				if (Z_TYPE_P(option) == IS_ARRAY) { 
					PHALCON_OBS_NVAR(option_value);
					phalcon_array_fetch(&option_value, option, using_zero, PH_NOISY);
	
					PHALCON_OBS_NVAR(option_text);
					phalcon_array_fetch(&option_text, option, using_one, PH_NOISY);
				} else {
					PHALCON_THROW_EXCEPTION_STR(phalcon_tag_exception_ce, "Resultset returned an invalid value");
					return;
				}
			}
	
			phalcon_htmlspecialchars(escaped, option_value, NULL, NULL TSRMLS_CC);
			if (Z_TYPE_P(value) == IS_ARRAY) { 
				if (phalcon_fast_in_array(option_value, value TSRMLS_CC)) {
					PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", escaped, "\">", option_text, close_option);
				} else {
					PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", escaped, "\">", option_text, close_option);
				}
			} else {
				if (PHALCON_IS_EQUAL(option_value, value)) {
					PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", escaped, "\">", option_text, close_option);
				} else {
					PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", escaped, "\">", option_text, close_option);
				}
			}
		} else {
			if (Z_TYPE_P(using) == IS_OBJECT) {
				if (Z_TYPE_P(params) == IS_NULL) {
					PHALCON_INIT_NVAR(params);
					array_init(params);
				}
				phalcon_array_update_long(&params, 0, option, PH_COPY | PH_SEPARATE);

				PHALCON_INIT_NVAR(code_option);/**/
				PHALCON_CALL_USER_FUNC_ARRAY(code_option, using, params);
				phalcon_concat_self(&code, code_option TSRMLS_CC);
			}
		}
	
		PHALCON_CALL_METHOD(NULL, resultset, "next");
	}
	
	RETURN_CTOR(code);
}

static PHP_METHOD(Phalcon_Tag_Select, _optionsFromArray){

	zval *data, *value, *close_option, *code, *option_text = NULL;
	zval *option_value = NULL, *escaped, *array_options = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 3, 0, &data, &value, &close_option);
	
	PHALCON_INIT_VAR(code);
	ZVAL_EMPTY_STRING(code);
	
	phalcon_is_iterable(data, &ah0, &hp0, 0, 0);
	
	PHALCON_INIT_VAR(escaped);

	while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
		PHALCON_GET_HKEY(option_value, ah0, hp0);
		PHALCON_GET_HVALUE(option_text);

		if (Z_TYPE_P(option_text) == IS_ARRAY) {
			phalcon_htmlspecialchars(escaped, option_value, NULL, NULL TSRMLS_CC);

			PHALCON_CALL_SELF(&array_options, "_optionsfromarray", option_text, value, close_option);

			PHALCON_SCONCAT_SVSVS(code, "\t<optgroup label=\"", escaped, "\">" PHP_EOL, array_options, "\t</optgroup>" PHP_EOL);
		} else {
			phalcon_htmlspecialchars(escaped, option_value, NULL, NULL TSRMLS_CC);
		
			if (Z_TYPE_P(value) == IS_ARRAY) { 
				if (phalcon_fast_in_array(option_value, value TSRMLS_CC)) {
					PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", escaped, "\">", option_text, close_option);
				} else {
					PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", escaped, "\">", option_text, close_option);
				}
			} else {
				if (PHALCON_IS_EQUAL(option_value, value)) {
					PHALCON_SCONCAT_SVSVV(code, "\t<option selected=\"selected\" value=\"", escaped, "\">", option_text, close_option);
				} else {
					PHALCON_SCONCAT_SVSVV(code, "\t<option value=\"", escaped, "\">", option_text, close_option);
				}
			}
		}
		
		zval_dtor(escaped);
		ZVAL_NULL(escaped);
	
		zend_hash_move_forward_ex(ah0, &hp0);
	}
	
	RETURN_CTOR(code);
}






zend_class_entry *phalcon_translate_adapter_ce;

static PHP_METHOD(Phalcon_Translate_Adapter, __construct);
static PHP_METHOD(Phalcon_Translate_Adapter, _);
static PHP_METHOD(Phalcon_Translate_Adapter, offsetSet);
static PHP_METHOD(Phalcon_Translate_Adapter, offsetExists);
static PHP_METHOD(Phalcon_Translate_Adapter, offsetUnset);
static PHP_METHOD(Phalcon_Translate_Adapter, offsetGet);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_translate_adapter__, 0, 0, 1)
	ZEND_ARG_INFO(0, translateKey)
	ZEND_ARG_INFO(0, placeholders)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_translate_adapter_method_entry[] = {
	PHP_ME(Phalcon_Translate_Adapter, __construct, arginfo_empty, ZEND_ACC_PUBLIC | ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Translate_Adapter, _, arginfo_phalcon_translate_adapter__, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter, offsetSet, arginfo_arrayaccess_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter, offsetExists, arginfo_arrayaccess_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter, offsetUnset, arginfo_arrayaccess_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter, offsetGet, arginfo_arrayaccess_offsetget, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_STATIC zend_object_handlers phalcon_translate_adapter_object_handlers;

static zval* phalcon_translate_adapter_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval *ret = NULL;
	int status;
	zval *params[] = { offset, PHALCON_GLOBAL(z_null) };

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	status = phalcon_call_method(&ret, object, "query", 2, params TSRMLS_CC);
	return UNEXPECTED(status == FAILURE) ? NULL : ret;
}

static void phalcon_translate_adapter_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->write_dimension(object, offset, value TSRMLS_CC);
		return;
	}

	zend_throw_exception_ex(phalcon_translate_exception_ce, 0 TSRMLS_CC, "'%s' is an immutable ArrayAccess object", "Phalcon\\Translate\\Adapter");
}

static int phalcon_translate_adapter_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	zval *exists = NULL;
	int retval;
	zval *params[] = { offset };

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	if (FAILURE == phalcon_call_method(&exists, object, "exists", 1, params TSRMLS_CC)) {
		return 0;
	}

	retval = zend_is_true(exists);
	zval_ptr_dtor(&exists);
	return retval;
}

static void phalcon_translate_adapter_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->unset_dimension(object, offset TSRMLS_CC);
		return;
	}

	zend_throw_exception_ex(phalcon_translate_exception_ce, 0 TSRMLS_CC, "'%s' is an immutable ArrayAccess object", "Phalcon\\Translate\\Adapter");
}


PHALCON_INIT_CLASS(Phalcon_Translate_Adapter){

	PHALCON_REGISTER_CLASS(Phalcon\\Translate, Adapter, translate_adapter, phalcon_translate_adapter_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	phalcon_translate_adapter_object_handlers = *zend_get_std_object_handlers();
	phalcon_translate_adapter_object_handlers.read_dimension  = phalcon_translate_adapter_read_dimension;
	phalcon_translate_adapter_object_handlers.write_dimension = phalcon_translate_adapter_write_dimension;
	phalcon_translate_adapter_object_handlers.has_dimension   = phalcon_translate_adapter_has_dimension;
	phalcon_translate_adapter_object_handlers.unset_dimension = phalcon_translate_adapter_unset_dimension;

	zend_class_implements(phalcon_translate_adapter_ce TSRMLS_CC, 2, zend_ce_arrayaccess, phalcon_translate_adapterinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Translate_Adapter, __construct)
{
	Z_OBJ_HT_P(getThis()) = &phalcon_translate_adapter_object_handlers;
}
static PHP_METHOD(Phalcon_Translate_Adapter, _){

	zval *translate_key, *placeholders = NULL;

	phalcon_fetch_params(0, 1, 1, &translate_key, &placeholders);

	if (!placeholders) {
		placeholders = PHALCON_GLOBAL(z_null);
	}

	PHALCON_RETURN_CALL_METHODW(this_ptr, "query", translate_key, placeholders);
}

static PHP_METHOD(Phalcon_Translate_Adapter, offsetSet){

	zend_throw_exception_ex(phalcon_translate_exception_ce, 0 TSRMLS_CC, "'%s' is an immutable ArrayAccess object", "Phalcon\\Translate\\Adapter");
}

static PHP_METHOD(Phalcon_Translate_Adapter, offsetExists){

	zval **translate_key;
	int exists;

	phalcon_fetch_params_ex(1, 0, &translate_key);
	exists = phalcon_translate_adapter_has_dimension(getThis(), *translate_key, 1 TSRMLS_CC);
	RETURN_BOOL(exists);
}

static PHP_METHOD(Phalcon_Translate_Adapter, offsetUnset){

	zend_throw_exception_ex(phalcon_translate_exception_ce, 0 TSRMLS_CC, "'%s' is an immutable ArrayAccess object", "Phalcon\\Translate\\Adapter");
}

static PHP_METHOD(Phalcon_Translate_Adapter, offsetGet){

	zval **translate_key, *res;

	phalcon_fetch_params_ex(1, 0, &translate_key);
	res = phalcon_translate_adapter_read_dimension(getThis(), *translate_key, BP_VAR_R TSRMLS_CC);
	RETURN_ZVAL(res, 1, 0);
}






zend_class_entry *phalcon_translate_adapterinterface_ce;

static const zend_function_entry phalcon_translate_adapterinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Translate_AdapterInterface, query, arginfo_phalcon_translate_adapterinterface_query)
	PHP_ABSTRACT_ME(Phalcon_Translate_AdapterInterface, exists, arginfo_phalcon_translate_adapterinterface_exists)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Translate_AdapterInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Translate, AdapterInterface, translate_adapterinterface, phalcon_translate_adapterinterface_method_entry);

	return SUCCESS;
}









zend_class_entry *phalcon_translate_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Translate_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate, Exception, translate_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_translate_adapter_gettext_ce;

static zend_object_handlers phalcon_translate_adapter_gettext_object_handlers;

static zval* phalcon_translate_adapter_gettext_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval *translation = NULL, *params[1];
	uint32_t result;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	params[0] = offset;
	result = phalcon_call_func_aparams(&translation, SL("gettext"), 1, params TSRMLS_CC);

	if (result) {
		MAKE_STD_ZVAL(translation);
		ZVAL_NULL(translation)
	}

	return translation;
}

static int phalcon_translate_adapter_gettext_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	zval *translation = NULL, *params[1];
	uint32_t result;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	params[0] = offset;
	result = phalcon_call_func_aparams(&translation, SL("gettext"), 1, params TSRMLS_CC);

	if (result) {
		return 0;
	}

	return (1 == check_empty) ? Z_STRLEN_P(translation) : 1;
}

static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, __construct);
static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, query);
static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, exists);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_translate_adapter_gettext___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_translate_adapter_gettext_method_entry[] = {
	PHP_ME(Phalcon_Translate_Adapter_Gettext, __construct, arginfo_phalcon_translate_adapter_gettext___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Translate_Adapter_Gettext, query, arginfo_phalcon_translate_adapterinterface_query, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter_Gettext, exists, arginfo_phalcon_translate_adapterinterface_exists, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Translate_Adapter_Gettext){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate\\Adapter, Gettext, translate_adapter_gettext, phalcon_translate_adapter_ce, phalcon_translate_adapter_gettext_method_entry, 0);

	zend_declare_property_null(phalcon_translate_adapter_gettext_ce, SL("_locale"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_translate_adapter_gettext_ce, SL("_defaultDomain"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_translate_adapter_gettext_ce, SL("_directory"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_translate_adapter_gettext_ce TSRMLS_CC, 1, phalcon_translate_adapterinterface_ce);

	phalcon_translate_adapter_gettext_object_handlers                = phalcon_translate_adapter_object_handlers;
	phalcon_translate_adapter_gettext_object_handlers.read_dimension = phalcon_translate_adapter_gettext_read_dimension;
	phalcon_translate_adapter_gettext_object_handlers.has_dimension  = phalcon_translate_adapter_gettext_has_dimension;

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, __construct){

	zval *options, *locale, *constant, *default_domain, *directory, *setting, *key = NULL, *value = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Invalid options");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&locale, options, SS("locale"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Parameter \"locale\" is required");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&default_domain, options, SS("defaultDomain"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Parameter \"defaultDomain\" is required");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&directory, options, SS("directory"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Parameter \"directory\" is required");
		return;
	}

	phalcon_update_property_this_quick(this_ptr, SL("_locale"), locale, 2882931668UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_defaultDomain"), default_domain, 936162849UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_directory"), directory, 1197964537UL TSRMLS_CC);

	PHALCON_INIT_VAR(setting);
	PHALCON_CONCAT_SV(setting, "LC_ALL=", locale);
	PHALCON_CALL_FUNCTION(NULL, "putenv", setting);

	PHALCON_INIT_VAR(constant);
	if (zend_get_constant(SL("LC_ALL"), constant TSRMLS_CC)) {
		PHALCON_CALL_FUNCTION(NULL, "setlocale", constant, locale);
	}
	
	if (Z_TYPE_P(directory) == IS_ARRAY) {
		phalcon_is_iterable(directory, &ah0, &hp0, 0, 0);
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);

			PHALCON_CALL_FUNCTION(NULL, "bindtextdomain", key, value);

			zend_hash_move_forward_ex(ah0, &hp0);
		}
	} else {
		PHALCON_CALL_FUNCTION(NULL, "bindtextdomain", default_domain, directory);
	}

	PHALCON_CALL_FUNCTION(NULL, "textdomain", default_domain);

	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, query){

	zval *index, *placeholders = NULL, *domain = NULL;
	zval *translation = NULL, *key = NULL, *value = NULL, *key_placeholder = NULL, *replaced = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 2, &index, &placeholders, &domain);
	
	if (!domain) {
		PHALCON_CALL_FUNCTION(&translation, "gettext", index);
	} else {
		PHALCON_CALL_FUNCTION(&translation, "dgettext", domain, index);
	}

	if (placeholders && Z_TYPE_P(placeholders) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(placeholders))) {
		phalcon_is_iterable(placeholders, &ah0, &hp0, 0, 0);
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(value);

			PHALCON_INIT_NVAR(key_placeholder);
			PHALCON_CONCAT_SVS(key_placeholder, "%", key, "%");

			PHALCON_INIT_NVAR(replaced);
			phalcon_fast_str_replace(replaced, key_placeholder, value, translation);

			PHALCON_CPY_WRT(translation, replaced);

			zend_hash_move_forward_ex(ah0, &hp0);
		}
	}

	RETURN_CTOR(translation);
}

static PHP_METHOD(Phalcon_Translate_Adapter_Gettext, exists){

	zval *index, *domain = NULL, *translation = NULL;

	phalcon_fetch_params(0, 1, 1, &index, &domain);

	if (!domain) {
		PHALCON_CALL_FUNCTIONW(&translation, "gettext", index);
	} else {
		PHALCON_CALL_FUNCTIONW(&translation, "dgettext", domain, index);
	}

	if (Z_STRLEN_P(translation) > 0) {
		zval_ptr_dtor(&translation);
		RETURN_TRUE;
	}
	
	zval_ptr_dtor(&translation);		
	RETURN_FALSE;
}






zend_class_entry *phalcon_translate_adapter_nativearray_ce;

static zend_object_handlers phalcon_translate_adapter_nativearray_object_handlers;

static zval* phalcon_translate_adapter_nativearray_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval *translate, *translation;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	translate = phalcon_fetch_nproperty_this(object, SL("_translate"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset_fetch(&translation, translate, offset)) {
		return translation;
	}

	return offset;
}

static int phalcon_translate_adapter_nativearray_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	zval *translate, *translation;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	translate = phalcon_fetch_nproperty_this(object, SL("_translate"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&translation, translate, offset)) {
		return 0;
	}

	return (1 == check_empty) ? zend_is_true(translation) : 1;
}

static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, __construct);
static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, query);
static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, exists);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_translate_adapter_nativearray___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_translate_adapter_nativearray_method_entry[] = {
	PHP_ME(Phalcon_Translate_Adapter_NativeArray, __construct, arginfo_phalcon_translate_adapter_nativearray___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Translate_Adapter_NativeArray, query, arginfo_phalcon_translate_adapterinterface_query, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Translate_Adapter_NativeArray, exists, arginfo_phalcon_translate_adapterinterface_exists, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Translate_Adapter_NativeArray){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Translate\\Adapter, NativeArray, translate_adapter_nativearray, phalcon_translate_adapter_ce, phalcon_translate_adapter_nativearray_method_entry, 0);

	zend_declare_property_null(phalcon_translate_adapter_nativearray_ce, SL("_translate"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_translate_adapter_nativearray_ce TSRMLS_CC, 1, phalcon_translate_adapterinterface_ce);

	phalcon_translate_adapter_nativearray_object_handlers                = phalcon_translate_adapter_object_handlers;
	phalcon_translate_adapter_nativearray_object_handlers.read_dimension = phalcon_translate_adapter_nativearray_read_dimension;
	phalcon_translate_adapter_nativearray_object_handlers.has_dimension  = phalcon_translate_adapter_nativearray_has_dimension;

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, __construct){

	zval *options, *data;

	phalcon_fetch_params(0, 1, 0, &options);
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Invalid options");
		return;
	}

	if (!phalcon_array_isset_string_fetch(&data, options, SS("content"))) {
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Translation content was not provided");
		return;
	}

	if (Z_TYPE_P(data) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STRW(phalcon_translate_exception_ce, "Translation data must be an array");
		return;
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_translate"), data, 3382158994UL TSRMLS_CC);

	Z_OBJ_HT_P(getThis()) = &phalcon_translate_adapter_nativearray_object_handlers;
}

static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, query){

	zval *index, *placeholders = NULL, *translate, *translation = NULL;
	zval *key_placeholder, *replaced;
	HashPosition hp0;
	zval **value;

	phalcon_fetch_params(0, 1, 1, &index, &placeholders);
	
	if (!placeholders) {
		placeholders = PHALCON_GLOBAL(z_null);
	}
	
	translate = phalcon_fetch_nproperty_this(this_ptr, SL("_translate"), PH_NOISY TSRMLS_CC);
	if (!phalcon_array_isset_fetch(&translation, translate, index)) {
		translation = index;
	}

	if (Z_TYPE_P(placeholders) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(placeholders))) {
		ALLOC_INIT_ZVAL(key_placeholder);
		Z_ADDREF_P(translation);

		for (
			zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(placeholders), &hp0);
			zend_hash_get_current_data_ex(Z_ARRVAL_P(placeholders), (void**)&value, &hp0) == SUCCESS;
			zend_hash_move_forward_ex(Z_ARRVAL_P(placeholders), &hp0)
		) {
			zval key = phalcon_get_current_key_w(Z_ARRVAL_P(placeholders), &hp0);

			PHALCON_CONCAT_SVS(key_placeholder, "%", &key, "%");

			ALLOC_INIT_ZVAL(replaced);
			phalcon_fast_str_replace(replaced, key_placeholder, *value, translation);
			zval_dtor(key_placeholder);

			zval_ptr_dtor(&translation);
			translation = replaced;
		}

		ZVAL_NULL(key_placeholder);
		zval_ptr_dtor(&key_placeholder);
		RETURN_ZVAL(translation, 1, 1);
	}

	RETURN_ZVAL(translation, 1, 0);
}

static PHP_METHOD(Phalcon_Translate_Adapter_NativeArray, exists){

	zval **index;

	phalcon_fetch_params_ex(1, 0, &index);
	RETURN_BOOL(phalcon_translate_adapter_nativearray_has_dimension(getThis(), *index, 0 TSRMLS_CC));
}





zend_class_entry *phalcon_validation_exception_ce;

PHALCON_INIT_CLASS(Phalcon_Validation_Exception){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation, Exception, validation_exception, phalcon_exception_ce, NULL, 0);

	return SUCCESS;
}






zend_class_entry *phalcon_validation_message_ce;

static PHP_METHOD(Phalcon_Validation_Message, __construct);
static PHP_METHOD(Phalcon_Validation_Message, setType);
static PHP_METHOD(Phalcon_Validation_Message, getType);
static PHP_METHOD(Phalcon_Validation_Message, setCode);
static PHP_METHOD(Phalcon_Validation_Message, getCode);
static PHP_METHOD(Phalcon_Validation_Message, setMessage);
static PHP_METHOD(Phalcon_Validation_Message, getMessage);
static PHP_METHOD(Phalcon_Validation_Message, setField);
static PHP_METHOD(Phalcon_Validation_Message, getField);
static PHP_METHOD(Phalcon_Validation_Message, __toString);
static PHP_METHOD(Phalcon_Validation_Message, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message___construct, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
	ZEND_ARG_INFO(0, field)
	ZEND_ARG_INFO(0, type)
	ZEND_ARG_INFO(0, code)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message___set_state, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_validation_message_method_entry[] = {
	PHP_ME(Phalcon_Validation_Message, __construct, arginfo_phalcon_validation_message___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Validation_Message, setType, arginfo_phalcon_validation_messageinterface_settype, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, getType, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, setCode, arginfo_phalcon_validation_messageinterface_setcode, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, getCode, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, setMessage, arginfo_phalcon_validation_messageinterface_setmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, getMessage, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, setField, arginfo_phalcon_validation_messageinterface_setfield, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, getField, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, __toString, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message, __set_state, arginfo_phalcon_validation_message___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Message){

	PHALCON_REGISTER_CLASS(Phalcon\\Validation, Message, validation_message, phalcon_validation_message_method_entry, 0);

	zend_declare_property_null(phalcon_validation_message_ce, SL("_type"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_message_ce, SL("_message"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_message_ce, SL("_field"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_long(phalcon_validation_message_ce, SL("_code"), 0, ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_validation_message_ce TSRMLS_CC, 1, phalcon_validation_messageinterface_ce);

	return SUCCESS;
}

zval* phalcon_validation_message_construct_helper(zval *message, zval *field, const char *type, zval *code TSRMLS_DC)
{
	zval *result;

	MAKE_STD_ZVAL(result);
	object_init_ex(result, phalcon_validation_message_ce);

	phalcon_update_property_this(result, SL("_message"), message TSRMLS_CC);
	phalcon_update_property_this(result, SL("_field"), field TSRMLS_CC);
	phalcon_update_property_string(result, SL("_type"), type, strlen(type) TSRMLS_CC);
	phalcon_update_property_this(result, SL("_code"), code TSRMLS_CC);

	return result;
}

static PHP_METHOD(Phalcon_Validation_Message, __construct){

	zval *message, *field = NULL, *type = NULL, *code = NULL;

	phalcon_fetch_params(0, 1, 3, &message, &field, &type, &code);
	
	if (!field) {
		field = PHALCON_GLOBAL(z_null);
	}
	
	if (!type) {
		type = PHALCON_GLOBAL(z_null);
	}

	if (!code) {
		code = PHALCON_GLOBAL(z_zero);
	}
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message, setType){

	zval *type;

	phalcon_fetch_params(0, 1, 0, &type);
	
	phalcon_update_property_this_quick(this_ptr, SL("_type"), type, 3991959110UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation_Message, getType){


	RETURN_MEMBER_QUICK(this_ptr, "_type", 3991959110UL);
}

static PHP_METHOD(Phalcon_Validation_Message, setCode){

	zval *code;

	phalcon_fetch_params(0, 1, 0, &code);

	phalcon_update_property_this_quick(this_ptr, SL("_code"), code, 3971426015UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation_Message, getCode){

	RETURN_MEMBER_QUICK(this_ptr, "_code", 3971426015UL);
}

static PHP_METHOD(Phalcon_Validation_Message, setMessage){

	zval *message;

	phalcon_fetch_params(0, 1, 0, &message);
	
	phalcon_update_property_this_quick(this_ptr, SL("_message"), message, 933579817UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation_Message, getMessage){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Validation_Message, setField){

	zval *field;

	phalcon_fetch_params(0, 1, 0, &field);
	
	phalcon_update_property_this_quick(this_ptr, SL("_field"), field, 2318377128UL TSRMLS_CC);
	RETURN_THISW();
}

static PHP_METHOD(Phalcon_Validation_Message, getField){


	RETURN_MEMBER_QUICK(this_ptr, "_field", 2318377128UL);
}

static PHP_METHOD(Phalcon_Validation_Message, __toString){


	RETURN_MEMBER_QUICK(this_ptr, "_message", 933579817UL);
}

static PHP_METHOD(Phalcon_Validation_Message, __set_state){

	zval *message, *message_text, *field, *type, *code;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &message);
	
	PHALCON_OBS_VAR(message_text);
	phalcon_array_fetch_quick_string(&message_text, message, SS("_message"), 933579817UL, PH_NOISY);
	
	PHALCON_OBS_VAR(field);
	phalcon_array_fetch_quick_string(&field, message, SS("_field"), 2318377128UL, PH_NOISY);
	
	PHALCON_OBS_VAR(type);
	phalcon_array_fetch_quick_string(&type, message, SS("_type"), 3991959110UL, PH_NOISY);

	PHALCON_OBS_VAR(code);
	phalcon_array_fetch_quick_string(&code, message, SS("_code"), 3971426015UL, PH_NOISY);

	object_init_ex(return_value, phalcon_validation_message_ce);
	PHALCON_CALL_METHOD(NULL, return_value, "__construct", message_text, field, type, code);
	
	RETURN_MM();
}





zend_class_entry *phalcon_validation_messageinterface_ce;

static const zend_function_entry phalcon_validation_messageinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, setType, arginfo_phalcon_validation_messageinterface_settype)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, getType, NULL)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, setCode, arginfo_phalcon_validation_messageinterface_setcode)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, getCode, NULL)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, setMessage, arginfo_phalcon_validation_messageinterface_setmessage)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, getMessage, NULL)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, setField, arginfo_phalcon_validation_messageinterface_setfield)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, getField, NULL)
	PHP_ABSTRACT_ME(Phalcon_Validation_MessageInterface, __toString, NULL)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_MessageInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Validation, MessageInterface, validation_messageinterface, phalcon_validation_messageinterface_method_entry);

	return SUCCESS;
}















zend_class_entry *phalcon_validation_validator_ce;

static PHP_METHOD(Phalcon_Validation_Validator, __construct);
static PHP_METHOD(Phalcon_Validation_Validator, isSetOption);
static PHP_METHOD(Phalcon_Validation_Validator, getOption);
static PHP_METHOD(Phalcon_Validation_Validator, setOption);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_validator___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, options)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_validation_validator_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator, __construct, arginfo_phalcon_validation_validator___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Validation_Validator, isSetOption, arginfo_phalcon_validation_validatorinterface_issetoption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Validator, getOption, arginfo_phalcon_validation_validatorinterface_getoption, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Validator, setOption, arginfo_phalcon_validation_validatorinterface_setoption, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator){

	PHALCON_REGISTER_CLASS(Phalcon\\Validation, Validator, validation_validator, phalcon_validation_validator_method_entry, ZEND_ACC_EXPLICIT_ABSTRACT_CLASS);

	zend_declare_property_null(phalcon_validation_validator_ce, SL("_options"), ZEND_ACC_PROTECTED TSRMLS_CC);

	zend_class_implements(phalcon_validation_validator_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static int phalcon_validation_validator_getoption_helper(const zend_class_entry *ce, zval **result, zval *this_ptr, const char *option TSRMLS_DC)
{
	zval *opt;
	zval *params[1];

	if (is_phalcon_class(ce)) {
		zval *value;
		zval *options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);

		MAKE_STD_ZVAL(*result);
		if (phalcon_array_isset_string_fetch(&value, options, option, strlen(option)+1)) {
			ZVAL_ZVAL(*result, value, 1, 0);
		}
		else {
			ZVAL_NULL(*result);
		}

		return SUCCESS;
	}

	PHALCON_ALLOC_GHOST_ZVAL(opt);
	PHALCON_ZVAL_MAYBE_INTERNED_STRING(opt, option);
	params[0] = opt;

	ALLOC_INIT_ZVAL(*result);
	return phalcon_return_call_method(*result, NULL, this_ptr, "getoption", 1, params TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Validator, __construct){

	zval *options = NULL;

	phalcon_fetch_params(0, 0, 1, &options);
	
	if (!options) {
		options = PHALCON_GLOBAL(z_null);
	}
	
	if (Z_TYPE_P(options) != IS_ARRAY) { 
		if (Z_TYPE_P(options) != IS_NULL) {
			PHALCON_THROW_EXCEPTION_STRW(phalcon_validation_exception_ce, "Options must be an array");
			return;
		}
	} else {
		phalcon_update_property_this_quick(this_ptr, SL("_options"), options, 1620153008UL TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Validation_Validator, isSetOption){

	zval *key, *options;

	phalcon_fetch_params(0, 1, 0, &key);
	
	options = phalcon_fetch_nproperty_this(this_ptr, SL("_options"), PH_NOISY TSRMLS_CC);
	RETURN_BOOL(phalcon_array_isset(options, key));
}

static PHP_METHOD(Phalcon_Validation_Validator, getOption){

	zval **key;
	zval *tmp = NULL;

	phalcon_fetch_params_ex(1, 0, &key);
	PHALCON_ENSURE_IS_STRING(key);
	phalcon_validation_validator_getoption_helper(phalcon_validation_validator_ce, &tmp, getThis(), Z_STRVAL_PP(key) TSRMLS_CC);
	RETURN_ZVAL(tmp, 1, 1);
}

static PHP_METHOD(Phalcon_Validation_Validator, setOption){

	zval *key, *value;

	phalcon_fetch_params(0, 2, 0, &key, &value);
	
	phalcon_update_property_array(this_ptr, SL("_options"), key, value TSRMLS_CC);
	
}





zend_class_entry *phalcon_validation_validatorinterface_ce;

static const zend_function_entry phalcon_validation_validatorinterface_method_entry[] = {
	PHP_ABSTRACT_ME(Phalcon_Validation_ValidatorInterface, isSetOption, arginfo_phalcon_validation_validatorinterface_issetoption)
	PHP_ABSTRACT_ME(Phalcon_Validation_ValidatorInterface, getOption, arginfo_phalcon_validation_validatorinterface_getoption)
	PHP_ABSTRACT_ME(Phalcon_Validation_ValidatorInterface, setOption, arginfo_phalcon_validation_validatorinterface_setoption)
	PHP_ABSTRACT_ME(Phalcon_Validation_ValidatorInterface, validate, arginfo_phalcon_validation_validatorinterface_validate)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_ValidatorInterface){

	PHALCON_REGISTER_INTERFACE(Phalcon\\Validation, ValidatorInterface, validation_validatorinterface, phalcon_validation_validatorinterface_method_entry);

	return SUCCESS;
}










zend_class_entry *phalcon_validation_message_group_ce;

static PHP_METHOD(Phalcon_Validation_Message_Group, __construct);
static PHP_METHOD(Phalcon_Validation_Message_Group, offsetGet);
static PHP_METHOD(Phalcon_Validation_Message_Group, offsetSet);
static PHP_METHOD(Phalcon_Validation_Message_Group, offsetExists);
static PHP_METHOD(Phalcon_Validation_Message_Group, offsetUnset);
static PHP_METHOD(Phalcon_Validation_Message_Group, appendMessage);
static PHP_METHOD(Phalcon_Validation_Message_Group, appendMessages);
static PHP_METHOD(Phalcon_Validation_Message_Group, filter);
static PHP_METHOD(Phalcon_Validation_Message_Group, count);
static PHP_METHOD(Phalcon_Validation_Message_Group, rewind);
static PHP_METHOD(Phalcon_Validation_Message_Group, current);
static PHP_METHOD(Phalcon_Validation_Message_Group, key);
static PHP_METHOD(Phalcon_Validation_Message_Group, next);
static PHP_METHOD(Phalcon_Validation_Message_Group, valid);
static PHP_METHOD(Phalcon_Validation_Message_Group, __set_state);

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group___construct, 0, 0, 0)
	ZEND_ARG_INFO(0, messages)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_offsetget, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_offsetset, 0, 0, 2)
	ZEND_ARG_INFO(0, index)
	ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_offsetexists, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_offsetunset, 0, 0, 1)
	ZEND_ARG_INFO(0, index)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_appendmessage, 0, 0, 1)
	ZEND_ARG_INFO(0, message)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_appendmessages, 0, 0, 1)
	ZEND_ARG_INFO(0, messages)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group_filter, 0, 0, 1)
	ZEND_ARG_INFO(0, fieldName)
ZEND_END_ARG_INFO()

ZEND_BEGIN_ARG_INFO_EX(arginfo_phalcon_validation_message_group___set_state, 0, 0, 1)
	ZEND_ARG_INFO(0, group)
ZEND_END_ARG_INFO()

static const zend_function_entry phalcon_validation_message_group_method_entry[] = {
	PHP_ME(Phalcon_Validation_Message_Group, __construct, arginfo_phalcon_validation_message_group___construct, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)
	PHP_ME(Phalcon_Validation_Message_Group, offsetGet, arginfo_phalcon_validation_message_group_offsetget, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, offsetSet, arginfo_phalcon_validation_message_group_offsetset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, offsetExists, arginfo_phalcon_validation_message_group_offsetexists, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, offsetUnset, arginfo_phalcon_validation_message_group_offsetunset, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, appendMessage, arginfo_phalcon_validation_message_group_appendmessage, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, appendMessages, arginfo_phalcon_validation_message_group_appendmessages, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, filter, arginfo_phalcon_validation_message_group_filter, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, count, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, rewind, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, current, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, key, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, next, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, valid, NULL, ZEND_ACC_PUBLIC)
	PHP_ME(Phalcon_Validation_Message_Group, __set_state, arginfo_phalcon_validation_message_group___set_state, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};

static zend_object_handlers phalcon_validation_message_group_object_handlers;

static void phalcon_validation_message_group_dtor(zend_object_iterator *it TSRMLS_DC)
{
	zval_ptr_dtor((zval**)&it->data);
	efree(it);
}

static int phalcon_validation_message_group_valid(zend_object_iterator *it TSRMLS_DC)
{
	zval *position, *messages;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	messages = phalcon_fetch_nproperty_this((zval*)it->data, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (phalcon_array_isset(messages, position)) {
		return SUCCESS;
	}

	return FAILURE;
}

static void phalcon_validation_message_group_get_current_data(zend_object_iterator *it, zval ***data TSRMLS_DC)
{
	zval *position, *messages;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	messages = phalcon_fetch_nproperty_this((zval*)it->data, SL("_messages"), PH_NOISY TSRMLS_CC);

	*data = phalcon_hash_get(Z_ARRVAL_P(messages), position, BP_VAR_NA);
}

#if ZEND_MODULE_API_NO >= 20121212
static void phalcon_validation_message_group_get_current_key(zend_object_iterator *it, zval *key TSRMLS_DC)
{
	zval *position;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	ZVAL_ZVAL(key, position, 1, 0);
}
#else
static int phalcon_validation_message_group_get_current_key(zend_object_iterator *it, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC)
{
	zval *position;

	position = phalcon_fetch_nproperty_this((zval*)it->data, SL("_position"), PH_NOISY TSRMLS_CC);
	*int_key = (IS_LONG == Z_TYPE_P(position)) ? Z_LVAL_P(position) : phalcon_get_intval(position);
	return HASH_KEY_IS_LONG;
}
#endif

static void phalcon_validation_message_group_move_forward(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_property_incr((zval*)it->data, SL("_position") TSRMLS_CC);
}

static void phalcon_validation_message_group_rewind(zend_object_iterator *it TSRMLS_DC)
{
	phalcon_update_property_long((zval*)it->data, SL("_position"), 0 TSRMLS_CC);
}

static zend_object_iterator_funcs phalcon_validation_message_group_iterator_funcs = {
	phalcon_validation_message_group_dtor,
	phalcon_validation_message_group_valid,
	phalcon_validation_message_group_get_current_data,
	phalcon_validation_message_group_get_current_key,
	phalcon_validation_message_group_move_forward,
	phalcon_validation_message_group_rewind,
	NULL
};

static zend_object_iterator* phalcon_validation_message_group_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)
{
	zend_object_iterator *result;

	if (by_ref) {
		zend_throw_exception_ex(phalcon_validation_exception_ce, 0 TSRMLS_CC, "Cannot iterate Phalcon\\Validation\\Message\\Group by reference");
		return NULL;
	}

	result = emalloc(sizeof(zend_object_iterator));

	Z_ADDREF_P(object);
	result->data  = object;
	result->funcs = &phalcon_validation_message_group_iterator_funcs;

	return result;
}

static zval* phalcon_validation_message_group_read_dimension(zval *object, zval *offset, int type TSRMLS_DC)
{
	zval *messages;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->read_dimension(object, offset, type TSRMLS_CC);
	}

	if (UNEXPECTED(!offset)) {
		return EG(uninitialized_zval_ptr);
	}

	messages = phalcon_fetch_nproperty_this(object, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_ARRAY) {
		zval **res = phalcon_hash_get(Z_ARRVAL_P(messages), offset, type);
		return res ? *res : NULL;
	}

	return NULL;
}

static void phalcon_validation_message_group_write_dimension(zval *object, zval *offset, zval *value TSRMLS_DC)
{
	zval *messages;
	int separate;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->write_dimension(object, offset, value TSRMLS_CC);
		return;
	}

	PHALCON_VERIFY_CLASS_EX(value, phalcon_validation_message_ce, spl_ce_BadMethodCallException, 0);

	messages = phalcon_fetch_nproperty_this(object, SL("_messages"), PH_NOISY TSRMLS_CC);
	separate = phalcon_maybe_separate_zval(&messages);
	if (Z_TYPE_P(messages) != IS_ARRAY) {
		zval_dtor(messages);
		array_init_size(messages, 1);
	}

	Z_ADDREF_P(value);
	phalcon_hash_update_or_insert(Z_ARRVAL_P(messages), offset, value);
	if (separate) {
		Z_DELREF_P(messages);
		phalcon_update_property_this(object, SL("_messages"), messages TSRMLS_CC);
	}
}

static int phalcon_validation_message_group_has_dimension(zval *object, zval *offset, int check_empty TSRMLS_DC)
{
	zval *messages;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		return zend_get_std_object_handlers()->has_dimension(object, offset, check_empty TSRMLS_CC);
	}

	messages = phalcon_fetch_nproperty_this(object, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_ARRAY) {
		zval **tmp = phalcon_hash_get(Z_ARRVAL_P(messages), offset, BP_VAR_NA);

		if (!tmp) {
			return 0;
		}

		if (0 == check_empty) {
			return Z_TYPE_PP(tmp) != IS_NULL;
		}

		if (1 == check_empty) {
			return zend_is_true(*tmp);
		}

		return 1;
	}

	return 0;
}

static void phalcon_validation_message_group_unset_dimension(zval *object, zval *offset TSRMLS_DC)
{
	zval *messages;
	int separate;

	if (!is_phalcon_class(Z_OBJCE_P(object))) {
		zend_get_std_object_handlers()->unset_dimension(object, offset TSRMLS_CC);
		return;
	}

	messages = phalcon_fetch_nproperty_this(object, SL("_messages"), PH_NOISY TSRMLS_CC);
	separate = phalcon_maybe_separate_zval(&messages);

	if (Z_TYPE_P(messages) != IS_ARRAY) {
		zval_dtor(messages);
		array_init_size(messages, 0);
	}
	else {
		phalcon_array_unset(&messages, offset, 0);
	}

	if (separate) {
		Z_DELREF_P(messages);
		phalcon_update_property_this(object, SL("_messages"), messages TSRMLS_CC);
	}
}

static int phalcon_validation_message_group_count_elements(zval *object, long int *count TSRMLS_DC)
{
	int res;
	zval *cnt = NULL;

	if (is_phalcon_class(Z_OBJCE_P(object))) {
		zval *messages = phalcon_fetch_nproperty_this(object, SL("_messages"), PH_NOISY TSRMLS_CC);
		*count         = (Z_TYPE_P(messages) == IS_ARRAY) ? zend_hash_num_elements(Z_ARRVAL_P(messages)) : 0;
		return SUCCESS;
	}

	res = phalcon_call_method(&cnt, object, "count", 0, NULL TSRMLS_CC);
	if (res == SUCCESS) {
		*count = (Z_TYPE_P(cnt) == IS_LONG) ? Z_LVAL_P(cnt) : phalcon_get_intval(cnt);
		zval_ptr_dtor(&cnt);
	}

	return res;
}

PHALCON_INIT_CLASS(Phalcon_Validation_Message_Group){

	PHALCON_REGISTER_CLASS(Phalcon\\Validation\\Message, Group, validation_message_group, phalcon_validation_message_group_method_entry, 0);

	zend_declare_property_null(phalcon_validation_message_group_ce, SL("_position"), ZEND_ACC_PROTECTED TSRMLS_CC);
	zend_declare_property_null(phalcon_validation_message_group_ce, SL("_messages"), ZEND_ACC_PROTECTED TSRMLS_CC);

	phalcon_validation_message_group_ce->get_iterator         = phalcon_validation_message_group_get_iterator;
	phalcon_validation_message_group_ce->iterator_funcs.funcs = &phalcon_validation_message_group_iterator_funcs;

	phalcon_validation_message_group_object_handlers = *zend_get_std_object_handlers();
	phalcon_validation_message_group_object_handlers.read_dimension  = phalcon_validation_message_group_read_dimension;
	phalcon_validation_message_group_object_handlers.write_dimension = phalcon_validation_message_group_write_dimension;
	phalcon_validation_message_group_object_handlers.has_dimension   = phalcon_validation_message_group_has_dimension;
	phalcon_validation_message_group_object_handlers.unset_dimension = phalcon_validation_message_group_unset_dimension;
	phalcon_validation_message_group_object_handlers.count_elements  = phalcon_validation_message_group_count_elements;

	zend_class_implements(phalcon_validation_message_group_ce TSRMLS_CC, 3, spl_ce_Countable, zend_ce_arrayaccess, zend_ce_iterator);

	return SUCCESS;
}

static void phalcon_validation_group_construct_helper(zval *object, zval *messages TSRMLS_DC)
{
	Z_OBJ_HT_P(object) = &phalcon_validation_message_group_object_handlers;

	if (messages && Z_TYPE_P(messages) == IS_ARRAY) {
		phalcon_update_property_this(object, SL("_messages"), messages TSRMLS_CC);
	}
}

static PHP_METHOD(Phalcon_Validation_Message_Group, __construct){

	zval **messages = NULL;

	phalcon_fetch_params_ex(0, 1, &messages);
	phalcon_validation_group_construct_helper(getThis(), (messages ? *messages : NULL) TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, offsetGet){

	zval **index, *ret;

	phalcon_fetch_params_ex(1, 0, &index);
	ret = phalcon_validation_message_group_read_dimension(getThis(), *index, BP_VAR_NA TSRMLS_CC);
	if (ret) {
		RETURN_ZVAL(ret, 1, 0);
	}
	
	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Validation_Message_Group, offsetSet){

	zval **index, **message;

	phalcon_fetch_params_ex(2, 0, &index, &message);
	phalcon_validation_message_group_write_dimension(getThis(), *index, *message TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, offsetExists){

	zval **index;

	phalcon_fetch_params_ex(1, 0, &index);
	RETURN_BOOL(phalcon_validation_message_group_has_dimension(getThis(), *index, 0 TSRMLS_CC));
}

static PHP_METHOD(Phalcon_Validation_Message_Group, offsetUnset){

	zval **index;

	phalcon_fetch_params_ex(1, 0, &index);
	phalcon_validation_message_group_unset_dimension(getThis(), *index TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, appendMessage){

	zval *message;

	phalcon_fetch_params(0, 1, 0, &message);
	PHALCON_VERIFY_INTERFACE_EX(message, phalcon_validation_messageinterface_ce, phalcon_validation_exception_ce, 0);
	phalcon_update_property_array_append(this_ptr, SL("_messages"), message TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, appendMessages){

	zval *messages;
	zval *key = NULL, *message = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &messages);
	
	if (Z_TYPE_P(messages) != IS_ARRAY) { 
		if (Z_TYPE_P(messages) != IS_OBJECT) {
			PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "The messages must be array or object");
			return;
		}
	}
	
	if (Z_TYPE_P(messages) == IS_ARRAY) { 
		phalcon_is_iterable(messages, &ah0, &hp0, 0, 0);
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
			PHALCON_GET_HKEY(key, ah0, hp0);
			PHALCON_GET_HVALUE(message);

			PHALCON_CALL_SELF(NULL, "appendmessage", message);

			zend_hash_move_forward_ex(ah0, &hp0);
		}
	} else {
		zend_class_entry *ce     = Z_OBJCE_P(messages);
		zend_object_iterator *it = ce->get_iterator(ce, messages, 0 TSRMLS_CC);

		PHALCON_VERIFY_INTERFACE_EX(messages, zend_ce_iterator, phalcon_validation_exception_ce, 1);

		assert(it != NULL);
		assert(it->funcs->rewind != NULL);
		assert(it->funcs->valid != NULL);
		assert(it->funcs->get_current_data != NULL);
		assert(it->funcs->move_forward != NULL);

		it->funcs->rewind(it TSRMLS_CC);
		while (!EG(exception) && SUCCESS == it->funcs->valid(it TSRMLS_CC)) {
			zval **message;
			zval *params[1];
	
			it->funcs->get_current_data(it, &message TSRMLS_CC);
			if (!EG(exception)) {
				params[0] = *message;
				if (FAILURE == phalcon_call_method(NULL, this_ptr, "appendmessage", 1, params TSRMLS_CC)) {
					break;
				}
			}

			if (!EG(exception)) {
				it->funcs->move_forward(it TSRMLS_CC);
			}
		}

		it->funcs->dtor(it TSRMLS_CC);
	}
	
	PHALCON_MM_RESTORE();
}

static PHP_METHOD(Phalcon_Validation_Message_Group, filter){

	zval *field_name, *filtered, *messages, *message = NULL;
	zval *field = NULL;
	HashTable *ah0;
	HashPosition hp0;
	zval **hd;

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 1, 0, &field_name);
	
	PHALCON_INIT_VAR(filtered);
	array_init(filtered);
	
	PHALCON_OBS_VAR(messages);
	phalcon_read_property_this(&messages, this_ptr, SL("_messages"), PH_NOISY TSRMLS_CC);
	if (Z_TYPE_P(messages) == IS_ARRAY) { 
	
		phalcon_is_iterable(messages, &ah0, &hp0, 0, 0);
	
		while (zend_hash_get_current_data_ex(ah0, (void**) &hd, &hp0) == SUCCESS) {
	
			PHALCON_GET_HVALUE(message);
	
			if (phalcon_method_quick_exists_ex(message, SS("getfield"), 3709730281UL TSRMLS_CC) == SUCCESS) {
				PHALCON_CALL_METHOD(&field, message, "getfield");
				if (PHALCON_IS_EQUAL(field_name, field)) {
					phalcon_array_append(&filtered, message, PH_SEPARATE);
				}
			}
	
			zend_hash_move_forward_ex(ah0, &hp0);
		}
	
	}
	
	RETURN_CTOR(filtered);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, count){

	long int count;

	if (SUCCESS == phalcon_validation_message_group_count_elements(getThis(), &count TSRMLS_CC)) {
		RETURN_LONG(count);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Validation_Message_Group, rewind){

	zend_object_iterator it;
	it.data = getThis();
	phalcon_validation_message_group_iterator_funcs.rewind(&it TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, current){

	zval **ret;
	zend_object_iterator it;
	it.data = getThis();

	phalcon_validation_message_group_iterator_funcs.get_current_data(&it, &ret TSRMLS_CC);
	if (ret) {
		RETURN_ZVAL(*ret, 1, 0);
	}

	RETURN_NULL();
}

static PHP_METHOD(Phalcon_Validation_Message_Group, key){

	zend_object_iterator it;
	it.data = getThis();
#if ZEND_MODULE_API_NO >= 20121212
	phalcon_validation_message_group_iterator_funcs.get_current_key(&it, return_value TSRMLS_CC);
#else
	{
		char *str_key;
		uint str_key_len;
		ulong int_key;
		if (HASH_KEY_IS_STRING == phalcon_validation_message_group_iterator_funcs.get_current_key(&it, &str_key, &str_key_len, &int_key TSRMLS_CC)) {
			RETURN_STRINGL(str_key, str_key_len-1, 1);
		}

		RETURN_LONG(int_key);
	}
#endif
}

static PHP_METHOD(Phalcon_Validation_Message_Group, next){

	zend_object_iterator it;
	it.data = getThis();
	phalcon_validation_message_group_iterator_funcs.move_forward(&it TSRMLS_CC);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, valid){

	zend_object_iterator it;
	it.data = getThis();
	RETURN_BOOL(phalcon_validation_message_group_iterator_funcs.valid(&it TSRMLS_CC) == SUCCESS);
}

static PHP_METHOD(Phalcon_Validation_Message_Group, __set_state){

	zval **group, *messages;

	phalcon_fetch_params_ex(1, 0, &group);

	if (phalcon_array_isset_string_fetch(&messages, *group, SS("_messages"))) {
		object_init_ex(return_value, phalcon_validation_message_group_ce);
		phalcon_validation_group_construct_helper(return_value, messages TSRMLS_CC);
	}
	else {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, "Invalid arguments passed to %s", "Phalcon\\Mvc\\Model\\Message\\Group::__set_state()");
	}
}







zend_class_entry *phalcon_validation_validator_between_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Between, validate);

static const zend_function_entry phalcon_validation_validator_between_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Between, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Between){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Between, validation_validator_between, phalcon_validation_validator_ce, phalcon_validation_validator_between_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_between_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Between, validate){

	zval *validator, *attribute, *value = NULL, *allow_empty, *minimum;
	zval *maximum, *label, *pairs, *valid, *message_str, *prepared = NULL, *message, *code;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);
	
	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	PHALCON_OBS_VAR(minimum);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &minimum, getThis(), "minimum" TSRMLS_CC));

	PHALCON_OBS_VAR(maximum);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &maximum, getThis(), "maximum" TSRMLS_CC));

	PHALCON_INIT_VAR(valid);
	is_smaller_or_equal_function(valid, minimum, value TSRMLS_CC);
	if (zend_is_true(valid)) {
		is_smaller_or_equal_function(valid, value, maximum TSRMLS_CC);
	}
	
	if (PHALCON_IS_FALSE(valid)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 3);
		Z_ADDREF_P(label);   add_assoc_zval_ex(pairs, SS(":field"), label);
		Z_ADDREF_P(minimum); add_assoc_zval_ex(pairs, SS(":min"), minimum);
		Z_ADDREF_P(maximum); add_assoc_zval_ex(pairs, SS(":max"), maximum);
	
		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Between" TSRMLS_CC));
		}

		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);
	
		message = phalcon_validation_message_construct_helper(prepared, attribute, "Between", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_confirmation_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Confirmation, validate);

static const zend_function_entry phalcon_validation_validator_confirmation_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Confirmation, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Confirmation){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Confirmation, validation_validator_confirmation, phalcon_validation_validator_ce, phalcon_validation_validator_confirmation_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_confirmation_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Confirmation, validate){

	zval *validator, *attribute, *with_attribute;
	zval *value = NULL, *with_value = NULL, *message_str, *message, *code;
	zval *label, *with_label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_OBS_VAR(with_attribute);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &with_attribute, getThis(), "with" TSRMLS_CC));
	
	PHALCON_CALL_METHOD(&value,      validator, "getvalue", attribute);
	PHALCON_CALL_METHOD(&with_value, validator, "getvalue", with_attribute);

	if (!PHALCON_IS_EQUAL(value, with_value)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}
                
                PHALCON_OBS_VAR(with_label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &with_label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(with_label)) {
			PHALCON_CALL_METHOD(&with_label, validator, "getlabel", with_attribute);
			if (!zend_is_true(with_label)) {
				PHALCON_CPY_WRT(with_label, with_attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 2);
		Z_ADDREF_P(label);          add_assoc_zval_ex(pairs, SS(":field"), label);
		Z_ADDREF_P(with_label); add_assoc_zval_ex(pairs, SS(":with"), with_label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Confirmation" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);
	
		message = phalcon_validation_message_construct_helper(prepared, attribute, "Confirmation", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_email_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Email, validate);

static const zend_function_entry phalcon_validation_validator_email_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Email, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Email){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Email, validation_validator_email, phalcon_validation_validator_ce, phalcon_validation_validator_email_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_email_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Email, validate){

	zval *validator, *attribute, *value = NULL, *validate_email;
	zval *validation = NULL, *message_str, *message, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);
	
	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	PHALCON_ALLOC_GHOST_ZVAL(validate_email);
	ZVAL_LONG(validate_email, 274);
	
	PHALCON_CALL_FUNCTION(&validation, "filter_var", value, validate_email);
	if (!zend_is_true(validation)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 1);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Email" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "Email", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_exclusionin_ce;

static PHP_METHOD(Phalcon_Validation_Validator_ExclusionIn, validate);

static const zend_function_entry phalcon_validation_validator_exclusionin_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_ExclusionIn, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_ExclusionIn){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, ExclusionIn, validation_validator_exclusionin, phalcon_validation_validator_ce, phalcon_validation_validator_exclusionin_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_exclusionin_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_ExclusionIn, validate){

	zval *validator, *attribute, *value = NULL, *domain;
	zval *message_str, *joined_domain, *message, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);

	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	/* A domain is an array with a list of valid values */
	PHALCON_OBS_VAR(domain);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &domain, getThis(), phalcon_interned_domain TSRMLS_CC));
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	if (phalcon_fast_in_array(value, domain TSRMLS_CC)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		ALLOC_INIT_ZVAL(joined_domain);
		phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 2);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);
		add_assoc_zval_ex(pairs, SS(":domain"), joined_domain);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "ExclusionIn" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);
	
		message = phalcon_validation_message_construct_helper(prepared, attribute, "ExclusionIn", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_identical_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Identical, validate);

static const zend_function_entry phalcon_validation_validator_identical_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Identical, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Identical){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Identical, validation_validator_identical, phalcon_validation_validator_ce, phalcon_validation_validator_identical_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_identical_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Identical, validate){

	zval *validator, *attribute, *value = NULL, *identical_value;
	zval *message_str, *message, *code;
	zval *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);
	
	PHALCON_OBS_VAR(identical_value);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &identical_value, getThis(), phalcon_interned_value TSRMLS_CC));

	if (!PHALCON_IS_EQUAL(value, identical_value)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 1);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Identical" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "Identical", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_inclusionin_ce;

static PHP_METHOD(Phalcon_Validation_Validator_InclusionIn, validate);

static const zend_function_entry phalcon_validation_validator_inclusionin_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_InclusionIn, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_InclusionIn){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, InclusionIn, validation_validator_inclusionin, phalcon_validation_validator_ce, phalcon_validation_validator_inclusionin_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_inclusionin_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_InclusionIn, validate){

	zval *validator, *attribute, *value = NULL, *domain;
	zval *message_str, *joined_domain, *message, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);

	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	/* A domain is an array with a list of valid values */
	PHALCON_OBS_VAR(domain);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &domain, getThis(), phalcon_interned_domain TSRMLS_CC));
	if (Z_TYPE_P(domain) != IS_ARRAY) { 
		PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "Option 'domain' must be an array");
		return;
	}
	
	if (!phalcon_fast_in_array(value, domain TSRMLS_CC)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		ALLOC_INIT_ZVAL(joined_domain);
		phalcon_fast_join_str(joined_domain, SL(", "), domain TSRMLS_CC);

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 2);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);
		add_assoc_zval_ex(pairs, SS(":domain"), joined_domain);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "InclusionIn" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "InclusionIn", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_presenceof_ce;

static PHP_METHOD(Phalcon_Validation_Validator_PresenceOf, validate);

static const zend_function_entry phalcon_validation_validator_presenceof_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_PresenceOf, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_PresenceOf){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, PresenceOf, validation_validator_presenceof, phalcon_validation_validator_ce, phalcon_validation_validator_presenceof_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_presenceof_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_PresenceOf, validate){

	zval *validator, *attribute, *value = NULL, *code, *message_str, *message;
	zval *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);

	if (PHALCON_IS_EMPTY(value)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 1);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "PresenceOf" TSRMLS_CC));
		}

		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "PresenceOf", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_regex_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Regex, validate);

static const zend_function_entry phalcon_validation_validator_regex_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Regex, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Regex){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Regex, validation_validator_regex, phalcon_validation_validator_ce, phalcon_validation_validator_regex_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_regex_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Regex, validate){

	zval *validator, *attribute, *value = NULL, *pattern;
	zval *matches, *match_pattern, *match_zero, *failed;
	zval *message_str, *message, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);

	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}
	
	/* The regular expression is set in the option 'pattern' */
	PHALCON_OBS_VAR(pattern);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &pattern, getThis(), "pattern" TSRMLS_CC));
	
	PHALCON_INIT_VAR(matches);
	
	/* Check if the value match using preg_match in the PHP userland */
	PHALCON_INIT_VAR(match_pattern);
	RETURN_MM_ON_FAILURE(phalcon_preg_match(match_pattern, pattern, value, matches TSRMLS_CC));
	
	PHALCON_INIT_VAR(failed);
	if (zend_is_true(match_pattern)) {
		PHALCON_OBS_VAR(match_zero);
		phalcon_array_fetch_long(&match_zero, matches, 0, PH_NOISY);

		is_not_equal_function(failed, match_zero, value TSRMLS_CC);
	} else {
		ZVAL_TRUE(failed);
	}
	
	if (PHALCON_IS_TRUE(failed)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 1);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Regex" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "Regex", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_stringlength_ce;

static PHP_METHOD(Phalcon_Validation_Validator_StringLength, validate);

static const zend_function_entry phalcon_validation_validator_stringlength_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_StringLength, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_StringLength){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, StringLength, validation_validator_stringlength, phalcon_validation_validator_ce, phalcon_validation_validator_stringlength_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_stringlength_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_StringLength, validate){

	zval *validator, *attribute;
	zval *value = NULL, *length = NULL, *invalid_maximum;
	zval *invalid_minimum, *maximum, *message_str = NULL;
	zval *message, *minimum, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);

	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	PHALCON_OBS_VAR(maximum);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &maximum, getThis(), "max" TSRMLS_CC));

	PHALCON_OBS_VAR(minimum);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &minimum, getThis(), "min" TSRMLS_CC));

	/* At least one of 'min' or 'max' must be set */
	if (Z_TYPE_P(minimum) == IS_NULL && Z_TYPE_P(maximum) == IS_NULL) {
		PHALCON_THROW_EXCEPTION_STR(phalcon_validation_exception_ce, "A minimum or maximum must be set");
		return;
	}
	
	/* Check if mbstring is available to calculate the correct length */
	if (phalcon_function_quick_exists_ex(SS("mb_strlen"), 3716840971UL TSRMLS_CC) == SUCCESS) {
		PHALCON_CALL_FUNCTION(&length, "mb_strlen", value);
	} else {
		convert_to_string(value);
		PHALCON_INIT_VAR(length);
		ZVAL_LONG(length, Z_STRLEN_P(value));
	}
	
	PHALCON_INIT_VAR(invalid_maximum);
	PHALCON_INIT_VAR(invalid_minimum);
	
	PHALCON_OBS_VAR(label);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
	if (!zend_is_true(label)) {
		PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
		if (!zend_is_true(label)) {
			PHALCON_CPY_WRT(label, attribute);
		}
	}

	PHALCON_OBS_VAR(code);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
	if (Z_TYPE_P(code) == IS_NULL) {
		ZVAL_LONG(code, 0);
	}

	/* Maximum length */
	if (Z_TYPE_P(maximum) != IS_NULL) {
	
		is_smaller_function(invalid_maximum, maximum, length TSRMLS_CC);
		if (PHALCON_IS_TRUE(invalid_maximum)) {
	
			PHALCON_ALLOC_GHOST_ZVAL(pairs);
			array_init_size(pairs, 2);
			Z_ADDREF_P(label);   add_assoc_zval_ex(pairs, SS(":field"), label);
			Z_ADDREF_P(maximum); add_assoc_zval_ex(pairs, SS(":max"), maximum);

			PHALCON_OBS_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), "messageMaximum" TSRMLS_CC));
			if (!zend_is_true(message_str)) {
				PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
				RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "TooLong" TSRMLS_CC));
			}

			PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

			message = phalcon_validation_message_construct_helper(prepared, attribute, "TooLong", code TSRMLS_CC);
			Z_DELREF_P(message);
	
			PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
			RETURN_MM_FALSE;
		}
	}
	
	/* Minimum length */
	if (Z_TYPE_P(minimum) != IS_NULL) {
	
		is_smaller_function(invalid_minimum, length, minimum TSRMLS_CC);
		if (PHALCON_IS_TRUE(invalid_minimum)) {
	
			PHALCON_ALLOC_GHOST_ZVAL(pairs);
			array_init_size(pairs, 2);
			Z_ADDREF_P(label);   add_assoc_zval_ex(pairs, SS(":field"), label);
			Z_ADDREF_P(minimum); add_assoc_zval_ex(pairs, SS(":min"), minimum);

			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), "messageMinimum" TSRMLS_CC));
			if (!zend_is_true(message_str)) {
				PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
				RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "TooShort" TSRMLS_CC));
			}

			PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

			message = phalcon_validation_message_construct_helper(prepared, attribute, "TooShort", code TSRMLS_CC);
			Z_DELREF_P(message);
	
			PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
			RETURN_MM_FALSE;
		}
	}
	
	RETURN_MM_TRUE;
}







zend_class_entry *phalcon_validation_validator_url_ce;

static PHP_METHOD(Phalcon_Validation_Validator_Url, validate);

static const zend_function_entry phalcon_validation_validator_url_method_entry[] = {
	PHP_ME(Phalcon_Validation_Validator_Url, validate, arginfo_phalcon_validation_validatorinterface_validate, ZEND_ACC_PUBLIC)
	PHP_FE_END
};

PHALCON_INIT_CLASS(Phalcon_Validation_Validator_Url){

	PHALCON_REGISTER_CLASS_EX(Phalcon\\Validation\\Validator, Url, validation_validator_url, phalcon_validation_validator_ce, phalcon_validation_validator_url_method_entry, 0);

	zend_class_implements(phalcon_validation_validator_url_ce TSRMLS_CC, 1, phalcon_validation_validatorinterface_ce);

	return SUCCESS;
}

static PHP_METHOD(Phalcon_Validation_Validator_Url, validate){

	zval *validator, *attribute, *value = NULL, *validate_url;
	zval *validation = NULL, *message_str, *message, *code;
	zval *allow_empty, *label, *pairs, *prepared = NULL;
	zend_class_entry *ce = Z_OBJCE_P(getThis());

	PHALCON_MM_GROW();

	phalcon_fetch_params(1, 2, 0, &validator, &attribute);
	
	PHALCON_VERIFY_CLASS_EX(validator, phalcon_validation_ce, phalcon_validation_exception_ce, 1);

	PHALCON_CALL_METHOD(&value, validator, "getvalue", attribute);
	
	PHALCON_OBS_VAR(allow_empty);
	RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &allow_empty, getThis(), phalcon_interned_allowEmpty TSRMLS_CC));
	if (zend_is_true(allow_empty) && phalcon_validation_validator_isempty_helper(value)) {
		RETURN_MM_TRUE;
	}

	PHALCON_ALLOC_GHOST_ZVAL(validate_url);
	ZVAL_LONG(validate_url, 273);
	
	PHALCON_CALL_FUNCTION(&validation, "filter_var", value, validate_url);
	if (!zend_is_true(validation)) {
		PHALCON_OBS_VAR(label);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &label, getThis(), phalcon_interned_label TSRMLS_CC));
		if (!zend_is_true(label)) {
			PHALCON_CALL_METHOD(&label, validator, "getlabel", attribute);
			if (!zend_is_true(label)) {
				PHALCON_CPY_WRT(label, attribute);
			}
		}

		PHALCON_ALLOC_GHOST_ZVAL(pairs);
		array_init_size(pairs, 1);
		Z_ADDREF_P(label); add_assoc_zval_ex(pairs, SS(":field"), label);

		PHALCON_OBS_VAR(message_str);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &message_str, getThis(), phalcon_interned_message TSRMLS_CC));
		if (!zend_is_true(message_str)) {
			PHALCON_OBSERVE_OR_NULLIFY_VAR(message_str);
			RETURN_MM_ON_FAILURE(phalcon_validation_getdefaultmessage_helper(Z_OBJCE_P(validator), &message_str, validator, "Url" TSRMLS_CC));
		}
	
		PHALCON_OBS_VAR(code);
		RETURN_MM_ON_FAILURE(phalcon_validation_validator_getoption_helper(ce, &code, getThis(), phalcon_interned_code TSRMLS_CC));
		if (Z_TYPE_P(code) == IS_NULL) {
			ZVAL_LONG(code, 0);
		}

		PHALCON_CALL_FUNCTION(&prepared, "strtr", message_str, pairs);

		message = phalcon_validation_message_construct_helper(prepared, attribute, "Url", code TSRMLS_CC);
		Z_DELREF_P(message);
	
		PHALCON_CALL_METHOD(NULL, validator, "appendmessage", message);
		RETURN_MM_FALSE;
	}
	
	RETURN_MM_TRUE;
}





#include <main/php_ini.h>
#include <ext/standard/info.h>
#include <Zend/zend_extensions.h>

#if PHP_VERSION_ID < 50500
#include <locale.h>
#endif



int nusphere_dbg_present;

ZEND_DECLARE_MODULE_GLOBALS(phalcon)

#if PHP_VERSION_ID >= 50500
static void (*orig_execute_internal)(zend_execute_data *, zend_fcall_info *, int TSRMLS_DC) = NULL;
#else
static void (*orig_execute_internal)(zend_execute_data *, int TSRMLS_DC) = NULL;
#endif

#if PHP_VERSION_ID >= 50500

static void phalcon_execute_internal(zend_execute_data *execute_data_ptr, zend_fcall_info *fci, int return_value_used TSRMLS_DC)
{
	if (fci) {
		((zend_internal_function *) execute_data_ptr->function_state.function)->handler(fci->param_count, *fci->retval_ptr_ptr, fci->retval_ptr_ptr, fci->object_ptr, return_value_used TSRMLS_CC);
	}
	else {
		zval **return_value_ptr = EX_TMP_VAR(execute_data_ptr, execute_data_ptr->opline->result.var)->var.ptr_ptr;
		((zend_internal_function *) execute_data_ptr->function_state.function)->handler(execute_data_ptr->opline->extended_value, *return_value_ptr, return_value_ptr, execute_data_ptr->object, return_value_used TSRMLS_CC);
	}
}

#else

static void phalcon_execute_internal(zend_execute_data *execute_data_ptr, int return_value_used TSRMLS_DC)
{
#if PHP_VERSION_ID < 50400
	zval **return_value_ptr = &(*(temp_variable *)((char *) execute_data_ptr->Ts + execute_data_ptr->opline->result.u.var)).var.ptr;
#else
	zval **return_value_ptr = &(*(temp_variable *)((char *) execute_data_ptr->Ts + execute_data_ptr->opline->result.var)).var.ptr;
#endif

	((zend_internal_function *) execute_data_ptr->function_state.function)->handler(execute_data_ptr->opline->extended_value, *return_value_ptr, return_value_ptr, execute_data_ptr->object, return_value_used TSRMLS_CC);
}

#endif

#ifndef PHALCON_RELEASE

/*static void phalcon_verify_permanent_zvals(int strict TSRMLS_DC)
{
	int ok = 1;
	zend_phalcon_globals *pg = PHALCON_VGLOBAL;

	if (strict) {
		if (Z_REFCOUNT_P(pg->z_null) != 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_null)) != 2 (%u)\n", Z_REFCOUNT_P(pg->z_null));
		}

		if (Z_REFCOUNT_P(pg->z_false) != 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_false)) != 2 (%u)\n", Z_REFCOUNT_P(pg->z_false));
		}

		if (Z_REFCOUNT_P(pg->z_true) != 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_true)) != 2 (%u)\n", Z_REFCOUNT_P(pg->z_true));
		}

		if (Z_REFCOUNT_P(pg->z_zero) != 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_zero)) != 2 (%u)\n", Z_REFCOUNT_P(pg->z_zero));
		}

		if (Z_REFCOUNT_P(pg->z_one) != 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_one)) != 2 (%u)\n", Z_REFCOUNT_P(pg->z_one));
		}
	}
	else {
		if (Z_REFCOUNT_P(pg->z_null) < 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_null)) < 2 (%u)\n", Z_REFCOUNT_P(pg->z_null));
		}

		if (Z_REFCOUNT_P(pg->z_false) < 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_false)) < 2 (%u)\n", Z_REFCOUNT_P(pg->z_false));
		}

		if (Z_REFCOUNT_P(pg->z_true) < 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_true)) < 2 (%u)\n", Z_REFCOUNT_P(pg->z_true));
		}

		if (Z_REFCOUNT_P(pg->z_zero) < 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_zero)) < 2 (%u)\n", Z_REFCOUNT_P(pg->z_zero));
		}

		if (Z_REFCOUNT_P(pg->z_one) < 2) {
			ok = 0;
			fprintf(stderr, "Z_REFCOUNT_P(PHALCON_GLOBAL(z_one)) < 2 (%u)\n", Z_REFCOUNT_P(pg->z_one));
		}
	}

	if (Z_TYPE_P(pg->z_null) != IS_NULL) {
		ok = 0;
		fprintf(stderr, "Z_TYPE_P(PHALCON_GLOBAL(z_null)) != IS_NULL (%d != %d)\n", Z_TYPE_P(pg->z_null), IS_NULL);
	}

	if (Z_TYPE_P(pg->z_false) != IS_BOOL) {
		ok = 0;
		fprintf(stderr, "Z_TYPE_P(PHALCON_GLOBAL(z_false)) != IS_BOOL (%d != %d)\n", Z_TYPE_P(pg->z_false), IS_BOOL);
	}
	else if (Z_BVAL_P(pg->z_false) != 0) {
		ok = 0;
		fprintf(stderr, "Z_BVAL_P(PHALCON_GLOBAL(z_false)) != 0 (%d)\n", Z_BVAL_P(pg->z_false));
	}

	if (Z_TYPE_P(pg->z_true) != IS_BOOL) {
		ok = 0;
		fprintf(stderr, "Z_TYPE_P(PHALCON_GLOBAL(z_true)) != IS_BOOL (%d != %d)\n", Z_TYPE_P(pg->z_true), IS_BOOL);
	}
	else if (Z_BVAL_P(pg->z_true) != 1) {
		ok = 0;
		fprintf(stderr, "Z_BVAL_P(PHALCON_GLOBAL(z_true)) != 1 (%d)\n", Z_BVAL_P(pg->z_true));
	}

	if (Z_TYPE_P(pg->z_zero) != IS_LONG) {
		ok = 0;
		fprintf(stderr, "Z_TYPE_P(PHALCON_GLOBAL(z_zero)) != IS_LONG (%d != %d)\n", Z_TYPE_P(pg->z_zero), IS_LONG);
	}
	else if (Z_LVAL_P(pg->z_zero) != 0) {
		ok = 0;
		fprintf(stderr, "Z_LVAL_P(PHALCON_GLOBAL(z_zero)) != 0 (%ld)\n", Z_LVAL_P(pg->z_zero));
	}

	if (Z_TYPE_P(pg->z_one) != IS_LONG) {
		ok = 0;
		fprintf(stderr, "Z_TYPE_P(PHALCON_GLOBAL(z_one)) != IS_LONG (%d != %d)\n", Z_TYPE_P(pg->z_one), IS_LONG);
	}
	else if (Z_LVAL_P(pg->z_one) != 1) {
		ok = 0;
		fprintf(stderr, "Z_LVAL_P(PHALCON_GLOBAL(z_one)) != 1 (%ld)\n", Z_LVAL_P(pg->z_one));
	}

	if (!ok) {
		abort();
	}
}*/

#endif

PHP_INI_BEGIN()
	/* Enables/Disables globally the internal events */
	STD_PHP_INI_BOOLEAN("phalcon.orm.events",                   "1", PHP_INI_ALL,    OnUpdateBool, orm.events,                   zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables virtual foreign keys */
	STD_PHP_INI_BOOLEAN("phalcon.orm.virtual_foreign_keys",     "1", PHP_INI_ALL,    OnUpdateBool, orm.virtual_foreign_keys,     zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables column renaming */
	STD_PHP_INI_BOOLEAN("phalcon.orm.column_renaming",          "1", PHP_INI_ALL,    OnUpdateBool, orm.column_renaming,          zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables automatic NOT NULL validation */
	STD_PHP_INI_BOOLEAN("phalcon.orm.not_null_validations",     "1", PHP_INI_ALL,    OnUpdateBool, orm.not_null_validations,     zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables throwing an exception if save fails */
	STD_PHP_INI_BOOLEAN("phalcon.orm.exception_on_failed_save", "0", PHP_INI_ALL,    OnUpdateBool, orm.exception_on_failed_save, zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables literals in PHQL */
	STD_PHP_INI_BOOLEAN("phalcon.orm.enable_literals",          "1", PHP_INI_ALL,    OnUpdateBool, orm.enable_literals,          zend_phalcon_globals, phalcon_globals)
	/* Enables/Disables auttomatic escape */
	STD_PHP_INI_BOOLEAN("phalcon.db.escape_identifiers",        "1", PHP_INI_ALL,    OnUpdateBool, db.escape_identifiers,        zend_phalcon_globals, phalcon_globals)
	/* Whether to register PSR-3 classes */
	STD_PHP_INI_BOOLEAN("phalcon.register_psr3_classes",        "0", PHP_INI_SYSTEM, OnUpdateBool, register_psr3_classes,        zend_phalcon_globals, phalcon_globals)
PHP_INI_END()

static PHP_MINIT_FUNCTION(phalcon)
{
#if PHP_VERSION_ID < 50500
	char* old_lc_all = setlocale(LC_ALL, NULL);
	if (old_lc_all) {
		size_t len = strlen(old_lc_all);
		char *tmp  = calloc(len+1, 1);
		if (UNEXPECTED(!tmp)) {
			return FAILURE;
		}

		memcpy(tmp, old_lc_all, len);
		old_lc_all = tmp;
	}

	setlocale(LC_ALL, "C");
#endif

	REGISTER_INI_ENTRIES();

	nusphere_dbg_present = (zend_get_extension("DBG") != NULL);

	/* 1. Register exceptions */
	PHALCON_INIT(Phalcon_Exception);
	PHALCON_INIT(Phalcon_Acl_Exception);
	PHALCON_INIT(Phalcon_Annotations_Exception);
	PHALCON_INIT(Phalcon_Assets_Exception);
	PHALCON_INIT(Phalcon_Cache_Exception);
	PHALCON_INIT(Phalcon_Crypt_Exception);
	PHALCON_INIT(Phalcon_CLI_Console_Exception);
	PHALCON_INIT(Phalcon_CLI_Dispatcher_Exception);
	PHALCON_INIT(Phalcon_CLI_Router_Exception);
	PHALCON_INIT(Phalcon_Db_Exception);
	PHALCON_INIT(Phalcon_DI_Exception);
	PHALCON_INIT(Phalcon_Escaper_Exception);
	PHALCON_INIT(Phalcon_Events_Exception);
	PHALCON_INIT(Phalcon_Filter_Exception);
	PHALCON_INIT(Phalcon_Flash_Exception);
	PHALCON_INIT(Phalcon_Forms_Exception);
	PHALCON_INIT(Phalcon_Http_Cookie_Exception);
	PHALCON_INIT(Phalcon_Http_Request_Exception);
	PHALCON_INIT(Phalcon_Http_Response_Exception);
	PHALCON_INIT(Phalcon_Image_Exception);
	PHALCON_INIT(Phalcon_Mvc_Application_Exception);
	PHALCON_INIT(Phalcon_Mvc_Collection_Exception);
	PHALCON_INIT(Phalcon_Mvc_Dispatcher_Exception);
	PHALCON_INIT(Phalcon_Mvc_Model_Exception);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Exception);
	PHALCON_INIT(Phalcon_Mvc_Router_Exception);
	PHALCON_INIT(Phalcon_Mvc_Url_Exception);
	PHALCON_INIT(Phalcon_Mvc_View_Exception);
	PHALCON_INIT(Phalcon_Paginator_Exception);
	PHALCON_INIT(Phalcon_Tag_Exception);
	PHALCON_INIT(Phalcon_Validation_Exception);
	PHALCON_INIT(Phalcon_Security_Exception);
	PHALCON_INIT(Phalcon_Session_Exception);
	PHALCON_INIT(Phalcon_Config_Exception);
	PHALCON_INIT(Phalcon_Loader_Exception);
	PHALCON_INIT(Phalcon_Logger_Exception);
	PHALCON_INIT(Phalcon_Translate_Exception);

	/* 2. Register interfaces */
	PHALCON_INIT(Phalcon_DiInterface);
	PHALCON_INIT(Phalcon_DI_InjectionAwareInterface);
	PHALCON_INIT(Phalcon_Events_EventsAwareInterface);

	PHALCON_INIT(Phalcon_Acl_AdapterInterface);
	PHALCON_INIT(Phalcon_Acl_ResourceInterface);
	PHALCON_INIT(Phalcon_Acl_RoleInterface);
	PHALCON_INIT(Phalcon_Annotations_AdapterInterface);
	PHALCON_INIT(Phalcon_Annotations_ReaderInterface);
	PHALCON_INIT(Phalcon_Assets_FilterInterface);
	PHALCON_INIT(Phalcon_Cache_BackendInterface);
	PHALCON_INIT(Phalcon_Cache_FrontendInterface);
	PHALCON_INIT(Phalcon_CryptInterface);
	PHALCON_INIT(Phalcon_Db_AdapterInterface);
	PHALCON_INIT(Phalcon_Db_ColumnInterface);
	PHALCON_INIT(Phalcon_Db_DialectInterface);
	PHALCON_INIT(Phalcon_Db_IndexInterface);
	PHALCON_INIT(Phalcon_Db_ReferenceInterface);
	PHALCON_INIT(Phalcon_Db_ResultInterface);
	PHALCON_INIT(Phalcon_DispatcherInterface);
	PHALCON_INIT(Phalcon_DI_ServiceInterface);
	PHALCON_INIT(Phalcon_EscaperInterface);
	PHALCON_INIT(Phalcon_Events_ManagerInterface);
	PHALCON_INIT(Phalcon_FlashInterface);
	PHALCON_INIT(Phalcon_FilterInterface);
	PHALCON_INIT(Phalcon_Filter_UserFilterInterface);
	PHALCON_INIT(Phalcon_Forms_ElementInterface);
	PHALCON_INIT(Phalcon_Http_RequestInterface);
	PHALCON_INIT(Phalcon_Http_Request_FileInterface);
	PHALCON_INIT(Phalcon_Http_ResponseInterface);
	PHALCON_INIT(Phalcon_Http_Response_CookiesInterface);
	PHALCON_INIT(Phalcon_Http_Response_HeadersInterface);
	PHALCON_INIT(Phalcon_Image_AdapterInterface);
	PHALCON_INIT(Phalcon_Logger_AdapterInterface);
	PHALCON_INIT(Phalcon_Logger_FormatterInterface);
	PHALCON_INIT(Phalcon_Mvc_CollectionInterface);
	PHALCON_INIT(Phalcon_Mvc_Collection_ManagerInterface);
	PHALCON_INIT(Phalcon_Mvc_Collection_MessageInterface);
	PHALCON_INIT(Phalcon_Mvc_ControllerInterface);
	PHALCON_INIT(Phalcon_Mvc_DispatcherInterface);
	PHALCON_INIT(Phalcon_Mvc_Micro_CollectionInterface);
	PHALCON_INIT(Phalcon_Mvc_Micro_MiddlewareInterface);
	PHALCON_INIT(Phalcon_Mvc_ModelInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_BehaviorInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_CriteriaInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ManagerInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_MessageInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaDataInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_QueryInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_BuilderInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_StatusInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_RelationInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ResultInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ResultsetInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_TransactionInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_ManagerInterface);
	PHALCON_INIT(Phalcon_Mvc_Model_ValidatorInterface);
	PHALCON_INIT(Phalcon_Mvc_ModuleDefinitionInterface);
	PHALCON_INIT(Phalcon_Mvc_RouterInterface);
	PHALCON_INIT(Phalcon_Mvc_Router_RouteInterface);
	PHALCON_INIT(Phalcon_Mvc_UrlInterface);
	PHALCON_INIT(Phalcon_Mvc_ViewInterface);
	PHALCON_INIT(Phalcon_Mvc_View_EngineInterface);
	PHALCON_INIT(Phalcon_Paginator_AdapterInterface);
	PHALCON_INIT(Phalcon_Session_AdapterInterface);
	PHALCON_INIT(Phalcon_Session_BagInterface);
	PHALCON_INIT(Phalcon_Translate_AdapterInterface);
	PHALCON_INIT(Phalcon_Validation_ValidatorInterface);
	PHALCON_INIT(Phalcon_Validation_MessageInterface);

	/* 3. Register PSR-3 classes */
	if (PHALCON_GLOBAL(register_psr3_classes)) {
		PHALCON_INIT(Psr_Log_LoggerAwareInterface);
		PHALCON_INIT(Psr_Log_LoggerInterface);
		PHALCON_INIT(Psr_Log_InvalidArgumentException);
		PHALCON_INIT(Psr_Log_LogLevel);
		PHALCON_INIT(Psr_Log_AbstractLogger);
		PHALCON_INIT(Psr_Log_NullLogger);
		PHALCON_INIT(Psr_Log_LoggerAwareTrait);
		PHALCON_INIT(Psr_Log_LoggerTrait);
	}

	/* 4. Register everything else */
	PHALCON_INIT(Phalcon_Db_Adapter);
	PHALCON_INIT(Phalcon_DI_Injectable);
	PHALCON_INIT(Phalcon_DI);
	PHALCON_INIT(Phalcon_Forms_Element);
	PHALCON_INIT(Phalcon_Validation_Validator);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator);
	PHALCON_INIT(Phalcon_Cache_Backend);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo);
	PHALCON_INIT(Phalcon_Db_Dialect);
	PHALCON_INIT(Phalcon_Annotations_Adapter);
	PHALCON_INIT(Phalcon_Logger_Adapter);
	PHALCON_INIT(Phalcon_Logger_Formatter);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset);
	PHALCON_INIT(Phalcon_Mvc_Model_Behavior);
	PHALCON_INIT(Phalcon_Assets_Resource);
	PHALCON_INIT(Phalcon_Flash);
	PHALCON_INIT(Phalcon_Dispatcher);
	PHALCON_INIT(Phalcon_Mvc_View_Engine);
	PHALCON_INIT(Phalcon_Translate_Adapter);
	PHALCON_INIT(Phalcon_Cache_Frontend_Data);
	PHALCON_INIT(Phalcon_DI_FactoryDefault);
	PHALCON_INIT(Phalcon_Config);
	PHALCON_INIT(Phalcon_Mvc_Router);
	PHALCON_INIT(Phalcon_Acl_Adapter);
	PHALCON_INIT(Phalcon_Session_Adapter);
	PHALCON_INIT(Phalcon_Db);
	PHALCON_INIT(Phalcon_Acl);
	PHALCON_INIT(Phalcon_Tag);
	PHALCON_INIT(Phalcon_Cache_Multiple);
	PHALCON_INIT(Phalcon_Cache_Backend_Apc);
	PHALCON_INIT(Phalcon_Cache_Backend_File);
	PHALCON_INIT(Phalcon_Cache_Backend_Memory);
	PHALCON_INIT(Phalcon_Cache_Backend_Xcache);
	PHALCON_INIT(Phalcon_Cache_Backend_Mongo);
	PHALCON_INIT(Phalcon_Cache_Backend_Memcache);
	PHALCON_INIT(Phalcon_Cache_Backend_Libmemcached);
	PHALCON_INIT(Phalcon_Cache_Frontend_Json);
	PHALCON_INIT(Phalcon_Cache_Frontend_Output);
	PHALCON_INIT(Phalcon_Cache_Frontend_None);
	PHALCON_INIT(Phalcon_Cache_Frontend_Base64);
	PHALCON_INIT(Phalcon_Cache_Frontend_Igbinary);
	PHALCON_INIT(Phalcon_Tag_Select);
	PHALCON_INIT(Phalcon_Paginator_Adapter_Model);
	PHALCON_INIT(Phalcon_Paginator_Adapter_NativeArray);
	PHALCON_INIT(Phalcon_Paginator_Adapter_QueryBuilder);
	PHALCON_INIT(Phalcon_Validation);
	PHALCON_INIT(Phalcon_Validation_Message);
	PHALCON_INIT(Phalcon_Validation_Message_Group);
	PHALCON_INIT(Phalcon_Validation_Validator_Regex);
	PHALCON_INIT(Phalcon_Validation_Validator_Email);
	PHALCON_INIT(Phalcon_Validation_Validator_Between);
	PHALCON_INIT(Phalcon_Validation_Validator_Identical);
	PHALCON_INIT(Phalcon_Validation_Validator_PresenceOf);
	PHALCON_INIT(Phalcon_Validation_Validator_InclusionIn);
	PHALCON_INIT(Phalcon_Validation_Validator_StringLength);
	PHALCON_INIT(Phalcon_Validation_Validator_ExclusionIn);
	PHALCON_INIT(Phalcon_Validation_Validator_Confirmation);
	PHALCON_INIT(Phalcon_Validation_Validator_Url);
	PHALCON_INIT(Phalcon_Db_Index);
	PHALCON_INIT(Phalcon_Db_Column);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Sqlite);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Mysql);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Oracle);
	PHALCON_INIT(Phalcon_Db_Adapter_Pdo_Postgresql);
	PHALCON_INIT(Phalcon_Db_Dialect_Sqlite);
	PHALCON_INIT(Phalcon_Db_Dialect_Mysql);
	PHALCON_INIT(Phalcon_Db_Dialect_Oracle);
	PHALCON_INIT(Phalcon_Db_Dialect_Postgresql);
	PHALCON_INIT(Phalcon_Db_Profiler);
	PHALCON_INIT(Phalcon_Db_Profiler_Item);
	PHALCON_INIT(Phalcon_Db_RawValue);
	PHALCON_INIT(Phalcon_Db_Reference);
	PHALCON_INIT(Phalcon_Db_Result_Pdo);
	PHALCON_INIT(Phalcon_Acl_Role);
	PHALCON_INIT(Phalcon_Acl_Resource);
	PHALCON_INIT(Phalcon_Acl_Adapter_Memory);
	PHALCON_INIT(Phalcon_Kernel);
	PHALCON_INIT(Phalcon_Debug);
	PHALCON_INIT(Phalcon_Text);
	PHALCON_INIT(Phalcon_Security);
	PHALCON_INIT(Phalcon_Version);
	PHALCON_INIT(Phalcon_Session_Bag);
	PHALCON_INIT(Phalcon_Session_Adapter_Files);
	PHALCON_INIT(Phalcon_Session_Adapter_Memcache);
	PHALCON_INIT(Phalcon_Session_Adapter_Libmemcached);
	PHALCON_INIT(Phalcon_Filter);
	PHALCON_INIT(Phalcon_DI_FactoryDefault_CLI);
	PHALCON_INIT(Phalcon_DI_Service);
	PHALCON_INIT(Phalcon_DI_Service_Builder);
	PHALCON_INIT(Phalcon_Flash_Direct);
	PHALCON_INIT(Phalcon_Flash_Session);
	PHALCON_INIT(Phalcon_CLI_Task);
	PHALCON_INIT(Phalcon_CLI_Router);
	PHALCON_INIT(Phalcon_CLI_Console);
	PHALCON_INIT(Phalcon_CLI_Dispatcher);
	PHALCON_INIT(Phalcon_Annotations_Reader);
	PHALCON_INIT(Phalcon_Annotations_Annotation);
	PHALCON_INIT(Phalcon_Annotations_Adapter_Apc);
	PHALCON_INIT(Phalcon_Annotations_Collection);
	PHALCON_INIT(Phalcon_Annotations_Reflection);
	PHALCON_INIT(Phalcon_Annotations_Adapter_Xcache);
	PHALCON_INIT(Phalcon_Annotations_Adapter_Files);
	PHALCON_INIT(Phalcon_Annotations_Adapter_Memory);
	PHALCON_INIT(Phalcon_Loader);
	PHALCON_INIT(Phalcon_Logger);
	PHALCON_INIT(Phalcon_Logger_Item);
	PHALCON_INIT(Phalcon_Logger_Multiple);
	PHALCON_INIT(Phalcon_Logger_Formatter_Json);
	PHALCON_INIT(Phalcon_Logger_Formatter_Line);
	PHALCON_INIT(Phalcon_Logger_Formatter_Firephp);
	PHALCON_INIT(Phalcon_Logger_Adapter_Stream);
	PHALCON_INIT(Phalcon_Logger_Adapter_Syslog);
	PHALCON_INIT(Phalcon_Logger_Adapter_File);
	PHALCON_INIT(Phalcon_Logger_Adapter_Firephp);
	PHALCON_INIT(Phalcon_Logger_Formatter_Syslog);
	PHALCON_INIT(Phalcon_Config_Adapter_Ini);
	PHALCON_INIT(Phalcon_Config_Adapter_Json);
	PHALCON_INIT(Phalcon_Config_Adapter_Php);
	PHALCON_INIT(Phalcon_Config_Adapter_Yaml);
	PHALCON_INIT(Phalcon_Forms_Form);
	PHALCON_INIT(Phalcon_Forms_Manager);
	PHALCON_INIT(Phalcon_Forms_Element_Text);
	PHALCON_INIT(Phalcon_Forms_Element_Date);
	PHALCON_INIT(Phalcon_Forms_Element_File);
	PHALCON_INIT(Phalcon_Forms_Element_Hidden);
	PHALCON_INIT(Phalcon_Forms_Element_Select);
	PHALCON_INIT(Phalcon_Forms_Element_Check);
	PHALCON_INIT(Phalcon_Forms_Element_Numeric);
	PHALCON_INIT(Phalcon_Forms_Element_Email);
	PHALCON_INIT(Phalcon_Forms_Element_Submit);
	PHALCON_INIT(Phalcon_Forms_Element_Password);
	PHALCON_INIT(Phalcon_Forms_Element_TextArea);
	PHALCON_INIT(Phalcon_Forms_Element_Radio);
	PHALCON_INIT(Phalcon_Crypt);
	PHALCON_INIT(Phalcon_Translate_Adapter_NativeArray);
	PHALCON_INIT(Phalcon_Translate_Adapter_Gettext);
	PHALCON_INIT(Phalcon_Escaper);
	PHALCON_INIT(Phalcon_Assets_Manager);
	PHALCON_INIT(Phalcon_Assets_Resource_Js);
	PHALCON_INIT(Phalcon_Assets_Collection);
	PHALCON_INIT(Phalcon_Assets_Filters_None);
	PHALCON_INIT(Phalcon_Assets_Filters_Cssmin);
	PHALCON_INIT(Phalcon_Assets_Filters_Jsmin);
	PHALCON_INIT(Phalcon_Assets_Resource_Css);
	PHALCON_INIT(Phalcon_Http_Request);
	PHALCON_INIT(Phalcon_Http_Cookie);
	PHALCON_INIT(Phalcon_Http_Response);
	PHALCON_INIT(Phalcon_Http_Request_File);
	PHALCON_INIT(Phalcon_Http_Response_Cookies);
	PHALCON_INIT(Phalcon_Http_Response_Headers);
	PHALCON_INIT(Phalcon_Queue_Beanstalk);
	PHALCON_INIT(Phalcon_Queue_Beanstalk_Job);
	PHALCON_INIT(Phalcon_Mvc_View);
	PHALCON_INIT(Phalcon_Mvc_Url);
	PHALCON_INIT(Phalcon_Mvc_Model);
	PHALCON_INIT(Phalcon_Mvc_Micro);
	PHALCON_INIT(Phalcon_Mvc_Application);
	PHALCON_INIT(Phalcon_Mvc_Collection);
	PHALCON_INIT(Phalcon_Mvc_Controller);
	PHALCON_INIT(Phalcon_Mvc_Collection_Document);
	PHALCON_INIT(Phalcon_Mvc_Collection_Manager);
	PHALCON_INIT(Phalcon_Mvc_Collection_Message);
	PHALCON_INIT(Phalcon_Mvc_Dispatcher);
	PHALCON_INIT(Phalcon_Mvc_Model_Row);
	PHALCON_INIT(Phalcon_Mvc_Model_Query);
	PHALCON_INIT(Phalcon_Mvc_Micro_Collection);
	PHALCON_INIT(Phalcon_Mvc_Micro_Exception);
	PHALCON_INIT(Phalcon_Mvc_Micro_LazyLoader);
	PHALCON_INIT(Phalcon_Mvc_Model_Criteria);
	PHALCON_INIT(Phalcon_Mvc_Model_Manager);
	PHALCON_INIT(Phalcon_Mvc_Model_Message);
	PHALCON_INIT(Phalcon_Mvc_Model_Relation);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_Lang);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Url);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_Status);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Apc);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Files);
	PHALCON_INIT(Phalcon_Mvc_Model_Query_Builder);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Regex);
	PHALCON_INIT(Phalcon_Mvc_Model_ValidationFailed);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset_Simple);
	PHALCON_INIT(Phalcon_Mvc_Model_Resultset_Complex);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Memory);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Xcache);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Email);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Session);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Uniqueness);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_PresenceOf);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Failed);
	PHALCON_INIT(Phalcon_Mvc_Model_Behavior_SoftDelete);
	PHALCON_INIT(Phalcon_Mvc_Model_Transaction_Manager);
	PHALCON_INIT(Phalcon_Mvc_Model_Behavior_Timestampable);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Strategy_Annotations);
	PHALCON_INIT(Phalcon_Mvc_Model_MetaData_Strategy_Introspection);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Inclusionin);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Numericality);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_Exclusionin);
	PHALCON_INIT(Phalcon_Mvc_Model_Validator_StringLength);
	PHALCON_INIT(Phalcon_Mvc_Router_Route);
	PHALCON_INIT(Phalcon_Mvc_Router_Group);
	PHALCON_INIT(Phalcon_Mvc_Router_Annotations);
	PHALCON_INIT(Phalcon_Mvc_User_Module);
	PHALCON_INIT(Phalcon_Mvc_User_Plugin);
	PHALCON_INIT(Phalcon_Mvc_User_Component);
	PHALCON_INIT(Phalcon_Mvc_View_Simple);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Volt);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Php);
	PHALCON_INIT(Phalcon_Mvc_View_Engine_Volt_Compiler);
	PHALCON_INIT(Phalcon_Events_Event);
	PHALCON_INIT(Phalcon_Events_Manager);
	PHALCON_INIT(Phalcon_Image);
	PHALCON_INIT(Phalcon_Image_Adapter);
	PHALCON_INIT(Phalcon_Image_Adapter_GD);
	PHALCON_INIT(Phalcon_Image_Adapter_Imagick);
	PHALCON_INIT(Phalcon_Registry);

#if PHP_VERSION_ID < 50500
	setlocale(LC_ALL, old_lc_all);
	free(old_lc_all);
#endif

	orig_execute_internal = zend_execute_internal;
	if (!zend_execute_internal && !getenv("PHALCON_NO_RVO")) {
		zend_execute_internal = phalcon_execute_internal;
	}

#if 0
	{
		zend_module_entry *entry;
		if (zend_hash_find(&module_registry, ZEND_STRS("mbstring"), (void**)&entry) == SUCCESS) {
#ifdef ZTS
			mbstring_globals_id = *(entry->globals_id_ptr);
#else
			mbstring_globals    = ((zend_mbstring_globals*)(entry->globals_ptr));
#endif
		}
	}
#endif

	return SUCCESS;
}

static PHP_MSHUTDOWN_FUNCTION(phalcon){

	phalcon_deinitialize_memory(TSRMLS_C);

	assert(PHALCON_GLOBAL(orm).parser_cache == NULL);
	assert(PHALCON_GLOBAL(orm).ast_cache == NULL);

	UNREGISTER_INI_ENTRIES();

	zend_execute_internal = orig_execute_internal;
	return SUCCESS;
}

static PHP_RINIT_FUNCTION(phalcon){

	zend_phalcon_globals *phalcon_globals_ptr = PHALCON_VGLOBAL;

	php_phalcon_init_globals(phalcon_globals_ptr TSRMLS_CC);
	phalcon_init_interned_strings(TSRMLS_C);

	phalcon_initialize_memory(phalcon_globals_ptr TSRMLS_CC);

	return SUCCESS;
}

static PHP_RSHUTDOWN_FUNCTION(phalcon){
	phalcon_deinitialize_memory(TSRMLS_C);
	return SUCCESS;
}

static PHP_MINFO_FUNCTION(phalcon)
{
	php_info_print_table_start();
	php_info_print_table_row(2, "Phalcon Framework", "enabled");
	php_info_print_table_row(2, "Phalcon Version", PHP_PHALCON_VERSION);
	php_info_print_table_end();

	DISPLAY_INI_ENTRIES();
}

static PHP_GINIT_FUNCTION(phalcon)
{
	php_phalcon_init_globals(phalcon_globals TSRMLS_CC);
}

static PHP_GSHUTDOWN_FUNCTION(phalcon)
{
	phalcon_deinitialize_memory(TSRMLS_C);
}


static
#if ZEND_MODULE_API_NO > 20060613
const
#endif
zend_module_dep phalcon_deps[] = {
	ZEND_MOD_REQUIRED("spl")
	ZEND_MOD_REQUIRED("date")
#if PHALCON_USE_PHP_JSON
	ZEND_MOD_REQUIRED("json")
#else
	ZEND_MOD_OPTIONAL("json")
#endif
#if PHALCON_USE_PHP_SESSION
	ZEND_MOD_REQUIRED("session")
#else
	ZEND_MOD_OPTIONAL("session")
#endif
#if PHALCON_USE_PHP_PCRE
	ZEND_MOD_REQUIRED("pcre")
#else
	ZEND_MOD_OPTIONAL("pcre")
#endif
#if PHALCON_USE_PHP_HASH
	ZEND_MOD_REQUIRED("hash")
#else
	ZEND_MOD_OPTIONAL("hash")
#endif
	ZEND_MOD_OPTIONAL("apc")
	ZEND_MOD_OPTIONAL("apcu")
	ZEND_MOD_OPTIONAL("XCache")
	ZEND_MOD_OPTIONAL("memcache")
	ZEND_MOD_OPTIONAL("memcached")
	ZEND_MOD_OPTIONAL("mongo")
	ZEND_MOD_OPTIONAL("filter")
	ZEND_MOD_OPTIONAL("iconv")
	ZEND_MOD_OPTIONAL("libxml")
	ZEND_MOD_OPTIONAL("mbstring")
	ZEND_MOD_OPTIONAL("mcrypt")
	ZEND_MOD_OPTIONAL("openssl")
	ZEND_MOD_OPTIONAL("pdo")
	ZEND_MOD_OPTIONAL("gd")
	ZEND_MOD_OPTIONAL("imagick")
	ZEND_MOD_END
};

zend_module_entry phalcon_module_entry = {
	STANDARD_MODULE_HEADER_EX,
	ini_entries,
	phalcon_deps,
	PHP_PHALCON_EXTNAME,
	NULL,
	PHP_MINIT(phalcon),
	PHP_MSHUTDOWN(phalcon),
	PHP_RINIT(phalcon),
	PHP_RSHUTDOWN(phalcon),
	PHP_MINFO(phalcon),
	PHP_PHALCON_VERSION,
	ZEND_MODULE_GLOBALS(phalcon),
	PHP_GINIT(phalcon),
	PHP_GSHUTDOWN(phalcon),
	NULL, /* ZEND_MODULE_POST_ZEND_DEACTIVATE_N(phalcon), */
	STANDARD_MODULE_PROPERTIES_EX
};

#ifdef COMPILE_DL_PHALCON
ZEND_GET_MODULE(phalcon)
#endif


